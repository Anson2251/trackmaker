var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a2;
import { G as Cp, H as gC, I as vC, J as yC, d as ot, c as $t, o as lt, a as mt, L as Il, j as De, b as Me, f as Ci, i as hr, M as Qc, q as Kt, k as Tn, p as Zr, h as L, m as qs, N as _C, O as Yb, t as Ot, P as Gs, B as Ro, Q as Vi, F as qr, w as zo, R as fs, S as bC, U as Vg, V as _i, W as xC, T as Kb, x as Pr, X as wC, Y as S_, Z as Ws, g as CC, $ as Zs, u as Pa, v as Y, a0 as Zc, n as Wo, A as Qt, _ as jn, a1 as js, a2 as SC, a3 as kC, a4 as $n, a5 as Fr, a6 as yv, a7 as cm, C as gr, y as $e, s as Re, z as Cr, D as eu, a8 as PC, a9 as Dp, aa as ti, ab as Id, ac as TC, ad as Jb, ae as MC, E as IC, l as Qb, af as EC, ag as RC, ah as cs, ai as zC, aj as Ac, ak as Dc } from "./index-CEdaJHVQ.js";
import { u as Ri } from "./vue-i18n-CXGylK1r.js";
import { bo as AC, bp as ex, bq as DC, a_ as vn, b1 as xl, br as tx, bs as wd, bt as rx, bu as ei, bv as Ni, bw as Fp, bx as um, aS as nx, a3 as de, a6 as Ue, ab as Ir, by as tu, a$ as Ed, bz as ms, a2 as Ge, a5 as Ae, a7 as Rd, a8 as Lp, bA as Ui, ai as Ur, ae as tr, A as FC, af as qt, ag as hn, a9 as _l, bB as _v, aY as pn, bC as Bp, bD as dn, ah as Op, bE as jd, ad as zi, bF as LC, bG as BC, bH as Eo, bI as wl, bJ as OC, aa as $p, bK as $C, bL as k_, b7 as Gt, Q as Ai, bM as jC, b5 as P_, bg as bv, bN as NC, a4 as Sp, ao as jp, bO as VC, ak as xv, al as Np, an as wv, am as Cv, bP as ix, S as Ug, bQ as UC, bR as qg, bS as qC, bT as GC, b3 as wi, bU as gs, bV as Ei, bW as Xi, bX as Vp, bY as WC, bZ as ox, b_ as sx, b$ as ZC, _ as Tl, c0 as HC, c1 as XC, c2 as YC, c3 as KC, c4 as vs, c5 as Cl, c6 as xa, c7 as mp, c8 as Vs, c9 as _a, ca as wa, cb as Gc, cc as Sl, cd as ax, ce as Gg, r as ds, cf as Wg, cg as Zg, ch as Cd, ci as Hg, cj as Xg, ck as Yg, cl as kp, cm as lx, cn as cx, co as ux, cp as Hc, cq as Pp, cr as JC, cs as Up, ct as dx, be as jr, cu as QC, b4 as Tp, b2 as eS, cv as tS, cw as kl, cx as rS, aZ as hx, cy as px, cz as nS, $ as iS, ap as oS, cA as sS, cB as aS, cC as Sv, cD as lS, cE as cS, cF as uS, cG as dS, c as Nd, cH as Mp, cI as fx, cJ as mx, cK as hS, cL as qo, cM as pS, cN as fS, cO as mS, cP as gx, cQ as gS, cR as vS, cS as vx, cT as yx, cU as yS, cV as _S, cW as bS, cX as T_, cY as xS, W as _x, cZ as wS, c_ as CS, c$ as SS, d0 as kS, d1 as PS, d2 as TS, d3 as dm, d4 as MS, d5 as IS, d6 as bx, d7 as M_, d8 as ES, aU as I_, d9 as xx, da as mo, db as go, bf as xn, T as zd, b0 as wx, bb as ru, ba as RS, bk as kv, bm as Sd, bn as Cx, bd as $s, bl as zS, dc as vo, bi as AS, bc as Sx, dd as DS, de as FS, df as LS } from "./platform-B3IUivCK.js";
var BS = /\s/;
function OS(a) {
  for (var i = a.length; i-- && BS.test(a.charAt(i)); ) ;
  return i;
}
var $S = /^\s+/;
function jS(a) {
  return a && a.slice(0, OS(a) + 1).replace($S, "");
}
var E_ = NaN, NS = /^[-+]0x[0-9a-f]+$/i, VS = /^0b[01]+$/i, US = /^0o[0-7]+$/i, qS = parseInt;
function kd(a) {
  if (typeof a == "number") return a;
  if (AC(a)) return E_;
  if (Cp(a)) {
    var i = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = Cp(i) ? i + "" : i;
  }
  if (typeof a != "string") return a === 0 ? a : +a;
  a = jS(a);
  var l = VS.test(a);
  return l || US.test(a) ? qS(a.slice(2), l ? 2 : 8) : NS.test(a) ? E_ : +a;
}
function GS(a, i, l, d) {
  for (var h = -1, g = a == null ? 0 : a.length; ++h < g; ) l = i(l, a[h], h, a);
  return l;
}
function WS(a) {
  return function(i) {
    return a == null ? void 0 : a[i];
  };
}
var ZS = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, HS = WS(ZS), XS = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, YS = "\\u0300-\\u036f", KS = "\\ufe20-\\ufe2f", JS = "\\u20d0-\\u20ff", QS = YS + KS + JS, ek = "[" + QS + "]", tk = RegExp(ek, "g");
function rk(a) {
  return a = ex(a), a && a.replace(XS, HS).replace(tk, "");
}
var nk = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function ik(a) {
  return a.match(nk) || [];
}
var ok = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function sk(a) {
  return ok.test(a);
}
var kx = "\\ud800-\\udfff", ak = "\\u0300-\\u036f", lk = "\\ufe20-\\ufe2f", ck = "\\u20d0-\\u20ff", uk = ak + lk + ck, Px = "\\u2700-\\u27bf", Tx = "a-z\\xdf-\\xf6\\xf8-\\xff", dk = "\\xac\\xb1\\xd7\\xf7", hk = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", pk = "\\u2000-\\u206f", fk = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Mx = "A-Z\\xc0-\\xd6\\xd8-\\xde", mk = "\\ufe0e\\ufe0f", Ix = dk + hk + pk + fk, Ex = "['\u2019]", R_ = "[" + Ix + "]", gk = "[" + uk + "]", Rx = "\\d+", vk = "[" + Px + "]", zx = "[" + Tx + "]", Ax = "[^" + kx + Ix + Rx + Px + Tx + Mx + "]", yk = "\\ud83c[\\udffb-\\udfff]", _k = "(?:" + gk + "|" + yk + ")", bk = "[^" + kx + "]", Dx = "(?:\\ud83c[\\udde6-\\uddff]){2}", Fx = "[\\ud800-\\udbff][\\udc00-\\udfff]", Uc = "[" + Mx + "]", xk = "\\u200d", z_ = "(?:" + zx + "|" + Ax + ")", wk = "(?:" + Uc + "|" + Ax + ")", A_ = "(?:" + Ex + "(?:d|ll|m|re|s|t|ve))?", D_ = "(?:" + Ex + "(?:D|LL|M|RE|S|T|VE))?", Lx = _k + "?", Bx = "[" + mk + "]?", Ck = "(?:" + xk + "(?:" + [bk, Dx, Fx].join("|") + ")" + Bx + Lx + ")*", Sk = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", kk = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Pk = Bx + Lx + Ck, Tk = "(?:" + [vk, Dx, Fx].join("|") + ")" + Pk, Mk = RegExp([Uc + "?" + zx + "+" + A_ + "(?=" + [R_, Uc, "$"].join("|") + ")", wk + "+" + D_ + "(?=" + [R_, Uc + z_, "$"].join("|") + ")", Uc + "?" + z_ + "+" + A_, Uc + "+" + D_, kk, Sk, Rx, Tk].join("|"), "g");
function Ik(a) {
  return a.match(Mk) || [];
}
function Ek(a, i, l) {
  return a = ex(a), i = i, i === void 0 ? sk(a) ? Ik(a) : ik(a) : a.match(i) || [];
}
var Rk = "['\u2019]", zk = RegExp(Rk, "g");
function Ak(a) {
  return function(i) {
    return GS(Ek(rk(i).replace(zk, "")), a, "");
  };
}
function Dk(a, i, l) {
  return a === a && (l !== void 0 && (a = a <= l ? a : l), i !== void 0 && (a = a >= i ? a : i)), a;
}
function Kg(a, i, l) {
  return l === void 0 && (l = i, i = void 0), l !== void 0 && (l = kd(l), l = l === l ? l : 0), i !== void 0 && (i = kd(i), i = i === i ? i : 0), Dk(kd(a), i, l);
}
var hm = function() {
  return gC.Date.now();
}, Fk = "Expected a function", Lk = Math.max, Bk = Math.min;
function Ok(a, i, l) {
  var d, h, g, p, o, w, S = 0, k = false, I = false, z = true;
  if (typeof a != "function") throw new TypeError(Fk);
  i = kd(i) || 0, Cp(l) && (k = !!l.leading, I = "maxWait" in l, g = I ? Lk(kd(l.maxWait) || 0, i) : g, z = "trailing" in l ? !!l.trailing : z);
  function R(q) {
    var he = d, se = h;
    return d = h = void 0, S = q, p = a.apply(se, he), p;
  }
  function O(q) {
    return S = q, o = setTimeout(N, i), k ? R(q) : p;
  }
  function V(q) {
    var he = q - w, se = q - S, Q = i - he;
    return I ? Bk(Q, g - se) : Q;
  }
  function W(q) {
    var he = q - w, se = q - S;
    return w === void 0 || he >= i || he < 0 || I && se >= g;
  }
  function N() {
    var q = hm();
    if (W(q)) return K(q);
    o = setTimeout(N, V(q));
  }
  function K(q) {
    return o = void 0, z && d ? R(q) : (d = h = void 0, p);
  }
  function Z() {
    o !== void 0 && clearTimeout(o), S = 0, d = w = h = o = void 0;
  }
  function X() {
    return o === void 0 ? p : K(hm());
  }
  function te() {
    var q = hm(), he = W(q);
    if (d = arguments, h = this, w = q, he) {
      if (o === void 0) return O(w);
      if (I) return clearTimeout(o), o = setTimeout(N, i), R(w);
    }
    return o === void 0 && (o = setTimeout(N, i)), p;
  }
  return te.cancel = Z, te.flush = X, te;
}
var $k = "[object Number]";
function jk(a) {
  return typeof a == "number" || vC(a) && yC(a) == $k;
}
var Nk = Ak(function(a, i, l) {
  return a + (l ? "-" : "") + i.toLowerCase();
}), Vk = "Expected a function";
function gp(a, i, l) {
  var d = true, h = true;
  if (typeof a != "function") throw new TypeError(Vk);
  return Cp(l) && (d = "leading" in l ? !!l.leading : d, h = "trailing" in l ? !!l.trailing : h), Ok(a, i, { leading: d, maxWait: i, trailing: h });
}
const Uk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, qk = ot({ name: "BrandGithub", render: function(i, l) {
  return lt(), $t("svg", Uk, l[0] || (l[0] = [mt("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Gk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Wk = ot({ name: "BuildingCommunity", render: function(i, l) {
  return lt(), $t("svg", Gk, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 9l5 5v7H8v-4m0 4H3v-7l5-5m1 1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v17h-8"></path><path d="M13 7v.01"></path><path d="M17 7v.01"></path><path d="M17 11v.01"></path><path d="M17 15v.01"></path></g>', 1)]));
} }), Zk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Hk = ot({ name: "Calendar", render: function(i, l) {
  return lt(), $t("svg", Zk, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), Xk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Yk = ot({ name: "CurrentLocation", render: function(i, l) {
  return lt(), $t("svg", Xk, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><circle cx="12" cy="12" r="8"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M20 12h2"></path><path d="M2 12h2"></path></g>', 1)]));
} }), Kk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Jk = ot({ name: "DeviceFloppy", render: function(i, l) {
  return lt(), $t("svg", Kk, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), mt("circle", { cx: "12", cy: "14", r: "2" }), mt("path", { d: "M14 4v4H8V4" })], -1)]));
} }), Qk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, eP = ot({ name: "Edit", render: function(i, l) {
  return lt(), $t("svg", Qk, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), mt("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), mt("path", { d: "M16 5l3 3" })], -1)]));
} }), tP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ox = ot({ name: "FileText", render: function(i, l) {
  return lt(), $t("svg", tP, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), rP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, nP = ot({ name: "Folder", render: function(i, l) {
  return lt(), $t("svg", rP, l[0] || (l[0] = [mt("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), iP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, $x = ot({ name: "HandFinger", render: function(i, l) {
  return lt(), $t("svg", iP, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), oP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, jx = ot({ name: "Line", render: function(i, l) {
  return lt(), $t("svg", oP, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("circle", { cx: "6", cy: "18", r: "2" }), mt("circle", { cx: "18", cy: "6", r: "2" }), mt("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), sP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, F_ = ot({ name: "Link", render: function(i, l) {
  return lt(), $t("svg", sP, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), mt("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), aP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, lP = ot({ name: "Minus", render: function(i, l) {
  return lt(), $t("svg", aP, l[0] || (l[0] = [mt("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), cP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, uP = ot({ name: "PlayerRecord", render: function(i, l) {
  return lt(), $t("svg", cP, l[0] || (l[0] = [mt("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), dP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ad = ot({ name: "Plus", render: function(i, l) {
  return lt(), $t("svg", dP, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("path", { d: "M12 5v14" }), mt("path", { d: "M5 12h14" })], -1)]));
} }), hP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Pv = ot({ name: "Route", render: function(i, l) {
  return lt(), $t("svg", hP, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("circle", { cx: "6", cy: "19", r: "2" }), mt("circle", { cx: "18", cy: "5", r: "2" }), mt("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), pP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Nx = ot({ name: "Shape", render: function(i, l) {
  return lt(), $t("svg", pP, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), fP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, mP = ot({ name: "Square", render: function(i, l) {
  return lt(), $t("svg", fP, l[0] || (l[0] = [mt("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), gP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, qp = ot({ name: "Trash", render: function(i, l) {
  return lt(), $t("svg", gP, l[0] || (l[0] = [Il('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), vP = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Vx = ot({ name: "Upload", render: function(i, l) {
  return lt(), $t("svg", vP, l[0] || (l[0] = [mt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [mt("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), mt("path", { d: "M7 9l5-5l5 5" }), mt("path", { d: "M12 4v12" })], -1)]));
} });
function Ux(a) {
  return typeof a == "string" ? document.querySelector(a) : typeof a == "function" ? a() : a;
}
function yP(a) {
  if (typeof a == "number") return { "": a.toString() };
  const i = {};
  return a.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [d, h] = l.split(":");
    h === void 0 ? i[""] = d : i[d] = h;
  }), i;
}
function Fc(a, i) {
  var l;
  if (a == null) return;
  const d = yP(a);
  if (i === void 0) return d[""];
  if (typeof i == "string") return (l = d[i]) !== null && l !== void 0 ? l : d[""];
  if (Array.isArray(i)) {
    for (let h = i.length - 1; h >= 0; --h) {
      const g = i[h];
      if (g in d) return d[g];
    }
    return d[""];
  } else {
    let h, g = -1;
    return Object.keys(d).forEach((p) => {
      const o = Number(p);
      !Number.isNaN(o) && i >= o && o >= g && (g = o, h = d[p]);
    }), h;
  }
}
const _P = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function bP(a) {
  return `(min-width: ${a}px)`;
}
const dd = {};
function xP(a = _P) {
  if (!DC) return De(() => []);
  if (typeof window.matchMedia != "function") return De(() => []);
  const i = Me({}), l = Object.keys(a), d = (h, g) => {
    h.matches ? i.value[g] = true : i.value[g] = false;
  };
  return l.forEach((h) => {
    const g = a[h];
    let p, o;
    dd[g] === void 0 ? (p = window.matchMedia(bP(g)), p.addEventListener ? p.addEventListener("change", (w) => {
      o.forEach((S) => {
        S(w, h);
      });
    }) : p.addListener && p.addListener((w) => {
      o.forEach((S) => {
        S(w, h);
      });
    }), o = /* @__PURE__ */ new Set(), dd[g] = { mql: p, cbs: o }) : (p = dd[g].mql, o = dd[g].cbs), o.add(d), p.matches && o.forEach((w) => {
      w(p, h);
    });
  }), Ci(() => {
    l.forEach((h) => {
      const { cbs: g } = dd[a[h]];
      g.has(d) && g.delete(d);
    });
  }), De(() => {
    const { value: h } = i;
    return l.filter((g) => h[g]);
  });
}
function wP(a, i, l) {
  var d;
  const h = hr(a, null);
  if (h === null) return;
  const g = (d = Qc()) === null || d === void 0 ? void 0 : d.proxy;
  Kt(l, p), p(l.value), Ci(() => {
    p(void 0, l.value);
  });
  function p(S, k) {
    if (!h) return;
    const I = h[i];
    k !== void 0 && o(I, k), S !== void 0 && w(I, S);
  }
  function o(S, k) {
    S[k] || (S[k] = []), S[k].splice(S[k].findIndex((I) => I === g), 1);
  }
  function w(S, k) {
    S[k] || (S[k] = []), ~S[k].findIndex((I) => I === g) || S[k].push(g);
  }
}
function CP(a, i, l) {
  const d = hr(a, null);
  d !== null && (i in d || (d[i] = []), d[i].push(l.value), Kt(l, (h, g) => {
    const p = d[i], o = p.findIndex((w) => w === g);
    ~o && p.splice(o, 1), p.push(h);
  }), Ci(() => {
    const h = d[i], g = h.findIndex((p) => p === l.value);
    ~g && h.splice(g, 1);
  }));
}
function SP(a, i, l) {
  const d = hr(a, null);
  d !== null && (i in d || (d[i] = []), Tn(() => {
    const h = l();
    h && d[i].push(h);
  }), Ci(() => {
    const h = d[i], g = l(), p = h.findIndex((o) => o === g);
    ~p && h.splice(p, 1);
  }));
}
function L_(a) {
  return a & -a;
}
class qx {
  constructor(i, l) {
    this.l = i, this.min = l;
    const d = new Array(i + 1);
    for (let h = 0; h < i + 1; ++h) d[h] = 0;
    this.ft = d;
  }
  add(i, l) {
    if (l === 0) return;
    const { l: d, ft: h } = this;
    for (i += 1; i <= d; ) h[i] += l, i += L_(i);
  }
  get(i) {
    return this.sum(i + 1) - this.sum(i);
  }
  sum(i) {
    if (i === void 0 && (i = this.l), i <= 0) return 0;
    const { ft: l, min: d, l: h } = this;
    if (i > h) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let g = i * d;
    for (; i > 0; ) g += l[i], i -= L_(i);
    return g;
  }
  getBound(i) {
    let l = 0, d = this.l;
    for (; d > l; ) {
      const h = Math.floor((l + d) / 2), g = this.sum(h);
      if (g > i) {
        d = h;
        continue;
      } else if (g < i) {
        if (l === h) return this.sum(l + 1) <= i ? l + 1 : h;
        l = h;
      } else return h;
    }
    return l;
  }
}
let Qh;
function kP() {
  return typeof document > "u" ? false : (Qh === void 0 && ("matchMedia" in window ? Qh = window.matchMedia("(pointer:coarse)").matches : Qh = false), Qh);
}
let pm;
function B_() {
  return typeof document > "u" ? 1 : (pm === void 0 && (pm = "chrome" in window ? window.devicePixelRatio : 1), pm);
}
const Gx = "VVirtualListXScroll";
function PP({ columnsRef: a, renderColRef: i, renderItemWithColsRef: l }) {
  const d = Me(0), h = Me(0), g = De(() => {
    const S = a.value;
    if (S.length === 0) return null;
    const k = new qx(S.length, 0);
    return S.forEach((I, z) => {
      k.add(z, I.width);
    }), k;
  }), p = vn(() => {
    const S = g.value;
    return S !== null ? Math.max(S.getBound(h.value) - 1, 0) : 0;
  }), o = (S) => {
    const k = g.value;
    return k !== null ? k.sum(S) : 0;
  }, w = vn(() => {
    const S = g.value;
    return S !== null ? Math.min(S.getBound(h.value + d.value) + 1, a.value.length - 1) : 0;
  });
  return Zr(Gx, { startIndexRef: p, endIndexRef: w, columnsRef: a, renderColRef: i, renderItemWithColsRef: l, getLeft: o }), { listWidthRef: d, scrollLeftRef: h };
}
const O_ = ot({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: a, endIndexRef: i, columnsRef: l, getLeft: d, renderColRef: h, renderItemWithColsRef: g } = hr(Gx);
  return { startIndex: a, endIndex: i, columns: l, renderCol: h, renderItemWithCols: g, getLeft: d };
}, render() {
  const { startIndex: a, endIndex: i, columns: l, renderCol: d, renderItemWithCols: h, getLeft: g, item: p } = this;
  if (h != null) return h({ itemIndex: this.index, startColIndex: a, endColIndex: i, allColumns: l, item: p, getLeft: g });
  if (d != null) {
    const o = [];
    for (let w = a; w <= i; ++w) {
      const S = l[w];
      o.push(d({ column: S, left: g(w), item: p }));
    }
    return o;
  }
  return null;
} }), TP = wd(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [wd("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [wd("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), MP = ot({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(a) {
  const i = tx();
  TP.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: rx, ssr: i }), Tn(() => {
    const { defaultScrollIndex: Ne, defaultScrollKey: Pe } = a;
    Ne != null ? W({ index: Ne }) : Pe != null && W({ key: Pe });
  });
  let l = false, d = false;
  _C(() => {
    if (l = false, !d) {
      d = true;
      return;
    }
    W({ top: R.value, left: p.value });
  }), Yb(() => {
    l = true, d || (d = true);
  });
  const h = vn(() => {
    if (a.renderCol == null && a.renderItemWithCols == null || a.columns.length === 0) return;
    let Ne = 0;
    return a.columns.forEach((Pe) => {
      Ne += Pe.width;
    }), Ne;
  }), g = De(() => {
    const Ne = /* @__PURE__ */ new Map(), { keyField: Pe } = a;
    return a.items.forEach((tt, at) => {
      Ne.set(tt[Pe], at);
    }), Ne;
  }), { scrollLeftRef: p, listWidthRef: o } = PP({ columnsRef: Ot(a, "columns"), renderColRef: Ot(a, "renderCol"), renderItemWithColsRef: Ot(a, "renderItemWithCols") }), w = Me(null), S = Me(void 0), k = /* @__PURE__ */ new Map(), I = De(() => {
    const { items: Ne, itemSize: Pe, keyField: tt } = a, at = new qx(Ne.length, Pe);
    return Ne.forEach((xt, ht) => {
      const Ye = xt[tt], Ke = k.get(Ye);
      Ke !== void 0 && at.add(ht, Ke);
    }), at;
  }), z = Me(0), R = Me(0), O = vn(() => Math.max(I.value.getBound(R.value - ei(a.paddingTop)) - 1, 0)), V = De(() => {
    const { value: Ne } = S;
    if (Ne === void 0) return [];
    const { items: Pe, itemSize: tt } = a, at = O.value, xt = Math.min(at + Math.ceil(Ne / tt + 1), Pe.length - 1), ht = [];
    for (let Ye = at; Ye <= xt; ++Ye) ht.push(Pe[Ye]);
    return ht;
  }), W = (Ne, Pe) => {
    if (typeof Ne == "number") {
      X(Ne, Pe, "auto");
      return;
    }
    const { left: tt, top: at, index: xt, key: ht, position: Ye, behavior: Ke, debounce: Lt = true } = Ne;
    if (tt !== void 0 || at !== void 0) X(tt, at, Ke);
    else if (xt !== void 0) Z(xt, Ke, Lt);
    else if (ht !== void 0) {
      const ct = g.value.get(ht);
      ct !== void 0 && Z(ct, Ke, Lt);
    } else Ye === "bottom" ? X(0, Number.MAX_SAFE_INTEGER, Ke) : Ye === "top" && X(0, 0, Ke);
  };
  let N, K = null;
  function Z(Ne, Pe, tt) {
    const { value: at } = I, xt = at.sum(Ne) + ei(a.paddingTop);
    if (!tt) w.value.scrollTo({ left: 0, top: xt, behavior: Pe });
    else {
      N = Ne, K !== null && window.clearTimeout(K), K = window.setTimeout(() => {
        N = void 0, K = null;
      }, 16);
      const { scrollTop: ht, offsetHeight: Ye } = w.value;
      if (xt > ht) {
        const Ke = at.get(Ne);
        xt + Ke <= ht + Ye || w.value.scrollTo({ left: 0, top: xt + Ke - Ye, behavior: Pe });
      } else w.value.scrollTo({ left: 0, top: xt, behavior: Pe });
    }
  }
  function X(Ne, Pe, tt) {
    w.value.scrollTo({ left: Ne, top: Pe, behavior: tt });
  }
  function te(Ne, Pe) {
    var tt, at, xt;
    if (l || a.ignoreItemResize || Be(Pe.target)) return;
    const { value: ht } = I, Ye = g.value.get(Ne), Ke = ht.get(Ye), Lt = (xt = (at = (tt = Pe.borderBoxSize) === null || tt === void 0 ? void 0 : tt[0]) === null || at === void 0 ? void 0 : at.blockSize) !== null && xt !== void 0 ? xt : Pe.contentRect.height;
    if (Lt === Ke) return;
    Lt - a.itemSize === 0 ? k.delete(Ne) : k.set(Ne, Lt - a.itemSize);
    const bt = Lt - Ke;
    if (bt === 0) return;
    ht.add(Ye, bt);
    const Nt = w.value;
    if (Nt != null) {
      if (N === void 0) {
        const Yt = ht.sum(Ye);
        Nt.scrollTop > Yt && Nt.scrollBy(0, bt);
      } else if (Ye < N) Nt.scrollBy(0, bt);
      else if (Ye === N) {
        const Yt = ht.sum(Ye);
        Lt + Yt > Nt.scrollTop + Nt.offsetHeight && Nt.scrollBy(0, bt);
      }
      ve();
    }
    z.value++;
  }
  const q = !kP();
  let he = false;
  function se(Ne) {
    var Pe;
    (Pe = a.onScroll) === null || Pe === void 0 || Pe.call(a, Ne), (!q || !he) && ve();
  }
  function Q(Ne) {
    var Pe;
    if ((Pe = a.onWheel) === null || Pe === void 0 || Pe.call(a, Ne), q) {
      const tt = w.value;
      if (tt != null) {
        if (Ne.deltaX === 0 && (tt.scrollTop === 0 && Ne.deltaY <= 0 || tt.scrollTop + tt.offsetHeight >= tt.scrollHeight && Ne.deltaY >= 0)) return;
        Ne.preventDefault(), tt.scrollTop += Ne.deltaY / B_(), tt.scrollLeft += Ne.deltaX / B_(), ve(), he = true, Fp(() => {
          he = false;
        });
      }
    }
  }
  function oe(Ne) {
    if (l || Be(Ne.target)) return;
    if (a.renderCol == null && a.renderItemWithCols == null) {
      if (Ne.contentRect.height === S.value) return;
    } else if (Ne.contentRect.height === S.value && Ne.contentRect.width === o.value) return;
    S.value = Ne.contentRect.height, o.value = Ne.contentRect.width;
    const { onResize: Pe } = a;
    Pe !== void 0 && Pe(Ne);
  }
  function ve() {
    const { value: Ne } = w;
    Ne != null && (R.value = Ne.scrollTop, p.value = Ne.scrollLeft);
  }
  function Be(Ne) {
    let Pe = Ne;
    for (; Pe !== null; ) {
      if (Pe.style.display === "none") return true;
      Pe = Pe.parentElement;
    }
    return false;
  }
  return { listHeight: S, listStyle: { overflow: "auto" }, keyToIndex: g, itemsStyle: De(() => {
    const { itemResizable: Ne } = a, Pe = Ni(I.value.sum());
    return z.value, [a.itemsStyle, { boxSizing: "content-box", width: Ni(h.value), height: Ne ? "" : Pe, minHeight: Ne ? Pe : "", paddingTop: Ni(a.paddingTop), paddingBottom: Ni(a.paddingBottom) }];
  }), visibleItemsStyle: De(() => (z.value, { transform: `translateY(${Ni(I.value.sum(O.value))})` })), viewportItems: V, listElRef: w, itemsElRef: Me(null), scrollTo: W, handleListResize: oe, handleListScroll: se, handleListWheel: Q, handleItemResize: te };
}, render() {
  const { itemResizable: a, keyField: i, keyToIndex: l, visibleItemsTag: d } = this;
  return L(xl, { onResize: this.handleListResize }, { default: () => {
    var h, g;
    return L("div", qs(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? L("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [L(d, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: p, renderItemWithCols: o } = this;
      return this.viewportItems.map((w) => {
        const S = w[i], k = l.get(S), I = p != null ? L(O_, { index: k, item: w }) : void 0, z = o != null ? L(O_, { index: k, item: w }) : void 0, R = this.$slots.default({ item: w, renderedCols: I, renderedItemWithCols: z, index: k })[0];
        return a ? L(xl, { key: S, onResize: (O) => this.handleItemResize(S, O) }, { default: () => R }) : (R.key = S, R);
      });
    } })]) : (g = (h = this.$slots).empty) === null || g === void 0 ? void 0 : g.call(h)]);
  } });
} }), IP = wd(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [wd("&::-webkit-scrollbar", { width: 0, height: 0 })]), EP = ot({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const a = Me(null);
  function i(h) {
    !(h.currentTarget.offsetWidth < h.currentTarget.scrollWidth) || h.deltaY === 0 || (h.currentTarget.scrollLeft += h.deltaY + h.deltaX, h.preventDefault());
  }
  const l = tx();
  return IP.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: rx, ssr: l }), Object.assign({ selfRef: a, handleWheel: i }, { scrollTo(...h) {
    var g;
    (g = a.value) === null || g === void 0 || g.scrollTo(...h);
  } });
}, render() {
  return L("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function Wx(a, i) {
  i && (Tn(() => {
    const { value: l } = a;
    l && um.registerHandler(l, i);
  }), Kt(a, (l, d) => {
    d && um.unregisterHandler(d);
  }, { deep: false }), Ci(() => {
    const { value: l } = a;
    l && um.unregisterHandler(l);
  }));
}
function Zx(a, i) {
  if (!a) return;
  const l = document.createElement("a");
  l.href = a, i !== void 0 && (l.download = i), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function Jg(a) {
  switch (typeof a) {
    case "string":
      return a || void 0;
    case "number":
      return String(a);
    default:
      return;
  }
}
function RP(a) {
  switch (a) {
    case "tiny":
      return "mini";
    case "small":
      return "tiny";
    case "medium":
      return "small";
    case "large":
      return "medium";
    case "huge":
      return "large";
  }
  throw new Error(`${a} has no smaller size.`);
}
function Gp(a, i = "default", l = []) {
  const h = a.$slots[i];
  return h === void 0 ? l : h();
}
function zP(a) {
  var i;
  const l = (i = a.dirs) === null || i === void 0 ? void 0 : i.find(({ dir: d }) => d === Gs);
  return !!(l && l.value === false);
}
function fm(a) {
  const i = a.filter((l) => l !== void 0);
  if (i.length !== 0) return i.length === 1 ? i[0] : (l) => {
    a.forEach((d) => {
      d && d(l);
    });
  };
}
const AP = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (a) => `Please load all ${a}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (a) => `Total ${a} items`, selected: (a) => `${a} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" } };
function mm(a) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : a.defaultWidth;
    return a.formats[l] || a.formats[a.defaultWidth];
  };
}
function hd(a) {
  return (i, l) => {
    const d = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let h;
    if (d === "formatting" && a.formattingValues) {
      const p = a.defaultFormattingWidth || a.defaultWidth, o = (l == null ? void 0 : l.width) ? String(l.width) : p;
      h = a.formattingValues[o] || a.formattingValues[p];
    } else {
      const p = a.defaultWidth, o = (l == null ? void 0 : l.width) ? String(l.width) : a.defaultWidth;
      h = a.values[o] || a.values[p];
    }
    const g = a.argumentCallback ? a.argumentCallback(i) : i;
    return h[g];
  };
}
function pd(a) {
  return (i, l = {}) => {
    const d = l.width, h = d && a.matchPatterns[d] || a.matchPatterns[a.defaultMatchWidth], g = i.match(h);
    if (!g) return null;
    const p = g[0], o = d && a.parsePatterns[d] || a.parsePatterns[a.defaultParseWidth], w = Array.isArray(o) ? FP(o, (I) => I.test(p)) : DP(o, (I) => I.test(p));
    let S;
    S = a.valueCallback ? a.valueCallback(w) : w, S = l.valueCallback ? l.valueCallback(S) : S;
    const k = i.slice(p.length);
    return { value: S, rest: k };
  };
}
function DP(a, i) {
  for (const l in a) if (Object.prototype.hasOwnProperty.call(a, l) && i(a[l])) return l;
}
function FP(a, i) {
  for (let l = 0; l < a.length; l++) if (i(a[l])) return l;
}
function LP(a) {
  return (i, l = {}) => {
    const d = i.match(a.matchPattern);
    if (!d) return null;
    const h = d[0], g = i.match(a.parsePattern);
    if (!g) return null;
    let p = a.valueCallback ? a.valueCallback(g[0]) : g[0];
    p = l.valueCallback ? l.valueCallback(p) : p;
    const o = i.slice(h.length);
    return { value: p, rest: o };
  };
}
const BP = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, OP = (a, i, l) => {
  let d;
  const h = BP[a];
  return typeof h == "string" ? d = h : i === 1 ? d = h.one : d = h.other.replace("{{count}}", i.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + d : d + " ago" : d;
}, $P = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, jP = (a, i, l, d) => $P[a], NP = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, VP = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, UP = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, qP = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, GP = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, WP = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, ZP = (a, i) => {
  const l = Number(a), d = l % 100;
  if (d > 20 || d < 10) switch (d % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, HP = { ordinalNumber: ZP, era: hd({ values: NP, defaultWidth: "wide" }), quarter: hd({ values: VP, defaultWidth: "wide", argumentCallback: (a) => a - 1 }), month: hd({ values: UP, defaultWidth: "wide" }), day: hd({ values: qP, defaultWidth: "wide" }), dayPeriod: hd({ values: GP, defaultWidth: "wide", formattingValues: WP, defaultFormattingWidth: "wide" }) }, XP = /^(\d+)(th|st|nd|rd)?/i, YP = /\d+/i, KP = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, JP = { any: [/^b/i, /^(a|c)/i] }, QP = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, eT = { any: [/1/i, /2/i, /3/i, /4/i] }, tT = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, rT = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, nT = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, iT = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, oT = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, sT = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, aT = { ordinalNumber: LP({ matchPattern: XP, parsePattern: YP, valueCallback: (a) => parseInt(a, 10) }), era: pd({ matchPatterns: KP, defaultMatchWidth: "wide", parsePatterns: JP, defaultParseWidth: "any" }), quarter: pd({ matchPatterns: QP, defaultMatchWidth: "wide", parsePatterns: eT, defaultParseWidth: "any", valueCallback: (a) => a + 1 }), month: pd({ matchPatterns: tT, defaultMatchWidth: "wide", parsePatterns: rT, defaultParseWidth: "any" }), day: pd({ matchPatterns: nT, defaultMatchWidth: "wide", parsePatterns: iT, defaultParseWidth: "any" }), dayPeriod: pd({ matchPatterns: oT, defaultMatchWidth: "any", parsePatterns: sT, defaultParseWidth: "any" }) }, lT = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, cT = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, uT = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, dT = { date: mm({ formats: lT, defaultWidth: "full" }), time: mm({ formats: cT, defaultWidth: "full" }), dateTime: mm({ formats: uT, defaultWidth: "full" }) }, hT = { code: "en-US", formatDistance: OP, formatLong: dT, formatRelative: jP, localize: HP, match: aT, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, pT = { name: "en-US", locale: hT };
function Hs(a) {
  const { mergedLocaleRef: i, mergedDateLocaleRef: l } = hr(nx, null) || {}, d = De(() => {
    var g, p;
    return (p = (g = i == null ? void 0 : i.value) === null || g === void 0 ? void 0 : g[a]) !== null && p !== void 0 ? p : AP[a];
  });
  return { dateLocaleRef: De(() => {
    var g;
    return (g = l == null ? void 0 : l.value) !== null && g !== void 0 ? g : pT;
  }), localeRef: d };
}
const fT = de("affix", [Ue("affixed", { position: "fixed" }, [Ue("absolute-positioned", { position: "absolute" })])]);
function mT(a) {
  return a instanceof HTMLElement ? a.scrollTop : window.scrollY;
}
function gT(a) {
  return a instanceof HTMLElement ? a.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const Tv = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, vT = Ed(Tv), yT = ot({ name: "Affix", props: Tv, setup(a) {
  const { mergedClsPrefixRef: i } = Ir(a);
  tu("-affix", fT, i);
  let l = null;
  const d = Me(false), h = Me(false), g = Me(null), p = Me(null), o = De(() => h.value || d.value), w = De(() => {
    var W, N;
    return (N = (W = a.triggerTop) !== null && W !== void 0 ? W : a.offsetTop) !== null && N !== void 0 ? N : a.top;
  }), S = De(() => {
    var W, N;
    return (N = (W = a.top) !== null && W !== void 0 ? W : a.triggerTop) !== null && N !== void 0 ? N : a.offsetTop;
  }), k = De(() => {
    var W, N;
    return (N = (W = a.bottom) !== null && W !== void 0 ? W : a.triggerBottom) !== null && N !== void 0 ? N : a.offsetBottom;
  }), I = De(() => {
    var W, N;
    return (N = (W = a.triggerBottom) !== null && W !== void 0 ? W : a.offsetBottom) !== null && N !== void 0 ? N : a.bottom;
  }), z = Me(null), R = () => {
    const { target: W, listenTo: N } = a;
    W ? l = W() : N ? l = Ux(N) : l = document, l && (l.addEventListener("scroll", O), O());
  };
  function O() {
    Fp(V);
  }
  function V() {
    const { value: W } = z;
    if (!l || !W) return;
    const N = mT(l);
    if (o.value) {
      p.value !== null && N < p.value && (d.value = false, p.value = null), g.value !== null && N > g.value && (h.value = false, g.value = null);
      return;
    }
    const K = gT(l), Z = W.getBoundingClientRect(), X = Z.top - K.top, te = K.bottom - Z.bottom, q = w.value, he = I.value;
    q !== void 0 && X <= q ? (d.value = true, p.value = N - (q - X)) : (d.value = false, p.value = null), he !== void 0 && te <= he ? (h.value = true, g.value = N + he - te) : (h.value = false, g.value = null);
  }
  return Tn(() => {
    R();
  }), Ci(() => {
    l && l.removeEventListener("scroll", O);
  }), { selfRef: z, affixed: o, mergedClsPrefix: i, mergedstyle: De(() => {
    const W = {};
    return d.value && w.value !== void 0 && S.value !== void 0 && (W.top = `${S.value}px`), h.value && I.value !== void 0 && k.value !== void 0 && (W.bottom = `${k.value}px`), W;
  }) };
}, render() {
  const { mergedClsPrefix: a } = this;
  return L("div", { ref: "selfRef", class: [`${a}-affix`, { [`${a}-affix--affixed`]: this.affixed, [`${a}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), Wp = ot({ name: "Add", render() {
  return L("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), _T = ms("attach", () => L("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, L("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, L("g", { fill: "currentColor", "fill-rule": "nonzero" }, L("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), bT = ms("cancel", () => L("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, L("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, L("g", { fill: "currentColor", "fill-rule": "nonzero" }, L("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), xT = ot({ name: "Checkmark", render() {
  return L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, L("g", { fill: "none" }, L("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), wT = ot({ name: "ChevronDown", render() {
  return L("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), CT = ot({ name: "ChevronLeft", render() {
  return L("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), ST = ms("clear", () => L("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, L("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, L("g", { fill: "currentColor", "fill-rule": "nonzero" }, L("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), Hx = ms("download", () => L("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, L("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, L("g", { fill: "currentColor", "fill-rule": "nonzero" }, L("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), kT = ot({ name: "Empty", render() {
  return L("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), L("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), Xx = ot({ name: "Eye", render() {
  return L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, L("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), L("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), PT = ot({ name: "EyeOff", render() {
  return L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, L("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), L("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), L("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), L("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), L("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), TT = ot({ name: "Remove", render() {
  return L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, L("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), MT = ot({ name: "ResizeSmall", render() {
  return L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, L("g", { fill: "none" }, L("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), IT = ms("retry", () => L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, L("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), L("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), ET = ms("rotateClockwise", () => L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), L("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), RT = ms("rotateClockwise", () => L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), L("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), zT = ms("trash", () => L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, L("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), L("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), L("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), L("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), AT = ms("zoomIn", () => L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), L("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), DT = ms("zoomOut", () => L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), L("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), FT = de("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [Ge(">", [Ae("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [Ge("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), Ge("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Ae("placeholder", `
 display: flex;
 `), Ae("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Rd({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), Qg = ot({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(a) {
  return tu("-base-clear", FT, Ot(a, "clsPrefix")), { handleMouseDown(i) {
    i.preventDefault();
  } };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-base-clear` }, L(Lp, null, { default: () => {
    var i, l;
    return this.show ? L("div", { key: "dismiss", class: `${a}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, Ui(this.$slots.icon, () => [L(Ur, { clsPrefix: a }, { default: () => L(ST, null) })])) : L("div", { key: "icon", class: `${a}-base-clear__placeholder` }, (l = (i = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(i));
  } }));
} }), LT = ot({ props: { onFocus: Function, onBlur: Function }, setup(a) {
  return () => L("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: a.onFocus, onBlur: a.onBlur });
} }), BT = de("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Ae("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [Ge("+", [Ae("description", `
 margin-top: 8px;
 `)])]), Ae("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Ae("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), OT = Object.assign(Object.assign({}, tr.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), Dd = ot({ name: "Empty", props: OT, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedComponentPropsRef: d } = Ir(a), h = tr("Empty", "-empty", BT, FC, a, i), { localeRef: g } = Hs("Empty"), p = De(() => {
    var k, I, z;
    return (k = a.description) !== null && k !== void 0 ? k : (z = (I = d == null ? void 0 : d.value) === null || I === void 0 ? void 0 : I.Empty) === null || z === void 0 ? void 0 : z.description;
  }), o = De(() => {
    var k, I;
    return ((I = (k = d == null ? void 0 : d.value) === null || k === void 0 ? void 0 : k.Empty) === null || I === void 0 ? void 0 : I.renderIcon) || (() => L(kT, null));
  }), w = De(() => {
    const { size: k } = a, { common: { cubicBezierEaseInOut: I }, self: { [qt("iconSize", k)]: z, [qt("fontSize", k)]: R, textColor: O, iconColor: V, extraTextColor: W } } = h.value;
    return { "--n-icon-size": z, "--n-font-size": R, "--n-bezier": I, "--n-text-color": O, "--n-icon-color": V, "--n-extra-text-color": W };
  }), S = l ? hn("empty", De(() => {
    let k = "";
    const { size: I } = a;
    return k += I[0], k;
  }), w, a) : void 0;
  return { mergedClsPrefix: i, mergedRenderIcon: o, localizedDescription: De(() => p.value || g.value.description), cssVars: l ? void 0 : w, themeClass: S == null ? void 0 : S.themeClass, onRender: S == null ? void 0 : S.onRender };
}, render() {
  const { $slots: a, mergedClsPrefix: i, onRender: l } = this;
  return l == null ? void 0 : l(), L("div", { class: [`${i}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? L("div", { class: `${i}-empty__icon` }, a.icon ? a.icon() : L(Ur, { clsPrefix: i }, { default: this.mergedRenderIcon })) : null, this.showDescription ? L("div", { class: `${i}-empty__description` }, a.default ? a.default() : this.localizedDescription) : null, a.extra ? L("div", { class: `${i}-empty__extra` }, a.extra()) : null);
} }), $_ = ot({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: a, renderOptionRef: i, labelFieldRef: l, nodePropsRef: d } = hr(_v);
  return { labelField: l, nodeProps: d, renderLabel: a, renderOption: i };
}, render() {
  const { clsPrefix: a, renderLabel: i, renderOption: l, nodeProps: d, tmNode: { rawNode: h } } = this, g = d == null ? void 0 : d(h), p = i ? i(h, false) : _l(h[this.labelField], h, false), o = L("div", Object.assign({}, g, { class: [`${a}-base-select-group-header`, g == null ? void 0 : g.class] }), p);
  return h.render ? h.render({ node: o, option: h }) : l ? l({ node: o, option: h, selected: false }) : o;
} });
function $T(a, i) {
  return L(Ro, { name: "fade-in-scale-up-transition" }, { default: () => a ? L(Ur, { clsPrefix: i, class: `${i}-base-select-option__check` }, { default: () => L(xT) }) : null });
}
const j_ = ot({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(a) {
  const { valueRef: i, pendingTmNodeRef: l, multipleRef: d, valueSetRef: h, renderLabelRef: g, renderOptionRef: p, labelFieldRef: o, valueFieldRef: w, showCheckmarkRef: S, nodePropsRef: k, handleOptionClick: I, handleOptionMouseEnter: z } = hr(_v), R = vn(() => {
    const { value: N } = l;
    return N ? a.tmNode.key === N.key : false;
  });
  function O(N) {
    const { tmNode: K } = a;
    K.disabled || I(N, K);
  }
  function V(N) {
    const { tmNode: K } = a;
    K.disabled || z(N, K);
  }
  function W(N) {
    const { tmNode: K } = a, { value: Z } = R;
    K.disabled || Z || z(N, K);
  }
  return { multiple: d, isGrouped: vn(() => {
    const { tmNode: N } = a, { parent: K } = N;
    return K && K.rawNode.type === "group";
  }), showCheckmark: S, nodeProps: k, isPending: R, isSelected: vn(() => {
    const { value: N } = i, { value: K } = d;
    if (N === null) return false;
    const Z = a.tmNode.rawNode[w.value];
    if (K) {
      const { value: X } = h;
      return X.has(Z);
    } else return N === Z;
  }), labelField: o, renderLabel: g, renderOption: p, handleMouseMove: W, handleMouseEnter: V, handleClick: O };
}, render() {
  const { clsPrefix: a, tmNode: { rawNode: i }, isSelected: l, isPending: d, isGrouped: h, showCheckmark: g, nodeProps: p, renderOption: o, renderLabel: w, handleClick: S, handleMouseEnter: k, handleMouseMove: I } = this, z = $T(l, a), R = w ? [w(i, l), g && z] : [_l(i[this.labelField], i, l), g && z], O = p == null ? void 0 : p(i), V = L("div", Object.assign({}, O, { class: [`${a}-base-select-option`, i.class, O == null ? void 0 : O.class, { [`${a}-base-select-option--disabled`]: i.disabled, [`${a}-base-select-option--selected`]: l, [`${a}-base-select-option--grouped`]: h, [`${a}-base-select-option--pending`]: d, [`${a}-base-select-option--show-checkmark`]: g }], style: [(O == null ? void 0 : O.style) || "", i.style || ""], onClick: fm([S, O == null ? void 0 : O.onClick]), onMouseenter: fm([k, O == null ? void 0 : O.onMouseenter]), onMousemove: fm([I, O == null ? void 0 : O.onMousemove]) }), L("div", { class: `${a}-base-select-option__content` }, R));
  return i.render ? i.render({ node: V, option: i, selected: l }) : o ? o({ node: V, option: i, selected: l }) : V;
} }), jT = de("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [de("scrollbar", `
 max-height: var(--n-height);
 `), de("virtual-list", `
 max-height: var(--n-height);
 `), de("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Ae("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), de("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), de("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Ae("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Ae("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Ae("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Ae("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), de("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), de("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ue("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), Ge("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), Ge("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ue("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ue("selected", `
 color: var(--n-option-text-color-active);
 `, [Ge("&::before", `
 background-color: var(--n-option-color-active);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 `, [pn("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ue("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Ae("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [Bp({ enterScale: "0.5" })])])]), NT = ot({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, tr.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(a) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Ir(a), d = zi("InternalSelectMenu", l, i), h = tr("InternalSelectMenu", "-internal-select-menu", jT, LC, a, Ot(a, "clsPrefix")), g = Me(null), p = Me(null), o = Me(null), w = De(() => a.treeMate.getFlattenedNodes()), S = De(() => BC(w.value)), k = Me(null);
  function I() {
    const { treeMate: ct } = a;
    let bt = null;
    const { value: Nt } = a;
    Nt === null ? bt = ct.getFirstAvailableNode() : (a.multiple ? bt = ct.getNode((Nt || [])[(Nt || []).length - 1]) : bt = ct.getNode(Nt), (!bt || bt.disabled) && (bt = ct.getFirstAvailableNode())), Pe(bt || null);
  }
  function z() {
    const { value: ct } = k;
    ct && !a.treeMate.getNode(ct.key) && (k.value = null);
  }
  let R;
  Kt(() => a.show, (ct) => {
    ct ? R = Kt(() => a.treeMate, () => {
      a.resetMenuOnOptionsChange ? (a.autoPending ? I() : z(), Vi(tt)) : z();
    }, { immediate: true }) : R == null ? void 0 : R();
  }, { immediate: true }), Ci(() => {
    R == null ? void 0 : R();
  });
  const O = De(() => ei(h.value.self[qt("optionHeight", a.size)])), V = De(() => Eo(h.value.self[qt("padding", a.size)])), W = De(() => a.multiple && Array.isArray(a.value) ? new Set(a.value) : /* @__PURE__ */ new Set()), N = De(() => {
    const ct = w.value;
    return ct && ct.length === 0;
  });
  function K(ct) {
    const { onToggle: bt } = a;
    bt && bt(ct);
  }
  function Z(ct) {
    const { onScroll: bt } = a;
    bt && bt(ct);
  }
  function X(ct) {
    var bt;
    (bt = o.value) === null || bt === void 0 || bt.sync(), Z(ct);
  }
  function te() {
    var ct;
    (ct = o.value) === null || ct === void 0 || ct.sync();
  }
  function q() {
    const { value: ct } = k;
    return ct || null;
  }
  function he(ct, bt) {
    bt.disabled || Pe(bt, false);
  }
  function se(ct, bt) {
    bt.disabled || K(bt);
  }
  function Q(ct) {
    var bt;
    wl(ct, "action") || (bt = a.onKeyup) === null || bt === void 0 || bt.call(a, ct);
  }
  function oe(ct) {
    var bt;
    wl(ct, "action") || (bt = a.onKeydown) === null || bt === void 0 || bt.call(a, ct);
  }
  function ve(ct) {
    var bt;
    (bt = a.onMousedown) === null || bt === void 0 || bt.call(a, ct), !a.focusable && ct.preventDefault();
  }
  function Be() {
    const { value: ct } = k;
    ct && Pe(ct.getNext({ loop: true }), true);
  }
  function Ne() {
    const { value: ct } = k;
    ct && Pe(ct.getPrev({ loop: true }), true);
  }
  function Pe(ct, bt = false) {
    k.value = ct, bt && tt();
  }
  function tt() {
    var ct, bt;
    const Nt = k.value;
    if (!Nt) return;
    const Yt = S.value(Nt.key);
    Yt !== null && (a.virtualScroll ? (ct = p.value) === null || ct === void 0 || ct.scrollTo({ index: Yt }) : (bt = o.value) === null || bt === void 0 || bt.scrollTo({ index: Yt, elSize: O.value }));
  }
  function at(ct) {
    var bt, Nt;
    !((bt = g.value) === null || bt === void 0) && bt.contains(ct.target) && ((Nt = a.onFocus) === null || Nt === void 0 || Nt.call(a, ct));
  }
  function xt(ct) {
    var bt, Nt;
    !((bt = g.value) === null || bt === void 0) && bt.contains(ct.relatedTarget) || (Nt = a.onBlur) === null || Nt === void 0 || Nt.call(a, ct);
  }
  Zr(_v, { handleOptionMouseEnter: he, handleOptionClick: se, valueSetRef: W, pendingTmNodeRef: k, nodePropsRef: Ot(a, "nodeProps"), showCheckmarkRef: Ot(a, "showCheckmark"), multipleRef: Ot(a, "multiple"), valueRef: Ot(a, "value"), renderLabelRef: Ot(a, "renderLabel"), renderOptionRef: Ot(a, "renderOption"), labelFieldRef: Ot(a, "labelField"), valueFieldRef: Ot(a, "valueField") }), Zr(OC, g), Tn(() => {
    const { value: ct } = o;
    ct && ct.sync();
  });
  const ht = De(() => {
    const { size: ct } = a, { common: { cubicBezierEaseInOut: bt }, self: { height: Nt, borderRadius: Yt, color: vt, groupHeaderTextColor: jt, actionDividerColor: er, optionTextColorPressed: yr, optionTextColor: Tr, optionTextColorDisabled: zr, optionTextColorActive: rr, optionOpacityDisabled: yt, optionCheckColor: Ct, actionTextColor: Dt, optionColorPending: ir, optionColorActive: ut, loadingColor: We, loadingSize: kt, optionColorActivePending: et, [qt("optionFontSize", ct)]: it, [qt("optionHeight", ct)]: Pt, [qt("optionPadding", ct)]: Et } } = h.value;
    return { "--n-height": Nt, "--n-action-divider-color": er, "--n-action-text-color": Dt, "--n-bezier": bt, "--n-border-radius": Yt, "--n-color": vt, "--n-option-font-size": it, "--n-group-header-text-color": jt, "--n-option-check-color": Ct, "--n-option-color-pending": ir, "--n-option-color-active": ut, "--n-option-color-active-pending": et, "--n-option-height": Pt, "--n-option-opacity-disabled": yt, "--n-option-text-color": Tr, "--n-option-text-color-active": rr, "--n-option-text-color-disabled": zr, "--n-option-text-color-pressed": yr, "--n-option-padding": Et, "--n-option-padding-left": Eo(Et, "left"), "--n-option-padding-right": Eo(Et, "right"), "--n-loading-color": We, "--n-loading-size": kt };
  }), { inlineThemeDisabled: Ye } = a, Ke = Ye ? hn("internal-select-menu", De(() => a.size[0]), ht, a) : void 0, Lt = { selfRef: g, next: Be, prev: Ne, getPendingTmNode: q };
  return Wx(g, a.onResize), Object.assign({ mergedTheme: h, mergedClsPrefix: i, rtlEnabled: d, virtualListRef: p, scrollbarRef: o, itemSize: O, padding: V, flattenedNodes: w, empty: N, virtualListContainer() {
    const { value: ct } = p;
    return ct == null ? void 0 : ct.listElRef;
  }, virtualListContent() {
    const { value: ct } = p;
    return ct == null ? void 0 : ct.itemsElRef;
  }, doScroll: Z, handleFocusin: at, handleFocusout: xt, handleKeyUp: Q, handleKeyDown: oe, handleMouseDown: ve, handleVirtualListResize: te, handleVirtualListScroll: X, cssVars: Ye ? void 0 : ht, themeClass: Ke == null ? void 0 : Ke.themeClass, onRender: Ke == null ? void 0 : Ke.onRender }, Lt);
}, render() {
  const { $slots: a, virtualScroll: i, clsPrefix: l, mergedTheme: d, themeClass: h, onRender: g } = this;
  return g == null ? void 0 : g(), L("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, h, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, dn(a.header, (p) => p && L("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, p)), this.loading ? L("div", { class: `${l}-base-select-menu__loading` }, L(Op, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? L("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, Ui(a.empty, () => [L(Dd, { theme: d.peers.Empty, themeOverrides: d.peerOverrides.Empty, size: this.size })])) : L(jd, { ref: "scrollbarRef", theme: d.peers.Scrollbar, themeOverrides: d.peerOverrides.Scrollbar, scrollable: this.scrollable, container: i ? this.virtualListContainer : void 0, content: i ? this.virtualListContent : void 0, onScroll: i ? void 0 : this.doScroll }, { default: () => i ? L(MP, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: p }) => p.isGroup ? L($_, { key: p.key, clsPrefix: l, tmNode: p }) : p.ignored ? null : L(j_, { clsPrefix: l, key: p.key, tmNode: p }) }) : L("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((p) => p.isGroup ? L($_, { key: p.key, clsPrefix: l, tmNode: p }) : L(j_, { clsPrefix: l, key: p.key, tmNode: p }))) }), dn(a.action, (p) => p && [L("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, p), L(LT, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), Yx = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, VT = de("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ue("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Ae("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Ae("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Ae("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Ae("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ue("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Ae("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Ae("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ue("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ue("icon, avatar", [Ue("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ue("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ue("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [pn("disabled", [Ge("&:hover", "background-color: var(--n-color-hover-checkable);", [pn("checked", "color: var(--n-text-color-hover-checkable);")]), Ge("&:active", "background-color: var(--n-color-pressed-checkable);", [pn("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ue("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [pn("disabled", [Ge("&:hover", "background-color: var(--n-color-checked-hover);"), Ge("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), UT = Object.assign(Object.assign(Object.assign({}, tr.props), Yx), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), qT = Ai("n-tag"), bo = ot({ name: "Tag", props: UT, slots: Object, setup(a) {
  const i = Me(null), { mergedBorderedRef: l, mergedClsPrefixRef: d, inlineThemeDisabled: h, mergedRtlRef: g } = Ir(a), p = tr("Tag", "-tag", VT, $C, a, d);
  Zr(qT, { roundRef: Ot(a, "round") });
  function o() {
    if (!a.disabled && a.checkable) {
      const { checked: R, onCheckedChange: O, onUpdateChecked: V, "onUpdate:checked": W } = a;
      V && V(!R), W && W(!R), O && O(!R);
    }
  }
  function w(R) {
    if (a.triggerClickOnClose || R.stopPropagation(), !a.disabled) {
      const { onClose: O } = a;
      O && Gt(O, R);
    }
  }
  const S = { setTextContent(R) {
    const { value: O } = i;
    O && (O.textContent = R);
  } }, k = zi("Tag", g, d), I = De(() => {
    const { type: R, size: O, color: { color: V, textColor: W } = {} } = a, { common: { cubicBezierEaseInOut: N }, self: { padding: K, closeMargin: Z, borderRadius: X, opacityDisabled: te, textColorCheckable: q, textColorHoverCheckable: he, textColorPressedCheckable: se, textColorChecked: Q, colorCheckable: oe, colorHoverCheckable: ve, colorPressedCheckable: Be, colorChecked: Ne, colorCheckedHover: Pe, colorCheckedPressed: tt, closeBorderRadius: at, fontWeightStrong: xt, [qt("colorBordered", R)]: ht, [qt("closeSize", O)]: Ye, [qt("closeIconSize", O)]: Ke, [qt("fontSize", O)]: Lt, [qt("height", O)]: ct, [qt("color", R)]: bt, [qt("textColor", R)]: Nt, [qt("border", R)]: Yt, [qt("closeIconColor", R)]: vt, [qt("closeIconColorHover", R)]: jt, [qt("closeIconColorPressed", R)]: er, [qt("closeColorHover", R)]: yr, [qt("closeColorPressed", R)]: Tr } } = p.value, zr = Eo(Z);
    return { "--n-font-weight-strong": xt, "--n-avatar-size-override": `calc(${ct} - 8px)`, "--n-bezier": N, "--n-border-radius": X, "--n-border": Yt, "--n-close-icon-size": Ke, "--n-close-color-pressed": Tr, "--n-close-color-hover": yr, "--n-close-border-radius": at, "--n-close-icon-color": vt, "--n-close-icon-color-hover": jt, "--n-close-icon-color-pressed": er, "--n-close-icon-color-disabled": vt, "--n-close-margin-top": zr.top, "--n-close-margin-right": zr.right, "--n-close-margin-bottom": zr.bottom, "--n-close-margin-left": zr.left, "--n-close-size": Ye, "--n-color": V || (l.value ? ht : bt), "--n-color-checkable": oe, "--n-color-checked": Ne, "--n-color-checked-hover": Pe, "--n-color-checked-pressed": tt, "--n-color-hover-checkable": ve, "--n-color-pressed-checkable": Be, "--n-font-size": Lt, "--n-height": ct, "--n-opacity-disabled": te, "--n-padding": K, "--n-text-color": W || Nt, "--n-text-color-checkable": q, "--n-text-color-checked": Q, "--n-text-color-hover-checkable": he, "--n-text-color-pressed-checkable": se };
  }), z = h ? hn("tag", De(() => {
    let R = "";
    const { type: O, size: V, color: { color: W, textColor: N } = {} } = a;
    return R += O[0], R += V[0], W && (R += `a${k_(W)}`), N && (R += `b${k_(N)}`), l.value && (R += "c"), R;
  }), I, a) : void 0;
  return Object.assign(Object.assign({}, S), { rtlEnabled: k, mergedClsPrefix: d, contentRef: i, mergedBordered: l, handleClick: o, handleCloseClick: w, cssVars: h ? void 0 : I, themeClass: z == null ? void 0 : z.themeClass, onRender: z == null ? void 0 : z.onRender });
}, render() {
  var a, i;
  const { mergedClsPrefix: l, rtlEnabled: d, closable: h, color: { borderColor: g } = {}, round: p, onRender: o, $slots: w } = this;
  o == null ? void 0 : o();
  const S = dn(w.avatar, (I) => I && L("div", { class: `${l}-tag__avatar` }, I)), k = dn(w.icon, (I) => I && L("div", { class: `${l}-tag__icon` }, I));
  return L("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: d, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: p, [`${l}-tag--avatar`]: S, [`${l}-tag--icon`]: k, [`${l}-tag--closable`]: h }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, k || S, L("span", { class: `${l}-tag__content`, ref: "contentRef" }, (i = (a = this.$slots).default) === null || i === void 0 ? void 0 : i.call(a)), !this.checkable && h ? L($p, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: p, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? L("div", { class: `${l}-tag__border`, style: { borderColor: g } }) : null);
} }), Kx = ot({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(a, { slots: i }) {
  return () => {
    const { clsPrefix: l } = a;
    return L(Op, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: a.loading }, { default: () => a.showArrow ? L(Qg, { clsPrefix: l, show: a.showClear, onClear: a.onClear }, { placeholder: () => L(Ur, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => Ui(i.default, () => [L(wT, null)]) }) }) : null });
  };
} }), GT = Ge([de("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [de("base-loading", `
 color: var(--n-loading-color);
 `), de("base-selection-tags", "min-height: var(--n-height);"), Ae("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Ae("state-border", `
 z-index: 1;
 border-color: #0000;
 `), de("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Ae("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), de("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Ae("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), de("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Ae("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), de("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), de("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [de("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Ae("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Ae("render-label", `
 color: var(--n-text-color);
 `)]), pn("disabled", [Ge("&:hover", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ue("focus", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ue("active", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), de("base-selection-label", "background-color: var(--n-color-active);"), de("base-selection-tags", "background-color: var(--n-color-active);")])]), Ue("disabled", "cursor: not-allowed;", [Ae("arrow", `
 color: var(--n-arrow-color-disabled);
 `), de("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [de("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Ae("render-label", `
 color: var(--n-text-color-disabled);
 `)]), de("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), de("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), de("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Ae("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Ae("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((a) => Ue(`${a}-status`, [Ae("state-border", `border: var(--n-border-${a});`), pn("disabled", [Ge("&:hover", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-hover-${a});
 border: var(--n-border-hover-${a});
 `)]), Ue("active", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-active-${a});
 border: var(--n-border-active-${a});
 `), de("base-selection-label", `background-color: var(--n-color-active-${a});`), de("base-selection-tags", `background-color: var(--n-color-active-${a});`)]), Ue("focus", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${a});
 border: var(--n-border-focus-${a});
 `)])])]))]), de("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), de("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [Ge("&:last-child", "padding-right: 0;"), de("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Ae("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), WT = ot({ name: "InternalSelection", props: Object.assign(Object.assign({}, tr.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(a) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Ir(a), d = zi("InternalSelection", l, i), h = Me(null), g = Me(null), p = Me(null), o = Me(null), w = Me(null), S = Me(null), k = Me(null), I = Me(null), z = Me(null), R = Me(null), O = Me(false), V = Me(false), W = Me(false), N = tr("InternalSelection", "-internal-selection", GT, NC, a, Ot(a, "clsPrefix")), K = De(() => a.clearable && !a.disabled && (W.value || a.active)), Z = De(() => a.selectedOption ? a.renderTag ? a.renderTag({ option: a.selectedOption, handleClose: () => {
  } }) : a.renderLabel ? a.renderLabel(a.selectedOption, true) : _l(a.selectedOption[a.labelField], a.selectedOption, true) : a.placeholder), X = De(() => {
    const st = a.selectedOption;
    if (st) return st[a.labelField];
  }), te = De(() => a.multiple ? !!(Array.isArray(a.selectedOptions) && a.selectedOptions.length) : a.selectedOption !== null);
  function q() {
    var st;
    const { value: St } = h;
    if (St) {
      const { value: ar } = g;
      ar && (ar.style.width = `${St.offsetWidth}px`, a.maxTagCount !== "responsive" && ((st = z.value) === null || st === void 0 || st.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function he() {
    const { value: st } = R;
    st && (st.style.display = "none");
  }
  function se() {
    const { value: st } = R;
    st && (st.style.display = "inline-block");
  }
  Kt(Ot(a, "active"), (st) => {
    st || he();
  }), Kt(Ot(a, "pattern"), () => {
    a.multiple && Vi(q);
  });
  function Q(st) {
    const { onFocus: St } = a;
    St && St(st);
  }
  function oe(st) {
    const { onBlur: St } = a;
    St && St(st);
  }
  function ve(st) {
    const { onDeleteOption: St } = a;
    St && St(st);
  }
  function Be(st) {
    const { onClear: St } = a;
    St && St(st);
  }
  function Ne(st) {
    const { onPatternInput: St } = a;
    St && St(st);
  }
  function Pe(st) {
    var St;
    (!st.relatedTarget || !(!((St = p.value) === null || St === void 0) && St.contains(st.relatedTarget))) && Q(st);
  }
  function tt(st) {
    var St;
    !((St = p.value) === null || St === void 0) && St.contains(st.relatedTarget) || oe(st);
  }
  function at(st) {
    Be(st);
  }
  function xt() {
    W.value = true;
  }
  function ht() {
    W.value = false;
  }
  function Ye(st) {
    !a.active || !a.filterable || st.target !== g.value && st.preventDefault();
  }
  function Ke(st) {
    ve(st);
  }
  const Lt = Me(false);
  function ct(st) {
    if (st.key === "Backspace" && !Lt.value && !a.pattern.length) {
      const { selectedOptions: St } = a;
      (St == null ? void 0 : St.length) && Ke(St[St.length - 1]);
    }
  }
  let bt = null;
  function Nt(st) {
    const { value: St } = h;
    if (St) {
      const ar = st.target.value;
      St.textContent = ar, q();
    }
    a.ignoreComposition && Lt.value ? bt = st : Ne(st);
  }
  function Yt() {
    Lt.value = true;
  }
  function vt() {
    Lt.value = false, a.ignoreComposition && Ne(bt), bt = null;
  }
  function jt(st) {
    var St;
    V.value = true, (St = a.onPatternFocus) === null || St === void 0 || St.call(a, st);
  }
  function er(st) {
    var St;
    V.value = false, (St = a.onPatternBlur) === null || St === void 0 || St.call(a, st);
  }
  function yr() {
    var st, St;
    if (a.filterable) V.value = false, (st = S.value) === null || st === void 0 || st.blur(), (St = g.value) === null || St === void 0 || St.blur();
    else if (a.multiple) {
      const { value: ar } = o;
      ar == null ? void 0 : ar.blur();
    } else {
      const { value: ar } = w;
      ar == null ? void 0 : ar.blur();
    }
  }
  function Tr() {
    var st, St, ar;
    a.filterable ? (V.value = false, (st = S.value) === null || st === void 0 || st.focus()) : a.multiple ? (St = o.value) === null || St === void 0 || St.focus() : (ar = w.value) === null || ar === void 0 || ar.focus();
  }
  function zr() {
    const { value: st } = g;
    st && (se(), st.focus());
  }
  function rr() {
    const { value: st } = g;
    st && st.blur();
  }
  function yt(st) {
    const { value: St } = k;
    St && St.setTextContent(`+${st}`);
  }
  function Ct() {
    const { value: st } = I;
    return st;
  }
  function Dt() {
    return g.value;
  }
  let ir = null;
  function ut() {
    ir !== null && window.clearTimeout(ir);
  }
  function We() {
    a.active || (ut(), ir = window.setTimeout(() => {
      te.value && (O.value = true);
    }, 100));
  }
  function kt() {
    ut();
  }
  function et(st) {
    st || (ut(), O.value = false);
  }
  Kt(te, (st) => {
    st || (O.value = false);
  }), Tn(() => {
    zo(() => {
      const st = S.value;
      st && (a.disabled ? st.removeAttribute("tabindex") : st.tabIndex = V.value ? -1 : 0);
    });
  }), Wx(p, a.onResize);
  const { inlineThemeDisabled: it } = a, Pt = De(() => {
    const { size: st } = a, { common: { cubicBezierEaseInOut: St }, self: { fontWeight: ar, borderRadius: on, color: Sn, placeholderColor: Le, textColor: re, paddingSingle: ne, paddingMultiple: ae, caretColor: be, colorDisabled: Ie, textColorDisabled: Fe, placeholderColorDisabled: fe, colorActive: _e, boxShadowFocus: Ve, boxShadowActive: nt, boxShadowHover: Xe, border: wt, borderFocus: Te, borderHover: Ut, borderActive: or, arrowColor: Wt, arrowColorDisabled: dr, loadingColor: Or, colorActiveWarning: Qr, boxShadowFocusWarning: en, boxShadowActiveWarning: sn, boxShadowHoverWarning: _r, borderWarning: wr, borderFocusWarning: Hr, borderHoverWarning: ye, borderActiveWarning: pt, colorActiveError: Vt, boxShadowFocusError: Ar, boxShadowActiveError: Nr, boxShadowHoverError: gt, borderError: pr, borderFocusError: ur, borderHoverError: an, borderActiveError: ci, clearColor: ni, clearColorHover: fr, clearColorPressed: Ho, clearSize: qi, arrowSize: Xo, [qt("height", st)]: Si, [qt("fontSize", st)]: xo } } = N.value, Xr = Eo(ne), Ji = Eo(ae);
    return { "--n-bezier": St, "--n-border": wt, "--n-border-active": or, "--n-border-focus": Te, "--n-border-hover": Ut, "--n-border-radius": on, "--n-box-shadow-active": nt, "--n-box-shadow-focus": Ve, "--n-box-shadow-hover": Xe, "--n-caret-color": be, "--n-color": Sn, "--n-color-active": _e, "--n-color-disabled": Ie, "--n-font-size": xo, "--n-height": Si, "--n-padding-single-top": Xr.top, "--n-padding-multiple-top": Ji.top, "--n-padding-single-right": Xr.right, "--n-padding-multiple-right": Ji.right, "--n-padding-single-left": Xr.left, "--n-padding-multiple-left": Ji.left, "--n-padding-single-bottom": Xr.bottom, "--n-padding-multiple-bottom": Ji.bottom, "--n-placeholder-color": Le, "--n-placeholder-color-disabled": fe, "--n-text-color": re, "--n-text-color-disabled": Fe, "--n-arrow-color": Wt, "--n-arrow-color-disabled": dr, "--n-loading-color": Or, "--n-color-active-warning": Qr, "--n-box-shadow-focus-warning": en, "--n-box-shadow-active-warning": sn, "--n-box-shadow-hover-warning": _r, "--n-border-warning": wr, "--n-border-focus-warning": Hr, "--n-border-hover-warning": ye, "--n-border-active-warning": pt, "--n-color-active-error": Vt, "--n-box-shadow-focus-error": Ar, "--n-box-shadow-active-error": Nr, "--n-box-shadow-hover-error": gt, "--n-border-error": pr, "--n-border-focus-error": ur, "--n-border-hover-error": an, "--n-border-active-error": ci, "--n-clear-size": qi, "--n-clear-color": ni, "--n-clear-color-hover": fr, "--n-clear-color-pressed": Ho, "--n-arrow-size": Xo, "--n-font-weight": ar };
  }), Et = it ? hn("internal-selection", De(() => a.size[0]), Pt, a) : void 0;
  return { mergedTheme: N, mergedClearable: K, mergedClsPrefix: i, rtlEnabled: d, patternInputFocused: V, filterablePlaceholder: Z, label: X, selected: te, showTagsPanel: O, isComposing: Lt, counterRef: k, counterWrapperRef: I, patternInputMirrorRef: h, patternInputRef: g, selfRef: p, multipleElRef: o, singleElRef: w, patternInputWrapperRef: S, overflowRef: z, inputTagElRef: R, handleMouseDown: Ye, handleFocusin: Pe, handleClear: at, handleMouseEnter: xt, handleMouseLeave: ht, handleDeleteOption: Ke, handlePatternKeyDown: ct, handlePatternInputInput: Nt, handlePatternInputBlur: er, handlePatternInputFocus: jt, handleMouseEnterCounter: We, handleMouseLeaveCounter: kt, handleFocusout: tt, handleCompositionEnd: vt, handleCompositionStart: Yt, onPopoverUpdateShow: et, focus: Tr, focusInput: zr, blur: yr, blurInput: rr, updateCounter: yt, getCounter: Ct, getTail: Dt, renderLabel: a.renderLabel, cssVars: it ? void 0 : Pt, themeClass: Et == null ? void 0 : Et.themeClass, onRender: Et == null ? void 0 : Et.onRender };
}, render() {
  const { status: a, multiple: i, size: l, disabled: d, filterable: h, maxTagCount: g, bordered: p, clsPrefix: o, ellipsisTagPopoverProps: w, onRender: S, renderTag: k, renderLabel: I } = this;
  S == null ? void 0 : S();
  const z = g === "responsive", R = typeof g == "number", O = z || R, V = L(jC, null, { default: () => L(Kx, { clsPrefix: o, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var N, K;
    return (K = (N = this.$slots).arrow) === null || K === void 0 ? void 0 : K.call(N);
  } }) });
  let W;
  if (i) {
    const { labelField: N } = this, K = (Ne) => L("div", { class: `${o}-base-selection-tag-wrapper`, key: Ne.value }, k ? k({ option: Ne, handleClose: () => {
      this.handleDeleteOption(Ne);
    } }) : L(bo, { size: l, closable: !Ne.disabled, disabled: d, onClose: () => {
      this.handleDeleteOption(Ne);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => I ? I(Ne, true) : _l(Ne[N], Ne, true) })), Z = () => (R ? this.selectedOptions.slice(0, g) : this.selectedOptions).map(K), X = h ? L("div", { class: `${o}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, L("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: d, value: this.pattern, autofocus: this.autofocus, class: `${o}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), L("span", { ref: "patternInputMirrorRef", class: `${o}-base-selection-input-tag__mirror` }, this.pattern)) : null, te = z ? () => L("div", { class: `${o}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, L(bo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: d })) : void 0;
    let q;
    if (R) {
      const Ne = this.selectedOptions.length - g;
      Ne > 0 && (q = L("div", { class: `${o}-base-selection-tag-wrapper`, key: "__counter__" }, L(bo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: d }, { default: () => `+${Ne}` })));
    }
    const he = z ? h ? L(P_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: Z, counter: te, tail: () => X }) : L(P_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: Z, counter: te }) : R && q ? Z().concat(q) : Z(), se = O ? () => L("div", { class: `${o}-base-selection-popover` }, z ? Z() : this.selectedOptions.map(K)) : void 0, Q = O ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, w) : null, ve = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? L("div", { class: `${o}-base-selection-placeholder ${o}-base-selection-overlay` }, L("div", { class: `${o}-base-selection-placeholder__inner` }, this.placeholder)) : null, Be = h ? L("div", { ref: "patternInputWrapperRef", class: `${o}-base-selection-tags` }, he, z ? null : X, V) : L("div", { ref: "multipleElRef", class: `${o}-base-selection-tags`, tabindex: d ? void 0 : 0 }, he, V);
    W = L(qr, null, O ? L(bv, Object.assign({}, Q, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => Be, default: se }) : Be, ve);
  } else if (h) {
    const N = this.pattern || this.isComposing, K = this.active ? !N : !this.selected, Z = this.active ? false : this.selected;
    W = L("div", { ref: "patternInputWrapperRef", class: `${o}-base-selection-label`, title: this.patternInputFocused ? void 0 : Jg(this.label) }, L("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${o}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: d, disabled: d, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), Z ? L("div", { class: `${o}-base-selection-label__render-label ${o}-base-selection-overlay`, key: "input" }, L("div", { class: `${o}-base-selection-overlay__wrapper` }, k ? k({ option: this.selectedOption, handleClose: () => {
    } }) : I ? I(this.selectedOption, true) : _l(this.label, this.selectedOption, true))) : null, K ? L("div", { class: `${o}-base-selection-placeholder ${o}-base-selection-overlay`, key: "placeholder" }, L("div", { class: `${o}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, V);
  } else W = L("div", { ref: "singleElRef", class: `${o}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? L("div", { class: `${o}-base-selection-input`, title: Jg(this.label), key: "input" }, L("div", { class: `${o}-base-selection-input__content` }, k ? k({ option: this.selectedOption, handleClose: () => {
  } }) : I ? I(this.selectedOption, true) : _l(this.label, this.selectedOption, true))) : L("div", { class: `${o}-base-selection-placeholder ${o}-base-selection-overlay`, key: "placeholder" }, L("div", { class: `${o}-base-selection-placeholder__inner` }, this.placeholder)), V);
  return L("div", { ref: "selfRef", class: [`${o}-base-selection`, this.rtlEnabled && `${o}-base-selection--rtl`, this.themeClass, a && `${o}-base-selection--${a}-status`, { [`${o}-base-selection--active`]: this.active, [`${o}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${o}-base-selection--disabled`]: this.disabled, [`${o}-base-selection--multiple`]: this.multiple, [`${o}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, W, p ? L("div", { class: `${o}-base-selection__border` }) : null, p ? L("div", { class: `${o}-base-selection__state-border` }) : null);
} }), ZT = de("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [Ae("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), Ue("closable", [de("alert-body", [Ae("title", `
 padding-right: 24px;
 `)])]), Ae("icon", { color: "var(--n-icon-color)" }), de("alert-body", { padding: "var(--n-padding)" }, [Ae("title", { color: "var(--n-title-text-color)" }), Ae("content", { color: "var(--n-content-text-color)" })]), Sp({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), Ae("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), Ae("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), Ue("show-icon", [de("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), Ue("right-adjust", [de("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), de("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [Ae("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [Ge("& +", [Ae("content", { marginTop: "9px" })])]), Ae("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), Ae("icon", { transition: "color .3s var(--n-bezier)" })]), HT = Object.assign(Object.assign({}, tr.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), vp = ot({ name: "Alert", inheritAttrs: false, props: HT, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: h } = Ir(a), g = tr("Alert", "-alert", ZT, VC, a, i), p = zi("Alert", h, i), o = De(() => {
    const { common: { cubicBezierEaseInOut: R }, self: O } = g.value, { fontSize: V, borderRadius: W, titleFontWeight: N, lineHeight: K, iconSize: Z, iconMargin: X, iconMarginRtl: te, closeIconSize: q, closeBorderRadius: he, closeSize: se, closeMargin: Q, closeMarginRtl: oe, padding: ve } = O, { type: Be } = a, { left: Ne, right: Pe } = Eo(X);
    return { "--n-bezier": R, "--n-color": O[qt("color", Be)], "--n-close-icon-size": q, "--n-close-border-radius": he, "--n-close-color-hover": O[qt("closeColorHover", Be)], "--n-close-color-pressed": O[qt("closeColorPressed", Be)], "--n-close-icon-color": O[qt("closeIconColor", Be)], "--n-close-icon-color-hover": O[qt("closeIconColorHover", Be)], "--n-close-icon-color-pressed": O[qt("closeIconColorPressed", Be)], "--n-icon-color": O[qt("iconColor", Be)], "--n-border": O[qt("border", Be)], "--n-title-text-color": O[qt("titleTextColor", Be)], "--n-content-text-color": O[qt("contentTextColor", Be)], "--n-line-height": K, "--n-border-radius": W, "--n-font-size": V, "--n-title-font-weight": N, "--n-icon-size": Z, "--n-icon-margin": X, "--n-icon-margin-rtl": te, "--n-close-size": se, "--n-close-margin": Q, "--n-close-margin-rtl": oe, "--n-padding": ve, "--n-icon-margin-left": Ne, "--n-icon-margin-right": Pe };
  }), w = d ? hn("alert", De(() => a.type[0]), o, a) : void 0, S = Me(true), k = () => {
    const { onAfterLeave: R, onAfterHide: O } = a;
    R && R(), O && O();
  };
  return { rtlEnabled: p, mergedClsPrefix: i, mergedBordered: l, visible: S, handleCloseClick: () => {
    var R;
    Promise.resolve((R = a.onClose) === null || R === void 0 ? void 0 : R.call(a)).then((O) => {
      O !== false && (S.value = false);
    });
  }, handleAfterLeave: () => {
    k();
  }, mergedTheme: g, cssVars: d ? void 0 : o, themeClass: w == null ? void 0 : w.themeClass, onRender: w == null ? void 0 : w.onRender };
}, render() {
  var a;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L(jp, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: i, $slots: l } = this, d = { class: [`${i}-alert`, this.themeClass, this.closable && `${i}-alert--closable`, this.showIcon && `${i}-alert--show-icon`, !this.title && this.closable && `${i}-alert--right-adjust`, this.rtlEnabled && `${i}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? L("div", Object.assign({}, qs(this.$attrs, d)), this.closable && L($p, { clsPrefix: i, class: `${i}-alert__close`, onClick: this.handleCloseClick }), this.bordered && L("div", { class: `${i}-alert__border` }), this.showIcon && L("div", { class: `${i}-alert__icon`, "aria-hidden": "true" }, Ui(l.icon, () => [L(Ur, { clsPrefix: i }, { default: () => {
      switch (this.type) {
        case "success":
          return L(Cv, null);
        case "info":
          return L(wv, null);
        case "warning":
          return L(Np, null);
        case "error":
          return L(xv, null);
        default:
          return null;
      }
    } })])), L("div", { class: [`${i}-alert-body`, this.mergedBordered && `${i}-alert-body--bordered`] }, dn(l.header, (h) => {
      const g = h || this.title;
      return g ? L("div", { class: `${i}-alert-body__title` }, g) : null;
    }), l.default && L("div", { class: `${i}-alert-body__content` }, l))) : null;
  } });
} }), yp = Ai("n-anchor"), XT = { title: String, href: String }, _p = ot({ name: "AnchorLink", props: XT, slots: Object, setup(a, { slots: i }) {
  const l = Me(null), d = hr(yp), h = Ot(a, "href"), g = vn(() => h.value && h.value === d.activeHref.value);
  CP(yp, "collectedLinkHrefs", h), SP(yp, "titleEls", () => l.value), Kt(g, (o) => {
    o && l.value && d.updateBarPosition(l.value);
  });
  function p() {
    a.href !== void 0 && d.setActiveHref(a.href);
  }
  return () => {
    var o;
    const { value: w } = d.mergedClsPrefix;
    return L("div", { class: [`${w}-anchor-link`, g.value && `${w}-anchor-link--active`] }, L("a", { ref: l, class: [`${w}-anchor-link__title`], href: a.href, title: Jg(a.title), onClick: p }, { default: () => Ui(i.title, () => [a.title]) }), (o = i.default) === null || o === void 0 ? void 0 : o.call(i));
  };
} });
function YT(a, i) {
  const { top: l, height: d } = a.getBoundingClientRect(), h = i instanceof HTMLElement ? i.getBoundingClientRect().top : 0;
  return { top: l - h, height: d };
}
const Mv = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, KT = Ed(Mv), JT = ot({ name: "BaseAnchor", props: Object.assign(Object.assign({}, Mv), { mergedClsPrefix: { type: String, required: true } }), setup(a) {
  const i = [], l = [], d = Me(null), h = Me(null), g = Me(null), p = Me(null), o = De(() => a.type === "block"), w = De(() => !o.value && a.showRail);
  function S() {
    const { value: O } = g, { value: V } = h;
    O && (O.style.transition = "none"), V && (V.style.transition = "none"), l && l.forEach((W) => {
      W.style.transition = "none";
    }), Vi(() => {
      const { value: W } = g, { value: N } = h;
      W && (W.offsetWidth, W.style.transition = ""), N && (N.offsetWidth, N.style.transition = ""), l && l.forEach((K) => {
        K.offsetWidth, K.style.transition = "";
      });
    });
  }
  function k(O, V = true) {
    const { value: W } = g, { value: N } = h, { value: K } = p;
    if (!K || !W) return;
    V || (W.style.transition = "none", N && (N.style.transition = "none"));
    const { offsetHeight: Z, offsetWidth: X } = O, { top: te, left: q } = O.getBoundingClientRect(), { top: he, left: se } = K.getBoundingClientRect(), Q = te - he, oe = q - se;
    W.style.top = `${Q}px`, W.style.height = `${Z}px`, N && (N.style.top = `${Q}px`, N.style.height = `${Z}px`, N.style.maxWidth = `${X + oe}px`), W.offsetHeight, N && N.offsetHeight, V || (W.style.transition = "", N && (N.style.transition = ""));
  }
  const I = gp(() => {
    R(true);
  }, 128);
  function z(O, V = true) {
    const W = /^#([^#]+)$/.exec(O);
    if (!W) return;
    const N = document.getElementById(W[1]);
    N && (d.value = O, N.scrollIntoView(), V || S(), I());
  }
  function R(O = true) {
    var V;
    const W = [], N = Ux((V = a.offsetTarget) !== null && V !== void 0 ? V : document);
    i.forEach((q) => {
      const he = /#([^#]+)$/.exec(q);
      if (!he) return;
      const se = document.getElementById(he[1]);
      if (se && N) {
        const { top: Q, height: oe } = YT(se, N);
        W.push({ top: Q, height: oe, href: q });
      }
    }), W.sort((q, he) => q.top > he.top ? 1 : (q.top === he.top && q.height < he.height, -1));
    const K = d.value, { bound: Z, ignoreGap: X } = a, te = W.reduce((q, he) => he.top + he.height < 0 ? X ? he : q : he.top <= Z ? q === null ? he : he.top === q.top ? he.href === K ? he : q : he.top > q.top ? he : q : q, null);
    O || S(), te ? d.value = te.href : d.value = null;
  }
  return Zr(yp, { activeHref: d, mergedClsPrefix: Ot(a, "mergedClsPrefix"), updateBarPosition: k, setActiveHref: z, collectedLinkHrefs: i, titleEls: l }), Tn(() => {
    document.addEventListener("scroll", I, true), z(window.location.hash), R(false);
  }), ix(() => {
    z(window.location.hash), R(false);
  }), Ci(() => {
    document.removeEventListener("scroll", I, true);
  }), Kt(d, (O) => {
    if (O === null) {
      const { value: V } = h;
      V && !o.value && (V.style.maxWidth = "0");
    }
  }), { selfRef: p, barRef: g, slotRef: h, setActiveHref: z, activeHref: d, isBlockType: o, mergedShowRail: w };
}, render() {
  var a;
  const { mergedClsPrefix: i, mergedShowRail: l, isBlockType: d, $slots: h } = this, g = L("div", { class: [`${i}-anchor`, d && `${i}-anchor--block`, l && `${i}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? L("div", { ref: "slotRef", class: `${i}-anchor-link-background` }) : null, l ? L("div", { class: `${i}-anchor-rail` }, L("div", { ref: "barRef", class: [`${i}-anchor-rail__bar`, this.activeHref !== null && `${i}-anchor-rail__bar--active`] })) : null, (a = h.default) === null || a === void 0 ? void 0 : a.call(h));
  return this.internalScrollable ? L(jd, null, { default: () => g }) : g;
} }), QT = de("anchor", `
 position: relative;
`, [pn("block", `
 padding-left: var(--n-rail-width);
 `, [de("anchor-link", [Ge("+, >", [de("anchor-link", `
 margin-top: .5em;
 `)])]), de("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), pn("show-rail", [Ge(">", [de("anchor-link", "padding-left: 0;")])])]), Ue("block", [de("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ue("active", `
 background-color: var(--n-link-color);
 `)])]), de("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), de("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Ae("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ue("active", { backgroundColor: "var(--n-rail-color-active)" })])]), de("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ue("active", [Ge(">", [Ae("title", `
 color: var(--n-link-text-color-active);
 `)])]), Ae("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [Ge("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), Ge("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), eM = Object.assign(Object.assign(Object.assign(Object.assign({}, tr.props), { affix: Boolean }), Tv), Mv), Jx = ot({ name: "Anchor", props: eM, setup(a, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Ir(a), h = tr("Anchor", "-anchor", QT, UC, a, l), g = Me(null), p = De(() => {
    const { self: { railColor: w, linkColor: S, railColorActive: k, linkTextColor: I, linkTextColorHover: z, linkTextColorPressed: R, linkTextColorActive: O, linkFontSize: V, railWidth: W, linkPadding: N, borderRadius: K }, common: { cubicBezierEaseInOut: Z } } = h.value;
    return { "--n-link-border-radius": K, "--n-link-color": S, "--n-link-font-size": V, "--n-link-text-color": I, "--n-link-text-color-hover": z, "--n-link-text-color-active": O, "--n-link-text-color-pressed": R, "--n-link-padding": N, "--n-bezier": Z, "--n-rail-color": w, "--n-rail-color-active": k, "--n-rail-width": W };
  }), o = d ? hn("anchor", void 0, p, a) : void 0;
  return { scrollTo(w) {
    var S;
    (S = g.value) === null || S === void 0 || S.setActiveHref(w);
  }, renderAnchor: () => (o == null ? void 0 : o.onRender(), L(JT, Object.assign({ ref: g, style: d ? void 0 : p.value, class: o == null ? void 0 : o.themeClass.value }, Ug(a, KT), { mergedClsPrefix: l.value }), i)) };
}, render() {
  return this.affix ? L(yT, Object.assign({}, Ug(this, vT)), { default: this.renderAnchor }) : this.renderAnchor();
} }), Qx = Ai("n-input"), tM = de("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Ae("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Ae("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Ae("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), Ge("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), Ge("&:-webkit-autofill ~", [Ae("placeholder", "display: none;")])]), Ue("round", [pn("textarea", "border-radius: calc(var(--n-height) / 2);")]), Ae("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [Ge("span", `
 width: 100%;
 display: inline-block;
 `)]), Ue("textarea", [Ae("placeholder", "overflow: visible;")]), pn("autosize", "width: 100%;"), Ue("autosize", [Ae("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), de("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Ae("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Ae("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [Ge("&[type=password]::-ms-reveal", "display: none;"), Ge("+", [Ae("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), pn("textarea", [Ae("placeholder", "white-space: nowrap;")]), Ae("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ue("textarea", "width: 100%;", [de("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ue("resizable", [de("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Ae("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Ae("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ue("pair", [Ae("input-el, placeholder", "text-align: center;"), Ae("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [de("icon", `
 color: var(--n-icon-color);
 `), de("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Ae("border", "border: var(--n-border-disabled);"), Ae("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Ae("placeholder", "color: var(--n-placeholder-color-disabled);"), Ae("separator", "color: var(--n-text-color-disabled);", [de("icon", `
 color: var(--n-icon-color-disabled);
 `), de("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), de("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Ae("suffix, prefix", "color: var(--n-text-color-disabled);", [de("icon", `
 color: var(--n-icon-color-disabled);
 `), de("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), pn("disabled", [Ae("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [Ge("&:hover", `
 color: var(--n-icon-color-hover);
 `), Ge("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), Ge("&:hover", [Ae("state-border", "border: var(--n-border-hover);")]), Ue("focus", "background-color: var(--n-color-focus);", [Ae("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ae("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Ae("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Ae("prefix", "margin-right: 4px;"), Ae("suffix", `
 margin-left: 4px;
 `), Ae("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [de("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), de("base-clear", `
 font-size: var(--n-icon-size);
 `, [Ae("placeholder", [de("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), Ge(">", [de("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), de("base-icon", `
 font-size: var(--n-icon-size);
 `)]), de("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((a) => Ue(`${a}-status`, [pn("disabled", [de("base-loading", `
 color: var(--n-loading-color-${a})
 `), Ae("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${a});
 `), Ae("state-border", `
 border: var(--n-border-${a});
 `), Ge("&:hover", [Ae("state-border", `
 border: var(--n-border-hover-${a});
 `)]), Ge("&:focus", `
 background-color: var(--n-color-focus-${a});
 `, [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${a});
 border: var(--n-border-focus-${a});
 `)]), Ue("focus", `
 background-color: var(--n-color-focus-${a});
 `, [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${a});
 border: var(--n-border-focus-${a});
 `)])])]))]), rM = de("input", [Ue("disabled", [Ae("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function nM(a) {
  let i = 0;
  for (const l of a) i++;
  return i;
}
function ep(a) {
  return a === "" || a == null;
}
function iM(a) {
  const i = Me(null);
  function l() {
    const { value: g } = a;
    if (!(g == null ? void 0 : g.focus)) {
      h();
      return;
    }
    const { selectionStart: p, selectionEnd: o, value: w } = g;
    if (p == null || o == null) {
      h();
      return;
    }
    i.value = { start: p, end: o, beforeText: w.slice(0, p), afterText: w.slice(o) };
  }
  function d() {
    var g;
    const { value: p } = i, { value: o } = a;
    if (!p || !o) return;
    const { value: w } = o, { start: S, beforeText: k, afterText: I } = p;
    let z = w.length;
    if (w.endsWith(I)) z = w.length - I.length;
    else if (w.startsWith(k)) z = k.length;
    else {
      const R = k[S - 1], O = w.indexOf(R, S - 1);
      O !== -1 && (z = O + 1);
    }
    (g = o.setSelectionRange) === null || g === void 0 || g.call(o, z, z);
  }
  function h() {
    i.value = null;
  }
  return Kt(a, h), { recordCursor: l, restoreCursor: d };
}
const N_ = ot({ name: "InputWordCount", setup(a, { slots: i }) {
  const { mergedValueRef: l, maxlengthRef: d, mergedClsPrefixRef: h, countGraphemesRef: g } = hr(Qx), p = De(() => {
    const { value: o } = l;
    return o === null || Array.isArray(o) ? 0 : (g.value || nM)(o);
  });
  return () => {
    const { value: o } = d, { value: w } = l;
    return L("span", { class: `${h.value}-input-word-count` }, qg(i.default, { value: w === null || Array.isArray(w) ? "" : w }, () => [o === void 0 ? p.value : `${p.value} / ${o}`]));
  };
} }), oM = Object.assign(Object.assign({}, tr.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), yo = ot({ name: "Input", props: oM, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: h } = Ir(a), g = tr("Input", "-input", tM, qC, a, i);
  GC && tu("-input-safari", rM, i);
  const p = Me(null), o = Me(null), w = Me(null), S = Me(null), k = Me(null), I = Me(null), z = Me(null), R = iM(z), O = Me(null), { localeRef: V } = Hs("Input"), W = Me(a.defaultValue), N = Ot(a, "value"), K = wi(N, W), Z = gs(a), { mergedSizeRef: X, mergedDisabledRef: te, mergedStatusRef: q } = Z, he = Me(false), se = Me(false), Q = Me(false), oe = Me(false);
  let ve = null;
  const Be = De(() => {
    const { placeholder: ye, pair: pt } = a;
    return pt ? Array.isArray(ye) ? ye : ye === void 0 ? ["", ""] : [ye, ye] : ye === void 0 ? [V.value.placeholder] : [ye];
  }), Ne = De(() => {
    const { value: ye } = Q, { value: pt } = K, { value: Vt } = Be;
    return !ye && (ep(pt) || Array.isArray(pt) && ep(pt[0])) && Vt[0];
  }), Pe = De(() => {
    const { value: ye } = Q, { value: pt } = K, { value: Vt } = Be;
    return !ye && Vt[1] && (ep(pt) || Array.isArray(pt) && ep(pt[1]));
  }), tt = vn(() => a.internalForceFocus || he.value), at = vn(() => {
    if (te.value || a.readonly || !a.clearable || !tt.value && !se.value) return false;
    const { value: ye } = K, { value: pt } = tt;
    return a.pair ? !!(Array.isArray(ye) && (ye[0] || ye[1])) && (se.value || pt) : !!ye && (se.value || pt);
  }), xt = De(() => {
    const { showPasswordOn: ye } = a;
    if (ye) return ye;
    if (a.showPasswordToggle) return "click";
  }), ht = Me(false), Ye = De(() => {
    const { textDecoration: ye } = a;
    return ye ? Array.isArray(ye) ? ye.map((pt) => ({ textDecoration: pt })) : [{ textDecoration: ye }] : ["", ""];
  }), Ke = Me(void 0), Lt = () => {
    var ye, pt;
    if (a.type === "textarea") {
      const { autosize: Vt } = a;
      if (Vt && (Ke.value = (pt = (ye = O.value) === null || ye === void 0 ? void 0 : ye.$el) === null || pt === void 0 ? void 0 : pt.offsetWidth), !o.value || typeof Vt == "boolean") return;
      const { paddingTop: Ar, paddingBottom: Nr, lineHeight: gt } = window.getComputedStyle(o.value), pr = Number(Ar.slice(0, -2)), ur = Number(Nr.slice(0, -2)), an = Number(gt.slice(0, -2)), { value: ci } = w;
      if (!ci) return;
      if (Vt.minRows) {
        const ni = Math.max(Vt.minRows, 1), fr = `${pr + ur + an * ni}px`;
        ci.style.minHeight = fr;
      }
      if (Vt.maxRows) {
        const ni = `${pr + ur + an * Vt.maxRows}px`;
        ci.style.maxHeight = ni;
      }
    }
  }, ct = De(() => {
    const { maxlength: ye } = a;
    return ye === void 0 ? void 0 : Number(ye);
  });
  Tn(() => {
    const { value: ye } = K;
    Array.isArray(ye) || or(ye);
  });
  const bt = Qc().proxy;
  function Nt(ye, pt) {
    const { onUpdateValue: Vt, "onUpdate:value": Ar, onInput: Nr } = a, { nTriggerFormInput: gt } = Z;
    Vt && Gt(Vt, ye, pt), Ar && Gt(Ar, ye, pt), Nr && Gt(Nr, ye, pt), W.value = ye, gt();
  }
  function Yt(ye, pt) {
    const { onChange: Vt } = a, { nTriggerFormChange: Ar } = Z;
    Vt && Gt(Vt, ye, pt), W.value = ye, Ar();
  }
  function vt(ye) {
    const { onBlur: pt } = a, { nTriggerFormBlur: Vt } = Z;
    pt && Gt(pt, ye), Vt();
  }
  function jt(ye) {
    const { onFocus: pt } = a, { nTriggerFormFocus: Vt } = Z;
    pt && Gt(pt, ye), Vt();
  }
  function er(ye) {
    const { onClear: pt } = a;
    pt && Gt(pt, ye);
  }
  function yr(ye) {
    const { onInputBlur: pt } = a;
    pt && Gt(pt, ye);
  }
  function Tr(ye) {
    const { onInputFocus: pt } = a;
    pt && Gt(pt, ye);
  }
  function zr() {
    const { onDeactivate: ye } = a;
    ye && Gt(ye);
  }
  function rr() {
    const { onActivate: ye } = a;
    ye && Gt(ye);
  }
  function yt(ye) {
    const { onClick: pt } = a;
    pt && Gt(pt, ye);
  }
  function Ct(ye) {
    const { onWrapperFocus: pt } = a;
    pt && Gt(pt, ye);
  }
  function Dt(ye) {
    const { onWrapperBlur: pt } = a;
    pt && Gt(pt, ye);
  }
  function ir() {
    Q.value = true;
  }
  function ut(ye) {
    Q.value = false, ye.target === I.value ? We(ye, 1) : We(ye, 0);
  }
  function We(ye, pt = 0, Vt = "input") {
    const Ar = ye.target.value;
    if (or(Ar), ye instanceof InputEvent && !ye.isComposing && (Q.value = false), a.type === "textarea") {
      const { value: gt } = O;
      gt && gt.syncUnifiedContainer();
    }
    if (ve = Ar, Q.value) return;
    R.recordCursor();
    const Nr = kt(Ar);
    if (Nr) if (!a.pair) Vt === "input" ? Nt(Ar, { source: pt }) : Yt(Ar, { source: pt });
    else {
      let { value: gt } = K;
      Array.isArray(gt) ? gt = [gt[0], gt[1]] : gt = ["", ""], gt[pt] = Ar, Vt === "input" ? Nt(gt, { source: pt }) : Yt(gt, { source: pt });
    }
    bt.$forceUpdate(), Nr || Vi(R.restoreCursor);
  }
  function kt(ye) {
    const { countGraphemes: pt, maxlength: Vt, minlength: Ar } = a;
    if (pt) {
      let gt;
      if (Vt !== void 0 && (gt === void 0 && (gt = pt(ye)), gt > Number(Vt)) || Ar !== void 0 && (gt === void 0 && (gt = pt(ye)), gt < Number(Vt))) return false;
    }
    const { allowInput: Nr } = a;
    return typeof Nr == "function" ? Nr(ye) : true;
  }
  function et(ye) {
    yr(ye), ye.relatedTarget === p.value && zr(), ye.relatedTarget !== null && (ye.relatedTarget === k.value || ye.relatedTarget === I.value || ye.relatedTarget === o.value) || (oe.value = false), st(ye, "blur"), z.value = null;
  }
  function it(ye, pt) {
    Tr(ye), he.value = true, oe.value = true, rr(), st(ye, "focus"), pt === 0 ? z.value = k.value : pt === 1 ? z.value = I.value : pt === 2 && (z.value = o.value);
  }
  function Pt(ye) {
    a.passivelyActivated && (Dt(ye), st(ye, "blur"));
  }
  function Et(ye) {
    a.passivelyActivated && (he.value = true, Ct(ye), st(ye, "focus"));
  }
  function st(ye, pt) {
    ye.relatedTarget !== null && (ye.relatedTarget === k.value || ye.relatedTarget === I.value || ye.relatedTarget === o.value || ye.relatedTarget === p.value) || (pt === "focus" ? (jt(ye), he.value = true) : pt === "blur" && (vt(ye), he.value = false));
  }
  function St(ye, pt) {
    We(ye, pt, "change");
  }
  function ar(ye) {
    yt(ye);
  }
  function on(ye) {
    er(ye), Sn();
  }
  function Sn() {
    a.pair ? (Nt(["", ""], { source: "clear" }), Yt(["", ""], { source: "clear" })) : (Nt("", { source: "clear" }), Yt("", { source: "clear" }));
  }
  function Le(ye) {
    const { onMousedown: pt } = a;
    pt && pt(ye);
    const { tagName: Vt } = ye.target;
    if (Vt !== "INPUT" && Vt !== "TEXTAREA") {
      if (a.resizable) {
        const { value: Ar } = p;
        if (Ar) {
          const { left: Nr, top: gt, width: pr, height: ur } = Ar.getBoundingClientRect(), an = 14;
          if (Nr + pr - an < ye.clientX && ye.clientX < Nr + pr && gt + ur - an < ye.clientY && ye.clientY < gt + ur) return;
        }
      }
      ye.preventDefault(), he.value || Ve();
    }
  }
  function re() {
    var ye;
    se.value = true, a.type === "textarea" && ((ye = O.value) === null || ye === void 0 || ye.handleMouseEnterWrapper());
  }
  function ne() {
    var ye;
    se.value = false, a.type === "textarea" && ((ye = O.value) === null || ye === void 0 || ye.handleMouseLeaveWrapper());
  }
  function ae() {
    te.value || xt.value === "click" && (ht.value = !ht.value);
  }
  function be(ye) {
    if (te.value) return;
    ye.preventDefault();
    const pt = (Ar) => {
      Ar.preventDefault(), Xi("mouseup", document, pt);
    };
    if (Ei("mouseup", document, pt), xt.value !== "mousedown") return;
    ht.value = true;
    const Vt = () => {
      ht.value = false, Xi("mouseup", document, Vt);
    };
    Ei("mouseup", document, Vt);
  }
  function Ie(ye) {
    a.onKeyup && Gt(a.onKeyup, ye);
  }
  function Fe(ye) {
    switch (a.onKeydown && Gt(a.onKeydown, ye), ye.key) {
      case "Escape":
        _e();
        break;
      case "Enter":
        fe(ye);
        break;
    }
  }
  function fe(ye) {
    var pt, Vt;
    if (a.passivelyActivated) {
      const { value: Ar } = oe;
      if (Ar) {
        a.internalDeactivateOnEnter && _e();
        return;
      }
      ye.preventDefault(), a.type === "textarea" ? (pt = o.value) === null || pt === void 0 || pt.focus() : (Vt = k.value) === null || Vt === void 0 || Vt.focus();
    }
  }
  function _e() {
    a.passivelyActivated && (oe.value = false, Vi(() => {
      var ye;
      (ye = p.value) === null || ye === void 0 || ye.focus();
    }));
  }
  function Ve() {
    var ye, pt, Vt;
    te.value || (a.passivelyActivated ? (ye = p.value) === null || ye === void 0 || ye.focus() : ((pt = o.value) === null || pt === void 0 || pt.focus(), (Vt = k.value) === null || Vt === void 0 || Vt.focus()));
  }
  function nt() {
    var ye;
    !((ye = p.value) === null || ye === void 0) && ye.contains(document.activeElement) && document.activeElement.blur();
  }
  function Xe() {
    var ye, pt;
    (ye = o.value) === null || ye === void 0 || ye.select(), (pt = k.value) === null || pt === void 0 || pt.select();
  }
  function wt() {
    te.value || (o.value ? o.value.focus() : k.value && k.value.focus());
  }
  function Te() {
    const { value: ye } = p;
    (ye == null ? void 0 : ye.contains(document.activeElement)) && ye !== document.activeElement && _e();
  }
  function Ut(ye) {
    if (a.type === "textarea") {
      const { value: pt } = o;
      pt == null ? void 0 : pt.scrollTo(ye);
    } else {
      const { value: pt } = k;
      pt == null ? void 0 : pt.scrollTo(ye);
    }
  }
  function or(ye) {
    const { type: pt, pair: Vt, autosize: Ar } = a;
    if (!Vt && Ar) if (pt === "textarea") {
      const { value: Nr } = w;
      Nr && (Nr.textContent = `${ye ?? ""}\r
`);
    } else {
      const { value: Nr } = S;
      Nr && (ye ? Nr.textContent = ye : Nr.innerHTML = "&nbsp;");
    }
  }
  function Wt() {
    Lt();
  }
  const dr = Me({ top: "0" });
  function Or(ye) {
    var pt;
    const { scrollTop: Vt } = ye.target;
    dr.value.top = `${-Vt}px`, (pt = O.value) === null || pt === void 0 || pt.syncUnifiedContainer();
  }
  let Qr = null;
  zo(() => {
    const { autosize: ye, type: pt } = a;
    ye && pt === "textarea" ? Qr = Kt(K, (Vt) => {
      !Array.isArray(Vt) && Vt !== ve && or(Vt);
    }) : Qr == null ? void 0 : Qr();
  });
  let en = null;
  zo(() => {
    a.type === "textarea" ? en = Kt(K, (ye) => {
      var pt;
      !Array.isArray(ye) && ye !== ve && ((pt = O.value) === null || pt === void 0 || pt.syncUnifiedContainer());
    }) : en == null ? void 0 : en();
  }), Zr(Qx, { mergedValueRef: K, maxlengthRef: ct, mergedClsPrefixRef: i, countGraphemesRef: Ot(a, "countGraphemes") });
  const sn = { wrapperElRef: p, inputElRef: k, textareaElRef: o, isCompositing: Q, clear: Sn, focus: Ve, blur: nt, select: Xe, deactivate: Te, activate: wt, scrollTo: Ut }, _r = zi("Input", h, i), wr = De(() => {
    const { value: ye } = X, { common: { cubicBezierEaseInOut: pt }, self: { color: Vt, borderRadius: Ar, textColor: Nr, caretColor: gt, caretColorError: pr, caretColorWarning: ur, textDecorationColor: an, border: ci, borderDisabled: ni, borderHover: fr, borderFocus: Ho, placeholderColor: qi, placeholderColorDisabled: Xo, lineHeightTextarea: Si, colorDisabled: xo, colorFocus: Xr, textColorDisabled: Ji, boxShadowFocus: ii, iconSize: Gr, colorFocusWarning: Rl, boxShadowFocusWarning: ys, borderWarning: Ia, borderFocusWarning: wo, borderHoverWarning: Co, colorFocusError: Ea, boxShadowFocusError: zl, borderError: Al, borderFocusError: Yo, borderHoverError: Dl, clearSize: iu, clearColor: ou, clearColorHover: su, clearColorPressed: Ra, iconColor: Ko, iconColorDisabled: za, suffixTextColor: Aa, countTextColor: Jo, countTextColorDisabled: Da, iconColorHover: Fa, iconColorPressed: au, loadingColor: Qo, loadingColorError: _s, loadingColorWarning: Di, fontWeight: Sr, [qt("padding", ye)]: Ao, [qt("fontSize", ye)]: So, [qt("height", ye)]: Qi } } = g.value, { left: Do, right: kr } = Eo(Ao);
    return { "--n-bezier": pt, "--n-count-text-color": Jo, "--n-count-text-color-disabled": Da, "--n-color": Vt, "--n-font-size": So, "--n-font-weight": Sr, "--n-border-radius": Ar, "--n-height": Qi, "--n-padding-left": Do, "--n-padding-right": kr, "--n-text-color": Nr, "--n-caret-color": gt, "--n-text-decoration-color": an, "--n-border": ci, "--n-border-disabled": ni, "--n-border-hover": fr, "--n-border-focus": Ho, "--n-placeholder-color": qi, "--n-placeholder-color-disabled": Xo, "--n-icon-size": Gr, "--n-line-height-textarea": Si, "--n-color-disabled": xo, "--n-color-focus": Xr, "--n-text-color-disabled": Ji, "--n-box-shadow-focus": ii, "--n-loading-color": Qo, "--n-caret-color-warning": ur, "--n-color-focus-warning": Rl, "--n-box-shadow-focus-warning": ys, "--n-border-warning": Ia, "--n-border-focus-warning": wo, "--n-border-hover-warning": Co, "--n-loading-color-warning": Di, "--n-caret-color-error": pr, "--n-color-focus-error": Ea, "--n-box-shadow-focus-error": zl, "--n-border-error": Al, "--n-border-focus-error": Yo, "--n-border-hover-error": Dl, "--n-loading-color-error": _s, "--n-clear-color": ou, "--n-clear-size": iu, "--n-clear-color-hover": su, "--n-clear-color-pressed": Ra, "--n-icon-color": Ko, "--n-icon-color-hover": Fa, "--n-icon-color-pressed": au, "--n-icon-color-disabled": za, "--n-suffix-text-color": Aa };
  }), Hr = d ? hn("input", De(() => {
    const { value: ye } = X;
    return ye[0];
  }), wr, a) : void 0;
  return Object.assign(Object.assign({}, sn), { wrapperElRef: p, inputElRef: k, inputMirrorElRef: S, inputEl2Ref: I, textareaElRef: o, textareaMirrorElRef: w, textareaScrollbarInstRef: O, rtlEnabled: _r, uncontrolledValue: W, mergedValue: K, passwordVisible: ht, mergedPlaceholder: Be, showPlaceholder1: Ne, showPlaceholder2: Pe, mergedFocus: tt, isComposing: Q, activated: oe, showClearButton: at, mergedSize: X, mergedDisabled: te, textDecorationStyle: Ye, mergedClsPrefix: i, mergedBordered: l, mergedShowPasswordOn: xt, placeholderStyle: dr, mergedStatus: q, textAreaScrollContainerWidth: Ke, handleTextAreaScroll: Or, handleCompositionStart: ir, handleCompositionEnd: ut, handleInput: We, handleInputBlur: et, handleInputFocus: it, handleWrapperBlur: Pt, handleWrapperFocus: Et, handleMouseEnter: re, handleMouseLeave: ne, handleMouseDown: Le, handleChange: St, handleClick: ar, handleClear: on, handlePasswordToggleClick: ae, handlePasswordToggleMousedown: be, handleWrapperKeydown: Fe, handleWrapperKeyup: Ie, handleTextAreaMirrorResize: Wt, getTextareaScrollContainer: () => o.value, mergedTheme: g, cssVars: d ? void 0 : wr, themeClass: Hr == null ? void 0 : Hr.themeClass, onRender: Hr == null ? void 0 : Hr.onRender });
}, render() {
  var a, i;
  const { mergedClsPrefix: l, mergedStatus: d, themeClass: h, type: g, countGraphemes: p, onRender: o } = this, w = this.$slots;
  return o == null ? void 0 : o(), L("div", { ref: "wrapperElRef", class: [`${l}-input`, h, d && `${l}-input--${d}-status`, { [`${l}-input--rtl`]: this.rtlEnabled, [`${l}-input--disabled`]: this.mergedDisabled, [`${l}-input--textarea`]: g === "textarea", [`${l}-input--resizable`]: this.resizable && !this.autosize, [`${l}-input--autosize`]: this.autosize, [`${l}-input--round`]: this.round && g !== "textarea", [`${l}-input--pair`]: this.pair, [`${l}-input--focus`]: this.mergedFocus, [`${l}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, L("div", { class: `${l}-input-wrapper` }, dn(w.prefix, (S) => S && L("div", { class: `${l}-input__prefix` }, S)), g === "textarea" ? L(jd, { ref: "textareaScrollbarInstRef", class: `${l}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var S, k;
    const { textAreaScrollContainerWidth: I } = this, z = { width: this.autosize && I && `${I}px` };
    return L(qr, null, L("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${l}-input__textarea-el`, (S = this.inputProps) === null || S === void 0 ? void 0 : S.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (k = this.inputProps) === null || k === void 0 ? void 0 : k.style, z], onBlur: this.handleInputBlur, onFocus: (R) => {
      this.handleInputFocus(R, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? L("div", { class: `${l}-input__placeholder`, style: [this.placeholderStyle, z], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? L(xl, { onResize: this.handleTextAreaMirrorResize }, { default: () => L("div", { ref: "textareaMirrorElRef", class: `${l}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : L("div", { class: `${l}-input__input` }, L("input", Object.assign({ type: g === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : g }, this.inputProps, { ref: "inputElRef", class: [`${l}-input__input-el`, (a = this.inputProps) === null || a === void 0 ? void 0 : a.class], style: [this.textDecorationStyle[0], (i = this.inputProps) === null || i === void 0 ? void 0 : i.style], tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (S) => {
    this.handleInputFocus(S, 0);
  }, onInput: (S) => {
    this.handleInput(S, 0);
  }, onChange: (S) => {
    this.handleChange(S, 0);
  } })), this.showPlaceholder1 ? L("div", { class: `${l}-input__placeholder` }, L("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? L("div", { class: `${l}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && dn(w.suffix, (S) => S || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? L("div", { class: `${l}-input__suffix` }, [dn(w["clear-icon-placeholder"], (k) => (this.clearable || k) && L(Qg, { clsPrefix: l, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => k, icon: () => {
    var I, z;
    return (z = (I = this.$slots)["clear-icon"]) === null || z === void 0 ? void 0 : z.call(I);
  } })), this.internalLoadingBeforeSuffix ? null : S, this.loading !== void 0 ? L(Kx, { clsPrefix: l, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? S : null, this.showCount && this.type !== "textarea" ? L(N_, null, { default: (k) => {
    var I;
    const { renderCount: z } = this;
    return z ? z(k) : (I = w.count) === null || I === void 0 ? void 0 : I.call(w, k);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? L("div", { class: `${l}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Ui(w["password-visible-icon"], () => [L(Ur, { clsPrefix: l }, { default: () => L(Xx, null) })]) : Ui(w["password-invisible-icon"], () => [L(Ur, { clsPrefix: l }, { default: () => L(PT, null) })])) : null]) : null)), this.pair ? L("span", { class: `${l}-input__separator` }, Ui(w.separator, () => [this.separator])) : null, this.pair ? L("div", { class: `${l}-input-wrapper` }, L("div", { class: `${l}-input__input` }, L("input", { ref: "inputEl2Ref", type: this.type, class: `${l}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (S) => {
    this.handleInputFocus(S, 1);
  }, onInput: (S) => {
    this.handleInput(S, 1);
  }, onChange: (S) => {
    this.handleChange(S, 1);
  } }), this.showPlaceholder2 ? L("div", { class: `${l}-input__placeholder` }, L("span", null, this.mergedPlaceholder[1])) : null), dn(w.suffix, (S) => (this.clearable || S) && L("div", { class: `${l}-input__suffix` }, [this.clearable && L(Qg, { clsPrefix: l, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var k;
    return (k = w["clear-icon"]) === null || k === void 0 ? void 0 : k.call(w);
  }, placeholder: () => {
    var k;
    return (k = w["clear-icon-placeholder"]) === null || k === void 0 ? void 0 : k.call(w);
  } }), S]))) : null, this.mergedBordered ? L("div", { class: `${l}-input__border` }) : null, this.mergedBordered ? L("div", { class: `${l}-input__state-border` }) : null, this.showCount && g === "textarea" ? L(N_, null, { default: (S) => {
    var k;
    const { renderCount: I } = this;
    return I ? I(S) : (k = w.count) === null || k === void 0 ? void 0 : k.call(w, S);
  } }) : null);
} }), sM = de("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [Ge(">", [de("input", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), de("button", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ae("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ae("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), Ge("*", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ge(">", [de("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), de("base-selection", [de("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), de("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ae("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), Ge("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ge(">", [de("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), de("base-selection", [de("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), de("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Ae("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), aM = {}, lM = ot({ name: "InputGroup", props: aM, setup(a) {
  const { mergedClsPrefixRef: i } = Ir(a);
  return tu("-input-group", sM, i), { mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: a } = this;
  return L("div", { class: `${a}-input-group` }, this.$slots);
} });
function Ip(a) {
  return a.type === "group";
}
function e1(a) {
  return a.type === "ignored";
}
function gm(a, i) {
  try {
    return !!(1 + i.toString().toLowerCase().indexOf(a.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function cM(a, i) {
  return { getIsGroup: Ip, getIgnored: e1, getKey(d) {
    return Ip(d) ? d.name || d.key || "key-required" : d[a];
  }, getChildren(d) {
    return d[i];
  } };
}
function uM(a, i, l, d) {
  if (!i) return a;
  function h(g) {
    if (!Array.isArray(g)) return [];
    const p = [];
    for (const o of g) if (Ip(o)) {
      const w = h(o[d]);
      w.length && p.push(Object.assign({}, o, { [d]: w }));
    } else {
      if (e1(o)) continue;
      i(l, o) && p.push(o);
    }
    return p;
  }
  return h(a);
}
function dM(a, i, l) {
  const d = /* @__PURE__ */ new Map();
  return a.forEach((h) => {
    Ip(h) ? h[l].forEach((g) => {
      d.set(g[i], g);
    }) : d.set(h[i], h);
  }), d;
}
const hM = Vp && "loading" in document.createElement("img");
function pM(a = {}) {
  var i;
  const { root: l = null } = a;
  return { hash: `${a.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(a.threshold) ? a.threshold.join(",") : (i = a.threshold) !== null && i !== void 0 ? i : "0"}`, options: Object.assign(Object.assign({}, a), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const vm = /* @__PURE__ */ new WeakMap(), ym = /* @__PURE__ */ new WeakMap(), _m = /* @__PURE__ */ new WeakMap(), fM = (a, i, l) => {
  if (!a) return () => {
  };
  const d = pM(i), { root: h } = d.options;
  let g;
  const p = vm.get(h);
  p ? g = p : (g = /* @__PURE__ */ new Map(), vm.set(h, g));
  let o, w;
  g.has(d.hash) ? (w = g.get(d.hash), w[1].has(a) || (o = w[0], w[1].add(a), o.observe(a))) : (o = new IntersectionObserver((I) => {
    I.forEach((z) => {
      if (z.isIntersecting) {
        const R = ym.get(z.target), O = _m.get(z.target);
        R && R(), O && (O.value = true);
      }
    });
  }, d.options), o.observe(a), w = [o, /* @__PURE__ */ new Set([a])], g.set(d.hash, w));
  let S = false;
  const k = () => {
    S || (ym.delete(a), _m.delete(a), S = true, w[1].has(a) && (w[0].unobserve(a), w[1].delete(a)), w[1].size <= 0 && g.delete(d.hash), g.size || vm.delete(h));
  };
  return ym.set(a, k), _m.set(a, l), k;
}, Pn = "0!important", t1 = "-1px!important";
function Lc(a) {
  return Ue(`${a}-type`, [Ge("& +", [de("button", {}, [Ue(`${a}-type`, [Ae("border", { borderLeftWidth: Pn }), Ae("state-border", { left: t1 })])])])]);
}
function Bc(a) {
  return Ue(`${a}-type`, [Ge("& +", [de("button", [Ue(`${a}-type`, [Ae("border", { borderTopWidth: Pn }), Ae("state-border", { top: t1 })])])])]);
}
const mM = de("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [pn("vertical", { flexDirection: "row" }, [pn("rtl", [de("button", [Ge("&:first-child:not(:last-child)", `
 margin-right: ${Pn};
 border-top-right-radius: ${Pn};
 border-bottom-right-radius: ${Pn};
 `), Ge("&:last-child:not(:first-child)", `
 margin-left: ${Pn};
 border-top-left-radius: ${Pn};
 border-bottom-left-radius: ${Pn};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin-left: ${Pn};
 margin-right: ${Pn};
 border-radius: ${Pn};
 `), Lc("default"), Ue("ghost", [Lc("primary"), Lc("info"), Lc("success"), Lc("warning"), Lc("error")])])])]), Ue("vertical", { flexDirection: "column" }, [de("button", [Ge("&:first-child:not(:last-child)", `
 margin-bottom: ${Pn};
 margin-left: ${Pn};
 margin-right: ${Pn};
 border-bottom-left-radius: ${Pn};
 border-bottom-right-radius: ${Pn};
 `), Ge("&:last-child:not(:first-child)", `
 margin-top: ${Pn};
 margin-left: ${Pn};
 margin-right: ${Pn};
 border-top-left-radius: ${Pn};
 border-top-right-radius: ${Pn};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin: ${Pn};
 border-radius: ${Pn};
 `), Bc("default"), Ue("ghost", [Bc("primary"), Bc("info"), Bc("success"), Bc("warning"), Bc("error")])])])]), gM = { size: { type: String, default: void 0 }, vertical: Boolean }, vM = ot({ name: "ButtonGroup", props: gM, setup(a) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Ir(a);
  return tu("-button-group", mM, i), Zr(WC, a), { rtlEnabled: zi("ButtonGroup", l, i), mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: a } = this;
  return L("div", { class: [`${a}-button-group`, this.rtlEnabled && `${a}-button-group--rtl`, this.vertical && `${a}-button-group--vertical`], role: "group" }, this.$slots);
} }), yM = Ai("n-checkbox-group"), _M = () => L("svg", { viewBox: "0 0 64 64", class: "check-icon" }, L("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), bM = () => L("svg", { viewBox: "0 0 100 100", class: "line-icon" }, L("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), xM = Ge([de("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ue("show-label", "line-height: var(--n-label-line-height);"), Ge("&:hover", [de("checkbox-box", [Ae("border", "border: var(--n-border-checked);")])]), Ge("&:focus:not(:active)", [de("checkbox-box", [Ae("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ue("inside-table", [de("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ue("checked", [de("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [de("checkbox-icon", [Ge(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("indeterminate", [de("checkbox-box", [de("checkbox-icon", [Ge(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), Ge(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("checked, indeterminate", [Ge("&:focus:not(:active)", [de("checkbox-box", [Ae("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), de("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Ae("border", { border: "var(--n-border-checked)" })])]), Ue("disabled", { cursor: "not-allowed" }, [Ue("checked", [de("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Ae("border", { border: "var(--n-border-disabled-checked)" }), de("checkbox-icon", [Ge(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), de("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Ae("border", `
 border: var(--n-border-disabled);
 `), de("checkbox-icon", [Ge(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Ae("label", `
 color: var(--n-text-color-disabled);
 `)]), de("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), de("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Ae("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), de("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [Ge(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Rd({ left: "1px", top: "1px" })])]), Ae("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [Ge("&:empty", { display: "none" })])]), ox(de("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), sx(de("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), wM = Object.assign(Object.assign({}, tr.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), CM = ot({ name: "Checkbox", props: wM, setup(a) {
  const i = hr(yM, null), l = Me(null), { mergedClsPrefixRef: d, inlineThemeDisabled: h, mergedRtlRef: g } = Ir(a), p = Me(a.defaultChecked), o = Ot(a, "checked"), w = wi(o, p), S = vn(() => {
    if (i) {
      const q = i.valueSetRef.value;
      return q && a.value !== void 0 ? q.has(a.value) : false;
    } else return w.value === a.checkedValue;
  }), k = gs(a, { mergedSize(q) {
    const { size: he } = a;
    if (he !== void 0) return he;
    if (i) {
      const { value: se } = i.mergedSizeRef;
      if (se !== void 0) return se;
    }
    if (q) {
      const { mergedSize: se } = q;
      if (se !== void 0) return se.value;
    }
    return "medium";
  }, mergedDisabled(q) {
    const { disabled: he } = a;
    if (he !== void 0) return he;
    if (i) {
      if (i.disabledRef.value) return true;
      const { maxRef: { value: se }, checkedCountRef: Q } = i;
      if (se !== void 0 && Q.value >= se && !S.value) return true;
      const { minRef: { value: oe } } = i;
      if (oe !== void 0 && Q.value <= oe && S.value) return true;
    }
    return q ? q.disabled.value : false;
  } }), { mergedDisabledRef: I, mergedSizeRef: z } = k, R = tr("Checkbox", "-checkbox", xM, ZC, a, d);
  function O(q) {
    if (i && a.value !== void 0) i.toggleCheckbox(!S.value, a.value);
    else {
      const { onChange: he, "onUpdate:checked": se, onUpdateChecked: Q } = a, { nTriggerFormInput: oe, nTriggerFormChange: ve } = k, Be = S.value ? a.uncheckedValue : a.checkedValue;
      se && Gt(se, Be, q), Q && Gt(Q, Be, q), he && Gt(he, Be, q), oe(), ve(), p.value = Be;
    }
  }
  function V(q) {
    I.value || O(q);
  }
  function W(q) {
    if (!I.value) switch (q.key) {
      case " ":
      case "Enter":
        O(q);
    }
  }
  function N(q) {
    switch (q.key) {
      case " ":
        q.preventDefault();
    }
  }
  const K = { focus: () => {
    var q;
    (q = l.value) === null || q === void 0 || q.focus();
  }, blur: () => {
    var q;
    (q = l.value) === null || q === void 0 || q.blur();
  } }, Z = zi("Checkbox", g, d), X = De(() => {
    const { value: q } = z, { common: { cubicBezierEaseInOut: he }, self: { borderRadius: se, color: Q, colorChecked: oe, colorDisabled: ve, colorTableHeader: Be, colorTableHeaderModal: Ne, colorTableHeaderPopover: Pe, checkMarkColor: tt, checkMarkColorDisabled: at, border: xt, borderFocus: ht, borderDisabled: Ye, borderChecked: Ke, boxShadowFocus: Lt, textColor: ct, textColorDisabled: bt, checkMarkColorDisabledChecked: Nt, colorDisabledChecked: Yt, borderDisabledChecked: vt, labelPadding: jt, labelLineHeight: er, labelFontWeight: yr, [qt("fontSize", q)]: Tr, [qt("size", q)]: zr } } = R.value;
    return { "--n-label-line-height": er, "--n-label-font-weight": yr, "--n-size": zr, "--n-bezier": he, "--n-border-radius": se, "--n-border": xt, "--n-border-checked": Ke, "--n-border-focus": ht, "--n-border-disabled": Ye, "--n-border-disabled-checked": vt, "--n-box-shadow-focus": Lt, "--n-color": Q, "--n-color-checked": oe, "--n-color-table": Be, "--n-color-table-modal": Ne, "--n-color-table-popover": Pe, "--n-color-disabled": ve, "--n-color-disabled-checked": Yt, "--n-text-color": ct, "--n-text-color-disabled": bt, "--n-check-mark-color": tt, "--n-check-mark-color-disabled": at, "--n-check-mark-color-disabled-checked": Nt, "--n-font-size": Tr, "--n-label-padding": jt };
  }), te = h ? hn("checkbox", De(() => z.value[0]), X, a) : void 0;
  return Object.assign(k, K, { rtlEnabled: Z, selfRef: l, mergedClsPrefix: d, mergedDisabled: I, renderedChecked: S, mergedTheme: R, labelId: Tl(), handleClick: V, handleKeyUp: W, handleKeyDown: N, cssVars: h ? void 0 : X, themeClass: te == null ? void 0 : te.themeClass, onRender: te == null ? void 0 : te.onRender });
}, render() {
  var a;
  const { $slots: i, renderedChecked: l, mergedDisabled: d, indeterminate: h, privateInsideTable: g, cssVars: p, labelId: o, label: w, mergedClsPrefix: S, focusable: k, handleKeyUp: I, handleKeyDown: z, handleClick: R } = this;
  (a = this.onRender) === null || a === void 0 || a.call(this);
  const O = dn(i.default, (V) => w || V ? L("span", { class: `${S}-checkbox__label`, id: o }, w || V) : null);
  return L("div", { ref: "selfRef", class: [`${S}-checkbox`, this.themeClass, this.rtlEnabled && `${S}-checkbox--rtl`, l && `${S}-checkbox--checked`, d && `${S}-checkbox--disabled`, h && `${S}-checkbox--indeterminate`, g && `${S}-checkbox--inside-table`, O && `${S}-checkbox--show-label`], tabindex: d || !k ? void 0 : 0, role: "checkbox", "aria-checked": h ? "mixed" : l, "aria-labelledby": o, style: p, onKeyup: I, onKeydown: z, onClick: R, onMousedown: () => {
    Ei("selectstart", window, (V) => {
      V.preventDefault();
    }, { once: true });
  } }, L("div", { class: `${S}-checkbox-box-wrapper` }, "\xA0", L("div", { class: `${S}-checkbox-box` }, L(Lp, null, { default: () => this.indeterminate ? L("div", { key: "indeterminate", class: `${S}-checkbox-icon` }, bM()) : L("div", { key: "check", class: `${S}-checkbox-icon` }, _M()) }), L("div", { class: `${S}-checkbox-box__border` }))), O);
} }), SM = de("collapse", "width: 100%;", [de("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ue("disabled", [Ae("header", "cursor: not-allowed;", [Ae("header-main", `
 color: var(--n-title-text-color-disabled);
 `), de("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), de("collapse-item", "margin-left: 32px;"), Ge("&:first-child", "margin-top: 0;"), Ge("&:first-child >", [Ae("header", "padding-top: 0;")]), Ue("left-arrow-placement", [Ae("header", [de("collapse-item-arrow", "margin-right: 4px;")])]), Ue("right-arrow-placement", [Ae("header", [de("collapse-item-arrow", "margin-left: 4px;")])]), Ae("content-wrapper", [Ae("content-inner", "padding-top: 16px;"), Sp({ duration: "0.15s" })]), Ue("active", [Ae("header", [Ue("active", [de("collapse-item-arrow", "transform: rotate(90deg);")])])]), Ge("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), pn("disabled", [Ue("trigger-area-main", [Ae("header", [Ae("header-main", "cursor: pointer;"), de("collapse-item-arrow", "cursor: default;")])]), Ue("trigger-area-arrow", [Ae("header", [de("collapse-item-arrow", "cursor: pointer;")])]), Ue("trigger-area-extra", [Ae("header", [Ae("header-extra", "cursor: pointer;")])])]), Ae("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Ae("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Ae("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), de("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), kM = Object.assign(Object.assign({}, tr.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), r1 = Ai("n-collapse"), V_ = ot({ name: "Collapse", props: kM, slots: Object, setup(a, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d, mergedRtlRef: h } = Ir(a), g = Me(a.defaultExpandedNames), p = De(() => a.expandedNames), o = wi(p, g), w = tr("Collapse", "-collapse", SM, HC, a, l);
  function S(V) {
    const { "onUpdate:expandedNames": W, onUpdateExpandedNames: N, onExpandedNamesChange: K } = a;
    N && Gt(N, V), W && Gt(W, V), K && Gt(K, V), g.value = V;
  }
  function k(V) {
    const { onItemHeaderClick: W } = a;
    W && Gt(W, V);
  }
  function I(V, W, N) {
    const { accordion: K } = a, { value: Z } = o;
    if (K) V ? (S([W]), k({ name: W, expanded: true, event: N })) : (S([]), k({ name: W, expanded: false, event: N }));
    else if (!Array.isArray(Z)) S([W]), k({ name: W, expanded: true, event: N });
    else {
      const X = Z.slice(), te = X.findIndex((q) => W === q);
      ~te ? (X.splice(te, 1), S(X), k({ name: W, expanded: false, event: N })) : (X.push(W), S(X), k({ name: W, expanded: true, event: N }));
    }
  }
  Zr(r1, { props: a, mergedClsPrefixRef: l, expandedNamesRef: o, slots: i, toggleItem: I });
  const z = zi("Collapse", h, l), R = De(() => {
    const { common: { cubicBezierEaseInOut: V }, self: { titleFontWeight: W, dividerColor: N, titlePadding: K, titleTextColor: Z, titleTextColorDisabled: X, textColor: te, arrowColor: q, fontSize: he, titleFontSize: se, arrowColorDisabled: Q, itemMargin: oe } } = w.value;
    return { "--n-font-size": he, "--n-bezier": V, "--n-text-color": te, "--n-divider-color": N, "--n-title-padding": K, "--n-title-font-size": se, "--n-title-text-color": Z, "--n-title-text-color-disabled": X, "--n-title-font-weight": W, "--n-arrow-color": q, "--n-arrow-color-disabled": Q, "--n-item-margin": oe };
  }), O = d ? hn("collapse", void 0, R, a) : void 0;
  return { rtlEnabled: z, mergedTheme: w, mergedClsPrefix: l, cssVars: d ? void 0 : R, themeClass: O == null ? void 0 : O.themeClass, onRender: O == null ? void 0 : O.onRender };
}, render() {
  var a;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), PM = ot({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(a) {
  return { onceTrue: XC(Ot(a, "show")) };
}, render() {
  return L(jp, null, { default: () => {
    const { show: a, displayDirective: i, onceTrue: l, clsPrefix: d } = this, h = i === "show" && l, g = L("div", { class: `${d}-collapse-item__content-wrapper` }, L("div", { class: `${d}-collapse-item__content-inner` }, this.$slots));
    return h ? fs(g, [[Gs, a]]) : a ? g : null;
  } });
} }), TM = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, U_ = ot({ name: "CollapseItem", props: TM, setup(a) {
  const { mergedRtlRef: i } = Ir(a), l = Tl(), d = vn(() => {
    var I;
    return (I = a.name) !== null && I !== void 0 ? I : l;
  }), h = hr(r1);
  h || vs("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: g, props: p, mergedClsPrefixRef: o, slots: w } = h, S = De(() => {
    const { value: I } = g;
    if (Array.isArray(I)) {
      const { value: z } = d;
      return !~I.findIndex((R) => R === z);
    } else if (I) {
      const { value: z } = d;
      return z !== I;
    }
    return true;
  });
  return { rtlEnabled: zi("Collapse", i, o), collapseSlots: w, randomName: l, mergedClsPrefix: o, collapsed: S, triggerAreas: Ot(p, "triggerAreas"), mergedDisplayDirective: De(() => {
    const { displayDirective: I } = a;
    return I || p.displayDirective;
  }), arrowPlacement: De(() => p.arrowPlacement), handleClick(I) {
    let z = "main";
    wl(I, "arrow") && (z = "arrow"), wl(I, "extra") && (z = "extra"), p.triggerAreas.includes(z) && h && !a.disabled && h.toggleItem(S.value, d.value, I);
  } };
}, render() {
  const { collapseSlots: a, $slots: i, arrowPlacement: l, collapsed: d, mergedDisplayDirective: h, mergedClsPrefix: g, disabled: p, triggerAreas: o } = this, w = qg(i.header, { collapsed: d }, () => [this.title]), S = i["header-extra"] || a["header-extra"], k = i.arrow || a.arrow;
  return L("div", { class: [`${g}-collapse-item`, `${g}-collapse-item--${l}-arrow-placement`, p && `${g}-collapse-item--disabled`, !d && `${g}-collapse-item--active`, o.map((I) => `${g}-collapse-item--trigger-area-${I}`)] }, L("div", { class: [`${g}-collapse-item__header`, !d && `${g}-collapse-item__header--active`] }, L("div", { class: `${g}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && w, L("div", { class: `${g}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, qg(k, { collapsed: d }, () => [L(Ur, { clsPrefix: g }, { default: () => this.rtlEnabled ? L(CT, null) : L(YC, null) })])), l === "left" && w), KC(S, { collapsed: d }, (I) => L("div", { class: `${g}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, I))), L(PM, { clsPrefix: g, displayDirective: h, show: !d }, i));
} });
function MM(a, i) {
  switch (a[0]) {
    case "hex":
      return i ? "#000000FF" : "#000000";
    case "rgb":
      return i ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return i ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return i ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function Fd(a) {
  return a === null ? null : /^ *#/.test(a) ? "hex" : a.includes("rgb") ? "rgb" : a.includes("hsl") ? "hsl" : a.includes("hsv") ? "hsv" : null;
}
function IM(a) {
  return a = Math.round(a), a >= 360 ? 359 : a < 0 ? 0 : a;
}
function EM(a) {
  return a = Math.round(a * 100) / 100, a > 1 ? 1 : a < 0 ? 0 : a;
}
const RM = { rgb: { hex(a) {
  return wa(ds(a));
}, hsl(a) {
  const [i, l, d, h] = ds(a);
  return xa([...Zg(i, l, d), h]);
}, hsv(a) {
  const [i, l, d, h] = ds(a);
  return Sl([...Wg(i, l, d), h]);
} }, hex: { rgb(a) {
  return Vs(ds(a));
}, hsl(a) {
  const [i, l, d, h] = ds(a);
  return xa([...Zg(i, l, d), h]);
}, hsv(a) {
  const [i, l, d, h] = ds(a);
  return Sl([...Wg(i, l, d), h]);
} }, hsl: { hex(a) {
  const [i, l, d, h] = Gc(a);
  return wa([...Gg(i, l, d), h]);
}, rgb(a) {
  const [i, l, d, h] = Gc(a);
  return Vs([...Gg(i, l, d), h]);
}, hsv(a) {
  const [i, l, d, h] = Gc(a);
  return Sl([...ax(i, l, d), h]);
} }, hsv: { hex(a) {
  const [i, l, d, h] = Cl(a);
  return wa([..._a(i, l, d), h]);
}, rgb(a) {
  const [i, l, d, h] = Cl(a);
  return Vs([..._a(i, l, d), h]);
}, hsl(a) {
  const [i, l, d, h] = Cl(a);
  return xa([...mp(i, l, d), h]);
} } };
function n1(a, i, l) {
  return l = l || Fd(a), l ? l === i ? a : RM[l][i](a) : null;
}
const fd = "12px", zM = 12, fl = "6px", AM = ot({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(a) {
  const i = Me(null);
  function l(g) {
    !i.value || !a.rgba || (Ei("mousemove", document, d), Ei("mouseup", document, h), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: o, left: w } = p.getBoundingClientRect(), S = (g.clientX - w) / (o - zM);
    a.onUpdateAlpha(EM(S));
  }
  function h() {
    var g;
    Xi("mousemove", document, d), Xi("mouseup", document, h), (g = a.onComplete) === null || g === void 0 || g.call(a);
  }
  return { railRef: i, railBackgroundImage: De(() => {
    const { rgba: g } = a;
    return g ? `linear-gradient(to right, rgba(${g[0]}, ${g[1]}, ${g[2]}, 0) 0%, rgba(${g[0]}, ${g[1]}, ${g[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-color-picker-slider`, ref: "railRef", style: { height: fd, borderRadius: fl }, onMousedown: this.handleMouseDown }, L("div", { style: { borderRadius: fl, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, L("div", { class: `${a}-color-picker-checkboard` }), L("div", { class: `${a}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && L("div", { style: { position: "absolute", left: fl, right: fl, top: 0, bottom: 0 } }, L("div", { class: `${a}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${fl})`, borderRadius: fl, width: fd, height: fd } }, L("div", { class: `${a}-color-picker-handle__fill`, style: { backgroundColor: Vs(this.rgba), borderRadius: fl, width: fd, height: fd } }))));
} }), Iv = Ai("n-color-picker");
function DM(a) {
  return /^\d{1,3}\.?\d*$/.test(a.trim()) ? Math.max(0, Math.min(Number.parseInt(a), 255)) : false;
}
function FM(a) {
  return /^\d{1,3}\.?\d*$/.test(a.trim()) ? Math.max(0, Math.min(Number.parseInt(a), 360)) : false;
}
function LM(a) {
  return /^\d{1,3}\.?\d*$/.test(a.trim()) ? Math.max(0, Math.min(Number.parseInt(a), 100)) : false;
}
function BM(a) {
  const i = a.trim();
  return /^#[0-9a-fA-F]+$/.test(i) ? [4, 5, 7, 9].includes(i.length) : false;
}
function OM(a) {
  return /^\d{1,3}\.?\d*%$/.test(a.trim()) ? Math.max(0, Math.min(Number.parseInt(a) / 100, 100)) : false;
}
const $M = { paddingSmall: "0 4px" }, q_ = ot({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(a) {
  const i = Me(""), { themeRef: l } = hr(Iv, null);
  zo(() => {
    i.value = d();
  });
  function d() {
    const { value: p } = a;
    if (p === null) return "";
    const { label: o } = a;
    return o === "HEX" ? p : o === "A" ? `${Math.floor(p * 100)}%` : String(Math.floor(p));
  }
  function h(p) {
    i.value = p;
  }
  function g(p) {
    let o, w;
    switch (a.label) {
      case "HEX":
        w = BM(p), w && a.onUpdateValue(p), i.value = d();
        break;
      case "H":
        o = FM(p), o === false ? i.value = d() : a.onUpdateValue(o);
        break;
      case "S":
      case "L":
      case "V":
        o = LM(p), o === false ? i.value = d() : a.onUpdateValue(o);
        break;
      case "A":
        o = OM(p), o === false ? i.value = d() : a.onUpdateValue(o);
        break;
      case "R":
      case "G":
      case "B":
        o = DM(p), o === false ? i.value = d() : a.onUpdateValue(o);
        break;
    }
  }
  return { mergedTheme: l, inputValue: i, handleInputChange: g, handleInputUpdateValue: h };
}, render() {
  const { mergedTheme: a } = this;
  return L(yo, { size: "small", placeholder: this.label, theme: a.peers.Input, themeOverrides: a.peerOverrides.Input, builtinThemeOverrides: $M, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), jM = ot({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(a) {
  return { handleUnitUpdateValue(i, l) {
    const { showAlpha: d } = a;
    if (a.mode === "hex") {
      a.onUpdateValue((d ? wa : Cd)(l));
      return;
    }
    let h;
    switch (a.valueArr === null ? h = [0, 0, 0, 0] : h = Array.from(a.valueArr), a.mode) {
      case "hsv":
        h[i] = l, a.onUpdateValue((d ? Sl : Yg)(h));
        break;
      case "rgb":
        h[i] = l, a.onUpdateValue((d ? Vs : Xg)(h));
        break;
      case "hsl":
        h[i] = l, a.onUpdateValue((d ? xa : Hg)(h));
        break;
    }
  } };
}, render() {
  const { clsPrefix: a, modes: i } = this;
  return L("div", { class: `${a}-color-picker-input` }, L("div", { class: `${a}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: i.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), L(lM, null, { default: () => {
    const { mode: l, valueArr: d, showAlpha: h } = this;
    if (l === "hex") {
      let g = null;
      try {
        g = d === null ? null : (h ? wa : Cd)(d);
      } catch {
      }
      return L(q_, { label: "HEX", showAlpha: h, value: g, onUpdateValue: (p) => {
        this.handleUnitUpdateValue(0, p);
      } });
    }
    return (l + (h ? "a" : "")).split("").map((g, p) => L(q_, { label: g.toUpperCase(), value: d === null ? null : d[p], onUpdateValue: (o) => {
      this.handleUnitUpdateValue(p, o);
    } }));
  } }));
} });
function NM(a, i) {
  if (i === "hsv") {
    const [l, d, h, g] = Cl(a);
    return Vs([..._a(l, d, h), g]);
  }
  return a;
}
function VM(a) {
  const i = document.createElement("canvas").getContext("2d");
  return i ? (i.fillStyle = a, i.fillStyle) : "#000000";
}
const UM = ot({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(a) {
  const i = De(() => a.swatches.map((g) => {
    const p = Fd(g);
    return { value: g, mode: p, legalValue: NM(g, p) };
  }));
  function l(g) {
    const { mode: p } = a;
    let { value: o, mode: w } = g;
    return w || (w = "hex", /^[a-zA-Z]+$/.test(o) ? o = VM(o) : (kp("color-picker", `color ${o} in swatches is invalid.`), o = "#000000")), w === p ? o : n1(o, p, w);
  }
  function d(g) {
    a.onUpdateColor(l(g));
  }
  function h(g, p) {
    g.key === "Enter" && d(p);
  }
  return { parsedSwatchesRef: i, handleSwatchSelect: d, handleSwatchKeyDown: h };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-color-picker-swatches` }, this.parsedSwatchesRef.map((i) => L("div", { class: `${a}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(i);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, i);
  } }, L("div", { class: `${a}-color-picker-swatch__fill`, style: { background: i.legalValue } }))));
} }), qM = ot({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(a) {
  const { colorPickerSlots: i, renderLabelRef: l } = hr(Iv, null);
  return () => {
    const { hsla: d, value: h, clsPrefix: g, onClick: p, disabled: o } = a, w = i.label || l.value;
    return L("div", { class: [`${g}-color-picker-trigger`, o && `${g}-color-picker-trigger--disabled`], onClick: o ? void 0 : p }, L("div", { class: `${g}-color-picker-trigger__fill` }, L("div", { class: `${g}-color-picker-checkboard` }), L("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: d ? xa(d) : "" } }), h && d ? L("div", { class: `${g}-color-picker-trigger__value`, style: { color: d[2] > 50 || d[3] < 0.5 ? "black" : "white" } }, w ? w(h) : h) : null));
  };
} }), GM = ot({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (a) => {
  const i = Fd(a);
  return !!(!a || i && i !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(a) {
  function i(l) {
    var d;
    const h = l.target.value;
    (d = a.onUpdateColor) === null || d === void 0 || d.call(a, n1(h.toUpperCase(), a.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: i };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-color-picker-preview__preview` }, L("span", { class: `${a}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), L("input", { class: `${a}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), Oc = "12px", WM = 12, ml = "6px", ZM = 6, HM = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", XM = ot({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(a) {
  const i = Me(null);
  function l(g) {
    i.value && (Ei("mousemove", document, d), Ei("mouseup", document, h), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: o, left: w } = p.getBoundingClientRect(), S = IM((g.clientX - w - ZM) / (o - WM) * 360);
    a.onUpdateHue(S);
  }
  function h() {
    var g;
    Xi("mousemove", document, d), Xi("mouseup", document, h), (g = a.onComplete) === null || g === void 0 || g.call(a);
  }
  return { railRef: i, handleMouseDown: l };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-color-picker-slider`, style: { height: Oc, borderRadius: ml } }, L("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: HM, height: Oc, borderRadius: ml, position: "relative" }, onMousedown: this.handleMouseDown }, L("div", { style: { position: "absolute", left: ml, right: ml, top: 0, bottom: 0 } }, L("div", { class: `${a}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${ml})`, borderRadius: ml, width: Oc, height: Oc } }, L("div", { class: `${a}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: ml, width: Oc, height: Oc } })))));
} }), tp = "12px", rp = "6px", YM = ot({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(a) {
  const i = Me(null);
  function l(g) {
    i.value && (Ei("mousemove", document, d), Ei("mouseup", document, h), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: o, height: w, left: S, bottom: k } = p.getBoundingClientRect(), I = (k - g.clientY) / w, z = (g.clientX - S) / o, R = 100 * (z > 1 ? 1 : z < 0 ? 0 : z), O = 100 * (I > 1 ? 1 : I < 0 ? 0 : I);
    a.onUpdateSV(R, O);
  }
  function h() {
    var g;
    Xi("mousemove", document, d), Xi("mouseup", document, h), (g = a.onComplete) === null || g === void 0 || g.call(a);
  }
  return { palleteRef: i, handleColor: De(() => {
    const { rgba: g } = a;
    return g ? `rgb(${g[0]}, ${g[1]}, ${g[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: a } = this;
  return L("div", { class: `${a}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, L("div", { class: `${a}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), L("div", { class: `${a}-color-picker-pallete__layer ${a}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && L("div", { class: `${a}-color-picker-handle`, style: { width: tp, height: tp, borderRadius: rp, left: `calc(${this.displayedSv[0]}% - ${rp})`, bottom: `calc(${this.displayedSv[1]}% - ${rp})` } }, L("div", { class: `${a}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: rp, width: tp, height: tp } })));
} }), KM = Ge([de("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), de("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [Bp(), de("input", `
 text-align: center;
 `)]), de("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ge("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), de("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Ae("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), Ge("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), de("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Ae("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), de("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Ae("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), de("color-picker-preview", `
 display: flex;
 `, [Ae("sliders", `
 flex: 1 0 auto;
 `), Ae("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Ae("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Ae("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), de("color-picker-input", `
 display: flex;
 align-items: center;
 `, [de("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Ae("mode", `
 width: 72px;
 text-align: center;
 `)]), de("color-picker-control", `
 padding: 12px;
 `), de("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [de("button", "margin-left: 8px;")]), de("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Ae("value", `
 white-space: nowrap;
 position: relative;
 `), Ae("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ue("disabled", "cursor: not-allowed"), de("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [Ge("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), de("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [de("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Ae("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), Ge("&:focus", `
 outline: none;
 `, [Ae("fill", [Ge("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), JM = Object.assign(Object.assign({}, tr.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: Hc.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), bm = ot({ name: "ColorPicker", props: JM, slots: Object, setup(a, { slots: i }) {
  const l = Me(null);
  let d = null;
  const h = gs(a), { mergedSizeRef: g, mergedDisabledRef: p } = h, { localeRef: o } = Hs("global"), { mergedClsPrefixRef: w, namespaceRef: S, inlineThemeDisabled: k } = Ir(a), I = tr("ColorPicker", "-color-picker", KM, JC, a, w);
  Zr(Iv, { themeRef: I, renderLabelRef: Ot(a, "renderLabel"), colorPickerSlots: i });
  const z = Me(a.defaultShow), R = wi(Ot(a, "show"), z);
  function O(We) {
    const { onUpdateShow: kt, "onUpdate:show": et } = a;
    kt && Gt(kt, We), et && Gt(et, We), z.value = We;
  }
  const { defaultValue: V } = a, W = Me(V === void 0 ? MM(a.modes, a.showAlpha) : V), N = wi(Ot(a, "value"), W), K = Me([N.value]), Z = Me(0), X = De(() => Fd(N.value)), { modes: te } = a, q = Me(Fd(N.value) || te[0] || "rgb");
  function he() {
    const { modes: We } = a, { value: kt } = q, et = We.findIndex((it) => it === kt);
    ~et ? q.value = We[(et + 1) % We.length] : q.value = "rgb";
  }
  let se, Q, oe, ve, Be, Ne, Pe, tt;
  const at = De(() => {
    const { value: We } = N;
    if (!We) return null;
    switch (X.value) {
      case "hsv":
        return Cl(We);
      case "hsl":
        return [se, Q, oe, tt] = Gc(We), [...ax(se, Q, oe), tt];
      case "rgb":
      case "hex":
        return [Be, Ne, Pe, tt] = ds(We), [...Wg(Be, Ne, Pe), tt];
    }
  }), xt = De(() => {
    const { value: We } = N;
    if (!We) return null;
    switch (X.value) {
      case "rgb":
      case "hex":
        return ds(We);
      case "hsv":
        return [se, Q, ve, tt] = Cl(We), [..._a(se, Q, ve), tt];
      case "hsl":
        return [se, Q, oe, tt] = Gc(We), [...Gg(se, Q, oe), tt];
    }
  }), ht = De(() => {
    const { value: We } = N;
    if (!We) return null;
    switch (X.value) {
      case "hsl":
        return Gc(We);
      case "hsv":
        return [se, Q, ve, tt] = Cl(We), [...mp(se, Q, ve), tt];
      case "rgb":
      case "hex":
        return [Be, Ne, Pe, tt] = ds(We), [...Zg(Be, Ne, Pe), tt];
    }
  }), Ye = De(() => {
    switch (q.value) {
      case "rgb":
      case "hex":
        return xt.value;
      case "hsv":
        return at.value;
      case "hsl":
        return ht.value;
    }
  }), Ke = Me(0), Lt = Me(1), ct = Me([0, 0]);
  function bt(We, kt) {
    const { value: et } = at, it = Ke.value, Pt = et ? et[3] : 1;
    ct.value = [We, kt];
    const { showAlpha: Et } = a;
    switch (q.value) {
      case "hsv":
        vt((Et ? Sl : Yg)([it, We, kt, Pt]), "cursor");
        break;
      case "hsl":
        vt((Et ? xa : Hg)([...mp(it, We, kt), Pt]), "cursor");
        break;
      case "rgb":
        vt((Et ? Vs : Xg)([..._a(it, We, kt), Pt]), "cursor");
        break;
      case "hex":
        vt((Et ? wa : Cd)([..._a(it, We, kt), Pt]), "cursor");
        break;
    }
  }
  function Nt(We) {
    Ke.value = We;
    const { value: kt } = at;
    if (!kt) return;
    const [, et, it, Pt] = kt, { showAlpha: Et } = a;
    switch (q.value) {
      case "hsv":
        vt((Et ? Sl : Yg)([We, et, it, Pt]), "cursor");
        break;
      case "rgb":
        vt((Et ? Vs : Xg)([..._a(We, et, it), Pt]), "cursor");
        break;
      case "hex":
        vt((Et ? wa : Cd)([..._a(We, et, it), Pt]), "cursor");
        break;
      case "hsl":
        vt((Et ? xa : Hg)([...mp(We, et, it), Pt]), "cursor");
        break;
    }
  }
  function Yt(We) {
    switch (q.value) {
      case "hsv":
        [se, Q, ve] = at.value, vt(Sl([se, Q, ve, We]), "cursor");
        break;
      case "rgb":
        [Be, Ne, Pe] = xt.value, vt(Vs([Be, Ne, Pe, We]), "cursor");
        break;
      case "hex":
        [Be, Ne, Pe] = xt.value, vt(wa([Be, Ne, Pe, We]), "cursor");
        break;
      case "hsl":
        [se, Q, oe] = ht.value, vt(xa([se, Q, oe, We]), "cursor");
        break;
    }
    Lt.value = We;
  }
  function vt(We, kt) {
    kt === "cursor" ? d = We : d = null;
    const { nTriggerFormChange: et, nTriggerFormInput: it } = h, { onUpdateValue: Pt, "onUpdate:value": Et } = a;
    Pt && Gt(Pt, We), Et && Gt(Et, We), et(), it(), W.value = We;
  }
  function jt(We) {
    vt(We, "input"), Vi(er);
  }
  function er(We = true) {
    const { value: kt } = N;
    if (kt) {
      const { nTriggerFormChange: et, nTriggerFormInput: it } = h, { onComplete: Pt } = a;
      Pt && Pt(kt);
      const { value: Et } = K, { value: st } = Z;
      We && (Et.splice(st + 1, Et.length, kt), Z.value = st + 1), et(), it();
    }
  }
  function yr() {
    const { value: We } = Z;
    We - 1 < 0 || (vt(K.value[We - 1], "input"), er(false), Z.value = We - 1);
  }
  function Tr() {
    const { value: We } = Z;
    We < 0 || We + 1 >= K.value.length || (vt(K.value[We + 1], "input"), er(false), Z.value = We + 1);
  }
  function zr() {
    vt(null, "input");
    const { onClear: We } = a;
    We && We(), O(false);
  }
  function rr() {
    const { value: We } = N, { onConfirm: kt } = a;
    kt && kt(We), O(false);
  }
  const yt = De(() => Z.value >= 1), Ct = De(() => {
    const { value: We } = K;
    return We.length > 1 && Z.value < We.length - 1;
  });
  Kt(R, (We) => {
    We || (K.value = [N.value], Z.value = 0);
  }), zo(() => {
    if (!(d && d === N.value)) {
      const { value: We } = at;
      We && (Ke.value = We[0], Lt.value = We[3], ct.value = [We[1], We[2]]);
    }
    d = null;
  });
  const Dt = De(() => {
    const { value: We } = g, { common: { cubicBezierEaseInOut: kt }, self: { textColor: et, color: it, panelFontSize: Pt, boxShadow: Et, border: st, borderRadius: St, dividerColor: ar, [qt("height", We)]: on, [qt("fontSize", We)]: Sn } } = I.value;
    return { "--n-bezier": kt, "--n-text-color": et, "--n-color": it, "--n-panel-font-size": Pt, "--n-font-size": Sn, "--n-box-shadow": Et, "--n-border": st, "--n-border-radius": St, "--n-height": on, "--n-divider-color": ar };
  }), ir = k ? hn("color-picker", De(() => g.value[0]), Dt, a) : void 0;
  function ut() {
    var We;
    const { value: kt } = xt, { value: et } = Ke, { internalActions: it, modes: Pt, actions: Et } = a, { value: st } = I, { value: St } = w;
    return L("div", { class: [`${St}-color-picker-panel`, ir == null ? void 0 : ir.themeClass.value], onDragstart: (ar) => {
      ar.preventDefault();
    }, style: k ? void 0 : Dt.value }, L("div", { class: `${St}-color-picker-control` }, L(YM, { clsPrefix: St, rgba: kt, displayedHue: et, displayedSv: ct.value, onUpdateSV: bt, onComplete: er }), L("div", { class: `${St}-color-picker-preview` }, L("div", { class: `${St}-color-picker-preview__sliders` }, L(XM, { clsPrefix: St, hue: et, onUpdateHue: Nt, onComplete: er }), a.showAlpha ? L(AM, { clsPrefix: St, rgba: kt, alpha: Lt.value, onUpdateAlpha: Yt, onComplete: er }) : null), a.showPreview ? L(GM, { clsPrefix: St, mode: q.value, color: xt.value && Cd(xt.value), onUpdateColor: (ar) => {
      vt(ar, "input");
    } }) : null), L(jM, { clsPrefix: St, showAlpha: a.showAlpha, mode: q.value, modes: Pt, onUpdateMode: he, value: N.value, valueArr: Ye.value, onUpdateValue: jt }), ((We = a.swatches) === null || We === void 0 ? void 0 : We.length) && L(UM, { clsPrefix: St, mode: q.value, swatches: a.swatches, onUpdateColor: (ar) => {
      vt(ar, "input");
    } })), (Et == null ? void 0 : Et.length) ? L("div", { class: `${St}-color-picker-action` }, Et.includes("confirm") && L(jr, { size: "small", onClick: rr, theme: st.peers.Button, themeOverrides: st.peerOverrides.Button }, { default: () => o.value.confirm }), Et.includes("clear") && L(jr, { size: "small", onClick: zr, disabled: !N.value, theme: st.peers.Button, themeOverrides: st.peerOverrides.Button }, { default: () => o.value.clear })) : null, i.action ? L("div", { class: `${St}-color-picker-action` }, { default: i.action }) : it ? L("div", { class: `${St}-color-picker-action` }, it.includes("undo") && L(jr, { size: "small", onClick: yr, disabled: !yt.value, theme: st.peers.Button, themeOverrides: st.peerOverrides.Button }, { default: () => o.value.undo }), it.includes("redo") && L(jr, { size: "small", onClick: Tr, disabled: !Ct.value, theme: st.peers.Button, themeOverrides: st.peerOverrides.Button }, { default: () => o.value.redo })) : null);
  }
  return { mergedClsPrefix: w, namespace: S, selfRef: l, hsla: ht, rgba: xt, mergedShow: R, mergedDisabled: p, isMounted: Up(), adjustedTo: Hc(a), mergedValue: N, handleTriggerClick() {
    O(true);
  }, handleClickOutside(We) {
    var kt;
    !((kt = l.value) === null || kt === void 0) && kt.contains(dx(We)) || O(false);
  }, renderPanel: ut, cssVars: k ? void 0 : Dt, themeClass: ir == null ? void 0 : ir.themeClass, onRender: ir == null ? void 0 : ir.onRender };
}, render() {
  const { mergedClsPrefix: a, onRender: i } = this;
  return i == null ? void 0 : i(), L("div", { class: [this.themeClass, `${a}-color-picker`], ref: "selfRef", style: this.cssVars }, L(lx, null, { default: () => [L(cx, null, { default: () => L(qM, { clsPrefix: a, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), L(ux, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === Hc.tdkey, to: this.adjustedTo }, { default: () => L(Ro, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? fs(this.renderPanel(), [[Pp, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), QM = Ge([de("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), de("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [Bp({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), eI = Object.assign(Object.assign({}, tr.props), { to: Hc.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), ev = ot({ name: "Select", props: eI, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, namespaceRef: d, inlineThemeDisabled: h } = Ir(a), g = tr("Select", "-select", QM, QC, a, i), p = Me(a.defaultValue), o = Ot(a, "value"), w = wi(o, p), S = Me(false), k = Me(""), I = Tp(a, ["items", "options"]), z = Me([]), R = Me([]), O = De(() => R.value.concat(z.value).concat(I.value)), V = De(() => {
    const { filter: fe } = a;
    if (fe) return fe;
    const { labelField: _e, valueField: Ve } = a;
    return (nt, Xe) => {
      if (!Xe) return false;
      const wt = Xe[_e];
      if (typeof wt == "string") return gm(nt, wt);
      const Te = Xe[Ve];
      return typeof Te == "string" ? gm(nt, Te) : typeof Te == "number" ? gm(nt, String(Te)) : false;
    };
  }), W = De(() => {
    if (a.remote) return I.value;
    {
      const { value: fe } = O, { value: _e } = k;
      return !_e.length || !a.filterable ? fe : uM(fe, V.value, _e, a.childrenField);
    }
  }), N = De(() => {
    const { valueField: fe, childrenField: _e } = a, Ve = cM(fe, _e);
    return eS(W.value, Ve);
  }), K = De(() => dM(O.value, a.valueField, a.childrenField)), Z = Me(false), X = wi(Ot(a, "show"), Z), te = Me(null), q = Me(null), he = Me(null), { localeRef: se } = Hs("Select"), Q = De(() => {
    var fe;
    return (fe = a.placeholder) !== null && fe !== void 0 ? fe : se.value.placeholder;
  }), oe = [], ve = Me(/* @__PURE__ */ new Map()), Be = De(() => {
    const { fallbackOption: fe } = a;
    if (fe === void 0) {
      const { labelField: _e, valueField: Ve } = a;
      return (nt) => ({ [_e]: String(nt), [Ve]: nt });
    }
    return fe === false ? false : (_e) => Object.assign(fe(_e), { value: _e });
  });
  function Ne(fe) {
    const _e = a.remote, { value: Ve } = ve, { value: nt } = K, { value: Xe } = Be, wt = [];
    return fe.forEach((Te) => {
      if (nt.has(Te)) wt.push(nt.get(Te));
      else if (_e && Ve.has(Te)) wt.push(Ve.get(Te));
      else if (Xe) {
        const Ut = Xe(Te);
        Ut && wt.push(Ut);
      }
    }), wt;
  }
  const Pe = De(() => {
    if (a.multiple) {
      const { value: fe } = w;
      return Array.isArray(fe) ? Ne(fe) : [];
    }
    return null;
  }), tt = De(() => {
    const { value: fe } = w;
    return !a.multiple && !Array.isArray(fe) ? fe === null ? null : Ne([fe])[0] || null : null;
  }), at = gs(a), { mergedSizeRef: xt, mergedDisabledRef: ht, mergedStatusRef: Ye } = at;
  function Ke(fe, _e) {
    const { onChange: Ve, "onUpdate:value": nt, onUpdateValue: Xe } = a, { nTriggerFormChange: wt, nTriggerFormInput: Te } = at;
    Ve && Gt(Ve, fe, _e), Xe && Gt(Xe, fe, _e), nt && Gt(nt, fe, _e), p.value = fe, wt(), Te();
  }
  function Lt(fe) {
    const { onBlur: _e } = a, { nTriggerFormBlur: Ve } = at;
    _e && Gt(_e, fe), Ve();
  }
  function ct() {
    const { onClear: fe } = a;
    fe && Gt(fe);
  }
  function bt(fe) {
    const { onFocus: _e, showOnFocus: Ve } = a, { nTriggerFormFocus: nt } = at;
    _e && Gt(_e, fe), nt(), Ve && er();
  }
  function Nt(fe) {
    const { onSearch: _e } = a;
    _e && Gt(_e, fe);
  }
  function Yt(fe) {
    const { onScroll: _e } = a;
    _e && Gt(_e, fe);
  }
  function vt() {
    var fe;
    const { remote: _e, multiple: Ve } = a;
    if (_e) {
      const { value: nt } = ve;
      if (Ve) {
        const { valueField: Xe } = a;
        (fe = Pe.value) === null || fe === void 0 || fe.forEach((wt) => {
          nt.set(wt[Xe], wt);
        });
      } else {
        const Xe = tt.value;
        Xe && nt.set(Xe[a.valueField], Xe);
      }
    }
  }
  function jt(fe) {
    const { onUpdateShow: _e, "onUpdate:show": Ve } = a;
    _e && Gt(_e, fe), Ve && Gt(Ve, fe), Z.value = fe;
  }
  function er() {
    ht.value || (jt(true), Z.value = true, a.filterable && ne());
  }
  function yr() {
    jt(false);
  }
  function Tr() {
    k.value = "", R.value = oe;
  }
  const zr = Me(false);
  function rr() {
    a.filterable && (zr.value = true);
  }
  function yt() {
    a.filterable && (zr.value = false, X.value || Tr());
  }
  function Ct() {
    ht.value || (X.value ? a.filterable ? ne() : yr() : er());
  }
  function Dt(fe) {
    var _e, Ve;
    !((Ve = (_e = he.value) === null || _e === void 0 ? void 0 : _e.selfRef) === null || Ve === void 0) && Ve.contains(fe.relatedTarget) || (S.value = false, Lt(fe), yr());
  }
  function ir(fe) {
    bt(fe), S.value = true;
  }
  function ut() {
    S.value = true;
  }
  function We(fe) {
    var _e;
    !((_e = te.value) === null || _e === void 0) && _e.$el.contains(fe.relatedTarget) || (S.value = false, Lt(fe), yr());
  }
  function kt() {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.focus(), yr();
  }
  function et(fe) {
    var _e;
    X.value && (!((_e = te.value) === null || _e === void 0) && _e.$el.contains(dx(fe)) || yr());
  }
  function it(fe) {
    if (!Array.isArray(fe)) return [];
    if (Be.value) return Array.from(fe);
    {
      const { remote: _e } = a, { value: Ve } = K;
      if (_e) {
        const { value: nt } = ve;
        return fe.filter((Xe) => Ve.has(Xe) || nt.has(Xe));
      } else return fe.filter((nt) => Ve.has(nt));
    }
  }
  function Pt(fe) {
    Et(fe.rawNode);
  }
  function Et(fe) {
    if (ht.value) return;
    const { tag: _e, remote: Ve, clearFilterAfterSelect: nt, valueField: Xe } = a;
    if (_e && !Ve) {
      const { value: wt } = R, Te = wt[0] || null;
      if (Te) {
        const Ut = z.value;
        Ut.length ? Ut.push(Te) : z.value = [Te], R.value = oe;
      }
    }
    if (Ve && ve.value.set(fe[Xe], fe), a.multiple) {
      const wt = it(w.value), Te = wt.findIndex((Ut) => Ut === fe[Xe]);
      if (~Te) {
        if (wt.splice(Te, 1), _e && !Ve) {
          const Ut = st(fe[Xe]);
          ~Ut && (z.value.splice(Ut, 1), nt && (k.value = ""));
        }
      } else wt.push(fe[Xe]), nt && (k.value = "");
      Ke(wt, Ne(wt));
    } else {
      if (_e && !Ve) {
        const wt = st(fe[Xe]);
        ~wt ? z.value = [z.value[wt]] : z.value = oe;
      }
      re(), yr(), Ke(fe[Xe], fe);
    }
  }
  function st(fe) {
    return z.value.findIndex((Ve) => Ve[a.valueField] === fe);
  }
  function St(fe) {
    X.value || er();
    const { value: _e } = fe.target;
    k.value = _e;
    const { tag: Ve, remote: nt } = a;
    if (Nt(_e), Ve && !nt) {
      if (!_e) {
        R.value = oe;
        return;
      }
      const { onCreate: Xe } = a, wt = Xe ? Xe(_e) : { [a.labelField]: _e, [a.valueField]: _e }, { valueField: Te, labelField: Ut } = a;
      I.value.some((or) => or[Te] === wt[Te] || or[Ut] === wt[Ut]) || z.value.some((or) => or[Te] === wt[Te] || or[Ut] === wt[Ut]) ? R.value = oe : R.value = [wt];
    }
  }
  function ar(fe) {
    fe.stopPropagation();
    const { multiple: _e } = a;
    !_e && a.filterable && yr(), ct(), _e ? Ke([], []) : Ke(null, null);
  }
  function on(fe) {
    !wl(fe, "action") && !wl(fe, "empty") && !wl(fe, "header") && fe.preventDefault();
  }
  function Sn(fe) {
    Yt(fe);
  }
  function Le(fe) {
    var _e, Ve, nt, Xe, wt;
    if (!a.keyboard) {
      fe.preventDefault();
      return;
    }
    switch (fe.key) {
      case " ":
        if (a.filterable) break;
        fe.preventDefault();
      case "Enter":
        if (!(!((_e = te.value) === null || _e === void 0) && _e.isComposing)) {
          if (X.value) {
            const Te = (Ve = he.value) === null || Ve === void 0 ? void 0 : Ve.getPendingTmNode();
            Te ? Pt(Te) : a.filterable || (yr(), re());
          } else if (er(), a.tag && zr.value) {
            const Te = R.value[0];
            if (Te) {
              const Ut = Te[a.valueField], { value: or } = w;
              a.multiple && Array.isArray(or) && or.includes(Ut) || Et(Te);
            }
          }
        }
        fe.preventDefault();
        break;
      case "ArrowUp":
        if (fe.preventDefault(), a.loading) return;
        X.value && ((nt = he.value) === null || nt === void 0 || nt.prev());
        break;
      case "ArrowDown":
        if (fe.preventDefault(), a.loading) return;
        X.value ? (Xe = he.value) === null || Xe === void 0 || Xe.next() : er();
        break;
      case "Escape":
        X.value && (tS(fe), yr()), (wt = te.value) === null || wt === void 0 || wt.focus();
        break;
    }
  }
  function re() {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.focus();
  }
  function ne() {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.focusInput();
  }
  function ae() {
    var fe;
    X.value && ((fe = q.value) === null || fe === void 0 || fe.syncPosition());
  }
  vt(), Kt(Ot(a, "options"), vt);
  const be = { focus: () => {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.focus();
  }, focusInput: () => {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.focusInput();
  }, blur: () => {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.blur();
  }, blurInput: () => {
    var fe;
    (fe = te.value) === null || fe === void 0 || fe.blurInput();
  } }, Ie = De(() => {
    const { self: { menuBoxShadow: fe } } = g.value;
    return { "--n-menu-box-shadow": fe };
  }), Fe = h ? hn("select", void 0, Ie, a) : void 0;
  return Object.assign(Object.assign({}, be), { mergedStatus: Ye, mergedClsPrefix: i, mergedBordered: l, namespace: d, treeMate: N, isMounted: Up(), triggerRef: te, menuRef: he, pattern: k, uncontrolledShow: Z, mergedShow: X, adjustedTo: Hc(a), uncontrolledValue: p, mergedValue: w, followerRef: q, localizedPlaceholder: Q, selectedOption: tt, selectedOptions: Pe, mergedSize: xt, mergedDisabled: ht, focused: S, activeWithoutMenuOpen: zr, inlineThemeDisabled: h, onTriggerInputFocus: rr, onTriggerInputBlur: yt, handleTriggerOrMenuResize: ae, handleMenuFocus: ut, handleMenuBlur: We, handleMenuTabOut: kt, handleTriggerClick: Ct, handleToggle: Pt, handleDeleteOption: Et, handlePatternInput: St, handleClear: ar, handleTriggerBlur: Dt, handleTriggerFocus: ir, handleKeydown: Le, handleMenuAfterLeave: Tr, handleMenuClickOutside: et, handleMenuScroll: Sn, handleMenuKeydown: Le, handleMenuMousedown: on, mergedTheme: g, cssVars: h ? void 0 : Ie, themeClass: Fe == null ? void 0 : Fe.themeClass, onRender: Fe == null ? void 0 : Fe.onRender });
}, render() {
  return L("div", { class: `${this.mergedClsPrefix}-select` }, L(lx, null, { default: () => [L(cx, null, { default: () => L(WT, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var a, i;
    return [(i = (a = this.$slots).arrow) === null || i === void 0 ? void 0 : i.call(a)];
  } }) }), L(ux, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === Hc.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => L(Ro, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var a, i, l;
    return this.mergedShow || this.displayDirective === "show" ? ((a = this.onRender) === null || a === void 0 || a.call(this), fs(L(NT, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (i = this.menuProps) === null || i === void 0 ? void 0 : i.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var d, h;
      return [(h = (d = this.$slots).empty) === null || h === void 0 ? void 0 : h.call(d)];
    }, header: () => {
      var d, h;
      return [(h = (d = this.$slots).header) === null || h === void 0 ? void 0 : h.call(d)];
    }, action: () => {
      var d, h;
      return [(h = (d = this.$slots).action) === null || h === void 0 ? void 0 : h.call(d)];
    } }), this.displayDirective === "show" ? [[Gs, this.mergedShow], [Pp, this.handleMenuClickOutside, void 0, { capture: true }]] : [[Pp, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), tI = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, i1 = Ai("n-radio-group");
function rI(a) {
  const i = hr(i1, null), l = gs(a, { mergedSize(K) {
    const { size: Z } = a;
    if (Z !== void 0) return Z;
    if (i) {
      const { mergedSizeRef: { value: X } } = i;
      if (X !== void 0) return X;
    }
    return K ? K.mergedSize.value : "medium";
  }, mergedDisabled(K) {
    return !!(a.disabled || (i == null ? void 0 : i.disabledRef.value) || (K == null ? void 0 : K.disabled.value));
  } }), { mergedSizeRef: d, mergedDisabledRef: h } = l, g = Me(null), p = Me(null), o = Me(a.defaultChecked), w = Ot(a, "checked"), S = wi(w, o), k = vn(() => i ? i.valueRef.value === a.value : S.value), I = vn(() => {
    const { name: K } = a;
    if (K !== void 0) return K;
    if (i) return i.nameRef.value;
  }), z = Me(false);
  function R() {
    if (i) {
      const { doUpdateValue: K } = i, { value: Z } = a;
      Gt(K, Z);
    } else {
      const { onUpdateChecked: K, "onUpdate:checked": Z } = a, { nTriggerFormInput: X, nTriggerFormChange: te } = l;
      K && Gt(K, true), Z && Gt(Z, true), X(), te(), o.value = true;
    }
  }
  function O() {
    h.value || k.value || R();
  }
  function V() {
    O(), g.value && (g.value.checked = k.value);
  }
  function W() {
    z.value = false;
  }
  function N() {
    z.value = true;
  }
  return { mergedClsPrefix: i ? i.mergedClsPrefixRef : Ir(a).mergedClsPrefixRef, inputRef: g, labelRef: p, mergedName: I, mergedDisabled: h, renderSafeChecked: k, focus: z, mergedSize: d, handleRadioInputChange: V, handleRadioInputBlur: W, handleRadioInputFocus: N };
}
const nI = ot({ name: "RadioButton", props: tI, setup: rI, render() {
  const { mergedClsPrefix: a } = this;
  return L("label", { class: [`${a}-radio-button`, this.mergedDisabled && `${a}-radio-button--disabled`, this.renderSafeChecked && `${a}-radio-button--checked`, this.focus && [`${a}-radio-button--focus`]] }, L("input", { ref: "inputRef", type: "radio", class: `${a}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), L("div", { class: `${a}-radio-button__state-border` }), dn(this.$slots.default, (i) => !i && !this.label ? null : L("div", { ref: "labelRef", class: `${a}-radio__label` }, i || this.label)));
} }), iI = de("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Ae("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ue("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ue("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ue("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [de("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Ae("splitor", { height: "var(--n-height)" })]), de("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [de("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Ae("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), Ge("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Ae("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), Ge("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Ae("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), pn("disabled", `
 cursor: pointer;
 `, [Ge("&:hover", [Ae("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), pn("checked", { color: "var(--n-button-text-color-hover)" })]), Ue("focus", [Ge("&:not(:active)", [Ae("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ue("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ue("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function oI(a, i, l) {
  var d;
  const h = [];
  let g = false;
  for (let p = 0; p < a.length; ++p) {
    const o = a[p], w = (d = o.type) === null || d === void 0 ? void 0 : d.name;
    w === "RadioButton" && (g = true);
    const S = o.props;
    if (w !== "RadioButton") {
      h.push(o);
      continue;
    }
    if (p === 0) h.push(o);
    else {
      const k = h[h.length - 1].props, I = i === k.value, z = k.disabled, R = i === S.value, O = S.disabled, V = (I ? 2 : 0) + (z ? 0 : 1), W = (R ? 2 : 0) + (O ? 0 : 1), N = { [`${l}-radio-group__splitor--disabled`]: z, [`${l}-radio-group__splitor--checked`]: I }, K = { [`${l}-radio-group__splitor--disabled`]: O, [`${l}-radio-group__splitor--checked`]: R }, Z = V < W ? K : N;
      h.push(L("div", { class: [`${l}-radio-group__splitor`, Z] }), o);
    }
  }
  return { children: h, isButtonGroup: g };
}
const sI = Object.assign(Object.assign({}, tr.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), aI = ot({ name: "RadioGroup", props: sI, setup(a) {
  const i = Me(null), { mergedSizeRef: l, mergedDisabledRef: d, nTriggerFormChange: h, nTriggerFormInput: g, nTriggerFormBlur: p, nTriggerFormFocus: o } = gs(a), { mergedClsPrefixRef: w, inlineThemeDisabled: S, mergedRtlRef: k } = Ir(a), I = tr("Radio", "-radio-group", iI, rS, a, w), z = Me(a.defaultValue), R = Ot(a, "value"), O = wi(R, z);
  function V(te) {
    const { onUpdateValue: q, "onUpdate:value": he } = a;
    q && Gt(q, te), he && Gt(he, te), z.value = te, h(), g();
  }
  function W(te) {
    const { value: q } = i;
    q && (q.contains(te.relatedTarget) || o());
  }
  function N(te) {
    const { value: q } = i;
    q && (q.contains(te.relatedTarget) || p());
  }
  Zr(i1, { mergedClsPrefixRef: w, nameRef: Ot(a, "name"), valueRef: O, disabledRef: d, mergedSizeRef: l, doUpdateValue: V });
  const K = zi("Radio", k, w), Z = De(() => {
    const { value: te } = l, { common: { cubicBezierEaseInOut: q }, self: { buttonBorderColor: he, buttonBorderColorActive: se, buttonBorderRadius: Q, buttonBoxShadow: oe, buttonBoxShadowFocus: ve, buttonBoxShadowHover: Be, buttonColor: Ne, buttonColorActive: Pe, buttonTextColor: tt, buttonTextColorActive: at, buttonTextColorHover: xt, opacityDisabled: ht, [qt("buttonHeight", te)]: Ye, [qt("fontSize", te)]: Ke } } = I.value;
    return { "--n-font-size": Ke, "--n-bezier": q, "--n-button-border-color": he, "--n-button-border-color-active": se, "--n-button-border-radius": Q, "--n-button-box-shadow": oe, "--n-button-box-shadow-focus": ve, "--n-button-box-shadow-hover": Be, "--n-button-color": Ne, "--n-button-color-active": Pe, "--n-button-text-color": tt, "--n-button-text-color-hover": xt, "--n-button-text-color-active": at, "--n-height": Ye, "--n-opacity-disabled": ht };
  }), X = S ? hn("radio-group", De(() => l.value[0]), Z, a) : void 0;
  return { selfElRef: i, rtlEnabled: K, mergedClsPrefix: w, mergedValue: O, handleFocusout: N, handleFocusin: W, cssVars: S ? void 0 : Z, themeClass: X == null ? void 0 : X.themeClass, onRender: X == null ? void 0 : X.onRender };
}, render() {
  var a;
  const { mergedValue: i, mergedClsPrefix: l, handleFocusin: d, handleFocusout: h } = this, { children: g, isButtonGroup: p } = oI(kl(Gp(this)), i, l);
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { onFocusin: d, onFocusout: h, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, p && `${l}-radio-group--button-group`], style: this.cssVars }, g);
} }), o1 = de("ellipsis", { overflow: "hidden" }, [pn("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ue("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ue("cursor-pointer", `
 cursor: pointer;
 `)]);
function tv(a) {
  return `${a}-ellipsis--line-clamp`;
}
function rv(a, i) {
  return `${a}-ellipsis--cursor-${i}`;
}
const s1 = Object.assign(Object.assign({}, tr.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), lI = ot({ name: "Ellipsis", inheritAttrs: false, props: s1, slots: Object, setup(a, { slots: i, attrs: l }) {
  const d = px(), h = tr("Ellipsis", "-ellipsis", o1, nS, a, d), g = Me(null), p = Me(null), o = Me(null), w = Me(false), S = De(() => {
    const { lineClamp: W } = a, { value: N } = w;
    return W !== void 0 ? { textOverflow: "", "-webkit-line-clamp": N ? "" : W } : { textOverflow: N ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function k() {
    let W = false;
    const { value: N } = w;
    if (N) return true;
    const { value: K } = g;
    if (K) {
      const { lineClamp: Z } = a;
      if (R(K), Z !== void 0) W = K.scrollHeight <= K.offsetHeight;
      else {
        const { value: X } = p;
        X && (W = X.getBoundingClientRect().width <= K.getBoundingClientRect().width);
      }
      O(K, W);
    }
    return W;
  }
  const I = De(() => a.expandTrigger === "click" ? () => {
    var W;
    const { value: N } = w;
    N && ((W = o.value) === null || W === void 0 || W.setShow(false)), w.value = !N;
  } : void 0);
  Yb(() => {
    var W;
    a.tooltip && ((W = o.value) === null || W === void 0 || W.setShow(false));
  });
  const z = () => L("span", Object.assign({}, qs(l, { class: [`${d.value}-ellipsis`, a.lineClamp !== void 0 ? tv(d.value) : void 0, a.expandTrigger === "click" ? rv(d.value, "pointer") : void 0], style: S.value }), { ref: "triggerRef", onClick: I.value, onMouseenter: a.expandTrigger === "click" ? k : void 0 }), a.lineClamp ? i : L("span", { ref: "triggerInnerRef" }, i));
  function R(W) {
    if (!W) return;
    const N = S.value, K = tv(d.value);
    a.lineClamp !== void 0 ? V(W, K, "add") : V(W, K, "remove");
    for (const Z in N) W.style[Z] !== N[Z] && (W.style[Z] = N[Z]);
  }
  function O(W, N) {
    const K = rv(d.value, "pointer");
    a.expandTrigger === "click" && !N ? V(W, K, "add") : V(W, K, "remove");
  }
  function V(W, N, K) {
    K === "add" ? W.classList.contains(N) || W.classList.add(N) : W.classList.contains(N) && W.classList.remove(N);
  }
  return { mergedTheme: h, triggerRef: g, triggerInnerRef: p, tooltipRef: o, handleClick: I, renderTrigger: z, getTooltipDisabled: k };
}, render() {
  var a;
  const { tooltip: i, renderTrigger: l, $slots: d } = this;
  if (i) {
    const { mergedTheme: h } = this;
    return L(hx, Object.assign({ ref: "tooltipRef", placement: "top" }, i, { getDisabled: this.getTooltipDisabled, theme: h.peers.Tooltip, themeOverrides: h.peerOverrides.Tooltip }), { trigger: l, default: (a = d.tooltip) !== null && a !== void 0 ? a : d.default });
  } else return l();
} }), a1 = ot({ name: "PerformantEllipsis", props: s1, inheritAttrs: false, setup(a, { attrs: i, slots: l }) {
  const d = Me(false), h = px();
  return tu("-ellipsis", o1, h), { mouseEntered: d, renderTrigger: () => {
    const { lineClamp: p } = a, o = h.value;
    return L("span", Object.assign({}, qs(i, { class: [`${o}-ellipsis`, p !== void 0 ? tv(o) : void 0, a.expandTrigger === "click" ? rv(o, "pointer") : void 0], style: p === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": p } }), { onMouseenter: () => {
      d.value = true;
    } }), p ? l : L("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? L(lI, qs({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function l1() {
  const a = hr(iS, null);
  return a === null && vs("use-dialog", "No outer <n-dialog-provider /> founded."), a;
}
function Zp() {
  const a = hr(oS, null);
  return a === null && vs("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), a;
}
const cI = de("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [pn("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [pn("no-title", `
 display: flex;
 align-items: center;
 `)]), Ae("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ue("title-position-left", [Ae("line", [Ue("left", { width: "28px" })])]), Ue("title-position-right", [Ae("line", [Ue("right", { width: "28px" })])]), Ue("dashed", [Ae("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ue("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Ae("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), pn("dashed", [Ae("line", { backgroundColor: "var(--n-color)" })]), Ue("dashed", [Ae("line", { borderColor: "var(--n-color)" })]), Ue("vertical", { backgroundColor: "var(--n-color)" })]), uI = Object.assign(Object.assign({}, tr.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), c1 = ot({ name: "Divider", props: uI, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = tr("Divider", "-divider", cI, sS, a, i), h = De(() => {
    const { common: { cubicBezierEaseInOut: p }, self: { color: o, textColor: w, fontWeight: S } } = d.value;
    return { "--n-bezier": p, "--n-color": o, "--n-text-color": w, "--n-font-weight": S };
  }), g = l ? hn("divider", void 0, h, a) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : h, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var a;
  const { $slots: i, titlePlacement: l, vertical: d, dashed: h, cssVars: g, mergedClsPrefix: p } = this;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { role: "separator", class: [`${p}-divider`, this.themeClass, { [`${p}-divider--vertical`]: d, [`${p}-divider--no-title`]: !i.default, [`${p}-divider--dashed`]: h, [`${p}-divider--title-position-${l}`]: i.default && l }], style: g }, d ? null : L("div", { class: `${p}-divider__line ${p}-divider__line--left` }), !d && i.default ? L(qr, null, L("div", { class: `${p}-divider__title` }, this.$slots), L("div", { class: `${p}-divider__line ${p}-divider__line--right` })) : null);
} }), dI = ot({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(a) {
  const i = Me(!!a.show), l = Me(null), d = hr(Sv);
  let h = 0, g = "", p = null;
  const o = Me(false), w = Me(false), S = De(() => a.placement === "top" || a.placement === "bottom"), { mergedClsPrefixRef: k, mergedRtlRef: I } = Ir(a), z = zi("Drawer", I, k), R = q, O = (Q) => {
    w.value = true, h = S.value ? Q.clientY : Q.clientX, g = document.body.style.cursor, document.body.style.cursor = S.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", te), document.body.addEventListener("mouseleave", R), document.body.addEventListener("mouseup", q);
  }, V = () => {
    p !== null && (window.clearTimeout(p), p = null), w.value ? o.value = true : p = window.setTimeout(() => {
      o.value = true;
    }, 300);
  }, W = () => {
    p !== null && (window.clearTimeout(p), p = null), o.value = false;
  }, { doUpdateHeight: N, doUpdateWidth: K } = d, Z = (Q) => {
    const { maxWidth: oe } = a;
    if (oe && Q > oe) return oe;
    const { minWidth: ve } = a;
    return ve && Q < ve ? ve : Q;
  }, X = (Q) => {
    const { maxHeight: oe } = a;
    if (oe && Q > oe) return oe;
    const { minHeight: ve } = a;
    return ve && Q < ve ? ve : Q;
  };
  function te(Q) {
    var oe, ve;
    if (w.value) if (S.value) {
      let Be = ((oe = l.value) === null || oe === void 0 ? void 0 : oe.offsetHeight) || 0;
      const Ne = h - Q.clientY;
      Be += a.placement === "bottom" ? Ne : -Ne, Be = X(Be), N(Be), h = Q.clientY;
    } else {
      let Be = ((ve = l.value) === null || ve === void 0 ? void 0 : ve.offsetWidth) || 0;
      const Ne = h - Q.clientX;
      Be += a.placement === "right" ? Ne : -Ne, Be = Z(Be), K(Be), h = Q.clientX;
    }
  }
  function q() {
    w.value && (h = 0, w.value = false, document.body.style.cursor = g, document.body.removeEventListener("mousemove", te), document.body.removeEventListener("mouseup", q), document.body.removeEventListener("mouseleave", R));
  }
  zo(() => {
    a.show && (i.value = true);
  }), Kt(() => a.show, (Q) => {
    Q || q();
  }), Ci(() => {
    q();
  });
  const he = De(() => {
    const { show: Q } = a, oe = [[Gs, Q]];
    return a.showMask || oe.push([Pp, a.onClickoutside, void 0, { capture: true }]), oe;
  });
  function se() {
    var Q;
    i.value = false, (Q = a.onAfterLeave) === null || Q === void 0 || Q.call(a);
  }
  return lS(De(() => a.blockScroll && i.value)), Zr(cS, l), Zr(uS, null), Zr(dS, null), { bodyRef: l, rtlEnabled: z, mergedClsPrefix: d.mergedClsPrefixRef, isMounted: d.isMountedRef, mergedTheme: d.mergedThemeRef, displayed: i, transitionName: De(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[a.placement]), handleAfterLeave: se, bodyDirectives: he, handleMousedownResizeTrigger: O, handleMouseenterResizeTrigger: V, handleMouseleaveResizeTrigger: W, isDragging: w, isHoverOnResizeTrigger: o };
}, render() {
  const { $slots: a, mergedClsPrefix: i } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? fs(L("div", { role: "none" }, L(aS, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => L(Ro, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => fs(L("div", qs(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${i}-drawer`, this.rtlEnabled && `${i}-drawer--rtl`, `${i}-drawer--${this.placement}-placement`, this.isDragging && `${i}-drawer--unselectable`, this.nativeScrollbar && `${i}-drawer--native-scrollbar`] }), [this.resizable ? L("div", { class: [`${i}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${i}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? L("div", { class: [`${i}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, a) : L(jd, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${i}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), a)]), this.bodyDirectives) }) })), [[Gs, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: hI, cubicBezierEaseOut: pI } = Nd;
function fI({ duration: a = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${hI}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${a} ${pI}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: mI, cubicBezierEaseOut: gI } = Nd;
function vI({ duration: a = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${mI}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${a} ${gI}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: yI, cubicBezierEaseOut: _I } = Nd;
function bI({ duration: a = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${yI}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${a} ${_I}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: xI, cubicBezierEaseOut: wI } = Nd;
function CI({ duration: a = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${xI}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${a} ${wI}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const SI = Ge([de("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [bI(), vI(), CI(), fI(), Ue("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ue("native-scrollbar", [de("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Ae("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), de("drawer-content-wrapper", `
 box-sizing: border-box;
 `), de("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ue("native-scrollbar", [de("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), de("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), de("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), de("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Ae("main", `
 flex: 1;
 `), Ae("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), de("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ue("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ue("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ue("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ue("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), Ge("body", [Ge(">", [de("drawer-container", `
 position: fixed;
 `)])]), de("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [Ge("> *", `
 pointer-events: all;
 `)]), de("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), Mp({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), kI = Object.assign(Object.assign({}, tr.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), u1 = ot({ name: "Drawer", inheritAttrs: false, props: kI, setup(a) {
  const { mergedClsPrefixRef: i, namespaceRef: l, inlineThemeDisabled: d } = Ir(a), h = Up(), g = tr("Drawer", "-drawer", SI, hS, a, i), p = Me(a.defaultWidth), o = Me(a.defaultHeight), w = wi(Ot(a, "width"), p), S = wi(Ot(a, "height"), o), k = De(() => {
    const { placement: q } = a;
    return q === "top" || q === "bottom" ? "" : qo(w.value);
  }), I = De(() => {
    const { placement: q } = a;
    return q === "left" || q === "right" ? "" : qo(S.value);
  }), z = (q) => {
    const { onUpdateWidth: he, "onUpdate:width": se } = a;
    he && Gt(he, q), se && Gt(se, q), p.value = q;
  }, R = (q) => {
    const { onUpdateHeight: he, "onUpdate:width": se } = a;
    he && Gt(he, q), se && Gt(se, q), o.value = q;
  }, O = De(() => [{ width: k.value, height: I.value }, a.drawerStyle || ""]);
  function V(q) {
    const { onMaskClick: he, maskClosable: se } = a;
    se && Z(false), he && he(q);
  }
  function W(q) {
    V(q);
  }
  const N = pS();
  function K(q) {
    var he;
    (he = a.onEsc) === null || he === void 0 || he.call(a), a.show && a.closeOnEsc && fS(q) && (N.value || Z(false));
  }
  function Z(q) {
    const { onHide: he, onUpdateShow: se, "onUpdate:show": Q } = a;
    se && Gt(se, q), Q && Gt(Q, q), he && !q && Gt(he, q);
  }
  Zr(Sv, { isMountedRef: h, mergedThemeRef: g, mergedClsPrefixRef: i, doUpdateShow: Z, doUpdateHeight: R, doUpdateWidth: z });
  const X = De(() => {
    const { common: { cubicBezierEaseInOut: q, cubicBezierEaseIn: he, cubicBezierEaseOut: se }, self: { color: Q, textColor: oe, boxShadow: ve, lineHeight: Be, headerPadding: Ne, footerPadding: Pe, borderRadius: tt, bodyPadding: at, titleFontSize: xt, titleTextColor: ht, titleFontWeight: Ye, headerBorderBottom: Ke, footerBorderTop: Lt, closeIconColor: ct, closeIconColorHover: bt, closeIconColorPressed: Nt, closeColorHover: Yt, closeColorPressed: vt, closeIconSize: jt, closeSize: er, closeBorderRadius: yr, resizableTriggerColorHover: Tr } } = g.value;
    return { "--n-line-height": Be, "--n-color": Q, "--n-border-radius": tt, "--n-text-color": oe, "--n-box-shadow": ve, "--n-bezier": q, "--n-bezier-out": se, "--n-bezier-in": he, "--n-header-padding": Ne, "--n-body-padding": at, "--n-footer-padding": Pe, "--n-title-text-color": ht, "--n-title-font-size": xt, "--n-title-font-weight": Ye, "--n-header-border-bottom": Ke, "--n-footer-border-top": Lt, "--n-close-icon-color": ct, "--n-close-icon-color-hover": bt, "--n-close-icon-color-pressed": Nt, "--n-close-size": er, "--n-close-color-hover": Yt, "--n-close-color-pressed": vt, "--n-close-icon-size": jt, "--n-close-border-radius": yr, "--n-resize-trigger-color-hover": Tr };
  }), te = d ? hn("drawer", void 0, X, a) : void 0;
  return { mergedClsPrefix: i, namespace: l, mergedBodyStyle: O, handleOutsideClick: W, handleMaskClick: V, handleEsc: K, mergedTheme: g, cssVars: d ? void 0 : X, themeClass: te == null ? void 0 : te.themeClass, onRender: te == null ? void 0 : te.onRender, isMounted: h };
}, render() {
  const { mergedClsPrefix: a } = this;
  return L(mx, { to: this.to, show: this.show }, { default: () => {
    var i;
    return (i = this.onRender) === null || i === void 0 || i.call(this), fs(L("div", { class: [`${a}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? L(Ro, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? L("div", { "aria-hidden": true, class: [`${a}-drawer-mask`, this.showMask === "transparent" && `${a}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, L(dI, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[fx, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), PI = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, d1 = ot({ name: "DrawerContent", props: PI, slots: Object, setup() {
  const a = hr(Sv, null);
  a || vs("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: i } = a;
  function l() {
    i(false);
  }
  return { handleCloseClick: l, mergedTheme: a.mergedThemeRef, mergedClsPrefix: a.mergedClsPrefixRef };
}, render() {
  const { title: a, mergedClsPrefix: i, nativeScrollbar: l, mergedTheme: d, bodyClass: h, bodyStyle: g, bodyContentClass: p, bodyContentStyle: o, headerClass: w, headerStyle: S, footerClass: k, footerStyle: I, scrollbarProps: z, closable: R, $slots: O } = this;
  return L("div", { role: "none", class: [`${i}-drawer-content`, l && `${i}-drawer-content--native-scrollbar`] }, O.header || a || R ? L("div", { class: [`${i}-drawer-header`, w], style: S, role: "none" }, L("div", { class: `${i}-drawer-header__main`, role: "heading", "aria-level": "1" }, O.header !== void 0 ? O.header() : a), R && L($p, { onClick: this.handleCloseClick, clsPrefix: i, class: `${i}-drawer-header__close`, absolute: true })) : null, l ? L("div", { class: [`${i}-drawer-body`, h], style: g, role: "none" }, L("div", { class: [`${i}-drawer-body-content-wrapper`, p], style: o, role: "none" }, O)) : L(jd, Object.assign({ themeOverrides: d.peerOverrides.Scrollbar, theme: d.peers.Scrollbar }, z, { class: `${i}-drawer-body`, contentClass: [`${i}-drawer-body-content-wrapper`, p], contentStyle: o }), O), O.footer ? L("div", { class: [`${i}-drawer-footer`, k], style: I, role: "none" }, O.footer()) : null);
} });
let xm;
function TI() {
  if (!Vp) return true;
  if (xm === void 0) {
    const a = document.createElement("div");
    a.style.display = "flex", a.style.flexDirection = "column", a.style.rowGap = "1px", a.appendChild(document.createElement("div")), a.appendChild(document.createElement("div")), document.body.appendChild(a);
    const i = a.scrollHeight === 1;
    return document.body.removeChild(a), xm = i;
  }
  return xm;
}
const MI = Object.assign(Object.assign({}, tr.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), ba = ot({ name: "Space", props: MI, setup(a) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Ir(a), d = tr("Space", "-space", void 0, mS, a, i), h = zi("Space", l, i);
  return { useGap: TI(), rtlEnabled: h, mergedClsPrefix: i, margin: De(() => {
    const { size: g } = a;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [qt("gap", g)]: p } } = d.value, { row: o, col: w } = gx(p);
    return { horizontal: ei(w), vertical: ei(o) };
  }) };
}, render() {
  const { vertical: a, reverse: i, align: l, inline: d, justify: h, itemClass: g, itemStyle: p, margin: o, wrap: w, mergedClsPrefix: S, rtlEnabled: k, useGap: I, wrapItem: z, internalUseGap: R } = this, O = kl(Gp(this), false);
  if (!O.length) return null;
  const V = `${o.horizontal}px`, W = `${o.horizontal / 2}px`, N = `${o.vertical}px`, K = `${o.vertical / 2}px`, Z = O.length - 1, X = h.startsWith("space-");
  return L("div", { role: "none", class: [`${S}-space`, k && `${S}-space--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: a && !i ? "column" : a && i ? "column-reverse" : !a && i ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(h) ? `flex-${h}` : h, flexWrap: !w || a ? "nowrap" : "wrap", marginTop: I || a ? "" : `-${K}`, marginBottom: I || a ? "" : `-${K}`, alignItems: l, gap: I ? `${o.vertical}px ${o.horizontal}px` : "" } }, !z && (I || R) ? O : O.map((te, q) => te.type === bC ? te : L("div", { role: "none", class: g, style: [p, { maxWidth: "100%" }, I ? "" : a ? { marginBottom: q !== Z ? N : "" } : k ? { marginLeft: X ? h === "space-between" && q === Z ? "" : W : q !== Z ? V : "", marginRight: X ? h === "space-between" && q === 0 ? "" : W : "", paddingTop: K, paddingBottom: K } : { marginRight: X ? h === "space-between" && q === Z ? "" : W : q !== Z ? V : "", marginLeft: X ? h === "space-between" && q === 0 ? "" : W : "", paddingTop: K, paddingBottom: K }] }, te)));
} }), II = de("dynamic-tags", [de("input", { minWidth: "var(--n-input-width)" })]), EI = Object.assign(Object.assign(Object.assign({}, tr.props), Yx), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (a) => a }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), RI = ot({ name: "DynamicTags", props: EI, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), { localeRef: d } = Hs("DynamicTags"), h = gs(a), { mergedDisabledRef: g } = h, p = Me(""), o = Me(false), w = Me(true), S = Me(null), k = tr("DynamicTags", "-dynamic-tags", II, gS, a, i), I = Me(a.defaultValue), z = Ot(a, "value"), R = wi(z, I), O = De(() => d.value.add), V = De(() => RP(a.size)), W = De(() => g.value || !!a.max && R.value.length >= a.max);
  function N(Q) {
    const { onChange: oe, "onUpdate:value": ve, onUpdateValue: Be } = a, { nTriggerFormInput: Ne, nTriggerFormChange: Pe } = h;
    oe && Gt(oe, Q), Be && Gt(Be, Q), ve && Gt(ve, Q), I.value = Q, Ne(), Pe();
  }
  function K(Q) {
    const oe = R.value.slice(0);
    oe.splice(Q, 1), N(oe);
  }
  function Z(Q) {
    switch (Q.key) {
      case "Enter":
        X();
    }
  }
  function X(Q) {
    const oe = Q ?? p.value;
    if (oe) {
      const ve = R.value.slice(0);
      ve.push(a.onCreate(oe)), N(ve);
    }
    o.value = false, w.value = true, p.value = "";
  }
  function te() {
    X();
  }
  function q() {
    o.value = true, Vi(() => {
      var Q;
      (Q = S.value) === null || Q === void 0 || Q.focus(), w.value = false;
    });
  }
  const he = De(() => {
    const { self: { inputWidth: Q } } = k.value;
    return { "--n-input-width": Q };
  }), se = l ? hn("dynamic-tags", void 0, he, a) : void 0;
  return { mergedClsPrefix: i, inputInstRef: S, localizedAdd: O, inputSize: V, inputValue: p, showInput: o, inputForceFocused: w, mergedValue: R, mergedDisabled: g, triggerDisabled: W, handleInputKeyDown: Z, handleAddClick: q, handleInputBlur: te, handleCloseClick: K, handleInputConfirm: X, mergedTheme: k, cssVars: l ? void 0 : he, themeClass: se == null ? void 0 : se.themeClass, onRender: se == null ? void 0 : se.onRender };
}, render() {
  const { mergedTheme: a, cssVars: i, mergedClsPrefix: l, onRender: d, renderTag: h } = this;
  return d == null ? void 0 : d(), L(ba, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: i, theme: a.peers.Space, themeOverrides: a.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: g, tagClass: p, tagStyle: o, type: w, round: S, size: k, color: I, closable: z, mergedDisabled: R, showInput: O, inputValue: V, inputClass: W, inputStyle: N, inputSize: K, inputForceFocused: Z, triggerDisabled: X, handleInputKeyDown: te, handleInputBlur: q, handleAddClick: he, handleCloseClick: se, handleInputConfirm: Q, $slots: oe } = this;
    return this.mergedValue.map((ve, Be) => h ? h(ve, Be) : L(bo, { key: Be, theme: g.peers.Tag, themeOverrides: g.peerOverrides.Tag, class: p, style: o, type: w, round: S, size: k, color: I, closable: z, disabled: R, onClose: () => {
      se(Be);
    } }, { default: () => typeof ve == "string" ? ve : ve.label })).concat(O ? oe.input ? oe.input({ submit: Q, deactivate: q }) : L(yo, Object.assign({ placeholder: "", size: K, style: N, class: W, autosize: true }, this.inputProps, { ref: "inputInstRef", value: V, onUpdateValue: (ve) => {
      this.inputValue = ve;
    }, theme: g.peers.Input, themeOverrides: g.peerOverrides.Input, onKeydown: te, onBlur: q, internalForceFocus: Z })) : oe.trigger ? oe.trigger({ activate: he, disabled: X }) : L(jr, { dashed: true, disabled: X, theme: g.peers.Button, themeOverrides: g.peerOverrides.Button, size: K, onClick: he }, { icon: () => L(Ur, { clsPrefix: l }, { default: () => L(Wp, null) }) }));
  } });
} }), zI = Object.assign(Object.assign({}, tr.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), G_ = ot({ name: "Flex", props: zI, setup(a) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Ir(a), d = tr("Flex", "-flex", void 0, vS, a, i);
  return { rtlEnabled: zi("Flex", l, i), mergedClsPrefix: i, margin: De(() => {
    const { size: g } = a;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [qt("gap", g)]: p } } = d.value, { row: o, col: w } = gx(p);
    return { horizontal: ei(w), vertical: ei(o) };
  }) };
}, render() {
  const { vertical: a, reverse: i, align: l, inline: d, justify: h, margin: g, wrap: p, mergedClsPrefix: o, rtlEnabled: w } = this, S = kl(Gp(this), false);
  return S.length ? L("div", { role: "none", class: [`${o}-flex`, w && `${o}-flex--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: a && !i ? "column" : a && i ? "column-reverse" : !a && i ? "row-reverse" : "row", justifyContent: h, flexWrap: !p || a ? "nowrap" : "wrap", alignItems: l, gap: `${g.vertical}px ${g.horizontal}px` } }, S) : null;
} }), Vd = Ai("n-form"), h1 = Ai("n-form-item-insts"), AI = de("form", [Ue("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [de("form-item", { width: "auto", marginRight: "18px" }, [Ge("&:last-child", { marginRight: 0 })])])]);
var DI = function(a, i, l, d) {
  function h(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function o(k) {
      try {
        S(d.next(k));
      } catch (I) {
        p(I);
      }
    }
    function w(k) {
      try {
        S(d.throw(k));
      } catch (I) {
        p(I);
      }
    }
    function S(k) {
      k.done ? g(k.value) : h(k.value).then(o, w);
    }
    S((d = d.apply(a, i || [])).next());
  });
};
const FI = Object.assign(Object.assign({}, tr.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (a) => {
  a.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), Ld = ot({ name: "Form", props: FI, setup(a) {
  const { mergedClsPrefixRef: i } = Ir(a);
  tr("Form", "-form", AI, vx, a, i);
  const l = {}, d = Me(void 0), h = (w) => {
    const S = d.value;
    (S === void 0 || w >= S) && (d.value = w);
  };
  function g(w) {
    return DI(this, arguments, void 0, function* (S, k = () => true) {
      return yield new Promise((I, z) => {
        const R = [];
        for (const O of Ed(l)) {
          const V = l[O];
          for (const W of V) W.path && R.push(W.internalValidate(null, k));
        }
        Promise.all(R).then((O) => {
          const V = O.some((K) => !K.valid), W = [], N = [];
          O.forEach((K) => {
            var Z, X;
            !((Z = K.errors) === null || Z === void 0) && Z.length && W.push(K.errors), !((X = K.warnings) === null || X === void 0) && X.length && N.push(K.warnings);
          }), S && S(W.length ? W : void 0, { warnings: N.length ? N : void 0 }), V ? z(W.length ? W : void 0) : I({ warnings: N.length ? N : void 0 });
        });
      });
    });
  }
  function p() {
    for (const w of Ed(l)) {
      const S = l[w];
      for (const k of S) k.restoreValidation();
    }
  }
  return Zr(Vd, { props: a, maxChildLabelWidthRef: d, deriveMaxChildLabelWidth: h }), Zr(h1, { formItems: l }), Object.assign({ validate: g, restoreValidation: p }, { mergedClsPrefix: i });
}, render() {
  const { mergedClsPrefix: a } = this;
  return L("form", { class: [`${a}-form`, this.inline && `${a}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function bl() {
  return bl = Object.assign ? Object.assign.bind() : function(a) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) Object.prototype.hasOwnProperty.call(l, d) && (a[d] = l[d]);
    }
    return a;
  }, bl.apply(this, arguments);
}
function LI(a, i) {
  a.prototype = Object.create(i.prototype), a.prototype.constructor = a, Bd(a, i);
}
function nv(a) {
  return nv = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, nv(a);
}
function Bd(a, i) {
  return Bd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, h) {
    return d.__proto__ = h, d;
  }, Bd(a, i);
}
function BI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function bp(a, i, l) {
  return BI() ? bp = Reflect.construct.bind() : bp = function(h, g, p) {
    var o = [null];
    o.push.apply(o, g);
    var w = Function.bind.apply(h, o), S = new w();
    return p && Bd(S, p.prototype), S;
  }, bp.apply(null, arguments);
}
function OI(a) {
  return Function.toString.call(a).indexOf("[native code]") !== -1;
}
function iv(a) {
  var i = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return iv = function(d) {
    if (d === null || !OI(d)) return d;
    if (typeof d != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof i < "u") {
      if (i.has(d)) return i.get(d);
      i.set(d, h);
    }
    function h() {
      return bp(d, arguments, nv(this).constructor);
    }
    return h.prototype = Object.create(d.prototype, { constructor: { value: h, enumerable: false, writable: true, configurable: true } }), Bd(h, d);
  }, iv(a);
}
var $I = /%[sdj%]/g, jI = function() {
};
function ov(a) {
  if (!a || !a.length) return null;
  var i = {};
  return a.forEach(function(l) {
    var d = l.field;
    i[d] = i[d] || [], i[d].push(l);
  }), i;
}
function _o(a) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), d = 1; d < i; d++) l[d - 1] = arguments[d];
  var h = 0, g = l.length;
  if (typeof a == "function") return a.apply(null, l);
  if (typeof a == "string") {
    var p = a.replace($I, function(o) {
      if (o === "%%") return "%";
      if (h >= g) return o;
      switch (o) {
        case "%s":
          return String(l[h++]);
        case "%d":
          return Number(l[h++]);
        case "%j":
          try {
            return JSON.stringify(l[h++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return o;
      }
    });
    return p;
  }
  return a;
}
function NI(a) {
  return a === "string" || a === "url" || a === "hex" || a === "email" || a === "date" || a === "pattern";
}
function ri(a, i) {
  return !!(a == null || i === "array" && Array.isArray(a) && !a.length || NI(i) && typeof a == "string" && !a);
}
function VI(a, i, l) {
  var d = [], h = 0, g = a.length;
  function p(o) {
    d.push.apply(d, o || []), h++, h === g && l(d);
  }
  a.forEach(function(o) {
    i(o, p);
  });
}
function W_(a, i, l) {
  var d = 0, h = a.length;
  function g(p) {
    if (p && p.length) {
      l(p);
      return;
    }
    var o = d;
    d = d + 1, o < h ? i(a[o], g) : l([]);
  }
  g([]);
}
function UI(a) {
  var i = [];
  return Object.keys(a).forEach(function(l) {
    i.push.apply(i, a[l] || []);
  }), i;
}
var Z_ = (function(a) {
  LI(i, a);
  function i(l, d) {
    var h;
    return h = a.call(this, "Async Validation Error") || this, h.errors = l, h.fields = d, h;
  }
  return i;
})(iv(Error));
function qI(a, i, l, d, h) {
  if (i.first) {
    var g = new Promise(function(z, R) {
      var O = function(N) {
        return d(N), N.length ? R(new Z_(N, ov(N))) : z(h);
      }, V = UI(a);
      W_(V, l, O);
    });
    return g.catch(function(z) {
      return z;
    }), g;
  }
  var p = i.firstFields === true ? Object.keys(a) : i.firstFields || [], o = Object.keys(a), w = o.length, S = 0, k = [], I = new Promise(function(z, R) {
    var O = function(W) {
      if (k.push.apply(k, W), S++, S === w) return d(k), k.length ? R(new Z_(k, ov(k))) : z(h);
    };
    o.length || (d(k), z(h)), o.forEach(function(V) {
      var W = a[V];
      p.indexOf(V) !== -1 ? W_(W, l, O) : VI(W, l, O);
    });
  });
  return I.catch(function(z) {
    return z;
  }), I;
}
function GI(a) {
  return !!(a && a.message !== void 0);
}
function WI(a, i) {
  for (var l = a, d = 0; d < i.length; d++) {
    if (l == null) return l;
    l = l[i[d]];
  }
  return l;
}
function H_(a, i) {
  return function(l) {
    var d;
    return a.fullFields ? d = WI(i, a.fullFields) : d = i[l.field || a.fullField], GI(l) ? (l.field = l.field || a.fullField, l.fieldValue = d, l) : { message: typeof l == "function" ? l() : l, fieldValue: d, field: l.field || a.fullField };
  };
}
function X_(a, i) {
  if (i) {
    for (var l in i) if (i.hasOwnProperty(l)) {
      var d = i[l];
      typeof d == "object" && typeof a[l] == "object" ? a[l] = bl({}, a[l], d) : a[l] = d;
    }
  }
  return a;
}
var p1 = function(i, l, d, h, g, p) {
  i.required && (!d.hasOwnProperty(i.field) || ri(l, p || i.type)) && h.push(_o(g.messages.required, i.fullField));
}, ZI = function(i, l, d, h, g) {
  (/^\s+$/.test(l) || l === "") && h.push(_o(g.messages.whitespace, i.fullField));
}, np, HI = (function() {
  if (np) return np;
  var a = "[a-fA-F\\d:]", i = function(X) {
    return X && X.includeBoundaries ? "(?:(?<=\\s|^)(?=" + a + ")|(?<=" + a + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", d = "[a-fA-F\\d]{1,4}", h = (`
(?:
(?:` + d + ":){7}(?:" + d + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + d + ":){6}(?:" + l + "|:" + d + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + d + ":){5}(?::" + l + "|(?::" + d + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + d + ":){4}(?:(?::" + d + "){0,1}:" + l + "|(?::" + d + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + d + ":){3}(?:(?::" + d + "){0,2}:" + l + "|(?::" + d + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + d + ":){2}(?:(?::" + d + "){0,3}:" + l + "|(?::" + d + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + d + ":){1}(?:(?::" + d + "){0,4}:" + l + "|(?::" + d + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + d + "){0,5}:" + l + "|(?::" + d + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), g = new RegExp("(?:^" + l + "$)|(?:^" + h + "$)"), p = new RegExp("^" + l + "$"), o = new RegExp("^" + h + "$"), w = function(X) {
    return X && X.exact ? g : new RegExp("(?:" + i(X) + l + i(X) + ")|(?:" + i(X) + h + i(X) + ")", "g");
  };
  w.v4 = function(Z) {
    return Z && Z.exact ? p : new RegExp("" + i(Z) + l + i(Z), "g");
  }, w.v6 = function(Z) {
    return Z && Z.exact ? o : new RegExp("" + i(Z) + h + i(Z), "g");
  };
  var S = "(?:(?:[a-z]+:)?//)", k = "(?:\\S+(?::\\S*)?@)?", I = w.v4().source, z = w.v6().source, R = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", O = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", V = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", W = "(?::\\d{2,5})?", N = '(?:[/?#][^\\s"]*)?', K = "(?:" + S + "|www\\.)" + k + "(?:localhost|" + I + "|" + z + "|" + R + O + V + ")" + W + N;
  return np = new RegExp("(?:^" + K + "$)", "i"), np;
}), Y_ = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, _d = { integer: function(i) {
  return _d.number(i) && parseInt(i, 10) === i;
}, float: function(i) {
  return _d.number(i) && !_d.integer(i);
}, array: function(i) {
  return Array.isArray(i);
}, regexp: function(i) {
  if (i instanceof RegExp) return true;
  try {
    return !!new RegExp(i);
  } catch {
    return false;
  }
}, date: function(i) {
  return typeof i.getTime == "function" && typeof i.getMonth == "function" && typeof i.getYear == "function" && !isNaN(i.getTime());
}, number: function(i) {
  return isNaN(i) ? false : typeof i == "number";
}, object: function(i) {
  return typeof i == "object" && !_d.array(i);
}, method: function(i) {
  return typeof i == "function";
}, email: function(i) {
  return typeof i == "string" && i.length <= 320 && !!i.match(Y_.email);
}, url: function(i) {
  return typeof i == "string" && i.length <= 2048 && !!i.match(HI());
}, hex: function(i) {
  return typeof i == "string" && !!i.match(Y_.hex);
} }, XI = function(i, l, d, h, g) {
  if (i.required && l === void 0) {
    p1(i, l, d, h, g);
    return;
  }
  var p = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], o = i.type;
  p.indexOf(o) > -1 ? _d[o](l) || h.push(_o(g.messages.types[o], i.fullField, i.type)) : o && typeof l !== i.type && h.push(_o(g.messages.types[o], i.fullField, i.type));
}, YI = function(i, l, d, h, g) {
  var p = typeof i.len == "number", o = typeof i.min == "number", w = typeof i.max == "number", S = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, k = l, I = null, z = typeof l == "number", R = typeof l == "string", O = Array.isArray(l);
  if (z ? I = "number" : R ? I = "string" : O && (I = "array"), !I) return false;
  O && (k = l.length), R && (k = l.replace(S, "_").length), p ? k !== i.len && h.push(_o(g.messages[I].len, i.fullField, i.len)) : o && !w && k < i.min ? h.push(_o(g.messages[I].min, i.fullField, i.min)) : w && !o && k > i.max ? h.push(_o(g.messages[I].max, i.fullField, i.max)) : o && w && (k < i.min || k > i.max) && h.push(_o(g.messages[I].range, i.fullField, i.min, i.max));
}, $c = "enum", KI = function(i, l, d, h, g) {
  i[$c] = Array.isArray(i[$c]) ? i[$c] : [], i[$c].indexOf(l) === -1 && h.push(_o(g.messages[$c], i.fullField, i[$c].join(", ")));
}, JI = function(i, l, d, h, g) {
  if (i.pattern) {
    if (i.pattern instanceof RegExp) i.pattern.lastIndex = 0, i.pattern.test(l) || h.push(_o(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    else if (typeof i.pattern == "string") {
      var p = new RegExp(i.pattern);
      p.test(l) || h.push(_o(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    }
  }
}, Br = { required: p1, whitespace: ZI, type: XI, range: YI, enum: KI, pattern: JI }, QI = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l, "string") && !i.required) return d();
    Br.required(i, l, h, p, g, "string"), ri(l, "string") || (Br.type(i, l, h, p, g), Br.range(i, l, h, p, g), Br.pattern(i, l, h, p, g), i.whitespace === true && Br.whitespace(i, l, h, p, g));
  }
  d(p);
}, eE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && Br.type(i, l, h, p, g);
  }
  d(p);
}, tE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (l === "" && (l = void 0), ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && (Br.type(i, l, h, p, g), Br.range(i, l, h, p, g));
  }
  d(p);
}, rE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && Br.type(i, l, h, p, g);
  }
  d(p);
}, nE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), ri(l) || Br.type(i, l, h, p, g);
  }
  d(p);
}, iE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && (Br.type(i, l, h, p, g), Br.range(i, l, h, p, g));
  }
  d(p);
}, oE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && (Br.type(i, l, h, p, g), Br.range(i, l, h, p, g));
  }
  d(p);
}, sE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (l == null && !i.required) return d();
    Br.required(i, l, h, p, g, "array"), l != null && (Br.type(i, l, h, p, g), Br.range(i, l, h, p, g));
  }
  d(p);
}, aE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && Br.type(i, l, h, p, g);
  }
  d(p);
}, lE = "enum", cE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g), l !== void 0 && Br[lE](i, l, h, p, g);
  }
  d(p);
}, uE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l, "string") && !i.required) return d();
    Br.required(i, l, h, p, g), ri(l, "string") || Br.pattern(i, l, h, p, g);
  }
  d(p);
}, dE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l, "date") && !i.required) return d();
    if (Br.required(i, l, h, p, g), !ri(l, "date")) {
      var w;
      l instanceof Date ? w = l : w = new Date(l), Br.type(i, w, h, p, g), w && Br.range(i, w.getTime(), h, p, g);
    }
  }
  d(p);
}, hE = function(i, l, d, h, g) {
  var p = [], o = Array.isArray(l) ? "array" : typeof l;
  Br.required(i, l, h, p, g, o), d(p);
}, wm = function(i, l, d, h, g) {
  var p = i.type, o = [], w = i.required || !i.required && h.hasOwnProperty(i.field);
  if (w) {
    if (ri(l, p) && !i.required) return d();
    Br.required(i, l, h, o, g, p), ri(l, p) || Br.type(i, l, h, o, g);
  }
  d(o);
}, pE = function(i, l, d, h, g) {
  var p = [], o = i.required || !i.required && h.hasOwnProperty(i.field);
  if (o) {
    if (ri(l) && !i.required) return d();
    Br.required(i, l, h, p, g);
  }
  d(p);
}, Pd = { string: QI, method: eE, number: tE, boolean: rE, regexp: nE, integer: iE, float: oE, array: sE, object: aE, enum: cE, pattern: uE, date: dE, url: wm, hex: wm, email: wm, required: hE, any: pE };
function sv() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var i = JSON.parse(JSON.stringify(this));
    return i.clone = this.clone, i;
  } };
}
var av = sv(), Xc = (function() {
  function a(l) {
    this.rules = null, this._messages = av, this.define(l);
  }
  var i = a.prototype;
  return i.define = function(d) {
    var h = this;
    if (!d) throw new Error("Cannot configure a schema with no rules");
    if (typeof d != "object" || Array.isArray(d)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(d).forEach(function(g) {
      var p = d[g];
      h.rules[g] = Array.isArray(p) ? p : [p];
    });
  }, i.messages = function(d) {
    return d && (this._messages = X_(sv(), d)), this._messages;
  }, i.validate = function(d, h, g) {
    var p = this;
    h === void 0 && (h = {}), g === void 0 && (g = function() {
    });
    var o = d, w = h, S = g;
    if (typeof w == "function" && (S = w, w = {}), !this.rules || Object.keys(this.rules).length === 0) return S && S(null, o), Promise.resolve(o);
    function k(V) {
      var W = [], N = {};
      function K(X) {
        if (Array.isArray(X)) {
          var te;
          W = (te = W).concat.apply(te, X);
        } else W.push(X);
      }
      for (var Z = 0; Z < V.length; Z++) K(V[Z]);
      W.length ? (N = ov(W), S(W, N)) : S(null, o);
    }
    if (w.messages) {
      var I = this.messages();
      I === av && (I = sv()), X_(I, w.messages), w.messages = I;
    } else w.messages = this.messages();
    var z = {}, R = w.keys || Object.keys(this.rules);
    R.forEach(function(V) {
      var W = p.rules[V], N = o[V];
      W.forEach(function(K) {
        var Z = K;
        typeof Z.transform == "function" && (o === d && (o = bl({}, o)), N = o[V] = Z.transform(N)), typeof Z == "function" ? Z = { validator: Z } : Z = bl({}, Z), Z.validator = p.getValidationMethod(Z), Z.validator && (Z.field = V, Z.fullField = Z.fullField || V, Z.type = p.getType(Z), z[V] = z[V] || [], z[V].push({ rule: Z, value: N, source: o, field: V }));
      });
    });
    var O = {};
    return qI(z, w, function(V, W) {
      var _a3;
      var N = V.rule, K = (N.type === "object" || N.type === "array") && (typeof N.fields == "object" || typeof N.defaultField == "object");
      K = K && (N.required || !N.required && V.value), N.field = V.field;
      function Z(q, he) {
        return bl({}, he, { fullField: N.fullField + "." + q, fullFields: N.fullFields ? [].concat(N.fullFields, [q]) : [q] });
      }
      function X(q) {
        q === void 0 && (q = []);
        var he = Array.isArray(q) ? q : [q];
        !w.suppressWarning && he.length && a.warning("async-validator:", he), he.length && N.message !== void 0 && (he = [].concat(N.message));
        var se = he.map(H_(N, o));
        if (w.first && se.length) return O[N.field] = 1, W(se);
        if (!K) W(se);
        else {
          if (N.required && !V.value) return N.message !== void 0 ? se = [].concat(N.message).map(H_(N, o)) : w.error && (se = [w.error(N, _o(w.messages.required, N.field))]), W(se);
          var Q = {};
          N.defaultField && Object.keys(V.value).map(function(Be) {
            Q[Be] = N.defaultField;
          }), Q = bl({}, Q, V.rule.fields);
          var oe = {};
          Object.keys(Q).forEach(function(Be) {
            var Ne = Q[Be], Pe = Array.isArray(Ne) ? Ne : [Ne];
            oe[Be] = Pe.map(Z.bind(null, Be));
          });
          var ve = new a(oe);
          ve.messages(w.messages), V.rule.options && (V.rule.options.messages = w.messages, V.rule.options.error = w.error), ve.validate(V.value, V.rule.options || w, function(Be) {
            var Ne = [];
            se && se.length && Ne.push.apply(Ne, se), Be && Be.length && Ne.push.apply(Ne, Be), W(Ne.length ? Ne : null);
          });
        }
      }
      var te;
      if (N.asyncValidator) te = N.asyncValidator(N, V.value, X, V.source, w);
      else if (N.validator) {
        try {
          te = N.validator(N, V.value, X, V.source, w);
        } catch (q) {
          (_a3 = console.error) == null ? void 0 : _a3.call(console, q), w.suppressValidatorError || setTimeout(function() {
            throw q;
          }, 0), X(q.message);
        }
        te === true ? X() : te === false ? X(typeof N.message == "function" ? N.message(N.fullField || N.field) : N.message || (N.fullField || N.field) + " fails") : te instanceof Array ? X(te) : te instanceof Error && X(te.message);
      }
      te && te.then && te.then(function() {
        return X();
      }, function(q) {
        return X(q);
      });
    }, function(V) {
      k(V);
    }, o);
  }, i.getType = function(d) {
    if (d.type === void 0 && d.pattern instanceof RegExp && (d.type = "pattern"), typeof d.validator != "function" && d.type && !Pd.hasOwnProperty(d.type)) throw new Error(_o("Unknown rule type %s", d.type));
    return d.type || "string";
  }, i.getValidationMethod = function(d) {
    if (typeof d.validator == "function") return d.validator;
    var h = Object.keys(d), g = h.indexOf("message");
    return g !== -1 && h.splice(g, 1), h.length === 1 && h[0] === "required" ? Pd.required : Pd[this.getType(d)] || void 0;
  }, a;
})();
Xc.register = function(i, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  Pd[i] = l;
};
Xc.warning = jI;
Xc.messages = av;
Xc.validators = Pd;
const { cubicBezierEaseInOut: K_ } = Nd;
function fE({ name: a = "fade-down", fromOffset: i = "-4px", enterDuration: l = ".3s", leaveDuration: d = ".3s", enterCubicBezier: h = K_, leaveCubicBezier: g = K_ } = {}) {
  return [Ge(`&.${a}-transition-enter-from, &.${a}-transition-leave-to`, { opacity: 0, transform: `translateY(${i})` }), Ge(`&.${a}-transition-enter-to, &.${a}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), Ge(`&.${a}-transition-leave-active`, { transition: `opacity ${d} ${g}, transform ${d} ${g}` }), Ge(`&.${a}-transition-enter-active`, { transition: `opacity ${l} ${h}, transform ${l} ${h}` })];
}
const mE = de("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [de("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Ae("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Ae("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), de("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ue("auto-label-width", [de("form-item-label", "white-space: nowrap;")]), Ue("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [de("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ue("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ue("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ue("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ue("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ae("text", `
 grid-area: text; 
 `), Ae("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ue("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ue("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), de("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), de("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), de("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [Ge("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), de("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ue("warning", { color: "var(--n-feedback-text-color-warning)" }), Ue("error", { color: "var(--n-feedback-text-color-error)" }), fE({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function gE(a) {
  const i = hr(Vd, null);
  return { mergedSize: De(() => a.size !== void 0 ? a.size : (i == null ? void 0 : i.props.size) !== void 0 ? i.props.size : "medium") };
}
function vE(a) {
  const i = hr(Vd, null), l = De(() => {
    const { labelPlacement: O } = a;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.labelPlacement) ? i.props.labelPlacement : "top";
  }), d = De(() => l.value === "left" && (a.labelWidth === "auto" || (i == null ? void 0 : i.props.labelWidth) === "auto")), h = De(() => {
    if (l.value === "top") return;
    const { labelWidth: O } = a;
    if (O !== void 0 && O !== "auto") return qo(O);
    if (d.value) {
      const V = i == null ? void 0 : i.maxChildLabelWidthRef.value;
      return V !== void 0 ? qo(V) : void 0;
    }
    if ((i == null ? void 0 : i.props.labelWidth) !== void 0) return qo(i.props.labelWidth);
  }), g = De(() => {
    const { labelAlign: O } = a;
    if (O) return O;
    if (i == null ? void 0 : i.props.labelAlign) return i.props.labelAlign;
  }), p = De(() => {
    var O;
    return [(O = a.labelProps) === null || O === void 0 ? void 0 : O.style, a.labelStyle, { width: h.value }];
  }), o = De(() => {
    const { showRequireMark: O } = a;
    return O !== void 0 ? O : i == null ? void 0 : i.props.showRequireMark;
  }), w = De(() => {
    const { requireMarkPlacement: O } = a;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.requireMarkPlacement) || "right";
  }), S = Me(false), k = Me(false), I = De(() => {
    const { validationStatus: O } = a;
    if (O !== void 0) return O;
    if (S.value) return "error";
    if (k.value) return "warning";
  }), z = De(() => {
    const { showFeedback: O } = a;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showFeedback) !== void 0 ? i.props.showFeedback : true;
  }), R = De(() => {
    const { showLabel: O } = a;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showLabel) !== void 0 ? i.props.showLabel : true;
  });
  return { validationErrored: S, validationWarned: k, mergedLabelStyle: p, mergedLabelPlacement: l, mergedLabelAlign: g, mergedShowRequireMark: o, mergedRequireMarkPlacement: w, mergedValidationStatus: I, mergedShowFeedback: z, mergedShowLabel: R, isAutoLabelWidth: d };
}
function yE(a) {
  const i = hr(Vd, null), l = De(() => {
    const { rulePath: p } = a;
    if (p !== void 0) return p;
    const { path: o } = a;
    if (o !== void 0) return o;
  }), d = De(() => {
    const p = [], { rule: o } = a;
    if (o !== void 0 && (Array.isArray(o) ? p.push(...o) : p.push(o)), i) {
      const { rules: w } = i.props, { value: S } = l;
      if (w !== void 0 && S !== void 0) {
        const k = yx(w, S);
        k !== void 0 && (Array.isArray(k) ? p.push(...k) : p.push(k));
      }
    }
    return p;
  }), h = De(() => d.value.some((p) => p.required)), g = De(() => h.value || a.required);
  return { mergedRules: d, mergedRequired: g };
}
var J_ = function(a, i, l, d) {
  function h(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function o(k) {
      try {
        S(d.next(k));
      } catch (I) {
        p(I);
      }
    }
    function w(k) {
      try {
        S(d.throw(k));
      } catch (I) {
        p(I);
      }
    }
    function S(k) {
      k.done ? g(k.value) : h(k.value).then(o, w);
    }
    S((d = d.apply(a, i || [])).next());
  });
};
const _E = Object.assign(Object.assign({}, tr.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object });
function Q_(a, i) {
  return (...l) => {
    try {
      const d = a(...l);
      return !i && (typeof d == "boolean" || d instanceof Error || Array.isArray(d)) || (d == null ? void 0 : d.then) ? d : (d === void 0 || kp("form-item/validate", `You return a ${typeof d} typed value in the validator method, which is not recommended. Please use ${i ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (d) {
      kp("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(d);
      return;
    }
  };
}
const yi = ot({ name: "FormItem", props: _E, setup(a) {
  wP(h1, "formItems", Ot(a, "path"));
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = hr(Vd, null), h = gE(a), g = vE(a), { validationErrored: p, validationWarned: o } = g, { mergedRequired: w, mergedRules: S } = yE(a), { mergedSize: k } = h, { mergedLabelPlacement: I, mergedLabelAlign: z, mergedRequireMarkPlacement: R } = g, O = Me([]), V = Me(Tl()), W = d ? Ot(d.props, "disabled") : Me(false), N = tr("Form", "-form-item", mE, vx, a, i);
  Kt(Ot(a, "path"), () => {
    a.ignorePathChange || K();
  });
  function K() {
    O.value = [], p.value = false, o.value = false, a.feedback && (V.value = Tl());
  }
  const Z = (...Pe) => J_(this, [...Pe], void 0, function* (tt = null, at = () => true, xt = { suppressWarning: true }) {
    const { path: ht } = a;
    xt ? xt.first || (xt.first = a.first) : xt = {};
    const { value: Ye } = S, Ke = d ? yx(d.props.model, ht || "") : void 0, Lt = {}, ct = {}, bt = (tt ? Ye.filter((rr) => Array.isArray(rr.trigger) ? rr.trigger.includes(tt) : rr.trigger === tt) : Ye).filter(at).map((rr, yt) => {
      const Ct = Object.assign({}, rr);
      if (Ct.validator && (Ct.validator = Q_(Ct.validator, false)), Ct.asyncValidator && (Ct.asyncValidator = Q_(Ct.asyncValidator, true)), Ct.renderMessage) {
        const Dt = `__renderMessage__${yt}`;
        ct[Dt] = Ct.message, Ct.message = Dt, Lt[Dt] = Ct.renderMessage;
      }
      return Ct;
    }), Nt = bt.filter((rr) => rr.level !== "warning"), Yt = bt.filter((rr) => rr.level === "warning"), vt = { valid: true, errors: void 0, warnings: void 0 };
    if (!bt.length) return vt;
    const jt = ht ?? "__n_no_path__", er = new Xc({ [jt]: Nt }), yr = new Xc({ [jt]: Yt }), { validateMessages: Tr } = (d == null ? void 0 : d.props) || {};
    Tr && (er.messages(Tr), yr.messages(Tr));
    const zr = (rr) => {
      O.value = rr.map((yt) => {
        const Ct = (yt == null ? void 0 : yt.message) || "";
        return { key: Ct, render: () => Ct.startsWith("__renderMessage__") ? Lt[Ct]() : Ct };
      }), rr.forEach((yt) => {
        var Ct;
        !((Ct = yt.message) === null || Ct === void 0) && Ct.startsWith("__renderMessage__") && (yt.message = ct[yt.message]);
      });
    };
    if (Nt.length) {
      const rr = yield new Promise((yt) => {
        er.validate({ [jt]: Ke }, xt, yt);
      });
      (rr == null ? void 0 : rr.length) && (vt.valid = false, vt.errors = rr, zr(rr));
    }
    if (Yt.length && !vt.errors) {
      const rr = yield new Promise((yt) => {
        yr.validate({ [jt]: Ke }, xt, yt);
      });
      (rr == null ? void 0 : rr.length) && (zr(rr), vt.warnings = rr);
    }
    return !vt.errors && !vt.warnings ? K() : (p.value = !!vt.errors, o.value = !!vt.warnings), vt;
  });
  function X() {
    Z("blur");
  }
  function te() {
    Z("change");
  }
  function q() {
    Z("focus");
  }
  function he() {
    Z("input");
  }
  function se(Pe, tt) {
    return J_(this, void 0, void 0, function* () {
      let at, xt, ht, Ye;
      return typeof Pe == "string" ? (at = Pe, xt = tt) : Pe !== null && typeof Pe == "object" && (at = Pe.trigger, xt = Pe.callback, ht = Pe.shouldRuleBeApplied, Ye = Pe.options), yield new Promise((Ke, Lt) => {
        Z(at, ht, Ye).then(({ valid: ct, errors: bt, warnings: Nt }) => {
          ct ? (xt && xt(void 0, { warnings: Nt }), Ke({ warnings: Nt })) : (xt && xt(bt, { warnings: Nt }), Lt(bt));
        });
      });
    });
  }
  Zr(yS, { path: Ot(a, "path"), disabled: W, mergedSize: h.mergedSize, mergedValidationStatus: g.mergedValidationStatus, restoreValidation: K, handleContentBlur: X, handleContentChange: te, handleContentFocus: q, handleContentInput: he });
  const Q = { validate: se, restoreValidation: K, internalValidate: Z }, oe = Me(null);
  Tn(() => {
    if (!g.isAutoLabelWidth.value) return;
    const Pe = oe.value;
    if (Pe !== null) {
      const tt = Pe.style.whiteSpace;
      Pe.style.whiteSpace = "nowrap", Pe.style.width = "", d == null ? void 0 : d.deriveMaxChildLabelWidth(Number(getComputedStyle(Pe).width.slice(0, -2))), Pe.style.whiteSpace = tt;
    }
  });
  const ve = De(() => {
    var Pe;
    const { value: tt } = k, { value: at } = I, xt = at === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: ht }, self: { labelTextColor: Ye, asteriskColor: Ke, lineHeight: Lt, feedbackTextColor: ct, feedbackTextColorWarning: bt, feedbackTextColorError: Nt, feedbackPadding: Yt, labelFontWeight: vt, [qt("labelHeight", tt)]: jt, [qt("blankHeight", tt)]: er, [qt("feedbackFontSize", tt)]: yr, [qt("feedbackHeight", tt)]: Tr, [qt("labelPadding", xt)]: zr, [qt("labelTextAlign", xt)]: rr, [qt(qt("labelFontSize", at), tt)]: yt } } = N.value;
    let Ct = (Pe = z.value) !== null && Pe !== void 0 ? Pe : rr;
    return at === "top" && (Ct = Ct === "right" ? "flex-end" : "flex-start"), { "--n-bezier": ht, "--n-line-height": Lt, "--n-blank-height": er, "--n-label-font-size": yt, "--n-label-text-align": Ct, "--n-label-height": jt, "--n-label-padding": zr, "--n-label-font-weight": vt, "--n-asterisk-color": Ke, "--n-label-text-color": Ye, "--n-feedback-padding": Yt, "--n-feedback-font-size": yr, "--n-feedback-height": Tr, "--n-feedback-text-color": ct, "--n-feedback-text-color-warning": bt, "--n-feedback-text-color-error": Nt };
  }), Be = l ? hn("form-item", De(() => {
    var Pe;
    return `${k.value[0]}${I.value[0]}${((Pe = z.value) === null || Pe === void 0 ? void 0 : Pe[0]) || ""}`;
  }), ve, a) : void 0, Ne = De(() => I.value === "left" && R.value === "left" && z.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: oe, mergedClsPrefix: i, mergedRequired: w, feedbackId: V, renderExplains: O, reverseColSpace: Ne }, g), h), Q), { cssVars: l ? void 0 : ve, themeClass: Be == null ? void 0 : Be.themeClass, onRender: Be == null ? void 0 : Be.onRender });
}, render() {
  const { $slots: a, mergedClsPrefix: i, mergedShowLabel: l, mergedShowRequireMark: d, mergedRequireMarkPlacement: h, onRender: g } = this, p = d !== void 0 ? d : this.mergedRequired;
  g == null ? void 0 : g();
  const o = () => {
    const w = this.$slots.label ? this.$slots.label() : this.label;
    if (!w) return null;
    const S = L("span", { class: `${i}-form-item-label__text` }, w), k = p ? L("span", { class: `${i}-form-item-label__asterisk` }, h !== "left" ? "\xA0*" : "*\xA0") : h === "right-hanging" && L("span", { class: `${i}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: I } = this;
    return L("label", Object.assign({}, I, { class: [I == null ? void 0 : I.class, `${i}-form-item-label`, `${i}-form-item-label--${h}-mark`, this.reverseColSpace && `${i}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), h === "left" ? [k, S] : [S, k]);
  };
  return L("div", { class: [`${i}-form-item`, this.themeClass, `${i}-form-item--${this.mergedSize}-size`, `${i}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${i}-form-item--auto-label-width`, !l && `${i}-form-item--no-label`], style: this.cssVars }, l && o(), L("div", { class: [`${i}-form-item-blank`, this.mergedValidationStatus && `${i}-form-item-blank--${this.mergedValidationStatus}`] }, a), this.mergedShowFeedback ? L("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${i}-form-item-feedback-wrapper`, this.feedbackClass] }, L(Ro, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: w } = this;
    return dn(a.feedback, (S) => {
      var k;
      const { feedback: I } = this, z = S || I ? L("div", { key: "__feedback__", class: `${i}-form-item-feedback__line` }, S || I) : this.renderExplains.length ? (k = this.renderExplains) === null || k === void 0 ? void 0 : k.map(({ key: R, render: O }) => L("div", { key: R, class: `${i}-form-item-feedback__line` }, O())) : null;
      return z ? w === "warning" ? L("div", { key: "controlled-warning", class: `${i}-form-item-feedback ${i}-form-item-feedback--warning` }, z) : w === "error" ? L("div", { key: "controlled-error", class: `${i}-form-item-feedback ${i}-form-item-feedback--error` }, z) : w === "success" ? L("div", { key: "controlled-success", class: `${i}-form-item-feedback ${i}-form-item-feedback--success` }, z) : L("div", { key: "controlled-default", class: `${i}-form-item-feedback` }, z) : null;
    });
  } })) : null);
} }), e0 = 1, f1 = Ai("n-grid"), m1 = 1, bE = { span: { type: [Number, String], default: m1 }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, xE = ot({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: bE, setup() {
  const { isSsrRef: a, xGapRef: i, itemStyleRef: l, overflowRef: d, layoutShiftDisabledRef: h } = hr(f1), g = Qc();
  return { overflow: d, itemStyle: l, layoutShiftDisabled: h, mergedXGap: De(() => Ni(i.value || 0)), deriveStyle: () => {
    a.value;
    const { privateSpan: p = m1, privateShow: o = true, privateColStart: w = void 0, privateOffset: S = 0 } = g.vnode.props, { value: k } = i, I = Ni(k || 0);
    return { display: o ? "" : "none", gridColumn: `${w ?? `span ${p}`} / span ${p}`, marginLeft: S ? `calc((100% - (${p} - 1) * ${I}) / ${p} * ${S} + ${I} * ${S})` : "" };
  } };
}, render() {
  var a, i;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: d, mergedXGap: h } = this;
    return L("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: d ? `calc((100% - (${l} - 1) * ${h}) / ${l} * ${d} + ${h} * ${d})` : "" } }, this.$slots);
  }
  return L("div", { style: [this.itemStyle, this.deriveStyle()] }, (i = (a = this.$slots).default) === null || i === void 0 ? void 0 : i.call(a, { overflow: this.overflow }));
} }), wE = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, g1 = 24, Cm = "__ssr__", CE = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: g1 }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, SE = ot({ name: "Grid", inheritAttrs: false, props: CE, setup(a) {
  const { mergedClsPrefixRef: i, mergedBreakpointsRef: l } = Ir(a), d = /^\d+$/, h = Me(void 0), g = xP((l == null ? void 0 : l.value) || wE), p = vn(() => !!(a.itemResponsive || !d.test(a.cols.toString()) || !d.test(a.xGap.toString()) || !d.test(a.yGap.toString()))), o = De(() => {
    if (p.value) return a.responsive === "self" ? h.value : g.value;
  }), w = vn(() => {
    var N;
    return (N = Number(Fc(a.cols.toString(), o.value))) !== null && N !== void 0 ? N : g1;
  }), S = vn(() => Fc(a.xGap.toString(), o.value)), k = vn(() => Fc(a.yGap.toString(), o.value)), I = (N) => {
    h.value = N.contentRect.width;
  }, z = (N) => {
    Fp(I, N);
  }, R = Me(false), O = De(() => {
    if (a.responsive === "self") return z;
  }), V = Me(false), W = Me();
  return Tn(() => {
    const { value: N } = W;
    N && N.hasAttribute(Cm) && (N.removeAttribute(Cm), V.value = true);
  }), Zr(f1, { layoutShiftDisabledRef: Ot(a, "layoutShiftDisabled"), isSsrRef: V, itemStyleRef: Ot(a, "itemStyle"), xGapRef: S, overflowRef: R }), { isSsr: !Vp, contentEl: W, mergedClsPrefix: i, style: De(() => a.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${a.cols}, minmax(0, 1fr))`, columnGap: Ni(a.xGap), rowGap: Ni(a.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${w.value}, minmax(0, 1fr))`, columnGap: Ni(S.value), rowGap: Ni(k.value) }), isResponsive: p, responsiveQuery: o, responsiveCols: w, handleResize: O, overflow: R };
}, render() {
  if (this.layoutShiftDisabled) return L("div", qs({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const a = () => {
    var i, l, d, h, g, p, o;
    this.overflow = false;
    const w = kl(Gp(this)), S = [], { collapsed: k, collapsedRows: I, responsiveCols: z, responsiveQuery: R } = this;
    w.forEach((K) => {
      var Z, X, te, q, he;
      if (((Z = K == null ? void 0 : K.type) === null || Z === void 0 ? void 0 : Z.__GRID_ITEM__) !== true) return;
      if (zP(K)) {
        const oe = Vg(K);
        oe.props ? oe.props.privateShow = false : oe.props = { privateShow: false }, S.push({ child: oe, rawChildSpan: 0 });
        return;
      }
      K.dirs = ((X = K.dirs) === null || X === void 0 ? void 0 : X.filter(({ dir: oe }) => oe !== Gs)) || null, ((te = K.dirs) === null || te === void 0 ? void 0 : te.length) === 0 && (K.dirs = null);
      const se = Vg(K), Q = Number((he = Fc((q = se.props) === null || q === void 0 ? void 0 : q.span, R)) !== null && he !== void 0 ? he : e0);
      Q !== 0 && S.push({ child: se, rawChildSpan: Q });
    });
    let O = 0;
    const V = (i = S[S.length - 1]) === null || i === void 0 ? void 0 : i.child;
    if (V == null ? void 0 : V.props) {
      const K = (l = V.props) === null || l === void 0 ? void 0 : l.suffix;
      K !== void 0 && K !== false && (O = Number((h = Fc((d = V.props) === null || d === void 0 ? void 0 : d.span, R)) !== null && h !== void 0 ? h : e0), V.props.privateSpan = O, V.props.privateColStart = z + 1 - O, V.props.privateShow = (g = V.props.privateShow) !== null && g !== void 0 ? g : true);
    }
    let W = 0, N = false;
    for (const { child: K, rawChildSpan: Z } of S) {
      if (N && (this.overflow = true), !N) {
        const X = Number((o = Fc((p = K.props) === null || p === void 0 ? void 0 : p.offset, R)) !== null && o !== void 0 ? o : 0), te = Math.min(Z + X, z);
        if (K.props ? (K.props.privateSpan = te, K.props.privateOffset = X) : K.props = { privateSpan: te, privateOffset: X }, k) {
          const q = W % z;
          te + q > z && (W += z - q), te + W + O > I * z ? N = true : W += te;
        }
      }
      N && (K.props ? K.props.privateShow !== true && (K.props.privateShow = false) : K.props = { privateShow: false });
    }
    return L("div", qs({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [Cm]: this.isSsr || void 0 }, this.$attrs), S.map(({ child: K }) => K));
  };
  return this.isResponsive && this.responsive === "self" ? L(xl, { onResize: this.handleResize }, { default: a }) : a();
} });
function kE() {
  return L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function PE() {
  return L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function TE() {
  return L("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, L("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const Ev = Object.assign(Object.assign({}, tr.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), v1 = Ai("n-image"), ME = Ge([Ge("body >", [de("image-container", "position: fixed;")]), de("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), de("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [Mp()]), de("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [de("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), Mp()]), de("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [Bp()]), de("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), de("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [pn("preview-disabled", `
 cursor: pointer;
 `), Ge("img", `
 border-radius: inherit;
 `)])]), ip = 32, y1 = ot({ name: "ImagePreview", props: Object.assign(Object.assign({}, Ev), { onNext: Function, onPrev: Function, clsPrefix: { type: String, required: true } }), setup(a) {
  const i = tr("Image", "-image", ME, _S, a, Ot(a, "clsPrefix"));
  let l = null;
  const d = Me(null), h = Me(null), g = Me(void 0), p = Me(false), o = Me(false), { localeRef: w } = Hs("Image");
  function S() {
    const { value: yt } = h;
    if (!l || !yt) return;
    const { style: Ct } = yt, Dt = l.getBoundingClientRect(), ir = Dt.left + Dt.width / 2, ut = Dt.top + Dt.height / 2;
    Ct.transformOrigin = `${ir}px ${ut}px`;
  }
  function k(yt) {
    var Ct, Dt;
    switch (yt.key) {
      case " ":
        yt.preventDefault();
        break;
      case "ArrowLeft":
        (Ct = a.onPrev) === null || Ct === void 0 || Ct.call(a);
        break;
      case "ArrowRight":
        (Dt = a.onNext) === null || Dt === void 0 || Dt.call(a);
        break;
      case "Escape":
        vt();
        break;
    }
  }
  Kt(p, (yt) => {
    yt ? Ei("keydown", document, k) : Xi("keydown", document, k);
  }), Ci(() => {
    Xi("keydown", document, k);
  });
  let I = 0, z = 0, R = 0, O = 0, V = 0, W = 0, N = 0, K = 0, Z = false;
  function X(yt) {
    const { clientX: Ct, clientY: Dt } = yt;
    R = Ct - I, O = Dt - z, Fp(Yt);
  }
  function te(yt) {
    const { mouseUpClientX: Ct, mouseUpClientY: Dt, mouseDownClientX: ir, mouseDownClientY: ut } = yt, We = ir - Ct, kt = ut - Dt, et = `vertical${kt > 0 ? "Top" : "Bottom"}`, it = `horizontal${We > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: et, moveHorizontalDirection: it, deltaHorizontal: We, deltaVertical: kt };
  }
  function q(yt) {
    const { value: Ct } = d;
    if (!Ct) return { offsetX: 0, offsetY: 0 };
    const Dt = Ct.getBoundingClientRect(), { moveVerticalDirection: ir, moveHorizontalDirection: ut, deltaHorizontal: We, deltaVertical: kt } = yt || {};
    let et = 0, it = 0;
    return Dt.width <= window.innerWidth ? et = 0 : Dt.left > 0 ? et = (Dt.width - window.innerWidth) / 2 : Dt.right < window.innerWidth ? et = -(Dt.width - window.innerWidth) / 2 : ut === "horizontalRight" ? et = Math.min((Dt.width - window.innerWidth) / 2, V - (We ?? 0)) : et = Math.max(-((Dt.width - window.innerWidth) / 2), V - (We ?? 0)), Dt.height <= window.innerHeight ? it = 0 : Dt.top > 0 ? it = (Dt.height - window.innerHeight) / 2 : Dt.bottom < window.innerHeight ? it = -(Dt.height - window.innerHeight) / 2 : ir === "verticalBottom" ? it = Math.min((Dt.height - window.innerHeight) / 2, W - (kt ?? 0)) : it = Math.max(-((Dt.height - window.innerHeight) / 2), W - (kt ?? 0)), { offsetX: et, offsetY: it };
  }
  function he(yt) {
    Xi("mousemove", document, X), Xi("mouseup", document, he);
    const { clientX: Ct, clientY: Dt } = yt;
    Z = false;
    const ir = te({ mouseUpClientX: Ct, mouseUpClientY: Dt, mouseDownClientX: N, mouseDownClientY: K }), ut = q(ir);
    R = ut.offsetX, O = ut.offsetY, Yt();
  }
  const se = hr(v1, null);
  function Q(yt) {
    var Ct, Dt;
    if ((Dt = (Ct = se == null ? void 0 : se.previewedImgPropsRef.value) === null || Ct === void 0 ? void 0 : Ct.onMousedown) === null || Dt === void 0 || Dt.call(Ct, yt), yt.button !== 0) return;
    const { clientX: ir, clientY: ut } = yt;
    Z = true, I = ir - R, z = ut - O, V = R, W = O, N = ir, K = ut, Yt(), Ei("mousemove", document, X), Ei("mouseup", document, he);
  }
  const oe = 1.5;
  let ve = 0, Be = 1, Ne = 0;
  function Pe(yt) {
    var Ct, Dt;
    (Dt = (Ct = se == null ? void 0 : se.previewedImgPropsRef.value) === null || Ct === void 0 ? void 0 : Ct.onDblclick) === null || Dt === void 0 || Dt.call(Ct, yt);
    const ir = Lt();
    Be = Be === ir ? 1 : ir, Yt();
  }
  function tt() {
    Be = 1, ve = 0;
  }
  function at() {
    var yt;
    tt(), Ne = 0, (yt = a.onPrev) === null || yt === void 0 || yt.call(a);
  }
  function xt() {
    var yt;
    tt(), Ne = 0, (yt = a.onNext) === null || yt === void 0 || yt.call(a);
  }
  function ht() {
    Ne -= 90, Yt();
  }
  function Ye() {
    Ne += 90, Yt();
  }
  function Ke() {
    const { value: yt } = d;
    if (!yt) return 1;
    const { innerWidth: Ct, innerHeight: Dt } = window, ir = Math.max(1, yt.naturalHeight / (Dt - ip)), ut = Math.max(1, yt.naturalWidth / (Ct - ip));
    return Math.max(3, ir * 2, ut * 2);
  }
  function Lt() {
    const { value: yt } = d;
    if (!yt) return 1;
    const { innerWidth: Ct, innerHeight: Dt } = window, ir = yt.naturalHeight / (Dt - ip), ut = yt.naturalWidth / (Ct - ip);
    return ir < 1 && ut < 1 ? 1 : Math.max(ir, ut);
  }
  function ct() {
    const yt = Ke();
    Be < yt && (ve += 1, Be = Math.min(yt, Math.pow(oe, ve)), Yt());
  }
  function bt() {
    if (Be > 0.5) {
      const yt = Be;
      ve -= 1, Be = Math.max(0.5, Math.pow(oe, ve));
      const Ct = yt - Be;
      Yt(false);
      const Dt = q();
      Be += Ct, Yt(false), Be -= Ct, R = Dt.offsetX, O = Dt.offsetY, Yt();
    }
  }
  function Nt() {
    const yt = g.value;
    yt && Zx(yt, void 0);
  }
  function Yt(yt = true) {
    var Ct;
    const { value: Dt } = d;
    if (!Dt) return;
    const { style: ir } = Dt, ut = _i((Ct = se == null ? void 0 : se.previewedImgPropsRef.value) === null || Ct === void 0 ? void 0 : Ct.style);
    let We = "";
    if (typeof ut == "string") We = `${ut};`;
    else for (const et in ut) We += `${Nk(et)}: ${ut[et]};`;
    const kt = `transform-origin: center; transform: translateX(${R}px) translateY(${O}px) rotate(${Ne}deg) scale(${Be});`;
    Z ? ir.cssText = `${We}cursor: grabbing; transition: none;${kt}` : ir.cssText = `${We}cursor: grab;${kt}${yt ? "" : "transition: none;"}`, yt || Dt.offsetHeight;
  }
  function vt() {
    p.value = !p.value, o.value = true;
  }
  function jt() {
    Be = Lt(), ve = Math.ceil(Math.log(Be) / Math.log(oe)), R = 0, O = 0, Yt();
  }
  const er = { setPreviewSrc: (yt) => {
    g.value = yt;
  }, setThumbnailEl: (yt) => {
    l = yt;
  }, toggleShow: vt };
  function yr(yt, Ct) {
    if (a.showToolbarTooltip) {
      const { value: Dt } = i;
      return L(hx, { to: false, theme: Dt.peers.Tooltip, themeOverrides: Dt.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => w.value[Ct], trigger: () => yt });
    } else return yt;
  }
  const Tr = De(() => {
    const { common: { cubicBezierEaseInOut: yt }, self: { toolbarIconColor: Ct, toolbarBorderRadius: Dt, toolbarBoxShadow: ir, toolbarColor: ut } } = i.value;
    return { "--n-bezier": yt, "--n-toolbar-icon-color": Ct, "--n-toolbar-color": ut, "--n-toolbar-border-radius": Dt, "--n-toolbar-box-shadow": ir };
  }), { inlineThemeDisabled: zr } = Ir(), rr = zr ? hn("image-preview", void 0, Tr, a) : void 0;
  return Object.assign({ previewRef: d, previewWrapperRef: h, previewSrc: g, show: p, appear: Up(), displayed: o, previewedImgProps: se == null ? void 0 : se.previewedImgPropsRef, handleWheel(yt) {
    yt.preventDefault();
  }, handlePreviewMousedown: Q, handlePreviewDblclick: Pe, syncTransformOrigin: S, handleAfterLeave: () => {
    tt(), Ne = 0, o.value = false;
  }, handleDragStart: (yt) => {
    var Ct, Dt;
    (Dt = (Ct = se == null ? void 0 : se.previewedImgPropsRef.value) === null || Ct === void 0 ? void 0 : Ct.onDragstart) === null || Dt === void 0 || Dt.call(Ct, yt), yt.preventDefault();
  }, zoomIn: ct, zoomOut: bt, handleDownloadClick: Nt, rotateCounterclockwise: ht, rotateClockwise: Ye, handleSwitchPrev: at, handleSwitchNext: xt, withTooltip: yr, resizeToOrignalImageSize: jt, cssVars: zr ? void 0 : Tr, themeClass: rr == null ? void 0 : rr.themeClass, onRender: rr == null ? void 0 : rr.onRender }, er);
}, render() {
  var a, i;
  const { clsPrefix: l, renderToolbar: d, withTooltip: h } = this, g = h(L(Ur, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: kE }), "tipPrevious"), p = h(L(Ur, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: PE }), "tipNext"), o = h(L(Ur, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => L(RT, null) }), "tipCounterclockwise"), w = h(L(Ur, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => L(ET, null) }), "tipClockwise"), S = h(L(Ur, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => L(MT, null) }), "tipOriginalSize"), k = h(L(Ur, { clsPrefix: l, onClick: this.zoomOut }, { default: () => L(DT, null) }), "tipZoomOut"), I = h(L(Ur, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => L(Hx, null) }), "tipDownload"), z = h(L(Ur, { clsPrefix: l, onClick: this.toggleShow }, { default: TE }), "tipClose"), R = h(L(Ur, { clsPrefix: l, onClick: this.zoomIn }, { default: () => L(AT, null) }), "tipZoomIn");
  return L(qr, null, (i = (a = this.$slots).default) === null || i === void 0 ? void 0 : i.call(a), L(mx, { show: this.show }, { default: () => {
    var O;
    return this.show || this.displayed ? ((O = this.onRender) === null || O === void 0 || O.call(this), fs(L("div", { class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, L(Ro, { name: "fade-in-transition", appear: this.appear }, { default: () => this.show ? L("div", { class: `${l}-image-preview-overlay`, onClick: this.toggleShow }) : null }), this.showToolbar ? L(Ro, { name: "fade-in-transition", appear: this.appear }, { default: () => this.show ? L("div", { class: `${l}-image-preview-toolbar` }, d ? d({ nodes: { prev: g, next: p, rotateCounterclockwise: o, rotateClockwise: w, resizeToOriginalSize: S, zoomOut: k, zoomIn: R, download: I, close: z } }) : L(qr, null, this.onPrev ? L(qr, null, g, p) : null, o, w, S, k, R, I, z)) : null }) : null, L(Ro, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: V = {} } = this;
      return fs(L("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, L("img", Object.assign({}, V, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, V.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[Gs, this.show]]);
    } })), [[fx, { enabled: this.show }]])) : null;
  } }));
} }), _1 = Ai("n-image-group"), IE = Ev, EE = ot({ name: "ImageGroup", props: IE, setup(a) {
  let i;
  const { mergedClsPrefixRef: l } = Ir(a), d = `c${Tl()}`, h = Qc(), g = Me(null), p = (w) => {
    var S;
    i = w, (S = g.value) === null || S === void 0 || S.setPreviewSrc(w);
  };
  function o(w) {
    var S, k;
    if (!(h == null ? void 0 : h.proxy)) return;
    const z = h.proxy.$el.parentElement.querySelectorAll(`[data-group-id=${d}]:not([data-error=true])`);
    if (!z.length) return;
    const R = Array.from(z).findIndex((O) => O.dataset.previewSrc === i);
    ~R ? p(z[(R + w + z.length) % z.length].dataset.previewSrc) : p(z[0].dataset.previewSrc), w === 1 ? (S = a.onPreviewNext) === null || S === void 0 || S.call(a) : (k = a.onPreviewPrev) === null || k === void 0 || k.call(a);
  }
  return Zr(_1, { mergedClsPrefixRef: l, setPreviewSrc: p, setThumbnailEl: (w) => {
    var S;
    (S = g.value) === null || S === void 0 || S.setThumbnailEl(w);
  }, toggleShow: () => {
    var w;
    (w = g.value) === null || w === void 0 || w.toggleShow();
  }, groupId: d, renderToolbarRef: Ot(a, "renderToolbar") }), { mergedClsPrefix: l, previewInstRef: g, next: () => {
    o(1);
  }, prev: () => {
    o(-1);
  } };
}, render() {
  return L(y1, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: this.mergedClsPrefix, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar }, this.$slots);
} }), RE = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, Ev), b1 = ot({ name: "Image", props: RE, slots: Object, inheritAttrs: false, setup(a) {
  const i = Me(null), l = Me(false), d = Me(null), h = hr(_1, null), { mergedClsPrefixRef: g } = h || Ir(a), p = { click: () => {
    if (a.previewDisabled || l.value) return;
    const S = a.previewSrc || a.src;
    if (h) {
      h.setPreviewSrc(S), h.setThumbnailEl(i.value), h.toggleShow();
      return;
    }
    const { value: k } = d;
    k && (k.setPreviewSrc(S), k.setThumbnailEl(i.value), k.toggleShow());
  } }, o = Me(!a.lazy);
  Tn(() => {
    var S;
    (S = i.value) === null || S === void 0 || S.setAttribute("data-group-id", (h == null ? void 0 : h.groupId) || "");
  }), Tn(() => {
    if (a.lazy && a.intersectionObserverOptions) {
      let S;
      const k = zo(() => {
        S == null ? void 0 : S(), S = void 0, S = fM(i.value, a.intersectionObserverOptions, o);
      });
      Ci(() => {
        k(), S == null ? void 0 : S();
      });
    }
  }), zo(() => {
    var S;
    a.src || ((S = a.imgProps) === null || S === void 0 || S.src), l.value = false;
  });
  const w = Me(false);
  return Zr(v1, { previewedImgPropsRef: Ot(a, "previewedImgProps") }), Object.assign({ mergedClsPrefix: g, groupId: h == null ? void 0 : h.groupId, previewInstRef: d, imageRef: i, showError: l, shouldStartLoading: o, loaded: w, mergedOnClick: (S) => {
    var k, I;
    p.click(), (I = (k = a.imgProps) === null || k === void 0 ? void 0 : k.onClick) === null || I === void 0 || I.call(k, S);
  }, mergedOnError: (S) => {
    if (!o.value) return;
    l.value = true;
    const { onError: k, imgProps: { onError: I } = {} } = a;
    k == null ? void 0 : k(S), I == null ? void 0 : I(S);
  }, mergedOnLoad: (S) => {
    const { onLoad: k, imgProps: { onLoad: I } = {} } = a;
    k == null ? void 0 : k(S), I == null ? void 0 : I(S), w.value = true;
  } }, p);
}, render() {
  var a, i;
  const { mergedClsPrefix: l, imgProps: d = {}, loaded: h, $attrs: g, lazy: p } = this, o = Ui(this.$slots.error, () => []), w = (i = (a = this.$slots).placeholder) === null || i === void 0 ? void 0 : i.call(a), S = this.src || d.src, k = this.showError && o.length ? o : L("img", Object.assign(Object.assign({}, d), { ref: "imageRef", width: this.width || d.width, height: this.height || d.height, src: this.showError ? this.fallbackSrc : p && this.intersectionObserverOptions ? this.shouldStartLoading ? S : void 0 : S, alt: this.alt || d.alt, "aria-label": this.alt || d.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: hM && p && !this.intersectionObserverOptions ? "lazy" : "eager", style: [d.style || "", w && !h ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return L("div", Object.assign({}, g, { role: "none", class: [g.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? k : L(y1, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: l, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar }, { default: () => k }), !h && w);
} }), zE = Ge([de("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), de("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function AE(a) {
  return a == null || typeof a == "string" && a.trim() === "" ? null : Number(a);
}
function DE(a) {
  return a.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(a) || /^-?\d*$/.test(a)) || a === "-" || a === "-0";
}
function Sm(a) {
  return a == null ? true : !Number.isNaN(a);
}
function t0(a, i) {
  return typeof a != "number" ? "" : i === void 0 ? String(a) : a.toFixed(i);
}
function km(a) {
  if (a === null) return null;
  if (typeof a == "number") return a;
  {
    const i = Number(a);
    return Number.isNaN(i) ? null : i;
  }
}
const r0 = 800, n0 = 100, FE = Object.assign(Object.assign({}, tr.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), i0 = ot({ name: "InputNumber", props: FE, slots: Object, setup(a) {
  const { mergedBorderedRef: i, mergedClsPrefixRef: l, mergedRtlRef: d } = Ir(a), h = tr("InputNumber", "-input-number", zE, bS, a, l), { localeRef: g } = Hs("InputNumber"), p = gs(a), { mergedSizeRef: o, mergedDisabledRef: w, mergedStatusRef: S } = p, k = Me(null), I = Me(null), z = Me(null), R = Me(a.defaultValue), O = Ot(a, "value"), V = wi(O, R), W = Me(""), N = (ut) => {
    const We = String(ut).split(".")[1];
    return We ? We.length : 0;
  }, K = (ut) => {
    const We = [a.min, a.max, a.step, ut].map((kt) => kt === void 0 ? 0 : N(kt));
    return Math.max(...We);
  }, Z = vn(() => {
    const { placeholder: ut } = a;
    return ut !== void 0 ? ut : g.value.placeholder;
  }), X = vn(() => {
    const ut = km(a.step);
    return ut !== null ? ut === 0 ? 1 : Math.abs(ut) : 1;
  }), te = vn(() => {
    const ut = km(a.min);
    return ut !== null ? ut : null;
  }), q = vn(() => {
    const ut = km(a.max);
    return ut !== null ? ut : null;
  }), he = () => {
    const { value: ut } = V;
    if (Sm(ut)) {
      const { format: We, precision: kt } = a;
      We ? W.value = We(ut) : ut === null || kt === void 0 || N(ut) > kt ? W.value = t0(ut, void 0) : W.value = t0(ut, kt);
    } else W.value = String(ut);
  };
  he();
  const se = (ut) => {
    const { value: We } = V;
    if (ut === We) {
      he();
      return;
    }
    const { "onUpdate:value": kt, onUpdateValue: et, onChange: it } = a, { nTriggerFormInput: Pt, nTriggerFormChange: Et } = p;
    it && Gt(it, ut), et && Gt(et, ut), kt && Gt(kt, ut), R.value = ut, Pt(), Et();
  }, Q = ({ offset: ut, doUpdateIfValid: We, fixPrecision: kt, isInputing: et }) => {
    const { value: it } = W;
    if (et && DE(it)) return false;
    const Pt = (a.parse || AE)(it);
    if (Pt === null) return We && se(null), null;
    if (Sm(Pt)) {
      const Et = N(Pt), { precision: st } = a;
      if (st !== void 0 && st < Et && !kt) return false;
      let St = Number.parseFloat((Pt + ut).toFixed(st ?? K(Pt)));
      if (Sm(St)) {
        const { value: ar } = q, { value: on } = te;
        if (ar !== null && St > ar) {
          if (!We || et) return false;
          St = ar;
        }
        if (on !== null && St < on) {
          if (!We || et) return false;
          St = on;
        }
        return a.validator && !a.validator(St) ? false : (We && se(St), St);
      }
    }
    return false;
  }, oe = vn(() => Q({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), ve = vn(() => {
    const { value: ut } = V;
    if (a.validator && ut === null) return false;
    const { value: We } = X;
    return Q({ offset: -We, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), Be = vn(() => {
    const { value: ut } = V;
    if (a.validator && ut === null) return false;
    const { value: We } = X;
    return Q({ offset: +We, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function Ne(ut) {
    const { onFocus: We } = a, { nTriggerFormFocus: kt } = p;
    We && Gt(We, ut), kt();
  }
  function Pe(ut) {
    var We, kt;
    if (ut.target === ((We = k.value) === null || We === void 0 ? void 0 : We.wrapperElRef)) return;
    const et = Q({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if (et !== false) {
      const Et = (kt = k.value) === null || kt === void 0 ? void 0 : kt.inputElRef;
      Et && (Et.value = String(et || "")), V.value === et && he();
    } else he();
    const { onBlur: it } = a, { nTriggerFormBlur: Pt } = p;
    it && Gt(it, ut), Pt(), Vi(() => {
      he();
    });
  }
  function tt(ut) {
    const { onClear: We } = a;
    We && Gt(We, ut);
  }
  function at() {
    const { value: ut } = Be;
    if (!ut) {
      er();
      return;
    }
    const { value: We } = V;
    if (We === null) a.validator || se(Ke());
    else {
      const { value: kt } = X;
      Q({ offset: kt, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function xt() {
    const { value: ut } = ve;
    if (!ut) {
      vt();
      return;
    }
    const { value: We } = V;
    if (We === null) a.validator || se(Ke());
    else {
      const { value: kt } = X;
      Q({ offset: -kt, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const ht = Ne, Ye = Pe;
  function Ke() {
    if (a.validator) return null;
    const { value: ut } = te, { value: We } = q;
    return ut !== null ? Math.max(0, ut) : We !== null ? Math.min(0, We) : 0;
  }
  function Lt(ut) {
    tt(ut), se(null);
  }
  function ct(ut) {
    var We, kt, et;
    !((We = z.value) === null || We === void 0) && We.$el.contains(ut.target) && ut.preventDefault(), !((kt = I.value) === null || kt === void 0) && kt.$el.contains(ut.target) && ut.preventDefault(), (et = k.value) === null || et === void 0 || et.activate();
  }
  let bt = null, Nt = null, Yt = null;
  function vt() {
    Yt && (window.clearTimeout(Yt), Yt = null), bt && (window.clearInterval(bt), bt = null);
  }
  let jt = null;
  function er() {
    jt && (window.clearTimeout(jt), jt = null), Nt && (window.clearInterval(Nt), Nt = null);
  }
  function yr() {
    vt(), Yt = window.setTimeout(() => {
      bt = window.setInterval(() => {
        xt();
      }, n0);
    }, r0), Ei("mouseup", document, vt, { once: true });
  }
  function Tr() {
    er(), jt = window.setTimeout(() => {
      Nt = window.setInterval(() => {
        at();
      }, n0);
    }, r0), Ei("mouseup", document, er, { once: true });
  }
  const zr = () => {
    Nt || at();
  }, rr = () => {
    bt || xt();
  };
  function yt(ut) {
    var We, kt;
    if (ut.key === "Enter") {
      if (ut.target === ((We = k.value) === null || We === void 0 ? void 0 : We.wrapperElRef)) return;
      Q({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((kt = k.value) === null || kt === void 0 || kt.deactivate());
    } else if (ut.key === "ArrowUp") {
      if (!Be.value || a.keyboard.ArrowUp === false) return;
      ut.preventDefault(), Q({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && at();
    } else if (ut.key === "ArrowDown") {
      if (!ve.value || a.keyboard.ArrowDown === false) return;
      ut.preventDefault(), Q({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && xt();
    }
  }
  function Ct(ut) {
    W.value = ut, a.updateValueOnInput && !a.format && !a.parse && a.precision === void 0 && Q({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  Kt(V, () => {
    he();
  });
  const Dt = { focus: () => {
    var ut;
    return (ut = k.value) === null || ut === void 0 ? void 0 : ut.focus();
  }, blur: () => {
    var ut;
    return (ut = k.value) === null || ut === void 0 ? void 0 : ut.blur();
  }, select: () => {
    var ut;
    return (ut = k.value) === null || ut === void 0 ? void 0 : ut.select();
  } }, ir = zi("InputNumber", d, l);
  return Object.assign(Object.assign({}, Dt), { rtlEnabled: ir, inputInstRef: k, minusButtonInstRef: I, addButtonInstRef: z, mergedClsPrefix: l, mergedBordered: i, uncontrolledValue: R, mergedValue: V, mergedPlaceholder: Z, displayedValueInvalid: oe, mergedSize: o, mergedDisabled: w, displayedValue: W, addable: Be, minusable: ve, mergedStatus: S, handleFocus: ht, handleBlur: Ye, handleClear: Lt, handleMouseDown: ct, handleAddClick: zr, handleMinusClick: rr, handleAddMousedown: Tr, handleMinusMousedown: yr, handleKeyDown: yt, handleUpdateDisplayedValue: Ct, mergedTheme: h, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: De(() => {
    const { self: { iconColorDisabled: ut } } = h.value, [We, kt, et, it] = ds(ut);
    return { textColorTextDisabled: `rgb(${We}, ${kt}, ${et})`, opacityDisabled: `${it}` };
  }) });
}, render() {
  const { mergedClsPrefix: a, $slots: i } = this, l = () => L(T_, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => Ui(i["minus-icon"], () => [L(Ur, { clsPrefix: a }, { default: () => L(TT, null) })]) }), d = () => L(T_, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => Ui(i["add-icon"], () => [L(Ur, { clsPrefix: a }, { default: () => L(Wp, null) })]) });
  return L("div", { class: [`${a}-input-number`, this.rtlEnabled && `${a}-input-number--rtl`] }, L(yo, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var h;
    return this.showButton && this.buttonPlacement === "both" ? [l(), dn(i.prefix, (g) => g ? L("span", { class: `${a}-input-number-prefix` }, g) : null)] : (h = i.prefix) === null || h === void 0 ? void 0 : h.call(i);
  }, suffix: () => {
    var h;
    return this.showButton ? [dn(i.suffix, (g) => g ? L("span", { class: `${a}-input-number-suffix` }, g) : null), this.buttonPlacement === "right" ? l() : null, d()] : (h = i.suffix) === null || h === void 0 ? void 0 : h.call(i);
  } }));
} }), LE = Ge([de("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ue("show-divider", [de("list-item", [Ge("&:not(:last-child)", [Ae("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ue("clickable", [de("list-item", `
 cursor: pointer;
 `)]), Ue("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ue("hoverable", [de("list-item", `
 border-radius: var(--n-border-radius);
 `, [Ge("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Ae("divider", `
 background-color: transparent;
 `)])])]), Ue("bordered, hoverable", [de("list-item", `
 padding: 12px 20px;
 `), Ae("header, footer", `
 padding: 12px 20px;
 `)]), Ae("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [Ge("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), de("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ae("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Ae("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Ae("main", `
 flex: 1;
 `), Ae("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), ox(de("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), sx(de("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), BE = Object.assign(Object.assign({}, tr.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), x1 = Ai("n-list"), Ud = ot({ name: "List", props: BE, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Ir(a), h = zi("List", d, i), g = tr("List", "-list", LE, xS, a, i);
  Zr(x1, { showDividerRef: Ot(a, "showDivider"), mergedClsPrefixRef: i });
  const p = De(() => {
    const { common: { cubicBezierEaseInOut: w }, self: { fontSize: S, textColor: k, color: I, colorModal: z, colorPopover: R, borderColor: O, borderColorModal: V, borderColorPopover: W, borderRadius: N, colorHover: K, colorHoverModal: Z, colorHoverPopover: X } } = g.value;
    return { "--n-font-size": S, "--n-bezier": w, "--n-text-color": k, "--n-color": I, "--n-border-radius": N, "--n-border-color": O, "--n-border-color-modal": V, "--n-border-color-popover": W, "--n-color-modal": z, "--n-color-popover": R, "--n-color-hover": K, "--n-color-hover-modal": Z, "--n-color-hover-popover": X };
  }), o = l ? hn("list", void 0, p, a) : void 0;
  return { mergedClsPrefix: i, rtlEnabled: h, cssVars: l ? void 0 : p, themeClass: o == null ? void 0 : o.themeClass, onRender: o == null ? void 0 : o.onRender };
}, render() {
  var a;
  const { $slots: i, mergedClsPrefix: l, onRender: d } = this;
  return d == null ? void 0 : d(), L("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, i.header ? L("div", { class: `${l}-list__header` }, i.header()) : null, (a = i.default) === null || a === void 0 ? void 0 : a.call(i), i.footer ? L("div", { class: `${l}-list__footer` }, i.footer()) : null);
} }), qd = ot({ name: "ListItem", slots: Object, setup() {
  const a = hr(x1, null);
  return a || vs("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: a.showDividerRef, mergedClsPrefix: a.mergedClsPrefixRef };
}, render() {
  const { $slots: a, mergedClsPrefix: i } = this;
  return L("li", { class: `${i}-list-item` }, a.prefix ? L("div", { class: `${i}-list-item__prefix` }, a.prefix()) : null, a.default ? L("div", { class: `${i}-list-item__main` }, a) : null, a.suffix ? L("div", { class: `${i}-list-item__suffix` }, a.suffix()) : null, this.showDivider && L("div", { class: `${i}-list-item__divider` }));
} }), w1 = Ai("n-popconfirm"), C1 = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, o0 = Ed(C1), OE = ot({ name: "NPopconfirmPanel", props: C1, setup(a) {
  const { localeRef: i } = Hs("Popconfirm"), { inlineThemeDisabled: l } = Ir(), { mergedClsPrefixRef: d, mergedThemeRef: h, props: g } = hr(w1), p = De(() => {
    const { common: { cubicBezierEaseInOut: w }, self: { fontSize: S, iconSize: k, iconColor: I } } = h.value;
    return { "--n-bezier": w, "--n-font-size": S, "--n-icon-size": k, "--n-icon-color": I };
  }), o = l ? hn("popconfirm-panel", void 0, p, g) : void 0;
  return Object.assign(Object.assign({}, Hs("Popconfirm")), { mergedClsPrefix: d, cssVars: l ? void 0 : p, localizedPositiveText: De(() => a.positiveText || i.value.positiveText), localizedNegativeText: De(() => a.negativeText || i.value.negativeText), positiveButtonProps: Ot(g, "positiveButtonProps"), negativeButtonProps: Ot(g, "negativeButtonProps"), handlePositiveClick(w) {
    a.onPositiveClick(w);
  }, handleNegativeClick(w) {
    a.onNegativeClick(w);
  }, themeClass: o == null ? void 0 : o.themeClass, onRender: o == null ? void 0 : o.onRender });
}, render() {
  var a;
  const { mergedClsPrefix: i, showIcon: l, $slots: d } = this, h = Ui(d.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && L(jr, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && L(jr, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { class: [`${i}-popconfirm__panel`, this.themeClass], style: this.cssVars }, dn(d.default, (g) => l || g ? L("div", { class: `${i}-popconfirm__body` }, l ? L("div", { class: `${i}-popconfirm__icon` }, Ui(d.icon, () => [L(Ur, { clsPrefix: i }, { default: () => L(Np, null) })])) : null, g) : null), h ? L("div", { class: [`${i}-popconfirm__action`] }, h) : null);
} }), $E = de("popconfirm", [Ae("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Ae("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Ae("action", `
 display: flex;
 justify-content: flex-end;
 `, [Ge("&:not(:first-child)", "margin-top: 8px"), de("button", [Ge("&:not(:last-child)", "margin-right: 8px;")])])]), jE = Object.assign(Object.assign(Object.assign({}, tr.props), CS), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), NE = ot({ name: "Popconfirm", props: jE, slots: Object, __popover__: true, setup(a) {
  const { mergedClsPrefixRef: i } = Ir(), l = tr("Popconfirm", "-popconfirm", $E, wS, a, i), d = Me(null);
  function h(o) {
    var w;
    if (!(!((w = d.value) === null || w === void 0) && w.getMergedShow())) return;
    const { onPositiveClick: S, "onUpdate:show": k } = a;
    Promise.resolve(S ? S(o) : true).then((I) => {
      var z;
      I !== false && ((z = d.value) === null || z === void 0 || z.setShow(false), k && Gt(k, false));
    });
  }
  function g(o) {
    var w;
    if (!(!((w = d.value) === null || w === void 0) && w.getMergedShow())) return;
    const { onNegativeClick: S, "onUpdate:show": k } = a;
    Promise.resolve(S ? S(o) : true).then((I) => {
      var z;
      I !== false && ((z = d.value) === null || z === void 0 || z.setShow(false), k && Gt(k, false));
    });
  }
  return Zr(w1, { mergedThemeRef: l, mergedClsPrefixRef: i, props: a }), { setShow(o) {
    var w;
    (w = d.value) === null || w === void 0 || w.setShow(o);
  }, syncPosition() {
    var o;
    (o = d.value) === null || o === void 0 || o.syncPosition();
  }, mergedTheme: l, popoverInstRef: d, handlePositiveClick: h, handleNegativeClick: g };
}, render() {
  const { $slots: a, $props: i, mergedTheme: l } = this;
  return L(bv, _x(i, o0, { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: a.trigger, default: () => {
    const d = Ug(i, o0);
    return L(OE, Object.assign(Object.assign({}, d), { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), a);
  } });
} }), VE = { success: L(Cv, null), error: L(xv, null), warning: L(Np, null), info: L(wv, null) }, UE = ot({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(a, { slots: i }) {
  function l(h, g, p, o) {
    const { gapDegree: w, viewBoxWidth: S, strokeWidth: k } = a, I = 50, z = 0, R = I, O = 0, V = 2 * I, W = 50 + k / 2, N = `M ${W},${W} m ${z},${R}
      a ${I},${I} 0 1 1 ${O},${-V}
      a ${I},${I} 0 1 1 ${-O},${V}`, K = Math.PI * 2 * I, Z = { stroke: o === "rail" ? p : typeof a.fillColor == "object" ? "url(#gradient)" : p, strokeDasharray: `${h / 100 * (K - w)}px ${S * 8}px`, strokeDashoffset: `-${w / 2}px`, transformOrigin: g ? "center" : void 0, transform: g ? `rotate(${g}deg)` : void 0 };
    return { pathString: N, pathStyle: Z };
  }
  const d = () => {
    const h = typeof a.fillColor == "object", g = h ? a.fillColor.stops[0] : "", p = h ? a.fillColor.stops[1] : "";
    return h && L("defs", null, L("linearGradient", { id: "gradient", x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, L("stop", { offset: "0%", "stop-color": g }), L("stop", { offset: "100%", "stop-color": p })));
  };
  return () => {
    const { fillColor: h, railColor: g, strokeWidth: p, offsetDegree: o, status: w, percentage: S, showIndicator: k, indicatorTextColor: I, unit: z, gapOffsetDegree: R, clsPrefix: O } = a, { pathString: V, pathStyle: W } = l(100, 0, g, "rail"), { pathString: N, pathStyle: K } = l(S, o, h, "fill"), Z = 100 + p;
    return L("div", { class: `${O}-progress-content`, role: "none" }, L("div", { class: `${O}-progress-graph`, "aria-hidden": true }, L("div", { class: `${O}-progress-graph-circle`, style: { transform: R ? `rotate(${R}deg)` : void 0 } }, L("svg", { viewBox: `0 0 ${Z} ${Z}` }, d(), L("g", null, L("path", { class: `${O}-progress-graph-circle-rail`, d: V, "stroke-width": p, "stroke-linecap": "round", fill: "none", style: W })), L("g", null, L("path", { class: [`${O}-progress-graph-circle-fill`, S === 0 && `${O}-progress-graph-circle-fill--empty`], d: N, "stroke-width": p, "stroke-linecap": "round", fill: "none", style: K }))))), k ? L("div", null, i.default ? L("div", { class: `${O}-progress-custom-content`, role: "none" }, i.default()) : w !== "default" ? L("div", { class: `${O}-progress-icon`, "aria-hidden": true }, L(Ur, { clsPrefix: O }, { default: () => VE[w] })) : L("div", { class: `${O}-progress-text`, style: { color: I }, role: "none" }, L("span", { class: `${O}-progress-text__percentage` }, S), L("span", { class: `${O}-progress-text__unit` }, z))) : null);
  };
} }), qE = { success: L(Cv, null), error: L(xv, null), warning: L(Np, null), info: L(wv, null) }, GE = ot({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(a, { slots: i }) {
  const l = De(() => qo(a.height)), d = De(() => {
    var p, o;
    return typeof a.fillColor == "object" ? `linear-gradient(to right, ${(p = a.fillColor) === null || p === void 0 ? void 0 : p.stops[0]} , ${(o = a.fillColor) === null || o === void 0 ? void 0 : o.stops[1]})` : a.fillColor;
  }), h = De(() => a.railBorderRadius !== void 0 ? qo(a.railBorderRadius) : a.height !== void 0 ? qo(a.height, { c: 0.5 }) : ""), g = De(() => a.fillBorderRadius !== void 0 ? qo(a.fillBorderRadius) : a.railBorderRadius !== void 0 ? qo(a.railBorderRadius) : a.height !== void 0 ? qo(a.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: p, railColor: o, railStyle: w, percentage: S, unit: k, indicatorTextColor: I, status: z, showIndicator: R, processing: O, clsPrefix: V } = a;
    return L("div", { class: `${V}-progress-content`, role: "none" }, L("div", { class: `${V}-progress-graph`, "aria-hidden": true }, L("div", { class: [`${V}-progress-graph-line`, { [`${V}-progress-graph-line--indicator-${p}`]: true }] }, L("div", { class: `${V}-progress-graph-line-rail`, style: [{ backgroundColor: o, height: l.value, borderRadius: h.value }, w] }, L("div", { class: [`${V}-progress-graph-line-fill`, O && `${V}-progress-graph-line-fill--processing`], style: { maxWidth: `${a.percentage}%`, background: d.value, height: l.value, lineHeight: l.value, borderRadius: g.value } }, p === "inside" ? L("div", { class: `${V}-progress-graph-line-indicator`, style: { color: I } }, i.default ? i.default() : `${S}${k}`) : null)))), R && p === "outside" ? L("div", null, i.default ? L("div", { class: `${V}-progress-custom-content`, style: { color: I }, role: "none" }, i.default()) : z === "default" ? L("div", { role: "none", class: `${V}-progress-icon ${V}-progress-icon--as-text`, style: { color: I } }, S, k) : L("div", { class: `${V}-progress-icon`, "aria-hidden": true }, L(Ur, { clsPrefix: V }, { default: () => qE[z] }))) : null);
  };
} });
function s0(a, i, l = 100) {
  return `m ${l / 2} ${l / 2 - a} a ${a} ${a} 0 1 1 0 ${2 * a} a ${a} ${a} 0 1 1 0 -${2 * a}`;
}
const WE = ot({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(a, { slots: i }) {
  const l = De(() => a.percentage.map((g, p) => `${Math.PI * g / 100 * (a.viewBoxWidth / 2 - a.strokeWidth / 2 * (1 + 2 * p) - a.circleGap * p) * 2}, ${a.viewBoxWidth * 8}`)), d = (h, g) => {
    const p = a.fillColor[g], o = typeof p == "object" ? p.stops[0] : "", w = typeof p == "object" ? p.stops[1] : "";
    return typeof a.fillColor[g] == "object" && L("linearGradient", { id: `gradient-${g}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, L("stop", { offset: "0%", "stop-color": o }), L("stop", { offset: "100%", "stop-color": w }));
  };
  return () => {
    const { viewBoxWidth: h, strokeWidth: g, circleGap: p, showIndicator: o, fillColor: w, railColor: S, railStyle: k, percentage: I, clsPrefix: z } = a;
    return L("div", { class: `${z}-progress-content`, role: "none" }, L("div", { class: `${z}-progress-graph`, "aria-hidden": true }, L("div", { class: `${z}-progress-graph-circle` }, L("svg", { viewBox: `0 0 ${h} ${h}` }, L("defs", null, I.map((R, O) => d(R, O))), I.map((R, O) => L("g", { key: O }, L("path", { class: `${z}-progress-graph-circle-rail`, d: s0(h / 2 - g / 2 * (1 + 2 * O) - p * O, g, h), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: S[O] }, k[O]] }), L("path", { class: [`${z}-progress-graph-circle-fill`, R === 0 && `${z}-progress-graph-circle-fill--empty`], d: s0(h / 2 - g / 2 * (1 + 2 * O) - p * O, g, h), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[O], strokeDashoffset: 0, stroke: typeof w[O] == "object" ? `url(#gradient-${O})` : w[O] } })))))), o && i.default ? L("div", null, L("div", { class: `${z}-progress-text` }, i.default())) : null);
  };
} }), ZE = Ge([de("progress", { display: "inline-block" }, [de("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ue("line", `
 width: 100%;
 display: block;
 `, [de("progress-content", `
 display: flex;
 align-items: center;
 `, [de("progress-graph", { flex: 1 })]), de("progress-custom-content", { marginLeft: "14px" }), de("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ue("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ue("circle, dashboard", { width: "120px" }, [de("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), de("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), de("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ue("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [de("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), de("progress-content", { position: "relative" }), de("progress-graph", { position: "relative" }, [de("progress-graph-circle", [Ge("svg", { verticalAlign: "bottom" }), de("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ue("empty", { opacity: 0 })]), de("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), de("progress-graph-line", [Ue("indicator-inside", [de("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [de("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), de("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ue("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [de("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), de("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), de("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [de("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ue("processing", [Ge("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), Ge("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), HE = Object.assign(Object.assign({}, tr.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), XE = ot({ name: "Progress", props: HE, setup(a) {
  const i = De(() => a.indicatorPlacement || a.indicatorPosition), l = De(() => {
    if (a.gapDegree || a.gapDegree === 0) return a.gapDegree;
    if (a.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: d, inlineThemeDisabled: h } = Ir(a), g = tr("Progress", "-progress", ZE, SS, a, d), p = De(() => {
    const { status: w } = a, { common: { cubicBezierEaseInOut: S }, self: { fontSize: k, fontSizeCircle: I, railColor: z, railHeight: R, iconSizeCircle: O, iconSizeLine: V, textColorCircle: W, textColorLineInner: N, textColorLineOuter: K, lineBgProcessing: Z, fontWeightCircle: X, [qt("iconColor", w)]: te, [qt("fillColor", w)]: q } } = g.value;
    return { "--n-bezier": S, "--n-fill-color": q, "--n-font-size": k, "--n-font-size-circle": I, "--n-font-weight-circle": X, "--n-icon-color": te, "--n-icon-size-circle": O, "--n-icon-size-line": V, "--n-line-bg-processing": Z, "--n-rail-color": z, "--n-rail-height": R, "--n-text-color-circle": W, "--n-text-color-line-inner": N, "--n-text-color-line-outer": K };
  }), o = h ? hn("progress", De(() => a.status[0]), p, a) : void 0;
  return { mergedClsPrefix: d, mergedIndicatorPlacement: i, gapDeg: l, cssVars: h ? void 0 : p, themeClass: o == null ? void 0 : o.themeClass, onRender: o == null ? void 0 : o.onRender };
}, render() {
  const { type: a, cssVars: i, indicatorTextColor: l, showIndicator: d, status: h, railColor: g, railStyle: p, color: o, percentage: w, viewBoxWidth: S, strokeWidth: k, mergedIndicatorPlacement: I, unit: z, borderRadius: R, fillBorderRadius: O, height: V, processing: W, circleGap: N, mergedClsPrefix: K, gapDeg: Z, gapOffsetDegree: X, themeClass: te, $slots: q, onRender: he } = this;
  return he == null ? void 0 : he(), L("div", { class: [te, `${K}-progress`, `${K}-progress--${a}`, `${K}-progress--${h}`], style: i, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": w, role: a === "circle" || a === "line" || a === "dashboard" ? "progressbar" : "none" }, a === "circle" || a === "dashboard" ? L(UE, { clsPrefix: K, status: h, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: o, railStyle: p, offsetDegree: this.offsetDegree, percentage: w, viewBoxWidth: S, strokeWidth: k, gapDegree: Z === void 0 ? a === "dashboard" ? 75 : 0 : Z, gapOffsetDegree: X, unit: z }, q) : a === "line" ? L(GE, { clsPrefix: K, status: h, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: o, railStyle: p, percentage: w, processing: W, indicatorPlacement: I, unit: z, fillBorderRadius: O, railBorderRadius: R, height: V }, q) : a === "multiple-circle" ? L(WE, { clsPrefix: K, strokeWidth: k, railColor: g, fillColor: o, railStyle: p, viewBoxWidth: S, percentage: w, showIndicator: d, circleGap: N }, q) : null);
} }), YE = Ge([Ge("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), de("spin-container", `
 position: relative;
 `, [de("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Mp()])]), de("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), de("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ue("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), de("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), de("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ue("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), KE = { small: 20, medium: 18, large: 16 }, JE = Object.assign(Object.assign({}, tr.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), QE = ot({ name: "Spin", props: JE, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = tr("Spin", "-spin", YE, kS, a, i), h = De(() => {
    const { size: w } = a, { common: { cubicBezierEaseInOut: S }, self: k } = d.value, { opacitySpinning: I, color: z, textColor: R } = k, O = typeof w == "number" ? Ni(w) : k[qt("size", w)];
    return { "--n-bezier": S, "--n-opacity-spinning": I, "--n-size": O, "--n-color": z, "--n-text-color": R };
  }), g = l ? hn("spin", De(() => {
    const { size: w } = a;
    return typeof w == "number" ? String(w) : w[0];
  }), h, a) : void 0, p = Tp(a, ["spinning", "show"]), o = Me(false);
  return zo((w) => {
    let S;
    if (p.value) {
      const { delay: k } = a;
      if (k) {
        S = window.setTimeout(() => {
          o.value = true;
        }, k), w(() => {
          clearTimeout(S);
        });
        return;
      }
    }
    o.value = p.value;
  }), { mergedClsPrefix: i, active: o, mergedStrokeWidth: De(() => {
    const { strokeWidth: w } = a;
    if (w !== void 0) return w;
    const { size: S } = a;
    return KE[typeof S == "number" ? "medium" : S];
  }), cssVars: l ? void 0 : h, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var a, i;
  const { $slots: l, mergedClsPrefix: d, description: h } = this, g = l.icon && this.rotate, p = (h || l.description) && L("div", { class: `${d}-spin-description` }, h || ((a = l.description) === null || a === void 0 ? void 0 : a.call(l))), o = l.icon ? L("div", { class: [`${d}-spin-body`, this.themeClass] }, L("div", { class: [`${d}-spin`, g && `${d}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), p) : L("div", { class: [`${d}-spin-body`, this.themeClass] }, L(Op, { clsPrefix: d, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${d}-spin` }), p);
  return (i = this.onRender) === null || i === void 0 || i.call(this), l.default ? L("div", { class: [`${d}-spin-container`, this.themeClass], style: this.cssVars }, L("div", { class: [`${d}-spin-content`, this.active && `${d}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), L(Ro, { name: "fade-in-transition" }, { default: () => this.active ? o : null })) : o;
} }), eR = de("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ue("horizontal", `
 flex-direction: row;
 `), Ue("vertical", `
 flex-direction: column;
 `), de("split-pane-1", `
 overflow: hidden;
 `), de("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Ae("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), Ge("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), tR = Object.assign(Object.assign({}, tr.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), a0 = ot({ name: "Split", props: tR, slots: Object, setup(a) {
  var i;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Ir(a), h = tr("Split", "-split", eR, PS, a, l), g = De(() => {
    const { common: { cubicBezierEaseInOut: Z }, self: { resizableTriggerColor: X, resizableTriggerColorHover: te } } = h.value;
    return { "--n-bezier": Z, "--n-resize-trigger-color": X, "--n-resize-trigger-color-hover": te };
  }), p = Me(null), o = Me(false), w = Ot(a, "size"), S = Me(a.defaultSize);
  !((i = a.watchProps) === null || i === void 0) && i.includes("defaultSize") && zo(() => S.value = a.defaultSize);
  const k = (Z) => {
    const X = a["onUpdate:size"];
    a.onUpdateSize && Gt(a.onUpdateSize, Z), X && Gt(X, Z), S.value = Z;
  }, I = wi(w, S), z = De(() => {
    const Z = I.value;
    if (typeof Z == "string") return { flex: `0 0 ${Z}` };
    if (typeof Z == "number") {
      const X = Z * 100;
      return { flex: `0 0 calc(${X}% - ${a.resizeTriggerSize * X / 100}px)` };
    }
  }), R = De(() => a.direction === "horizontal" ? { width: `${a.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${a.resizeTriggerSize}px` }), O = De(() => {
    const Z = a.direction === "horizontal";
    return { width: Z ? `${a.resizeTriggerSize}px` : "", height: Z ? "" : `${a.resizeTriggerSize}px`, cursor: a.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let V = 0;
  const W = (Z) => {
    Z.preventDefault(), o.value = true, a.onDragStart && a.onDragStart(Z);
    const X = "mousemove", te = "mouseup", q = (Q) => {
      N(Q), a.onDragMove && a.onDragMove(Q);
    }, he = () => {
      Xi(X, document, q), Xi(te, document, he), o.value = false, a.onDragEnd && a.onDragEnd(Z), document.body.style.cursor = "";
    };
    document.body.style.cursor = O.value.cursor, Ei(X, document, q), Ei(te, document, he);
    const se = p.value;
    if (se) {
      const Q = se.getBoundingClientRect();
      a.direction === "horizontal" ? V = Z.clientX - Q.left : V = Q.top - Z.clientY;
    }
    N(Z);
  };
  function N(Z) {
    var X, te;
    const q = (te = (X = p.value) === null || X === void 0 ? void 0 : X.parentElement) === null || te === void 0 ? void 0 : te.getBoundingClientRect();
    if (!q) return;
    const { direction: he } = a, se = q.width - a.resizeTriggerSize, Q = q.height - a.resizeTriggerSize, oe = he === "horizontal" ? se : Q, ve = he === "horizontal" ? Z.clientX - q.left - V : Z.clientY - q.top + V, { min: Be, max: Ne } = a, Pe = typeof Be == "string" ? ei(Be) : Be * oe, tt = typeof Ne == "string" ? ei(Ne) : Ne * oe;
    let at = ve;
    at = Math.max(at, Pe), at = Math.min(at, tt, oe), typeof I.value == "string" ? k(`${at}px`) : k(at / oe);
  }
  const K = d ? hn("split", void 0, g, a) : void 0;
  return { themeClass: K == null ? void 0 : K.themeClass, onRender: K == null ? void 0 : K.onRender, cssVars: d ? void 0 : g, resizeTriggerElRef: p, isDragging: o, mergedClsPrefix: l, resizeTriggerWrapperStyle: O, resizeTriggerStyle: R, handleMouseDown: W, firstPaneStyle: z };
}, render() {
  var a, i, l, d, h;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, L("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (i = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(i)), !this.disabled && L("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, Ui(this.$slots["resize-trigger"], () => [L("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), L("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (h = (d = this.$slots)[2]) === null || h === void 0 ? void 0 : h.call(d)));
} }), rR = de("statistic", [Ae("label", `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), de("statistic-value", `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [Ae("prefix", `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [de("icon", { verticalAlign: "-0.125em" })]), Ae("content", `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), Ae("suffix", `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [de("icon", { verticalAlign: "-0.125em" })])])]), nR = Object.assign(Object.assign({}, tr.props), { tabularNums: Boolean, label: String, value: [String, Number] }), Qn = ot({ name: "Statistic", props: nR, slots: Object, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Ir(a), h = tr("Statistic", "-statistic", rR, TS, a, i), g = zi("Statistic", d, i), p = De(() => {
    const { self: { labelFontWeight: w, valueFontSize: S, valueFontWeight: k, valuePrefixTextColor: I, labelTextColor: z, valueSuffixTextColor: R, valueTextColor: O, labelFontSize: V }, common: { cubicBezierEaseInOut: W } } = h.value;
    return { "--n-bezier": W, "--n-label-font-size": V, "--n-label-font-weight": w, "--n-label-text-color": z, "--n-value-font-weight": k, "--n-value-font-size": S, "--n-value-prefix-text-color": I, "--n-value-suffix-text-color": R, "--n-value-text-color": O };
  }), o = l ? hn("statistic", void 0, p, a) : void 0;
  return { rtlEnabled: g, mergedClsPrefix: i, cssVars: l ? void 0 : p, themeClass: o == null ? void 0 : o.themeClass, onRender: o == null ? void 0 : o.onRender };
}, render() {
  var a;
  const { mergedClsPrefix: i, $slots: { default: l, label: d, prefix: h, suffix: g } } = this;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("div", { class: [`${i}-statistic`, this.themeClass, this.rtlEnabled && `${i}-statistic--rtl`], style: this.cssVars }, dn(d, (p) => L("div", { class: `${i}-statistic__label` }, this.label || p)), L("div", { class: `${i}-statistic-value`, style: { fontVariantNumeric: this.tabularNums ? "tabular-nums" : "" } }, dn(h, (p) => p && L("span", { class: `${i}-statistic-value__prefix` }, p)), this.value !== void 0 ? L("span", { class: `${i}-statistic-value__content` }, this.value) : dn(l, (p) => p && L("span", { class: `${i}-statistic-value__content` }, p)), dn(g, (p) => p && L("span", { class: `${i}-statistic-value__suffix` }, p))));
} }), iR = de("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Ae("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Ae("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Ae("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), de("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Rd({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Ae("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Ae("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ae("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ge("&:focus", [Ae("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ue("round", [Ae("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Ae("button", "border-radius: calc(var(--n-button-height) / 2);")])]), pn("disabled", [pn("icon", [Ue("rubber-band", [Ue("pressed", [Ae("rail", [Ae("button", "max-width: var(--n-button-width-pressed);")])]), Ae("rail", [Ge("&:active", [Ae("button", "max-width: var(--n-button-width-pressed);")])]), Ue("active", [Ue("pressed", [Ae("rail", [Ae("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Ae("rail", [Ge("&:active", [Ae("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ue("active", [Ae("rail", [Ae("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Ae("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Ae("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Rd()]), Ae("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ue("active", [Ae("rail", "background-color: var(--n-rail-color-active);")]), Ue("loading", [Ae("rail", `
 cursor: wait;
 `)]), Ue("disabled", [Ae("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), oR = Object.assign(Object.assign({}, tr.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let md;
const S1 = ot({ name: "Switch", props: oR, slots: Object, setup(a) {
  md === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? md = CSS.supports("width", "max(1px)") : md = false : md = true);
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = tr("Switch", "-switch", iR, MS, a, i), h = gs(a), { mergedSizeRef: g, mergedDisabledRef: p } = h, o = Me(a.defaultValue), w = Ot(a, "value"), S = wi(w, o), k = De(() => S.value === a.checkedValue), I = Me(false), z = Me(false), R = De(() => {
    const { railStyle: se } = a;
    if (se) return se({ focused: z.value, checked: k.value });
  });
  function O(se) {
    const { "onUpdate:value": Q, onChange: oe, onUpdateValue: ve } = a, { nTriggerFormInput: Be, nTriggerFormChange: Ne } = h;
    Q && Gt(Q, se), ve && Gt(ve, se), oe && Gt(oe, se), o.value = se, Be(), Ne();
  }
  function V() {
    const { nTriggerFormFocus: se } = h;
    se();
  }
  function W() {
    const { nTriggerFormBlur: se } = h;
    se();
  }
  function N() {
    a.loading || p.value || (S.value !== a.checkedValue ? O(a.checkedValue) : O(a.uncheckedValue));
  }
  function K() {
    z.value = true, V();
  }
  function Z() {
    z.value = false, W(), I.value = false;
  }
  function X(se) {
    a.loading || p.value || se.key === " " && (S.value !== a.checkedValue ? O(a.checkedValue) : O(a.uncheckedValue), I.value = false);
  }
  function te(se) {
    a.loading || p.value || se.key === " " && (se.preventDefault(), I.value = true);
  }
  const q = De(() => {
    const { value: se } = g, { self: { opacityDisabled: Q, railColor: oe, railColorActive: ve, buttonBoxShadow: Be, buttonColor: Ne, boxShadowFocus: Pe, loadingColor: tt, textColor: at, iconColor: xt, [qt("buttonHeight", se)]: ht, [qt("buttonWidth", se)]: Ye, [qt("buttonWidthPressed", se)]: Ke, [qt("railHeight", se)]: Lt, [qt("railWidth", se)]: ct, [qt("railBorderRadius", se)]: bt, [qt("buttonBorderRadius", se)]: Nt }, common: { cubicBezierEaseInOut: Yt } } = d.value;
    let vt, jt, er;
    return md ? (vt = `calc((${Lt} - ${ht}) / 2)`, jt = `max(${Lt}, ${ht})`, er = `max(${ct}, calc(${ct} + ${ht} - ${Lt}))`) : (vt = Ni((ei(Lt) - ei(ht)) / 2), jt = Ni(Math.max(ei(Lt), ei(ht))), er = ei(Lt) > ei(ht) ? ct : Ni(ei(ct) + ei(ht) - ei(Lt))), { "--n-bezier": Yt, "--n-button-border-radius": Nt, "--n-button-box-shadow": Be, "--n-button-color": Ne, "--n-button-width": Ye, "--n-button-width-pressed": Ke, "--n-button-height": ht, "--n-height": jt, "--n-offset": vt, "--n-opacity-disabled": Q, "--n-rail-border-radius": bt, "--n-rail-color": oe, "--n-rail-color-active": ve, "--n-rail-height": Lt, "--n-rail-width": ct, "--n-width": er, "--n-box-shadow-focus": Pe, "--n-loading-color": tt, "--n-text-color": at, "--n-icon-color": xt };
  }), he = l ? hn("switch", De(() => g.value[0]), q, a) : void 0;
  return { handleClick: N, handleBlur: Z, handleFocus: K, handleKeyup: X, handleKeydown: te, mergedRailStyle: R, pressed: I, mergedClsPrefix: i, mergedValue: S, checked: k, mergedDisabled: p, cssVars: l ? void 0 : q, themeClass: he == null ? void 0 : he.themeClass, onRender: he == null ? void 0 : he.onRender };
}, render() {
  const { mergedClsPrefix: a, mergedDisabled: i, checked: l, mergedRailStyle: d, onRender: h, $slots: g } = this;
  h == null ? void 0 : h();
  const { checked: p, unchecked: o, icon: w, "checked-icon": S, "unchecked-icon": k } = g, I = !(dm(w) && dm(S) && dm(k));
  return L("div", { role: "switch", "aria-checked": l, class: [`${a}-switch`, this.themeClass, I && `${a}-switch--icon`, l && `${a}-switch--active`, i && `${a}-switch--disabled`, this.round && `${a}-switch--round`, this.loading && `${a}-switch--loading`, this.pressed && `${a}-switch--pressed`, this.rubberBand && `${a}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, L("div", { class: `${a}-switch__rail`, "aria-hidden": "true", style: d }, dn(p, (z) => dn(o, (R) => z || R ? L("div", { "aria-hidden": true, class: `${a}-switch__children-placeholder` }, L("div", { class: `${a}-switch__rail-placeholder` }, L("div", { class: `${a}-switch__button-placeholder` }), z), L("div", { class: `${a}-switch__rail-placeholder` }, L("div", { class: `${a}-switch__button-placeholder` }), R)) : null)), L("div", { class: `${a}-switch__button` }, dn(w, (z) => dn(S, (R) => dn(k, (O) => L(Lp, null, { default: () => this.loading ? L(Op, { key: "loading", clsPrefix: a, strokeWidth: 20 }) : this.checked && (R || z) ? L("div", { class: `${a}-switch__button-icon`, key: R ? "checked-icon" : "icon" }, R || z) : !this.checked && (O || z) ? L("div", { class: `${a}-switch__button-icon`, key: O ? "unchecked-icon" : "icon" }, O || z) : null })))), dn(p, (z) => z && L("div", { key: "checked", class: `${a}-switch__checked` }, z)), dn(o, (z) => z && L("div", { key: "unchecked", class: `${a}-switch__unchecked` }, z)))));
} }), Rv = Ai("n-tabs"), k1 = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, l0 = ot({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: k1, slots: Object, setup(a) {
  const i = hr(Rv, null);
  return i || vs("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: i.paneStyleRef, class: i.paneClassRef, mergedClsPrefix: i.mergedClsPrefixRef };
}, render() {
  return L("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), sR = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, _x(k1, ["displayDirective"])), lv = ot({ __TAB__: true, inheritAttrs: false, name: "Tab", props: sR, setup(a) {
  const { mergedClsPrefixRef: i, valueRef: l, typeRef: d, closableRef: h, tabStyleRef: g, addTabStyleRef: p, tabClassRef: o, addTabClassRef: w, tabChangeIdRef: S, onBeforeLeaveRef: k, triggerRef: I, handleAdd: z, activateTab: R, handleClose: O } = hr(Rv);
  return { trigger: I, mergedClosable: De(() => {
    if (a.internalAddable) return false;
    const { closable: V } = a;
    return V === void 0 ? h.value : V;
  }), style: g, addStyle: p, tabClass: o, addTabClass: w, clsPrefix: i, value: l, type: d, handleClose(V) {
    V.stopPropagation(), !a.disabled && O(a.name);
  }, activateTab() {
    if (a.disabled) return;
    if (a.internalAddable) {
      z();
      return;
    }
    const { name: V } = a, W = ++S.id;
    if (V !== l.value) {
      const { value: N } = k;
      N ? Promise.resolve(N(a.name, l.value)).then((K) => {
        K && S.id === W && R(V);
      }) : R(V);
    }
  } };
}, render() {
  const { internalAddable: a, clsPrefix: i, name: l, disabled: d, label: h, tab: g, value: p, mergedClosable: o, trigger: w, $slots: { default: S } } = this, k = h ?? g;
  return L("div", { class: `${i}-tabs-tab-wrapper` }, this.internalLeftPadded ? L("div", { class: `${i}-tabs-tab-pad` }) : null, L("div", Object.assign({ key: l, "data-name": l, "data-disabled": d ? true : void 0 }, qs({ class: [`${i}-tabs-tab`, p === l && `${i}-tabs-tab--active`, d && `${i}-tabs-tab--disabled`, o && `${i}-tabs-tab--closable`, a && `${i}-tabs-tab--addable`, a ? this.addTabClass : this.tabClass], onClick: w === "click" ? this.activateTab : void 0, onMouseenter: w === "hover" ? this.activateTab : void 0, style: a ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), L("span", { class: `${i}-tabs-tab__label` }, a ? L(qr, null, L("div", { class: `${i}-tabs-tab__height-placeholder` }, "\xA0"), L(Ur, { clsPrefix: i }, { default: () => L(Wp, null) })) : S ? S() : typeof k == "object" ? k : _l(k ?? l)), o && this.type === "card" ? L($p, { clsPrefix: i, class: `${i}-tabs-tab__close`, onClick: this.handleClose, disabled: d }) : null));
} }), aR = de("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ue("segment-type", [de("tabs-rail", [Ge("&.transition-disabled", [de("tabs-capsule", `
 transition: none;
 `)])])]), Ue("top", [de("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ue("left", [de("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ue("left, right", `
 flex-direction: row;
 `, [de("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), de("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ue("right", `
 flex-direction: row-reverse;
 `, [de("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), de("tabs-bar", `
 left: 0;
 `)]), Ue("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [de("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), de("tabs-bar", `
 top: 0;
 `)]), de("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [de("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), de("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [de("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ue("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ue("flex", [de("tabs-nav", `
 width: 100%;
 position: relative;
 `, [de("tabs-wrapper", `
 width: 100%;
 `, [de("tabs-tab", `
 margin-right: 0;
 `)])])]), de("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Ae("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Ae("prefix", "padding-right: 16px;"), Ae("suffix", "padding-left: 16px;")]), Ue("top, bottom", [de("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), Ge("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])]), Ue("left, right", [de("tabs-nav-scroll-content", `
 flex-direction: column;
 `), de("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ge("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])]), de("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [de("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), Ge("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), de("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), de("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), de("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), de("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ue("disabled", { cursor: "not-allowed" }), Ae("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ae("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), de("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ge("&.transition-disabled", `
 transition: none;
 `), Ue("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), de("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), de("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [Ge("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), Ge("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), Ge("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), de("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ue("line-type, bar-type", [de("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [Ge("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ue("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ue("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), de("tabs-nav", [Ue("line-type", [Ue("top", [Ae("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), de("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), de("tabs-bar", `
 bottom: -1px;
 `)]), Ue("left", [Ae("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), de("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), de("tabs-bar", `
 right: -1px;
 `)]), Ue("right", [Ae("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), de("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), de("tabs-bar", `
 left: -1px;
 `)]), Ue("bottom", [Ae("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), de("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), de("tabs-bar", `
 top: -1px;
 `)]), Ae("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), de("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), de("tabs-bar", `
 border-radius: 0;
 `)]), Ue("card-type", [Ae("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), de("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), de("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), de("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ue("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Ae("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), pn("disabled", [Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ue("closable", "padding-right: 8px;"), Ue("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ue("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ue("left, right", `
 flex-direction: column; 
 `, [Ae("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), de("tabs-wrapper", `
 flex-direction: column;
 `), de("tabs-tab-wrapper", `
 flex-direction: column;
 `, [de("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ue("top", [Ue("card-type", [de("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), de("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-bottom: 1px solid #0000;
 `)]), de("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), de("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ue("left", [Ue("card-type", [de("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), de("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-right: 1px solid #0000;
 `)]), de("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), de("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ue("right", [Ue("card-type", [de("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), de("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-left: 1px solid #0000;
 `)]), de("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), de("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ue("bottom", [Ue("card-type", [de("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), de("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-top: 1px solid #0000;
 `)]), de("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), de("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), lR = Object.assign(Object.assign({}, tr.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), cR = ot({ name: "Tabs", props: lR, slots: Object, setup(a, { slots: i }) {
  var l, d, h, g;
  const { mergedClsPrefixRef: p, inlineThemeDisabled: o } = Ir(a), w = tr("Tabs", "-tabs", aR, IS, a, p), S = Me(null), k = Me(null), I = Me(null), z = Me(null), R = Me(null), O = Me(null), V = Me(true), W = Me(true), N = Tp(a, ["labelSize", "size"]), K = Tp(a, ["activeName", "value"]), Z = Me((d = (l = K.value) !== null && l !== void 0 ? l : a.defaultValue) !== null && d !== void 0 ? d : i.default ? (g = (h = kl(i.default())[0]) === null || h === void 0 ? void 0 : h.props) === null || g === void 0 ? void 0 : g.name : null), X = wi(K, Z), te = { id: 0 }, q = De(() => {
    if (!(!a.justifyContent || a.type === "card")) return { display: "flex", justifyContent: a.justifyContent };
  });
  Kt(X, () => {
    te.id = 0, ve(), Be();
  });
  function he() {
    var et;
    const { value: it } = X;
    return it === null ? null : (et = S.value) === null || et === void 0 ? void 0 : et.querySelector(`[data-name="${it}"]`);
  }
  function se(et) {
    if (a.type === "card") return;
    const { value: it } = k;
    if (!it) return;
    const Pt = it.style.opacity === "0";
    if (et) {
      const Et = `${p.value}-tabs-bar--disabled`, { barWidth: st, placement: St } = a;
      if (et.dataset.disabled === "true" ? it.classList.add(Et) : it.classList.remove(Et), ["top", "bottom"].includes(St)) {
        if (oe(["top", "maxHeight", "height"]), typeof st == "number" && et.offsetWidth >= st) {
          const ar = Math.floor((et.offsetWidth - st) / 2) + et.offsetLeft;
          it.style.left = `${ar}px`, it.style.maxWidth = `${st}px`;
        } else it.style.left = `${et.offsetLeft}px`, it.style.maxWidth = `${et.offsetWidth}px`;
        it.style.width = "8192px", Pt && (it.style.transition = "none"), it.offsetWidth, Pt && (it.style.transition = "", it.style.opacity = "1");
      } else {
        if (oe(["left", "maxWidth", "width"]), typeof st == "number" && et.offsetHeight >= st) {
          const ar = Math.floor((et.offsetHeight - st) / 2) + et.offsetTop;
          it.style.top = `${ar}px`, it.style.maxHeight = `${st}px`;
        } else it.style.top = `${et.offsetTop}px`, it.style.maxHeight = `${et.offsetHeight}px`;
        it.style.height = "8192px", Pt && (it.style.transition = "none"), it.offsetHeight, Pt && (it.style.transition = "", it.style.opacity = "1");
      }
    }
  }
  function Q() {
    if (a.type === "card") return;
    const { value: et } = k;
    et && (et.style.opacity = "0");
  }
  function oe(et) {
    const { value: it } = k;
    if (it) for (const Pt of et) it.style[Pt] = "";
  }
  function ve() {
    if (a.type === "card") return;
    const et = he();
    et ? se(et) : Q();
  }
  function Be() {
    var et;
    const it = (et = R.value) === null || et === void 0 ? void 0 : et.$el;
    if (!it) return;
    const Pt = he();
    if (!Pt) return;
    const { scrollLeft: Et, offsetWidth: st } = it, { offsetLeft: St, offsetWidth: ar } = Pt;
    Et > St ? it.scrollTo({ top: 0, left: St, behavior: "smooth" }) : St + ar > Et + st && it.scrollTo({ top: 0, left: St + ar - st, behavior: "smooth" });
  }
  const Ne = Me(null);
  let Pe = 0, tt = null;
  function at(et) {
    const it = Ne.value;
    if (it) {
      Pe = et.getBoundingClientRect().height;
      const Pt = `${Pe}px`, Et = () => {
        it.style.height = Pt, it.style.maxHeight = Pt;
      };
      tt ? (Et(), tt(), tt = null) : tt = Et;
    }
  }
  function xt(et) {
    const it = Ne.value;
    if (it) {
      const Pt = et.getBoundingClientRect().height, Et = () => {
        document.body.offsetHeight, it.style.maxHeight = `${Pt}px`, it.style.height = `${Math.max(Pe, Pt)}px`;
      };
      tt ? (tt(), tt = null, Et()) : tt = Et;
    }
  }
  function ht() {
    const et = Ne.value;
    if (et) {
      et.style.maxHeight = "", et.style.height = "";
      const { paneWrapperStyle: it } = a;
      if (typeof it == "string") et.style.cssText = it;
      else if (it) {
        const { maxHeight: Pt, height: Et } = it;
        Pt !== void 0 && (et.style.maxHeight = Pt), Et !== void 0 && (et.style.height = Et);
      }
    }
  }
  const Ye = { value: [] }, Ke = Me("next");
  function Lt(et) {
    const it = X.value;
    let Pt = "next";
    for (const Et of Ye.value) {
      if (Et === it) break;
      if (Et === et) {
        Pt = "prev";
        break;
      }
    }
    Ke.value = Pt, ct(et);
  }
  function ct(et) {
    const { onActiveNameChange: it, onUpdateValue: Pt, "onUpdate:value": Et } = a;
    it && Gt(it, et), Pt && Gt(Pt, et), Et && Gt(Et, et), Z.value = et;
  }
  function bt(et) {
    const { onClose: it } = a;
    it && Gt(it, et);
  }
  function Nt() {
    const { value: et } = k;
    if (!et) return;
    const it = "transition-disabled";
    et.classList.add(it), ve(), et.classList.remove(it);
  }
  const Yt = Me(null);
  function vt({ transitionDisabled: et }) {
    const it = S.value;
    if (!it) return;
    et && it.classList.add("transition-disabled");
    const Pt = he();
    Pt && Yt.value && (Yt.value.style.width = `${Pt.offsetWidth}px`, Yt.value.style.height = `${Pt.offsetHeight}px`, Yt.value.style.transform = `translateX(${Pt.offsetLeft - ei(getComputedStyle(it).paddingLeft)}px)`, et && Yt.value.offsetWidth), et && it.classList.remove("transition-disabled");
  }
  Kt([X], () => {
    a.type === "segment" && Vi(() => {
      vt({ transitionDisabled: false });
    });
  }), Tn(() => {
    a.type === "segment" && vt({ transitionDisabled: true });
  });
  let jt = 0;
  function er(et) {
    var it;
    if (et.contentRect.width === 0 && et.contentRect.height === 0 || jt === et.contentRect.width) return;
    jt = et.contentRect.width;
    const { type: Pt } = a;
    if ((Pt === "line" || Pt === "bar") && Nt(), Pt !== "segment") {
      const { placement: Et } = a;
      Ct((Et === "top" || Et === "bottom" ? (it = R.value) === null || it === void 0 ? void 0 : it.$el : O.value) || null);
    }
  }
  const yr = gp(er, 64);
  Kt([() => a.justifyContent, () => a.size], () => {
    Vi(() => {
      const { type: et } = a;
      (et === "line" || et === "bar") && Nt();
    });
  });
  const Tr = Me(false);
  function zr(et) {
    var it;
    const { target: Pt, contentRect: { width: Et, height: st } } = et, St = Pt.parentElement.parentElement.offsetWidth, ar = Pt.parentElement.parentElement.offsetHeight, { placement: on } = a;
    if (!Tr.value) on === "top" || on === "bottom" ? St < Et && (Tr.value = true) : ar < st && (Tr.value = true);
    else {
      const { value: Sn } = z;
      if (!Sn) return;
      on === "top" || on === "bottom" ? St - Et > Sn.$el.offsetWidth && (Tr.value = false) : ar - st > Sn.$el.offsetHeight && (Tr.value = false);
    }
    Ct(((it = R.value) === null || it === void 0 ? void 0 : it.$el) || null);
  }
  const rr = gp(zr, 64);
  function yt() {
    const { onAdd: et } = a;
    et && et(), Vi(() => {
      const it = he(), { value: Pt } = R;
      !it || !Pt || Pt.scrollTo({ left: it.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function Ct(et) {
    if (!et) return;
    const { placement: it } = a;
    if (it === "top" || it === "bottom") {
      const { scrollLeft: Pt, scrollWidth: Et, offsetWidth: st } = et;
      V.value = Pt <= 0, W.value = Pt + st >= Et;
    } else {
      const { scrollTop: Pt, scrollHeight: Et, offsetHeight: st } = et;
      V.value = Pt <= 0, W.value = Pt + st >= Et;
    }
  }
  const Dt = gp((et) => {
    Ct(et.target);
  }, 64);
  Zr(Rv, { triggerRef: Ot(a, "trigger"), tabStyleRef: Ot(a, "tabStyle"), tabClassRef: Ot(a, "tabClass"), addTabStyleRef: Ot(a, "addTabStyle"), addTabClassRef: Ot(a, "addTabClass"), paneClassRef: Ot(a, "paneClass"), paneStyleRef: Ot(a, "paneStyle"), mergedClsPrefixRef: p, typeRef: Ot(a, "type"), closableRef: Ot(a, "closable"), valueRef: X, tabChangeIdRef: te, onBeforeLeaveRef: Ot(a, "onBeforeLeave"), activateTab: Lt, handleClose: bt, handleAdd: yt }), ix(() => {
    ve(), Be();
  }), zo(() => {
    const { value: et } = I;
    if (!et) return;
    const { value: it } = p, Pt = `${it}-tabs-nav-scroll-wrapper--shadow-start`, Et = `${it}-tabs-nav-scroll-wrapper--shadow-end`;
    V.value ? et.classList.remove(Pt) : et.classList.add(Pt), W.value ? et.classList.remove(Et) : et.classList.add(Et);
  });
  const ir = { syncBarPosition: () => {
    ve();
  } }, ut = () => {
    vt({ transitionDisabled: true });
  }, We = De(() => {
    const { value: et } = N, { type: it } = a, Pt = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[it], Et = `${et}${Pt}`, { self: { barColor: st, closeIconColor: St, closeIconColorHover: ar, closeIconColorPressed: on, tabColor: Sn, tabBorderColor: Le, paneTextColor: re, tabFontWeight: ne, tabBorderRadius: ae, tabFontWeightActive: be, colorSegment: Ie, fontWeightStrong: Fe, tabColorSegment: fe, closeSize: _e, closeIconSize: Ve, closeColorHover: nt, closeColorPressed: Xe, closeBorderRadius: wt, [qt("panePadding", et)]: Te, [qt("tabPadding", Et)]: Ut, [qt("tabPaddingVertical", Et)]: or, [qt("tabGap", Et)]: Wt, [qt("tabGap", `${Et}Vertical`)]: dr, [qt("tabTextColor", it)]: Or, [qt("tabTextColorActive", it)]: Qr, [qt("tabTextColorHover", it)]: en, [qt("tabTextColorDisabled", it)]: sn, [qt("tabFontSize", et)]: _r }, common: { cubicBezierEaseInOut: wr } } = w.value;
    return { "--n-bezier": wr, "--n-color-segment": Ie, "--n-bar-color": st, "--n-tab-font-size": _r, "--n-tab-text-color": Or, "--n-tab-text-color-active": Qr, "--n-tab-text-color-disabled": sn, "--n-tab-text-color-hover": en, "--n-pane-text-color": re, "--n-tab-border-color": Le, "--n-tab-border-radius": ae, "--n-close-size": _e, "--n-close-icon-size": Ve, "--n-close-color-hover": nt, "--n-close-color-pressed": Xe, "--n-close-border-radius": wt, "--n-close-icon-color": St, "--n-close-icon-color-hover": ar, "--n-close-icon-color-pressed": on, "--n-tab-color": Sn, "--n-tab-font-weight": ne, "--n-tab-font-weight-active": be, "--n-tab-padding": Ut, "--n-tab-padding-vertical": or, "--n-tab-gap": Wt, "--n-tab-gap-vertical": dr, "--n-pane-padding-left": Eo(Te, "left"), "--n-pane-padding-right": Eo(Te, "right"), "--n-pane-padding-top": Eo(Te, "top"), "--n-pane-padding-bottom": Eo(Te, "bottom"), "--n-font-weight-strong": Fe, "--n-tab-color-segment": fe };
  }), kt = o ? hn("tabs", De(() => `${N.value[0]}${a.type[0]}`), We, a) : void 0;
  return Object.assign({ mergedClsPrefix: p, mergedValue: X, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: Yt, tabsPaneWrapperRef: Ne, tabsElRef: S, barElRef: k, addTabInstRef: z, xScrollInstRef: R, scrollWrapperElRef: I, addTabFixed: Tr, tabWrapperStyle: q, handleNavResize: yr, mergedSize: N, handleScroll: Dt, handleTabsResize: rr, cssVars: o ? void 0 : We, themeClass: kt == null ? void 0 : kt.themeClass, animationDirection: Ke, renderNameListRef: Ye, yScrollElRef: O, handleSegmentResize: ut, onAnimationBeforeLeave: at, onAnimationEnter: xt, onAnimationAfterEnter: ht, onRender: kt == null ? void 0 : kt.onRender }, ir);
}, render() {
  const { mergedClsPrefix: a, type: i, placement: l, addTabFixed: d, addable: h, mergedSize: g, renderNameListRef: p, onRender: o, paneWrapperClass: w, paneWrapperStyle: S, $slots: { default: k, prefix: I, suffix: z } } = this;
  o == null ? void 0 : o();
  const R = k ? kl(k()).filter((te) => te.type.__TAB_PANE__ === true) : [], O = k ? kl(k()).filter((te) => te.type.__TAB__ === true) : [], V = !O.length, W = i === "card", N = i === "segment", K = !W && !N && this.justifyContent;
  p.value = [];
  const Z = () => {
    const te = L("div", { style: this.tabWrapperStyle, class: `${a}-tabs-wrapper` }, K ? null : L("div", { class: `${a}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), V ? R.map((q, he) => (p.value.push(q.props.name), Pm(L(lv, Object.assign({}, q.props, { internalCreatedByPane: true, internalLeftPadded: he !== 0 && (!K || K === "center" || K === "start" || K === "end") }), q.children ? { default: q.children.tab } : void 0)))) : O.map((q, he) => (p.value.push(q.props.name), Pm(he !== 0 && !K ? d0(q) : q))), !d && h && W ? u0(h, (V ? R.length : O.length) !== 0) : null, K ? null : L("div", { class: `${a}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return L("div", { ref: "tabsElRef", class: `${a}-tabs-nav-scroll-content` }, W && h ? L(xl, { onResize: this.handleTabsResize }, { default: () => te }) : te, W ? L("div", { class: `${a}-tabs-pad` }) : null, W ? null : L("div", { ref: "barElRef", class: `${a}-tabs-bar` }));
  }, X = N ? "top" : l;
  return L("div", { class: [`${a}-tabs`, this.themeClass, `${a}-tabs--${i}-type`, `${a}-tabs--${g}-size`, K && `${a}-tabs--flex`, `${a}-tabs--${X}`], style: this.cssVars }, L("div", { class: [`${a}-tabs-nav--${i}-type`, `${a}-tabs-nav--${X}`, `${a}-tabs-nav`] }, dn(I, (te) => te && L("div", { class: `${a}-tabs-nav__prefix` }, te)), N ? L(xl, { onResize: this.handleSegmentResize }, { default: () => L("div", { class: `${a}-tabs-rail`, ref: "tabsElRef" }, L("div", { class: `${a}-tabs-capsule`, ref: "segmentCapsuleElRef" }, L("div", { class: `${a}-tabs-wrapper` }, L("div", { class: `${a}-tabs-tab` }))), V ? R.map((te, q) => (p.value.push(te.props.name), L(lv, Object.assign({}, te.props, { internalCreatedByPane: true, internalLeftPadded: q !== 0 }), te.children ? { default: te.children.tab } : void 0))) : O.map((te, q) => (p.value.push(te.props.name), q === 0 ? te : d0(te)))) }) : L(xl, { onResize: this.handleNavResize }, { default: () => L("div", { class: `${a}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(X) ? L(EP, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: Z }) : L("div", { class: `${a}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, Z())) }), d && h && W ? u0(h, true) : null, dn(z, (te) => te && L("div", { class: `${a}-tabs-nav__suffix` }, te))), V && (this.animated && (X === "top" || X === "bottom") ? L("div", { ref: "tabsPaneWrapperRef", style: S, class: [`${a}-tabs-pane-wrapper`, w] }, c0(R, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : c0(R, this.mergedValue, this.renderedNames)));
} });
function c0(a, i, l, d, h, g, p) {
  const o = [];
  return a.forEach((w) => {
    const { name: S, displayDirective: k, "display-directive": I } = w.props, z = (O) => k === O || I === O, R = i === S;
    if (w.key !== void 0 && (w.key = S), R || z("show") || z("show:lazy") && l.has(S)) {
      l.has(S) || l.add(S);
      const O = !z("if");
      o.push(O ? fs(w, [[Gs, R]]) : w);
    }
  }), p ? L(xC, { name: `${p}-transition`, onBeforeLeave: d, onEnter: h, onAfterEnter: g }, { default: () => o }) : o;
}
function u0(a, i) {
  return L(lv, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: i, disabled: typeof a == "object" && a.disabled });
}
function d0(a) {
  const i = Vg(a);
  return i.props ? i.props.internalLeftPadded = true : i.props = { internalLeftPadded: true }, i;
}
function Pm(a) {
  return Array.isArray(a.dynamicProps) ? a.dynamicProps.includes("internalLeftPadded") || a.dynamicProps.push("internalLeftPadded") : a.dynamicProps = ["internalLeftPadded"], a;
}
const uR = de("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [Ge("&:first-child", { marginTop: 0 }), Ue("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ue("align-text", { paddingLeft: 0 }, [Ge("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), Ge("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), Ge("&::before", { backgroundColor: "var(--n-bar-color)" })])]), dR = Object.assign(Object.assign({}, tr.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), hR = (a) => ot({ name: `H${a}`, props: dR, setup(i) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Ir(i), h = tr("Typography", "-h", uR, bx, i, l), g = De(() => {
    const { type: o } = i, { common: { cubicBezierEaseInOut: w }, self: { headerFontWeight: S, headerTextColor: k, [qt("headerPrefixWidth", a)]: I, [qt("headerFontSize", a)]: z, [qt("headerMargin", a)]: R, [qt("headerBarWidth", a)]: O, [qt("headerBarColor", o)]: V } } = h.value;
    return { "--n-bezier": w, "--n-font-size": z, "--n-margin": R, "--n-bar-color": V, "--n-bar-width": O, "--n-font-weight": S, "--n-text-color": k, "--n-prefix-width": I };
  }), p = d ? hn(`h${a}`, De(() => i.type[0]), g, i) : void 0;
  return { mergedClsPrefix: l, cssVars: d ? void 0 : g, themeClass: p == null ? void 0 : p.themeClass, onRender: p == null ? void 0 : p.onRender };
}, render() {
  var i;
  const { prefix: l, alignText: d, mergedClsPrefix: h, cssVars: g, $slots: p } = this;
  return (i = this.onRender) === null || i === void 0 || i.call(this), L(`h${a}`, { class: [`${h}-h`, `${h}-h${a}`, this.themeClass, { [`${h}-h--prefix-bar`]: l, [`${h}-h--align-text`]: d }], style: g }, p);
} }), pR = hR("1"), fR = de("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [Ge("&:first-child", "margin-top: 0;"), Ge("&:last-child", "margin-bottom: 0;")]), mR = Object.assign(Object.assign({}, tr.props), { depth: [String, Number] }), op = ot({ name: "P", props: mR, setup(a) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = tr("Typography", "-p", fR, bx, a, i), h = De(() => {
    const { depth: p } = a, o = p || "1", { common: { cubicBezierEaseInOut: w }, self: { pFontSize: S, pLineHeight: k, pMargin: I, pTextColor: z, [`pTextColor${o}Depth`]: R } } = d.value;
    return { "--n-bezier": w, "--n-font-size": S, "--n-line-height": k, "--n-margin": I, "--n-text-color": p === void 0 ? z : R };
  }), g = l ? hn("p", De(() => `${a.depth || ""}`), h, a) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : h, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var a;
  return (a = this.onRender) === null || a === void 0 || a.call(this), L("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), nu = Ai("n-upload"), gR = Ge([de("upload", "width: 100%;", [Ue("dragger-inside", [de("upload-trigger", `
 display: block;
 `)]), Ue("drag-over", [de("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), de("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [Ge("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ue("disabled", `
 cursor: not-allowed;
 `)]), de("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("+", [de("upload-file-list", "margin-top: 8px;")]), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ue("image-card", `
 width: 96px;
 height: 96px;
 `, [de("base-icon", `
 font-size: 24px;
 `), de("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), de("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("a, img", "outline: none;"), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [de("upload-file", "cursor: not-allowed;")]), Ue("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), de("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Sp(), de("progress", [Sp({ foldPadding: true })]), Ge("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [de("upload-file-info", [Ae("action", `
 opacity: 1;
 `)])]), Ue("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [de("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [de("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Ae("name", `
 padding: 0 8px;
 `), Ae("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [Ge("img", `
 width: 100%;
 `)])])]), Ue("text-type", [de("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ue("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [de("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), de("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Ae("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [Ge("img", `
 width: 100%;
 `)])]), Ge("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), Ge("&:hover", [Ge("&::before", "opacity: 1;"), de("upload-file-info", [Ae("thumbnail", "opacity: .12;")])])]), Ue("error-status", [Ge("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), de("upload-file-info", [Ae("name", "color: var(--n-item-text-color-error);"), Ae("thumbnail", "color: var(--n-item-text-color-error);")]), Ue("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ue("with-url", `
 cursor: pointer;
 `, [de("upload-file-info", [Ae("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [Ge("a", `
 text-decoration: underline;
 `)])])]), de("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Ae("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [de("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Ae("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [de("button", [Ge("&:not(:last-child)", { marginRight: "4px" }), de("base-icon", [Ge("svg", [Rd()])])]), Ue("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ue("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Ae("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [Ge("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), de("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), P1 = "__UPLOAD_DRAGGER__", T1 = ot({ name: "UploadDragger", [P1]: true, setup(a, { slots: i }) {
  const l = hr(nu, null);
  return l || vs("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: d }, mergedDisabledRef: { value: h }, maxReachedRef: { value: g } } = l;
    return L("div", { class: [`${d}-upload-dragger`, (h || g) && `${d}-upload-dragger--disabled`] }, i);
  };
} }), vR = L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, L("g", { fill: "none" }, L("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" }))), yR = L("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, L("g", { fill: "none" }, L("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" }))), _R = ot({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: hr(nu).mergedThemeRef };
}, render() {
  return L(jp, null, { default: () => this.show ? L(XE, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var cv = function(a, i, l, d) {
  function h(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function o(k) {
      try {
        S(d.next(k));
      } catch (I) {
        p(I);
      }
    }
    function w(k) {
      try {
        S(d.throw(k));
      } catch (I) {
        p(I);
      }
    }
    function S(k) {
      k.done ? g(k.value) : h(k.value).then(o, w);
    }
    S((d = d.apply(a, i || [])).next());
  });
};
function M1(a) {
  return a.includes("image/");
}
function h0(a = "") {
  const i = a.split("/"), d = i[i.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(d) || [""])[0];
}
const p0 = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, I1 = (a) => {
  if (a.type) return M1(a.type);
  const i = h0(a.name || "");
  if (p0.test(i)) return true;
  const l = a.thumbnailUrl || a.url || "", d = h0(l);
  return !!(/^data:image\//.test(l) || p0.test(d));
};
function bR(a) {
  return cv(this, void 0, void 0, function* () {
    return yield new Promise((i) => {
      if (!a.type || !M1(a.type)) {
        i("");
        return;
      }
      i(window.URL.createObjectURL(a));
    });
  });
}
const xR = Vp && window.FileReader && window.File;
function wR(a) {
  return a.isDirectory;
}
function CR(a) {
  return a.isFile;
}
function SR(a, i) {
  return cv(this, void 0, void 0, function* () {
    const l = [];
    function d(h) {
      return cv(this, void 0, void 0, function* () {
        for (const g of h) if (g) {
          if (i && wR(g)) {
            const p = g.createReader();
            let o = [], w;
            try {
              do
                w = yield new Promise((S, k) => {
                  p.readEntries(S, k);
                }), o = o.concat(w);
              while (w.length > 0);
            } catch (S) {
              M_("upload", "error happens when handling directory upload", S);
            }
            yield d(o);
          } else if (CR(g)) try {
            const p = yield new Promise((o, w) => {
              g.file(o, w);
            });
            l.push({ file: p, entry: g, source: "dnd" });
          } catch (p) {
            M_("upload", "error happens when handling file upload", p);
          }
        }
      });
    }
    return yield d(a), l;
  });
}
function Od(a) {
  const { id: i, name: l, percentage: d, status: h, url: g, file: p, thumbnailUrl: o, type: w, fullPath: S, batchId: k } = a;
  return { id: i, name: l, percentage: d ?? null, status: h, url: g ?? null, file: p ?? null, thumbnailUrl: o ?? null, type: w ?? null, fullPath: S ?? null, batchId: k ?? null };
}
function kR(a, i, l) {
  return a = a.toLowerCase(), i = i.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((h) => h.trim()).filter(Boolean).some((h) => {
    if (h.startsWith(".")) {
      if (a.endsWith(h)) return true;
    } else if (h.includes("/")) {
      const [g, p] = i.split("/"), [o, w] = h.split("/");
      if ((o === "*" || g && o && o === g) && (w === "*" || p && w && w === p)) return true;
    } else return true;
    return false;
  });
}
var f0 = function(a, i, l, d) {
  function h(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function o(k) {
      try {
        S(d.next(k));
      } catch (I) {
        p(I);
      }
    }
    function w(k) {
      try {
        S(d.throw(k));
      } catch (I) {
        p(I);
      }
    }
    function S(k) {
      k.done ? g(k.value) : h(k.value).then(o, w);
    }
    S((d = d.apply(a, i || [])).next());
  });
};
const sp = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, PR = ot({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(a) {
  const i = hr(nu), l = Me(null), d = Me(""), h = De(() => {
    const { file: te } = a;
    return te.status === "finished" ? "success" : te.status === "error" ? "error" : "info";
  }), g = De(() => {
    const { file: te } = a;
    if (te.status === "error") return "error";
  }), p = De(() => {
    const { file: te } = a;
    return te.status === "uploading";
  }), o = De(() => {
    if (!i.showCancelButtonRef.value) return false;
    const { file: te } = a;
    return ["uploading", "pending", "error"].includes(te.status);
  }), w = De(() => {
    if (!i.showRemoveButtonRef.value) return false;
    const { file: te } = a;
    return ["finished"].includes(te.status);
  }), S = De(() => {
    if (!i.showDownloadButtonRef.value) return false;
    const { file: te } = a;
    return ["finished"].includes(te.status);
  }), k = De(() => {
    if (!i.showRetryButtonRef.value) return false;
    const { file: te } = a;
    return ["error"].includes(te.status);
  }), I = vn(() => d.value || a.file.thumbnailUrl || a.file.url), z = De(() => {
    if (!i.showPreviewButtonRef.value) return false;
    const { file: { status: te }, listType: q } = a;
    return ["finished"].includes(te) && I.value && q === "image-card";
  });
  function R() {
    return f0(this, void 0, void 0, function* () {
      const te = i.onRetryRef.value;
      te && (yield te({ file: a.file })) === false || i.submit(a.file.id);
    });
  }
  function O(te) {
    te.preventDefault();
    const { file: q } = a;
    ["finished", "pending", "error"].includes(q.status) ? W(q) : ["uploading"].includes(q.status) ? K(q) : kp("upload", "The button clicked type is unknown.");
  }
  function V(te) {
    te.preventDefault(), N(a.file);
  }
  function W(te) {
    const { xhrMap: q, doChange: he, onRemoveRef: { value: se }, mergedFileListRef: { value: Q } } = i;
    Promise.resolve(se ? se({ file: Object.assign({}, te), fileList: Q, index: a.index }) : true).then((oe) => {
      if (oe === false) return;
      const ve = Object.assign({}, te, { status: "removed" });
      q.delete(te.id), he(ve, void 0, { remove: true });
    });
  }
  function N(te) {
    const { onDownloadRef: { value: q }, customDownloadRef: { value: he } } = i;
    Promise.resolve(q ? q(Object.assign({}, te)) : true).then((se) => {
      se !== false && (he ? he(Object.assign({}, te)) : Zx(te.url, te.name));
    });
  }
  function K(te) {
    const { xhrMap: q } = i, he = q.get(te.id);
    he == null ? void 0 : he.abort(), W(Object.assign({}, te));
  }
  function Z(te) {
    const { onPreviewRef: { value: q } } = i;
    if (q) q(a.file, { event: te });
    else if (a.listType === "image-card") {
      const { value: he } = l;
      if (!he) return;
      he.click();
    }
  }
  const X = () => f0(this, void 0, void 0, function* () {
    const { listType: te } = a;
    te !== "image" && te !== "image-card" || i.shouldUseThumbnailUrlRef.value(a.file) && (d.value = yield i.getFileThumbnailUrlResolver(a.file));
  });
  return zo(() => {
    X();
  }), { mergedTheme: i.mergedThemeRef, progressStatus: h, buttonType: g, showProgress: p, disabled: i.mergedDisabledRef, showCancelButton: o, showRemoveButton: w, showDownloadButton: S, showRetryButton: k, showPreviewButton: z, mergedThumbnailUrl: I, shouldUseThumbnailUrl: i.shouldUseThumbnailUrlRef, renderIcon: i.renderIconRef, imageRef: l, handleRemoveOrCancelClick: O, handleDownloadClick: V, handleRetryClick: R, handlePreviewClick: Z };
}, render() {
  const { clsPrefix: a, mergedTheme: i, listType: l, file: d, renderIcon: h } = this;
  let g;
  const p = l === "image";
  p || l === "image-card" ? g = !this.shouldUseThumbnailUrl(d) || !this.mergedThumbnailUrl ? L("span", { class: `${a}-upload-file-info__thumbnail` }, h ? h(d) : I1(d) ? L(Ur, { clsPrefix: a }, { default: vR }) : L(Ur, { clsPrefix: a }, { default: yR })) : L("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, class: `${a}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? L(b1, { src: this.mergedThumbnailUrl || void 0, previewSrc: d.url || void 0, alt: d.name, ref: "imageRef" }) : L("img", { src: this.mergedThumbnailUrl || void 0, alt: d.name })) : g = L("span", { class: `${a}-upload-file-info__thumbnail` }, h ? h(d) : L(Ur, { clsPrefix: a }, { default: () => L(_T, null) }));
  const w = L(_R, { show: this.showProgress, percentage: d.percentage || 0, status: this.progressStatus }), S = l === "text" || l === "image";
  return L("div", { class: [`${a}-upload-file`, `${a}-upload-file--${this.progressStatus}-status`, d.url && d.status !== "error" && l !== "image-card" && `${a}-upload-file--with-url`, `${a}-upload-file--${l}-type`] }, L("div", { class: `${a}-upload-file-info` }, g, L("div", { class: `${a}-upload-file-info__name` }, S && (d.url && d.status !== "error" ? L("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, onClick: this.handlePreviewClick }, d.name) : L("span", { onClick: this.handlePreviewClick }, d.name)), p && w), L("div", { class: [`${a}-upload-file-info__action`, `${a}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? L(jr, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: sp }, { icon: () => L(Ur, { clsPrefix: a }, { default: () => L(Xx, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && L(jr, { key: "cancelOrTrash", theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, quaternary: true, builtinThemeOverrides: sp, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => L(Lp, null, { default: () => this.showRemoveButton ? L(Ur, { clsPrefix: a, key: "trash" }, { default: () => L(zT, null) }) : L(Ur, { clsPrefix: a, key: "cancel" }, { default: () => L(bT, null) }) }) }), this.showRetryButton && !this.disabled && L(jr, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: sp }, { icon: () => L(Ur, { clsPrefix: a }, { default: () => L(IT, null) }) }), this.showDownloadButton ? L(jr, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: sp }, { icon: () => L(Ur, { clsPrefix: a }, { default: () => L(Hx, null) }) }) : null)), !p && w);
} }), E1 = ot({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(a, { slots: i }) {
  const l = hr(nu, null);
  l || vs("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: d, mergedDisabledRef: h, maxReachedRef: g, listTypeRef: p, dragOverRef: o, openOpenFileDialog: w, draggerInsideRef: S, handleFileAddition: k, mergedDirectoryDndRef: I, triggerClassRef: z, triggerStyleRef: R } = l, O = De(() => p.value === "image-card");
  function V() {
    h.value || g.value || w();
  }
  function W(X) {
    X.preventDefault(), o.value = true;
  }
  function N(X) {
    X.preventDefault(), o.value = true;
  }
  function K(X) {
    X.preventDefault(), o.value = false;
  }
  function Z(X) {
    var te;
    if (X.preventDefault(), !S.value || h.value || g.value) {
      o.value = false;
      return;
    }
    const q = (te = X.dataTransfer) === null || te === void 0 ? void 0 : te.items;
    (q == null ? void 0 : q.length) ? SR(Array.from(q).map((he) => he.webkitGetAsEntry()), I.value).then((he) => {
      k(he);
    }).finally(() => {
      o.value = false;
    }) : o.value = false;
  }
  return () => {
    var X;
    const { value: te } = d;
    return a.abstract ? (X = i.default) === null || X === void 0 ? void 0 : X.call(i, { handleClick: V, handleDrop: Z, handleDragOver: W, handleDragEnter: N, handleDragLeave: K }) : L("div", { class: [`${te}-upload-trigger`, (h.value || g.value) && `${te}-upload-trigger--disabled`, O.value && `${te}-upload-trigger--image-card`, z.value], style: R.value, onClick: V, onDrop: Z, onDragover: W, onDragenter: N, onDragleave: K }, O.value ? L(T1, null, { default: () => Ui(i.default, () => [L(Ur, { clsPrefix: te }, { default: () => L(Wp, null) })]) }) : i);
  };
} }), TR = ot({ name: "UploadFileList", setup(a, { slots: i }) {
  const l = hr(nu, null);
  l || vs("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: d, mergedClsPrefixRef: h, listTypeRef: g, mergedFileListRef: p, fileListClassRef: o, fileListStyleRef: w, cssVarsRef: S, themeClassRef: k, maxReachedRef: I, showTriggerRef: z, imageGroupPropsRef: R } = l, O = De(() => g.value === "image-card"), V = () => p.value.map((N, K) => L(PR, { clsPrefix: h.value, key: N.id, file: N, index: K, listType: g.value })), W = () => O.value ? L(EE, Object.assign({}, R.value), { default: V }) : L(jp, { group: true }, { default: V });
  return () => {
    const { value: N } = h, { value: K } = d;
    return L("div", { class: [`${N}-upload-file-list`, O.value && `${N}-upload-file-list--grid`, K ? k == null ? void 0 : k.value : void 0, o.value], style: [K && S ? S.value : "", w.value] }, W(), z.value && !I.value && O.value && L(E1, null, i));
  };
} });
var m0 = function(a, i, l, d) {
  function h(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function o(k) {
      try {
        S(d.next(k));
      } catch (I) {
        p(I);
      }
    }
    function w(k) {
      try {
        S(d.throw(k));
      } catch (I) {
        p(I);
      }
    }
    function S(k) {
      k.done ? g(k.value) : h(k.value).then(o, w);
    }
    S((d = d.apply(a, i || [])).next());
  });
};
function MR(a, i, l) {
  const { doChange: d, xhrMap: h } = a;
  let g = 0;
  function p(w) {
    var S;
    let k = Object.assign({}, i, { status: "error", percentage: g });
    h.delete(i.id), k = Od(((S = a.onError) === null || S === void 0 ? void 0 : S.call(a, { file: k, event: w })) || k), d(k, w);
  }
  function o(w) {
    var S;
    if (a.isErrorState) {
      if (a.isErrorState(l)) {
        p(w);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      p(w);
      return;
    }
    let k = Object.assign({}, i, { status: "finished", percentage: g });
    h.delete(i.id), k = Od(((S = a.onFinish) === null || S === void 0 ? void 0 : S.call(a, { file: k, event: w })) || k), d(k, w);
  }
  return { handleXHRLoad: o, handleXHRError: p, handleXHRAbort(w) {
    const S = Object.assign({}, i, { status: "removed", file: null, percentage: g });
    h.delete(i.id), d(S, w);
  }, handleXHRProgress(w) {
    const S = Object.assign({}, i, { status: "uploading" });
    if (w.lengthComputable) {
      const k = Math.ceil(w.loaded / w.total * 100);
      S.percentage = k, g = k;
    }
    d(S, w);
  } };
}
function IR(a) {
  const { inst: i, file: l, data: d, headers: h, withCredentials: g, action: p, customRequest: o } = a, { doChange: w } = a.inst;
  let S = 0;
  o({ file: l, data: d, headers: h, withCredentials: g, action: p, onProgress(k) {
    const I = Object.assign({}, l, { status: "uploading" }), z = k.percent;
    I.percentage = z, S = z, w(I);
  }, onFinish() {
    var k;
    let I = Object.assign({}, l, { status: "finished", percentage: S });
    I = Od(((k = i.onFinish) === null || k === void 0 ? void 0 : k.call(i, { file: I })) || I), w(I);
  }, onError() {
    var k;
    let I = Object.assign({}, l, { status: "error", percentage: S });
    I = Od(((k = i.onError) === null || k === void 0 ? void 0 : k.call(i, { file: I })) || I), w(I);
  } });
}
function ER(a, i, l) {
  const d = MR(a, i, l);
  l.onabort = d.handleXHRAbort, l.onerror = d.handleXHRError, l.onload = d.handleXHRLoad, l.upload && (l.upload.onprogress = d.handleXHRProgress);
}
function R1(a, i) {
  return typeof a == "function" ? a({ file: i }) : a || {};
}
function RR(a, i, l) {
  const d = R1(i, l);
  d && Object.keys(d).forEach((h) => {
    a.setRequestHeader(h, d[h]);
  });
}
function zR(a, i, l) {
  const d = R1(i, l);
  d && Object.keys(d).forEach((h) => {
    a.append(h, d[h]);
  });
}
function AR(a, i, l, { method: d, action: h, withCredentials: g, responseType: p, headers: o, data: w }) {
  const S = new XMLHttpRequest();
  S.responseType = p, a.xhrMap.set(l.id, S), S.withCredentials = g;
  const k = new FormData();
  if (zR(k, w, l), l.file !== null && k.append(i, l.file), ER(a, l, S), h !== void 0) {
    S.open(d.toUpperCase(), h), RR(S, o, l), S.send(k);
    const I = Object.assign({}, l, { status: "uploading" });
    a.doChange(I);
  }
}
const DR = Object.assign(Object.assign({}, tr.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (a) => xR ? I1(a) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), FR = ot({ name: "Upload", props: DR, setup(a) {
  a.abstract && a.listType === "image-card" && vs("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Ir(a), d = tr("Upload", "-upload", gR, ES, a, i), h = gs(a), g = Me(a.defaultFileList), p = Ot(a, "fileList"), o = Me(null), w = { value: false }, S = Me(false), k = /* @__PURE__ */ new Map(), I = wi(p, g), z = De(() => I.value.map(Od)), R = De(() => {
    const { max: Q } = a;
    return Q !== void 0 ? z.value.length >= Q : false;
  });
  function O() {
    var Q;
    (Q = o.value) === null || Q === void 0 || Q.click();
  }
  function V(Q) {
    const oe = Q.target;
    Z(oe.files ? Array.from(oe.files).map((ve) => ({ file: ve, entry: null, source: "input" })) : null, Q), oe.value = "";
  }
  function W(Q) {
    const { "onUpdate:fileList": oe, onUpdateFileList: ve } = a;
    oe && Gt(oe, Q), ve && Gt(ve, Q), g.value = Q;
  }
  const N = De(() => a.multiple || a.directory), K = (Q, oe, ve = { append: false, remove: false }) => {
    const { append: Be, remove: Ne } = ve, Pe = Array.from(z.value), tt = Pe.findIndex((at) => at.id === Q.id);
    if (Be || Ne || ~tt) {
      Be ? Pe.push(Q) : Ne ? Pe.splice(tt, 1) : Pe.splice(tt, 1, Q);
      const { onChange: at } = a;
      at && at({ file: Q, fileList: Pe, event: oe }), W(Pe);
    }
  };
  function Z(Q, oe) {
    if (!Q || Q.length === 0) return;
    const { onBeforeUpload: ve } = a;
    Q = N.value ? Q : [Q[0]];
    const { max: Be, accept: Ne } = a;
    Q = Q.filter(({ file: tt, source: at }) => at === "dnd" && (Ne == null ? void 0 : Ne.trim()) ? kR(tt.name, tt.type, Ne) : true), Be && (Q = Q.slice(0, Be - z.value.length));
    const Pe = Tl();
    Promise.all(Q.map((tt) => m0(this, [tt], void 0, function* ({ file: at, entry: xt }) {
      var ht;
      const Ye = { id: Tl(), batchId: Pe, name: at.name, status: "pending", percentage: 0, file: at, url: null, type: at.type, thumbnailUrl: null, fullPath: (ht = xt == null ? void 0 : xt.fullPath) !== null && ht !== void 0 ? ht : `/${at.webkitRelativePath || at.name}` };
      return !ve || (yield ve({ file: Ye, fileList: z.value })) !== false ? Ye : null;
    }))).then((tt) => m0(this, void 0, void 0, function* () {
      let at = Promise.resolve();
      tt.forEach((xt) => {
        at = at.then(Vi).then(() => {
          xt && K(xt, oe, { append: true });
        });
      }), yield at;
    })).then(() => {
      a.defaultUpload && X();
    });
  }
  function X(Q) {
    const { method: oe, action: ve, withCredentials: Be, headers: Ne, data: Pe, name: tt } = a, at = Q !== void 0 ? z.value.filter((ht) => ht.id === Q) : z.value, xt = Q !== void 0;
    at.forEach((ht) => {
      const { status: Ye } = ht;
      (Ye === "pending" || Ye === "error" && xt) && (a.customRequest ? IR({ inst: { doChange: K, xhrMap: k, onFinish: a.onFinish, onError: a.onError }, file: ht, action: ve, withCredentials: Be, headers: Ne, data: Pe, customRequest: a.customRequest }) : AR({ doChange: K, xhrMap: k, onFinish: a.onFinish, onError: a.onError, isErrorState: a.isErrorState }, tt, ht, { method: oe, action: ve, withCredentials: Be, responseType: a.responseType, headers: Ne, data: Pe }));
    });
  }
  function te(Q) {
    var oe;
    if (Q.thumbnailUrl) return Q.thumbnailUrl;
    const { createThumbnailUrl: ve } = a;
    return ve ? (oe = ve(Q.file, Q)) !== null && oe !== void 0 ? oe : Q.url || "" : Q.url ? Q.url : Q.file ? bR(Q.file) : "";
  }
  const q = De(() => {
    const { common: { cubicBezierEaseInOut: Q }, self: { draggerColor: oe, draggerBorder: ve, draggerBorderHover: Be, itemColorHover: Ne, itemColorHoverError: Pe, itemTextColorError: tt, itemTextColorSuccess: at, itemTextColor: xt, itemIconColor: ht, itemDisabledOpacity: Ye, lineHeight: Ke, borderRadius: Lt, fontSize: ct, itemBorderImageCardError: bt, itemBorderImageCard: Nt } } = d.value;
    return { "--n-bezier": Q, "--n-border-radius": Lt, "--n-dragger-border": ve, "--n-dragger-border-hover": Be, "--n-dragger-color": oe, "--n-font-size": ct, "--n-item-color-hover": Ne, "--n-item-color-hover-error": Pe, "--n-item-disabled-opacity": Ye, "--n-item-icon-color": ht, "--n-item-text-color": xt, "--n-item-text-color-error": tt, "--n-item-text-color-success": at, "--n-line-height": Ke, "--n-item-border-image-card-error": bt, "--n-item-border-image-card": Nt };
  }), he = l ? hn("upload", void 0, q, a) : void 0;
  Zr(nu, { mergedClsPrefixRef: i, mergedThemeRef: d, showCancelButtonRef: Ot(a, "showCancelButton"), showDownloadButtonRef: Ot(a, "showDownloadButton"), showRemoveButtonRef: Ot(a, "showRemoveButton"), showRetryButtonRef: Ot(a, "showRetryButton"), onRemoveRef: Ot(a, "onRemove"), onDownloadRef: Ot(a, "onDownload"), customDownloadRef: Ot(a, "customDownload"), mergedFileListRef: z, triggerClassRef: Ot(a, "triggerClass"), triggerStyleRef: Ot(a, "triggerStyle"), shouldUseThumbnailUrlRef: Ot(a, "shouldUseThumbnailUrl"), renderIconRef: Ot(a, "renderIcon"), xhrMap: k, submit: X, doChange: K, showPreviewButtonRef: Ot(a, "showPreviewButton"), onPreviewRef: Ot(a, "onPreview"), getFileThumbnailUrlResolver: te, listTypeRef: Ot(a, "listType"), dragOverRef: S, openOpenFileDialog: O, draggerInsideRef: w, handleFileAddition: Z, mergedDisabledRef: h.mergedDisabledRef, maxReachedRef: R, fileListClassRef: Ot(a, "fileListClass"), fileListStyleRef: Ot(a, "fileListStyle"), abstractRef: Ot(a, "abstract"), acceptRef: Ot(a, "accept"), cssVarsRef: l ? void 0 : q, themeClassRef: he == null ? void 0 : he.themeClass, onRender: he == null ? void 0 : he.onRender, showTriggerRef: Ot(a, "showTrigger"), imageGroupPropsRef: Ot(a, "imageGroupProps"), mergedDirectoryDndRef: De(() => {
    var Q;
    return (Q = a.directoryDnd) !== null && Q !== void 0 ? Q : a.directory;
  }), onRetryRef: Ot(a, "onRetry") });
  const se = { clear: () => {
    g.value = [];
  }, submit: X, openOpenFileDialog: O };
  return Object.assign({ mergedClsPrefix: i, draggerInsideRef: w, inputElRef: o, mergedTheme: d, dragOver: S, mergedMultiple: N, cssVars: l ? void 0 : q, themeClass: he == null ? void 0 : he.themeClass, onRender: he == null ? void 0 : he.onRender, handleFileInputChange: V }, se);
}, render() {
  var a, i;
  const { draggerInsideRef: l, mergedClsPrefix: d, $slots: h, directory: g, onRender: p } = this;
  if (h.default && !this.abstract) {
    const w = h.default()[0];
    !((a = w == null ? void 0 : w.type) === null || a === void 0) && a[P1] && (l.value = true);
  }
  const o = L("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${d}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: g || void 0, directory: g || void 0 }));
  return this.abstract ? L(qr, null, (i = h.default) === null || i === void 0 ? void 0 : i.call(h), L(Kb, { to: "body" }, o)) : (p == null ? void 0 : p(), L("div", { class: [`${d}-upload`, l.value && `${d}-upload--dragger-inside`, this.dragOver && `${d}-upload--drag-over`, this.themeClass], style: this.cssVars }, o, this.showTrigger && this.listType !== "image-card" && L(E1, null, h), this.showFileList && L(TR, null, h)));
} });
function Sa() {
  const a = hr(nx, null);
  return De(() => {
    if (a === null) return I_;
    const { mergedThemeRef: { value: i }, mergedThemeOverridesRef: { value: l } } = a, d = (i == null ? void 0 : i.common) || I_;
    return (l == null ? void 0 : l.common) ? Object.assign({}, d, l.common) : d;
  });
}
var xp = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.7.0/LICENSE.txt
*/
var LR = xp.exports, g0;
function BR() {
  return g0 || (g0 = 1, (function(a, i) {
    (function(l, d) {
      a.exports = d();
    })(LR, (function() {
      var l = {}, d = {};
      function h(p, o, w) {
        if (d[p] = w, p === "index") {
          var S = "var sharedModule = {}; (" + d.shared + ")(sharedModule); (" + d.worker + ")(sharedModule);", k = {};
          return d.shared(k), d.index(l, k), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([S], { type: "text/javascript" }))), l;
        }
      }
      h("shared", ["exports"], (function(p) {
        function o(n, t, r, c) {
          return new (r || (r = Promise))((function(f, _) {
            function b(E) {
              try {
                P(c.next(E));
              } catch (A) {
                _(A);
              }
            }
            function C(E) {
              try {
                P(c.throw(E));
              } catch (A) {
                _(A);
              }
            }
            function P(E) {
              var A;
              E.done ? f(E.value) : (A = E.value, A instanceof r ? A : new r((function(B) {
                B(A);
              }))).then(b, C);
            }
            P((c = c.apply(n, t || [])).next());
          }));
        }
        function w(n, t) {
          this.x = n, this.y = t;
        }
        function S(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
        }
        var k, I;
        typeof SuppressedError == "function" && SuppressedError, w.prototype = { clone() {
          return new w(this.x, this.y);
        }, add(n) {
          return this.clone()._add(n);
        }, sub(n) {
          return this.clone()._sub(n);
        }, multByPoint(n) {
          return this.clone()._multByPoint(n);
        }, divByPoint(n) {
          return this.clone()._divByPoint(n);
        }, mult(n) {
          return this.clone()._mult(n);
        }, div(n) {
          return this.clone()._div(n);
        }, rotate(n) {
          return this.clone()._rotate(n);
        }, rotateAround(n, t) {
          return this.clone()._rotateAround(n, t);
        }, matMult(n) {
          return this.clone()._matMult(n);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(n) {
          return this.x === n.x && this.y === n.y;
        }, dist(n) {
          return Math.sqrt(this.distSqr(n));
        }, distSqr(n) {
          const t = n.x - this.x, r = n.y - this.y;
          return t * t + r * r;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(n) {
          return Math.atan2(this.y - n.y, this.x - n.x);
        }, angleWith(n) {
          return this.angleWithSep(n.x, n.y);
        }, angleWithSep(n, t) {
          return Math.atan2(this.x * t - this.y * n, this.x * n + this.y * t);
        }, _matMult(n) {
          const t = n[2] * this.x + n[3] * this.y;
          return this.x = n[0] * this.x + n[1] * this.y, this.y = t, this;
        }, _add(n) {
          return this.x += n.x, this.y += n.y, this;
        }, _sub(n) {
          return this.x -= n.x, this.y -= n.y, this;
        }, _mult(n) {
          return this.x *= n, this.y *= n, this;
        }, _div(n) {
          return this.x /= n, this.y /= n, this;
        }, _multByPoint(n) {
          return this.x *= n.x, this.y *= n.y, this;
        }, _divByPoint(n) {
          return this.x /= n.x, this.y /= n.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const n = this.y;
          return this.y = this.x, this.x = -n, this;
        }, _rotate(n) {
          const t = Math.cos(n), r = Math.sin(n), c = r * this.x + t * this.y;
          return this.x = t * this.x - r * this.y, this.y = c, this;
        }, _rotateAround(n, t) {
          const r = Math.cos(n), c = Math.sin(n), f = t.y + c * (this.x - t.x) + r * (this.y - t.y);
          return this.x = t.x + r * (this.x - t.x) - c * (this.y - t.y), this.y = f, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: w }, w.convert = function(n) {
          if (n instanceof w) return n;
          if (Array.isArray(n)) return new w(+n[0], +n[1]);
          if (n.x !== void 0 && n.y !== void 0) return new w(+n.x, +n.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var z = (function() {
          if (I) return k;
          function n(t, r, c, f) {
            this.cx = 3 * t, this.bx = 3 * (c - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return I = 1, k = n, n.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, r) {
            if (r === void 0 && (r = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var c = t, f = 0; f < 8; f++) {
              var _ = this.sampleCurveX(c) - t;
              if (Math.abs(_) < r) return c;
              var b = this.sampleCurveDerivativeX(c);
              if (Math.abs(b) < 1e-6) break;
              c -= _ / b;
            }
            var C = 0, P = 1;
            for (c = t, f = 0; f < 20 && (_ = this.sampleCurveX(c), !(Math.abs(_ - t) < r)); f++) t > _ ? C = c : P = c, c = 0.5 * (P - C) + C;
            return c;
          }, solve: function(t, r) {
            return this.sampleCurveY(this.solveCurveX(t, r));
          } }, k;
        })(), R = S(z);
        let O, V;
        function W() {
          return O == null && (O = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), O;
        }
        function N() {
          if (V == null && (V = false, W())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (t) {
              for (let c = 0; c < 25; c++) {
                const f = 4 * c;
                t.fillStyle = `rgb(${f},${f + 1},${f + 2})`, t.fillRect(c % 5, Math.floor(c / 5), 1, 1);
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let c = 0; c < 100; c++) if (c % 4 != 3 && r[c] !== c) {
                V = true;
                break;
              }
            }
          }
          return V || false;
        }
        var K = 1e-6, Z = typeof Float32Array < "u" ? Float32Array : Array;
        function X() {
          var n = new Z(9);
          return Z != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n;
        }
        function te(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
        }
        function q() {
          var n = new Z(3);
          return Z != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
        }
        function he(n) {
          var t = n[0], r = n[1], c = n[2];
          return Math.sqrt(t * t + r * r + c * c);
        }
        function se(n, t, r) {
          var c = new Z(3);
          return c[0] = n, c[1] = t, c[2] = r, c;
        }
        function Q(n, t, r) {
          return n[0] = t[0] + r[0], n[1] = t[1] + r[1], n[2] = t[2] + r[2], n;
        }
        function oe(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n;
        }
        function ve(n, t, r) {
          var c = t[0], f = t[1], _ = t[2], b = r[0], C = r[1], P = r[2];
          return n[0] = f * P - _ * C, n[1] = _ * b - c * P, n[2] = c * C - f * b, n;
        }
        var Be, Ne = he;
        function Pe(n, t, r) {
          var c = t[0], f = t[1], _ = t[2], b = t[3];
          return n[0] = r[0] * c + r[4] * f + r[8] * _ + r[12] * b, n[1] = r[1] * c + r[5] * f + r[9] * _ + r[13] * b, n[2] = r[2] * c + r[6] * f + r[10] * _ + r[14] * b, n[3] = r[3] * c + r[7] * f + r[11] * _ + r[15] * b, n;
        }
        function tt() {
          var n = new Z(4);
          return Z != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n;
        }
        function at(n, t, r, c) {
          var f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", _ = Math.PI / 360;
          t *= _, c *= _, r *= _;
          var b = Math.sin(t), C = Math.cos(t), P = Math.sin(r), E = Math.cos(r), A = Math.sin(c), B = Math.cos(c);
          switch (f) {
            case "xyz":
              n[0] = b * E * B + C * P * A, n[1] = C * P * B - b * E * A, n[2] = C * E * A + b * P * B, n[3] = C * E * B - b * P * A;
              break;
            case "xzy":
              n[0] = b * E * B - C * P * A, n[1] = C * P * B - b * E * A, n[2] = C * E * A + b * P * B, n[3] = C * E * B + b * P * A;
              break;
            case "yxz":
              n[0] = b * E * B + C * P * A, n[1] = C * P * B - b * E * A, n[2] = C * E * A - b * P * B, n[3] = C * E * B + b * P * A;
              break;
            case "yzx":
              n[0] = b * E * B + C * P * A, n[1] = C * P * B + b * E * A, n[2] = C * E * A - b * P * B, n[3] = C * E * B - b * P * A;
              break;
            case "zxy":
              n[0] = b * E * B - C * P * A, n[1] = C * P * B + b * E * A, n[2] = C * E * A + b * P * B, n[3] = C * E * B - b * P * A;
              break;
            case "zyx":
              n[0] = b * E * B - C * P * A, n[1] = C * P * B + b * E * A, n[2] = C * E * A - b * P * B, n[3] = C * E * B + b * P * A;
              break;
            default:
              throw new Error("Unknown angle order " + f);
          }
          return n;
        }
        function xt() {
          var n = new Z(2);
          return Z != Float32Array && (n[0] = 0, n[1] = 0), n;
        }
        function ht(n, t) {
          var r = new Z(2);
          return r[0] = n, r[1] = t, r;
        }
        q(), Be = new Z(4), Z != Float32Array && (Be[0] = 0, Be[1] = 0, Be[2] = 0, Be[3] = 0), q(), se(1, 0, 0), se(0, 1, 0), tt(), tt(), X(), xt();
        const Ye = 8192;
        function Ke(n, t, r) {
          return t * (Ye / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)));
        }
        function Lt(n, t) {
          return (n % t + t) % t;
        }
        function ct(n, t, r) {
          return n * (1 - r) + t * r;
        }
        function bt(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n, r = t * n;
          return 4 * (n < 0.5 ? r : 3 * (n - t) + r - 0.75);
        }
        function Nt(n, t, r, c) {
          const f = new R(n, t, r, c);
          return (_) => f.solve(_);
        }
        const Yt = Nt(0.25, 0.1, 0.25, 1);
        function vt(n, t, r) {
          return Math.min(r, Math.max(t, n));
        }
        function jt(n, t, r) {
          const c = r - t, f = ((n - t) % c + c) % c + t;
          return f === t ? r : f;
        }
        function er(n, ...t) {
          for (const r of t) for (const c in r) n[c] = r[c];
          return n;
        }
        let yr = 1;
        function Tr(n, t, r) {
          const c = {};
          for (const f in n) c[f] = t.call(this, n[f], f, n);
          return c;
        }
        function zr(n, t, r) {
          const c = {};
          for (const f in n) t.call(this, n[f], f, n) && (c[f] = n[f]);
          return c;
        }
        function rr(n) {
          return Array.isArray(n) ? n.map(rr) : typeof n == "object" && n ? Tr(n, rr) : n;
        }
        const yt = {};
        function Ct(n) {
          yt[n] || (typeof console < "u" && console.warn(n), yt[n] = true);
        }
        function Dt(n, t, r) {
          return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x);
        }
        function ir(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope;
        }
        let ut = null;
        function We(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap;
        }
        const kt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function et(n, t, r, c, f) {
          return o(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const _ = new VideoFrame(n, { timestamp: 0 });
            try {
              const b = _ == null ? void 0 : _.format;
              if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
              const C = b.startsWith("BGR"), P = new Uint8ClampedArray(c * f * 4);
              if (yield _.copyTo(P, (function(E, A, B, U, H) {
                const J = 4 * Math.max(-A, 0), ie = (Math.max(0, B) - B) * U * 4 + J, le = 4 * U, me = Math.max(0, A), Oe = Math.max(0, B);
                return { rect: { x: me, y: Oe, width: Math.min(E.width, A + U) - me, height: Math.min(E.height, B + H) - Oe }, layout: [{ offset: ie, stride: le }] };
              })(n, t, r, c, f)), C) for (let E = 0; E < P.length; E += 4) {
                const A = P[E];
                P[E] = P[E + 2], P[E + 2] = A;
              }
              return P;
            } finally {
              _.close();
            }
          }));
        }
        let it, Pt;
        function Et(n, t, r, c) {
          return n.addEventListener(t, r, c), { unsubscribe: () => {
            n.removeEventListener(t, r, c);
          } };
        }
        function st(n) {
          return n * Math.PI / 180;
        }
        function St(n) {
          return n / Math.PI * 180;
        }
        const ar = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, on = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, Sn = "AbortError";
        function Le() {
          return new Error(Sn);
        }
        const re = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function ne(n) {
          return re.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))];
        }
        const ae = "global-dispatcher";
        class be extends Error {
          constructor(t, r, c, f) {
            super(`AJAXError: ${r} (${t}): ${c}`), this.status = t, this.statusText = r, this.url = c, this.body = f;
          }
        }
        const Ie = () => ir(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Fe = function(n, t) {
          if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
            const c = ne(n.url);
            if (c) return c(n, t);
            if (ir(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: n, targetMapId: ae }, t);
          }
          if (!(/^file:/.test(r = n.url) || /^file:/.test(Ie()) && !/^\w+:/.test(r))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(c, f) {
              return o(this, void 0, void 0, (function* () {
                const _ = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, cache: c.cache, referrer: Ie(), signal: f.signal });
                let b, C;
                c.type !== "json" || _.headers.has("Accept") || _.headers.set("Accept", "application/json");
                try {
                  b = yield fetch(_);
                } catch (E) {
                  throw new be(0, E.message, c.url, new Blob());
                }
                if (!b.ok) {
                  const E = yield b.blob();
                  throw new be(b.status, b.statusText, c.url, E);
                }
                C = c.type === "arrayBuffer" || c.type === "image" ? b.arrayBuffer() : c.type === "json" ? b.json() : b.text();
                const P = yield C;
                if (f.signal.aborted) throw Le();
                return { data: P, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
              }));
            })(n, t);
            if (ir(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: n, mustQueue: true, targetMapId: ae }, t);
          }
          var r;
          return (function(c, f) {
            return new Promise(((_, b) => {
              var C;
              const P = new XMLHttpRequest();
              P.open(c.method || "GET", c.url, true), c.type !== "arrayBuffer" && c.type !== "image" || (P.responseType = "arraybuffer");
              for (const E in c.headers) P.setRequestHeader(E, c.headers[E]);
              c.type === "json" && (P.responseType = "text", !((C = c.headers) === null || C === void 0) && C.Accept || P.setRequestHeader("Accept", "application/json")), P.withCredentials = c.credentials === "include", P.onerror = () => {
                b(new Error(P.statusText));
              }, P.onload = () => {
                if (!f.signal.aborted) if ((P.status >= 200 && P.status < 300 || P.status === 0) && P.response !== null) {
                  let E = P.response;
                  if (c.type === "json") try {
                    E = JSON.parse(P.response);
                  } catch (A) {
                    return void b(A);
                  }
                  _({ data: E, cacheControl: P.getResponseHeader("Cache-Control"), expires: P.getResponseHeader("Expires") });
                } else {
                  const E = new Blob([P.response], { type: P.getResponseHeader("Content-Type") });
                  b(new be(P.status, P.statusText, c.url, E));
                }
              }, f.signal.addEventListener("abort", (() => {
                P.abort(), b(Le());
              })), P.send(c.body);
            }));
          })(n, t);
        };
        function fe(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return true;
          const t = new URL(n), r = window.location;
          return t.protocol === r.protocol && t.host === r.host;
        }
        function _e(n, t, r) {
          r[n] && r[n].indexOf(t) !== -1 || (r[n] = r[n] || [], r[n].push(t));
        }
        function Ve(n, t, r) {
          if (r && r[n]) {
            const c = r[n].indexOf(t);
            c !== -1 && r[n].splice(c, 1);
          }
        }
        class nt {
          constructor(t, r = {}) {
            er(this, r), this.type = t;
          }
        }
        class Xe extends nt {
          constructor(t, r = {}) {
            super("error", er({ error: t }, r));
          }
        }
        class wt {
          on(t, r) {
            return this._listeners = this._listeners || {}, _e(t, r, this._listeners), { unsubscribe: () => {
              this.off(t, r);
            } };
          }
          off(t, r) {
            return Ve(t, r, this._listeners), Ve(t, r, this._oneTimeListeners), this;
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, _e(t, r, this._oneTimeListeners), this) : new Promise(((c) => this.once(t, c)));
          }
          fire(t, r) {
            typeof t == "string" && (t = new nt(t, r || {}));
            const c = t.type;
            if (this.listens(c)) {
              t.target = this;
              const f = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
              for (const C of f) C.call(this, t);
              const _ = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
              for (const C of _) Ve(c, C, this._oneTimeListeners), C.call(this, t);
              const b = this._eventedParent;
              b && (er(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
            } else t instanceof Xe && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this;
          }
        }
        var Te = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const Ut = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function or(n, t) {
          const r = {};
          for (const c in n) c !== "ref" && (r[c] = n[c]);
          return Ut.forEach(((c) => {
            c in t && (r[c] = t[c]);
          })), r;
        }
        function Wt(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return false;
            for (let r = 0; r < n.length; r++) if (!Wt(n[r], t[r])) return false;
            return true;
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return false;
            for (const r in n) if (!Wt(n[r], t[r])) return false;
            return true;
          }
          return n === t;
        }
        function dr(n, t) {
          n.push(t);
        }
        function Or(n, t, r) {
          dr(r, { command: "addSource", args: [n, t[n]] });
        }
        function Qr(n, t, r) {
          dr(t, { command: "removeSource", args: [n] }), r[n] = true;
        }
        function en(n, t, r, c) {
          Qr(n, r, c), Or(n, t, r);
        }
        function sn(n, t, r) {
          let c;
          for (c in n[r]) if (Object.prototype.hasOwnProperty.call(n[r], c) && c !== "data" && !Wt(n[r][c], t[r][c])) return false;
          for (c in t[r]) if (Object.prototype.hasOwnProperty.call(t[r], c) && c !== "data" && !Wt(n[r][c], t[r][c])) return false;
          return true;
        }
        function _r(n, t, r, c, f, _) {
          n = n || {}, t = t || {};
          for (const b in n) Object.prototype.hasOwnProperty.call(n, b) && (Wt(n[b], t[b]) || r.push({ command: _, args: [c, b, t[b], f] }));
          for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(n, b) && (Wt(n[b], t[b]) || r.push({ command: _, args: [c, b, t[b], f] }));
        }
        function wr(n) {
          return n.id;
        }
        function Hr(n, t) {
          return n[t.id] = t, n;
        }
        class ye {
          constructor(t, r, c, f) {
            this.message = (t ? `${t}: ` : "") + c, f && (this.identifier = f), r != null && r.__line__ && (this.line = r.__line__);
          }
        }
        function pt(n, ...t) {
          for (const r of t) for (const c in r) n[c] = r[c];
          return n;
        }
        class Vt extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t;
          }
        }
        class Ar {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [c, f] of r) this.bindings[c] = f;
          }
          concat(t) {
            return new Ar(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const Nr = { kind: "null" }, gt = { kind: "number" }, pr = { kind: "string" }, ur = { kind: "boolean" }, an = { kind: "color" }, ci = { kind: "projectionDefinition" }, ni = { kind: "object" }, fr = { kind: "value" }, Ho = { kind: "collator" }, qi = { kind: "formatted" }, Xo = { kind: "padding" }, Si = { kind: "colorArray" }, xo = { kind: "numberArray" }, Xr = { kind: "resolvedImage" }, Ji = { kind: "variableAnchorOffsetCollection" };
        function ii(n, t) {
          return { kind: "array", itemType: n, N: t };
        }
        function Gr(n) {
          if (n.kind === "array") {
            const t = Gr(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return n.kind;
        }
        const Rl = [Nr, gt, pr, ur, an, ci, qi, ni, ii(fr), Xo, xo, Si, Xr, Ji];
        function ys(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ys(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null;
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const r of Rl) if (!ys(r, t)) return null;
            }
          }
          return `Expected ${Gr(n)} but found ${Gr(t)} instead.`;
        }
        function Ia(n, t) {
          return t.some(((r) => r.kind === n.kind));
        }
        function wo(n, t) {
          return t.some(((r) => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n));
        }
        function Co(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind;
        }
        const Ea = 0.96422, zl = 0.82521, Al = 4 / 29, Yo = 6 / 29, Dl = 3 * Yo * Yo, iu = Yo * Yo * Yo, ou = Math.PI / 180, su = 180 / Math.PI;
        function Ra(n) {
          return (n %= 360) < 0 && (n += 360), n;
        }
        function Ko([n, t, r, c]) {
          let f, _;
          const b = Aa((0.2225045 * (n = za(n)) + 0.7168786 * (t = za(t)) + 0.0606169 * (r = za(r))) / 1);
          n === t && t === r ? f = _ = b : (f = Aa((0.4360747 * n + 0.3850649 * t + 0.1430804 * r) / Ea), _ = Aa((0.0139322 * n + 0.0971045 * t + 0.7141733 * r) / zl));
          const C = 116 * b - 16;
          return [C < 0 ? 0 : C, 500 * (f - b), 200 * (b - _), c];
        }
        function za(n) {
          return n <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
        }
        function Aa(n) {
          return n > iu ? Math.pow(n, 1 / 3) : n / Dl + Al;
        }
        function Jo([n, t, r, c]) {
          let f = (n + 16) / 116, _ = isNaN(t) ? f : f + t / 500, b = isNaN(r) ? f : f - r / 200;
          return f = 1 * Fa(f), _ = Ea * Fa(_), b = zl * Fa(b), [Da(3.1338561 * _ - 1.6168667 * f - 0.4906146 * b), Da(-0.9787684 * _ + 1.9161415 * f + 0.033454 * b), Da(0.0719453 * _ - 0.2289914 * f + 1.4052427 * b), c];
        }
        function Da(n) {
          return (n = n <= 304e-5 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055) < 0 ? 0 : n > 1 ? 1 : n;
        }
        function Fa(n) {
          return n > Yo ? n * n * n : Dl * (n - Al);
        }
        const au = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t);
        };
        function Qo(n, t) {
          return au(n, t) ? n[t] : void 0;
        }
        function _s(n) {
          return parseInt(n.padEnd(2, n), 16) / 255;
        }
        function Di(n, t) {
          return Sr(t ? n / 100 : n, 0, 1);
        }
        function Sr(n, t, r) {
          return Math.min(Math.max(t, n), r);
        }
        function Ao(n) {
          return !n.some(Number.isNaN);
        }
        const So = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Qi(n, t, r) {
          return n + r * (t - n);
        }
        function Do(n, t, r) {
          return n.map(((c, f) => Qi(c, t[f], r)));
        }
        class kr {
          constructor(t, r, c, f = 1, _ = true) {
            this.r = t, this.g = r, this.b = c, this.a = f, _ || (this.r *= f, this.g *= f, this.b *= f, f || this.overwriteGetter("rgb", [t, r, c, f]));
          }
          static parse(t) {
            if (t instanceof kr) return t;
            if (typeof t != "string") return;
            const r = (function(c) {
              if ((c = c.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const f = Qo(So, c);
              if (f) {
                const [b, C, P] = f;
                return [b / 255, C / 255, P / 255, 1];
              }
              if (c.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(c)) {
                const b = c.length < 6 ? 1 : 2;
                let C = 1;
                return [_s(c.slice(C, C += b)), _s(c.slice(C, C += b)), _s(c.slice(C, C += b)), _s(c.slice(C, C + b) || "ff")];
              }
              if (c.startsWith("rgb")) {
                const b = c.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (b) {
                  const [C, P, E, A, B, U, H, J, ie, le, me, Oe] = b, Se = [A || " ", H || " ", le].join("");
                  if (Se === "  " || Se === "  /" || Se === ",," || Se === ",,,") {
                    const Ee = [E, U, ie].join(""), He = Ee === "%%%" ? 100 : Ee === "" ? 255 : 0;
                    if (He) {
                      const rt = [Sr(+P / He, 0, 1), Sr(+B / He, 0, 1), Sr(+J / He, 0, 1), me ? Di(+me, Oe) : 1];
                      if (Ao(rt)) return rt;
                    }
                  }
                  return;
                }
              }
              const _ = c.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (_) {
                const [b, C, P, E, A, B, U, H, J] = _, ie = [P || " ", A || " ", U].join("");
                if (ie === "  " || ie === "  /" || ie === ",," || ie === ",,,") {
                  const le = [+C, Sr(+E, 0, 100), Sr(+B, 0, 100), H ? Di(+H, J) : 1];
                  if (Ao(le)) return (function([me, Oe, Se, Ee]) {
                    function He(rt) {
                      const _t = (rt + me / 30) % 12, Ft = Oe * Math.min(Se, 1 - Se);
                      return Se - Ft * Math.max(-1, Math.min(_t - 3, 9 - _t, 1));
                    }
                    return me = Ra(me), Oe /= 100, Se /= 100, [He(0), He(8), He(4), Ee];
                  })(le);
                }
              }
            })(t);
            return r ? new kr(...r, false) : void 0;
          }
          get rgb() {
            const { r: t, g: r, b: c, a: f } = this, _ = f || 1 / 0;
            return this.overwriteGetter("rgb", [t / _, r / _, c / _, f]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, c, f, _] = Ko(t), b = Math.sqrt(c * c + f * f);
              return [Math.round(1e4 * b) ? Ra(Math.atan2(f, c) * su) : NaN, b, r, _];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Ko(this.rgb));
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, { value: r }), r;
          }
          toString() {
            const [t, r, c, f] = this.rgb;
            return `rgba(${[t, r, c].map(((_) => Math.round(255 * _))).join(",")},${f})`;
          }
          static interpolate(t, r, c, f = "rgb") {
            switch (f) {
              case "rgb": {
                const [_, b, C, P] = Do(t.rgb, r.rgb, c);
                return new kr(_, b, C, P, false);
              }
              case "hcl": {
                const [_, b, C, P] = t.hcl, [E, A, B, U] = r.hcl;
                let H, J;
                if (isNaN(_) || isNaN(E)) isNaN(_) ? isNaN(E) ? H = NaN : (H = E, C !== 1 && C !== 0 || (J = A)) : (H = _, B !== 1 && B !== 0 || (J = b));
                else {
                  let Se = E - _;
                  E > _ && Se > 180 ? Se -= 360 : E < _ && _ - E > 180 && (Se += 360), H = _ + c * Se;
                }
                const [ie, le, me, Oe] = (function([Se, Ee, He, rt]) {
                  return Se = isNaN(Se) ? 0 : Se * ou, Jo([He, Math.cos(Se) * Ee, Math.sin(Se) * Ee, rt]);
                })([H, J ?? Qi(b, A, c), Qi(C, B, c), Qi(P, U, c)]);
                return new kr(ie, le, me, Oe, false);
              }
              case "lab": {
                const [_, b, C, P] = Jo(Do(t.lab, r.lab, c));
                return new kr(_, b, C, P, false);
              }
            }
          }
        }
        kr.black = new kr(0, 0, 0, 1), kr.white = new kr(1, 1, 1, 1), kr.transparent = new kr(0, 0, 0, 0), kr.red = new kr(1, 0, 0, 1);
        class bs {
          constructor(t, r, c) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = c, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, r) {
            return this.collator.compare(t, r);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Fl = ["bottom", "center", "top"];
        class Ll {
          constructor(t, r, c, f, _, b) {
            this.text = t, this.image = r, this.scale = c, this.fontStack = f, this.textColor = _, this.verticalAlign = b;
          }
        }
        class ui {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new ui([new Ll(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof ui ? t : ui.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class Nn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Nn) return t;
            if (typeof t == "number") return new Nn([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t) if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new Nn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, r, c) {
            return new Nn(Do(t.values, r.values, c));
          }
        }
        class di {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof di) return t;
            if (typeof t == "number") return new di([t]);
            if (Array.isArray(t)) {
              for (const r of t) if (typeof r != "number") return;
              return new di(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, r, c) {
            return new di(Do(t.values, r.values, c));
          }
        }
        class Mn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Mn) return t;
            if (typeof t == "string") {
              const c = kr.parse(t);
              return c ? new Mn([c]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const c of t) {
              if (typeof c != "string") return;
              const f = kr.parse(c);
              if (!f) return;
              r.push(f);
            }
            return new Mn(r);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, r, c, f = "rgb") {
            const _ = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let b = 0; b < t.values.length; b++) _.push(kr.interpolate(t.values[b], r.values[b], c, f));
            return new Mn(_);
          }
        }
        class tn extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const Zd = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class hi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof hi) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const c = t[r], f = t[r + 1];
                if (typeof c != "string" || !Zd.has(c) || !Array.isArray(f) || f.length !== 2 || typeof f[0] != "number" || typeof f[1] != "number") return;
              }
              return new hi(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, r, c) {
            const f = t.values, _ = r.values;
            if (f.length !== _.length) throw new tn(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const b = [];
            for (let C = 0; C < f.length; C += 2) {
              if (f[C] !== _[C]) throw new tn(`Cannot interpolate values containing mismatched anchors. from[${C}]: ${f[C]}, to[${C}]: ${_[C]}`);
              b.push(f[C]);
              const [P, E] = f[C + 1], [A, B] = _[C + 1];
              b.push([Qi(P, A, c), Qi(E, B, c)]);
            }
            return new hi(b);
          }
        }
        class Fi {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new Fi({ name: t, available: false }) : null;
          }
        }
        class oi {
          constructor(t, r, c) {
            this.from = t, this.to = r, this.transition = c;
          }
          static interpolate(t, r, c) {
            return new oi(t, r, c);
          }
          static parse(t) {
            return t instanceof oi ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new oi(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new oi(t.from, t.to, t.transition) : typeof t == "string" ? new oi(t, t, 1) : void 0;
          }
        }
        function cn(n, t, r, c) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? c === void 0 || typeof c == "number" && c >= 0 && c <= 1 ? null : `Invalid rgba value [${[n, t, r, c].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof c == "number" ? [n, t, r, c] : [n, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function xs(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof oi || n instanceof kr || n instanceof bs || n instanceof ui || n instanceof Nn || n instanceof di || n instanceof Mn || n instanceof hi || n instanceof Fi) return true;
          if (Array.isArray(n)) {
            for (const t of n) if (!xs(t)) return false;
            return true;
          }
          if (typeof n == "object") {
            for (const t in n) if (!xs(n[t])) return false;
            return true;
          }
          return false;
        }
        function lr(n) {
          if (n === null) return Nr;
          if (typeof n == "string") return pr;
          if (typeof n == "boolean") return ur;
          if (typeof n == "number") return gt;
          if (n instanceof kr) return an;
          if (n instanceof oi) return ci;
          if (n instanceof bs) return Ho;
          if (n instanceof ui) return qi;
          if (n instanceof Nn) return Xo;
          if (n instanceof di) return xo;
          if (n instanceof Mn) return Si;
          if (n instanceof hi) return Ji;
          if (n instanceof Fi) return Xr;
          if (Array.isArray(n)) {
            const t = n.length;
            let r;
            for (const c of n) {
              const f = lr(c);
              if (r) {
                if (r === f) continue;
                r = fr;
                break;
              }
              r = f;
            }
            return ii(r || fr, t);
          }
          return ni;
        }
        function vr(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof kr || n instanceof oi || n instanceof ui || n instanceof Nn || n instanceof di || n instanceof Mn || n instanceof hi || n instanceof Fi ? n.toString() : JSON.stringify(n);
        }
        class Fo {
          constructor(t, r) {
            this.type = t, this.value = r;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!xs(t[1])) return r.error("invalid value");
            const c = t[1];
            let f = lr(c);
            const _ = r.expectedType;
            return f.kind !== "array" || f.N !== 0 || !_ || _.kind !== "array" || typeof _.N == "number" && _.N !== 0 || (f = _), new Fo(f, c);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Dr = { string: pr, number: gt, boolean: ur, object: ni };
        class Li {
          constructor(t, r) {
            this.type = t, this.args = r;
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let c, f = 1;
            const _ = t[0];
            if (_ === "array") {
              let C, P;
              if (t.length > 2) {
                const E = t[1];
                if (typeof E != "string" || !(E in Dr) || E === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                C = Dr[E], f++;
              } else C = fr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                P = t[2], f++;
              }
              c = ii(C, P);
            } else {
              if (!Dr[_]) throw new Error(`Types doesn't contain name = ${_}`);
              c = Dr[_];
            }
            const b = [];
            for (; f < t.length; f++) {
              const C = r.parse(t[f], f, fr);
              if (!C) return null;
              b.push(C);
            }
            return new Li(c, b);
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const c = this.args[r].evaluate(t);
              if (!ys(this.type, lr(c))) return c;
              if (r === this.args.length - 1) throw new tn(`Expected value to be of type ${Gr(this.type)}, but found ${Gr(lr(c))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const ko = { "to-boolean": ur, "to-color": an, "to-number": gt, "to-string": pr };
        class Po {
          constructor(t, r) {
            this.type = t, this.args = r;
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const c = t[0];
            if (!ko[c]) throw new Error(`Can't parse ${c} as it is not part of the known types`);
            if ((c === "to-boolean" || c === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const f = ko[c], _ = [];
            for (let b = 1; b < t.length; b++) {
              const C = r.parse(t[b], b, fr);
              if (!C) return null;
              _.push(C);
            }
            return new Po(f, _);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, c;
                for (const f of this.args) {
                  if (r = f.evaluate(t), c = null, r instanceof kr) return r;
                  if (typeof r == "string") {
                    const _ = t.parseColor(r);
                    if (_) return _;
                  } else if (Array.isArray(r) && (c = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : cn(r[0], r[1], r[2], r[3]), !c)) return new kr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
                }
                throw new tn(c || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "padding": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(t);
                  const f = Nn.parse(r);
                  if (f) return f;
                }
                throw new tn(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "numberArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(t);
                  const f = di.parse(r);
                  if (f) return f;
                }
                throw new tn(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "colorArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(t);
                  const f = Mn.parse(r);
                  if (f) return f;
                }
                throw new tn(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(t);
                  const f = hi.parse(r);
                  if (f) return f;
                }
                throw new tn(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "number": {
                let r = null;
                for (const c of this.args) {
                  if (r = c.evaluate(t), r === null) return 0;
                  const f = Number(r);
                  if (!isNaN(f)) return f;
                }
                throw new tn(`Could not convert ${JSON.stringify(r)} to number.`);
              }
              case "formatted":
                return ui.fromString(vr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Fi.fromString(vr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return vr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Bl = ["Unknown", "Point", "LineString", "Polygon"];
        class lu {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Bl[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = kr.parse(t), this._parseColorCache.set(t, r)), r;
          }
        }
        class Xs {
          constructor(t, r, c = [], f, _ = new Ar(), b = []) {
            this.registry = t, this.path = c, this.key = c.map(((C) => `[${C}]`)).join(""), this.scope = _, this.errors = b, this.expectedType = f, this._isConstant = r;
          }
          parse(t, r, c, f, _ = {}) {
            return r ? this.concat(r, c, f)._parse(t, _) : this._parse(t, _);
          }
          _parse(t, r) {
            function c(f, _, b) {
              return b === "assert" ? new Li(_, [f]) : b === "coerce" ? new Po(_, [f]) : f;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const f = t[0];
              if (typeof f != "string") return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const _ = this.registry[f];
              if (_) {
                let b = _.parse(t, this);
                if (!b) return null;
                if (this.expectedType) {
                  const C = this.expectedType, P = b.type;
                  if (C.kind !== "string" && C.kind !== "number" && C.kind !== "boolean" && C.kind !== "object" && C.kind !== "array" || P.kind !== "value") {
                    if (C.kind === "projectionDefinition" && ["string", "array"].includes(P.kind) || ["color", "formatted", "resolvedImage"].includes(C.kind) && ["value", "string"].includes(P.kind) || ["padding", "numberArray"].includes(C.kind) && ["value", "number", "array"].includes(P.kind) || C.kind === "colorArray" && ["value", "string", "array"].includes(P.kind) || C.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(P.kind)) b = c(b, C, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(C, P)) return null;
                  } else b = c(b, C, r.typeAnnotation || "assert");
                }
                if (!(b instanceof Fo) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                  const C = new lu();
                  try {
                    b = new Fo(b.type, b.evaluate(C));
                  } catch (P) {
                    return this.error(P.message), null;
                  }
                }
                return b;
              }
              return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, r, c) {
            const f = typeof t == "number" ? this.path.concat(t) : this.path, _ = c ? this.scope.concat(c) : this.scope;
            return new Xs(this.registry, this._isConstant, f, r || null, _, this.errors);
          }
          error(t, ...r) {
            const c = `${this.key}${r.map(((f) => `[${f}]`)).join("")}`;
            this.errors.push(new Vt(c, t));
          }
          checkSubtype(t, r) {
            const c = ys(t, r);
            return c && this.error(c), c;
          }
        }
        class La {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result);
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const c = [];
            for (let _ = 1; _ < t.length - 1; _ += 2) {
              const b = t[_];
              if (typeof b != "string") return r.error(`Expected string, but found ${typeof b} instead.`, _);
              if (/[^a-zA-Z0-9_]/.test(b)) return r.error("Variable names must contain only alphanumeric characters or '_'.", _);
              const C = r.parse(t[_ + 1], _ + 1);
              if (!C) return null;
              c.push([b, C]);
            }
            const f = r.parse(t[t.length - 1], t.length - 1, r.expectedType, c);
            return f ? new La(c, f) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ol {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r;
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const c = t[1];
            return r.scope.has(c) ? new Ol(c, r.scope.get(c)) : r.error(`Unknown variable "${c}". Make sure "${c}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class $l {
          constructor(t, r, c) {
            this.type = t, this.index = r, this.input = c;
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const c = r.parse(t[1], 1, gt), f = r.parse(t[2], 2, ii(r.expectedType || fr));
            return c && f ? new $l(f.type.itemType, c, f) : null;
          }
          evaluate(t) {
            const r = this.index.evaluate(t), c = this.input.evaluate(t);
            if (r < 0) throw new tn(`Array index out of bounds: ${r} < 0.`);
            if (r >= c.length) throw new tn(`Array index out of bounds: ${r} > ${c.length - 1}.`);
            if (r !== Math.floor(r)) throw new tn(`Array index must be an integer, but found ${r} instead.`);
            return c[r];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class jl {
          constructor(t, r) {
            this.type = ur, this.needle = t, this.haystack = r;
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const c = r.parse(t[1], 1, fr), f = r.parse(t[2], 2, fr);
            return c && f ? Ia(c.type, [ur, pr, gt, Nr, fr]) ? new jl(c, f) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(c.type)} instead`) : null;
          }
          evaluate(t) {
            const r = this.needle.evaluate(t), c = this.haystack.evaluate(t);
            if (!c) return false;
            if (!wo(r, ["boolean", "string", "number", "null"])) throw new tn(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(lr(r))} instead.`);
            if (!wo(c, ["string", "array"])) throw new tn(`Expected second argument to be of type array or string, but found ${Gr(lr(c))} instead.`);
            return c.indexOf(r) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class eo {
          constructor(t, r, c) {
            this.type = gt, this.needle = t, this.haystack = r, this.fromIndex = c;
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const c = r.parse(t[1], 1, fr), f = r.parse(t[2], 2, fr);
            if (!c || !f) return null;
            if (!Ia(c.type, [ur, pr, gt, Nr, fr])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(c.type)} instead`);
            if (t.length === 4) {
              const _ = r.parse(t[3], 3, gt);
              return _ ? new eo(c, f, _) : null;
            }
            return new eo(c, f);
          }
          evaluate(t) {
            const r = this.needle.evaluate(t), c = this.haystack.evaluate(t);
            if (!wo(r, ["boolean", "string", "number", "null"])) throw new tn(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(lr(r))} instead.`);
            let f;
            if (this.fromIndex && (f = this.fromIndex.evaluate(t)), wo(c, ["string"])) {
              const _ = c.indexOf(r, f);
              return _ === -1 ? -1 : [...c.slice(0, _)].length;
            }
            if (wo(c, ["array"])) return c.indexOf(r, f);
            throw new tn(`Expected second argument to be of type array or string, but found ${Gr(lr(c))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Vn {
          constructor(t, r, c, f, _, b) {
            this.inputType = t, this.type = r, this.input = c, this.cases = f, this.outputs = _, this.otherwise = b;
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let c, f;
            r.expectedType && r.expectedType.kind !== "value" && (f = r.expectedType);
            const _ = {}, b = [];
            for (let E = 2; E < t.length - 1; E += 2) {
              let A = t[E];
              const B = t[E + 1];
              Array.isArray(A) || (A = [A]);
              const U = r.concat(E);
              if (A.length === 0) return U.error("Expected at least one branch label.");
              for (const J of A) {
                if (typeof J != "number" && typeof J != "string") return U.error("Branch labels must be numbers or strings.");
                if (typeof J == "number" && Math.abs(J) > Number.MAX_SAFE_INTEGER) return U.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof J == "number" && Math.floor(J) !== J) return U.error("Numeric branch labels must be integer values.");
                if (c) {
                  if (U.checkSubtype(c, lr(J))) return null;
                } else c = lr(J);
                if (_[String(J)] !== void 0) return U.error("Branch labels must be unique.");
                _[String(J)] = b.length;
              }
              const H = r.parse(B, E, f);
              if (!H) return null;
              f = f || H.type, b.push(H);
            }
            const C = r.parse(t[1], 1, fr);
            if (!C) return null;
            const P = r.parse(t[t.length - 1], t.length - 1, f);
            return P ? C.type.kind !== "value" && r.concat(1).checkSubtype(c, C.type) ? null : new Vn(c, f, C, _, b, P) : null;
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (lr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Ys {
          constructor(t, r, c) {
            this.type = t, this.branches = r, this.otherwise = c;
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const f = [];
            for (let b = 1; b < t.length - 1; b += 2) {
              const C = r.parse(t[b], b, ur);
              if (!C) return null;
              const P = r.parse(t[b + 1], b + 1, c);
              if (!P) return null;
              f.push([C, P]), c = c || P.type;
            }
            const _ = r.parse(t[t.length - 1], t.length - 1, c);
            if (!_) return null;
            if (!c) throw new Error("Can't infer output type");
            return new Ys(c, f, _);
          }
          evaluate(t) {
            for (const [r, c] of this.branches) if (r.evaluate(t)) return c.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [r, c] of this.branches) t(r), t(c);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Ba {
          constructor(t, r, c, f) {
            this.type = t, this.input = r, this.beginIndex = c, this.endIndex = f;
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const c = r.parse(t[1], 1, fr), f = r.parse(t[2], 2, gt);
            if (!c || !f) return null;
            if (!Ia(c.type, [ii(fr), pr, fr])) return r.error(`Expected first argument to be of type array or string, but found ${Gr(c.type)} instead`);
            if (t.length === 4) {
              const _ = r.parse(t[3], 3, gt);
              return _ ? new Ba(c.type, c, f, _) : null;
            }
            return new Ba(c.type, c, f);
          }
          evaluate(t) {
            const r = this.input.evaluate(t), c = this.beginIndex.evaluate(t);
            let f;
            if (this.endIndex && (f = this.endIndex.evaluate(t)), wo(r, ["string"])) return [...r].slice(c, f).join("");
            if (wo(r, ["array"])) return r.slice(c, f);
            throw new tn(`Expected first argument to be of type array or string, but found ${Gr(lr(r))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function ws(n, t) {
          const r = n.length - 1;
          let c, f, _ = 0, b = r, C = 0;
          for (; _ <= b; ) if (C = Math.floor((_ + b) / 2), c = n[C], f = n[C + 1], c <= t) {
            if (C === r || t < f) return C;
            _ = C + 1;
          } else {
            if (!(c > t)) throw new tn("Input is not a number.");
            b = C - 1;
          }
          return 0;
        }
        class wn {
          constructor(t, r, c) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [f, _] of c) this.labels.push(f), this.outputs.push(_);
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const c = r.parse(t[1], 1, gt);
            if (!c) return null;
            const f = [];
            let _ = null;
            r.expectedType && r.expectedType.kind !== "value" && (_ = r.expectedType);
            for (let b = 1; b < t.length; b += 2) {
              const C = b === 1 ? -1 / 0 : t[b], P = t[b + 1], E = b, A = b + 1;
              if (typeof C != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', E);
              if (f.length && f[f.length - 1][0] >= C) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', E);
              const B = r.parse(P, A, _);
              if (!B) return null;
              _ = _ || B.type, f.push([C, B]);
            }
            return new wn(_, c, f);
          }
          evaluate(t) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(t);
            const f = this.input.evaluate(t);
            if (f <= r[0]) return c[0].evaluate(t);
            const _ = r.length;
            return f >= r[_ - 1] ? c[_ - 1].evaluate(t) : c[ws(r, f)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Hd(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
        }
        var Oa, cu, Jp = (function() {
          if (cu) return Oa;
          function n(t, r, c, f) {
            this.cx = 3 * t, this.bx = 3 * (c - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return cu = 1, Oa = n, n.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, r) {
            if (r === void 0 && (r = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var c = t, f = 0; f < 8; f++) {
              var _ = this.sampleCurveX(c) - t;
              if (Math.abs(_) < r) return c;
              var b = this.sampleCurveDerivativeX(c);
              if (Math.abs(b) < 1e-6) break;
              c -= _ / b;
            }
            var C = 0, P = 1;
            for (c = t, f = 0; f < 20 && (_ = this.sampleCurveX(c), !(Math.abs(_ - t) < r)); f++) t > _ ? C = c : P = c, c = 0.5 * (P - C) + C;
            return c;
          }, solve: function(t, r) {
            return this.sampleCurveY(this.solveCurveX(t, r));
          } }, Oa;
        })(), Ks = Hd(Jp);
        class Xn {
          constructor(t, r, c, f, _) {
            this.type = t, this.operator = r, this.interpolation = c, this.input = f, this.labels = [], this.outputs = [];
            for (const [b, C] of _) this.labels.push(b), this.outputs.push(C);
          }
          static interpolationFactor(t, r, c, f) {
            let _ = 0;
            if (t.name === "exponential") _ = $a(r, t.base, c, f);
            else if (t.name === "linear") _ = $a(r, 1, c, f);
            else if (t.name === "cubic-bezier") {
              const b = t.controlPoints;
              _ = new Ks(b[0], b[1], b[2], b[3]).solve($a(r, 1, c, f));
            }
            return _;
          }
          static parse(t, r) {
            let [c, f, _, ...b] = t;
            if (!Array.isArray(f) || f.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (f[0] === "linear") f = { name: "linear" };
            else if (f[0] === "exponential") {
              const E = f[1];
              if (typeof E != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              f = { name: "exponential", base: E };
            } else {
              if (f[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
              {
                const E = f.slice(1);
                if (E.length !== 4 || E.some(((A) => typeof A != "number" || A < 0 || A > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                f = { name: "cubic-bezier", controlPoints: E };
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (_ = r.parse(_, 2, gt), !_) return null;
            const C = [];
            let P = null;
            c !== "interpolate-hcl" && c !== "interpolate-lab" || r.expectedType == Si ? r.expectedType && r.expectedType.kind !== "value" && (P = r.expectedType) : P = an;
            for (let E = 0; E < b.length; E += 2) {
              const A = b[E], B = b[E + 1], U = E + 3, H = E + 4;
              if (typeof A != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', U);
              if (C.length && C[C.length - 1][0] >= A) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', U);
              const J = r.parse(B, H, P);
              if (!J) return null;
              P = P || J.type, C.push([A, J]);
            }
            return Co(P, gt) || Co(P, ci) || Co(P, an) || Co(P, Xo) || Co(P, xo) || Co(P, Si) || Co(P, Ji) || Co(P, ii(gt)) ? new Xn(P, c, f, _, C) : r.error(`Type ${Gr(P)} is not interpolatable.`);
          }
          evaluate(t) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(t);
            const f = this.input.evaluate(t);
            if (f <= r[0]) return c[0].evaluate(t);
            const _ = r.length;
            if (f >= r[_ - 1]) return c[_ - 1].evaluate(t);
            const b = ws(r, f), C = Xn.interpolationFactor(this.interpolation, f, r[b], r[b + 1]), P = c[b].evaluate(t), E = c[b + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Qi(P, E, C);
                  case "color":
                    return kr.interpolate(P, E, C);
                  case "padding":
                    return Nn.interpolate(P, E, C);
                  case "colorArray":
                    return Mn.interpolate(P, E, C);
                  case "numberArray":
                    return di.interpolate(P, E, C);
                  case "variableAnchorOffsetCollection":
                    return hi.interpolate(P, E, C);
                  case "array":
                    return Do(P, E, C);
                  case "projectionDefinition":
                    return oi.interpolate(P, E, C);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return kr.interpolate(P, E, C, "hcl");
                  case "colorArray":
                    return Mn.interpolate(P, E, C, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return kr.interpolate(P, E, C, "lab");
                  case "colorArray":
                    return Mn.interpolate(P, E, C, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function $a(n, t, r, c) {
          const f = c - r, _ = n - r;
          return f === 0 ? 0 : t === 1 ? _ / f : (Math.pow(t, _) - 1) / (Math.pow(t, f) - 1);
        }
        const To = { color: kr.interpolate, number: Qi, padding: Nn.interpolate, numberArray: di.interpolate, colorArray: Mn.interpolate, variableAnchorOffsetCollection: hi.interpolate, array: Do };
        class ja {
          constructor(t, r) {
            this.type = t, this.args = r;
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let c = null;
            const f = r.expectedType;
            f && f.kind !== "value" && (c = f);
            const _ = [];
            for (const C of t.slice(1)) {
              const P = r.parse(C, 1 + _.length, c, void 0, { typeAnnotation: "omit" });
              if (!P) return null;
              c = c || P.type, _.push(P);
            }
            if (!c) throw new Error("No output type");
            const b = f && _.some(((C) => ys(f, C.type)));
            return new ja(b ? fr : c, _);
          }
          evaluate(t) {
            let r, c = null, f = 0;
            for (const _ of this.args) if (f++, c = _.evaluate(t), c && c instanceof Fi && !c.available && (r || (r = c.name), c = null, f === this.args.length && (c = r)), c !== null) break;
            return c;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function Na(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function Va(n, t, r, c) {
          return c.compare(t, r) === 0;
        }
        function si(n, t, r) {
          const c = n !== "==" && n !== "!=";
          return class z1 {
            constructor(_, b, C) {
              this.type = ur, this.lhs = _, this.rhs = b, this.collator = C, this.hasUntypedArgument = _.type.kind === "value" || b.type.kind === "value";
            }
            static parse(_, b) {
              if (_.length !== 3 && _.length !== 4) return b.error("Expected two or three arguments.");
              const C = _[0];
              let P = b.parse(_[1], 1, fr);
              if (!P) return null;
              if (!Na(C, P.type)) return b.concat(1).error(`"${C}" comparisons are not supported for type '${Gr(P.type)}'.`);
              let E = b.parse(_[2], 2, fr);
              if (!E) return null;
              if (!Na(C, E.type)) return b.concat(2).error(`"${C}" comparisons are not supported for type '${Gr(E.type)}'.`);
              if (P.type.kind !== E.type.kind && P.type.kind !== "value" && E.type.kind !== "value") return b.error(`Cannot compare types '${Gr(P.type)}' and '${Gr(E.type)}'.`);
              c && (P.type.kind === "value" && E.type.kind !== "value" ? P = new Li(E.type, [P]) : P.type.kind !== "value" && E.type.kind === "value" && (E = new Li(P.type, [E])));
              let A = null;
              if (_.length === 4) {
                if (P.type.kind !== "string" && E.type.kind !== "string" && P.type.kind !== "value" && E.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
                if (A = b.parse(_[3], 3, Ho), !A) return null;
              }
              return new z1(P, E, A);
            }
            evaluate(_) {
              const b = this.lhs.evaluate(_), C = this.rhs.evaluate(_);
              if (c && this.hasUntypedArgument) {
                const P = lr(b), E = lr(C);
                if (P.kind !== E.kind || P.kind !== "string" && P.kind !== "number") throw new tn(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${P.kind}, ${E.kind}) instead.`);
              }
              if (this.collator && !c && this.hasUntypedArgument) {
                const P = lr(b), E = lr(C);
                if (P.kind !== "string" || E.kind !== "string") return t(_, b, C);
              }
              return this.collator ? r(_, b, C, this.collator.evaluate(_)) : t(_, b, C);
            }
            eachChild(_) {
              _(this.lhs), _(this.rhs), this.collator && _(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const Xd = si("==", (function(n, t, r) {
          return t === r;
        }), Va), Nl = si("!=", (function(n, t, r) {
          return t !== r;
        }), (function(n, t, r, c) {
          return !Va(0, t, r, c);
        })), Qp = si("<", (function(n, t, r) {
          return t < r;
        }), (function(n, t, r, c) {
          return c.compare(t, r) < 0;
        })), uu = si(">", (function(n, t, r) {
          return t > r;
        }), (function(n, t, r, c) {
          return c.compare(t, r) > 0;
        })), ef = si("<=", (function(n, t, r) {
          return t <= r;
        }), (function(n, t, r, c) {
          return c.compare(t, r) <= 0;
        })), tf = si(">=", (function(n, t, r) {
          return t >= r;
        }), (function(n, t, r, c) {
          return c.compare(t, r) >= 0;
        }));
        class Vl {
          constructor(t, r, c) {
            this.type = Ho, this.locale = c, this.caseSensitive = t, this.diacriticSensitive = r;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const c = t[1];
            if (typeof c != "object" || Array.isArray(c)) return r.error("Collator options argument must be an object.");
            const f = r.parse(c["case-sensitive"] !== void 0 && c["case-sensitive"], 1, ur);
            if (!f) return null;
            const _ = r.parse(c["diacritic-sensitive"] !== void 0 && c["diacritic-sensitive"], 1, ur);
            if (!_) return null;
            let b = null;
            return c.locale && (b = r.parse(c.locale, 1, pr), !b) ? null : new Vl(f, _, b);
          }
          evaluate(t) {
            return new bs(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class du {
          constructor(t, r, c, f, _) {
            this.type = pr, this.number = t, this.locale = r, this.currency = c, this.minFractionDigits = f, this.maxFractionDigits = _;
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const c = r.parse(t[1], 1, gt);
            if (!c) return null;
            const f = t[2];
            if (typeof f != "object" || Array.isArray(f)) return r.error("NumberFormat options argument must be an object.");
            let _ = null;
            if (f.locale && (_ = r.parse(f.locale, 1, pr), !_)) return null;
            let b = null;
            if (f.currency && (b = r.parse(f.currency, 1, pr), !b)) return null;
            let C = null;
            if (f["min-fraction-digits"] && (C = r.parse(f["min-fraction-digits"], 1, gt), !C)) return null;
            let P = null;
            return f["max-fraction-digits"] && (P = r.parse(f["max-fraction-digits"], 1, gt), !P) ? null : new du(c, _, b, C, P);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Cs {
          constructor(t) {
            this.type = qi, this.sections = t;
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const c = t[1];
            if (!Array.isArray(c) && typeof c == "object") return r.error("First argument must be an image or text section.");
            const f = [];
            let _ = false;
            for (let b = 1; b <= t.length - 1; ++b) {
              const C = t[b];
              if (_ && typeof C == "object" && !Array.isArray(C)) {
                _ = false;
                let P = null;
                if (C["font-scale"] && (P = r.parse(C["font-scale"], 1, gt), !P)) return null;
                let E = null;
                if (C["text-font"] && (E = r.parse(C["text-font"], 1, ii(pr)), !E)) return null;
                let A = null;
                if (C["text-color"] && (A = r.parse(C["text-color"], 1, an), !A)) return null;
                let B = null;
                if (C["vertical-align"]) {
                  if (typeof C["vertical-align"] == "string" && !Fl.includes(C["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${C["vertical-align"]}' instead.`);
                  if (B = r.parse(C["vertical-align"], 1, pr), !B) return null;
                }
                const U = f[f.length - 1];
                U.scale = P, U.font = E, U.textColor = A, U.verticalAlign = B;
              } else {
                const P = r.parse(t[b], 1, fr);
                if (!P) return null;
                const E = P.type.kind;
                if (E !== "string" && E !== "value" && E !== "null" && E !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                _ = true, f.push({ content: P, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Cs(f);
          }
          evaluate(t) {
            return new ui(this.sections.map(((r) => {
              const c = r.content.evaluate(t);
              return lr(c) === Xr ? new Ll("", c, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new Ll(vr(c), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class hu {
          constructor(t) {
            this.type = Xr, this.input = t;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const c = r.parse(t[1], 1, pr);
            return c ? new hu(c) : r.error("No image name provided.");
          }
          evaluate(t) {
            const r = this.input.evaluate(t), c = Fi.fromString(r);
            return c && t.availableImages && (c.available = t.availableImages.indexOf(r) > -1), c;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Ul {
          constructor(t) {
            this.type = gt, this.input = t;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const c = r.parse(t[1], 1);
            return c ? c.type.kind !== "array" && c.type.kind !== "string" && c.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Gr(c.type)} instead.`) : new Ul(c) : null;
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new tn(`Expected value to be of type string or array, but found ${Gr(lr(r))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const to = 8192;
        function rf(n, t) {
          const r = (180 + n[0]) / 360, c = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360, f = Math.pow(2, t.z);
          return [Math.round(r * f * to), Math.round(c * f * to)];
        }
        function ql(n, t) {
          const r = Math.pow(2, t.z);
          return [(f = (n[0] / to + t.x) / r, 360 * f - 180), (c = (n[1] / to + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90)];
          var c, f;
        }
        function Ua(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1]);
        }
        function qa(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3]);
        }
        function nf(n, t, r) {
          const c = n[0] - t[0], f = n[1] - t[1], _ = n[0] - r[0], b = n[1] - r[1];
          return c * b - _ * f == 0 && c * _ <= 0 && f * b <= 0;
        }
        function Gl(n, t, r, c) {
          return (f = [c[0] - r[0], c[1] - r[1]])[0] * (_ = [t[0] - n[0], t[1] - n[1]])[1] - f[1] * _[0] != 0 && !(!Kd(n, t, r, c) || !Kd(r, c, n, t));
          var f, _;
        }
        function of(n, t, r) {
          for (const c of r) for (let f = 0; f < c.length - 1; ++f) if (Gl(n, t, c[f], c[f + 1])) return true;
          return false;
        }
        function Ss(n, t, r = false) {
          let c = false;
          for (const C of t) for (let P = 0; P < C.length - 1; P++) {
            if (nf(n, C[P], C[P + 1])) return r;
            (_ = C[P])[1] > (f = n)[1] != (b = C[P + 1])[1] > f[1] && f[0] < (b[0] - _[0]) * (f[1] - _[1]) / (b[1] - _[1]) + _[0] && (c = !c);
          }
          var f, _, b;
          return c;
        }
        function Yd(n, t) {
          for (const r of t) if (Ss(n, r)) return true;
          return false;
        }
        function pu(n, t) {
          for (const r of n) if (!Ss(r, t)) return false;
          for (let r = 0; r < n.length - 1; ++r) if (of(n[r], n[r + 1], t)) return false;
          return true;
        }
        function sf(n, t) {
          for (const r of t) if (pu(n, r)) return true;
          return false;
        }
        function Kd(n, t, r, c) {
          const f = c[0] - r[0], _ = c[1] - r[1], b = (n[0] - r[0]) * _ - f * (n[1] - r[1]), C = (t[0] - r[0]) * _ - f * (t[1] - r[1]);
          return b > 0 && C < 0 || b < 0 && C > 0;
        }
        function fu(n, t, r) {
          const c = [];
          for (let f = 0; f < n.length; f++) {
            const _ = [];
            for (let b = 0; b < n[f].length; b++) {
              const C = rf(n[f][b], r);
              Ua(t, C), _.push(C);
            }
            c.push(_);
          }
          return c;
        }
        function Jd(n, t, r) {
          const c = [];
          for (let f = 0; f < n.length; f++) {
            const _ = fu(n[f], t, r);
            c.push(_);
          }
          return c;
        }
        function Wl(n, t, r, c) {
          if (n[0] < r[0] || n[0] > r[2]) {
            const f = 0.5 * c;
            let _ = n[0] - r[0] > f ? -c : r[0] - n[0] > f ? c : 0;
            _ === 0 && (_ = n[0] - r[2] > f ? -c : r[2] - n[0] > f ? c : 0), n[0] += _;
          }
          Ua(t, n);
        }
        function Qd(n, t, r, c) {
          const f = Math.pow(2, c.z) * to, _ = [c.x * to, c.y * to], b = [];
          for (const C of n) for (const P of C) {
            const E = [P.x + _[0], P.y + _[1]];
            Wl(E, t, r, f), b.push(E);
          }
          return b;
        }
        function eh(n, t, r, c) {
          const f = Math.pow(2, c.z) * to, _ = [c.x * to, c.y * to], b = [];
          for (const P of n) {
            const E = [];
            for (const A of P) {
              const B = [A.x + _[0], A.y + _[1]];
              Ua(t, B), E.push(B);
            }
            b.push(E);
          }
          if (t[2] - t[0] <= f / 2) {
            (C = t)[0] = C[1] = 1 / 0, C[2] = C[3] = -1 / 0;
            for (const P of b) for (const E of P) Wl(E, t, r, f);
          }
          var C;
          return b;
        }
        class ks {
          constructor(t, r) {
            this.type = ur, this.geojson = t, this.geometries = r;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (xs(t[1])) {
              const c = t[1];
              if (c.type === "FeatureCollection") {
                const f = [];
                for (const _ of c.features) {
                  const { type: b, coordinates: C } = _.geometry;
                  b === "Polygon" && f.push(C), b === "MultiPolygon" && f.push(...C);
                }
                if (f.length) return new ks(c, { type: "MultiPolygon", coordinates: f });
              } else if (c.type === "Feature") {
                const f = c.geometry.type;
                if (f === "Polygon" || f === "MultiPolygon") return new ks(c, c.geometry);
              } else if (c.type === "Polygon" || c.type === "MultiPolygon") return new ks(c, c);
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = r.canonicalID();
                if (c.type === "Polygon") {
                  const C = fu(c.coordinates, _, b), P = Qd(r.geometry(), f, _, b);
                  if (!qa(f, _)) return false;
                  for (const E of P) if (!Ss(E, C)) return false;
                }
                if (c.type === "MultiPolygon") {
                  const C = Jd(c.coordinates, _, b), P = Qd(r.geometry(), f, _, b);
                  if (!qa(f, _)) return false;
                  for (const E of P) if (!Yd(E, C)) return false;
                }
                return true;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = r.canonicalID();
                if (c.type === "Polygon") {
                  const C = fu(c.coordinates, _, b), P = eh(r.geometry(), f, _, b);
                  if (!qa(f, _)) return false;
                  for (const E of P) if (!pu(E, C)) return false;
                }
                if (c.type === "MultiPolygon") {
                  const C = Jd(c.coordinates, _, b), P = eh(r.geometry(), f, _, b);
                  if (!qa(f, _)) return false;
                  for (const E of P) if (!sf(E, C)) return false;
                }
                return true;
              })(t, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let mu = class {
          constructor(n = [], t = (r, c) => r < c ? -1 : r > c ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
          }
          push(n) {
            this.data.push(n), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n;
          }
          peek() {
            return this.data[0];
          }
          _up(n) {
            const { data: t, compare: r } = this, c = t[n];
            for (; n > 0; ) {
              const f = n - 1 >> 1, _ = t[f];
              if (r(c, _) >= 0) break;
              t[n] = _, n = f;
            }
            t[n] = c;
          }
          _down(n) {
            const { data: t, compare: r } = this, c = this.length >> 1, f = t[n];
            for (; n < c; ) {
              let _ = 1 + (n << 1);
              const b = _ + 1;
              if (b < this.length && r(t[b], t[_]) < 0 && (_ = b), r(t[_], f) >= 0) break;
              t[n] = t[_], n = _;
            }
            t[n] = f;
          }
        };
        function gu(n, t, r = 0, c = n.length - 1, f = af) {
          for (; c > r; ) {
            if (c - r > 600) {
              const P = c - r + 1, E = t - r + 1, A = Math.log(P), B = 0.5 * Math.exp(2 * A / 3), U = 0.5 * Math.sqrt(A * B * (P - B) / P) * (E - P / 2 < 0 ? -1 : 1);
              gu(n, t, Math.max(r, Math.floor(t - E * B / P + U)), Math.min(c, Math.floor(t + (P - E) * B / P + U)), f);
            }
            const _ = n[t];
            let b = r, C = c;
            for (Ga(n, r, t), f(n[c], _) > 0 && Ga(n, r, c); b < C; ) {
              for (Ga(n, b, C), b++, C--; f(n[b], _) < 0; ) b++;
              for (; f(n[C], _) > 0; ) C--;
            }
            f(n[r], _) === 0 ? Ga(n, r, C) : (C++, Ga(n, C, c)), C <= t && (r = C + 1), t <= C && (c = C - 1);
          }
        }
        function Ga(n, t, r) {
          const c = n[t];
          n[t] = n[r], n[r] = c;
        }
        function af(n, t) {
          return n < t ? -1 : n > t ? 1 : 0;
        }
        function Wa(n, t) {
          if (n.length <= 1) return [n];
          const r = [];
          let c, f;
          for (const _ of n) {
            const b = lf(_);
            b !== 0 && (_.area = Math.abs(b), f === void 0 && (f = b < 0), f === b < 0 ? (c && r.push(c), c = [_]) : c.push(_));
          }
          if (c && r.push(c), t > 1) for (let _ = 0; _ < r.length; _++) r[_].length <= t || (gu(r[_], t, 1, r[_].length - 1, th), r[_] = r[_].slice(0, t));
          return r;
        }
        function th(n, t) {
          return t.area - n.area;
        }
        function lf(n) {
          let t = 0;
          for (let r, c, f = 0, _ = n.length, b = _ - 1; f < _; b = f++) r = n[f], c = n[b], t += (c.x - r.x) * (r.y + c.y);
          return t;
        }
        const rh = 1 / 298.257223563, nh = rh * (2 - rh), vu = Math.PI / 180;
        class yu {
          constructor(t) {
            const r = 6378.137 * vu * 1e3, c = Math.cos(t * vu), f = 1 / (1 - nh * (1 - c * c)), _ = Math.sqrt(f);
            this.kx = r * _ * c, this.ky = r * _ * f * (1 - nh);
          }
          distance(t, r) {
            const c = this.wrap(t[0] - r[0]) * this.kx, f = (t[1] - r[1]) * this.ky;
            return Math.sqrt(c * c + f * f);
          }
          pointOnLine(t, r) {
            let c, f, _, b, C = 1 / 0;
            for (let P = 0; P < t.length - 1; P++) {
              let E = t[P][0], A = t[P][1], B = this.wrap(t[P + 1][0] - E) * this.kx, U = (t[P + 1][1] - A) * this.ky, H = 0;
              B === 0 && U === 0 || (H = (this.wrap(r[0] - E) * this.kx * B + (r[1] - A) * this.ky * U) / (B * B + U * U), H > 1 ? (E = t[P + 1][0], A = t[P + 1][1]) : H > 0 && (E += B / this.kx * H, A += U / this.ky * H)), B = this.wrap(r[0] - E) * this.kx, U = (r[1] - A) * this.ky;
              const J = B * B + U * U;
              J < C && (C = J, c = E, f = A, _ = P, b = H);
            }
            return { point: [c, f], index: _, t: Math.max(0, Math.min(1, b)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function ih(n, t) {
          return t[0] - n[0];
        }
        function Zl(n) {
          return n[1] - n[0] + 1;
        }
        function Lo(n, t) {
          return n[1] >= n[0] && n[1] < t;
        }
        function Lr(n, t) {
          if (n[0] > n[1]) return [null, null];
          const r = Zl(n);
          if (t) {
            if (r === 2) return [n, null];
            const f = Math.floor(r / 2);
            return [[n[0], n[0] + f], [n[0] + f, n[1]]];
          }
          if (r === 1) return [n, null];
          const c = Math.floor(r / 2) - 1;
          return [[n[0], n[0] + c], [n[0] + c + 1, n[1]]];
        }
        function _u(n, t) {
          if (!Lo(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let c = t[0]; c <= t[1]; ++c) Ua(r, n[c]);
          return r;
        }
        function bu(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of n) for (const c of r) Ua(t, c);
          return t;
        }
        function oh(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0;
        }
        function xu(n, t, r) {
          if (!oh(n) || !oh(t)) return NaN;
          let c = 0, f = 0;
          return n[2] < t[0] && (c = t[0] - n[2]), n[0] > t[2] && (c = n[0] - t[2]), n[1] > t[3] && (f = n[1] - t[3]), n[3] < t[1] && (f = t[1] - n[3]), r.distance([0, 0], [c, f]);
        }
        function Ps(n, t, r) {
          const c = r.pointOnLine(t, n);
          return r.distance(n, c.point);
        }
        function wu(n, t, r, c, f) {
          const _ = Math.min(Ps(n, [r, c], f), Ps(t, [r, c], f)), b = Math.min(Ps(r, [n, t], f), Ps(c, [n, t], f));
          return Math.min(_, b);
        }
        function cf(n, t, r, c, f) {
          if (!Lo(t, n.length) || !Lo(c, r.length)) return 1 / 0;
          let _ = 1 / 0;
          for (let b = t[0]; b < t[1]; ++b) {
            const C = n[b], P = n[b + 1];
            for (let E = c[0]; E < c[1]; ++E) {
              const A = r[E], B = r[E + 1];
              if (Gl(C, P, A, B)) return 0;
              _ = Math.min(_, wu(C, P, A, B, f));
            }
          }
          return _;
        }
        function uf(n, t, r, c, f) {
          if (!Lo(t, n.length) || !Lo(c, r.length)) return NaN;
          let _ = 1 / 0;
          for (let b = t[0]; b <= t[1]; ++b) for (let C = c[0]; C <= c[1]; ++C) if (_ = Math.min(_, f.distance(n[b], r[C])), _ === 0) return _;
          return _;
        }
        function df(n, t, r) {
          if (Ss(n, t, true)) return 0;
          let c = 1 / 0;
          for (const f of t) {
            const _ = f[0], b = f[f.length - 1];
            if (_ !== b && (c = Math.min(c, Ps(n, [b, _], r)), c === 0)) return c;
            const C = r.pointOnLine(f, n);
            if (c = Math.min(c, r.distance(n, C.point)), c === 0) return c;
          }
          return c;
        }
        function hf(n, t, r, c) {
          if (!Lo(t, n.length)) return NaN;
          for (let _ = t[0]; _ <= t[1]; ++_) if (Ss(n[_], r, true)) return 0;
          let f = 1 / 0;
          for (let _ = t[0]; _ < t[1]; ++_) {
            const b = n[_], C = n[_ + 1];
            for (const P of r) for (let E = 0, A = P.length, B = A - 1; E < A; B = E++) {
              const U = P[B], H = P[E];
              if (Gl(b, C, U, H)) return 0;
              f = Math.min(f, wu(b, C, U, H, c));
            }
          }
          return f;
        }
        function sh(n, t) {
          for (const r of n) for (const c of r) if (Ss(c, t, true)) return true;
          return false;
        }
        function pf(n, t, r, c = 1 / 0) {
          const f = bu(n), _ = bu(t);
          if (c !== 1 / 0 && xu(f, _, r) >= c) return c;
          if (qa(f, _)) {
            if (sh(n, t)) return 0;
          } else if (sh(t, n)) return 0;
          let b = 1 / 0;
          for (const C of n) for (let P = 0, E = C.length, A = E - 1; P < E; A = P++) {
            const B = C[A], U = C[P];
            for (const H of t) for (let J = 0, ie = H.length, le = ie - 1; J < ie; le = J++) {
              const me = H[le], Oe = H[J];
              if (Gl(B, U, me, Oe)) return 0;
              b = Math.min(b, wu(B, U, me, Oe, r));
            }
          }
          return b;
        }
        function ah(n, t, r, c, f, _) {
          if (!_) return;
          const b = xu(_u(c, _), f, r);
          b < t && n.push([b, _, [0, 0]]);
        }
        function Hl(n, t, r, c, f, _, b) {
          if (!_ || !b) return;
          const C = xu(_u(c, _), _u(f, b), r);
          C < t && n.push([C, _, b]);
        }
        function Xl(n, t, r, c, f = 1 / 0) {
          let _ = Math.min(c.distance(n[0], r[0][0]), f);
          if (_ === 0) return _;
          const b = new mu([[0, [0, n.length - 1], [0, 0]]], ih), C = bu(r);
          for (; b.length > 0; ) {
            const P = b.pop();
            if (P[0] >= _) continue;
            const E = P[1], A = t ? 50 : 100;
            if (Zl(E) <= A) {
              if (!Lo(E, n.length)) return NaN;
              if (t) {
                const B = hf(n, E, r, c);
                if (isNaN(B) || B === 0) return B;
                _ = Math.min(_, B);
              } else for (let B = E[0]; B <= E[1]; ++B) {
                const U = df(n[B], r, c);
                if (_ = Math.min(_, U), _ === 0) return 0;
              }
            } else {
              const B = Lr(E, t);
              ah(b, _, c, n, C, B[0]), ah(b, _, c, n, C, B[1]);
            }
          }
          return _;
        }
        function Yl(n, t, r, c, f, _ = 1 / 0) {
          let b = Math.min(_, f.distance(n[0], r[0]));
          if (b === 0) return b;
          const C = new mu([[0, [0, n.length - 1], [0, r.length - 1]]], ih);
          for (; C.length > 0; ) {
            const P = C.pop();
            if (P[0] >= b) continue;
            const E = P[1], A = P[2], B = t ? 50 : 100, U = c ? 50 : 100;
            if (Zl(E) <= B && Zl(A) <= U) {
              if (!Lo(E, n.length) && Lo(A, r.length)) return NaN;
              let H;
              if (t && c) H = cf(n, E, r, A, f), b = Math.min(b, H);
              else if (t && !c) {
                const J = n.slice(E[0], E[1] + 1);
                for (let ie = A[0]; ie <= A[1]; ++ie) if (H = Ps(r[ie], J, f), b = Math.min(b, H), b === 0) return b;
              } else if (!t && c) {
                const J = r.slice(A[0], A[1] + 1);
                for (let ie = E[0]; ie <= E[1]; ++ie) if (H = Ps(n[ie], J, f), b = Math.min(b, H), b === 0) return b;
              } else H = uf(n, E, r, A, f), b = Math.min(b, H);
            } else {
              const H = Lr(E, t), J = Lr(A, c);
              Hl(C, b, f, n, r, H[0], J[0]), Hl(C, b, f, n, r, H[0], J[1]), Hl(C, b, f, n, r, H[1], J[0]), Hl(C, b, f, n, r, H[1], J[1]);
            }
          }
          return b;
        }
        function Cu(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : n.type === "MultiLineString" ? n.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : n.type === "MultiPoint" ? n.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [n];
        }
        class Ts {
          constructor(t, r) {
            this.type = gt, this.geojson = t, this.geometries = r;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (xs(t[1])) {
              const c = t[1];
              if (c.type === "FeatureCollection") return new Ts(c, c.features.map(((f) => Cu(f.geometry))).flat());
              if (c.type === "Feature") return new Ts(c, Cu(c.geometry));
              if ("type" in c && "coordinates" in c) return new Ts(c, Cu(c));
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, c) {
                const f = r.geometry(), _ = f.flat().map(((P) => ql([P.x, P.y], r.canonical)));
                if (f.length === 0) return NaN;
                const b = new yu(_[0][1]);
                let C = 1 / 0;
                for (const P of c) {
                  switch (P.type) {
                    case "Point":
                      C = Math.min(C, Yl(_, false, [P.coordinates], false, b, C));
                      break;
                    case "LineString":
                      C = Math.min(C, Yl(_, false, P.coordinates, true, b, C));
                      break;
                    case "Polygon":
                      C = Math.min(C, Xl(_, false, P.coordinates, b, C));
                  }
                  if (C === 0) return C;
                }
                return C;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, c) {
                const f = r.geometry(), _ = f.flat().map(((P) => ql([P.x, P.y], r.canonical)));
                if (f.length === 0) return NaN;
                const b = new yu(_[0][1]);
                let C = 1 / 0;
                for (const P of c) {
                  switch (P.type) {
                    case "Point":
                      C = Math.min(C, Yl(_, true, [P.coordinates], false, b, C));
                      break;
                    case "LineString":
                      C = Math.min(C, Yl(_, true, P.coordinates, true, b, C));
                      break;
                    case "Polygon":
                      C = Math.min(C, Xl(_, true, P.coordinates, b, C));
                  }
                  if (C === 0) return C;
                }
                return C;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, c) {
                const f = r.geometry();
                if (f.length === 0 || f[0].length === 0) return NaN;
                const _ = Wa(f, 0).map(((P) => P.map(((E) => E.map(((A) => ql([A.x, A.y], r.canonical))))))), b = new yu(_[0][0][0][1]);
                let C = 1 / 0;
                for (const P of c) for (const E of _) {
                  switch (P.type) {
                    case "Point":
                      C = Math.min(C, Xl([P.coordinates], false, E, b, C));
                      break;
                    case "LineString":
                      C = Math.min(C, Xl(P.coordinates, true, E, b, C));
                      break;
                    case "Polygon":
                      C = Math.min(C, pf(E, P.coordinates, b, C));
                  }
                  if (C === 0) return C;
                }
                return C;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Za {
          constructor(t) {
            this.type = fr, this.key = t;
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const c = t[1];
            return c == null ? r.error("Global state property must be defined.") : typeof c != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Za(c);
          }
          evaluate(t) {
            var r;
            const c = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return c && Object.keys(c).length !== 0 ? Qo(c, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const Js = { "==": Xd, "!=": Nl, ">": uu, "<": Qp, ">=": tf, "<=": ef, array: Li, at: $l, boolean: Li, case: Ys, coalesce: ja, collator: Vl, format: Cs, image: hu, in: jl, "index-of": eo, interpolate: Xn, "interpolate-hcl": Xn, "interpolate-lab": Xn, length: Ul, let: La, literal: Fo, match: Vn, number: Li, "number-format": du, object: Li, slice: Ba, step: wn, string: Li, "to-boolean": Po, "to-color": Po, "to-number": Po, "to-string": Po, var: Ol, within: ks, distance: Ts, "global-state": Za };
        class Gi {
          constructor(t, r, c, f) {
            this.name = t, this.type = r, this._evaluate = c, this.args = f;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return false;
          }
          static parse(t, r) {
            const c = t[0], f = Gi.definitions[c];
            if (!f) return r.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const _ = Array.isArray(f) ? f[0] : f.type, b = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads, C = b.filter((([E]) => !Array.isArray(E) || E.length === t.length - 1));
            let P = null;
            for (const [E, A] of C) {
              P = new Xs(r.registry, Kl, r.path, null, r.scope);
              const B = [];
              let U = false;
              for (let H = 1; H < t.length; H++) {
                const J = t[H], ie = Array.isArray(E) ? E[H - 1] : E.type, le = P.parse(J, 1 + B.length, ie);
                if (!le) {
                  U = true;
                  break;
                }
                B.push(le);
              }
              if (!U) if (Array.isArray(E) && E.length !== B.length) P.error(`Expected ${E.length} arguments, but found ${B.length} instead.`);
              else {
                for (let H = 0; H < B.length; H++) {
                  const J = Array.isArray(E) ? E[H] : E.type, ie = B[H];
                  P.concat(H + 1).checkSubtype(J, ie.type);
                }
                if (P.errors.length === 0) return new Gi(c, _, A, B);
              }
            }
            if (C.length === 1) r.errors.push(...P.errors);
            else {
              const E = (C.length ? C : b).map((([B]) => {
                return U = B, Array.isArray(U) ? `(${U.map(Gr).join(", ")})` : `(${Gr(U.type)}...)`;
                var U;
              })).join(" | "), A = [];
              for (let B = 1; B < t.length; B++) {
                const U = r.parse(t[B], 1 + A.length);
                if (!U) return null;
                A.push(Gr(U.type));
              }
              r.error(`Expected arguments of type ${E}, but found (${A.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, r) {
            Gi.definitions = r;
            for (const c in r) t[c] = Gi;
          }
        }
        function lh(n, [t, r, c, f]) {
          t = t.evaluate(n), r = r.evaluate(n), c = c.evaluate(n);
          const _ = f ? f.evaluate(n) : 1, b = cn(t, r, c, _);
          if (b) throw new tn(b);
          return new kr(t / 255, r / 255, c / 255, _, false);
        }
        function ch(n, t) {
          return n in t;
        }
        function Su(n, t) {
          const r = t[n];
          return r === void 0 ? null : r;
        }
        function Ms(n) {
          return { type: n };
        }
        function Kl(n) {
          if (n instanceof Ol) return Kl(n.boundExpression);
          if (n instanceof Gi && n.name === "error" || n instanceof Vl || n instanceof ks || n instanceof Ts || n instanceof Za) return false;
          const t = n instanceof Po || n instanceof Li;
          let r = true;
          return n.eachChild(((c) => {
            r = t ? r && Kl(c) : r && c instanceof Fo;
          })), !!r && Jl(n) && Ql(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Jl(n) {
          if (n instanceof Gi && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof ks || n instanceof Ts) return false;
          let t = true;
          return n.eachChild(((r) => {
            t && !Jl(r) && (t = false);
          })), t;
        }
        function Ha(n) {
          if (n instanceof Gi && n.name === "feature-state") return false;
          let t = true;
          return n.eachChild(((r) => {
            t && !Ha(r) && (t = false);
          })), t;
        }
        function Ql(n, t) {
          if (n instanceof Gi && t.indexOf(n.name) >= 0) return false;
          let r = true;
          return n.eachChild(((c) => {
            r && !Ql(c, t) && (r = false);
          })), r;
        }
        function uh(n) {
          return { result: "success", value: n };
        }
        function Qs(n) {
          return { result: "error", value: n };
        }
        function es(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven";
        }
        function dh(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1;
        }
        function ku(n) {
          return !!n.expression && n.expression.interpolated;
        }
        function Mr(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n;
        }
        function Xa(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && lr(n) === ni;
        }
        function ff(n) {
          return n;
        }
        function hh(n, t) {
          const r = n.stops && typeof n.stops[0][0] == "object", c = r || !(r || n.property !== void 0), f = n.type || (ku(t) ? "exponential" : "interval"), _ = (function(A) {
            switch (A.type) {
              case "color":
                return kr.parse;
              case "padding":
                return Nn.parse;
              case "numberArray":
                return di.parse;
              case "colorArray":
                return Mn.parse;
              default:
                return null;
            }
          })(t);
          if (_ && ((n = pt({}, n)).stops && (n.stops = n.stops.map(((A) => [A[0], _(A[1])]))), n.default = _(n.default ? n.default : t.default)), n.colorSpace && (b = n.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var b;
          const C = (function(A) {
            switch (A) {
              case "exponential":
                return fh;
              case "interval":
                return mf;
              case "categorical":
                return ph;
              case "identity":
                return gf;
              default:
                throw new Error(`Unknown function type "${A}"`);
            }
          })(f);
          let P, E;
          if (f === "categorical") {
            P = /* @__PURE__ */ Object.create(null);
            for (const A of n.stops) P[A[0]] = A[1];
            E = typeof n.stops[0][0];
          }
          if (r) {
            const A = {}, B = [];
            for (let J = 0; J < n.stops.length; J++) {
              const ie = n.stops[J], le = ie[0].zoom;
              A[le] === void 0 && (A[le] = { zoom: le, type: n.type, property: n.property, default: n.default, stops: [] }, B.push(le)), A[le].stops.push([ie[0].value, ie[1]]);
            }
            const U = [];
            for (const J of B) U.push([A[J].zoom, hh(A[J], t)]);
            const H = { name: "linear" };
            return { kind: "composite", interpolationType: H, interpolationFactor: Xn.interpolationFactor.bind(void 0, H), zoomStops: U.map(((J) => J[0])), evaluate: ({ zoom: J }, ie) => fh({ stops: U, base: n.base }, t, J).evaluate(J, ie) };
          }
          if (c) {
            const A = f === "exponential" ? { name: "exponential", base: n.base !== void 0 ? n.base : 1 } : null;
            return { kind: "camera", interpolationType: A, interpolationFactor: Xn.interpolationFactor.bind(void 0, A), zoomStops: n.stops.map(((B) => B[0])), evaluate: ({ zoom: B }) => C(n, t, B, P, E) };
          }
          return { kind: "source", evaluate(A, B) {
            const U = B && B.properties ? B.properties[n.property] : void 0;
            return U === void 0 ? ts(n.default, t.default) : C(n, t, U, P, E);
          } };
        }
        function ts(n, t, r) {
          return n !== void 0 ? n : t !== void 0 ? t : r !== void 0 ? r : void 0;
        }
        function ph(n, t, r, c, f) {
          return ts(typeof r === f ? c[r] : void 0, n.default, t.default);
        }
        function mf(n, t, r) {
          if (Mr(r) !== "number") return ts(n.default, t.default);
          const c = n.stops.length;
          if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
          const f = ws(n.stops.map(((_) => _[0])), r);
          return n.stops[f][1];
        }
        function fh(n, t, r) {
          const c = n.base !== void 0 ? n.base : 1;
          if (Mr(r) !== "number") return ts(n.default, t.default);
          const f = n.stops.length;
          if (f === 1 || r <= n.stops[0][0]) return n.stops[0][1];
          if (r >= n.stops[f - 1][0]) return n.stops[f - 1][1];
          const _ = ws(n.stops.map(((A) => A[0])), r), b = (function(A, B, U, H) {
            const J = H - U, ie = A - U;
            return J === 0 ? 0 : B === 1 ? ie / J : (Math.pow(B, ie) - 1) / (Math.pow(B, J) - 1);
          })(r, c, n.stops[_][0], n.stops[_ + 1][0]), C = n.stops[_][1], P = n.stops[_ + 1][1], E = To[t.type] || ff;
          return typeof C.evaluate == "function" ? { evaluate(...A) {
            const B = C.evaluate.apply(void 0, A), U = P.evaluate.apply(void 0, A);
            if (B !== void 0 && U !== void 0) return E(B, U, b, n.colorSpace);
          } } : E(C, P, b, n.colorSpace);
        }
        function gf(n, t, r) {
          switch (t.type) {
            case "color":
              r = kr.parse(r);
              break;
            case "formatted":
              r = ui.fromString(r.toString());
              break;
            case "resolvedImage":
              r = Fi.fromString(r.toString());
              break;
            case "padding":
              r = Nn.parse(r);
              break;
            case "colorArray":
              r = Mn.parse(r);
              break;
            case "numberArray":
              r = di.parse(r);
              break;
            default:
              Mr(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0);
          }
          return ts(r, n.default, t.default);
        }
        Gi.register(Js, { error: [{ kind: "error" }, [pr], (n, [t]) => {
          throw new tn(t.evaluate(n));
        }], typeof: [pr, [fr], (n, [t]) => Gr(lr(t.evaluate(n)))], "to-rgba": [ii(gt, 4), [an], (n, [t]) => {
          const [r, c, f, _] = t.evaluate(n).rgb;
          return [255 * r, 255 * c, 255 * f, _];
        }], rgb: [an, [gt, gt, gt], lh], rgba: [an, [gt, gt, gt, gt], lh], has: { type: ur, overloads: [[[pr], (n, [t]) => ch(t.evaluate(n), n.properties())], [[pr, ni], (n, [t, r]) => ch(t.evaluate(n), r.evaluate(n))]] }, get: { type: fr, overloads: [[[pr], (n, [t]) => Su(t.evaluate(n), n.properties())], [[pr, ni], (n, [t, r]) => Su(t.evaluate(n), r.evaluate(n))]] }, "feature-state": [fr, [pr], (n, [t]) => Su(t.evaluate(n), n.featureState || {})], properties: [ni, [], (n) => n.properties()], "geometry-type": [pr, [], (n) => n.geometryType()], id: [fr, [], (n) => n.id()], zoom: [gt, [], (n) => n.globals.zoom], "heatmap-density": [gt, [], (n) => n.globals.heatmapDensity || 0], elevation: [gt, [], (n) => n.globals.elevation || 0], "line-progress": [gt, [], (n) => n.globals.lineProgress || 0], accumulated: [fr, [], (n) => n.globals.accumulated === void 0 ? null : n.globals.accumulated], "+": [gt, Ms(gt), (n, t) => {
          let r = 0;
          for (const c of t) r += c.evaluate(n);
          return r;
        }], "*": [gt, Ms(gt), (n, t) => {
          let r = 1;
          for (const c of t) r *= c.evaluate(n);
          return r;
        }], "-": { type: gt, overloads: [[[gt, gt], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)], [[gt], (n, [t]) => -t.evaluate(n)]] }, "/": [gt, [gt, gt], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)], "%": [gt, [gt, gt], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)], ln2: [gt, [], () => Math.LN2], pi: [gt, [], () => Math.PI], e: [gt, [], () => Math.E], "^": [gt, [gt, gt], (n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n))], sqrt: [gt, [gt], (n, [t]) => Math.sqrt(t.evaluate(n))], log10: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10], ln: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n))], log2: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2], sin: [gt, [gt], (n, [t]) => Math.sin(t.evaluate(n))], cos: [gt, [gt], (n, [t]) => Math.cos(t.evaluate(n))], tan: [gt, [gt], (n, [t]) => Math.tan(t.evaluate(n))], asin: [gt, [gt], (n, [t]) => Math.asin(t.evaluate(n))], acos: [gt, [gt], (n, [t]) => Math.acos(t.evaluate(n))], atan: [gt, [gt], (n, [t]) => Math.atan(t.evaluate(n))], min: [gt, Ms(gt), (n, t) => Math.min(...t.map(((r) => r.evaluate(n))))], max: [gt, Ms(gt), (n, t) => Math.max(...t.map(((r) => r.evaluate(n))))], abs: [gt, [gt], (n, [t]) => Math.abs(t.evaluate(n))], round: [gt, [gt], (n, [t]) => {
          const r = t.evaluate(n);
          return r < 0 ? -Math.round(-r) : Math.round(r);
        }], floor: [gt, [gt], (n, [t]) => Math.floor(t.evaluate(n))], ceil: [gt, [gt], (n, [t]) => Math.ceil(t.evaluate(n))], "filter-==": [ur, [pr, fr], (n, [t, r]) => n.properties()[t.value] === r.value], "filter-id-==": [ur, [fr], (n, [t]) => n.id() === t.value], "filter-type-==": [ur, [pr], (n, [t]) => n.geometryType() === t.value], "filter-<": [ur, [pr, fr], (n, [t, r]) => {
          const c = n.properties()[t.value], f = r.value;
          return typeof c == typeof f && c < f;
        }], "filter-id-<": [ur, [fr], (n, [t]) => {
          const r = n.id(), c = t.value;
          return typeof r == typeof c && r < c;
        }], "filter->": [ur, [pr, fr], (n, [t, r]) => {
          const c = n.properties()[t.value], f = r.value;
          return typeof c == typeof f && c > f;
        }], "filter-id->": [ur, [fr], (n, [t]) => {
          const r = n.id(), c = t.value;
          return typeof r == typeof c && r > c;
        }], "filter-<=": [ur, [pr, fr], (n, [t, r]) => {
          const c = n.properties()[t.value], f = r.value;
          return typeof c == typeof f && c <= f;
        }], "filter-id-<=": [ur, [fr], (n, [t]) => {
          const r = n.id(), c = t.value;
          return typeof r == typeof c && r <= c;
        }], "filter->=": [ur, [pr, fr], (n, [t, r]) => {
          const c = n.properties()[t.value], f = r.value;
          return typeof c == typeof f && c >= f;
        }], "filter-id->=": [ur, [fr], (n, [t]) => {
          const r = n.id(), c = t.value;
          return typeof r == typeof c && r >= c;
        }], "filter-has": [ur, [fr], (n, [t]) => t.value in n.properties()], "filter-has-id": [ur, [], (n) => n.id() !== null && n.id() !== void 0], "filter-type-in": [ur, [ii(pr)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0], "filter-id-in": [ur, [ii(fr)], (n, [t]) => t.value.indexOf(n.id()) >= 0], "filter-in-small": [ur, [pr, ii(fr)], (n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0], "filter-in-large": [ur, [pr, ii(fr)], (n, [t, r]) => (function(c, f, _, b) {
          for (; _ <= b; ) {
            const C = _ + b >> 1;
            if (f[C] === c) return true;
            f[C] > c ? b = C - 1 : _ = C + 1;
          }
          return false;
        })(n.properties()[t.value], r.value, 0, r.value.length - 1)], all: { type: ur, overloads: [[[ur, ur], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)], [Ms(ur), (n, t) => {
          for (const r of t) if (!r.evaluate(n)) return false;
          return true;
        }]] }, any: { type: ur, overloads: [[[ur, ur], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)], [Ms(ur), (n, t) => {
          for (const r of t) if (r.evaluate(n)) return true;
          return false;
        }]] }, "!": [ur, [ur], (n, [t]) => !t.evaluate(n)], "is-supported-script": [ur, [pr], (n, [t]) => {
          const r = n.globals && n.globals.isSupportedScript;
          return !r || r(t.evaluate(n));
        }], upcase: [pr, [pr], (n, [t]) => t.evaluate(n).toUpperCase()], downcase: [pr, [pr], (n, [t]) => t.evaluate(n).toLowerCase()], concat: [pr, Ms(fr), (n, t) => t.map(((r) => vr(r.evaluate(n)))).join("")], "resolved-locale": [pr, [Ho], (n, [t]) => t.evaluate(n).resolvedLocale()] });
        class Pu {
          constructor(t, r) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new lu(), this._defaultValue = r ? (function(c) {
              if (c.type === "color" && Xa(c.default)) return new kr(0, 0, 0, 0);
              switch (c.type) {
                case "color":
                  return kr.parse(c.default) || null;
                case "padding":
                  return Nn.parse(c.default) || null;
                case "numberArray":
                  return di.parse(c.default) || null;
                case "colorArray":
                  return Mn.parse(c.default) || null;
                case "variableAnchorOffsetCollection":
                  return hi.parse(c.default) || null;
                case "projectionDefinition":
                  return oi.parse(c.default) || null;
                default:
                  return c.default === void 0 ? null : c.default;
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null;
          }
          evaluateWithoutErrorHandling(t, r, c, f, _, b) {
            return this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = c, this._evaluator.canonical = f, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, r, c, f, _, b) {
            this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = c || null, this._evaluator.canonical = f, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b || null;
            try {
              const C = this.expression.evaluate(this._evaluator);
              if (C == null || typeof C == "number" && C != C) return this._defaultValue;
              if (this._enumValues && !(C in this._enumValues)) throw new tn(`Expected value to be one of ${Object.keys(this._enumValues).map(((P) => JSON.stringify(P))).join(", ")}, but found ${JSON.stringify(C)} instead.`);
              return C;
            } catch (C) {
              return this._warningHistory[C.message] || (this._warningHistory[C.message] = true, typeof console < "u" && console.warn(C.message)), this._defaultValue;
            }
          }
        }
        function ec(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in Js;
        }
        function Ya(n, t) {
          const r = new Xs(Js, Kl, [], t ? (function(f) {
            const _ = { color: an, string: pr, number: gt, enum: pr, boolean: ur, formatted: qi, padding: Xo, numberArray: xo, colorArray: Si, projectionDefinition: ci, resolvedImage: Xr, variableAnchorOffsetCollection: Ji };
            return f.type === "array" ? ii(_[f.value] || fr, f.length) : _[f.type];
          })(t) : void 0), c = r.parse(n, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return c ? uh(new Pu(c, t)) : Qs(r.errors);
        }
        class Ka {
          constructor(t, r) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Ha(r.expression), this.globalStateRefs = el(r.expression);
          }
          evaluateWithoutErrorHandling(t, r, c, f, _, b) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, c, f, _, b);
          }
          evaluate(t, r, c, f, _, b) {
            return this._styleExpression.evaluate(t, r, c, f, _, b);
          }
        }
        class Tu {
          constructor(t, r, c, f) {
            this.kind = t, this.zoomStops = c, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Ha(r.expression), this.globalStateRefs = el(r.expression), this.interpolationType = f;
          }
          evaluateWithoutErrorHandling(t, r, c, f, _, b) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, r, c, f, _, b);
          }
          evaluate(t, r, c, f, _, b) {
            return this._styleExpression.evaluate(t, r, c, f, _, b);
          }
          interpolationFactor(t, r, c) {
            return this.interpolationType ? Xn.interpolationFactor(this.interpolationType, t, r, c) : 0;
          }
        }
        function mh(n, t) {
          const r = Ya(n, t);
          if (r.result === "error") return r;
          const c = r.value.expression, f = Jl(c);
          if (!f && !es(t)) return Qs([new Vt("", "data expressions not supported")]);
          const _ = Ql(c, ["zoom"]);
          if (!_ && !dh(t)) return Qs([new Vt("", "zoom expressions not supported")]);
          const b = Qa(c);
          return b || _ ? b instanceof Vt ? Qs([b]) : b instanceof Xn && !ku(t) ? Qs([new Vt("", '"interpolate" expressions cannot be used with this property')]) : uh(b ? new Tu(f ? "camera" : "composite", r.value, b.labels, b instanceof Xn ? b.interpolation : void 0) : new Ka(f ? "constant" : "source", r.value)) : Qs([new Vt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Ja {
          constructor(t, r) {
            this._parameters = t, this._specification = r, pt(this, hh(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new Ja(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function Qa(n) {
          let t = null;
          if (n instanceof La) t = Qa(n.result);
          else if (n instanceof ja) {
            for (const r of n.args) if (t = Qa(r), t) break;
          } else (n instanceof wn || n instanceof Xn) && n.input instanceof Gi && n.input.name === "zoom" && (t = n);
          return t instanceof Vt || n.eachChild(((r) => {
            const c = Qa(r);
            c instanceof Vt ? t = c : !t && c ? t = new Vt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && c && t !== c && (t = new Vt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function el(n, t = /* @__PURE__ */ new Set()) {
          return n instanceof Za && t.add(n.key), n.eachChild(((r) => {
            el(r, t);
          })), t;
        }
        function tc(n) {
          if (n === true || n === false) return true;
          if (!Array.isArray(n) || n.length === 0) return false;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1)) if (!tc(t) && typeof t != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const Mu = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Is(n) {
          if (n == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          tc(n) || (n = Es(n));
          const t = Ya(n, Mu);
          if (t.result === "error") throw new Error(t.value.map(((r) => `${r.key}: ${r.message}`)).join(", "));
          return { filter: (r, c, f) => t.value.evaluate(r, c, {}, f), needGeometry: rc(n), getGlobalStateRefs: () => el(t.value.expression) };
        }
        function Iu(n, t) {
          return n < t ? -1 : n > t ? 1 : 0;
        }
        function rc(n) {
          if (!Array.isArray(n)) return false;
          if (n[0] === "within" || n[0] === "distance") return true;
          for (let t = 1; t < n.length; t++) if (rc(n[t])) return true;
          return false;
        }
        function Es(n) {
          if (!n) return true;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? Eu(n[1], n[2], "==") : t === "!=" ? nc(Eu(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Eu(n[1], n[2], t) : t === "any" ? (r = n.slice(1), ["any"].concat(r.map(Es))) : t === "all" ? ["all"].concat(n.slice(1).map(Es)) : t === "none" ? ["all"].concat(n.slice(1).map(Es).map(nc)) : t === "in" ? gh(n[1], n.slice(2)) : t === "!in" ? nc(gh(n[1], n.slice(2))) : t === "has" ? vh(n[1]) : t !== "!has" || nc(vh(n[1]));
          var r;
        }
        function Eu(n, t, r) {
          switch (n) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, n, t];
          }
        }
        function gh(n, t) {
          if (t.length === 0) return false;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((r) => typeof r != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(Iu)]] : ["filter-in-small", n, ["literal", t]];
          }
        }
        function vh(n) {
          switch (n) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n];
          }
        }
        function nc(n) {
          return ["!", n];
        }
        function Ru(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let f = "[";
            for (const _ of n) f += `${Ru(_)},`;
            return `${f}]`;
          }
          const r = Object.keys(n).sort();
          let c = "{";
          for (let f = 0; f < r.length; f++) c += `${JSON.stringify(r[f])}:${Ru(n[r[f]])},`;
          return `${c}}`;
        }
        function vf(n) {
          let t = "";
          for (const r of Ut) t += `/${Ru(n[r])}`;
          return t;
        }
        function zu(n) {
          const t = n.value;
          return t ? [new ye(n.key, t, "constants have been deprecated as of v8")] : [];
        }
        function yn(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n;
        }
        function Mo(n) {
          if (Array.isArray(n)) return n.map(Mo);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const r in n) t[r] = Mo(n[r]);
            return t;
          }
          return yn(n);
        }
        function Wi(n) {
          const t = n.key, r = n.value, c = n.valueSpec || {}, f = n.objectElementValidators || {}, _ = n.style, b = n.styleSpec, C = n.validateSpec;
          let P = [];
          const E = Mr(r);
          if (E !== "object") return [new ye(t, r, `object expected, ${E} found`)];
          for (const A in r) {
            const B = A.split(".")[0], U = Qo(c, B) || c["*"];
            let H;
            if (Qo(f, B)) H = f[B];
            else if (Qo(c, B)) H = C;
            else if (f["*"]) H = f["*"];
            else {
              if (!c["*"]) {
                P.push(new ye(t, r[A], `unknown property "${A}"`));
                continue;
              }
              H = C;
            }
            P = P.concat(H({ key: (t && `${t}.`) + A, value: r[A], valueSpec: U, style: _, styleSpec: b, object: r, objectKey: A, validateSpec: C }, r));
          }
          for (const A in c) f[A] || c[A].required && c[A].default === void 0 && r[A] === void 0 && P.push(new ye(t, r, `missing required property "${A}"`));
          return P;
        }
        function ic(n) {
          const t = n.value, r = n.valueSpec, c = n.style, f = n.styleSpec, _ = n.key, b = n.arrayElementValidator || n.validateSpec;
          if (Mr(t) !== "array") return [new ye(_, t, `array expected, ${Mr(t)} found`)];
          if (r.length && t.length !== r.length) return [new ye(_, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new ye(_, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let C = { type: r.value, values: r.values };
          f.$version < 7 && (C.function = r.function), Mr(r.value) === "object" && (C = r.value);
          let P = [];
          for (let E = 0; E < t.length; E++) P = P.concat(b({ array: t, arrayIndex: E, value: t[E], valueSpec: C, validateSpec: n.validateSpec, style: c, styleSpec: f, key: `${_}[${E}]` }));
          return P;
        }
        function tl(n) {
          const t = n.key, r = n.value, c = n.valueSpec;
          let f = Mr(r);
          return f === "number" && r != r && (f = "NaN"), f !== "number" ? [new ye(t, r, `number expected, ${f} found`)] : "minimum" in c && r < c.minimum ? [new ye(t, r, `${r} is less than the minimum value ${c.minimum}`)] : "maximum" in c && r > c.maximum ? [new ye(t, r, `${r} is greater than the maximum value ${c.maximum}`)] : [];
        }
        function yh(n) {
          const t = n.valueSpec, r = yn(n.value.type);
          let c, f, _, b = {};
          const C = r !== "categorical" && n.value.property === void 0, P = !C, E = Mr(n.value.stops) === "array" && Mr(n.value.stops[0]) === "array" && Mr(n.value.stops[0][0]) === "object", A = Wi({ key: n.key, value: n.value, valueSpec: n.styleSpec.function, validateSpec: n.validateSpec, style: n.style, styleSpec: n.styleSpec, objectElementValidators: { stops: function(H) {
            if (r === "identity") return [new ye(H.key, H.value, 'identity function may not have a "stops" property')];
            let J = [];
            const ie = H.value;
            return J = J.concat(ic({ key: H.key, value: ie, valueSpec: H.valueSpec, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, arrayElementValidator: B })), Mr(ie) === "array" && ie.length === 0 && J.push(new ye(H.key, ie, "array must have at least one stop")), J;
          }, default: function(H) {
            return H.validateSpec({ key: H.key, value: H.value, valueSpec: t, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec });
          } } });
          return r === "identity" && C && A.push(new ye(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || A.push(new ye(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !ku(n.valueSpec) && A.push(new ye(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (P && !es(n.valueSpec) ? A.push(new ye(n.key, n.value, "property functions not supported")) : C && !dh(n.valueSpec) && A.push(new ye(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !E || n.value.property !== void 0 || A.push(new ye(n.key, n.value, '"property" property is required')), A;
          function B(H) {
            let J = [];
            const ie = H.value, le = H.key;
            if (Mr(ie) !== "array") return [new ye(le, ie, `array expected, ${Mr(ie)} found`)];
            if (ie.length !== 2) return [new ye(le, ie, `array length 2 expected, length ${ie.length} found`)];
            if (E) {
              if (Mr(ie[0]) !== "object") return [new ye(le, ie, `object expected, ${Mr(ie[0])} found`)];
              if (ie[0].zoom === void 0) return [new ye(le, ie, "object stop key must have zoom")];
              if (ie[0].value === void 0) return [new ye(le, ie, "object stop key must have value")];
              if (_ && _ > yn(ie[0].zoom)) return [new ye(le, ie[0].zoom, "stop zoom values must appear in ascending order")];
              yn(ie[0].zoom) !== _ && (_ = yn(ie[0].zoom), f = void 0, b = {}), J = J.concat(Wi({ key: `${le}[0]`, value: ie[0], valueSpec: { zoom: {} }, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, objectElementValidators: { zoom: tl, value: U } }));
            } else J = J.concat(U({ key: `${le}[0]`, value: ie[0], validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }, ie));
            return ec(Mo(ie[1])) ? J.concat([new ye(`${le}[1]`, ie[1], "expressions are not allowed in function stops.")]) : J.concat(H.validateSpec({ key: `${le}[1]`, value: ie[1], valueSpec: t, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }));
          }
          function U(H, J) {
            const ie = Mr(H.value), le = yn(H.value), me = H.value !== null ? H.value : J;
            if (c) {
              if (ie !== c) return [new ye(H.key, me, `${ie} stop domain type must match previous stop domain type ${c}`)];
            } else c = ie;
            if (ie !== "number" && ie !== "string" && ie !== "boolean") return [new ye(H.key, me, "stop domain value must be a number, string, or boolean")];
            if (ie !== "number" && r !== "categorical") {
              let Oe = `number expected, ${ie} found`;
              return es(t) && r === void 0 && (Oe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ye(H.key, me, Oe)];
            }
            return r !== "categorical" || ie !== "number" || isFinite(le) && Math.floor(le) === le ? r !== "categorical" && ie === "number" && f !== void 0 && le < f ? [new ye(H.key, me, "stop domain values must appear in ascending order")] : (f = le, r === "categorical" && le in b ? [new ye(H.key, me, "stop domain values must be unique")] : (b[le] = true, [])) : [new ye(H.key, me, `integer expected, found ${le}`)];
          }
        }
        function Rs(n) {
          const t = (n.expressionContext === "property" ? mh : Ya)(Mo(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map(((c) => new ye(`${n.key}${c.key}`, n.value, c.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new ye(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !Ha(r)) return [new ye(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !Ha(r)) return [new ye(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!Ql(r, ["zoom", "feature-state"])) return [new ye(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !Jl(r)) return [new ye(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function oc(n) {
          const t = n.key, r = n.value, c = Mr(r);
          return c !== "string" ? [new ye(t, r, `color expected, ${c} found`)] : kr.parse(String(r)) ? [] : [new ye(t, r, `color expected, "${r}" found`)];
        }
        function Bo(n) {
          const t = n.key, r = n.value, c = n.valueSpec, f = [];
          return Array.isArray(c.values) ? c.values.indexOf(yn(r)) === -1 && f.push(new ye(t, r, `expected one of [${c.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(c.values).indexOf(yn(r)) === -1 && f.push(new ye(t, r, `expected one of [${Object.keys(c.values).join(", ")}], ${JSON.stringify(r)} found`)), f;
        }
        function Au(n) {
          return tc(Mo(n.value)) ? Rs(pt({}, n, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : _h(n);
        }
        function _h(n) {
          const t = n.value, r = n.key;
          if (Mr(t) !== "array") return [new ye(r, t, `array expected, ${Mr(t)} found`)];
          const c = n.styleSpec;
          let f, _ = [];
          if (t.length < 1) return [new ye(r, t, "filter array must have at least 1 element")];
          switch (_ = _.concat(Bo({ key: `${r}[0]`, value: t[0], valueSpec: c.filter_operator, style: n.style, styleSpec: n.styleSpec })), yn(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && yn(t[1]) === "$type" && _.push(new ye(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && _.push(new ye(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (f = Mr(t[1]), f !== "string" && _.push(new ye(`${r}[1]`, t[1], `string expected, ${f} found`)));
              for (let b = 2; b < t.length; b++) f = Mr(t[b]), yn(t[1]) === "$type" ? _ = _.concat(Bo({ key: `${r}[${b}]`, value: t[b], valueSpec: c.geometry_type, style: n.style, styleSpec: n.styleSpec })) : f !== "string" && f !== "number" && f !== "boolean" && _.push(new ye(`${r}[${b}]`, t[b], `string, number, or boolean expected, ${f} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let b = 1; b < t.length; b++) _ = _.concat(_h({ key: `${r}[${b}]`, value: t[b], style: n.style, styleSpec: n.styleSpec }));
              break;
            case "has":
            case "!has":
              f = Mr(t[1]), t.length !== 2 ? _.push(new ye(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : f !== "string" && _.push(new ye(`${r}[1]`, t[1], `string expected, ${f} found`));
          }
          return _;
        }
        function bh(n, t) {
          const r = n.key, c = n.validateSpec, f = n.style, _ = n.styleSpec, b = n.value, C = n.objectKey, P = _[`${t}_${n.layerType}`];
          if (!P) return [];
          const E = C.match(/^(.*)-transition$/);
          if (t === "paint" && E && P[E[1]] && P[E[1]].transition) return c({ key: r, value: b, valueSpec: _.transition, style: f, styleSpec: _ });
          const A = n.valueSpec || P[C];
          if (!A) return [new ye(r, b, `unknown property "${C}"`)];
          let B;
          if (Mr(b) === "string" && es(A) && !A.tokens && (B = /^{([^}]+)}$/.exec(b))) return [new ye(r, b, `"${C}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(B[1])} }\`.`)];
          const U = [];
          return n.layerType === "symbol" && (C === "text-field" && f && !f.glyphs && U.push(new ye(r, b, 'use of "text-field" requires a style "glyphs" property')), C === "text-font" && Xa(Mo(b)) && yn(b.type) === "identity" && U.push(new ye(r, b, '"text-font" does not support identity functions'))), U.concat(c({ key: n.key, value: b, valueSpec: A, style: f, styleSpec: _, expressionContext: "property", propertyType: t, propertyKey: C }));
        }
        function xh(n) {
          return bh(n, "paint");
        }
        function wh(n) {
          return bh(n, "layout");
        }
        function Ch(n) {
          let t = [];
          const r = n.value, c = n.key, f = n.style, _ = n.styleSpec;
          if (Mr(r) !== "object") return [new ye(c, r, `object expected, ${Mr(r)} found`)];
          r.type || r.ref || t.push(new ye(c, r, 'either "type" or "ref" is required'));
          let b = yn(r.type);
          const C = yn(r.ref);
          if (r.id) {
            const P = yn(r.id);
            for (let E = 0; E < n.arrayIndex; E++) {
              const A = f.layers[E];
              yn(A.id) === P && t.push(new ye(c, r.id, `duplicate layer id "${r.id}", previously used at line ${A.id.__line__}`));
            }
          }
          if ("ref" in r) {
            let P;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((E) => {
              E in r && t.push(new ye(c, r[E], `"${E}" is prohibited for ref layers`));
            })), f.layers.forEach(((E) => {
              yn(E.id) === C && (P = E);
            })), P ? P.ref ? t.push(new ye(c, r.ref, "ref cannot reference another ref layer")) : b = yn(P.type) : t.push(new ye(c, r.ref, `ref layer "${C}" not found`));
          } else if (b !== "background") if (r.source) {
            const P = f.sources && f.sources[r.source], E = P && yn(P.type);
            P ? E === "vector" && b === "raster" ? t.push(new ye(c, r.source, `layer "${r.id}" requires a raster source`)) : E !== "raster-dem" && b === "hillshade" || E !== "raster-dem" && b === "color-relief" ? t.push(new ye(c, r.source, `layer "${r.id}" requires a raster-dem source`)) : E === "raster" && b !== "raster" ? t.push(new ye(c, r.source, `layer "${r.id}" requires a vector source`)) : E !== "vector" || r["source-layer"] ? E === "raster-dem" && b !== "hillshade" && b !== "color-relief" ? t.push(new ye(c, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : b !== "line" || !r.paint || !r.paint["line-gradient"] || E === "geojson" && P.lineMetrics || t.push(new ye(c, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ye(c, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new ye(c, r.source, `source "${r.source}" not found`));
          } else t.push(new ye(c, r, 'missing required property "source"'));
          return t = t.concat(Wi({ key: c, value: r, valueSpec: _.layer, style: n.style, styleSpec: n.styleSpec, validateSpec: n.validateSpec, objectElementValidators: { "*": () => [], type: () => n.validateSpec({ key: `${c}.type`, value: r.type, valueSpec: _.layer.type, style: n.style, styleSpec: n.styleSpec, validateSpec: n.validateSpec, object: r, objectKey: "type" }), filter: Au, layout: (P) => Wi({ layer: r, key: P.key, value: P.value, style: P.style, styleSpec: P.styleSpec, validateSpec: P.validateSpec, objectElementValidators: { "*": (E) => wh(pt({ layerType: b }, E)) } }), paint: (P) => Wi({ layer: r, key: P.key, value: P.value, style: P.style, styleSpec: P.styleSpec, validateSpec: P.validateSpec, objectElementValidators: { "*": (E) => xh(pt({ layerType: b }, E)) } }) } })), t;
        }
        function ro(n) {
          const t = n.value, r = n.key, c = Mr(t);
          return c !== "string" ? [new ye(r, t, `string expected, ${c} found`)] : [];
        }
        const ea = { promoteId: function({ key: n, value: t }) {
          if (Mr(t) === "string") return ro({ key: n, value: t });
          {
            const r = [];
            for (const c in t) r.push(...ro({ key: `${n}.${c}`, value: t[c] }));
            return r;
          }
        } };
        function ki(n) {
          const t = n.value, r = n.key, c = n.styleSpec, f = n.style, _ = n.validateSpec;
          if (!t.type) return [new ye(r, t, '"type" is required')];
          const b = yn(t.type);
          let C;
          switch (b) {
            case "vector":
            case "raster":
              return C = Wi({ key: r, value: t, valueSpec: c[`source_${b.replace("-", "_")}`], style: n.style, styleSpec: c, objectElementValidators: ea, validateSpec: _ }), C;
            case "raster-dem":
              return C = (function(P) {
                var E;
                const A = (E = P.sourceName) !== null && E !== void 0 ? E : "", B = P.value, U = P.styleSpec, H = U.source_raster_dem, J = P.style;
                let ie = [];
                const le = Mr(B);
                if (B === void 0) return ie;
                if (le !== "object") return ie.push(new ye("source_raster_dem", B, `object expected, ${le} found`)), ie;
                const me = yn(B.encoding) === "custom", Oe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Se = P.value.encoding ? `"${P.value.encoding}"` : "Default";
                for (const Ee in B) !me && Oe.includes(Ee) ? ie.push(new ye(Ee, B[Ee], `In "${A}": "${Ee}" is only valid when "encoding" is set to "custom". ${Se} encoding found`)) : H[Ee] ? ie = ie.concat(P.validateSpec({ key: Ee, value: B[Ee], valueSpec: H[Ee], validateSpec: P.validateSpec, style: J, styleSpec: U })) : ie.push(new ye(Ee, B[Ee], `unknown property "${Ee}"`));
                return ie;
              })({ sourceName: r, value: t, style: n.style, styleSpec: c, validateSpec: _ }), C;
            case "geojson":
              if (C = Wi({ key: r, value: t, valueSpec: c.source_geojson, style: f, styleSpec: c, validateSpec: _, objectElementValidators: ea }), t.cluster) for (const P in t.clusterProperties) {
                const [E, A] = t.clusterProperties[P], B = typeof E == "string" ? [E, ["accumulated"], ["get", P]] : E;
                C.push(...Rs({ key: `${r}.${P}.map`, value: A, expressionContext: "cluster-map" })), C.push(...Rs({ key: `${r}.${P}.reduce`, value: B, expressionContext: "cluster-reduce" }));
              }
              return C;
            case "video":
              return Wi({ key: r, value: t, valueSpec: c.source_video, style: f, validateSpec: _, styleSpec: c });
            case "image":
              return Wi({ key: r, value: t, valueSpec: c.source_image, style: f, validateSpec: _, styleSpec: c });
            case "canvas":
              return [new ye(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Bo({ key: `${r}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function ta(n) {
          const t = n.value, r = n.styleSpec, c = r.light, f = n.style;
          let _ = [];
          const b = Mr(t);
          if (t === void 0) return _;
          if (b !== "object") return _ = _.concat([new ye("light", t, `object expected, ${b} found`)]), _;
          for (const C in t) {
            const P = C.match(/^(.*)-transition$/);
            _ = _.concat(P && c[P[1]] && c[P[1]].transition ? n.validateSpec({ key: C, value: t[C], valueSpec: r.transition, validateSpec: n.validateSpec, style: f, styleSpec: r }) : c[C] ? n.validateSpec({ key: C, value: t[C], valueSpec: c[C], validateSpec: n.validateSpec, style: f, styleSpec: r }) : [new ye(C, t[C], `unknown property "${C}"`)]);
          }
          return _;
        }
        function Du(n) {
          const t = n.value, r = n.styleSpec, c = r.sky, f = n.style, _ = Mr(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new ye("sky", t, `object expected, ${_} found`)];
          let b = [];
          for (const C in t) b = b.concat(c[C] ? n.validateSpec({ key: C, value: t[C], valueSpec: c[C], style: f, styleSpec: r }) : [new ye(C, t[C], `unknown property "${C}"`)]);
          return b;
        }
        function Sh(n) {
          const t = n.value, r = n.styleSpec, c = r.terrain, f = n.style;
          let _ = [];
          const b = Mr(t);
          if (t === void 0) return _;
          if (b !== "object") return _ = _.concat([new ye("terrain", t, `object expected, ${b} found`)]), _;
          for (const C in t) _ = _.concat(c[C] ? n.validateSpec({ key: C, value: t[C], valueSpec: c[C], validateSpec: n.validateSpec, style: f, styleSpec: r }) : [new ye(C, t[C], `unknown property "${C}"`)]);
          return _;
        }
        function kh(n) {
          let t = [];
          const r = n.value, c = n.key;
          if (Array.isArray(r)) {
            const f = [], _ = [];
            for (const b in r) r[b].id && f.includes(r[b].id) && t.push(new ye(c, r, `all the sprites' ids must be unique, but ${r[b].id} is duplicated`)), f.push(r[b].id), r[b].url && _.includes(r[b].url) && t.push(new ye(c, r, `all the sprites' URLs must be unique, but ${r[b].url} is duplicated`)), _.push(r[b].url), t = t.concat(Wi({ key: `${c}[${b}]`, value: r[b], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: n.validateSpec }));
            return t;
          }
          return ro({ key: c, value: r });
        }
        function ra(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new ye(n.key, n.value, `object expected, ${Mr(n.value)} found`)];
          var t;
        }
        const Fu = { "*": () => [], array: ic, boolean: function(n) {
          const t = n.value, r = n.key, c = Mr(t);
          return c !== "boolean" ? [new ye(r, t, `boolean expected, ${c} found`)] : [];
        }, number: tl, color: oc, constants: zu, enum: Bo, filter: Au, function: yh, layer: Ch, object: Wi, source: ki, light: ta, sky: Du, terrain: Sh, projection: function(n) {
          const t = n.value, r = n.styleSpec, c = r.projection, f = n.style, _ = Mr(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new ye("projection", t, `object expected, ${_} found`)];
          let b = [];
          for (const C in t) b = b.concat(c[C] ? n.validateSpec({ key: C, value: t[C], valueSpec: c[C], style: f, styleSpec: r }) : [new ye(C, t[C], `unknown property "${C}"`)]);
          return b;
        }, projectionDefinition: function(n) {
          const t = n.key;
          let r = n.value;
          r = r instanceof String ? r.valueOf() : r;
          const c = Mr(r);
          return c !== "array" || (function(f) {
            return Array.isArray(f) && f.length === 3 && typeof f[0] == "string" && typeof f[1] == "string" && typeof f[2] == "number";
          })(r) || (function(f) {
            return !!["interpolate", "step", "literal"].includes(f[0]);
          })(r) ? ["array", "string"].includes(c) ? [] : [new ye(t, r, `projection expected, invalid type "${c}" found`)] : [new ye(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)];
        }, string: ro, formatted: function(n) {
          return ro(n).length === 0 ? [] : Rs(n);
        }, resolvedImage: function(n) {
          return ro(n).length === 0 ? [] : Rs(n);
        }, padding: function(n) {
          const t = n.key, r = n.value;
          if (Mr(r) === "array") {
            if (r.length < 1 || r.length > 4) return [new ye(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
            const c = { type: "number" };
            let f = [];
            for (let _ = 0; _ < r.length; _++) f = f.concat(n.validateSpec({ key: `${t}[${_}]`, value: r[_], validateSpec: n.validateSpec, valueSpec: c }));
            return f;
          }
          return tl({ key: t, value: r, valueSpec: {} });
        }, numberArray: function(n) {
          const t = n.key, r = n.value;
          if (Mr(r) === "array") {
            const c = { type: "number" };
            if (r.length < 1) return [new ye(t, r, "array length at least 1 expected, length 0 found")];
            let f = [];
            for (let _ = 0; _ < r.length; _++) f = f.concat(n.validateSpec({ key: `${t}[${_}]`, value: r[_], validateSpec: n.validateSpec, valueSpec: c }));
            return f;
          }
          return tl({ key: t, value: r, valueSpec: {} });
        }, colorArray: function(n) {
          const t = n.key, r = n.value;
          if (Mr(r) === "array") {
            if (r.length < 1) return [new ye(t, r, "array length at least 1 expected, length 0 found")];
            let c = [];
            for (let f = 0; f < r.length; f++) c = c.concat(oc({ key: `${t}[${f}]`, value: r[f] }));
            return c;
          }
          return oc({ key: t, value: r });
        }, variableAnchorOffsetCollection: function(n) {
          const t = n.key, r = n.value, c = Mr(r), f = n.styleSpec;
          if (c !== "array" || r.length < 1 || r.length % 2 != 0) return [new ye(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let _ = [];
          for (let b = 0; b < r.length; b += 2) _ = _.concat(Bo({ key: `${t}[${b}]`, value: r[b], valueSpec: f.layout_symbol["text-anchor"] })), _ = _.concat(ic({ key: `${t}[${b + 1}]`, value: r[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: n.validateSpec, style: n.style, styleSpec: f }));
          return _;
        }, sprite: kh, state: ra };
        function na(n) {
          const t = n.value, r = n.valueSpec, c = n.styleSpec;
          return n.validateSpec = na, r.expression && Xa(yn(t)) ? yh(n) : r.expression && ec(Mo(t)) ? Rs(n) : r.type && Fu[r.type] ? Fu[r.type](n) : Wi(pt({}, n, { valueSpec: r.type ? c[r.type] : r }));
        }
        function Ph(n) {
          const t = n.value, r = n.key, c = ro(n);
          return c.length || (t.indexOf("{fontstack}") === -1 && c.push(new ye(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && c.push(new ye(r, t, '"glyphs" url must include a "{range}" token'))), c;
        }
        function Pi(n, t = Te) {
          let r = [];
          return r = r.concat(na({ key: "", value: n, valueSpec: t.$root, styleSpec: t, style: n, validateSpec: na, objectElementValidators: { glyphs: Ph, "*": () => [] } })), n.constants && (r = r.concat(zu({ key: "constants", value: n.constants }))), ia(r);
        }
        function no(n) {
          return function(t) {
            return n({ ...t, validateSpec: na });
          };
        }
        function ia(n) {
          return [].concat(n).sort(((t, r) => t.line - r.line));
        }
        function io(n) {
          return function(...t) {
            return ia(n.apply(this, t));
          };
        }
        Pi.source = io(no(ki)), Pi.sprite = io(no(kh)), Pi.glyphs = io(no(Ph)), Pi.light = io(no(ta)), Pi.sky = io(no(Du)), Pi.terrain = io(no(Sh)), Pi.state = io(no(ra)), Pi.layer = io(no(Ch)), Pi.filter = io(no(Au)), Pi.paintProperty = io(no(xh)), Pi.layoutProperty = io(no(wh));
        const oa = Pi, yf = oa.light, rl = oa.sky, _f = oa.paintProperty, bf = oa.layoutProperty;
        function nl(n, t) {
          let r = false;
          if (t && t.length) for (const c of t) n.fire(new Xe(new Error(c.message))), r = true;
          return r;
        }
        class il {
          constructor(t, r, c) {
            const f = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const b = new Int32Array(this.arrayBuffer);
              t = b[0], this.d = (r = b[1]) + 2 * (c = b[2]);
              for (let P = 0; P < this.d * this.d; P++) {
                const E = b[3 + P], A = b[3 + P + 1];
                f.push(E === A ? null : b.subarray(E, A));
              }
              const C = b[3 + f.length + 1];
              this.keys = b.subarray(b[3 + f.length], C), this.bboxes = b.subarray(C), this.insert = this._insertReadonly;
            } else {
              this.d = r + 2 * c;
              for (let b = 0; b < this.d * this.d; b++) f.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = r, this.extent = t, this.padding = c, this.scale = r / t, this.uid = 0;
            const _ = c / r * t;
            this.min = -_, this.max = t + _;
          }
          insert(t, r, c, f, _) {
            this._forEachCell(r, c, f, _, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(c), this.bboxes.push(f), this.bboxes.push(_);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, r, c, f, _, b) {
            this.cells[_].push(b);
          }
          query(t, r, c, f, _) {
            const b = this.min, C = this.max;
            if (t <= b && r <= b && C <= c && C <= f && !_) return Array.prototype.slice.call(this.keys);
            {
              const P = [];
              return this._forEachCell(t, r, c, f, this._queryCell, P, {}, _), P;
            }
          }
          _queryCell(t, r, c, f, _, b, C, P) {
            const E = this.cells[_];
            if (E !== null) {
              const A = this.keys, B = this.bboxes;
              for (let U = 0; U < E.length; U++) {
                const H = E[U];
                if (C[H] === void 0) {
                  const J = 4 * H;
                  (P ? P(B[J + 0], B[J + 1], B[J + 2], B[J + 3]) : t <= B[J + 2] && r <= B[J + 3] && c >= B[J + 0] && f >= B[J + 1]) ? (C[H] = true, b.push(A[H])) : C[H] = false;
                }
              }
            }
          }
          _forEachCell(t, r, c, f, _, b, C, P) {
            const E = this._convertToCellCoord(t), A = this._convertToCellCoord(r), B = this._convertToCellCoord(c), U = this._convertToCellCoord(f);
            for (let H = E; H <= B; H++) for (let J = A; J <= U; J++) {
              const ie = this.d * J + H;
              if ((!P || P(this._convertFromCellCoord(H), this._convertFromCellCoord(J), this._convertFromCellCoord(H + 1), this._convertFromCellCoord(J + 1))) && _.call(this, t, r, c, f, ie, b, C, P)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, r = 3 + this.cells.length + 1 + 1;
            let c = 0;
            for (let b = 0; b < this.cells.length; b++) c += this.cells[b].length;
            const f = new Int32Array(r + c + this.keys.length + this.bboxes.length);
            f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
            let _ = r;
            for (let b = 0; b < t.length; b++) {
              const C = t[b];
              f[3 + b] = _, f.set(C, _), _ += C.length;
            }
            return f[3 + t.length] = _, f.set(this.keys, _), _ += this.keys.length, f[3 + t.length + 1] = _, f.set(this.bboxes, _), _ += this.bboxes.length, f.buffer;
          }
          static serialize(t, r) {
            const c = t.toArrayBuffer();
            return r && r.push(c), { buffer: c };
          }
          static deserialize(t) {
            return new il(t.buffer);
          }
        }
        const oo = {};
        function Bt(n, t, r = {}) {
          if (oo[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: n, writeable: false }), oo[n] = { klass: t, omit: r.omit || [], shallow: r.shallow || [] };
        }
        Bt("Object", Object), Bt("Set", Set), Bt("TransferableGridIndex", il), Bt("Color", kr), Bt("Error", Error), Bt("AJAXError", be), Bt("ResolvedImage", Fi), Bt("StylePropertyFunction", Ja), Bt("StyleExpression", Pu, { omit: ["_evaluator"] }), Bt("ZoomDependentExpression", Tu), Bt("ZoomConstantExpression", Ka), Bt("CompoundExpression", Gi, { omit: ["_evaluate"] });
        for (const n in Js) Js[n]._classRegistryKey || Bt(`Expression_${n}`, Js[n]);
        function Lu(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer");
        }
        function sc(n) {
          return n.$name || n.constructor._classRegistryKey;
        }
        function Bu(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return false;
            const r = sc(t);
            return !(!r || r === "Object");
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || Lu(n) || We(n) || ArrayBuffer.isView(n) || n instanceof ImageData);
        }
        function sa(n, t) {
          if (Bu(n)) return (Lu(n) || We(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const _ = [];
            for (const b of n) _.push(sa(b, t));
            return _;
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const r = sc(n);
          if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!oo[r]) throw new Error(`${r} is not registered.`);
          const { klass: c } = oo[r], f = c.serialize ? c.serialize(n, t) : {};
          if (c.serialize) {
            if (t && f === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const _ in n) {
              if (!n.hasOwnProperty(_) || oo[r].omit.indexOf(_) >= 0) continue;
              const b = n[_];
              f[_] = oo[r].shallow.indexOf(_) >= 0 ? b : sa(b, t);
            }
            n instanceof Error && (f.message = n.message);
          }
          if (f.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (f.$name = r), f;
        }
        function zs(n) {
          if (Bu(n)) return n;
          if (Array.isArray(n)) return n.map(zs);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = sc(n) || "Object";
          if (!oo[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: r } = oo[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(n);
          const c = Object.create(r.prototype);
          for (const f of Object.keys(n)) {
            if (f === "$name") continue;
            const _ = n[f];
            c[f] = oo[t].shallow.indexOf(f) >= 0 ? _ : zs(_);
          }
          return c;
        }
        class ac {
          constructor() {
            this.first = true;
          }
          update(t, r) {
            const c = Math.floor(t);
            return this.first ? (this.first = false, this.lastIntegerZoom = c, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = c, true) : (this.lastFloorZoom > c ? (this.lastIntegerZoom = c + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < c && (this.lastIntegerZoom = c, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = c, true));
          }
        }
        const Er = { "Latin-1 Supplement": (n) => n >= 128 && n <= 255, "Hangul Jamo": (n) => n >= 4352 && n <= 4607, Khmer: (n) => n >= 6016 && n <= 6143, "General Punctuation": (n) => n >= 8192 && n <= 8303, "Letterlike Symbols": (n) => n >= 8448 && n <= 8527, "Number Forms": (n) => n >= 8528 && n <= 8591, "Miscellaneous Technical": (n) => n >= 8960 && n <= 9215, "Control Pictures": (n) => n >= 9216 && n <= 9279, "Optical Character Recognition": (n) => n >= 9280 && n <= 9311, "Enclosed Alphanumerics": (n) => n >= 9312 && n <= 9471, "Geometric Shapes": (n) => n >= 9632 && n <= 9727, "Miscellaneous Symbols": (n) => n >= 9728 && n <= 9983, "Miscellaneous Symbols and Arrows": (n) => n >= 11008 && n <= 11263, "Ideographic Description Characters": (n) => n >= 12272 && n <= 12287, "CJK Symbols and Punctuation": (n) => n >= 12288 && n <= 12351, Hiragana: (n) => n >= 12352 && n <= 12447, Katakana: (n) => n >= 12448 && n <= 12543, Kanbun: (n) => n >= 12688 && n <= 12703, "CJK Strokes": (n) => n >= 12736 && n <= 12783, "Enclosed CJK Letters and Months": (n) => n >= 12800 && n <= 13055, "CJK Compatibility": (n) => n >= 13056 && n <= 13311, "Yijing Hexagram Symbols": (n) => n >= 19904 && n <= 19967, "CJK Unified Ideographs": (n) => n >= 19968 && n <= 40959, "Hangul Syllables": (n) => n >= 44032 && n <= 55215, "Private Use Area": (n) => n >= 57344 && n <= 63743, "Vertical Forms": (n) => n >= 65040 && n <= 65055, "CJK Compatibility Forms": (n) => n >= 65072 && n <= 65103, "Small Form Variants": (n) => n >= 65104 && n <= 65135, "Halfwidth and Fullwidth Forms": (n) => n >= 65280 && n <= 65519 };
        function lc(n) {
          for (const t of n) if ($u(t.charCodeAt(0))) return true;
          return false;
        }
        function xf(n) {
          for (const t of n) if (!Th(t.charCodeAt(0))) return false;
          return true;
        }
        function cc(n) {
          const t = n.map(((r) => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((r) => r));
          return new RegExp(t.join("|"), "u");
        }
        const wf = cc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Th(n) {
          return !wf.test(String.fromCodePoint(n));
        }
        const Ou = cc(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function $u(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(Er["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || Er["CJK Compatibility"](n) || Er["CJK Strokes"](n) || !(!Er["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || Er["Enclosed CJK Letters and Months"](n) || Er["Ideographic Description Characters"](n) || Er.Kanbun(n) || Er.Katakana(n) && n !== 12540 || !(!Er["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!Er["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || Er["Vertical Forms"](n) || Er["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || Ou.test(String.fromCodePoint(n)))));
        }
        function Mh(n) {
          return !($u(n) || (function(t) {
            return !!(Er["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Er["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Er["Letterlike Symbols"](t) || Er["Number Forms"](t) || Er["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Er["Control Pictures"](t) && t !== 9251 || Er["Optical Character Recognition"](t) || Er["Enclosed Alphanumerics"](t) || Er["Geometric Shapes"](t) || Er["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Er["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Er["CJK Symbols and Punctuation"](t) || Er.Katakana(t) || Er["Private Use Area"](t) || Er["CJK Compatibility Forms"](t) || Er["Small Form Variants"](t) || Er["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(n));
        }
        const Ih = cc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function ju(n) {
          return Ih.test(String.fromCodePoint(n));
        }
        function Eh(n, t) {
          return !(!t && ju(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || Er.Khmer(n));
        }
        function Rh(n) {
          for (const t of n) if (ju(t.charCodeAt(0))) return true;
          return false;
        }
        const so = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(n) {
            if (so.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(n, t) {
            return o(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const r = n.pluginURL, c = new Promise(((_) => {
                this.loadScriptResolve = _;
              }));
              t(r);
              const f = new Promise(((_) => setTimeout((() => _()), this.TIMEOUT)));
              if (yield Promise.race([c, f]), this.isParsed()) {
                const _ = { pluginStatus: "loaded", pluginURL: r };
                return this.setState(_), _;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${r}`);
            }));
          }
        }();
        class rn {
          constructor(t, r) {
            this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new ac(), this.transition = r.transition || {}, this.globalState = r.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ac(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(t) {
            return (function(r, c) {
              for (const f of r) if (!Eh(f.charCodeAt(0), c)) return false;
              return true;
            })(t, so.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, r = t - Math.floor(t), c = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * c } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - c) * r };
          }
        }
        class aa {
          constructor(t, r) {
            this.property = t, this.value = r, this.expression = (function(c, f) {
              if (Xa(c)) return new Ja(c, f);
              if (ec(c)) {
                const _ = mh(c, f);
                if (_.result === "error") throw new Error(_.value.map(((b) => `${b.key}: ${b.message}`)).join(", "));
                return _.value;
              }
              {
                let _ = c;
                return f.type === "color" && typeof c == "string" ? _ = kr.parse(c) : f.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? f.type !== "numberArray" || typeof c != "number" && !Array.isArray(c) ? f.type !== "colorArray" || typeof c != "string" && !Array.isArray(c) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(c) ? _ = hi.parse(c) : f.type === "projectionDefinition" && typeof c == "string" && (_ = oi.parse(c)) : _ = Mn.parse(c) : _ = di.parse(c) : _ = Nn.parse(c), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => _ };
              }
            })(r === void 0 ? t.specification.default : r, t.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, r, c) {
            return this.property.possiblyEvaluate(this, t, r, c);
          }
        }
        class Nu {
          constructor(t) {
            this.property = t, this.value = new aa(t, void 0);
          }
          transitioned(t, r) {
            return new Vu(this.property, this.value, r, er({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new Vu(this.property, this.value, null, {}, 0);
          }
        }
        class zh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
          }
          getValue(t) {
            return rr(this._values[t].value.value);
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Nu(this._values[t].property)), this._values[t].value = new aa(this._values[t].property, r === null ? void 0 : rr(r));
          }
          getTransition(t) {
            return rr(this._values[t].transition);
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Nu(this._values[t].property)), this._values[t].transition = rr(r) || void 0;
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (t[r] = c);
              const f = this.getTransition(r);
              f !== void 0 && (t[`${r}-transition`] = f);
            }
            return t;
          }
          transitioned(t, r) {
            const c = new Uu(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].transitioned(t, r._values[f]);
            return c;
          }
          untransitioned() {
            const t = new Uu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t;
          }
        }
        class Vu {
          constructor(t, r, c, f, _) {
            this.property = t, this.value = r, this.begin = _ + f.delay || 0, this.end = this.begin + f.duration || 0, t.specification.transition && (f.delay || f.duration) && (this.prior = c);
          }
          possiblyEvaluate(t, r, c) {
            const f = t.now || 0, _ = this.value.possiblyEvaluate(t, r, c), b = this.prior;
            if (b) {
              if (f > this.end) return this.prior = null, _;
              if (this.value.isDataDriven()) return this.prior = null, _;
              if (f < this.begin) return b.possiblyEvaluate(t, r, c);
              {
                const C = (f - this.begin) / (this.end - this.begin);
                return this.property.interpolate(b.possiblyEvaluate(t, r, c), _, bt(C));
              }
            }
            return _;
          }
        }
        class Uu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, r, c) {
            const f = new uc(this._properties);
            for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].possiblyEvaluate(t, r, c);
            return f;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return true;
            return false;
          }
        }
        class Ah {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues);
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return rr(this._values[t].value);
          }
          setValue(t, r) {
            this._values[t] = new aa(this._values[t].property, r === null ? void 0 : rr(r));
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (t[r] = c);
            }
            return t;
          }
          possiblyEvaluate(t, r, c) {
            const f = new uc(this._properties);
            for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].possiblyEvaluate(t, r, c);
            return f;
          }
        }
        class Io {
          constructor(t, r, c) {
            this.property = t, this.value = r, this.parameters = c;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, r, c, f) {
            return this.property.evaluate(this.value, this.parameters, t, r, c, f);
          }
        }
        class uc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Xt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r);
          }
          interpolate(t, r, c) {
            const f = To[this.specification.type];
            return f ? f(t, r, c) : t;
          }
        }
        class sr {
          constructor(t, r) {
            this.specification = t, this.overrides = r;
          }
          possiblyEvaluate(t, r, c, f) {
            return new Io(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(r, null, {}, c, f) } : t.expression, r);
          }
          interpolate(t, r, c) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Io(this, { kind: "constant", value: void 0 }, t.parameters);
            const f = To[this.specification.type];
            if (f) {
              const _ = f(t.value.value, r.value.value, c);
              return new Io(this, { kind: "constant", value: _ }, t.parameters);
            }
            return t;
          }
          evaluate(t, r, c, f, _, b) {
            return t.kind === "constant" ? t.value : t.evaluate(r, c, f, _, b);
          }
        }
        class dc extends sr {
          possiblyEvaluate(t, r, c, f) {
            if (t.value === void 0) return new Io(this, { kind: "constant", value: void 0 }, r);
            if (t.expression.kind === "constant") {
              const _ = t.expression.evaluate(r, null, {}, c, f), b = t.property.specification.type === "resolvedImage" && typeof _ != "string" ? _.name : _, C = this._calculate(b, b, b, r);
              return new Io(this, { kind: "constant", value: C }, r);
            }
            if (t.expression.kind === "camera") {
              const _ = this._calculate(t.expression.evaluate({ zoom: r.zoom - 1 }), t.expression.evaluate({ zoom: r.zoom }), t.expression.evaluate({ zoom: r.zoom + 1 }), r);
              return new Io(this, { kind: "constant", value: _ }, r);
            }
            return new Io(this, t.expression, r);
          }
          evaluate(t, r, c, f, _, b) {
            if (t.kind === "source") {
              const C = t.evaluate(r, c, f, _, b);
              return this._calculate(C, C, C, r);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(r.zoom) - 1 }, c, f), t.evaluate({ zoom: Math.floor(r.zoom) }, c, f), t.evaluate({ zoom: Math.floor(r.zoom) + 1 }, c, f), r) : t.value;
          }
          _calculate(t, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: r } : { from: c, to: r };
          }
          interpolate(t) {
            return t;
          }
        }
        class rs {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, r, c, f) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const _ = t.expression.evaluate(r, null, {}, c, f);
                return this._calculate(_, _, _, r);
              }
              return this._calculate(t.expression.evaluate(new rn(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new rn(Math.floor(r.zoom), r)), t.expression.evaluate(new rn(Math.floor(r.zoom + 1), r)), r);
            }
          }
          _calculate(t, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: r } : { from: c, to: r };
          }
          interpolate(t) {
            return t;
          }
        }
        class hc {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, r, c, f) {
            return !!t.expression.evaluate(r, null, {}, c, f);
          }
          interpolate() {
            return false;
          }
        }
        class pi {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const c = t[r];
              c.specification.overridable && this.overridableProperties.push(r);
              const f = this.defaultPropertyValues[r] = new aa(c, void 0), _ = this.defaultTransitionablePropertyValues[r] = new Nu(c);
              this.defaultTransitioningPropertyValues[r] = _.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = f.possiblyEvaluate({});
            }
          }
        }
        Bt("DataDrivenProperty", sr), Bt("DataConstantProperty", Xt), Bt("CrossFadedDataDrivenProperty", dc), Bt("CrossFadedProperty", rs), Bt("ColorRampProperty", hc);
        const Dh = "-transition";
        class Zi extends wt {
          constructor(t, r) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Is(t.filter)), r.layout && (this._unevaluatedLayout = new Ah(r.layout)), r.paint)) {
              this._transitionablePaint = new zh(r.paint);
              for (const c in t.paint) this.setPaintProperty(c, t.paint[c], { validate: false });
              for (const c in t.layout) this.setLayoutProperty(c, t.layout[c], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new uc(r.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Is(t);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const r in this._unevaluatedLayout._values) {
              const c = this._unevaluatedLayout._values[r];
              for (const f of c.getGlobalStateRefs()) t.add(f);
            }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const r = new globalThis.Map();
            if (this._transitionablePaint) for (const c in this._transitionablePaint._values) {
              const f = this._transitionablePaint._values[c].value;
              for (const _ of f.getGlobalStateRefs()) {
                const b = (t = r.get(_)) !== null && t !== void 0 ? t : [];
                b.push({ name: c, value: f.value }), r.set(_, b);
              }
            }
            return r;
          }
          setLayoutProperty(t, r, c = {}) {
            r != null && this._validate(bf, `layers.${this.id}.layout.${t}`, t, r, c) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r);
          }
          getPaintProperty(t) {
            return t.endsWith(Dh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, r, c = {}) {
            if (r != null && this._validate(_f, `layers.${this.id}.paint.${t}`, t, r, c)) return false;
            if (t.endsWith(Dh)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), false;
            {
              const f = this._transitionablePaint._values[t], _ = f.property.specification["property-type"] === "cross-faded-data-driven", b = f.value.isDataDriven(), C = f.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const P = this._transitionablePaint._values[t].value;
              return P.isDataDriven() || b || _ || this._handleOverridablePaintPropertyUpdate(t, C, P);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, r, c) {
            return false;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), zr(t, ((r, c) => !(r === void 0 || c === "layout" && !Object.keys(r).length || c === "paint" && !Object.keys(r).length)));
          }
          _validate(t, r, c, f, _ = {}) {
            return (!_ || _.validate !== false) && nl(this, t.call(oa, { key: r, layerType: this.type, objectKey: c, value: f, styleSpec: Te, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Io && es(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const Cf = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class ol {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Yr {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = true, r.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Cn(n, t = 1) {
          let r = 0, c = 0;
          return { members: n.map(((f) => {
            const _ = Cf[f.type].BYTES_PER_ELEMENT, b = r = pc(r, Math.max(t, _)), C = f.components || 1;
            return c = Math.max(c, _), r += _ * C, { name: f.name, type: f.type, components: C, offset: b };
          })), size: pc(r, Math.max(c, t)), alignment: t };
        }
        function pc(n, t) {
          return Math.ceil(n / t) * t;
        }
        class la extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r);
          }
          emplace(t, r, c) {
            const f = 2 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = c, t;
          }
        }
        la.prototype.bytesPerElement = 4, Bt("StructArrayLayout2i4", la);
        class ca extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, c);
          }
          emplace(t, r, c, f) {
            const _ = 3 * t;
            return this.int16[_ + 0] = r, this.int16[_ + 1] = c, this.int16[_ + 2] = f, t;
          }
        }
        ca.prototype.bytesPerElement = 6, Bt("StructArrayLayout3i6", ca);
        class qu extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, c, f);
          }
          emplace(t, r, c, f, _) {
            const b = 4 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = c, this.int16[b + 2] = f, this.int16[b + 3] = _, t;
          }
        }
        qu.prototype.bytesPerElement = 8, Bt("StructArrayLayout4i8", qu);
        class ua extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, c, f, _, b);
          }
          emplace(t, r, c, f, _, b, C) {
            const P = 6 * t;
            return this.int16[P + 0] = r, this.int16[P + 1] = c, this.int16[P + 2] = f, this.int16[P + 3] = _, this.int16[P + 4] = b, this.int16[P + 5] = C, t;
          }
        }
        ua.prototype.bytesPerElement = 12, Bt("StructArrayLayout2i4i12", ua);
        class As extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, c, f, _, b);
          }
          emplace(t, r, c, f, _, b, C) {
            const P = 4 * t, E = 8 * t;
            return this.int16[P + 0] = r, this.int16[P + 1] = c, this.uint8[E + 4] = f, this.uint8[E + 5] = _, this.uint8[E + 6] = b, this.uint8[E + 7] = C, t;
          }
        }
        As.prototype.bytesPerElement = 8, Bt("StructArrayLayout2i4ub8", As);
        class sl extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r);
          }
          emplace(t, r, c) {
            const f = 2 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = c, t;
          }
        }
        sl.prototype.bytesPerElement = 8, Bt("StructArrayLayout2f8", sl);
        class fc extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b, C, P, E, A) {
            const B = this.length;
            return this.resize(B + 1), this.emplace(B, t, r, c, f, _, b, C, P, E, A);
          }
          emplace(t, r, c, f, _, b, C, P, E, A, B) {
            const U = 10 * t;
            return this.uint16[U + 0] = r, this.uint16[U + 1] = c, this.uint16[U + 2] = f, this.uint16[U + 3] = _, this.uint16[U + 4] = b, this.uint16[U + 5] = C, this.uint16[U + 6] = P, this.uint16[U + 7] = E, this.uint16[U + 8] = A, this.uint16[U + 9] = B, t;
          }
        }
        fc.prototype.bytesPerElement = 20, Bt("StructArrayLayout10ui20", fc);
        class Ds extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b, C, P, E, A, B, U) {
            const H = this.length;
            return this.resize(H + 1), this.emplace(H, t, r, c, f, _, b, C, P, E, A, B, U);
          }
          emplace(t, r, c, f, _, b, C, P, E, A, B, U, H) {
            const J = 12 * t;
            return this.int16[J + 0] = r, this.int16[J + 1] = c, this.int16[J + 2] = f, this.int16[J + 3] = _, this.uint16[J + 4] = b, this.uint16[J + 5] = C, this.uint16[J + 6] = P, this.uint16[J + 7] = E, this.int16[J + 8] = A, this.int16[J + 9] = B, this.int16[J + 10] = U, this.int16[J + 11] = H, t;
          }
        }
        Ds.prototype.bytesPerElement = 24, Bt("StructArrayLayout4i4ui4i24", Ds);
        class Gu extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, c);
          }
          emplace(t, r, c, f) {
            const _ = 3 * t;
            return this.float32[_ + 0] = r, this.float32[_ + 1] = c, this.float32[_ + 2] = f, t;
          }
        }
        Gu.prototype.bytesPerElement = 12, Bt("StructArrayLayout3f12", Gu);
        class Wu extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t);
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t;
          }
        }
        Wu.prototype.bytesPerElement = 4, Bt("StructArrayLayout1ul4", Wu);
        class mc extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b, C, P, E) {
            const A = this.length;
            return this.resize(A + 1), this.emplace(A, t, r, c, f, _, b, C, P, E);
          }
          emplace(t, r, c, f, _, b, C, P, E, A) {
            const B = 10 * t, U = 5 * t;
            return this.int16[B + 0] = r, this.int16[B + 1] = c, this.int16[B + 2] = f, this.int16[B + 3] = _, this.int16[B + 4] = b, this.int16[B + 5] = C, this.uint32[U + 3] = P, this.uint16[B + 8] = E, this.uint16[B + 9] = A, t;
          }
        }
        mc.prototype.bytesPerElement = 20, Bt("StructArrayLayout6i1ul2ui20", mc);
        class Zu extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, c, f, _, b);
          }
          emplace(t, r, c, f, _, b, C) {
            const P = 6 * t;
            return this.int16[P + 0] = r, this.int16[P + 1] = c, this.int16[P + 2] = f, this.int16[P + 3] = _, this.int16[P + 4] = b, this.int16[P + 5] = C, t;
          }
        }
        Zu.prototype.bytesPerElement = 12, Bt("StructArrayLayout2i2i2i12", Zu);
        class v extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, r, c, f, _);
          }
          emplace(t, r, c, f, _, b) {
            const C = 4 * t, P = 8 * t;
            return this.float32[C + 0] = r, this.float32[C + 1] = c, this.float32[C + 2] = f, this.int16[P + 6] = _, this.int16[P + 7] = b, t;
          }
        }
        v.prototype.bytesPerElement = 16, Bt("StructArrayLayout2f1f2i16", v);
        class e extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, c, f, _, b);
          }
          emplace(t, r, c, f, _, b, C) {
            const P = 16 * t, E = 4 * t, A = 8 * t;
            return this.uint8[P + 0] = r, this.uint8[P + 1] = c, this.float32[E + 1] = f, this.float32[E + 2] = _, this.int16[A + 6] = b, this.int16[A + 7] = C, t;
          }
        }
        e.prototype.bytesPerElement = 16, Bt("StructArrayLayout2ub2f2i16", e);
        class s extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, c);
          }
          emplace(t, r, c, f) {
            const _ = 3 * t;
            return this.uint16[_ + 0] = r, this.uint16[_ + 1] = c, this.uint16[_ + 2] = f, t;
          }
        }
        s.prototype.bytesPerElement = 6, Bt("StructArrayLayout3ui6", s);
        class u extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me) {
            const Oe = this.length;
            return this.resize(Oe + 1), this.emplace(Oe, t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me);
          }
          emplace(t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me, Oe) {
            const Se = 24 * t, Ee = 12 * t, He = 48 * t;
            return this.int16[Se + 0] = r, this.int16[Se + 1] = c, this.uint16[Se + 2] = f, this.uint16[Se + 3] = _, this.uint32[Ee + 2] = b, this.uint32[Ee + 3] = C, this.uint32[Ee + 4] = P, this.uint16[Se + 10] = E, this.uint16[Se + 11] = A, this.uint16[Se + 12] = B, this.float32[Ee + 7] = U, this.float32[Ee + 8] = H, this.uint8[He + 36] = J, this.uint8[He + 37] = ie, this.uint8[He + 38] = le, this.uint32[Ee + 10] = me, this.int16[Se + 22] = Oe, t;
          }
        }
        u.prototype.bytesPerElement = 48, Bt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", u);
        class m extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me, Oe, Se, Ee, He, rt, _t, Ft, Mt, zt, Jt, Rt) {
            const At = this.length;
            return this.resize(At + 1), this.emplace(At, t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me, Oe, Se, Ee, He, rt, _t, Ft, Mt, zt, Jt, Rt);
          }
          emplace(t, r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me, Oe, Se, Ee, He, rt, _t, Ft, Mt, zt, Jt, Rt, At) {
            const dt = 32 * t, cr = 16 * t;
            return this.int16[dt + 0] = r, this.int16[dt + 1] = c, this.int16[dt + 2] = f, this.int16[dt + 3] = _, this.int16[dt + 4] = b, this.int16[dt + 5] = C, this.int16[dt + 6] = P, this.int16[dt + 7] = E, this.uint16[dt + 8] = A, this.uint16[dt + 9] = B, this.uint16[dt + 10] = U, this.uint16[dt + 11] = H, this.uint16[dt + 12] = J, this.uint16[dt + 13] = ie, this.uint16[dt + 14] = le, this.uint16[dt + 15] = me, this.uint16[dt + 16] = Oe, this.uint16[dt + 17] = Se, this.uint16[dt + 18] = Ee, this.uint16[dt + 19] = He, this.uint16[dt + 20] = rt, this.uint16[dt + 21] = _t, this.uint16[dt + 22] = Ft, this.uint32[cr + 12] = Mt, this.float32[cr + 13] = zt, this.float32[cr + 14] = Jt, this.uint16[dt + 30] = Rt, this.uint16[dt + 31] = At, t;
          }
        }
        m.prototype.bytesPerElement = 64, Bt("StructArrayLayout8i15ui1ul2f2ui64", m);
        class y extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t);
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t;
          }
        }
        y.prototype.bytesPerElement = 4, Bt("StructArrayLayout1f4", y);
        class x extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, c);
          }
          emplace(t, r, c, f) {
            const _ = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[_ + 1] = c, this.float32[_ + 2] = f, t;
          }
        }
        x.prototype.bytesPerElement = 12, Bt("StructArrayLayout1ui2f12", x);
        class T extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, c);
          }
          emplace(t, r, c, f) {
            const _ = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[_ + 2] = c, this.uint16[_ + 3] = f, t;
          }
        }
        T.prototype.bytesPerElement = 8, Bt("StructArrayLayout1ul2ui8", T);
        class M extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r);
          }
          emplace(t, r, c) {
            const f = 2 * t;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = c, t;
          }
        }
        M.prototype.bytesPerElement = 4, Bt("StructArrayLayout2ui4", M);
        class D extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t);
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t;
          }
        }
        D.prototype.bytesPerElement = 2, Bt("StructArrayLayout1ui2", D);
        class F extends Yr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, r, c, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, c, f);
          }
          emplace(t, r, c, f, _) {
            const b = 4 * t;
            return this.float32[b + 0] = r, this.float32[b + 1] = c, this.float32[b + 2] = f, this.float32[b + 3] = _, t;
          }
        }
        F.prototype.bytesPerElement = 16, Bt("StructArrayLayout4f16", F);
        class j extends ol {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new w(this.anchorPointX, this.anchorPointY);
          }
        }
        j.prototype.size = 20;
        class $ extends mc {
          get(t) {
            return new j(this, t);
          }
        }
        Bt("CollisionBoxArray", $);
        class G extends ol {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        G.prototype.size = 48;
        class ee extends u {
          get(t) {
            return new G(this, t);
          }
        }
        Bt("PlacedSymbolArray", ee);
        class ue extends ol {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        ue.prototype.size = 64;
        class ce extends m {
          get(t) {
            return new ue(this, t);
          }
        }
        Bt("SymbolInstanceArray", ce);
        class pe extends y {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Bt("GlyphOffsetArray", pe);
        class ge extends ca {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Bt("SymbolLineVertexArray", ge);
        class Ce extends ol {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Ce.prototype.size = 12;
        class xe extends x {
          get(t) {
            return new Ce(this, t);
          }
        }
        Bt("TextAnchorOffsetArray", xe);
        class ke extends ol {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ke.prototype.size = 8;
        class ze extends T {
          get(t) {
            return new ke(this, t);
          }
        }
        Bt("FeatureIndexArray", ze);
        class we extends la {
        }
        class je extends la {
        }
        class Qe extends la {
        }
        class qe extends ua {
        }
        class Ze extends As {
        }
        class Je extends sl {
        }
        class Tt extends fc {
        }
        class It extends Ds {
        }
        class ft extends Gu {
        }
        class Zt extends Wu {
        }
        class xr extends Zu {
        }
        class $r extends e {
        }
        class Kr extends s {
        }
        class Wr extends M {
        }
        const fn = Cn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: _n } = fn;
        class br {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t;
          }
          prepareSegment(t, r, c, f) {
            const _ = this.segments[this.segments.length - 1];
            return t > br.MAX_VERTEX_ARRAY_LENGTH && Ct(`Max vertices per segment is ${br.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${br.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !_ || _.vertexLength + t > br.MAX_VERTEX_ARRAY_LENGTH || _.sortKey !== f ? this.createNewSegment(r, c, f) : _;
          }
          createNewSegment(t, r, c) {
            const f = { vertexOffset: t.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return c !== void 0 && (f.sortKey = c), this._forceNewSegmentOnNextPrepare = false, this.segments.push(f), f;
          }
          getOrCreateLatestSegment(t, r, c) {
            return this.prepareSegment(0, t, r, c);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const r in t.vaos) t.vaos[r].destroy();
          }
          static simpleSegment(t, r, c, f) {
            return new br([{ vertexOffset: t, primitiveOffset: r, vertexLength: c, primitiveLength: f, vaos: {}, sortKey: 0 }]);
          }
        }
        function Jr(n, t) {
          return 256 * (n = vt(Math.floor(n), 0, 255)) + vt(Math.floor(t), 0, 255);
        }
        br.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Bt("SegmentVector", br);
        const In = Cn([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Fn, Un, fi, ao = { exports: {} }, ns = { exports: {} }, is = { exports: {} }, da = (function() {
          if (fi) return ao.exports;
          fi = 1;
          var n = (Fn || (Fn = 1, ns.exports = function(r, c) {
            var f, _, b, C, P, E, A, B;
            for (_ = r.length - (f = 3 & r.length), b = c, P = 3432918353, E = 461845907, B = 0; B < _; ) A = 255 & r.charCodeAt(B) | (255 & r.charCodeAt(++B)) << 8 | (255 & r.charCodeAt(++B)) << 16 | (255 & r.charCodeAt(++B)) << 24, ++B, b = 27492 + (65535 & (C = 5 * (65535 & (b = (b ^= A = (65535 & (A = (A = (65535 & A) * P + (((A >>> 16) * P & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * E + (((A >>> 16) * E & 65535) << 16) & 4294967295) << 13 | b >>> 19)) + ((5 * (b >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (C >>> 16) & 65535) << 16);
            switch (A = 0, f) {
              case 3:
                A ^= (255 & r.charCodeAt(B + 2)) << 16;
              case 2:
                A ^= (255 & r.charCodeAt(B + 1)) << 8;
              case 1:
                b ^= A = (65535 & (A = (A = (65535 & (A ^= 255 & r.charCodeAt(B))) * P + (((A >>> 16) * P & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * E + (((A >>> 16) * E & 65535) << 16) & 4294967295;
            }
            return b ^= r.length, b = 2246822507 * (65535 & (b ^= b >>> 16)) + ((2246822507 * (b >>> 16) & 65535) << 16) & 4294967295, b = 3266489909 * (65535 & (b ^= b >>> 13)) + ((3266489909 * (b >>> 16) & 65535) << 16) & 4294967295, (b ^= b >>> 16) >>> 0;
          }), ns.exports), t = (Un || (Un = 1, is.exports = function(r, c) {
            for (var f, _ = r.length, b = c ^ _, C = 0; _ >= 4; ) f = 1540483477 * (65535 & (f = 255 & r.charCodeAt(C) | (255 & r.charCodeAt(++C)) << 8 | (255 & r.charCodeAt(++C)) << 16 | (255 & r.charCodeAt(++C)) << 24)) + ((1540483477 * (f >>> 16) & 65535) << 16), b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16) ^ (f = 1540483477 * (65535 & (f ^= f >>> 24)) + ((1540483477 * (f >>> 16) & 65535) << 16)), _ -= 4, ++C;
            switch (_) {
              case 3:
                b ^= (255 & r.charCodeAt(C + 2)) << 16;
              case 2:
                b ^= (255 & r.charCodeAt(C + 1)) << 8;
              case 1:
                b = 1540483477 * (65535 & (b ^= 255 & r.charCodeAt(C))) + ((1540483477 * (b >>> 16) & 65535) << 16);
            }
            return b = 1540483477 * (65535 & (b ^= b >>> 13)) + ((1540483477 * (b >>> 16) & 65535) << 16), (b ^= b >>> 15) >>> 0;
          }), is.exports);
          return ao.exports = n, ao.exports.murmur3 = n, ao.exports.murmur2 = t, ao.exports;
        })(), ha = S(da);
        class Fs {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t, r, c, f) {
            this.ids.push(Ls(t)), this.positions.push(r, c, f);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Ls(t);
            let c = 0, f = this.ids.length - 1;
            for (; c < f; ) {
              const b = c + f >> 1;
              this.ids[b] >= r ? f = b : c = b + 1;
            }
            const _ = [];
            for (; this.ids[c] === r; ) _.push({ index: this.positions[3 * c], start: this.positions[3 * c + 1], end: this.positions[3 * c + 2] }), c++;
            return _;
          }
          static serialize(t, r) {
            const c = new Float64Array(t.ids), f = new Uint32Array(t.positions);
            return Ti(c, f, 0, c.length - 1), r && r.push(c.buffer, f.buffer), { ids: c, positions: f };
          }
          static deserialize(t) {
            const r = new Fs();
            return r.ids = t.ids, r.positions = t.positions, r.indexed = true, r;
          }
        }
        function Ls(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ha(String(n));
        }
        function Ti(n, t, r, c) {
          for (; r < c; ) {
            const f = n[r + c >> 1];
            let _ = r - 1, b = c + 1;
            for (; ; ) {
              do
                _++;
              while (n[_] < f);
              do
                b--;
              while (n[b] > f);
              if (_ >= b) break;
              lo(n, _, b), lo(t, 3 * _, 3 * b), lo(t, 3 * _ + 1, 3 * b + 1), lo(t, 3 * _ + 2, 3 * b + 2);
            }
            b - r < c - b ? (Ti(n, t, r, b), r = b + 1) : (Ti(n, t, b + 1, c), c = b);
          }
        }
        function lo(n, t, r) {
          const c = n[t];
          n[t] = n[r], n[r] = c;
        }
        Bt("FeaturePositionMap", Fs);
        class mi {
          constructor(t, r) {
            this.gl = t.gl, this.location = r;
          }
        }
        class os extends mi {
          constructor(t, r) {
            super(t, r), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class En extends mi {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class Ln extends mi {
          constructor(t, r) {
            super(t, r), this.current = kr.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Hi = new Float32Array(16);
        function Rn(n) {
          return [Jr(255 * n.r, 255 * n.g), Jr(255 * n.b, 255 * n.a)];
        }
        class al {
          constructor(t, r, c) {
            this.value = t, this.uniformNames = r.map(((f) => `u_${f}`)), this.type = c;
          }
          setUniform(t, r, c) {
            t.set(c.constantOr(this.value));
          }
          getBinding(t, r, c) {
            return this.type === "color" ? new Ln(t, r) : new os(t, r);
          }
        }
        class pa {
          constructor(t, r) {
            this.uniformNames = r.map(((c) => `u_${c}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, r, c, f) {
            const _ = f === "u_pattern_to" ? this.patternTo : f === "u_pattern_from" ? this.patternFrom : f === "u_pixel_ratio_to" ? this.pixelRatioTo : f === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            _ && t.set(_);
          }
          getBinding(t, r, c) {
            return c.substr(0, 9) === "u_pattern" ? new En(t, r) : new os(t, r);
          }
        }
        class Oo {
          constructor(t, r, c, f) {
            this.expression = t, this.type = c, this.maxValue = 0, this.paintVertexAttributes = r.map(((_) => ({ name: `a_${_}`, type: "Float32", components: c === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new f();
          }
          populatePaintArray(t, r, c) {
            const f = this.paintVertexArray.length, _ = this.expression.evaluate(new rn(0, c), r, {}, c.canonical, [], c.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, _);
          }
          updatePaintArray(t, r, c, f, _) {
            const b = this.expression.evaluate(new rn(0, _), c, f);
            this._setPaintValue(t, r, b);
          }
          _setPaintValue(t, r, c) {
            if (this.type === "color") {
              const f = Rn(c);
              for (let _ = t; _ < r; _++) this.paintVertexArray.emplace(_, f[0], f[1]);
            } else {
              for (let f = t; f < r; f++) this.paintVertexArray.emplace(f, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(c));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class co {
          constructor(t, r, c, f, _, b) {
            this.expression = t, this.uniformNames = r.map(((C) => `u_${C}_t`)), this.type = c, this.useIntegerZoom = f, this.zoom = _, this.maxValue = 0, this.paintVertexAttributes = r.map(((C) => ({ name: `a_${C}`, type: "Float32", components: c === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new b();
          }
          populatePaintArray(t, r, c) {
            const f = this.expression.evaluate(new rn(this.zoom, c), r, {}, c.canonical, [], c.formattedSection), _ = this.expression.evaluate(new rn(this.zoom + 1, c), r, {}, c.canonical, [], c.formattedSection), b = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(b, t, f, _);
          }
          updatePaintArray(t, r, c, f, _) {
            const b = this.expression.evaluate(new rn(this.zoom, _), c, f), C = this.expression.evaluate(new rn(this.zoom + 1, _), c, f);
            this._setPaintValue(t, r, b, C);
          }
          _setPaintValue(t, r, c, f) {
            if (this.type === "color") {
              const _ = Rn(c), b = Rn(f);
              for (let C = t; C < r; C++) this.paintVertexArray.emplace(C, _[0], _[1], b[0], b[1]);
            } else {
              for (let _ = t; _ < r; _++) this.paintVertexArray.emplace(_, c, f);
              this.maxValue = Math.max(this.maxValue, Math.abs(c), Math.abs(f));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, r) {
            const c = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, f = vt(this.expression.interpolationFactor(c, this.zoom, this.zoom + 1), 0, 1);
            t.set(f);
          }
          getBinding(t, r, c) {
            return new os(t, r);
          }
        }
        class ss {
          constructor(t, r, c, f, _, b) {
            this.expression = t, this.type = r, this.useIntegerZoom = c, this.zoom = f, this.layerId = b, this.zoomInPaintVertexArray = new _(), this.zoomOutPaintVertexArray = new _();
          }
          populatePaintArray(t, r, c) {
            const f = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(f, t, r.patterns && r.patterns[this.layerId], c.imagePositions);
          }
          updatePaintArray(t, r, c, f, _) {
            this._setPaintValues(t, r, c.patterns && c.patterns[this.layerId], _.imagePositions);
          }
          _setPaintValues(t, r, c, f) {
            if (!f || !c) return;
            const { min: _, mid: b, max: C } = c, P = f[_], E = f[b], A = f[C];
            if (P && E && A) for (let B = t; B < r; B++) this.zoomInPaintVertexArray.emplace(B, E.tl[0], E.tl[1], E.br[0], E.br[1], P.tl[0], P.tl[1], P.br[0], P.br[1], E.pixelRatio, P.pixelRatio), this.zoomOutPaintVertexArray.emplace(B, E.tl[0], E.tl[1], E.br[0], E.br[1], A.tl[0], A.tl[1], A.br[0], A.br[1], E.pixelRatio, A.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, In.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, In.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Fh {
          constructor(t, r, c) {
            this.binders = {}, this._buffers = [];
            const f = [];
            for (const _ in t.paint._values) {
              if (!c(_)) continue;
              const b = t.paint.get(_);
              if (!(b instanceof Io && es(b.property.specification))) continue;
              const C = Lh(_, t.type), P = b.value, E = b.property.specification.type, A = b.property.useIntegerZoom, B = b.property.specification["property-type"], U = B === "cross-faded" || B === "cross-faded-data-driven";
              if (P.kind === "constant") this.binders[_] = U ? new pa(P.value, C) : new al(P.value, C, E), f.push(`/u_${_}`);
              else if (P.kind === "source" || U) {
                const H = Hu(_, E, "source");
                this.binders[_] = U ? new ss(P, E, A, r, H, t.id) : new Oo(P, C, E, H), f.push(`/a_${_}`);
              } else {
                const H = Hu(_, E, "composite");
                this.binders[_] = new co(P, C, E, A, r, H), f.push(`/z_${_}`);
              }
            }
            this.cacheKey = f.sort().join("");
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof Oo || r instanceof co ? r.maxValue : 0;
          }
          populatePaintArrays(t, r, c) {
            for (const f in this.binders) {
              const _ = this.binders[f];
              (_ instanceof Oo || _ instanceof co || _ instanceof ss) && _.populatePaintArray(t, r, c);
            }
          }
          setConstantPatternPositions(t, r) {
            for (const c in this.binders) {
              const f = this.binders[c];
              f instanceof pa && f.setConstantPatternPositions(t, r);
            }
          }
          updatePaintArrays(t, r, c, f, _) {
            let b = false;
            for (const C in t) {
              const P = r.getPositions(C);
              for (const E of P) {
                const A = c.feature(E.index);
                for (const B in this.binders) {
                  const U = this.binders[B];
                  if ((U instanceof Oo || U instanceof co || U instanceof ss) && U.expression.isStateDependent === true) {
                    const H = f.paint.get(B);
                    U.expression = H.value, U.updatePaintArray(E.start, E.end, A, t[C], _), b = true;
                  }
                }
              }
            }
            return b;
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof al || c instanceof pa) && t.push(...c.uniformNames.map(((f) => `#define HAS_UNIFORM_${f}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof Oo || c instanceof co) for (let f = 0; f < c.paintVertexAttributes.length; f++) t.push(c.paintVertexAttributes[f].name);
              else if (c instanceof ss) for (let f = 0; f < In.members.length; f++) t.push(In.members[f].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof al || c instanceof pa || c instanceof co) for (const f of c.uniformNames) t.push(f);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, r) {
            const c = [];
            for (const f in this.binders) {
              const _ = this.binders[f];
              if (_ instanceof al || _ instanceof pa || _ instanceof co) {
                for (const b of _.uniformNames) if (r[b]) {
                  const C = _.getBinding(t, r[b], b);
                  c.push({ name: b, property: f, binding: C });
                }
              }
            }
            return c;
          }
          setUniforms(t, r, c, f) {
            for (const { name: _, property: b, binding: C } of r) this.binders[b].setUniform(C, f, c.get(b), _);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (t && c instanceof ss) {
                const f = t.fromScale === 2 ? c.zoomInPaintVertexBuffer : c.zoomOutPaintVertexBuffer;
                f && this._buffers.push(f);
              } else (c instanceof Oo || c instanceof co) && c.paintVertexBuffer && this._buffers.push(c.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof Oo || c instanceof co || c instanceof ss) && c.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof Oo || r instanceof co || r instanceof ss) && r.destroy();
            }
          }
        }
        class Bi {
          constructor(t, r, c = () => true) {
            this.programConfigurations = {};
            for (const f of t) this.programConfigurations[f.id] = new Fh(f, r, c);
            this.needsUpload = false, this._featureMap = new Fs(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, r, c, f) {
            for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, r, f);
            r.id !== void 0 && this._featureMap.add(r.id, c, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = true;
          }
          updatePaintArrays(t, r, c, f) {
            for (const _ of c) this.needsUpload = this.programConfigurations[_.id].updatePaintArrays(t, this._featureMap, r, _, f) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Lh(n, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[n] || [n.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function Hu(n, t, r) {
          const c = { color: { source: sl, composite: F }, number: { source: y, composite: sl } }, f = (function(_) {
            return { "line-pattern": { source: Tt, composite: Tt }, "fill-pattern": { source: Tt, composite: Tt }, "fill-extrusion-pattern": { source: Tt, composite: Tt } }[_];
          })(n);
          return f && f[r] || c[t][r];
        }
        Bt("ConstantBinder", al), Bt("CrossFadedConstantBinder", pa), Bt("SourceExpressionBinder", Oo), Bt("CrossFadedCompositeBinder", ss), Bt("CompositeExpressionBinder", co), Bt("ProgramConfiguration", Fh, { omit: ["_buffers"] }), Bt("ProgramConfigurationSet", Bi);
        const gc = Math.pow(2, 14) - 1, vc = -gc - 1;
        function as(n) {
          const t = Ye / n.extent, r = n.loadGeometry();
          for (let c = 0; c < r.length; c++) {
            const f = r[c];
            for (let _ = 0; _ < f.length; _++) {
              const b = f[_], C = Math.round(b.x * t), P = Math.round(b.y * t);
              b.x = vt(C, vc, gc), b.y = vt(P, vc, gc), (C < b.x || C > b.x + 1 || P < b.y || P > b.y + 1) && Ct("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r;
        }
        function $o(n, t) {
          return { type: n.type, id: n.id, properties: n.properties, geometry: t ? as(n) : [] };
        }
        const qv = -32768;
        function ww(n, t, r, c, f) {
          n.emplaceBack(qv + 8 * t + c, qv + 8 * r + f);
        }
        class Sf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new je(), this.indexArray = new Kr(), this.segments = new br(), this.programConfigurations = new Bi(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(t, r, c) {
            const f = this.layers[0], _ = [];
            let b = null, C = false, P = f.type === "heatmap";
            if (f.type === "circle") {
              const A = f;
              b = A.layout.get("circle-sort-key"), C = !b.isConstant(), P = P || A.paint.get("circle-pitch-alignment") === "map";
            }
            const E = P ? r.subdivisionGranularity.circle : 1;
            for (const { feature: A, id: B, index: U, sourceLayerIndex: H } of t) {
              const J = this.layers[0]._featureFilter.needGeometry, ie = $o(A, J);
              if (!this.layers[0]._featureFilter.filter(new rn(this.zoom, { globalState: this.globalState }), ie, c)) continue;
              const le = C ? b.evaluate(ie, {}, c) : void 0, me = { id: B, properties: A.properties, type: A.type, sourceLayerIndex: H, index: U, geometry: J ? ie.geometry : as(A), patterns: {}, sortKey: le };
              _.push(me);
            }
            C && _.sort(((A, B) => A.sortKey - B.sortKey));
            for (const A of _) {
              const { geometry: B, index: U, sourceLayerIndex: H } = A, J = t[U].feature;
              this.addFeature(A, B, U, c, E), r.featureIndex.insert(J, B, U, H, this.index);
            }
          }
          update(t, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, { imagePositions: c, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _n), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, r, c, f, _ = 1) {
            let b;
            switch (_) {
              case 1:
                b = [0, 7];
                break;
              case 3:
                b = [0, 2, 5, 7];
                break;
              case 5:
                b = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                b = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${_}; valid values are 1, 3, 5, 7.`);
            }
            const C = b.length;
            for (const P of r) for (const E of P) {
              const A = E.x, B = E.y;
              if (A < 0 || A >= Ye || B < 0 || B >= Ye) continue;
              const U = this.segments.prepareSegment(C * C, this.layoutVertexArray, this.indexArray, t.sortKey), H = U.vertexLength;
              for (let J = 0; J < C; J++) for (let ie = 0; ie < C; ie++) ww(this.layoutVertexArray, A, B, b[ie], b[J]);
              for (let J = 0; J < C - 1; J++) for (let ie = 0; ie < C - 1; ie++) {
                const le = H + J * C + ie, me = H + (J + 1) * C + ie;
                this.indexArray.emplaceBack(le, me + 1, le + 1), this.indexArray.emplaceBack(le, me, me + 1);
              }
              U.vertexLength += C * C, U.primitiveLength += (C - 1) * (C - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, { imagePositions: {}, canonical: f, globalState: this.globalState });
          }
        }
        function Gv(n, t) {
          for (let r = 0; r < n.length; r++) if (yc(t, n[r])) return true;
          for (let r = 0; r < t.length; r++) if (yc(n, t[r])) return true;
          return !!kf(n, t);
        }
        function Cw(n, t, r) {
          return !!yc(n, t) || !!Pf(t, n, r);
        }
        function Wv(n, t) {
          if (n.length === 1) return Hv(t, n[0]);
          for (let r = 0; r < t.length; r++) {
            const c = t[r];
            for (let f = 0; f < c.length; f++) if (yc(n, c[f])) return true;
          }
          for (let r = 0; r < n.length; r++) if (Hv(t, n[r])) return true;
          for (let r = 0; r < t.length; r++) if (kf(n, t[r])) return true;
          return false;
        }
        function Sw(n, t, r) {
          if (n.length > 1) {
            if (kf(n, t)) return true;
            for (let c = 0; c < t.length; c++) if (Pf(t[c], n, r)) return true;
          }
          for (let c = 0; c < n.length; c++) if (Pf(n[c], t, r)) return true;
          return false;
        }
        function kf(n, t) {
          if (n.length === 0 || t.length === 0) return false;
          for (let r = 0; r < n.length - 1; r++) {
            const c = n[r], f = n[r + 1];
            for (let _ = 0; _ < t.length - 1; _++) if (kw(c, f, t[_], t[_ + 1])) return true;
          }
          return false;
        }
        function kw(n, t, r, c) {
          return Dt(n, r, c) !== Dt(t, r, c) && Dt(n, t, r) !== Dt(n, t, c);
        }
        function Pf(n, t, r) {
          const c = r * r;
          if (t.length === 1) return n.distSqr(t[0]) < c;
          for (let f = 1; f < t.length; f++) if (Zv(n, t[f - 1], t[f]) < c) return true;
          return false;
        }
        function Zv(n, t, r) {
          const c = t.distSqr(r);
          if (c === 0) return n.distSqr(t);
          const f = ((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / c;
          return n.distSqr(f < 0 ? t : f > 1 ? r : r.sub(t)._mult(f)._add(t));
        }
        function Hv(n, t) {
          let r, c, f, _ = false;
          for (let b = 0; b < n.length; b++) {
            r = n[b];
            for (let C = 0, P = r.length - 1; C < r.length; P = C++) c = r[C], f = r[P], c.y > t.y != f.y > t.y && t.x < (f.x - c.x) * (t.y - c.y) / (f.y - c.y) + c.x && (_ = !_);
          }
          return _;
        }
        function yc(n, t) {
          let r = false;
          for (let c = 0, f = n.length - 1; c < n.length; f = c++) {
            const _ = n[c], b = n[f];
            _.y > t.y != b.y > t.y && t.x < (b.x - _.x) * (t.y - _.y) / (b.y - _.y) + _.x && (r = !r);
          }
          return r;
        }
        function Pw(n, t, r) {
          const c = r[0], f = r[2];
          if (n.x < c.x && t.x < c.x || n.x > f.x && t.x > f.x || n.y < c.y && t.y < c.y || n.y > f.y && t.y > f.y) return false;
          const _ = Dt(n, t, r[0]);
          return _ !== Dt(n, t, r[1]) || _ !== Dt(n, t, r[2]) || _ !== Dt(n, t, r[3]);
        }
        function Xu(n, t, r) {
          const c = t.paint.get(n).value;
          return c.kind === "constant" ? c.value : r.programConfigurations.get(t.id).getMaxValue(n);
        }
        function Bh(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
        }
        function Oh(n, t, r, c, f) {
          if (!t[0] && !t[1]) return n;
          const _ = w.convert(t)._mult(f);
          r === "viewport" && _._rotate(-c);
          const b = [];
          for (let C = 0; C < n.length; C++) b.push(n[C].sub(_));
          return b;
        }
        let Xv, Yv;
        Bt("CircleBucket", Sf, { omit: ["layers"] });
        var Tw = { get paint() {
          return Yv = Yv || new pi({ "circle-radius": new sr(Te.paint_circle["circle-radius"]), "circle-color": new sr(Te.paint_circle["circle-color"]), "circle-blur": new sr(Te.paint_circle["circle-blur"]), "circle-opacity": new sr(Te.paint_circle["circle-opacity"]), "circle-translate": new Xt(Te.paint_circle["circle-translate"]), "circle-translate-anchor": new Xt(Te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Xt(Te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Xt(Te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new sr(Te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new sr(Te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new sr(Te.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Xv = Xv || new pi({ "circle-sort-key": new sr(Te.layout_circle["circle-sort-key"]) });
        } };
        class Mw extends Zi {
          constructor(t) {
            super(t, Tw);
          }
          createBucket(t) {
            return new Sf(t);
          }
          queryRadius(t) {
            const r = t;
            return Xu("circle-radius", this, r) + Xu("circle-stroke-width", this, r) + Bh(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: c, geometry: f, transform: _, pixelsToTileUnits: b, unwrappedTileID: C, getElevation: P }) {
            const E = Oh(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -_.bearingInRadians, b), A = this.paint.get("circle-radius").evaluate(r, c) + this.paint.get("circle-stroke-width").evaluate(r, c), B = this.paint.get("circle-pitch-alignment") === "map", U = B ? E : (function(J, ie, le, me) {
              return J.map(((Oe) => Kv(Oe, ie, le, me)));
            })(E, _, C, P), H = B ? A * b : A;
            for (const J of f) for (const ie of J) {
              const le = B ? ie : Kv(ie, _, C, P);
              let me = H;
              const Oe = _.projectTileCoordinates(ie.x, ie.y, C, P).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? me *= Oe / _.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (me *= _.cameraToCenterDistance / Oe), Cw(U, le, me)) return true;
            }
            return false;
          }
        }
        function Kv(n, t, r, c) {
          const f = t.projectTileCoordinates(n.x, n.y, r, c).point;
          return new w((0.5 * f.x + 0.5) * t.width, (0.5 * -f.y + 0.5) * t.height);
        }
        class Jv extends Sf {
        }
        let Qv;
        Bt("HeatmapBucket", Jv, { omit: ["layers"] });
        var Iw = { get paint() {
          return Qv = Qv || new pi({ "heatmap-radius": new sr(Te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new sr(Te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Xt(Te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new hc(Te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Xt(Te.paint_heatmap["heatmap-opacity"]) });
        } };
        function Tf(n, { width: t, height: r }, c, f) {
          if (f) {
            if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
            else if (f.length !== t * r * c) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${t * r * c}`);
          } else f = new Uint8Array(t * r * c);
          return n.width = t, n.height = r, n.data = f, n;
        }
        function ey(n, { width: t, height: r }, c) {
          if (t === n.width && r === n.height) return;
          const f = Tf({}, { width: t, height: r }, c);
          Mf(n, f, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(n.width, t), height: Math.min(n.height, r) }, c), n.width = t, n.height = r, n.data = f.data;
        }
        function Mf(n, t, r, c, f, _) {
          if (f.width === 0 || f.height === 0) return t;
          if (f.width > n.width || f.height > n.height || r.x > n.width - f.width || r.y > n.height - f.height) throw new RangeError("out of range source coordinates for image copy");
          if (f.width > t.width || f.height > t.height || c.x > t.width - f.width || c.y > t.height - f.height) throw new RangeError("out of range destination coordinates for image copy");
          const b = n.data, C = t.data;
          if (b === C) throw new Error("srcData equals dstData, so image is already copied");
          for (let P = 0; P < f.height; P++) {
            const E = ((r.y + P) * n.width + r.x) * _, A = ((c.y + P) * t.width + c.x) * _;
            for (let B = 0; B < f.width * _; B++) C[A + B] = b[E + B];
          }
          return t;
        }
        class Yu {
          constructor(t, r) {
            Tf(this, t, 1, r);
          }
          resize(t) {
            ey(this, t, 1);
          }
          clone() {
            return new Yu({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, r, c, f, _) {
            Mf(t, r, c, f, _, 1);
          }
        }
        class Oi {
          constructor(t, r) {
            Tf(this, t, 4, r);
          }
          resize(t) {
            ey(this, t, 4);
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Oi({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, r, c, f, _) {
            Mf(t, r, c, f, _, 4);
          }
          setPixel(t, r, c) {
            const f = 4 * (t * this.width + r);
            this.data[f + 0] = Math.round(255 * c.r / c.a), this.data[f + 1] = Math.round(255 * c.g / c.a), this.data[f + 2] = Math.round(255 * c.b / c.a), this.data[f + 3] = Math.round(255 * c.a);
          }
        }
        function ty(n) {
          const t = {}, r = n.resolution || 256, c = n.clips ? n.clips.length : 1, f = n.image || new Oi({ width: r, height: c });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const _ = (b, C, P) => {
            t[n.evaluationKey] = P;
            const E = n.expression.evaluate(t);
            f.setPixel(b / 4 / r, C / 4, E);
          };
          if (n.clips) for (let b = 0, C = 0; b < c; ++b, C += 4 * r) for (let P = 0, E = 0; P < r; P++, E += 4) {
            const A = P / (r - 1), { start: B, end: U } = n.clips[b];
            _(C, E, B * (1 - A) + U * A);
          }
          else for (let b = 0, C = 0; b < r; b++, C += 4) _(0, C, b / (r - 1));
          return f;
        }
        Bt("AlphaImage", Yu), Bt("RGBAImage", Oi);
        const If = "big-fb";
        class Ew extends Zi {
          createBucket(t) {
            return new Jv(t);
          }
          constructor(t) {
            super(t, Iw), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = ty({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(If) && this.heatmapFbos.delete(If);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let ry;
        var Rw = { get paint() {
          return ry = ry || new pi({ "hillshade-illumination-direction": new Xt(Te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Xt(Te.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Xt(Te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Xt(Te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Xt(Te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Xt(Te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Xt(Te.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Xt(Te.paint_hillshade["hillshade-method"]) });
        } };
        class zw extends Zi {
          constructor(t) {
            super(t, Rw), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, r = this.paint.get("hillshade-illumination-altitude").values, c = this.paint.get("hillshade-highlight-color").values, f = this.paint.get("hillshade-shadow-color").values;
            const _ = Math.max(t.length, r.length, c.length, f.length);
            t = t.concat(Array(_ - t.length).fill(t.at(-1))), r = r.concat(Array(_ - r.length).fill(r.at(-1))), c = c.concat(Array(_ - c.length).fill(c.at(-1))), f = f.concat(Array(_ - f.length).fill(f.at(-1)));
            const b = r.map(st);
            return { directionRadians: t.map(st), altitudeRadians: b, shadowColor: f, highlightColor: c };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let ny;
        var Aw = { get paint() {
          return ny = ny || new pi({ "color-relief-opacity": new Xt(Te["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new hc(Te["paint_color-relief"]["color-relief-color"]) });
        } };
        class Ef {
          constructor(t, r, c, f) {
            this.context = t, this.format = c, this.texture = t.gl.createTexture(), this.update(r, f);
          }
          update(t, r, c) {
            const { width: f, height: _ } = t, b = !(this.size && this.size[0] === f && this.size[1] === _ || c), { context: C } = this, { gl: P } = C;
            if (this.useMipmap = !!(r && r.useMipmap), P.bindTexture(P.TEXTURE_2D, this.texture), C.pixelStoreUnpackFlipY.set(false), C.pixelStoreUnpack.set(1), C.pixelStoreUnpackPremultiplyAlpha.set(this.format === P.RGBA && (!r || r.premultiply !== false)), b) this.size = [f, _], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || We(t) ? P.texImage2D(P.TEXTURE_2D, 0, this.format, this.format, P.UNSIGNED_BYTE, t) : P.texImage2D(P.TEXTURE_2D, 0, this.format, f, _, 0, this.format, P.UNSIGNED_BYTE, t.data);
            else {
              const { x: E, y: A } = c || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || We(t) ? P.texSubImage2D(P.TEXTURE_2D, 0, E, A, P.RGBA, P.UNSIGNED_BYTE, t) : P.texSubImage2D(P.TEXTURE_2D, 0, E, A, f, _, P.RGBA, P.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && P.generateMipmap(P.TEXTURE_2D), C.pixelStoreUnpackFlipY.setDefault(), C.pixelStoreUnpack.setDefault(), C.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, r, c) {
            const { context: f } = this, { gl: _ } = f;
            _.bindTexture(_.TEXTURE_2D, this.texture), c !== _.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (c = _.LINEAR), t !== this.filter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, t), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, c || t), this.filter = t), r !== this.wrap && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, r), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, r), this.wrap = r);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class iy {
          constructor(t, r, c, f = 1, _ = 1, b = 1, C = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (c && !["mapbox", "terrarium", "custom"].includes(c)) return void Ct(`"${c}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const P = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), c) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = f, this.greenFactor = _, this.blueFactor = b, this.baseShift = C;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let E = 0; E < P; E++) this.data[this._idx(-1, E)] = this.data[this._idx(0, E)], this.data[this._idx(P, E)] = this.data[this._idx(P - 1, E)], this.data[this._idx(E, -1)] = this.data[this._idx(E, 0)], this.data[this._idx(E, P)] = this.data[this._idx(E, P - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(P, -1)] = this.data[this._idx(P - 1, 0)], this.data[this._idx(-1, P)] = this.data[this._idx(0, P - 1)], this.data[this._idx(P, P)] = this.data[this._idx(P - 1, P - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let E = 0; E < P; E++) for (let A = 0; A < P; A++) {
              const B = this.get(E, A);
              B > this.max && (this.max = B), B < this.min && (this.min = B);
            }
          }
          get(t, r) {
            const c = new Uint8Array(this.data.buffer), f = 4 * this._idx(t, r);
            return this.unpack(c[f], c[f + 1], c[f + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1);
          }
          unpack(t, r, c) {
            return t * this.redFactor + r * this.greenFactor + c * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return oy(t, this.getUnpackVector());
          }
          getPixels() {
            return new Oi({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, r, c) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let f = r * this.dim, _ = r * this.dim + this.dim, b = c * this.dim, C = c * this.dim + this.dim;
            switch (r) {
              case -1:
                f = _ - 1;
                break;
              case 1:
                _ = f + 1;
            }
            switch (c) {
              case -1:
                b = C - 1;
                break;
              case 1:
                C = b + 1;
            }
            const P = -r * this.dim, E = -c * this.dim;
            for (let A = b; A < C; A++) for (let B = f; B < _; B++) this.data[this._idx(B, A)] = t.data[this._idx(B + P, A + E)];
          }
        }
        function oy(n, t) {
          const r = t[0], c = t[1], f = t[2], _ = t[3], b = Math.min(r, c, f), C = Math.round((n + _) / b);
          return { r: Math.floor(C * b / r) % 256, g: Math.floor(C * b / c) % 256, b: Math.floor(C * b / f) % 256 };
        }
        Bt("DEMData", iy);
        class Dw extends Zi {
          constructor(t) {
            super(t, Aw);
          }
          _createColorRamp(t) {
            const r = { elevationStops: [], colorStops: [] }, c = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (c instanceof Ka && c._styleExpression.expression instanceof Xn) {
              this.colorRampExpression = c;
              const b = c._styleExpression.expression;
              r.elevationStops = b.labels, r.colorStops = [];
              for (const C of r.elevationStops) r.colorStops.push(b.evaluate({ globals: { elevation: C } }));
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [kr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const f = { elevationStops: [], colorStops: [] }, _ = (r.elevationStops.length - 1) / (t - 1);
            for (let b = 0; b < r.elevationStops.length - 0.5; b += _) f.elevationStops.push(r.elevationStops[Math.round(b)]), f.colorStops.push(r.colorStops[Math.round(b)]);
            return Ct(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), f;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, r, c) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const f = this._createColorRamp(r), _ = new Oi({ width: f.colorStops.length, height: 1 }), b = new Oi({ width: f.colorStops.length, height: 1 });
            for (let C = 0; C < f.elevationStops.length; C++) {
              const P = oy(f.elevationStops[C], c);
              b.setPixel(0, C, new kr(P.r / 255, P.g / 255, P.b / 255, 1)), _.setPixel(0, C, f.colorStops[C]);
            }
            return this.colorRampTextures = { elevationTexture: new Ef(t, b, t.gl.RGBA), colorTexture: new Ef(t, _, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const Fw = Cn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Lw } = Fw;
        function Rf(n, t, r) {
          const c = r.patternDependencies;
          let f = false;
          for (const _ of t) {
            const b = _.paint.get(`${n}-pattern`);
            b.isConstant() || (f = true);
            const C = b.constantOr(null);
            C && (f = true, c[C.to] = true, c[C.from] = true);
          }
          return f;
        }
        function zf(n, t, r, c, f) {
          const _ = f.patternDependencies;
          for (const b of t) {
            const C = b.paint.get(`${n}-pattern`).value;
            if (C.kind !== "constant") {
              let P = C.evaluate({ zoom: c - 1 }, r, {}, f.availableImages), E = C.evaluate({ zoom: c }, r, {}, f.availableImages), A = C.evaluate({ zoom: c + 1 }, r, {}, f.availableImages);
              P = P && P.name ? P.name : P, E = E && E.name ? E.name : E, A = A && A.name ? A.name : A, _[P] = true, _[E] = true, _[A] = true, r.patterns[b.id] = { min: P, mid: E, max: A };
            }
          }
          return r;
        }
        function sy(n, t, r, c, f) {
          let _;
          if (f === (function(b, C, P, E) {
            let A = 0;
            for (let B = C, U = P - E; B < P; B += E) A += (b[U] - b[B]) * (b[B + 1] + b[U + 1]), U = B;
            return A;
          })(n, t, r, c) > 0) for (let b = t; b < r; b += c) _ = uy(b / c | 0, n[b], n[b + 1], _);
          else for (let b = r - c; b >= t; b -= c) _ = uy(b / c | 0, n[b], n[b + 1], _);
          return _ && _c(_, _.next) && (ed(_), _ = _.next), _;
        }
        function ll(n, t) {
          if (!n) return n;
          t || (t = n);
          let r, c = n;
          do
            if (r = false, c.steiner || !_c(c, c.next) && kn(c.prev, c, c.next) !== 0) c = c.next;
            else {
              if (ed(c), c = t = c.prev, c === c.next) break;
              r = true;
            }
          while (r || c !== t);
          return t;
        }
        function Ku(n, t, r, c, f, _, b) {
          if (!n) return;
          !b && _ && (function(P, E, A, B) {
            let U = P;
            do
              U.z === 0 && (U.z = Af(U.x, U.y, E, A, B)), U.prevZ = U.prev, U.nextZ = U.next, U = U.next;
            while (U !== P);
            U.prevZ.nextZ = null, U.prevZ = null, (function(H) {
              let J, ie = 1;
              do {
                let le, me = H;
                H = null;
                let Oe = null;
                for (J = 0; me; ) {
                  J++;
                  let Se = me, Ee = 0;
                  for (let rt = 0; rt < ie && (Ee++, Se = Se.nextZ, Se); rt++) ;
                  let He = ie;
                  for (; Ee > 0 || He > 0 && Se; ) Ee !== 0 && (He === 0 || !Se || me.z <= Se.z) ? (le = me, me = me.nextZ, Ee--) : (le = Se, Se = Se.nextZ, He--), Oe ? Oe.nextZ = le : H = le, le.prevZ = Oe, Oe = le;
                  me = Se;
                }
                Oe.nextZ = null, ie *= 2;
              } while (J > 1);
            })(U);
          })(n, c, f, _);
          let C = n;
          for (; n.prev !== n.next; ) {
            const P = n.prev, E = n.next;
            if (_ ? Ow(n, c, f, _) : Bw(n)) t.push(P.i, n.i, E.i), ed(n), n = E.next, C = E.next;
            else if ((n = E) === C) {
              b ? b === 1 ? Ku(n = $w(ll(n), t), t, r, c, f, _, 2) : b === 2 && jw(n, t, r, c, f, _) : Ku(ll(n), t, r, c, f, _, 1);
              break;
            }
          }
        }
        function Bw(n) {
          const t = n.prev, r = n, c = n.next;
          if (kn(t, r, c) >= 0) return false;
          const f = t.x, _ = r.x, b = c.x, C = t.y, P = r.y, E = c.y, A = Math.min(f, _, b), B = Math.min(C, P, E), U = Math.max(f, _, b), H = Math.max(C, P, E);
          let J = c.next;
          for (; J !== t; ) {
            if (J.x >= A && J.x <= U && J.y >= B && J.y <= H && Ju(f, C, _, P, b, E, J.x, J.y) && kn(J.prev, J, J.next) >= 0) return false;
            J = J.next;
          }
          return true;
        }
        function Ow(n, t, r, c) {
          const f = n.prev, _ = n, b = n.next;
          if (kn(f, _, b) >= 0) return false;
          const C = f.x, P = _.x, E = b.x, A = f.y, B = _.y, U = b.y, H = Math.min(C, P, E), J = Math.min(A, B, U), ie = Math.max(C, P, E), le = Math.max(A, B, U), me = Af(H, J, t, r, c), Oe = Af(ie, le, t, r, c);
          let Se = n.prevZ, Ee = n.nextZ;
          for (; Se && Se.z >= me && Ee && Ee.z <= Oe; ) {
            if (Se.x >= H && Se.x <= ie && Se.y >= J && Se.y <= le && Se !== f && Se !== b && Ju(C, A, P, B, E, U, Se.x, Se.y) && kn(Se.prev, Se, Se.next) >= 0 || (Se = Se.prevZ, Ee.x >= H && Ee.x <= ie && Ee.y >= J && Ee.y <= le && Ee !== f && Ee !== b && Ju(C, A, P, B, E, U, Ee.x, Ee.y) && kn(Ee.prev, Ee, Ee.next) >= 0)) return false;
            Ee = Ee.nextZ;
          }
          for (; Se && Se.z >= me; ) {
            if (Se.x >= H && Se.x <= ie && Se.y >= J && Se.y <= le && Se !== f && Se !== b && Ju(C, A, P, B, E, U, Se.x, Se.y) && kn(Se.prev, Se, Se.next) >= 0) return false;
            Se = Se.prevZ;
          }
          for (; Ee && Ee.z <= Oe; ) {
            if (Ee.x >= H && Ee.x <= ie && Ee.y >= J && Ee.y <= le && Ee !== f && Ee !== b && Ju(C, A, P, B, E, U, Ee.x, Ee.y) && kn(Ee.prev, Ee, Ee.next) >= 0) return false;
            Ee = Ee.nextZ;
          }
          return true;
        }
        function $w(n, t) {
          let r = n;
          do {
            const c = r.prev, f = r.next.next;
            !_c(c, f) && ly(c, r, r.next, f) && Qu(c, f) && Qu(f, c) && (t.push(c.i, r.i, f.i), ed(r), ed(r.next), r = n = f), r = r.next;
          } while (r !== n);
          return ll(r);
        }
        function jw(n, t, r, c, f, _) {
          let b = n;
          do {
            let C = b.next.next;
            for (; C !== b.prev; ) {
              if (b.i !== C.i && Gw(b, C)) {
                let P = cy(b, C);
                return b = ll(b, b.next), P = ll(P, P.next), Ku(b, t, r, c, f, _, 0), void Ku(P, t, r, c, f, _, 0);
              }
              C = C.next;
            }
            b = b.next;
          } while (b !== n);
        }
        function Nw(n, t) {
          let r = n.x - t.x;
          return r === 0 && (r = n.y - t.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), r;
        }
        function Vw(n, t) {
          const r = (function(f, _) {
            let b = _;
            const C = f.x, P = f.y;
            let E, A = -1 / 0;
            if (_c(f, b)) return b;
            do {
              if (_c(f, b.next)) return b.next;
              if (P <= b.y && P >= b.next.y && b.next.y !== b.y) {
                const ie = b.x + (P - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
                if (ie <= C && ie > A && (A = ie, E = b.x < b.next.x ? b : b.next, ie === C)) return E;
              }
              b = b.next;
            } while (b !== _);
            if (!E) return null;
            const B = E, U = E.x, H = E.y;
            let J = 1 / 0;
            b = E;
            do {
              if (C >= b.x && b.x >= U && C !== b.x && ay(P < H ? C : A, P, U, H, P < H ? A : C, P, b.x, b.y)) {
                const ie = Math.abs(P - b.y) / (C - b.x);
                Qu(b, f) && (ie < J || ie === J && (b.x > E.x || b.x === E.x && Uw(E, b))) && (E = b, J = ie);
              }
              b = b.next;
            } while (b !== B);
            return E;
          })(n, t);
          if (!r) return t;
          const c = cy(r, n);
          return ll(c, c.next), ll(r, r.next);
        }
        function Uw(n, t) {
          return kn(n.prev, n, t.prev) < 0 && kn(t.next, n, n.next) < 0;
        }
        function Af(n, t, r, c, f) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * f | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - c) * f | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function qw(n) {
          let t = n, r = n;
          do
            (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next;
          while (t !== n);
          return r;
        }
        function ay(n, t, r, c, f, _, b, C) {
          return (f - b) * (t - C) >= (n - b) * (_ - C) && (n - b) * (c - C) >= (r - b) * (t - C) && (r - b) * (_ - C) >= (f - b) * (c - C);
        }
        function Ju(n, t, r, c, f, _, b, C) {
          return !(n === b && t === C) && ay(n, t, r, c, f, _, b, C);
        }
        function Gw(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(r, c) {
            let f = r;
            do {
              if (f.i !== r.i && f.next.i !== r.i && f.i !== c.i && f.next.i !== c.i && ly(f, f.next, r, c)) return true;
              f = f.next;
            } while (f !== r);
            return false;
          })(n, t) && (Qu(n, t) && Qu(t, n) && (function(r, c) {
            let f = r, _ = false;
            const b = (r.x + c.x) / 2, C = (r.y + c.y) / 2;
            do
              f.y > C != f.next.y > C && f.next.y !== f.y && b < (f.next.x - f.x) * (C - f.y) / (f.next.y - f.y) + f.x && (_ = !_), f = f.next;
            while (f !== r);
            return _;
          })(n, t) && (kn(n.prev, n, t.prev) || kn(n, t.prev, t)) || _c(n, t) && kn(n.prev, n, n.next) > 0 && kn(t.prev, t, t.next) > 0);
        }
        function kn(n, t, r) {
          return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y);
        }
        function _c(n, t) {
          return n.x === t.x && n.y === t.y;
        }
        function ly(n, t, r, c) {
          const f = jh(kn(n, t, r)), _ = jh(kn(n, t, c)), b = jh(kn(r, c, n)), C = jh(kn(r, c, t));
          return f !== _ && b !== C || !(f !== 0 || !$h(n, r, t)) || !(_ !== 0 || !$h(n, c, t)) || !(b !== 0 || !$h(r, n, c)) || !(C !== 0 || !$h(r, t, c));
        }
        function $h(n, t, r) {
          return t.x <= Math.max(n.x, r.x) && t.x >= Math.min(n.x, r.x) && t.y <= Math.max(n.y, r.y) && t.y >= Math.min(n.y, r.y);
        }
        function jh(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0;
        }
        function Qu(n, t) {
          return kn(n.prev, n, n.next) < 0 ? kn(n, t, n.next) >= 0 && kn(n, n.prev, t) >= 0 : kn(n, t, n.prev) < 0 || kn(n, n.next, t) < 0;
        }
        function cy(n, t) {
          const r = Df(n.i, n.x, n.y), c = Df(t.i, t.x, t.y), f = n.next, _ = t.prev;
          return n.next = t, t.prev = n, r.next = f, f.prev = r, c.next = r, r.prev = c, _.next = c, c.prev = _, c;
        }
        function uy(n, t, r, c) {
          const f = Df(n, t, r);
          return c ? (f.next = c.next, f.prev = c, c.next.prev = f, c.next = f) : (f.prev = f, f.next = f), f;
        }
        function ed(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
        }
        function Df(n, t, r) {
          return { i: n, x: t, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class bc {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class Nh {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        Nh.noSubdivision = new Nh({ fill: new bc(0, 0), line: new bc(0, 0), tile: new bc(0, 0), stencil: new bc(0, 0), circle: 1 }), Bt("SubdivisionGranularityExpression", bc), Bt("SubdivisionGranularitySetting", Nh);
        const xc = -32768, td = 32767;
        class Ww {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t, this._granularityCellSize = Ye / t, this._canonical = r;
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768;
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const c = 0 | Math.round(t), f = 0 | Math.round(r), _ = this._getKey(c, f);
            if (this._vertexDictionary.has(_)) return this._vertexDictionary.get(_);
            const b = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(_, b), this._vertexBuffer.push(c, f), b;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(f, _) {
              const b = [];
              for (let C = 0; C < _.length; C += 3) {
                const P = _[C], E = _[C + 1], A = _[C + 2], B = f[2 * P], U = f[2 * P + 1];
                (f[2 * E] - B) * (f[2 * A + 1] - U) - (f[2 * E + 1] - U) * (f[2 * A] - B) > 0 ? (b.push(P), b.push(A), b.push(E)) : (b.push(P), b.push(E), b.push(A));
              }
              return b;
            })(this._vertexBuffer, t);
            const r = [], c = t.length;
            for (let f = 0; f < c; f += 3) {
              const _ = [t[f + 0], t[f + 1], t[f + 2]], b = [this._vertexBuffer[2 * t[f + 0] + 0], this._vertexBuffer[2 * t[f + 0] + 1], this._vertexBuffer[2 * t[f + 1] + 0], this._vertexBuffer[2 * t[f + 1] + 1], this._vertexBuffer[2 * t[f + 2] + 0], this._vertexBuffer[2 * t[f + 2] + 1]];
              let C = 1 / 0, P = 1 / 0, E = -1 / 0, A = -1 / 0;
              for (let ie = 0; ie < 3; ie++) {
                const le = b[2 * ie], me = b[2 * ie + 1];
                C = Math.min(C, le), E = Math.max(E, le), P = Math.min(P, me), A = Math.max(A, me);
              }
              if (C === E || P === A) continue;
              const B = Math.floor(C / this._granularityCellSize), U = Math.ceil(E / this._granularityCellSize), H = Math.floor(P / this._granularityCellSize), J = Math.ceil(A / this._granularityCellSize);
              if (B !== U || H !== J) for (let ie = H; ie < J; ie++) {
                const le = this._scanlineGenerateVertexRingForCellRow(ie, b, _);
                Zw(this._vertexBuffer, le, r);
              }
              else r.push(..._);
            }
            return r;
          }
          _scanlineGenerateVertexRingForCellRow(t, r, c) {
            const f = t * this._granularityCellSize, _ = f + this._granularityCellSize, b = [];
            for (let C = 0; C < 3; C++) {
              const P = r[2 * C], E = r[2 * C + 1], A = r[2 * (C + 1) % 6], B = r[(2 * (C + 1) + 1) % 6], U = r[2 * (C + 2) % 6], H = r[(2 * (C + 2) + 1) % 6], J = A - P, ie = B - E, le = J === 0, me = ie === 0, Oe = (f - E) / ie, Se = (_ - E) / ie, Ee = Math.min(Oe, Se), He = Math.max(Oe, Se);
              if (!me && (Ee >= 1 || He <= 0) || me && (E < f || E > _)) {
                B >= f && B <= _ && b.push(c[(C + 1) % 3]);
                continue;
              }
              !me && Ee > 0 && b.push(this._vertexToIndex(P + J * Ee, E + ie * Ee));
              const rt = P + J * Math.max(Ee, 0), _t = P + J * Math.min(He, 1);
              le || this._generateIntraEdgeVertices(b, P, E, A, B, rt, _t), !me && He < 1 && b.push(this._vertexToIndex(P + J * He, E + ie * He)), (me || B >= f && B <= _) && b.push(c[(C + 1) % 3]), !me && (B <= f || B >= _) && this._generateInterEdgeVertices(b, P, E, A, B, U, H, _t, f, _);
            }
            return b;
          }
          _generateIntraEdgeVertices(t, r, c, f, _, b, C) {
            const P = f - r, E = _ - c, A = E === 0, B = A ? Math.min(r, f) : Math.min(b, C), U = A ? Math.max(r, f) : Math.max(b, C), H = Math.floor(B / this._granularityCellSize) + 1, J = Math.ceil(U / this._granularityCellSize) - 1;
            if (A ? r < f : b < C) for (let ie = H; ie <= J; ie++) {
              const le = ie * this._granularityCellSize;
              t.push(this._vertexToIndex(le, c + E * (le - r) / P));
            }
            else for (let ie = J; ie >= H; ie--) {
              const le = ie * this._granularityCellSize;
              t.push(this._vertexToIndex(le, c + E * (le - r) / P));
            }
          }
          _generateInterEdgeVertices(t, r, c, f, _, b, C, P, E, A) {
            const B = _ - c, U = b - f, H = C - _, J = (E - _) / H, ie = (A - _) / H, le = Math.min(J, ie), me = Math.max(J, ie), Oe = f + U * le;
            let Se = Math.floor(Math.min(Oe, P) / this._granularityCellSize) + 1, Ee = Math.ceil(Math.max(Oe, P) / this._granularityCellSize) - 1, He = P < Oe;
            const rt = H === 0;
            if (rt && (C === E || C === A)) return;
            if (rt || le >= 1 || me <= 0) {
              const Ft = c - C, Mt = b + (r - b) * Math.min((E - C) / Ft, (A - C) / Ft);
              Se = Math.floor(Math.min(Mt, P) / this._granularityCellSize) + 1, Ee = Math.ceil(Math.max(Mt, P) / this._granularityCellSize) - 1, He = P < Mt;
            }
            const _t = B > 0 ? A : E;
            if (He) for (let Ft = Se; Ft <= Ee; Ft++) t.push(this._vertexToIndex(Ft * this._granularityCellSize, _t));
            else for (let Ft = Ee; Ft >= Se; Ft--) t.push(this._vertexToIndex(Ft * this._granularityCellSize, _t));
          }
          _generateOutline(t) {
            const r = [];
            for (const c of t) {
              const f = cl(c, this._granularity, true), _ = this._pointArrayToIndices(f), b = [];
              for (let C = 1; C < _.length; C++) b.push(_[C - 1]), b.push(_[C]);
              r.push(b);
            }
            return r;
          }
          _handlePoles(t) {
            let r = false, c = false;
            this._canonical && (this._canonical.y === 0 && (r = true), this._canonical.y === (1 << this._canonical.z) - 1 && (c = true)), (r || c) && this._fillPoles(t, r, c);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const c = t[r + 1];
              c === xc && (t[r + 1] = -32767), c === td && (t[r + 1] = 32766);
            }
          }
          _generatePoleQuad(t, r, c, f, _, b) {
            f > _ != (b === xc) ? (t.push(r), t.push(c), t.push(this._vertexToIndex(f, b)), t.push(c), t.push(this._vertexToIndex(_, b)), t.push(this._vertexToIndex(f, b))) : (t.push(c), t.push(r), t.push(this._vertexToIndex(f, b)), t.push(this._vertexToIndex(_, b)), t.push(c), t.push(this._vertexToIndex(f, b)));
          }
          _fillPoles(t, r, c) {
            const f = this._vertexBuffer, _ = Ye, b = t.length;
            for (let C = 2; C < b; C += 3) {
              const P = t[C - 2], E = t[C - 1], A = t[C], B = f[2 * P], U = f[2 * P + 1], H = f[2 * E], J = f[2 * E + 1], ie = f[2 * A], le = f[2 * A + 1];
              r && (U === 0 && J === 0 && this._generatePoleQuad(t, P, E, B, H, xc), J === 0 && le === 0 && this._generatePoleQuad(t, E, A, H, ie, xc), le === 0 && U === 0 && this._generatePoleQuad(t, A, P, ie, B, xc)), c && (U === _ && J === _ && this._generatePoleQuad(t, P, E, B, H, td), J === _ && le === _ && this._generatePoleQuad(t, E, A, H, ie, td), le === _ && U === _ && this._generatePoleQuad(t, A, P, ie, B, td));
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1]);
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: c, holeIndices: f } = (function(C) {
              const P = [], E = [];
              for (const A of C) if (A.length !== 0) {
                A !== C[0] && P.push(E.length / 2);
                for (let B = 0; B < A.length; B++) E.push(A[B].x), E.push(A[B].y);
              }
              return { flattened: E, holeIndices: P };
            })(t);
            let _;
            this._initializeVertices(c);
            try {
              const C = (function(E, A, B = 2) {
                const U = A && A.length, H = U ? A[0] * B : E.length;
                let J = sy(E, 0, H, B, true);
                const ie = [];
                if (!J || J.next === J.prev) return ie;
                let le, me, Oe;
                if (U && (J = (function(Se, Ee, He, rt) {
                  const _t = [];
                  for (let Ft = 0, Mt = Ee.length; Ft < Mt; Ft++) {
                    const zt = sy(Se, Ee[Ft] * rt, Ft < Mt - 1 ? Ee[Ft + 1] * rt : Se.length, rt, false);
                    zt === zt.next && (zt.steiner = true), _t.push(qw(zt));
                  }
                  _t.sort(Nw);
                  for (let Ft = 0; Ft < _t.length; Ft++) He = Vw(_t[Ft], He);
                  return He;
                })(E, A, J, B)), E.length > 80 * B) {
                  le = E[0], me = E[1];
                  let Se = le, Ee = me;
                  for (let He = B; He < H; He += B) {
                    const rt = E[He], _t = E[He + 1];
                    rt < le && (le = rt), _t < me && (me = _t), rt > Se && (Se = rt), _t > Ee && (Ee = _t);
                  }
                  Oe = Math.max(Se - le, Ee - me), Oe = Oe !== 0 ? 32767 / Oe : 0;
                }
                return Ku(J, ie, B, le, me, Oe, 0), ie;
              })(c, f), P = this._convertIndices(c, C);
              _ = this._subdivideTrianglesScanline(P);
            } catch (C) {
              console.error(C);
            }
            let b = [];
            return r && (b = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(_), { verticesFlattened: this._vertexBuffer, indicesTriangles: _, indicesLineList: b };
          }
          _convertIndices(t, r) {
            const c = [];
            for (let f = 0; f < r.length; f++) c.push(this._vertexToIndex(t[2 * r[f]], t[2 * r[f] + 1]));
            return c;
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let c = 0; c < t.length; c++) {
              const f = t[c];
              r.push(this._vertexToIndex(f.x, f.y));
            }
            return r;
          }
        }
        function dy(n, t, r, c = true) {
          return new Ww(r, t).subdividePolygonInternal(n, c);
        }
        function cl(n, t, r = false) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const c = n[0], f = n[n.length - 1], _ = r && (c.x !== f.x || c.y !== f.y);
          if (t < 2) return _ ? [...n, n[0]] : [...n];
          const b = Math.floor(Ye / t), C = [];
          C.push(new w(n[0].x, n[0].y));
          const P = n.length, E = _ ? P : P - 1;
          for (let A = 0; A < E; A++) {
            const B = n[A], U = A < P - 1 ? n[A + 1] : n[0], H = B.x, J = B.y, ie = U.x, le = U.y, me = H !== ie, Oe = J !== le;
            if (!me && !Oe) continue;
            const Se = ie - H, Ee = le - J, He = Math.abs(Se), rt = Math.abs(Ee);
            let _t = H, Ft = J;
            for (; ; ) {
              const zt = Se > 0 ? (Math.floor(_t / b) + 1) * b : (Math.ceil(_t / b) - 1) * b, Jt = Ee > 0 ? (Math.floor(Ft / b) + 1) * b : (Math.ceil(Ft / b) - 1) * b, Rt = Math.abs(_t - zt), At = Math.abs(Ft - Jt), dt = Math.abs(_t - ie), cr = Math.abs(Ft - le), mr = me ? Rt / He : Number.POSITIVE_INFINITY, nr = Oe ? At / rt : Number.POSITIVE_INFINITY;
              if ((dt <= Rt || !me) && (cr <= At || !Oe)) break;
              if (mr < nr && me || !Oe) {
                _t = zt, Ft += Ee * mr;
                const Ht = new w(_t, Math.round(Ft));
                C[C.length - 1].x === Ht.x && C[C.length - 1].y === Ht.y || C.push(Ht);
              } else {
                _t += Se * nr, Ft = Jt;
                const Ht = new w(Math.round(_t), Ft);
                C[C.length - 1].x === Ht.x && C[C.length - 1].y === Ht.y || C.push(Ht);
              }
            }
            const Mt = new w(ie, le);
            C[C.length - 1].x === Mt.x && C[C.length - 1].y === Mt.y || C.push(Mt);
          }
          return C;
        }
        function Zw(n, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let c = 0, f = n[2 * t[0]];
          for (let P = 1; P < t.length; P++) {
            const E = n[2 * t[P]];
            E < f && (f = E, c = P);
          }
          const _ = t.length;
          let b = c, C = (b + 1) % _;
          for (; ; ) {
            const P = b - 1 >= 0 ? b - 1 : _ - 1, E = (C + 1) % _, A = n[2 * t[P]], B = n[2 * t[E]], U = n[2 * t[b]], H = n[2 * t[b] + 1], J = n[2 * t[C] + 1];
            let ie = false;
            if (A < B) ie = true;
            else if (A > B) ie = false;
            else {
              const le = J - H, me = -(n[2 * t[C]] - U), Oe = H < J ? 1 : -1;
              ((A - U) * le + (n[2 * t[P] + 1] - H) * me) * Oe > ((B - U) * le + (n[2 * t[E] + 1] - H) * me) * Oe && (ie = true);
            }
            if (ie) {
              const le = t[P], me = t[b], Oe = t[C];
              le !== me && le !== Oe && me !== Oe && r.push(Oe, me, le), b--, b < 0 && (b = _ - 1);
            } else {
              const le = t[E], me = t[b], Oe = t[C];
              le !== me && le !== Oe && me !== Oe && r.push(Oe, me, le), C++, C >= _ && (C = 0);
            }
            if (P === E) break;
          }
        }
        function hy(n, t, r, c, f, _, b, C, P) {
          const E = f.length / 2, A = b && C && P;
          if (E < br.MAX_VERTEX_ARRAY_LENGTH) {
            const B = t.prepareSegment(E, r, c), U = B.vertexLength;
            for (let ie = 0; ie < _.length; ie += 3) c.emplaceBack(U + _[ie], U + _[ie + 1], U + _[ie + 2]);
            let H, J;
            B.vertexLength += E, B.primitiveLength += _.length / 3, A && (J = b.prepareSegment(E, r, C), H = J.vertexLength, J.vertexLength += E);
            for (let ie = 0; ie < f.length; ie += 2) n(f[ie], f[ie + 1]);
            if (A) for (let ie = 0; ie < P.length; ie++) {
              const le = P[ie];
              for (let me = 1; me < le.length; me += 2) C.emplaceBack(H + le[me - 1], H + le[me]);
              J.primitiveLength += le.length / 2;
            }
          } else (function(B, U, H, J, ie, le) {
            const me = [];
            for (let rt = 0; rt < J.length / 2; rt++) me.push(-1);
            const Oe = { count: 0 };
            let Se = 0, Ee = B.getOrCreateLatestSegment(U, H), He = Ee.vertexLength;
            for (let rt = 2; rt < ie.length; rt += 3) {
              const _t = ie[rt - 2], Ft = ie[rt - 1], Mt = ie[rt];
              let zt = me[_t] < Se, Jt = me[Ft] < Se, Rt = me[Mt] < Se;
              Ee.vertexLength + ((zt ? 1 : 0) + (Jt ? 1 : 0) + (Rt ? 1 : 0)) > br.MAX_VERTEX_ARRAY_LENGTH && (Ee = B.createNewSegment(U, H), Se = Oe.count, zt = true, Jt = true, Rt = true, He = 0);
              const At = rd(me, J, le, Oe, _t, zt, Ee), dt = rd(me, J, le, Oe, Ft, Jt, Ee), cr = rd(me, J, le, Oe, Mt, Rt, Ee);
              H.emplaceBack(He + At - Se, He + dt - Se, He + cr - Se), Ee.primitiveLength++;
            }
          })(t, r, c, f, _, n), A && (function(B, U, H, J, ie, le) {
            const me = [];
            for (let rt = 0; rt < J.length / 2; rt++) me.push(-1);
            const Oe = { count: 0 };
            let Se = 0, Ee = B.getOrCreateLatestSegment(U, H), He = Ee.vertexLength;
            for (let rt = 0; rt < ie.length; rt++) {
              const _t = ie[rt];
              for (let Ft = 1; Ft < ie[rt].length; Ft += 2) {
                const Mt = _t[Ft - 1], zt = _t[Ft];
                let Jt = me[Mt] < Se, Rt = me[zt] < Se;
                Ee.vertexLength + ((Jt ? 1 : 0) + (Rt ? 1 : 0)) > br.MAX_VERTEX_ARRAY_LENGTH && (Ee = B.createNewSegment(U, H), Se = Oe.count, Jt = true, Rt = true, He = 0);
                const At = rd(me, J, le, Oe, Mt, Jt, Ee), dt = rd(me, J, le, Oe, zt, Rt, Ee);
                H.emplaceBack(He + At - Se, He + dt - Se), Ee.primitiveLength++;
              }
            }
          })(b, r, C, f, P, n), t.forceNewSegmentOnNextPrepare(), b == null ? void 0 : b.forceNewSegmentOnNextPrepare();
        }
        function rd(n, t, r, c, f, _, b) {
          if (_) {
            const C = c.count;
            return r(t[2 * f], t[2 * f + 1]), n[f] = c.count, c.count++, b.vertexLength++, C;
          }
          return n[f];
        }
        class Ff {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Qe(), this.indexArray = new Kr(), this.indexArray2 = new Wr(), this.programConfigurations = new Bi(t.layers, t.zoom), this.segments = new br(), this.segments2 = new br(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(t, r, c) {
            this.hasPattern = Rf("fill", this.layers, r);
            const f = this.layers[0].layout.get("fill-sort-key"), _ = !f.isConstant(), b = [];
            for (const { feature: C, id: P, index: E, sourceLayerIndex: A } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, U = $o(C, B);
              if (!this.layers[0]._featureFilter.filter(new rn(this.zoom, { globalState: this.globalState }), U, c)) continue;
              const H = _ ? f.evaluate(U, {}, c, r.availableImages) : void 0, J = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: A, index: E, geometry: B ? U.geometry : as(C), patterns: {}, sortKey: H };
              b.push(J);
            }
            _ && b.sort(((C, P) => C.sortKey - P.sortKey));
            for (const C of b) {
              const { geometry: P, index: E, sourceLayerIndex: A } = C;
              if (this.hasPattern) {
                const B = zf("fill", this.layers, C, this.zoom, r);
                this.patternFeatures.push(B);
              } else this.addFeature(C, P, E, c, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[E].feature, P, E, A, this.index);
            }
          }
          update(t, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, { imagePositions: c, globalState: this.globalState });
          }
          addFeatures(t, r, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, c, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Lw), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, r, c, f, _, b) {
            for (const C of Wa(r, 500)) {
              const P = dy(C, f, b.fill.getGranularityForZoomLevel(f.z)), E = this.layoutVertexArray;
              hy(((A, B) => {
                E.emplaceBack(A, B);
              }), this.segments, this.layoutVertexArray, this.indexArray, P.verticesFlattened, P.indicesTriangles, this.segments2, this.indexArray2, P.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, { imagePositions: _, canonical: f, globalState: this.globalState });
          }
        }
        let py, fy;
        Bt("FillBucket", Ff, { omit: ["layers", "patternFeatures"] });
        var Hw = { get paint() {
          return fy = fy || new pi({ "fill-antialias": new Xt(Te.paint_fill["fill-antialias"]), "fill-opacity": new sr(Te.paint_fill["fill-opacity"]), "fill-color": new sr(Te.paint_fill["fill-color"]), "fill-outline-color": new sr(Te.paint_fill["fill-outline-color"]), "fill-translate": new Xt(Te.paint_fill["fill-translate"]), "fill-translate-anchor": new Xt(Te.paint_fill["fill-translate-anchor"]), "fill-pattern": new dc(Te.paint_fill["fill-pattern"]) });
        }, get layout() {
          return py = py || new pi({ "fill-sort-key": new sr(Te.layout_fill["fill-sort-key"]) });
        } };
        class Xw extends Zi {
          constructor(t) {
            super(t, Hw);
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const c = this.paint._values["fill-outline-color"];
            c.value.kind === "constant" && c.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new Ff(t);
          }
          queryRadius() {
            return Bh(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: r, transform: c, pixelsToTileUnits: f }) {
            return Wv(Oh(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -c.bearingInRadians, f), r);
          }
          isTileClipped() {
            return true;
          }
        }
        const Yw = Cn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Kw = Cn([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Jw } = Yw;
        class wc {
          constructor(t, r, c, f, _) {
            this.properties = {}, this.extent = c, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = f, this._values = _, t.readFields(Qw, this, r);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos, c = [];
            let f, _ = 1, b = 0, C = 0, P = 0;
            for (; t.pos < r; ) {
              if (b <= 0) {
                const E = t.readVarint();
                _ = 7 & E, b = E >> 3;
              }
              if (b--, _ === 1 || _ === 2) C += t.readSVarint(), P += t.readSVarint(), _ === 1 && (f && c.push(f), f = []), f && f.push(new w(C, P));
              else {
                if (_ !== 7) throw new Error(`unknown command ${_}`);
                f && f.push(f[0].clone());
              }
            }
            return f && c.push(f), c;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let c = 1, f = 0, _ = 0, b = 0, C = 1 / 0, P = -1 / 0, E = 1 / 0, A = -1 / 0;
            for (; t.pos < r; ) {
              if (f <= 0) {
                const B = t.readVarint();
                c = 7 & B, f = B >> 3;
              }
              if (f--, c === 1 || c === 2) _ += t.readSVarint(), b += t.readSVarint(), _ < C && (C = _), _ > P && (P = _), b < E && (E = b), b > A && (A = b);
              else if (c !== 7) throw new Error(`unknown command ${c}`);
            }
            return [C, E, P, A];
          }
          toGeoJSON(t, r, c) {
            const f = this.extent * Math.pow(2, c), _ = this.extent * t, b = this.extent * r, C = this.loadGeometry();
            function P(U) {
              return [360 * (U.x + _) / f - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (U.y + b) / f) * Math.PI)) - 90];
            }
            function E(U) {
              return U.map(P);
            }
            let A;
            if (this.type === 1) {
              const U = [];
              for (const J of C) U.push(J[0]);
              const H = E(U);
              A = U.length === 1 ? { type: "Point", coordinates: H[0] } : { type: "MultiPoint", coordinates: H };
            } else if (this.type === 2) {
              const U = C.map(E);
              A = U.length === 1 ? { type: "LineString", coordinates: U[0] } : { type: "MultiLineString", coordinates: U };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const U = (function(J) {
                  const ie = J.length;
                  if (ie <= 1) return [J];
                  const le = [];
                  let me, Oe;
                  for (let Se = 0; Se < ie; Se++) {
                    const Ee = e2(J[Se]);
                    Ee !== 0 && (Oe === void 0 && (Oe = Ee < 0), Oe === Ee < 0 ? (me && le.push(me), me = [J[Se]]) : me && me.push(J[Se]));
                  }
                  return me && le.push(me), le;
                })(C), H = [];
                for (const J of U) H.push(J.map(E));
                A = H.length === 1 ? { type: "Polygon", coordinates: H[0] } : { type: "MultiPolygon", coordinates: H };
              }
            }
            const B = { type: "Feature", geometry: A, properties: this.properties };
            return this.id != null && (B.id = this.id), B;
          }
        }
        function Qw(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? (function(c, f) {
            const _ = c.readVarint() + c.pos;
            for (; c.pos < _; ) {
              const b = f._keys[c.readVarint()], C = f._values[c.readVarint()];
              f.properties[b] = C;
            }
          })(r, t) : n === 3 ? t.type = r.readVarint() : n === 4 && (t._geometry = r.pos);
        }
        function e2(n) {
          let t = 0;
          for (let r, c, f = 0, _ = n.length, b = _ - 1; f < _; b = f++) r = n[f], c = n[b], t += (c.x - r.x) * (r.y + c.y);
          return t;
        }
        wc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class my {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(t2, this, r), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new wc(this._pbf, r, this.extent, this._keys, this._values);
          }
        }
        function t2(n, t, r) {
          n === 15 ? t.version = r.readVarint() : n === 1 ? t.name = r.readString() : n === 5 ? t.extent = r.readVarint() : n === 2 ? t._features.push(r.pos) : n === 3 ? t._keys.push(r.readString()) : n === 4 && t._values.push((function(c) {
            let f = null;
            const _ = c.readVarint() + c.pos;
            for (; c.pos < _; ) {
              const b = c.readVarint() >> 3;
              f = b === 1 ? c.readString() : b === 2 ? c.readFloat() : b === 3 ? c.readDouble() : b === 4 ? c.readVarint64() : b === 5 ? c.readVarint() : b === 6 ? c.readSVarint() : b === 7 ? c.readBoolean() : null;
            }
            if (f == null) throw new Error("unknown feature value");
            return f;
          })(r));
        }
        class gy {
          constructor(t, r) {
            this.layers = t.readFields(r2, {}, r);
          }
        }
        function r2(n, t, r) {
          if (n === 3) {
            const c = new my(r, r.readVarint() + r.pos);
            c.length && (t[c.name] = c);
          }
        }
        const Lf = Math.pow(2, 13);
        function nd(n, t, r, c, f, _, b, C) {
          n.emplaceBack(t, r, 2 * Math.floor(c * Lf) + b, f * Lf * 2, _ * Lf * 2, Math.round(C));
        }
        class Bf {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new qe(), this.centroidVertexArray = new we(), this.indexArray = new Kr(), this.programConfigurations = new Bi(t.layers, t.zoom), this.segments = new br(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(t, r, c) {
            this.features = [], this.hasPattern = Rf("fill-extrusion", this.layers, r);
            for (const { feature: f, id: _, index: b, sourceLayerIndex: C } of t) {
              const P = this.layers[0]._featureFilter.needGeometry, E = $o(f, P);
              if (!this.layers[0]._featureFilter.filter(new rn(this.zoom, { globalState: this.globalState }), E, c)) continue;
              const A = { id: _, sourceLayerIndex: C, index: b, geometry: P ? E.geometry : as(f), properties: f.properties, type: f.type, patterns: {} };
              this.hasPattern ? this.features.push(zf("fill-extrusion", this.layers, A, this.zoom, r)) : this.addFeature(A, A.geometry, b, c, {}, r.subdivisionGranularity), r.featureIndex.insert(f, A.geometry, b, C, this.index, true);
            }
          }
          addFeatures(t, r, c) {
            for (const f of this.features) {
              const { geometry: _ } = f;
              this.addFeature(f, _, f.index, r, c, t.subdivisionGranularity);
            }
          }
          update(t, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, { imagePositions: c, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Jw), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Kw.members, true), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, r, c, f, _, b) {
            for (const C of Wa(r, 500)) {
              const P = { x: 0, y: 0, sampleCount: 0 }, E = this.layoutVertexArray.length;
              this.processPolygon(P, f, t, C, b);
              const A = this.layoutVertexArray.length - E, B = Math.floor(P.x / P.sampleCount), U = Math.floor(P.y / P.sampleCount);
              for (let H = 0; H < A; H++) this.centroidVertexArray.emplaceBack(B, U);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, { imagePositions: _, canonical: f, globalState: this.globalState });
          }
          processPolygon(t, r, c, f, _) {
            if (f.length < 1 || vy(f[0])) return;
            for (const B of f) B.length !== 0 && n2(t, B);
            const b = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, C = _.fill.getGranularityForZoomLevel(r.z), P = wc.types[c.type] === "Polygon";
            for (const B of f) {
              if (B.length === 0 || vy(B)) continue;
              const U = cl(B, C, P);
              this._generateSideFaces(U, b);
            }
            if (!P) return;
            const E = dy(f, r, C, false), A = this.layoutVertexArray;
            hy(((B, U) => {
              nd(A, B, U, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, E.verticesFlattened, E.indicesTriangles);
          }
          _generateSideFaces(t, r) {
            let c = 0;
            for (let f = 1; f < t.length; f++) {
              const _ = t[f], b = t[f - 1];
              if (i2(_, b)) continue;
              r.segment.vertexLength + 4 > br.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const C = _.sub(b)._perp()._unit(), P = b.dist(_);
              c + P > 32768 && (c = 0), nd(this.layoutVertexArray, _.x, _.y, C.x, C.y, 0, 0, c), nd(this.layoutVertexArray, _.x, _.y, C.x, C.y, 0, 1, c), c += P, nd(this.layoutVertexArray, b.x, b.y, C.x, C.y, 0, 0, c), nd(this.layoutVertexArray, b.x, b.y, C.x, C.y, 0, 1, c);
              const E = r.segment.vertexLength;
              this.indexArray.emplaceBack(E, E + 2, E + 1), this.indexArray.emplaceBack(E + 1, E + 2, E + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2;
            }
          }
        }
        function n2(n, t) {
          for (let r = 0; r < t.length; r++) {
            const c = t[r];
            r === t.length - 1 && t[0].x === c.x && t[0].y === c.y || (n.x += c.x, n.y += c.y, n.sampleCount++);
          }
        }
        function i2(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > Ye) || n.y === t.y && (n.y < 0 || n.y > Ye);
        }
        function vy(n) {
          return n.every(((t) => t.x < 0)) || n.every(((t) => t.x > Ye)) || n.every(((t) => t.y < 0)) || n.every(((t) => t.y > Ye));
        }
        let yy;
        Bt("FillExtrusionBucket", Bf, { omit: ["layers", "features"] });
        var o2 = { get paint() {
          return yy = yy || new pi({ "fill-extrusion-opacity": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new sr(Te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new dc(Te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new sr(Te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new sr(Te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class s2 extends Zi {
          constructor(t) {
            super(t, o2);
          }
          createBucket(t) {
            return new Bf(t);
          }
          queryRadius() {
            return Bh(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: c, geometry: f, transform: _, pixelsToTileUnits: b, pixelPosMatrix: C }) {
            const P = Oh(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -_.bearingInRadians, b), E = this.paint.get("fill-extrusion-height").evaluate(r, c), A = this.paint.get("fill-extrusion-base").evaluate(r, c), B = (function(H, J) {
              const ie = [];
              for (const le of H) {
                const me = [le.x, le.y, 0, 1];
                Pe(me, me, J), ie.push(new w(me[0] / me[3], me[1] / me[3]));
              }
              return ie;
            })(P, C), U = (function(H, J, ie, le) {
              const me = [], Oe = [], Se = le[8] * J, Ee = le[9] * J, He = le[10] * J, rt = le[11] * J, _t = le[8] * ie, Ft = le[9] * ie, Mt = le[10] * ie, zt = le[11] * ie;
              for (const Jt of H) {
                const Rt = [], At = [];
                for (const dt of Jt) {
                  const cr = dt.x, mr = dt.y, nr = le[0] * cr + le[4] * mr + le[12], Ht = le[1] * cr + le[5] * mr + le[13], Rr = le[2] * cr + le[6] * mr + le[14], bn = le[3] * cr + le[7] * mr + le[15], Bn = Rr + He, li = bn + rt, ho = nr + _t, $i = Ht + Ft, Yn = Rr + Mt, mn = bn + zt, Gn = new w((nr + Se) / li, (Ht + Ee) / li);
                  Gn.z = Bn / li, Rt.push(Gn);
                  const Kn = new w(ho / mn, $i / mn);
                  Kn.z = Yn / mn, At.push(Kn);
                }
                me.push(Rt), Oe.push(At);
              }
              return [me, Oe];
            })(f, A, E, C);
            return (function(H, J, ie) {
              let le = 1 / 0;
              Wv(ie, J) && (le = _y(ie, J[0]));
              for (let me = 0; me < J.length; me++) {
                const Oe = J[me], Se = H[me];
                for (let Ee = 0; Ee < Oe.length - 1; Ee++) {
                  const He = Oe[Ee], rt = [He, Oe[Ee + 1], Se[Ee + 1], Se[Ee], He];
                  Gv(ie, rt) && (le = Math.min(le, _y(ie, rt)));
                }
              }
              return le !== 1 / 0 && le;
            })(U[0], U[1], B);
          }
        }
        function id(n, t) {
          return n.x * t.x + n.y * t.y;
        }
        function _y(n, t) {
          if (n.length === 1) {
            let r = 0;
            const c = t[r++];
            let f;
            for (; !f || c.equals(f); ) if (f = t[r++], !f) return 1 / 0;
            for (; r < t.length; r++) {
              const _ = t[r], b = n[0], C = f.sub(c), P = _.sub(c), E = b.sub(c), A = id(C, C), B = id(C, P), U = id(P, P), H = id(E, C), J = id(E, P), ie = A * U - B * B, le = (U * H - B * J) / ie, me = (A * J - B * H) / ie, Oe = c.z * (1 - le - me) + f.z * le + _.z * me;
              if (isFinite(Oe)) return Oe;
            }
            return 1 / 0;
          }
          {
            let r = 1 / 0;
            for (const c of t) r = Math.min(r, c.z);
            return r;
          }
        }
        const a2 = Cn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: l2 } = a2, c2 = Cn([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: u2 } = c2, d2 = Math.cos(Math.PI / 180 * 37.5), by = Math.pow(2, 14) / 0.5;
        class Of {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((r) => {
              this.gradients[r.id] = {};
            })), this.layoutVertexArray = new Ze(), this.layoutVertexArray2 = new Je(), this.indexArray = new Kr(), this.programConfigurations = new Bi(t.layers, t.zoom), this.segments = new br(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(t, r, c) {
            this.hasPattern = Rf("line", this.layers, r);
            const f = this.layers[0].layout.get("line-sort-key"), _ = !f.isConstant(), b = [];
            for (const { feature: C, id: P, index: E, sourceLayerIndex: A } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, U = $o(C, B);
              if (!this.layers[0]._featureFilter.filter(new rn(this.zoom, { globalState: this.globalState }), U, c)) continue;
              const H = _ ? f.evaluate(U, {}, c) : void 0, J = { id: P, properties: C.properties, type: C.type, sourceLayerIndex: A, index: E, geometry: B ? U.geometry : as(C), patterns: {}, sortKey: H };
              b.push(J);
            }
            _ && b.sort(((C, P) => C.sortKey - P.sortKey));
            for (const C of b) {
              const { geometry: P, index: E, sourceLayerIndex: A } = C;
              if (this.hasPattern) {
                const B = zf("line", this.layers, C, this.zoom, r);
                this.patternFeatures.push(B);
              } else this.addFeature(C, P, E, c, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[E].feature, P, E, A, this.index);
            }
          }
          update(t, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, { imagePositions: c, globalState: this.globalState });
          }
          addFeatures(t, r, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, c, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, u2)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, l2), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, r, c, f, _, b) {
            const C = this.layers[0].layout, P = C.get("line-join").evaluate(t, {}), E = C.get("line-cap"), A = C.get("line-miter-limit"), B = C.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const U of r) this.addLine(U, t, P, E, A, B, f, b);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, c, { imagePositions: _, canonical: f, globalState: this.globalState });
          }
          addLine(t, r, c, f, _, b, C, P) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = cl(t, C ? P.line.getGranularityForZoomLevel(C.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Se = 0; Se < t.length - 1; Se++) this.totalDistance += t[Se].dist(t[Se + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const E = wc.types[r.type] === "Polygon";
            let A = t.length;
            for (; A >= 2 && t[A - 1].equals(t[A - 2]); ) A--;
            let B = 0;
            for (; B < A - 1 && t[B].equals(t[B + 1]); ) B++;
            if (A < (E ? 3 : 2)) return;
            c === "bevel" && (_ = 1.05);
            const U = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, H = this.segments.prepareSegment(10 * A, this.layoutVertexArray, this.indexArray);
            let J, ie, le, me, Oe;
            this.e1 = this.e2 = -1, E && (J = t[A - 2], Oe = t[B].sub(J)._unit()._perp());
            for (let Se = B; Se < A; Se++) {
              if (le = Se === A - 1 ? E ? t[B + 1] : void 0 : t[Se + 1], le && t[Se].equals(le)) continue;
              Oe && (me = Oe), J && (ie = J), J = t[Se], Oe = le ? le.sub(J)._unit()._perp() : me, me = me || Oe;
              let Ee = me.add(Oe);
              Ee.x === 0 && Ee.y === 0 || Ee._unit();
              const He = me.x * Oe.x + me.y * Oe.y, rt = Ee.x * Oe.x + Ee.y * Oe.y, _t = rt !== 0 ? 1 / rt : 1 / 0, Ft = 2 * Math.sqrt(2 - 2 * rt), Mt = rt < d2 && ie && le, zt = me.x * Oe.y - me.y * Oe.x > 0;
              if (Mt && Se > B) {
                const At = J.dist(ie);
                if (At > 2 * U) {
                  const dt = J.sub(J.sub(ie)._mult(U / At)._round());
                  this.updateDistance(ie, dt), this.addCurrentVertex(dt, me, 0, 0, H), ie = dt;
                }
              }
              const Jt = ie && le;
              let Rt = Jt ? c : E ? "butt" : f;
              if (Jt && Rt === "round" && (_t < b ? Rt = "miter" : _t <= 2 && (Rt = "fakeround")), Rt === "miter" && _t > _ && (Rt = "bevel"), Rt === "bevel" && (_t > 2 && (Rt = "flipbevel"), _t < _ && (Rt = "miter")), ie && this.updateDistance(ie, J), Rt === "miter") Ee._mult(_t), this.addCurrentVertex(J, Ee, 0, 0, H);
              else if (Rt === "flipbevel") {
                if (_t > 100) Ee = Oe.mult(-1);
                else {
                  const At = _t * me.add(Oe).mag() / me.sub(Oe).mag();
                  Ee._perp()._mult(At * (zt ? -1 : 1));
                }
                this.addCurrentVertex(J, Ee, 0, 0, H), this.addCurrentVertex(J, Ee.mult(-1), 0, 0, H);
              } else if (Rt === "bevel" || Rt === "fakeround") {
                const At = -Math.sqrt(_t * _t - 1), dt = zt ? At : 0, cr = zt ? 0 : At;
                if (ie && this.addCurrentVertex(J, me, dt, cr, H), Rt === "fakeround") {
                  const mr = Math.round(180 * Ft / Math.PI / 20);
                  for (let nr = 1; nr < mr; nr++) {
                    let Ht = nr / mr;
                    if (Ht !== 0.5) {
                      const bn = Ht - 0.5;
                      Ht += Ht * bn * (Ht - 1) * ((1.0904 + He * (He * (3.55645 - 1.43519 * He) - 3.2452)) * bn * bn + (0.848013 + He * (0.215638 * He - 1.06021)));
                    }
                    const Rr = Oe.sub(me)._mult(Ht)._add(me)._unit()._mult(zt ? -1 : 1);
                    this.addHalfVertex(J, Rr.x, Rr.y, false, zt, 0, H);
                  }
                }
                le && this.addCurrentVertex(J, Oe, -dt, -cr, H);
              } else if (Rt === "butt") this.addCurrentVertex(J, Ee, 0, 0, H);
              else if (Rt === "square") {
                const At = ie ? 1 : -1;
                this.addCurrentVertex(J, Ee, At, At, H);
              } else Rt === "round" && (ie && (this.addCurrentVertex(J, me, 0, 0, H), this.addCurrentVertex(J, me, 1, 1, H, true)), le && (this.addCurrentVertex(J, Oe, -1, -1, H, true), this.addCurrentVertex(J, Oe, 0, 0, H)));
              if (Mt && Se < A - 1) {
                const At = J.dist(le);
                if (At > 2 * U) {
                  const dt = J.add(le.sub(J)._mult(U / At)._round());
                  this.updateDistance(J, dt), this.addCurrentVertex(dt, Oe, 0, 0, H), J = dt;
                }
              }
            }
          }
          addCurrentVertex(t, r, c, f, _, b = false) {
            const C = r.y * f - r.x, P = -r.y - r.x * f;
            this.addHalfVertex(t, r.x + r.y * c, r.y - r.x * c, b, false, c, _), this.addHalfVertex(t, C, P, b, true, -f, _), this.distance > by / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, c, f, _, b));
          }
          addHalfVertex({ x: t, y: r }, c, f, _, b, C, P) {
            const E = 0.5 * (this.lineClips ? this.scaledDistance * (by - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (_ ? 1 : 0), (r << 1) + (b ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * f) + 128, 1 + (C === 0 ? 0 : C < 0 ? -1 : 1) | (63 & E) << 2, E >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const A = P.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, A, this.e2), P.primitiveLength++), b ? this.e2 = A : this.e1 = A;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance();
          }
        }
        let xy, wy;
        Bt("LineBucket", Of, { omit: ["layers", "patternFeatures"] });
        var Cy = { get paint() {
          return wy = wy || new pi({ "line-opacity": new sr(Te.paint_line["line-opacity"]), "line-color": new sr(Te.paint_line["line-color"]), "line-translate": new Xt(Te.paint_line["line-translate"]), "line-translate-anchor": new Xt(Te.paint_line["line-translate-anchor"]), "line-width": new sr(Te.paint_line["line-width"]), "line-gap-width": new sr(Te.paint_line["line-gap-width"]), "line-offset": new sr(Te.paint_line["line-offset"]), "line-blur": new sr(Te.paint_line["line-blur"]), "line-dasharray": new rs(Te.paint_line["line-dasharray"]), "line-pattern": new dc(Te.paint_line["line-pattern"]), "line-gradient": new hc(Te.paint_line["line-gradient"]) });
        }, get layout() {
          return xy = xy || new pi({ "line-cap": new Xt(Te.layout_line["line-cap"]), "line-join": new sr(Te.layout_line["line-join"]), "line-miter-limit": new Xt(Te.layout_line["line-miter-limit"]), "line-round-limit": new Xt(Te.layout_line["line-round-limit"]), "line-sort-key": new sr(Te.layout_line["line-sort-key"]) });
        } };
        class h2 extends sr {
          possiblyEvaluate(t, r) {
            return r = new rn(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(t, r);
          }
          evaluate(t, r, c, f) {
            return r = er({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(t, r, c, f);
          }
        }
        let Vh;
        class p2 extends Zi {
          constructor(t) {
            super(t, Cy), this.gradientVersion = 0, Vh || (Vh = new h2(Cy.paint.properties["line-width"].specification), Vh.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(c) {
                return c._styleExpression !== void 0;
              })(r) && r._styleExpression.expression instanceof wn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = Vh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new Of(t);
          }
          queryRadius(t) {
            const r = t, c = Sy(Xu("line-width", this, r), Xu("line-gap-width", this, r)), f = Xu("line-offset", this, r);
            return c / 2 + Math.abs(f) + Bh(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: r, featureState: c, geometry: f, transform: _, pixelsToTileUnits: b }) {
            const C = Oh(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -_.bearingInRadians, b), P = b / 2 * Sy(this.paint.get("line-width").evaluate(r, c), this.paint.get("line-gap-width").evaluate(r, c)), E = this.paint.get("line-offset").evaluate(r, c);
            return E && (f = (function(A, B) {
              const U = [];
              for (let H = 0; H < A.length; H++) {
                const J = A[H], ie = [];
                for (let le = 0; le < J.length; le++) {
                  const me = J[le - 1], Oe = J[le], Se = J[le + 1], Ee = le === 0 ? new w(0, 0) : Oe.sub(me)._unit()._perp(), He = le === J.length - 1 ? new w(0, 0) : Se.sub(Oe)._unit()._perp(), rt = Ee._add(He)._unit(), _t = rt.x * He.x + rt.y * He.y;
                  _t !== 0 && rt._mult(1 / _t), ie.push(rt._mult(B)._add(Oe));
                }
                U.push(ie);
              }
              return U;
            })(f, E * b)), (function(A, B, U) {
              for (let H = 0; H < B.length; H++) {
                const J = B[H];
                if (A.length >= 3) {
                  for (let ie = 0; ie < J.length; ie++) if (yc(A, J[ie])) return true;
                }
                if (Sw(A, J, U)) return true;
              }
              return false;
            })(C, f, P);
          }
          isTileClipped() {
            return true;
          }
        }
        function Sy(n, t) {
          return t > 0 ? t + 2 * n : n;
        }
        const f2 = Cn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), m2 = Cn([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Cn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const g2 = Cn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Cn([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const ky = Cn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), v2 = Cn([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function y2(n, t, r) {
          return n.sections.forEach(((c) => {
            c.text = (function(f, _, b) {
              const C = _.layout.get("text-transform").evaluate(b, {});
              return C === "uppercase" ? f = f.toLocaleUpperCase() : C === "lowercase" && (f = f.toLocaleLowerCase()), so.applyArabicShaping && (f = so.applyArabicShaping(f)), f;
            })(c.text, t, r);
          })), n;
        }
        Cn([{ name: "triangle", components: 3, type: "Uint16" }]), Cn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Cn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Cn([{ type: "Float32", name: "offsetX" }]), Cn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Cn([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const od = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var qn = 24;
        const $f = 4294967296, Py = 1 / $f, Ty = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class jf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, r, c = this.length) {
            for (; this.pos < c; ) {
              const f = this.readVarint(), _ = f >> 3, b = this.pos;
              this.type = 7 & f, t(_, r, this), this.pos === b && this.skip(f);
            }
            return r;
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * $f;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * $f;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const r = this.buf;
            let c, f;
            return f = r[this.pos++], c = 127 & f, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 7, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 14, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 21, f < 128 ? c : (f = r[this.pos], c |= (15 & f) << 28, (function(_, b, C) {
              const P = C.buf;
              let E, A;
              if (A = P[C.pos++], E = (112 & A) >> 4, A < 128 || (A = P[C.pos++], E |= (127 & A) << 3, A < 128) || (A = P[C.pos++], E |= (127 & A) << 10, A < 128) || (A = P[C.pos++], E |= (127 & A) << 17, A < 128) || (A = P[C.pos++], E |= (127 & A) << 24, A < 128) || (A = P[C.pos++], E |= (1 & A) << 31, A < 128)) return Cc(_, E, b);
              throw new Error("Expected varint not more than 10 bytes");
            })(c, t, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, r = this.pos;
            return this.pos = t, t - r >= 12 && Ty ? Ty.decode(this.buf.subarray(r, t)) : (function(c, f, _) {
              let b = "", C = f;
              for (; C < _; ) {
                const P = c[C];
                let E, A, B, U = null, H = P > 239 ? 4 : P > 223 ? 3 : P > 191 ? 2 : 1;
                if (C + H > _) break;
                H === 1 ? P < 128 && (U = P) : H === 2 ? (E = c[C + 1], (192 & E) == 128 && (U = (31 & P) << 6 | 63 & E, U <= 127 && (U = null))) : H === 3 ? (E = c[C + 1], A = c[C + 2], (192 & E) == 128 && (192 & A) == 128 && (U = (15 & P) << 12 | (63 & E) << 6 | 63 & A, (U <= 2047 || U >= 55296 && U <= 57343) && (U = null))) : H === 4 && (E = c[C + 1], A = c[C + 2], B = c[C + 3], (192 & E) == 128 && (192 & A) == 128 && (192 & B) == 128 && (U = (15 & P) << 18 | (63 & E) << 12 | (63 & A) << 6 | 63 & B, (U <= 65535 || U >= 1114112) && (U = null))), U === null ? (U = 65533, H = 1) : U > 65535 && (U -= 65536, b += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), b += String.fromCharCode(U), C += H;
              }
              return b;
            })(this.buf, r, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, r = this.buf.subarray(this.pos, t);
            return this.pos = t, r;
          }
          readPackedVarint(t = [], r) {
            const c = this.readPackedEnd();
            for (; this.pos < c; ) t.push(this.readVarint(r));
            return t;
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8;
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r);
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t; ) r *= 2;
            if (r !== this.length) {
              const c = new Uint8Array(r);
              c.set(this.buf), this.buf = c, this.dataView = new DataView(c.buffer), this.length = r;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * Py), true), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * Py), true), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, c) {
              let f, _;
              if (r >= 0 ? (f = r % 4294967296 | 0, _ = r / 4294967296 | 0) : (f = ~(-r % 4294967296), _ = ~(-r / 4294967296), 4294967295 ^ f ? f = f + 1 | 0 : (f = 0, _ = _ + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              c.realloc(10), (function(b, C, P) {
                P.buf[P.pos++] = 127 & b | 128, b >>>= 7, P.buf[P.pos++] = 127 & b | 128, b >>>= 7, P.buf[P.pos++] = 127 & b | 128, b >>>= 7, P.buf[P.pos++] = 127 & b | 128, P.buf[P.pos] = 127 & (b >>>= 7);
              })(f, 0, c), (function(b, C) {
                const P = (7 & b) << 4;
                C.buf[C.pos++] |= P | ((b >>>= 3) ? 128 : 0), b && (C.buf[C.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (C.buf[C.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (C.buf[C.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (C.buf[C.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (C.buf[C.pos++] = 127 & b)))));
              })(_, c);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(f, _, b) {
              for (let C, P, E = 0; E < _.length; E++) {
                if (C = _.charCodeAt(E), C > 55295 && C < 57344) {
                  if (!P) {
                    C > 56319 || E + 1 === _.length ? (f[b++] = 239, f[b++] = 191, f[b++] = 189) : P = C;
                    continue;
                  }
                  if (C < 56320) {
                    f[b++] = 239, f[b++] = 191, f[b++] = 189, P = C;
                    continue;
                  }
                  C = P - 55296 << 10 | C - 56320 | 65536, P = null;
                } else P && (f[b++] = 239, f[b++] = 191, f[b++] = 189, P = null);
                C < 128 ? f[b++] = C : (C < 2048 ? f[b++] = C >> 6 | 192 : (C < 65536 ? f[b++] = C >> 12 | 224 : (f[b++] = C >> 18 | 240, f[b++] = C >> 12 & 63 | 128), f[b++] = C >> 6 & 63 | 128), f[b++] = 63 & C | 128);
              }
              return b;
            })(this.buf, t, this.pos);
            const c = this.pos - r;
            c >= 128 && My(r, c, this), this.pos = r - 1, this.writeVarint(c), this.pos += c;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let c = 0; c < r; c++) this.buf[this.pos++] = t[c];
          }
          writeRawMessage(t, r) {
            this.pos++;
            const c = this.pos;
            t(r, this);
            const f = this.pos - c;
            f >= 128 && My(c, f, this), this.pos = c - 1, this.writeVarint(f), this.pos += f;
          }
          writeMessage(t, r, c) {
            this.writeTag(t, 2), this.writeRawMessage(r, c);
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, _2, r);
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, b2, r);
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, C2, r);
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, x2, r);
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, w2, r);
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, S2, r);
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, k2, r);
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, P2, r);
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, T2, r);
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r);
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r);
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r);
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r);
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r);
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r);
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r);
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r);
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r);
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r);
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r);
          }
        }
        function Cc(n, t, r) {
          return r ? 4294967296 * t + (n >>> 0) : 4294967296 * (t >>> 0) + (n >>> 0);
        }
        function My(n, t, r) {
          const c = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(c);
          for (let f = r.pos - 1; f >= n; f--) r.buf[f + c] = r.buf[f];
        }
        function _2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeVarint(n[r]);
        }
        function b2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSVarint(n[r]);
        }
        function x2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFloat(n[r]);
        }
        function w2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeDouble(n[r]);
        }
        function C2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeBoolean(n[r]);
        }
        function S2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed32(n[r]);
        }
        function k2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r]);
        }
        function P2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeFixed64(n[r]);
        }
        function T2(n, t) {
          for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r]);
        }
        function M2(n, t, r) {
          n === 1 && r.readMessage(I2, t);
        }
        function I2(n, t, r) {
          if (n === 3) {
            const { id: c, bitmap: f, width: _, height: b, left: C, top: P, advance: E } = r.readMessage(E2, {});
            t.push({ id: c, bitmap: new Yu({ width: _ + 6, height: b + 6 }, f), metrics: { width: _, height: b, left: C, top: P, advance: E } });
          }
        }
        function E2(n, t, r) {
          n === 1 ? t.id = r.readVarint() : n === 2 ? t.bitmap = r.readBytes() : n === 3 ? t.width = r.readVarint() : n === 4 ? t.height = r.readVarint() : n === 5 ? t.left = r.readSVarint() : n === 6 ? t.top = r.readSVarint() : n === 7 && (t.advance = r.readVarint());
        }
        function Iy(n) {
          let t = 0, r = 0;
          for (const b of n) t += b.w * b.h, r = Math.max(r, b.w);
          n.sort(((b, C) => C.h - b.h));
          const c = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), r), h: 1 / 0 }];
          let f = 0, _ = 0;
          for (const b of n) for (let C = c.length - 1; C >= 0; C--) {
            const P = c[C];
            if (!(b.w > P.w || b.h > P.h)) {
              if (b.x = P.x, b.y = P.y, _ = Math.max(_, b.y + b.h), f = Math.max(f, b.x + b.w), b.w === P.w && b.h === P.h) {
                const E = c.pop();
                E && C < c.length && (c[C] = E);
              } else b.h === P.h ? (P.x += b.w, P.w -= b.w) : b.w === P.w ? (P.y += b.h, P.h -= b.h) : (c.push({ x: P.x + b.w, y: P.y, w: P.w - b.w, h: b.h }), P.y += b.h, P.h -= b.h);
              break;
            }
          }
          return { w: f, h: _, fill: t / (f * _) || 0 };
        }
        class Nf {
          constructor(t, { pixelRatio: r, version: c, stretchX: f, stretchY: _, content: b, textFitWidth: C, textFitHeight: P }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = f, this.stretchY = _, this.content = b, this.version = c, this.textFitWidth = C, this.textFitHeight = P;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Ey {
          constructor(t, r) {
            const c = {}, f = {};
            this.haveRenderCallbacks = [];
            const _ = [];
            this.addImages(t, c, _), this.addImages(r, f, _);
            const { w: b, h: C } = Iy(_), P = new Oi({ width: b || 1, height: C || 1 });
            for (const E in t) {
              const A = t[E], B = c[E].paddedRect;
              Oi.copy(A.data, P, { x: 0, y: 0 }, { x: B.x + 1, y: B.y + 1 }, A.data);
            }
            for (const E in r) {
              const A = r[E], B = f[E].paddedRect, U = B.x + 1, H = B.y + 1, J = A.data.width, ie = A.data.height;
              Oi.copy(A.data, P, { x: 0, y: 0 }, { x: U, y: H }, A.data), Oi.copy(A.data, P, { x: 0, y: ie - 1 }, { x: U, y: H - 1 }, { width: J, height: 1 }), Oi.copy(A.data, P, { x: 0, y: 0 }, { x: U, y: H + ie }, { width: J, height: 1 }), Oi.copy(A.data, P, { x: J - 1, y: 0 }, { x: U - 1, y: H }, { width: 1, height: ie }), Oi.copy(A.data, P, { x: 0, y: 0 }, { x: U + J, y: H }, { width: 1, height: ie });
            }
            this.image = P, this.iconPositions = c, this.patternPositions = f;
          }
          addImages(t, r, c) {
            for (const f in t) {
              const _ = t[f], b = { x: 0, y: 0, w: _.data.width + 2, h: _.data.height + 2 };
              c.push(b), r[f] = new Nf(b, _), _.hasRenderCallback && this.haveRenderCallbacks.push(f);
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const c in t.updatedImages) this.patchUpdatedImage(this.iconPositions[c], t.getImage(c), r), this.patchUpdatedImage(this.patternPositions[c], t.getImage(c), r);
          }
          patchUpdatedImage(t, r, c) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [f, _] = t.tl;
            c.update(r.data, void 0, { x: f, y: _ });
          }
        }
        var fa;
        Bt("ImagePosition", Nf), Bt("ImageAtlas", Ey), p.ao = void 0, (fa = p.ao || (p.ao = {}))[fa.none = 0] = "none", fa[fa.horizontal = 1] = "horizontal", fa[fa.vertical = 2] = "vertical", fa[fa.horizontalOnly = 3] = "horizontalOnly";
        class sd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, r, c) {
            const f = new sd();
            return f.scale = t || 1, f.fontStack = r, f.verticalAlign = c || "bottom", f;
          }
          static forImage(t, r) {
            const c = new sd();
            return c.imageName = t, c.verticalAlign = r || "bottom", c;
          }
        }
        class Sc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, r) {
            const c = new Sc();
            for (let f = 0; f < t.sections.length; f++) {
              const _ = t.sections[f];
              _.image ? c.addImageSection(_) : c.addTextSection(_, r);
            }
            return c;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let c = 0; c < t.length; c++) {
                const f = t.charCodeAt(c + 1) || null, _ = t.charCodeAt(c - 1) || null;
                r += f && Mh(f) && !od[t[c + 1]] || _ && Mh(_) && !od[t[c - 1]] || !od[t[c]] ? t[c] : od[t[c]];
              }
              return r;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let c = 0; c < this.text.length && qh[this.text.charCodeAt(c)]; c++) t++;
            let r = this.text.length;
            for (let c = this.text.length - 1; c >= 0 && c >= t && qh[this.text.charCodeAt(c)]; c--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);
          }
          substring(t, r) {
            const c = new Sc();
            return c.text = this.text.substring(t, r), c.sectionIndex = this.sectionIndex.slice(t, r), c.sections = this.sections, c;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0);
          }
          getMaxImageSize(t) {
            let r = 0, c = 0;
            for (let f = 0; f < this.length(); f++) {
              const _ = this.getSection(f);
              if (_.imageName) {
                const b = t[_.imageName];
                if (!b) continue;
                const C = b.displaySize;
                r = Math.max(r, C[0]), c = Math.max(c, C[1]);
              }
            }
            return { maxImageWidth: r, maxImageHeight: c };
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(sd.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const c = this.sections.length - 1;
            for (let f = 0; f < t.text.length; ++f) this.sectionIndex.push(c);
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void Ct("Can't add FormattedSection with an empty image.");
            const c = this.getNextImageSectionCharCode();
            c ? (this.text += String.fromCharCode(c), this.sections.push(sd.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Ct("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Uh(n, t, r, c, f, _, b, C, P, E, A, B, U, H, J) {
          const ie = Sc.fromFeature(n, f);
          let le;
          B === p.ao.vertical && ie.verticalizePunctuation();
          const { processBidirectionalText: me, processStyledBidirectionalText: Oe } = so;
          if (me && ie.sections.length === 1) {
            le = [];
            const He = me(ie.toString(), Vf(ie, E, _, t, c, H));
            for (const rt of He) {
              const _t = new Sc();
              _t.text = rt, _t.sections = ie.sections;
              for (let Ft = 0; Ft < rt.length; Ft++) _t.sectionIndex.push(0);
              le.push(_t);
            }
          } else if (Oe) {
            le = [];
            const He = Oe(ie.text, ie.sectionIndex, Vf(ie, E, _, t, c, H));
            for (const rt of He) {
              const _t = new Sc();
              _t.text = rt[0], _t.sectionIndex = rt[1], _t.sections = ie.sections, le.push(_t);
            }
          } else le = (function(He, rt) {
            const _t = [], Ft = He.text;
            let Mt = 0;
            for (const zt of rt) _t.push(He.substring(Mt, zt)), Mt = zt;
            return Mt < Ft.length && _t.push(He.substring(Mt, Ft.length)), _t;
          })(ie, Vf(ie, E, _, t, c, H));
          const Se = [], Ee = { positionedLines: Se, text: ie.toString(), top: A[1], bottom: A[1], left: A[0], right: A[0], writingMode: B, iconsInText: false, verticalizable: false };
          return (function(He, rt, _t, Ft, Mt, zt, Jt, Rt, At, dt, cr, mr) {
            let nr = 0, Ht = 0, Rr = 0, bn = 0;
            const Bn = Rt === "right" ? 1 : Rt === "left" ? 0 : 0.5, li = qn / mr;
            let ho = 0;
            for (const mn of Mt) {
              mn.trim();
              const Gn = mn.getMaxScale(), Kn = { positionedGlyphs: [], lineOffset: 0 };
              He.positionedLines[ho] = Kn;
              const Jn = Kn.positionedGlyphs;
              let Mi = 0;
              if (!mn.length()) {
                Ht += zt, ++ho;
                continue;
              }
              const po = D2(Ft, mn, li);
              for (let ji = 0; ji < mn.length(); ji++) {
                const On = mn.getSection(ji), Zn = mn.getSectionIndex(ji), Hn = mn.getCharCode(ji), zn = F2(At, cr, Hn);
                let un;
                if (On.imageName) {
                  if (He.iconsInText = true, On.scale = On.scale * li, un = B2(On, zn, Gn, po, Ft), !un) continue;
                  Mi = Math.max(Mi, un.imageOffset);
                } else if (un = L2(On, Hn, zn, po, rt, _t), !un) continue;
                const { rect: jo, metrics: Mc, baselineOffset: No } = un;
                Jn.push({ glyph: Hn, imageName: On.imageName, x: nr, y: Ht + No + -17, vertical: zn, scale: On.scale, fontStack: On.fontStack, sectionIndex: Zn, metrics: Mc, rect: jo }), zn ? (He.verticalizable = true, nr += (On.imageName ? Mc.advance : qn) * On.scale + dt) : nr += Mc.advance * On.scale + dt;
              }
              Jn.length !== 0 && (Rr = Math.max(nr - dt, Rr), O2(Jn, 0, Jn.length - 1, Bn)), nr = 0, Kn.lineOffset = Math.max(Mi, (Gn - 1) * qn);
              const Wn = zt * Gn + Mi;
              Ht += Wn, bn = Math.max(Wn, bn), ++ho;
            }
            const { horizontalAlign: $i, verticalAlign: Yn } = Uf(Jt);
            (function(mn, Gn, Kn, Jn, Mi, po, Wn, ji, On) {
              const Zn = (Gn - Kn) * Mi;
              let Hn = 0;
              Hn = po !== Wn ? -ji * Jn - -17 : -Jn * On * Wn + 0.5 * Wn;
              for (const zn of mn) for (const un of zn.positionedGlyphs) un.x += Zn, un.y += Hn;
            })(He.positionedLines, Bn, $i, Yn, Rr, bn, zt, Ht, Mt.length), He.top += -Yn * Ht, He.bottom = He.top + Ht, He.left += -$i * Rr, He.right = He.left + Rr;
          })(Ee, t, r, c, le, b, C, P, B, E, U, J), !(function(He) {
            for (const rt of He) if (rt.positionedGlyphs.length !== 0) return false;
            return true;
          })(Se) && Ee;
        }
        const qh = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, R2 = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, z2 = { 40: true };
        function Ry(n, t, r, c, f, _) {
          if (t.imageName) {
            const b = c[t.imageName];
            return b ? b.displaySize[0] * t.scale * qn / _ + f : 0;
          }
          {
            const b = r[t.fontStack], C = b && b[n];
            return C ? C.metrics.advance * t.scale + f : 0;
          }
        }
        function zy(n, t, r, c) {
          const f = Math.pow(n - t, 2);
          return c ? n < t ? f / 2 : 2 * f : f + Math.abs(r) * r;
        }
        function A2(n, t, r) {
          let c = 0;
          return n === 10 && (c -= 1e4), r && (c += 150), n !== 40 && n !== 65288 || (c += 50), t !== 41 && t !== 65289 || (c += 50), c;
        }
        function Ay(n, t, r, c, f, _) {
          let b = null, C = zy(t, r, f, _);
          for (const P of c) {
            const E = zy(t - P.x, r, f, _) + P.badness;
            E <= C && (b = P, C = E);
          }
          return { index: n, x: t, priorBreak: b, badness: C };
        }
        function Dy(n) {
          return n ? Dy(n.priorBreak).concat(n.index) : [];
        }
        function Vf(n, t, r, c, f, _) {
          if (!n) return [];
          const b = [], C = (function(B, U, H, J, ie, le) {
            let me = 0;
            for (let Oe = 0; Oe < B.length(); Oe++) {
              const Se = B.getSection(Oe);
              me += Ry(B.getCharCode(Oe), Se, J, ie, U, le);
            }
            return me / Math.max(1, Math.ceil(me / H));
          })(n, t, r, c, f, _), P = n.text.indexOf("\u200B") >= 0;
          let E = 0;
          for (let B = 0; B < n.length(); B++) {
            const U = n.getSection(B), H = n.getCharCode(B);
            if (qh[H] || (E += Ry(H, U, c, f, t, _)), B < n.length() - 1) {
              const J = !((A = H) < 11904) && (!!Er["CJK Compatibility Forms"](A) || !!Er["CJK Compatibility"](A) || !!Er["CJK Strokes"](A) || !!Er["CJK Symbols and Punctuation"](A) || !!Er["Enclosed CJK Letters and Months"](A) || !!Er["Halfwidth and Fullwidth Forms"](A) || !!Er["Ideographic Description Characters"](A) || !!Er["Vertical Forms"](A) || Ou.test(String.fromCodePoint(A)));
              (R2[H] || J || U.imageName || B !== n.length() - 2 && z2[n.getCharCode(B + 1)]) && b.push(Ay(B + 1, E, C, b, A2(H, n.getCharCode(B + 1), J && P), false));
            }
          }
          var A;
          return Dy(Ay(n.length(), E, C, b, 0, true));
        }
        function Uf(n) {
          let t = 0.5, r = 0.5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0;
          }
          return { horizontalAlign: t, verticalAlign: r };
        }
        function D2(n, t, r) {
          const c = t.getMaxScale() * qn, { maxImageWidth: f, maxImageHeight: _ } = t.getMaxImageSize(n), b = Math.max(c, _ * r);
          return { verticalLineContentWidth: Math.max(c, f * r), horizontalLineContentHeight: b };
        }
        function Fy(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function F2(n, t, r) {
          return !(n === p.ao.horizontal || !t && !$u(r) || t && (qh[r] || (c = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(c)))));
          var c;
        }
        function L2(n, t, r, c, f, _) {
          const b = _[n.fontStack], C = (function(E, A, B, U) {
            if (E && E.rect) return E;
            const H = A[B.fontStack], J = H && H[U];
            return J ? { rect: null, metrics: J.metrics } : null;
          })(b && b[t], f, n, t);
          if (C === null) return null;
          let P;
          if (r) P = c.verticalLineContentWidth - n.scale * qn;
          else {
            const E = Fy(n.verticalAlign);
            P = (c.horizontalLineContentHeight - n.scale * qn) * E;
          }
          return { rect: C.rect, metrics: C.metrics, baselineOffset: P };
        }
        function B2(n, t, r, c, f) {
          const _ = f[n.imageName];
          if (!_) return null;
          const b = _.paddedRect, C = _.displaySize, P = { width: C[0], height: C[1], left: 1, top: -3, advance: t ? C[1] : C[0] };
          let E;
          if (t) E = c.verticalLineContentWidth - C[1] * n.scale;
          else {
            const A = Fy(n.verticalAlign);
            E = (c.horizontalLineContentHeight - C[1] * n.scale) * A;
          }
          return { rect: b, metrics: P, baselineOffset: E, imageOffset: (t ? C[0] : C[1]) * n.scale - qn * r };
        }
        function O2(n, t, r, c) {
          if (c === 0) return;
          const f = n[r], _ = (n[r].x + f.metrics.advance * f.scale) * c;
          for (let b = t; b <= r; b++) n[b].x -= _;
        }
        function $2(n, t, r) {
          const { horizontalAlign: c, verticalAlign: f } = Uf(r), _ = t[0] - n.displaySize[0] * c, b = t[1] - n.displaySize[1] * f;
          return { image: n, top: b, bottom: b + n.displaySize[1], left: _, right: _ + n.displaySize[0] };
        }
        function Ly(n) {
          var t, r;
          let c = n.left, f = n.top, _ = n.right - c, b = n.bottom - f;
          const C = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", P = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", E = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (P === "proportional") {
            if (C === "stretchOnly" && _ / b < E || C === "proportional") {
              const A = Math.ceil(b * E);
              c *= A / _, _ = A;
            }
          } else if (C === "proportional" && P === "stretchOnly" && E !== 0 && _ / b > E) {
            const A = Math.ceil(_ / E);
            f *= A / b, b = A;
          }
          return { x1: c, y1: f, x2: c + _, y2: f + b };
        }
        function By(n, t, r, c, f, _) {
          const b = n.image;
          let C;
          if (b.content) {
            const le = b.content, me = b.pixelRatio || 1;
            C = [le[0] / me, le[1] / me, b.displaySize[0] - le[2] / me, b.displaySize[1] - le[3] / me];
          }
          const P = t.left * _, E = t.right * _;
          let A, B, U, H;
          r === "width" || r === "both" ? (H = f[0] + P - c[3], B = f[0] + E + c[1]) : (H = f[0] + (P + E - b.displaySize[0]) / 2, B = H + b.displaySize[0]);
          const J = t.top * _, ie = t.bottom * _;
          return r === "height" || r === "both" ? (A = f[1] + J - c[0], U = f[1] + ie + c[2]) : (A = f[1] + (J + ie - b.displaySize[1]) / 2, U = A + b.displaySize[1]), { image: b, top: A, right: B, bottom: U, left: H, collisionPadding: C };
        }
        const Bs = 128, ma = 32640;
        function Oy(n, t) {
          const { expression: r } = t;
          if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new rn(n + 1)) };
          if (r.kind === "source") return { kind: "source" };
          {
            const { zoomStops: c, interpolationType: f } = r;
            let _ = 0;
            for (; _ < c.length && c[_] <= n; ) _++;
            _ = Math.max(0, _ - 1);
            let b = _;
            for (; b < c.length && c[b] < n + 1; ) b++;
            b = Math.min(c.length - 1, b);
            const C = c[_], P = c[b];
            return r.kind === "composite" ? { kind: "composite", minZoom: C, maxZoom: P, interpolationType: f } : { kind: "camera", minZoom: C, maxZoom: P, minSize: r.evaluate(new rn(C)), maxSize: r.evaluate(new rn(P)), interpolationType: f };
          }
        }
        function qf(n, t, r) {
          let c = "never";
          const f = n.get(t);
          return f ? c = f : n.get(r) && (c = "always"), c;
        }
        const j2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Gh(n, t, r, c, f, _, b, C, P, E, A, B, U) {
          const H = C ? Math.min(ma, Math.round(C[0])) : 0, J = C ? Math.min(ma, Math.round(C[1])) : 0;
          n.emplaceBack(t, r, Math.round(32 * c), Math.round(32 * f), _, b, (H << 1) + (P ? 1 : 0), J, 16 * E, 16 * A, 256 * B, 256 * U);
        }
        function Gf(n, t, r) {
          n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r), n.emplaceBack(t.x, t.y, r);
        }
        function N2(n) {
          for (const t of n.sections) if (Rh(t.text)) return true;
          return false;
        }
        class Wf {
          constructor(t) {
            this.layoutVertexArray = new It(), this.indexArray = new Kr(), this.programConfigurations = t, this.segments = new br(), this.dynamicLayoutVertexArray = new ft(), this.opacityVertexArray = new Zt(), this.hasVisibleVertices = false, this.placedSymbolArray = new ee();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, r, c, f) {
            this.isEmpty() || (c && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, f2.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, m2.members, true), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, j2, true), this.opacityVertexBuffer.itemSize = 1), (c || f) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Bt("SymbolBuffers", Wf);
        class Zf {
          constructor(t, r, c) {
            this.layoutVertexArray = new t(), this.layoutAttributes = r, this.indexArray = new c(), this.segments = new br(), this.collisionVertexArray = new $r();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, g2.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Bt("CollisionBuffers", Zf);
        class kc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((b) => b.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Oy(this.zoom, r["text-size"]), this.iconSizeData = Oy(this.zoom, r["icon-size"]);
            const c = this.layers[0].layout, f = c.get("symbol-sort-key"), _ = c.get("symbol-z-order");
            this.canOverlap = qf(c, "text-overlap", "text-allow-overlap") !== "never" || qf(c, "icon-overlap", "icon-allow-overlap") !== "never" || c.get("text-ignore-placement") || c.get("icon-ignore-placement"), this.sortFeaturesByKey = _ !== "viewport-y" && !f.isConstant(), this.sortFeaturesByY = (_ === "viewport-y" || _ === "auto" && !this.sortFeaturesByKey) && this.canOverlap, c.get("symbol-placement") === "point" && (this.writingModes = c.get("text-writing-mode").map(((b) => p.ao[b]))), this.stateDependentLayerIds = this.layers.filter(((b) => b.isStateDependent())).map(((b) => b.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new Wf(new Bi(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new Wf(new Bi(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new pe(), this.lineVertexArray = new ge(), this.symbolInstances = new ce(), this.textAnchorOffsets = new xe();
          }
          calculateGlyphDependencies(t, r, c, f, _) {
            for (let b = 0; b < t.length; b++) if (r[t.charCodeAt(b)] = true, (c || f) && _) {
              const C = od[t.charAt(b)];
              C && (r[C.charCodeAt(0)] = true);
            }
          }
          populate(t, r, c) {
            const f = this.layers[0], _ = f.layout, b = _.get("text-font"), C = _.get("text-field"), P = _.get("icon-image"), E = (C.value.kind !== "constant" || C.value.value instanceof ui && !C.value.value.isEmpty() || C.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), A = P.value.kind !== "constant" || !!P.value.value || Object.keys(P.parameters).length > 0, B = _.get("symbol-sort-key");
            if (this.features = [], !E && !A) return;
            const U = r.iconDependencies, H = r.glyphDependencies, J = r.availableImages, ie = new rn(this.zoom, { globalState: this.globalState });
            for (const { feature: le, id: me, index: Oe, sourceLayerIndex: Se } of t) {
              const Ee = f._featureFilter.needGeometry, He = $o(le, Ee);
              if (!f._featureFilter.filter(ie, He, c)) continue;
              let rt, _t;
              if (Ee || (He.geometry = as(le)), E) {
                const Mt = f.getValueAndResolveTokens("text-field", He, c, J), zt = ui.factory(Mt), Jt = this.hasRTLText = this.hasRTLText || N2(zt);
                (!Jt || so.getRTLTextPluginStatus() === "unavailable" || Jt && so.isParsed()) && (rt = y2(zt, f, He));
              }
              if (A) {
                const Mt = f.getValueAndResolveTokens("icon-image", He, c, J);
                _t = Mt instanceof Fi ? Mt : Fi.fromString(Mt);
              }
              if (!rt && !_t) continue;
              const Ft = this.sortFeaturesByKey ? B.evaluate(He, {}, c) : void 0;
              if (this.features.push({ id: me, text: rt, icon: _t, index: Oe, sourceLayerIndex: Se, geometry: He.geometry, properties: le.properties, type: wc.types[le.type], sortKey: Ft }), _t && (U[_t.name] = true), rt) {
                const Mt = b.evaluate(He, {}, c).join(","), zt = _.get("text-rotation-alignment") !== "viewport" && _.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(p.ao.vertical) >= 0;
                for (const Jt of rt.sections) if (Jt.image) U[Jt.image.name] = true;
                else {
                  const Rt = lc(rt.toString()), At = Jt.fontStack || Mt, dt = H[At] = H[At] || {};
                  this.calculateGlyphDependencies(Jt.text, dt, zt, this.allowVerticalPlacement, Rt);
                }
              }
            }
            _.get("symbol-placement") === "line" && (this.features = (function(le) {
              const me = {}, Oe = {}, Se = [];
              let Ee = 0;
              function He(Mt) {
                Se.push(le[Mt]), Ee++;
              }
              function rt(Mt, zt, Jt) {
                const Rt = Oe[Mt];
                return delete Oe[Mt], Oe[zt] = Rt, Se[Rt].geometry[0].pop(), Se[Rt].geometry[0] = Se[Rt].geometry[0].concat(Jt[0]), Rt;
              }
              function _t(Mt, zt, Jt) {
                const Rt = me[zt];
                return delete me[zt], me[Mt] = Rt, Se[Rt].geometry[0].shift(), Se[Rt].geometry[0] = Jt[0].concat(Se[Rt].geometry[0]), Rt;
              }
              function Ft(Mt, zt, Jt) {
                const Rt = Jt ? zt[0][zt[0].length - 1] : zt[0][0];
                return `${Mt}:${Rt.x}:${Rt.y}`;
              }
              for (let Mt = 0; Mt < le.length; Mt++) {
                const zt = le[Mt], Jt = zt.geometry, Rt = zt.text ? zt.text.toString() : null;
                if (!Rt) {
                  He(Mt);
                  continue;
                }
                const At = Ft(Rt, Jt), dt = Ft(Rt, Jt, true);
                if (At in Oe && dt in me && Oe[At] !== me[dt]) {
                  const cr = _t(At, dt, Jt), mr = rt(At, dt, Se[cr].geometry);
                  delete me[At], delete Oe[dt], Oe[Ft(Rt, Se[mr].geometry, true)] = mr, Se[cr].geometry = null;
                } else At in Oe ? rt(At, dt, Jt) : dt in me ? _t(At, dt, Jt) : (He(Mt), me[At] = Ee - 1, Oe[dt] = Ee - 1);
              }
              return Se.filter(((Mt) => Mt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((le, me) => le.sortKey - me.sortKey));
          }
          update(t, r, c) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, { imagePositions: c, globalState: this.globalState }), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, { imagePositions: c, globalState: this.globalState }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, r) {
            const c = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let f = t.dist(r[t.segment + 1]), _ = t.dist(r[t.segment]);
              const b = {};
              for (let C = t.segment + 1; C < r.length; C++) b[C] = { x: r[C].x, y: r[C].y, tileUnitDistanceFromAnchor: f }, C < r.length - 1 && (f += r[C + 1].dist(r[C]));
              for (let C = t.segment || 0; C >= 0; C--) b[C] = { x: r[C].x, y: r[C].y, tileUnitDistanceFromAnchor: _ }, C > 0 && (_ += r[C - 1].dist(r[C]));
              for (let C = 0; C < r.length; C++) {
                const P = b[C];
                this.lineVertexArray.emplaceBack(P.x, P.y, P.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: c, lineLength: this.lineVertexArray.length - c };
          }
          addSymbols(t, r, c, f, _, b, C, P, E, A, B, U) {
            const H = t.indexArray, J = t.layoutVertexArray, ie = t.segments.prepareSegment(4 * r.length, J, H, this.canOverlap ? b.sortKey : void 0), le = this.glyphOffsetArray.length, me = ie.vertexLength, Oe = this.allowVerticalPlacement && C === p.ao.vertical ? Math.PI / 2 : 0, Se = b.text && b.text.sections;
            for (let Ee = 0; Ee < r.length; Ee++) {
              const { tl: He, tr: rt, bl: _t, br: Ft, tex: Mt, pixelOffsetTL: zt, pixelOffsetBR: Jt, minFontScaleX: Rt, minFontScaleY: At, glyphOffset: dt, isSDF: cr, sectionIndex: mr } = r[Ee], nr = ie.vertexLength, Ht = dt[1];
              Gh(J, P.x, P.y, He.x, Ht + He.y, Mt.x, Mt.y, c, cr, zt.x, zt.y, Rt, At), Gh(J, P.x, P.y, rt.x, Ht + rt.y, Mt.x + Mt.w, Mt.y, c, cr, Jt.x, zt.y, Rt, At), Gh(J, P.x, P.y, _t.x, Ht + _t.y, Mt.x, Mt.y + Mt.h, c, cr, zt.x, Jt.y, Rt, At), Gh(J, P.x, P.y, Ft.x, Ht + Ft.y, Mt.x + Mt.w, Mt.y + Mt.h, c, cr, Jt.x, Jt.y, Rt, At), Gf(t.dynamicLayoutVertexArray, P, Oe), H.emplaceBack(nr, nr + 2, nr + 1), H.emplaceBack(nr + 1, nr + 2, nr + 3), ie.vertexLength += 4, ie.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), Ee !== r.length - 1 && mr === r[Ee + 1].sectionIndex || t.programConfigurations.populatePaintArrays(J.length, b, b.index, { imagePositions: {}, canonical: U, formattedSection: Se && Se[mr], globalState: this.globalState });
            }
            t.placedSymbolArray.emplaceBack(P.x, P.y, le, this.glyphOffsetArray.length - le, me, E, A, P.segment, c ? c[0] : 0, c ? c[1] : 0, f[0], f[1], C, 0, false, 0, B);
          }
          _addCollisionDebugVertex(t, r, c, f, _, b) {
            return r.emplaceBack(0, 0), t.emplaceBack(c.x, c.y, f, _, Math.round(b.x), Math.round(b.y));
          }
          addCollisionDebugVertices(t, r, c, f, _, b, C) {
            const P = _.segments.prepareSegment(4, _.layoutVertexArray, _.indexArray), E = P.vertexLength, A = _.layoutVertexArray, B = _.collisionVertexArray, U = C.anchorX, H = C.anchorY;
            this._addCollisionDebugVertex(A, B, b, U, H, new w(t, r)), this._addCollisionDebugVertex(A, B, b, U, H, new w(c, r)), this._addCollisionDebugVertex(A, B, b, U, H, new w(c, f)), this._addCollisionDebugVertex(A, B, b, U, H, new w(t, f)), P.vertexLength += 4;
            const J = _.indexArray;
            J.emplaceBack(E, E + 1), J.emplaceBack(E + 1, E + 2), J.emplaceBack(E + 2, E + 3), J.emplaceBack(E + 3, E), P.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, r, c, f) {
            for (let _ = t; _ < r; _++) {
              const b = this.collisionBoxArray.get(_);
              this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, f ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, c);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Zf(xr, ky.members, Wr), this.iconCollisionBox = new Zf(xr, ky.members, Wr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, true), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, true), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, false), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, c, f, _, b, C, P, E) {
            const A = {};
            for (let B = r; B < c; B++) {
              const U = t.get(B);
              A.textBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, A.textFeatureIndex = U.featureIndex;
              break;
            }
            for (let B = f; B < _; B++) {
              const U = t.get(B);
              A.verticalTextBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, A.verticalTextFeatureIndex = U.featureIndex;
              break;
            }
            for (let B = b; B < C; B++) {
              const U = t.get(B);
              A.iconBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, A.iconFeatureIndex = U.featureIndex;
              break;
            }
            for (let B = P; B < E; B++) {
              const U = t.get(B);
              A.verticalIconBox = { x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2, anchorPointX: U.anchorPointX, anchorPointY: U.anchorPointY }, A.verticalIconFeatureIndex = U.featureIndex;
              break;
            }
            return A;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const c = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, c.textBoxStartIndex, c.textBoxEndIndex, c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c.iconBoxStartIndex, c.iconBoxEndIndex, c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, r) {
            const c = t.placedSymbolArray.get(r), f = c.vertexStartIndex + 4 * c.numGlyphs;
            for (let _ = c.vertexStartIndex; _ < f; _ += 4) t.indexArray.emplaceBack(_, _ + 2, _ + 1), t.indexArray.emplaceBack(_ + 1, _ + 2, _ + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t), c = Math.cos(t), f = [], _ = [], b = [];
            for (let C = 0; C < this.symbolInstances.length; ++C) {
              b.push(C);
              const P = this.symbolInstances.get(C);
              f.push(0 | Math.round(r * P.anchorX + c * P.anchorY)), _.push(P.featureIndex);
            }
            return b.sort(((C, P) => f[C] - f[P] || _[P] - _[C])), b;
          }
          addToSortKeyRanges(t, r) {
            const c = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            c && c.sortKey === r ? c.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const c = this.symbolInstances.get(r);
                this.featureSortOrder.push(c.featureIndex), [c.rightJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.leftJustifiedTextSymbolIndex].forEach(((f, _, b) => {
                  f >= 0 && b.indexOf(f) === _ && this.addIndicesForPlacedSymbol(this.text, f);
                })), c.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, c.verticalPlacedTextSymbolIndex), c.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.placedIconSymbolIndex), c.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let $y, jy;
        Bt("SymbolBucket", kc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), kc.MAX_GLYPHS = 65535, kc.addDynamicAttributes = Gf;
        var Hf = { get paint() {
          return jy = jy || new pi({ "icon-opacity": new sr(Te.paint_symbol["icon-opacity"]), "icon-color": new sr(Te.paint_symbol["icon-color"]), "icon-halo-color": new sr(Te.paint_symbol["icon-halo-color"]), "icon-halo-width": new sr(Te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new sr(Te.paint_symbol["icon-halo-blur"]), "icon-translate": new Xt(Te.paint_symbol["icon-translate"]), "icon-translate-anchor": new Xt(Te.paint_symbol["icon-translate-anchor"]), "text-opacity": new sr(Te.paint_symbol["text-opacity"]), "text-color": new sr(Te.paint_symbol["text-color"], { runtimeType: an, getOverride: (n) => n.textColor, hasOverride: (n) => !!n.textColor }), "text-halo-color": new sr(Te.paint_symbol["text-halo-color"]), "text-halo-width": new sr(Te.paint_symbol["text-halo-width"]), "text-halo-blur": new sr(Te.paint_symbol["text-halo-blur"]), "text-translate": new Xt(Te.paint_symbol["text-translate"]), "text-translate-anchor": new Xt(Te.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return $y = $y || new pi({ "symbol-placement": new Xt(Te.layout_symbol["symbol-placement"]), "symbol-spacing": new Xt(Te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Xt(Te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new sr(Te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Xt(Te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Xt(Te.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Xt(Te.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Xt(Te.layout_symbol["icon-ignore-placement"]), "icon-optional": new Xt(Te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Xt(Te.layout_symbol["icon-rotation-alignment"]), "icon-size": new sr(Te.layout_symbol["icon-size"]), "icon-text-fit": new Xt(Te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Xt(Te.layout_symbol["icon-text-fit-padding"]), "icon-image": new sr(Te.layout_symbol["icon-image"]), "icon-rotate": new sr(Te.layout_symbol["icon-rotate"]), "icon-padding": new sr(Te.layout_symbol["icon-padding"]), "icon-keep-upright": new Xt(Te.layout_symbol["icon-keep-upright"]), "icon-offset": new sr(Te.layout_symbol["icon-offset"]), "icon-anchor": new sr(Te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Xt(Te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Xt(Te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Xt(Te.layout_symbol["text-rotation-alignment"]), "text-field": new sr(Te.layout_symbol["text-field"]), "text-font": new sr(Te.layout_symbol["text-font"]), "text-size": new sr(Te.layout_symbol["text-size"]), "text-max-width": new sr(Te.layout_symbol["text-max-width"]), "text-line-height": new Xt(Te.layout_symbol["text-line-height"]), "text-letter-spacing": new sr(Te.layout_symbol["text-letter-spacing"]), "text-justify": new sr(Te.layout_symbol["text-justify"]), "text-radial-offset": new sr(Te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Xt(Te.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new sr(Te.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new sr(Te.layout_symbol["text-anchor"]), "text-max-angle": new Xt(Te.layout_symbol["text-max-angle"]), "text-writing-mode": new Xt(Te.layout_symbol["text-writing-mode"]), "text-rotate": new sr(Te.layout_symbol["text-rotate"]), "text-padding": new Xt(Te.layout_symbol["text-padding"]), "text-keep-upright": new Xt(Te.layout_symbol["text-keep-upright"]), "text-transform": new sr(Te.layout_symbol["text-transform"]), "text-offset": new sr(Te.layout_symbol["text-offset"]), "text-allow-overlap": new Xt(Te.layout_symbol["text-allow-overlap"]), "text-overlap": new Xt(Te.layout_symbol["text-overlap"]), "text-ignore-placement": new Xt(Te.layout_symbol["text-ignore-placement"]), "text-optional": new Xt(Te.layout_symbol["text-optional"]) });
        } };
        class Ny {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : Nr, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Bt("FormatSectionOverride", Ny, { omit: ["defaultValue"] });
        class Wh extends Zi {
          constructor(t) {
            super(t, Hf);
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const c = this.layout.get("text-writing-mode");
              if (c) {
                const f = [];
                for (const _ of c) f.indexOf(_) < 0 && f.push(_);
                this.layout._values["text-writing-mode"] = f;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, r, c, f) {
            const _ = this.layout.get(t).evaluate(r, {}, c, f), b = this._unevaluatedLayout._values[t];
            return b.isDataDriven() || ec(b.value) || !_ ? _ : (function(C, P) {
              return P.replace(/{([^{}]+)}/g, ((E, A) => C && A in C ? String(C[A]) : ""));
            })(r.properties, _);
          }
          createBucket(t) {
            return new kc(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of Hf.paint.overridableProperties) {
              if (!Wh.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t), c = new Ny(r), f = new Pu(c, r.property.specification);
              let _ = null;
              _ = r.value.kind === "constant" || r.value.kind === "source" ? new Ka("source", f) : new Tu("composite", f, r.value.zoomStops), this.paint._values[t] = new Io(r.property, _, r.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, c) {
            return !(!this.layout || r.isDataDriven() || c.isDataDriven()) && Wh.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, r) {
            const c = t.get("text-field"), f = Hf.paint.properties[r];
            let _ = false;
            const b = (C) => {
              for (const P of C) if (f.overrides && f.overrides.hasOverride(P)) return void (_ = true);
            };
            if (c.value.kind === "constant" && c.value.value instanceof ui) b(c.value.value.sections);
            else if (c.value.kind === "source") {
              const C = (E) => {
                _ || (E instanceof Fo && lr(E.value) === qi ? b(E.value.sections) : E instanceof Cs ? b(E.sections) : E.eachChild(C));
              }, P = c.value;
              P._styleExpression && C(P._styleExpression.expression);
            }
            return _;
          }
        }
        let Vy;
        var V2 = { get paint() {
          return Vy = Vy || new pi({ "background-color": new Xt(Te.paint_background["background-color"]), "background-pattern": new rs(Te.paint_background["background-pattern"]), "background-opacity": new Xt(Te.paint_background["background-opacity"]) });
        } };
        class U2 extends Zi {
          constructor(t) {
            super(t, V2);
          }
        }
        let Uy;
        var q2 = { get paint() {
          return Uy = Uy || new pi({ "raster-opacity": new Xt(Te.paint_raster["raster-opacity"]), "raster-hue-rotate": new Xt(Te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Xt(Te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Xt(Te.paint_raster["raster-brightness-max"]), "raster-saturation": new Xt(Te.paint_raster["raster-saturation"]), "raster-contrast": new Xt(Te.paint_raster["raster-contrast"]), "raster-resampling": new Xt(Te.paint_raster["raster-resampling"]), "raster-fade-duration": new Xt(Te.paint_raster["raster-fade-duration"]) });
        } };
        class G2 extends Zi {
          constructor(t) {
            super(t, q2);
          }
        }
        class W2 extends Zi {
          constructor(t) {
            super(t, {}), this.onAdd = (r) => {
              this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl);
            }, this.onRemove = (r) => {
              this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Z2 {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const H2 = { once: true }, Xf = 63710088e-1;
        class ga {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ga(jt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const r = Math.PI / 180, c = this.lat * r, f = t.lat * r, _ = Math.sin(c) * Math.sin(f) + Math.cos(c) * Math.cos(f) * Math.cos((t.lng - this.lng) * r);
            return Xf * Math.acos(Math.min(_, 1));
          }
          static convert(t) {
            if (t instanceof ga) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new ga(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new ga(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const qy = 2 * Math.PI * Xf;
        function Gy(n) {
          return qy * Math.cos(n * Math.PI / 180);
        }
        function Wy(n) {
          return (180 + n) / 360;
        }
        function Zy(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360;
        }
        function Hy(n, t) {
          return n / Gy(t);
        }
        function Yf(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90;
        }
        function Xy(n, t) {
          return n * Gy(Yf(t));
        }
        class ad {
          constructor(t, r, c = 0) {
            this.x = +t, this.y = +r, this.z = +c;
          }
          static fromLngLat(t, r = 0) {
            const c = ga.convert(t);
            return new ad(Wy(c.lng), Zy(c.lat), Hy(r, c.lat));
          }
          toLngLat() {
            return new ga(360 * this.x - 180, Yf(this.y));
          }
          toAltitude() {
            return Xy(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / qy * (t = Yf(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function Yy(n, t, r) {
          var c = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [n * c - 2 * Math.PI * 6378137 / 2, t * c - 2 * Math.PI * 6378137 / 2];
        }
        class Kf {
          constructor(t, r, c) {
            if (!(function(f, _, b) {
              return !(f < 0 || f > 25 || b < 0 || b >= Math.pow(2, f) || _ < 0 || _ >= Math.pow(2, f));
            })(t, r, c)) throw new Error(`x=${r}, y=${c}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = c, this.key = Pc(0, t, t, r, c);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, r, c) {
            const f = (b = this.y, C = this.z, P = Yy(256 * (_ = this.x), 256 * (b = Math.pow(2, C) - b - 1), C), E = Yy(256 * (_ + 1), 256 * (b + 1), C), P[0] + "," + P[1] + "," + E[0] + "," + E[1]);
            var _, b, C, P, E;
            const A = (function(B, U, H) {
              let J, ie = "";
              for (let le = B; le > 0; le--) J = 1 << le - 1, ie += (U & J ? 1 : 0) + (H & J ? 2 : 0);
              return ie;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(c === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, A).replace(/{bbox-epsg-3857}/g, f);
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r;
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new w((t.x * r - this.x) * Ye, (t.y * r - this.y) * Ye);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Ky {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = Pc(t, r.z, r.z, r.x, r.y);
          }
        }
        class uo {
          constructor(t, r, c, f, _) {
            if (this.terrainRttPosMatrix32f = null, t < c) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${c}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new Kf(c, +f, +_), this.key = Pc(r, t, c, f, _);
          }
          clone() {
            return new uo(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new uo(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new uo(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r);
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const c = this.canonical.z - t;
            return t > this.canonical.z ? Pc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : Pc(this.wrap * +r, t, t, this.canonical.x >> c, this.canonical.y >> c);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return false;
            const r = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new uo(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1, c = 2 * this.canonical.x, f = 2 * this.canonical.y;
            return [new uo(r, this.wrap, r, c, f), new uo(r, this.wrap, r, c + 1, f), new uo(r, this.wrap, r, c, f + 1), new uo(r, this.wrap, r, c + 1, f + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new uo(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new uo(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Ky(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new ad(t.x - this.wrap, t.y));
          }
        }
        function Pc(n, t, r, c, f) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const _ = 1 << r;
          return (_ * _ * n + _ * f + c).toString(36) + r.toString(36) + t.toString(36);
        }
        function ld(n, t) {
          return t ? n.properties[t] : n.id;
        }
        Bt("CanonicalTileID", Kf), Bt("OverscaledTileID", uo, { omit: ["terrainRttPosMatrix32f"] });
        class ul {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const r = new ul();
            return r.extend(t(new w(this.minX, this.minY))), r.extend(t(new w(this.maxX, this.minY))), r.extend(t(new w(this.minX, this.maxY))), r.extend(t(new w(this.maxX, this.maxY))), r;
          }
          static fromPoints(t) {
            const r = new ul();
            for (const c of t) r.extend(c);
            return r;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class Jy {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const c = t[r];
              this._stringToNumber[c] = r, this._numberToString[r] = c;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class Qy {
          constructor(t, r, c, f, _) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = c, t._y = f, this.properties = t.properties, this.id = _;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t;
          }
        }
        class e_ {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new il(Ye, 16, 0), this.grid3D = new il(Ye, 16, 0), this.featureIndexArray = new ze(), this.promoteId = r;
          }
          insert(t, r, c, f, _, b) {
            const C = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(c, f, _);
            const P = b ? this.grid3D : this.grid;
            for (let E = 0; E < r.length; E++) {
              const A = r[E], B = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let U = 0; U < A.length; U++) {
                const H = A[U];
                B[0] = Math.min(B[0], H.x), B[1] = Math.min(B[1], H.y), B[2] = Math.max(B[2], H.x), B[3] = Math.max(B[3], H.y);
              }
              B[0] < Ye && B[1] < Ye && B[2] >= 0 && B[3] >= 0 && P.insert(C, B[0], B[1], B[2], B[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new gy(new jf(this.rawTileData)).layers, this.sourceLayerCoder = new Jy(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, r, c, f) {
            this.loadVTLayers();
            const _ = t.params, b = Ye / t.tileSize / t.scale, C = Is(_.filter), P = t.queryGeometry, E = t.queryPadding * b, A = ul.fromPoints(P), B = this.grid.query(A.minX - E, A.minY - E, A.maxX + E, A.maxY + E), U = ul.fromPoints(t.cameraQueryGeometry).expandBy(E), H = this.grid3D.query(U.minX, U.minY, U.maxX, U.maxY, ((le, me, Oe, Se) => (function(Ee, He, rt, _t, Ft) {
              for (const zt of Ee) if (He <= zt.x && rt <= zt.y && _t >= zt.x && Ft >= zt.y) return true;
              const Mt = [new w(He, rt), new w(He, Ft), new w(_t, Ft), new w(_t, rt)];
              if (Ee.length > 2) {
                for (const zt of Mt) if (yc(Ee, zt)) return true;
              }
              for (let zt = 0; zt < Ee.length - 1; zt++) if (Pw(Ee[zt], Ee[zt + 1], Mt)) return true;
              return false;
            })(t.cameraQueryGeometry, le - E, me - E, Oe + E, Se + E)));
            for (const le of H) B.push(le);
            B.sort(X2);
            const J = {};
            let ie;
            for (let le = 0; le < B.length; le++) {
              const me = B[le];
              if (me === ie) continue;
              ie = me;
              const Oe = this.featureIndexArray.get(me);
              let Se = null;
              this.loadMatchingFeature(J, Oe.bucketIndex, Oe.sourceLayerIndex, Oe.featureIndex, C, _.layers, _.availableImages, r, c, f, ((Ee, He, rt) => (Se || (Se = as(Ee)), He.queryIntersectsFeature({ queryGeometry: P, feature: Ee, featureState: rt, geometry: Se, zoom: this.z, transform: t.transform, pixelsToTileUnits: b, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return J;
          }
          loadMatchingFeature(t, r, c, f, _, b, C, P, E, A, B) {
            const U = this.bucketLayerIDs[r];
            if (b && !U.some(((le) => b.has(le)))) return;
            const H = this.sourceLayerCoder.decode(c), J = this.vtLayers[H].feature(f);
            if (_.needGeometry) {
              const le = $o(J, true);
              if (!_.filter(new rn(this.tileID.overscaledZ), le, this.tileID.canonical)) return;
            } else if (!_.filter(new rn(this.tileID.overscaledZ), J)) return;
            const ie = this.getId(J, H);
            for (let le = 0; le < U.length; le++) {
              const me = U[le];
              if (b && !b.has(me)) continue;
              const Oe = P[me];
              if (!Oe) continue;
              let Se = {};
              ie && A && (Se = A.getState(Oe.sourceLayer || "_geojsonTileLayer", ie));
              const Ee = er({}, E[me]);
              Ee.paint = t_(Ee.paint, Oe.paint, J, Se, C), Ee.layout = t_(Ee.layout, Oe.layout, J, Se, C);
              const He = !B || B(J, Oe, Se);
              if (!He) continue;
              const rt = new Qy(J, this.z, this.x, this.y, ie);
              rt.layer = Ee;
              let _t = t[me];
              _t === void 0 && (_t = t[me] = []), _t.push({ featureIndex: f, feature: rt, intersectionZ: He });
            }
          }
          lookupSymbolFeatures(t, r, c, f, _, b, C, P) {
            const E = {};
            this.loadVTLayers();
            const A = Is(_);
            for (const B of t) this.loadMatchingFeature(E, c, f, B, A, b, C, P, r);
            return E;
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs) for (const c of r) if (t === c) return true;
            return false;
          }
          getId(t, r) {
            var c;
            let f = t.id;
            return this.promoteId && (f = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof f == "boolean" && (f = Number(f)), f === void 0 && (!((c = t.properties) === null || c === void 0) && c.cluster) && this.promoteId && (f = Number(t.properties.cluster_id))), f;
          }
        }
        function t_(n, t, r, c, f) {
          return Tr(n, ((_, b) => {
            const C = t instanceof uc ? t.get(b) : null;
            return C && C.evaluate ? C.evaluate(r, c, f) : C;
          }));
        }
        function X2(n, t) {
          return t - n;
        }
        function r_(n, t, r, c, f) {
          const _ = [];
          for (let b = 0; b < n.length; b++) {
            const C = n[b];
            let P;
            for (let E = 0; E < C.length - 1; E++) {
              let A = C[E], B = C[E + 1];
              A.x < t && B.x < t || (A.x < t ? A = new w(t, A.y + (t - A.x) / (B.x - A.x) * (B.y - A.y))._round() : B.x < t && (B = new w(t, A.y + (t - A.x) / (B.x - A.x) * (B.y - A.y))._round()), A.y < r && B.y < r || (A.y < r ? A = new w(A.x + (r - A.y) / (B.y - A.y) * (B.x - A.x), r)._round() : B.y < r && (B = new w(A.x + (r - A.y) / (B.y - A.y) * (B.x - A.x), r)._round()), A.x >= c && B.x >= c || (A.x >= c ? A = new w(c, A.y + (c - A.x) / (B.x - A.x) * (B.y - A.y))._round() : B.x >= c && (B = new w(c, A.y + (c - A.x) / (B.x - A.x) * (B.y - A.y))._round()), A.y >= f && B.y >= f || (A.y >= f ? A = new w(A.x + (f - A.y) / (B.y - A.y) * (B.x - A.x), f)._round() : B.y >= f && (B = new w(A.x + (f - A.y) / (B.y - A.y) * (B.x - A.x), f)._round()), P && A.equals(P[P.length - 1]) || (P = [A], _.push(P)), P.push(B)))));
            }
          }
          return _;
        }
        Bt("FeatureIndex", e_, { omit: ["rawTileData", "sourceLayerCoder"] });
        class va extends w {
          constructor(t, r, c, f) {
            super(t, r), this.angle = c, f !== void 0 && (this.segment = f);
          }
          clone() {
            return new va(this.x, this.y, this.angle, this.segment);
          }
        }
        function n_(n, t, r, c, f) {
          if (t.segment === void 0 || r === 0) return true;
          let _ = t, b = t.segment + 1, C = 0;
          for (; C > -r / 2; ) {
            if (b--, b < 0) return false;
            C -= n[b].dist(_), _ = n[b];
          }
          C += n[b].dist(n[b + 1]), b++;
          const P = [];
          let E = 0;
          for (; C < r / 2; ) {
            const A = n[b], B = n[b + 1];
            if (!B) return false;
            let U = n[b - 1].angleTo(A) - A.angleTo(B);
            for (U = Math.abs((U + 3 * Math.PI) % (2 * Math.PI) - Math.PI), P.push({ distance: C, angleDelta: U }), E += U; C - P[0].distance > c; ) E -= P.shift().angleDelta;
            if (E > f) return false;
            b++, C += A.dist(B);
          }
          return true;
        }
        function i_(n) {
          let t = 0;
          for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
          return t;
        }
        function o_(n, t, r) {
          return n ? 0.6 * t * r : 0;
        }
        function s_(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0);
        }
        function Y2(n, t, r, c, f, _) {
          const b = o_(r, f, _), C = s_(r, c) * _;
          let P = 0;
          const E = i_(n) / 2;
          for (let A = 0; A < n.length - 1; A++) {
            const B = n[A], U = n[A + 1], H = B.dist(U);
            if (P + H > E) {
              const J = (E - P) / H, ie = To.number(B.x, U.x, J), le = To.number(B.y, U.y, J), me = new va(ie, le, U.angleTo(B), A);
              return me._round(), !b || n_(n, me, C, b, t) ? me : void 0;
            }
            P += H;
          }
        }
        function K2(n, t, r, c, f, _, b, C, P) {
          const E = o_(c, _, b), A = s_(c, f), B = A * b, U = n[0].x === 0 || n[0].x === P || n[0].y === 0 || n[0].y === P;
          return t - B < t / 4 && (t = B + t / 4), a_(n, U ? t / 2 * C % t : (A / 2 + 2 * _) * b * C % t, t, E, r, B, U, false, P);
        }
        function a_(n, t, r, c, f, _, b, C, P) {
          const E = _ / 2, A = i_(n);
          let B = 0, U = t - r, H = [];
          for (let J = 0; J < n.length - 1; J++) {
            const ie = n[J], le = n[J + 1], me = ie.dist(le), Oe = le.angleTo(ie);
            for (; U + r < B + me; ) {
              U += r;
              const Se = (U - B) / me, Ee = To.number(ie.x, le.x, Se), He = To.number(ie.y, le.y, Se);
              if (Ee >= 0 && Ee < P && He >= 0 && He < P && U - E >= 0 && U + E <= A) {
                const rt = new va(Ee, He, Oe, J);
                rt._round(), c && !n_(n, rt, _, c, f) || H.push(rt);
              }
            }
            B += me;
          }
          return C || H.length || b || (H = a_(n, B / 2, r, c, f, _, b, true, P)), H;
        }
        function l_(n, t, r, c) {
          const f = [], _ = n.image, b = _.pixelRatio, C = _.paddedRect.w - 2, P = _.paddedRect.h - 2;
          let E = { x1: n.left, y1: n.top, x2: n.right, y2: n.bottom };
          const A = _.stretchX || [[0, C]], B = _.stretchY || [[0, P]], U = (dt, cr) => dt + cr[1] - cr[0], H = A.reduce(U, 0), J = B.reduce(U, 0), ie = C - H, le = P - J;
          let me = 0, Oe = H, Se = 0, Ee = J, He = 0, rt = ie, _t = 0, Ft = le;
          if (_.content && c) {
            const dt = _.content, cr = dt[2] - dt[0], mr = dt[3] - dt[1];
            (_.textFitWidth || _.textFitHeight) && (E = Ly(n)), me = Zh(A, 0, dt[0]), Se = Zh(B, 0, dt[1]), Oe = Zh(A, dt[0], dt[2]), Ee = Zh(B, dt[1], dt[3]), He = dt[0] - me, _t = dt[1] - Se, rt = cr - Oe, Ft = mr - Ee;
          }
          const Mt = E.x1, zt = E.y1, Jt = E.x2 - Mt, Rt = E.y2 - zt, At = (dt, cr, mr, nr) => {
            const Ht = Hh(dt.stretch - me, Oe, Jt, Mt), Rr = Xh(dt.fixed - He, rt, dt.stretch, H), bn = Hh(cr.stretch - Se, Ee, Rt, zt), Bn = Xh(cr.fixed - _t, Ft, cr.stretch, J), li = Hh(mr.stretch - me, Oe, Jt, Mt), ho = Xh(mr.fixed - He, rt, mr.stretch, H), $i = Hh(nr.stretch - Se, Ee, Rt, zt), Yn = Xh(nr.fixed - _t, Ft, nr.stretch, J), mn = new w(Ht, bn), Gn = new w(li, bn), Kn = new w(li, $i), Jn = new w(Ht, $i), Mi = new w(Rr / b, Bn / b), po = new w(ho / b, Yn / b), Wn = t * Math.PI / 180;
            if (Wn) {
              const Zn = Math.sin(Wn), Hn = Math.cos(Wn), zn = [Hn, -Zn, Zn, Hn];
              mn._matMult(zn), Gn._matMult(zn), Jn._matMult(zn), Kn._matMult(zn);
            }
            const ji = dt.stretch + dt.fixed, On = cr.stretch + cr.fixed;
            return { tl: mn, tr: Gn, bl: Jn, br: Kn, tex: { x: _.paddedRect.x + 1 + ji, y: _.paddedRect.y + 1 + On, w: mr.stretch + mr.fixed - ji, h: nr.stretch + nr.fixed - On }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Mi, pixelOffsetBR: po, minFontScaleX: rt / b / Jt, minFontScaleY: Ft / b / Rt, isSDF: r };
          };
          if (c && (_.stretchX || _.stretchY)) {
            const dt = c_(A, ie, H), cr = c_(B, le, J);
            for (let mr = 0; mr < dt.length - 1; mr++) {
              const nr = dt[mr], Ht = dt[mr + 1];
              for (let Rr = 0; Rr < cr.length - 1; Rr++) f.push(At(nr, cr[Rr], Ht, cr[Rr + 1]));
            }
          } else f.push(At({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: C + 1 }, { fixed: 0, stretch: P + 1 }));
          return f;
        }
        function Zh(n, t, r) {
          let c = 0;
          for (const f of n) c += Math.max(t, Math.min(r, f[1])) - Math.max(t, Math.min(r, f[0]));
          return c;
        }
        function c_(n, t, r) {
          const c = [{ fixed: -1, stretch: 0 }];
          for (const [f, _] of n) {
            const b = c[c.length - 1];
            c.push({ fixed: f - b.stretch, stretch: b.stretch }), c.push({ fixed: f - b.stretch, stretch: b.stretch + (_ - f) });
          }
          return c.push({ fixed: t + 1, stretch: r }), c;
        }
        function Hh(n, t, r, c) {
          return n / t * r + c;
        }
        function Xh(n, t, r, c) {
          return n - t * r / c;
        }
        Bt("Anchor", va);
        class Yh {
          constructor(t, r, c, f, _, b, C, P, E, A) {
            var B;
            if (this.boxStartIndex = t.length, E) {
              let U = b.top, H = b.bottom;
              const J = b.collisionPadding;
              J && (U -= J[1], H += J[3]);
              let ie = H - U;
              ie > 0 && (ie = Math.max(10, ie), this.circleDiameter = ie);
            } else {
              const U = !((B = b.image) === null || B === void 0) && B.content && (b.image.textFitWidth || b.image.textFitHeight) ? Ly(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
              U.y1 = U.y1 * C - P[0], U.y2 = U.y2 * C + P[2], U.x1 = U.x1 * C - P[3], U.x2 = U.x2 * C + P[1];
              const H = b.collisionPadding;
              if (H && (U.x1 -= H[0] * C, U.y1 -= H[1] * C, U.x2 += H[2] * C, U.y2 += H[3] * C), A) {
                const J = new w(U.x1, U.y1), ie = new w(U.x2, U.y1), le = new w(U.x1, U.y2), me = new w(U.x2, U.y2), Oe = A * Math.PI / 180;
                J._rotate(Oe), ie._rotate(Oe), le._rotate(Oe), me._rotate(Oe), U.x1 = Math.min(J.x, ie.x, le.x, me.x), U.x2 = Math.max(J.x, ie.x, le.x, me.x), U.y1 = Math.min(J.y, ie.y, le.y, me.y), U.y2 = Math.max(J.y, ie.y, le.y, me.y);
              }
              t.emplaceBack(r.x, r.y, U.x1, U.y1, U.x2, U.y2, c, f, _);
            }
            this.boxEndIndex = t.length;
          }
        }
        class J2 {
          constructor(t = [], r = (c, f) => c < f ? -1 : c > f ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0) for (let c = (this.length >> 1) - 1; c >= 0; c--) this._down(c);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: r, compare: c } = this, f = r[t];
            for (; t > 0; ) {
              const _ = t - 1 >> 1, b = r[_];
              if (c(f, b) >= 0) break;
              r[t] = b, t = _;
            }
            r[t] = f;
          }
          _down(t) {
            const { data: r, compare: c } = this, f = this.length >> 1, _ = r[t];
            for (; t < f; ) {
              let b = 1 + (t << 1);
              const C = b + 1;
              if (C < this.length && c(r[C], r[b]) < 0 && (b = C), c(r[b], _) >= 0) break;
              r[t] = r[b], t = b;
            }
            r[t] = _;
          }
        }
        function Q2(n, t = 1, r = false) {
          const c = ul.fromPoints(n[0]), f = Math.min(c.width(), c.height());
          let _ = f / 2;
          const b = new J2([], eC), { minX: C, minY: P, maxX: E, maxY: A } = c;
          if (f === 0) return new w(C, P);
          for (let H = C; H < E; H += f) for (let J = P; J < A; J += f) b.push(new Tc(H + _, J + _, _, n));
          let B = (function(H) {
            let J = 0, ie = 0, le = 0;
            const me = H[0];
            for (let Oe = 0, Se = me.length, Ee = Se - 1; Oe < Se; Ee = Oe++) {
              const He = me[Oe], rt = me[Ee], _t = He.x * rt.y - rt.x * He.y;
              ie += (He.x + rt.x) * _t, le += (He.y + rt.y) * _t, J += 3 * _t;
            }
            return new Tc(ie / J, le / J, 0, H);
          })(n), U = b.length;
          for (; b.length; ) {
            const H = b.pop();
            (H.d > B.d || !B.d) && (B = H, r && console.log("found best %d after %d probes", Math.round(1e4 * H.d) / 1e4, U)), H.max - B.d <= t || (_ = H.h / 2, b.push(new Tc(H.p.x - _, H.p.y - _, _, n)), b.push(new Tc(H.p.x + _, H.p.y - _, _, n)), b.push(new Tc(H.p.x - _, H.p.y + _, _, n)), b.push(new Tc(H.p.x + _, H.p.y + _, _, n)), U += 4);
          }
          return r && (console.log(`num probes: ${U}`), console.log(`best distance: ${B.d}`)), B.p;
        }
        function eC(n, t) {
          return t.max - n.max;
        }
        function Tc(n, t, r, c) {
          this.p = new w(n, t), this.h = r, this.d = (function(f, _) {
            let b = false, C = 1 / 0;
            for (let P = 0; P < _.length; P++) {
              const E = _[P];
              for (let A = 0, B = E.length, U = B - 1; A < B; U = A++) {
                const H = E[A], J = E[U];
                H.y > f.y != J.y > f.y && f.x < (J.x - H.x) * (f.y - H.y) / (J.y - H.y) + H.x && (b = !b), C = Math.min(C, Zv(f, H, J));
              }
            }
            return (b ? 1 : -1) * Math.sqrt(C);
          })(this.p, c), this.max = this.d + this.h * Math.SQRT2;
        }
        var ai;
        p.aE = void 0, (ai = p.aE || (p.aE = {}))[ai.center = 1] = "center", ai[ai.left = 2] = "left", ai[ai.right = 3] = "right", ai[ai.top = 4] = "top", ai[ai.bottom = 5] = "bottom", ai[ai["top-left"] = 6] = "top-left", ai[ai["top-right"] = 7] = "top-right", ai[ai["bottom-left"] = 8] = "bottom-left", ai[ai["bottom-right"] = 9] = "bottom-right";
        const Jf = Number.POSITIVE_INFINITY;
        function u_(n, t) {
          return t[1] !== Jf ? (function(r, c, f) {
            let _ = 0, b = 0;
            switch (c = Math.abs(c), f = Math.abs(f), r) {
              case "top-right":
              case "top-left":
              case "top":
                b = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                b = 7 - f;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                _ = -c;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                _ = c;
            }
            return [_, b];
          })(n, t[0], t[1]) : (function(r, c) {
            let f = 0, _ = 0;
            c < 0 && (c = 0);
            const b = c / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                _ = b - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                _ = 7 - b;
                break;
              case "bottom":
                _ = 7 - c;
                break;
              case "top":
                _ = c - 7;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                f = -b;
                break;
              case "top-left":
              case "bottom-left":
                f = b;
                break;
              case "left":
                f = c;
                break;
              case "right":
                f = -c;
            }
            return [f, _];
          })(n, t[0]);
        }
        function d_(n, t, r) {
          var c;
          const f = n.layout, _ = (c = f.get("text-variable-anchor-offset")) === null || c === void 0 ? void 0 : c.evaluate(t, {}, r);
          if (_) {
            const C = _.values, P = [];
            for (let E = 0; E < C.length; E += 2) {
              const A = P[E] = C[E], B = C[E + 1].map(((U) => U * qn));
              A.startsWith("top") ? B[1] -= 7 : A.startsWith("bottom") && (B[1] += 7), P[E + 1] = B;
            }
            return new hi(P);
          }
          const b = f.get("text-variable-anchor");
          if (b) {
            let C;
            C = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [f.get("text-radial-offset").evaluate(t, {}, r) * qn, Jf] : f.get("text-offset").evaluate(t, {}, r).map(((E) => E * qn));
            const P = [];
            for (const E of b) P.push(E, u_(E, C));
            return new hi(P);
          }
          return null;
        }
        function Qf(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function tC(n, t, r, c, f, _, b, C, P, E, A, B) {
          let U = _.textMaxSize.evaluate(t, {});
          U === void 0 && (U = b);
          const H = n.layers[0].layout, J = H.get("icon-offset").evaluate(t, {}, A), ie = p_(r.horizontal), le = b / 24, me = n.tilePixelRatio * le, Oe = n.tilePixelRatio * U / 24, Se = n.tilePixelRatio * C, Ee = n.tilePixelRatio * H.get("symbol-spacing"), He = H.get("text-padding") * n.tilePixelRatio, rt = (function(mr, nr, Ht, Rr = 1) {
            const bn = mr.get("icon-padding").evaluate(nr, {}, Ht), Bn = bn && bn.values;
            return [Bn[0] * Rr, Bn[1] * Rr, Bn[2] * Rr, Bn[3] * Rr];
          })(H, t, A, n.tilePixelRatio), _t = H.get("text-max-angle") / 180 * Math.PI, Ft = H.get("text-rotation-alignment") !== "viewport" && H.get("symbol-placement") !== "point", Mt = H.get("icon-rotation-alignment") === "map" && H.get("symbol-placement") !== "point", zt = H.get("symbol-placement"), Jt = Ee / 2, Rt = H.get("icon-text-fit");
          let At;
          c && Rt !== "none" && (n.allowVerticalPlacement && r.vertical && (At = By(c, r.vertical, Rt, H.get("icon-text-fit-padding"), J, le)), ie && (c = By(c, ie, Rt, H.get("icon-text-fit-padding"), J, le)));
          const dt = A ? B.line.getGranularityForZoomLevel(A.z) : 1, cr = (mr, nr) => {
            nr.x < 0 || nr.x >= Ye || nr.y < 0 || nr.y >= Ye || (function(Ht, Rr, bn, Bn, li, ho, $i, Yn, mn, Gn, Kn, Jn, Mi, po, Wn, ji, On, Zn, Hn, zn, un, jo, Mc, No, iC) {
              const Ic = Ht.addToLineVertexArray(Rr, bn);
              let dl, Ec, Rc, zc, v_ = 0, y_ = 0, __ = 0, b_ = 0, am = -1, lm = -1;
              const Os = {};
              let x_ = ha("");
              if (Ht.allowVerticalPlacement && Bn.vertical) {
                const gi = Yn.layout.get("text-rotate").evaluate(un, {}, No) + 90;
                Rc = new Yh(mn, Rr, Gn, Kn, Jn, Bn.vertical, Mi, po, Wn, gi), $i && (zc = new Yh(mn, Rr, Gn, Kn, Jn, $i, On, Zn, Wn, gi));
              }
              if (li) {
                const gi = Yn.layout.get("icon-rotate").evaluate(un, {}), fo = Yn.layout.get("icon-text-fit") !== "none", hl = l_(li, gi, Mc, fo), Uo = $i ? l_($i, gi, Mc, fo) : void 0;
                Ec = new Yh(mn, Rr, Gn, Kn, Jn, li, On, Zn, false, gi), v_ = 4 * hl.length;
                const pl = Ht.iconSizeData;
                let ls = null;
                pl.kind === "source" ? (ls = [Bs * Yn.layout.get("icon-size").evaluate(un, {})], ls[0] > ma && Ct(`${Ht.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : pl.kind === "composite" && (ls = [Bs * jo.compositeIconSizes[0].evaluate(un, {}, No), Bs * jo.compositeIconSizes[1].evaluate(un, {}, No)], (ls[0] > ma || ls[1] > ma) && Ct(`${Ht.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Ht.addSymbols(Ht.icon, hl, ls, zn, Hn, un, p.ao.none, Rr, Ic.lineStartIndex, Ic.lineLength, -1, No), am = Ht.icon.placedSymbolArray.length - 1, Uo && (y_ = 4 * Uo.length, Ht.addSymbols(Ht.icon, Uo, ls, zn, Hn, un, p.ao.vertical, Rr, Ic.lineStartIndex, Ic.lineLength, -1, No), lm = Ht.icon.placedSymbolArray.length - 1);
              }
              const w_ = Object.keys(Bn.horizontal);
              for (const gi of w_) {
                const fo = Bn.horizontal[gi];
                if (!dl) {
                  x_ = ha(fo.text);
                  const Uo = Yn.layout.get("text-rotate").evaluate(un, {}, No);
                  dl = new Yh(mn, Rr, Gn, Kn, Jn, fo, Mi, po, Wn, Uo);
                }
                const hl = fo.positionedLines.length === 1;
                if (__ += h_(Ht, Rr, fo, ho, Yn, Wn, un, ji, Ic, Bn.vertical ? p.ao.horizontal : p.ao.horizontalOnly, hl ? w_ : [gi], Os, am, jo, No), hl) break;
              }
              Bn.vertical && (b_ += h_(Ht, Rr, Bn.vertical, ho, Yn, Wn, un, ji, Ic, p.ao.vertical, ["vertical"], Os, lm, jo, No));
              const oC = dl ? dl.boxStartIndex : Ht.collisionBoxArray.length, sC = dl ? dl.boxEndIndex : Ht.collisionBoxArray.length, aC = Rc ? Rc.boxStartIndex : Ht.collisionBoxArray.length, lC = Rc ? Rc.boxEndIndex : Ht.collisionBoxArray.length, cC = Ec ? Ec.boxStartIndex : Ht.collisionBoxArray.length, uC = Ec ? Ec.boxEndIndex : Ht.collisionBoxArray.length, dC = zc ? zc.boxStartIndex : Ht.collisionBoxArray.length, hC = zc ? zc.boxEndIndex : Ht.collisionBoxArray.length;
              let Vo = -1;
              const Jh = (gi, fo) => gi && gi.circleDiameter ? Math.max(gi.circleDiameter, fo) : fo;
              Vo = Jh(dl, Vo), Vo = Jh(Rc, Vo), Vo = Jh(Ec, Vo), Vo = Jh(zc, Vo);
              const C_ = Vo > -1 ? 1 : 0;
              C_ && (Vo *= iC / qn), Ht.glyphOffsetArray.length >= kc.MAX_GLYPHS && Ct("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), un.sortKey !== void 0 && Ht.addToSortKeyRanges(Ht.symbolInstances.length, un.sortKey);
              const pC = d_(Yn, un, No), [fC, mC] = (function(gi, fo) {
                const hl = gi.length, Uo = fo == null ? void 0 : fo.values;
                if ((Uo == null ? void 0 : Uo.length) > 0) for (let pl = 0; pl < Uo.length; pl += 2) {
                  const ls = Uo[pl + 1];
                  gi.emplaceBack(p.aE[Uo[pl]], ls[0], ls[1]);
                }
                return [hl, gi.length];
              })(Ht.textAnchorOffsets, pC);
              Ht.symbolInstances.emplaceBack(Rr.x, Rr.y, Os.right >= 0 ? Os.right : -1, Os.center >= 0 ? Os.center : -1, Os.left >= 0 ? Os.left : -1, Os.vertical || -1, am, lm, x_, oC, sC, aC, lC, cC, uC, dC, hC, Gn, __, b_, v_, y_, C_, 0, Mi, Vo, fC, mC);
            })(n, nr, mr, r, c, f, At, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, me, [He, He, He, He], Ft, P, Se, rt, Mt, J, t, _, E, A, b);
          };
          if (zt === "line") for (const mr of r_(t.geometry, 0, 0, Ye, Ye)) {
            const nr = cl(mr, dt), Ht = K2(nr, Ee, _t, r.vertical || ie, c, 24, Oe, n.overscaling, Ye);
            for (const Rr of Ht) ie && rC(n, ie.text, Jt, Rr) || cr(nr, Rr);
          }
          else if (zt === "line-center") {
            for (const mr of t.geometry) if (mr.length > 1) {
              const nr = cl(mr, dt), Ht = Y2(nr, _t, r.vertical || ie, c, 24, Oe);
              Ht && cr(nr, Ht);
            }
          } else if (t.type === "Polygon") for (const mr of Wa(t.geometry, 0)) {
            const nr = Q2(mr, 16);
            cr(cl(mr[0], dt, true), new va(nr.x, nr.y, 0));
          }
          else if (t.type === "LineString") for (const mr of t.geometry) {
            const nr = cl(mr, dt);
            cr(nr, new va(nr[0].x, nr[0].y, 0));
          }
          else if (t.type === "Point") for (const mr of t.geometry) for (const nr of mr) cr([nr], new va(nr.x, nr.y, 0));
        }
        function h_(n, t, r, c, f, _, b, C, P, E, A, B, U, H, J) {
          const ie = (function(Oe, Se, Ee, He, rt, _t, Ft, Mt) {
            const zt = He.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180, Jt = [];
            for (const Rt of Se.positionedLines) for (const At of Rt.positionedGlyphs) {
              if (!At.rect) continue;
              const dt = At.rect || {};
              let cr = 4, mr = true, nr = 1, Ht = 0;
              const Rr = (rt || Mt) && At.vertical, bn = At.metrics.advance * At.scale / 2;
              if (Mt && Se.verticalizable && (Ht = Rt.lineOffset / 2 - (At.imageName ? -(qn - At.metrics.width * At.scale) / 2 : (At.scale - 1) * qn)), At.imageName) {
                const Zn = Ft[At.imageName];
                mr = Zn.sdf, nr = Zn.pixelRatio, cr = 1 / nr;
              }
              const Bn = rt ? [At.x + bn, At.y] : [0, 0];
              let li = rt ? [0, 0] : [At.x + bn + Ee[0], At.y + Ee[1] - Ht], ho = [0, 0];
              Rr && (ho = li, li = [0, 0]);
              const $i = At.metrics.isDoubleResolution ? 2 : 1, Yn = (At.metrics.left - cr) * At.scale - bn + li[0], mn = (-At.metrics.top - cr) * At.scale + li[1], Gn = Yn + dt.w / $i * At.scale / nr, Kn = mn + dt.h / $i * At.scale / nr, Jn = new w(Yn, mn), Mi = new w(Gn, mn), po = new w(Yn, Kn), Wn = new w(Gn, Kn);
              if (Rr) {
                const Zn = new w(-bn, bn - -17), Hn = -Math.PI / 2, zn = 12 - bn, un = new w(22 - zn, -(At.imageName ? zn : 0)), jo = new w(...ho);
                Jn._rotateAround(Hn, Zn)._add(un)._add(jo), Mi._rotateAround(Hn, Zn)._add(un)._add(jo), po._rotateAround(Hn, Zn)._add(un)._add(jo), Wn._rotateAround(Hn, Zn)._add(un)._add(jo);
              }
              if (zt) {
                const Zn = Math.sin(zt), Hn = Math.cos(zt), zn = [Hn, -Zn, Zn, Hn];
                Jn._matMult(zn), Mi._matMult(zn), po._matMult(zn), Wn._matMult(zn);
              }
              const ji = new w(0, 0), On = new w(0, 0);
              Jt.push({ tl: Jn, tr: Mi, bl: po, br: Wn, tex: dt, writingMode: Se.writingMode, glyphOffset: Bn, sectionIndex: At.sectionIndex, isSDF: mr, pixelOffsetTL: ji, pixelOffsetBR: On, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Jt;
          })(0, r, C, f, _, b, c, n.allowVerticalPlacement), le = n.textSizeData;
          let me = null;
          le.kind === "source" ? (me = [Bs * f.layout.get("text-size").evaluate(b, {})], me[0] > ma && Ct(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : le.kind === "composite" && (me = [Bs * H.compositeTextSizes[0].evaluate(b, {}, J), Bs * H.compositeTextSizes[1].evaluate(b, {}, J)], (me[0] > ma || me[1] > ma) && Ct(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, ie, me, C, _, b, E, t, P.lineStartIndex, P.lineLength, U, J);
          for (const Oe of A) B[Oe] = n.text.placedSymbolArray.length - 1;
          return 4 * ie.length;
        }
        function p_(n) {
          for (const t in n) return n[t];
          return null;
        }
        function rC(n, t, r, c) {
          const f = n.compareText;
          if (t in f) {
            const _ = f[t];
            for (let b = _.length - 1; b >= 0; b--) if (c.dist(_[b]) < r) return true;
          } else f[t] = [];
          return f[t].push(c), false;
        }
        const f_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class em {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, c] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const f = c >> 4;
            if (f !== 1) throw new Error(`Got v${f} data when expected v1.`);
            const _ = f_[15 & c];
            if (!_) throw new Error("Unrecognized array type.");
            const [b] = new Uint16Array(t, 2, 1), [C] = new Uint32Array(t, 4, 1);
            return new em(C, b, _, t);
          }
          constructor(t, r = 64, c = Float64Array, f) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = c, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const _ = f_.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, C = t * this.IndexArrayType.BYTES_PER_ELEMENT, P = (8 - C % 8) % 8;
            if (_ < 0) throw new Error(`Unexpected typed array class: ${c}.`);
            f && f instanceof ArrayBuffer ? (this.data = f, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + C + P, 2 * t), this._pos = 2 * t, this._finished = true) : (this.data = new ArrayBuffer(8 + b + C + P), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + C + P, 2 * t), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + _]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, r) {
            const c = this._pos >> 1;
            return this.ids[c] = c, this.coords[this._pos++] = t, this.coords[this._pos++] = r, c;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return tm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t, r, c, f) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: _, coords: b, nodeSize: C } = this, P = [0, _.length - 1, 0], E = [];
            for (; P.length; ) {
              const A = P.pop() || 0, B = P.pop() || 0, U = P.pop() || 0;
              if (B - U <= C) {
                for (let le = U; le <= B; le++) {
                  const me = b[2 * le], Oe = b[2 * le + 1];
                  me >= t && me <= c && Oe >= r && Oe <= f && E.push(_[le]);
                }
                continue;
              }
              const H = U + B >> 1, J = b[2 * H], ie = b[2 * H + 1];
              J >= t && J <= c && ie >= r && ie <= f && E.push(_[H]), (A === 0 ? t <= J : r <= ie) && (P.push(U), P.push(H - 1), P.push(1 - A)), (A === 0 ? c >= J : f >= ie) && (P.push(H + 1), P.push(B), P.push(1 - A));
            }
            return E;
          }
          within(t, r, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: f, coords: _, nodeSize: b } = this, C = [0, f.length - 1, 0], P = [], E = c * c;
            for (; C.length; ) {
              const A = C.pop() || 0, B = C.pop() || 0, U = C.pop() || 0;
              if (B - U <= b) {
                for (let le = U; le <= B; le++) g_(_[2 * le], _[2 * le + 1], t, r) <= E && P.push(f[le]);
                continue;
              }
              const H = U + B >> 1, J = _[2 * H], ie = _[2 * H + 1];
              g_(J, ie, t, r) <= E && P.push(f[H]), (A === 0 ? t - c <= J : r - c <= ie) && (C.push(U), C.push(H - 1), C.push(1 - A)), (A === 0 ? t + c >= J : r + c >= ie) && (C.push(H + 1), C.push(B), C.push(1 - A));
            }
            return P;
          }
        }
        function tm(n, t, r, c, f, _) {
          if (f - c <= r) return;
          const b = c + f >> 1;
          m_(n, t, b, c, f, _), tm(n, t, r, c, b - 1, 1 - _), tm(n, t, r, b + 1, f, 1 - _);
        }
        function m_(n, t, r, c, f, _) {
          for (; f > c; ) {
            if (f - c > 600) {
              const E = f - c + 1, A = r - c + 1, B = Math.log(E), U = 0.5 * Math.exp(2 * B / 3), H = 0.5 * Math.sqrt(B * U * (E - U) / E) * (A - E / 2 < 0 ? -1 : 1);
              m_(n, t, r, Math.max(c, Math.floor(r - A * U / E + H)), Math.min(f, Math.floor(r + (E - A) * U / E + H)), _);
            }
            const b = t[2 * r + _];
            let C = c, P = f;
            for (cd(n, t, c, r), t[2 * f + _] > b && cd(n, t, c, f); C < P; ) {
              for (cd(n, t, C, P), C++, P--; t[2 * C + _] < b; ) C++;
              for (; t[2 * P + _] > b; ) P--;
            }
            t[2 * c + _] === b ? cd(n, t, c, P) : (P++, cd(n, t, P, f)), P <= r && (c = P + 1), r <= P && (f = P - 1);
          }
        }
        function cd(n, t, r, c) {
          rm(n, r, c), rm(t, 2 * r, 2 * c), rm(t, 2 * r + 1, 2 * c + 1);
        }
        function rm(n, t, r) {
          const c = n[t];
          n[t] = n[r], n[r] = c;
        }
        function g_(n, t, r, c) {
          const f = n - r, _ = t - c;
          return f * f + _ * _;
        }
        var nm;
        p.cx = void 0, (nm = p.cx || (p.cx = {})).create = "create", nm.load = "load", nm.fullLoad = "fullLoad";
        let Kh = null, ud = [];
        const im = 1e3 / 60, om = "loadTime", sm = "fullLoadTime", nC = { mark(n) {
          performance.mark(n);
        }, frame(n) {
          const t = n;
          Kh != null && ud.push(t - Kh), Kh = t;
        }, clearMetrics() {
          Kh = null, ud = [], performance.clearMeasures(om), performance.clearMeasures(sm);
          for (const n in p.cx) performance.clearMarks(p.cx[n]);
        }, getPerformanceMetrics() {
          performance.measure(om, p.cx.create, p.cx.load), performance.measure(sm, p.cx.create, p.cx.fullLoad);
          const n = performance.getEntriesByName(om)[0].duration, t = performance.getEntriesByName(sm)[0].duration, r = ud.length, c = 1 / (ud.reduce(((_, b) => _ + b), 0) / r / 1e3), f = ud.filter(((_) => _ > im)).reduce(((_, b) => _ + (b - im) / im), 0);
          return { loadTime: n, fullLoadTime: t, fps: c, percentDroppedFrames: f / (r + f) * 100, totalFrames: r };
        } };
        p.$ = Ye, p.A = Z, p.B = function([n, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, { x: n * Math.cos(t) * Math.sin(r), y: n * Math.sin(t) * Math.sin(r), z: n * Math.cos(r) };
        }, p.C = To, p.D = Xt, p.E = wt, p.F = rn, p.G = rl, p.H = function(n) {
          if (ut == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            ut = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return ut;
        }, p.I = Nf, p.J = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Z2((() => this.process())), this.subscription = Et(this.target, "message", ((r) => this.receive(r)), false), this.globalScope = ir(self) ? n : window;
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t;
          }
          sendAsync(n, t) {
            return new Promise(((r, c) => {
              const f = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), _ = t ? Et(t.signal, "abort", (() => {
                _ == null ? void 0 : _.unsubscribe(), delete this.resolveRejects[f];
                const P = { id: f, type: "<cancel>", origin: location.origin, targetMapId: n.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(P);
              }), H2) : null;
              this.resolveRejects[f] = { resolve: (P) => {
                _ == null ? void 0 : _.unsubscribe(), r(P);
              }, reject: (P) => {
                _ == null ? void 0 : _.unsubscribe(), c(P);
              } };
              const b = [], C = Object.assign(Object.assign({}, n), { id: f, sourceMapId: this.mapId, origin: location.origin, data: sa(n.data, b) });
              this.target.postMessage(C, { transfer: b });
            }));
          }
          receive(n) {
            const t = n.data, r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const c = this.abortControllers[r];
                return delete this.abortControllers[r], void (c && c.abort());
              }
              if (ir(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(), t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t);
          }
          processTask(n, t) {
            return o(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const f = this.resolveRejects[n];
                return delete this.resolveRejects[n], f ? void (t.error ? f.reject(zs(t.error)) : f.resolve(zs(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = zs(t.data), c = new AbortController();
              this.abortControllers[n] = c;
              try {
                const f = yield this.messageHandlers[t.type](t.sourceMapId, r, c);
                this.completeTask(n, null, f);
              } catch (f) {
                this.completeTask(n, f);
              }
            }));
          }
          completeTask(n, t, r) {
            const c = [];
            delete this.abortControllers[n];
            const f = { id: n, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? sa(t) : null, data: sa(r, c) };
            this.target.postMessage(f, { transfer: c });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, p.K = ae, p.L = function() {
          var n = new Z(16);
          return Z != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n;
        }, p.M = function(n, t, r) {
          var c, f, _, b, C, P, E, A, B, U, H, J, ie = r[0], le = r[1], me = r[2];
          return t === n ? (n[12] = t[0] * ie + t[4] * le + t[8] * me + t[12], n[13] = t[1] * ie + t[5] * le + t[9] * me + t[13], n[14] = t[2] * ie + t[6] * le + t[10] * me + t[14], n[15] = t[3] * ie + t[7] * le + t[11] * me + t[15]) : (f = t[1], _ = t[2], b = t[3], C = t[4], P = t[5], E = t[6], A = t[7], B = t[8], U = t[9], H = t[10], J = t[11], n[0] = c = t[0], n[1] = f, n[2] = _, n[3] = b, n[4] = C, n[5] = P, n[6] = E, n[7] = A, n[8] = B, n[9] = U, n[10] = H, n[11] = J, n[12] = c * ie + C * le + B * me + t[12], n[13] = f * ie + P * le + U * me + t[13], n[14] = _ * ie + E * le + H * me + t[14], n[15] = b * ie + A * le + J * me + t[15]), n;
        }, p.N = function(n, t, r) {
          var c = r[0], f = r[1], _ = r[2];
          return n[0] = t[0] * c, n[1] = t[1] * c, n[2] = t[2] * c, n[3] = t[3] * c, n[4] = t[4] * f, n[5] = t[5] * f, n[6] = t[6] * f, n[7] = t[7] * f, n[8] = t[8] * _, n[9] = t[9] * _, n[10] = t[10] * _, n[11] = t[11] * _, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n;
        }, p.O = function(n, t, r) {
          var c = t[0], f = t[1], _ = t[2], b = t[3], C = t[4], P = t[5], E = t[6], A = t[7], B = t[8], U = t[9], H = t[10], J = t[11], ie = t[12], le = t[13], me = t[14], Oe = t[15], Se = r[0], Ee = r[1], He = r[2], rt = r[3];
          return n[0] = Se * c + Ee * C + He * B + rt * ie, n[1] = Se * f + Ee * P + He * U + rt * le, n[2] = Se * _ + Ee * E + He * H + rt * me, n[3] = Se * b + Ee * A + He * J + rt * Oe, n[4] = (Se = r[4]) * c + (Ee = r[5]) * C + (He = r[6]) * B + (rt = r[7]) * ie, n[5] = Se * f + Ee * P + He * U + rt * le, n[6] = Se * _ + Ee * E + He * H + rt * me, n[7] = Se * b + Ee * A + He * J + rt * Oe, n[8] = (Se = r[8]) * c + (Ee = r[9]) * C + (He = r[10]) * B + (rt = r[11]) * ie, n[9] = Se * f + Ee * P + He * U + rt * le, n[10] = Se * _ + Ee * E + He * H + rt * me, n[11] = Se * b + Ee * A + He * J + rt * Oe, n[12] = (Se = r[12]) * c + (Ee = r[13]) * C + (He = r[14]) * B + (rt = r[15]) * ie, n[13] = Se * f + Ee * P + He * U + rt * le, n[14] = Se * _ + Ee * E + He * H + rt * me, n[15] = Se * b + Ee * A + He * J + rt * Oe, n;
        }, p.P = w, p.Q = function(n, t) {
          const r = {};
          for (let c = 0; c < t.length; c++) {
            const f = t[c];
            f in n && (r[f] = n[f]);
          }
          return r;
        }, p.R = Oi, p.S = ga, p.T = Ef, p.U = Zy, p.V = Wy, p.W = W, p.X = N, p.Y = et, p.Z = uo, p._ = o, p.a = re, p.a$ = Ne, p.a0 = function(n, t) {
          var r, c, f, _;
          if (!n) return t ?? {};
          if (!t) return n;
          const b = Object.assign({}, n);
          if (t.removeAll && (b.removeAll = true), t.remove) {
            const C = new Set(b.remove ? b.remove.concat(t.remove) : t.remove);
            b.remove = Array.from(C.values());
          }
          if (t.add) {
            const C = b.add ? b.add.concat(t.add) : t.add, P = new Map(C.map(((E) => [E.id, E])));
            b.add = Array.from(P.values());
          }
          if (t.update) {
            const C = new Map((r = b.update) === null || r === void 0 ? void 0 : r.map(((P) => [P.id, P])));
            for (const P of t.update) {
              const E = (c = C.get(P.id)) !== null && c !== void 0 ? c : { id: P.id };
              P.newGeometry && (E.newGeometry = P.newGeometry), P.addOrUpdateProperties && (E.addOrUpdateProperties = ((f = E.addOrUpdateProperties) !== null && f !== void 0 ? f : []).concat(P.addOrUpdateProperties)), P.removeProperties && (E.removeProperties = ((_ = E.removeProperties) !== null && _ !== void 0 ? _ : []).concat(P.removeProperties)), P.removeAllProperties && (E.removeAllProperties = true), C.set(P.id, E);
            }
            b.update = Array.from(C.values());
          }
          return b;
        }, p.a1 = ad, p.a2 = ul, p.a3 = 25, p.a4 = Kf, p.a5 = (n) => {
          const t = window.document.createElement("video");
          return t.muted = true, new Promise(((r) => {
            t.onloadstart = () => {
              r(t);
            };
            for (const c of n) {
              const f = window.document.createElement("source");
              fe(c) || (t.crossOrigin = "Anonymous"), f.src = c, t.appendChild(f);
            }
          }));
        }, p.a6 = ye, p.a7 = function() {
          return yr++;
        }, p.a8 = $, p.a9 = kc, p.aA = function(n) {
          let t = 1 / 0, r = 1 / 0, c = -1 / 0, f = -1 / 0;
          for (const _ of n) t = Math.min(t, _.x), r = Math.min(r, _.y), c = Math.max(c, _.x), f = Math.max(f, _.y);
          return [t, r, c, f];
        }, p.aB = qn, p.aC = Ke, p.aD = function(n, t, r, c, f = false) {
          if (!r[0] && !r[1]) return [0, 0];
          const _ = f ? c === "map" ? -n.bearingInRadians : 0 : c === "viewport" ? n.bearingInRadians : 0;
          if (_) {
            const b = Math.sin(_), C = Math.cos(_);
            r = [r[0] * C - r[1] * b, r[0] * b + r[1] * C];
          }
          return [f ? r[0] : Ke(t, r[0], n.zoom), f ? r[1] : Ke(t, r[1], n.zoom)];
        }, p.aF = qf, p.aG = Qf, p.aH = Uf, p.aI = em, p.aJ = Cn, p.aK = Nh, p.aL = we, p.aM = br, p.aN = Kr, p.aO = jt, p.aP = St, p.aQ = Xy, p.aR = oe, p.aS = Q, p.aT = function(n) {
          var t = new Z(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t;
        }, p.aU = function(n, t, r) {
          return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], n;
        }, p.aV = function(n, t) {
          var r = t[0], c = t[1], f = t[2], _ = r * r + c * c + f * f;
          return _ > 0 && (_ = 1 / Math.sqrt(_)), n[0] = t[0] * _, n[1] = t[1] * _, n[2] = t[2] * _, n;
        }, p.aW = ve, p.aX = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
        }, p.aY = function(n, t, r) {
          return n[0] = t[0] * r[0], n[1] = t[1] * r[1], n[2] = t[2] * r[2], n[3] = t[3] * r[3], n;
        }, p.aZ = he, p.a_ = function(n, t, r) {
          const c = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return c === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / c;
        }, p.aa = Is, p.ab = $o, p.ac = Qy, p.ad = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, c, f, _) => {
            const b = f || _;
            return t[c] = !b || b.toLowerCase(), "";
          })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r;
          }
          return t;
        }, p.ae = st, p.af = function(n) {
          return Math.pow(2, n);
        }, p.ag = te, p.ah = vt, p.ai = 85.051129, p.aj = Hy, p.ak = function(n) {
          return Math.log(n) / Math.LN2;
        }, p.al = function(n) {
          var t = n[0], r = n[1];
          return t * t + r * r;
        }, p.am = function(n, t) {
          const r = [];
          for (const c in n) c in t || r.push(c);
          return r;
        }, p.an = function(n, t) {
          let r = 0, c = 0;
          if (n.kind === "constant") c = n.layoutSize;
          else if (n.kind !== "source") {
            const { interpolationType: f, minZoom: _, maxZoom: b } = n, C = f ? vt(Xn.interpolationFactor(f, t, _, b), 0, 1) : 0;
            n.kind === "camera" ? c = To.number(n.minSize, n.maxSize, C) : r = C;
          }
          return { uSizeT: r, uSize: c };
        }, p.ap = function(n, { uSize: t, uSizeT: r }, { lowerSize: c, upperSize: f }) {
          return n.kind === "source" ? c / Bs : n.kind === "composite" ? To.number(c / Bs, f / Bs, r) : t;
        }, p.aq = function(n, t) {
          var r = t[0], c = t[1], f = t[2], _ = t[3], b = t[4], C = t[5], P = t[6], E = t[7], A = t[8], B = t[9], U = t[10], H = t[11], J = t[12], ie = t[13], le = t[14], me = t[15], Oe = r * C - c * b, Se = r * P - f * b, Ee = r * E - _ * b, He = c * P - f * C, rt = c * E - _ * C, _t = f * E - _ * P, Ft = A * ie - B * J, Mt = A * le - U * J, zt = A * me - H * J, Jt = B * le - U * ie, Rt = B * me - H * ie, At = U * me - H * le, dt = Oe * At - Se * Rt + Ee * Jt + He * zt - rt * Mt + _t * Ft;
          return dt ? (n[0] = (C * At - P * Rt + E * Jt) * (dt = 1 / dt), n[1] = (f * Rt - c * At - _ * Jt) * dt, n[2] = (ie * _t - le * rt + me * He) * dt, n[3] = (U * rt - B * _t - H * He) * dt, n[4] = (P * zt - b * At - E * Mt) * dt, n[5] = (r * At - f * zt + _ * Mt) * dt, n[6] = (le * Ee - J * _t - me * Se) * dt, n[7] = (A * _t - U * Ee + H * Se) * dt, n[8] = (b * Rt - C * zt + E * Ft) * dt, n[9] = (c * zt - r * Rt - _ * Ft) * dt, n[10] = (J * rt - ie * Ee + me * Oe) * dt, n[11] = (B * Ee - A * rt - H * Oe) * dt, n[12] = (C * Mt - b * Jt - P * Ft) * dt, n[13] = (r * Jt - c * Mt + f * Ft) * dt, n[14] = (ie * Se - J * He - le * Oe) * dt, n[15] = (A * He - B * Se + U * Oe) * dt, n) : null;
        }, p.ar = xt, p.as = function(n) {
          var t = n[0], r = n[1];
          return Math.sqrt(t * t + r * r);
        }, p.at = function(n) {
          return n[0] = 0, n[1] = 0, n;
        }, p.au = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n;
        }, p.av = Gf, p.aw = Pe, p.ax = function(n, t, r, c) {
          const f = t.y - n.y, _ = t.x - n.x, b = c.y - r.y, C = c.x - r.x, P = b * _ - C * f;
          if (P === 0) return null;
          const E = (C * (n.y - r.y) - b * (n.x - r.x)) / P;
          return new w(n.x + E * _, n.y + E * f);
        }, p.ay = r_, p.az = Gv, p.b = We, p.b$ = class extends v {
        }, p.b0 = function(n, t, r) {
          return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[3] = t[3] * r, n;
        }, p.b1 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3];
        }, p.b2 = Ky, p.b3 = Pc, p.b4 = function(n, t, r, c, f) {
          var _ = 1 / Math.tan(t / 2);
          if (n[0] = _ / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = _, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, f != null && f !== 1 / 0) {
            var b = 1 / (c - f);
            n[10] = (f + c) * b, n[14] = 2 * f * c * b;
          } else n[10] = -1, n[14] = -2 * c;
          return n;
        }, p.b5 = function(n) {
          var t = new Z(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t;
        }, p.b6 = function(n, t, r) {
          var c = Math.sin(r), f = Math.cos(r), _ = t[0], b = t[1], C = t[2], P = t[3], E = t[4], A = t[5], B = t[6], U = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = _ * f + E * c, n[1] = b * f + A * c, n[2] = C * f + B * c, n[3] = P * f + U * c, n[4] = E * f - _ * c, n[5] = A * f - b * c, n[6] = B * f - C * c, n[7] = U * f - P * c, n;
        }, p.b7 = function(n, t, r) {
          var c = Math.sin(r), f = Math.cos(r), _ = t[4], b = t[5], C = t[6], P = t[7], E = t[8], A = t[9], B = t[10], U = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = _ * f + E * c, n[5] = b * f + A * c, n[6] = C * f + B * c, n[7] = P * f + U * c, n[8] = E * f - _ * c, n[9] = A * f - b * c, n[10] = B * f - C * c, n[11] = U * f - P * c, n;
        }, p.b8 = function() {
          const n = new Float32Array(16);
          return te(n), n;
        }, p.b9 = function() {
          const n = new Float64Array(16);
          return te(n), n;
        }, p.bA = function(n, t) {
          const r = Lt(n, 360), c = Lt(t, 360), f = c - r, _ = c > r ? f - 360 : f + 360;
          return Math.abs(f) < Math.abs(_) ? f : _;
        }, p.bB = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n;
        }, p.bC = function(n, t, r, c) {
          const f = Math.sqrt(n * n + t * t), _ = Math.sqrt(r * r + c * c);
          n /= f, t /= f, r /= _, c /= _;
          const b = Math.acos(n * r + t * c);
          return -t * r + n * c > 0 ? b : -b;
        }, p.bD = function(n, t) {
          const r = Lt(n, 2 * Math.PI), c = Lt(t, 2 * Math.PI);
          return Math.min(Math.abs(r - c), Math.abs(r - c + 2 * Math.PI), Math.abs(r - c - 2 * Math.PI));
        }, p.bE = function() {
          const n = {}, t = Te.$version;
          for (const r in Te.$root) {
            const c = Te.$root[r];
            if (c.required) {
              let f = null;
              f = r === "version" ? t : c.type === "array" ? [] : {}, f != null && (n[r] = f);
            }
          }
          return n;
        }, p.bF = ac, p.bG = Ie, p.bH = function n(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return false;
            for (let c = 0; c < t.length; c++) if (!n(t[c], r[c])) return false;
            return true;
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return false;
            for (const c in t) if (!n(t[c], r[c])) return false;
            return true;
          }
          return t === r;
        }, p.bI = function(n) {
          n = n.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
          for (let r = 0; r < n.length; r++) "ref" in n[r] && (n[r] = or(n[r], t[n[r].ref]));
          return n;
        }, p.bJ = function(n) {
          if (n.type === "custom") return new W2(n);
          switch (n.type) {
            case "background":
              return new U2(n);
            case "circle":
              return new Mw(n);
            case "color-relief":
              return new Dw(n);
            case "fill":
              return new Xw(n);
            case "fill-extrusion":
              return new s2(n);
            case "heatmap":
              return new Ew(n);
            case "hillshade":
              return new zw(n);
            case "line":
              return new p2(n);
            case "raster":
              return new G2(n);
            case "symbol":
              return new Wh(n);
          }
        }, p.bK = rr, p.bL = function(n, t) {
          if (!n) return [{ command: "setStyle", args: [t] }];
          let r = [];
          try {
            if (!Wt(n.version, t.version)) return [{ command: "setStyle", args: [t] }];
            Wt(n.center, t.center) || r.push({ command: "setCenter", args: [t.center] }), Wt(n.state, t.state) || r.push({ command: "setGlobalState", args: [t.state] }), Wt(n.centerAltitude, t.centerAltitude) || r.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), Wt(n.zoom, t.zoom) || r.push({ command: "setZoom", args: [t.zoom] }), Wt(n.bearing, t.bearing) || r.push({ command: "setBearing", args: [t.bearing] }), Wt(n.pitch, t.pitch) || r.push({ command: "setPitch", args: [t.pitch] }), Wt(n.roll, t.roll) || r.push({ command: "setRoll", args: [t.roll] }), Wt(n.sprite, t.sprite) || r.push({ command: "setSprite", args: [t.sprite] }), Wt(n.glyphs, t.glyphs) || r.push({ command: "setGlyphs", args: [t.glyphs] }), Wt(n.transition, t.transition) || r.push({ command: "setTransition", args: [t.transition] }), Wt(n.light, t.light) || r.push({ command: "setLight", args: [t.light] }), Wt(n.terrain, t.terrain) || r.push({ command: "setTerrain", args: [t.terrain] }), Wt(n.sky, t.sky) || r.push({ command: "setSky", args: [t.sky] }), Wt(n.projection, t.projection) || r.push({ command: "setProjection", args: [t.projection] });
            const c = {}, f = [];
            (function(b, C, P, E) {
              let A;
              for (A in C = C || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, A) && (Object.prototype.hasOwnProperty.call(C, A) || Qr(A, P, E));
              for (A in C) Object.prototype.hasOwnProperty.call(C, A) && (Object.prototype.hasOwnProperty.call(b, A) ? Wt(b[A], C[A]) || (b[A].type === "geojson" && C[A].type === "geojson" && sn(b, C, A) ? dr(P, { command: "setGeoJSONSourceData", args: [A, C[A].data] }) : en(A, C, P, E)) : Or(A, C, P));
            })(n.sources, t.sources, f, c);
            const _ = [];
            n.layers && n.layers.forEach(((b) => {
              "source" in b && c[b.source] ? r.push({ command: "removeLayer", args: [b.id] }) : _.push(b);
            })), r = r.concat(f), (function(b, C, P) {
              C = C || [];
              const E = (b = b || []).map(wr), A = C.map(wr), B = b.reduce(Hr, {}), U = C.reduce(Hr, {}), H = E.slice(), J = /* @__PURE__ */ Object.create(null);
              let ie, le, me, Oe, Se;
              for (let Ee = 0, He = 0; Ee < E.length; Ee++) ie = E[Ee], Object.prototype.hasOwnProperty.call(U, ie) ? He++ : (dr(P, { command: "removeLayer", args: [ie] }), H.splice(H.indexOf(ie, He), 1));
              for (let Ee = 0, He = 0; Ee < A.length; Ee++) ie = A[A.length - 1 - Ee], H[H.length - 1 - Ee] !== ie && (Object.prototype.hasOwnProperty.call(B, ie) ? (dr(P, { command: "removeLayer", args: [ie] }), H.splice(H.lastIndexOf(ie, H.length - He), 1)) : He++, Oe = H[H.length - Ee], dr(P, { command: "addLayer", args: [U[ie], Oe] }), H.splice(H.length - Ee, 0, ie), J[ie] = true);
              for (let Ee = 0; Ee < A.length; Ee++) if (ie = A[Ee], le = B[ie], me = U[ie], !J[ie] && !Wt(le, me)) if (Wt(le.source, me.source) && Wt(le["source-layer"], me["source-layer"]) && Wt(le.type, me.type)) {
                for (Se in _r(le.layout, me.layout, P, ie, null, "setLayoutProperty"), _r(le.paint, me.paint, P, ie, null, "setPaintProperty"), Wt(le.filter, me.filter) || dr(P, { command: "setFilter", args: [ie, me.filter] }), Wt(le.minzoom, me.minzoom) && Wt(le.maxzoom, me.maxzoom) || dr(P, { command: "setLayerZoomRange", args: [ie, me.minzoom, me.maxzoom] }), le) Object.prototype.hasOwnProperty.call(le, Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && (Se.indexOf("paint.") === 0 ? _r(le[Se], me[Se], P, ie, Se.slice(6), "setPaintProperty") : Wt(le[Se], me[Se]) || dr(P, { command: "setLayerProperty", args: [ie, Se, me[Se]] }));
                for (Se in me) Object.prototype.hasOwnProperty.call(me, Se) && !Object.prototype.hasOwnProperty.call(le, Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && (Se.indexOf("paint.") === 0 ? _r(le[Se], me[Se], P, ie, Se.slice(6), "setPaintProperty") : Wt(le[Se], me[Se]) || dr(P, { command: "setLayerProperty", args: [ie, Se, me[Se]] }));
              } else dr(P, { command: "removeLayer", args: [ie] }), Oe = H[H.lastIndexOf(ie) + 1], dr(P, { command: "addLayer", args: [me, Oe] });
            })(_, t.layers, r);
          } catch (c) {
            console.warn("Unable to compute style diff:", c), r = [{ command: "setStyle", args: [t] }];
          }
          return r;
        }, p.bM = function(n) {
          const t = [], r = n.id;
          return r === void 0 && t.push({ message: `layers.${r}: missing required property "id"` }), n.render === void 0 && t.push({ message: `layers.${r}: missing required method "render"` }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, p.bN = Tr, p.bO = zr, p.bP = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = 0;
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n));
          }
        }, p.bQ = Ln, p.bR = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = Hi;
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, false, n);
            for (let t = 1; t < 16; t++) if (n[t] !== this.current[t]) {
              this.current = n, this.gl.uniformMatrix4fv(this.location, false, n);
              break;
            }
          }
        }, p.bS = En, p.bT = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0];
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]));
          }
        }, p.bU = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = [0, 0];
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]));
          }
        }, p.bV = X, p.bW = function(n, t) {
          var r = Math.sin(t), c = Math.cos(t);
          return n[0] = c, n[1] = r, n[2] = 0, n[3] = -r, n[4] = c, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n;
        }, p.bX = function(n, t, r) {
          var c = t[0], f = t[1], _ = t[2];
          return n[0] = c * r[0] + f * r[3] + _ * r[6], n[1] = c * r[1] + f * r[4] + _ * r[7], n[2] = c * r[2] + f * r[5] + _ * r[8], n;
        }, p.bY = function(n, t, r, c, f, _, b) {
          var C = 1 / (t - r), P = 1 / (c - f), E = 1 / (_ - b);
          return n[0] = -2 * C, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * P, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * E, n[11] = 0, n[12] = (t + r) * C, n[13] = (f + c) * P, n[14] = (b + _) * E, n[15] = 1, n;
        }, p.bZ = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = new Array();
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let r = 0; r < n.length; r++) t[4 * r] = n[r].r, t[4 * r + 1] = n[r].g, t[4 * r + 2] = n[r].b, t[4 * r + 3] = n[r].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, p.b_ = class extends mi {
          constructor(n, t) {
            super(n, t), this.current = new Array();
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, p.ba = function() {
          return new Float64Array(16);
        }, p.bb = function(n, t, r) {
          const c = new Float64Array(4);
          return at(c, n, t - 90, r), c;
        }, p.bc = function(n, t, r, c) {
          var f, _, b, C, P, E = t[0], A = t[1], B = t[2], U = t[3], H = r[0], J = r[1], ie = r[2], le = r[3];
          return (_ = E * H + A * J + B * ie + U * le) < 0 && (_ = -_, H = -H, J = -J, ie = -ie, le = -le), 1 - _ > K ? (f = Math.acos(_), b = Math.sin(f), C = Math.sin((1 - c) * f) / b, P = Math.sin(c * f) / b) : (C = 1 - c, P = c), n[0] = C * E + P * H, n[1] = C * A + P * J, n[2] = C * B + P * ie, n[3] = C * U + P * le, n;
        }, p.bd = function(n) {
          const t = new Float64Array(9);
          var r, c, f, _, b, C, P, E, A, B, U, H, J, ie, le, me, Oe, Se;
          B = (f = (c = n)[0]) * (P = f + f), U = (_ = c[1]) * P, J = (b = c[2]) * P, ie = b * (E = _ + _), me = (C = c[3]) * P, Oe = C * E, Se = C * (A = b + b), (r = t)[0] = 1 - (H = _ * E) - (le = b * A), r[3] = U - Se, r[6] = J + Oe, r[1] = U + Se, r[4] = 1 - B - le, r[7] = ie - me, r[2] = J - Oe, r[5] = ie + me, r[8] = 1 - B - H;
          const Ee = St(-Math.asin(vt(t[2], -1, 1)));
          let He, rt;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (He = 0, rt = -St(Math.atan2(t[3], t[4]))) : (He = St(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), rt = St(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: He, pitch: Ee + 90, bearing: rt };
        }, p.be = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing;
        }, p.bf = kr, p.bg = os, p.bh = xc, p.bi = td, p.bj = bc, p.bk = ct, p.bl = bt, p.bm = oi, p.bn = function(n, t, r, c, f) {
          return ct(c, f, vt((n - t) / (r - t), 0, 1));
        }, p.bo = Lt, p.bp = function() {
          return new Float64Array(3);
        }, p.bq = function(n, t, r, c) {
          return n[0] = t[0] + r[0] * c, n[1] = t[1] + r[1] * c, n[2] = t[2] + r[2] * c, n;
        }, p.br = at, p.bs = function(n, t, r) {
          var c = r[0], f = r[1], _ = r[2], b = r[3], C = t[0], P = t[1], E = t[2], A = f * E - _ * P, B = _ * C - c * E, U = c * P - f * C;
          return n[0] = C + b * (A += A) + f * (U += U) - _ * (B += B), n[1] = P + b * B + _ * A - c * U, n[2] = E + b * U + c * B - f * A, n;
        }, p.bt = function(n, t, r) {
          const c = (f = [n[0], n[1], n[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((A = f[8]) * (b = f[4]) - (C = f[5]) * (E = f[7])) + f[1] * (-A * (_ = f[3]) + C * (P = f[6])) + f[2] * (E * _ - b * P);
          var f, _, b, C, P, E, A;
          if (c === 0) return null;
          const B = ve([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]), U = ve([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]), H = ve([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]), J = oe([], B, -n[3]);
          return Q(J, J, oe([], U, -t[3])), Q(J, J, oe([], H, -r[3])), oe(J, J, 1 / c), J;
        }, p.bu = Xf, p.bv = function() {
          return new Float64Array(4);
        }, p.bw = function(n, t, r, c) {
          var f = [], _ = [];
          return f[0] = t[0] - r[0], f[1] = t[1] - r[1], f[2] = t[2] - r[2], _[0] = f[0] * Math.cos(c) - f[1] * Math.sin(c), _[1] = f[0] * Math.sin(c) + f[1] * Math.cos(c), _[2] = f[2], n[0] = _[0] + r[0], n[1] = _[1] + r[1], n[2] = _[2] + r[2], n;
        }, p.bx = function(n, t, r, c) {
          var f = [], _ = [];
          return f[0] = t[0] - r[0], f[1] = t[1] - r[1], f[2] = t[2] - r[2], _[0] = f[0], _[1] = f[1] * Math.cos(c) - f[2] * Math.sin(c), _[2] = f[1] * Math.sin(c) + f[2] * Math.cos(c), n[0] = _[0] + r[0], n[1] = _[1] + r[1], n[2] = _[2] + r[2], n;
        }, p.by = function(n, t, r, c) {
          var f = [], _ = [];
          return f[0] = t[0] - r[0], f[1] = t[1] - r[1], f[2] = t[2] - r[2], _[0] = f[2] * Math.sin(c) + f[0] * Math.cos(c), _[1] = f[1], _[2] = f[2] * Math.cos(c) - f[0] * Math.sin(c), n[0] = _[0] + r[0], n[1] = _[1] + r[1], n[2] = _[2] + r[2], n;
        }, p.bz = function(n, t, r) {
          var c = Math.sin(r), f = Math.cos(r), _ = t[0], b = t[1], C = t[2], P = t[3], E = t[8], A = t[9], B = t[10], U = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = _ * f - E * c, n[1] = b * f - A * c, n[2] = C * f - B * c, n[3] = P * f - U * c, n[8] = _ * c + E * f, n[9] = b * c + A * f, n[10] = C * c + B * f, n[11] = P * c + U * f, n;
        }, p.c = Le, p.c0 = v2, p.c1 = class extends s {
        }, p.c2 = If, p.c3 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
        }, p.c4 = ty, p.c5 = function(n, t, r) {
          var c = t[0], f = t[1], _ = t[2], b = r[3] * c + r[7] * f + r[11] * _ + r[15];
          return n[0] = (r[0] * c + r[4] * f + r[8] * _ + r[12]) / (b = b || 1), n[1] = (r[1] * c + r[5] * f + r[9] * _ + r[13]) / b, n[2] = (r[2] * c + r[6] * f + r[10] * _ + r[14]) / b, n;
        }, p.c6 = class extends qu {
        }, p.c7 = class extends D {
        }, p.c8 = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15];
        }, p.c9 = function(n, t) {
          var r = n[0], c = n[1], f = n[2], _ = n[3], b = n[4], C = n[5], P = n[6], E = n[7], A = n[8], B = n[9], U = n[10], H = n[11], J = n[12], ie = n[13], le = n[14], me = n[15], Oe = t[0], Se = t[1], Ee = t[2], He = t[3], rt = t[4], _t = t[5], Ft = t[6], Mt = t[7], zt = t[8], Jt = t[9], Rt = t[10], At = t[11], dt = t[12], cr = t[13], mr = t[14], nr = t[15];
          return Math.abs(r - Oe) <= K * Math.max(1, Math.abs(r), Math.abs(Oe)) && Math.abs(c - Se) <= K * Math.max(1, Math.abs(c), Math.abs(Se)) && Math.abs(f - Ee) <= K * Math.max(1, Math.abs(f), Math.abs(Ee)) && Math.abs(_ - He) <= K * Math.max(1, Math.abs(_), Math.abs(He)) && Math.abs(b - rt) <= K * Math.max(1, Math.abs(b), Math.abs(rt)) && Math.abs(C - _t) <= K * Math.max(1, Math.abs(C), Math.abs(_t)) && Math.abs(P - Ft) <= K * Math.max(1, Math.abs(P), Math.abs(Ft)) && Math.abs(E - Mt) <= K * Math.max(1, Math.abs(E), Math.abs(Mt)) && Math.abs(A - zt) <= K * Math.max(1, Math.abs(A), Math.abs(zt)) && Math.abs(B - Jt) <= K * Math.max(1, Math.abs(B), Math.abs(Jt)) && Math.abs(U - Rt) <= K * Math.max(1, Math.abs(U), Math.abs(Rt)) && Math.abs(H - At) <= K * Math.max(1, Math.abs(H), Math.abs(At)) && Math.abs(J - dt) <= K * Math.max(1, Math.abs(J), Math.abs(dt)) && Math.abs(ie - cr) <= K * Math.max(1, Math.abs(ie), Math.abs(cr)) && Math.abs(le - mr) <= K * Math.max(1, Math.abs(le), Math.abs(mr)) && Math.abs(me - nr) <= K * Math.max(1, Math.abs(me), Math.abs(nr));
        }, p.cA = function(n, t) {
          re.REGISTERED_PROTOCOLS[n] = t;
        }, p.cB = function(n) {
          delete re.REGISTERED_PROTOCOLS[n];
        }, p.cC = function(n, t) {
          const r = {};
          for (let f = 0; f < n.length; f++) {
            const _ = t && t[n[f].id] || vf(n[f]);
            t && (t[n[f].id] = _);
            let b = r[_];
            b || (b = r[_] = []), b.push(n[f]);
          }
          const c = [];
          for (const f in r) c.push(r[f]);
          return c;
        }, p.cD = Bt, p.cE = Jy, p.cF = e_, p.cG = Ey, p.cH = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = Ye / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = false;
          const t = n.bucket.layers[0], r = t.layout, c = t._unevaluatedLayout._values, f = { layoutIconSize: c["icon-size"].possiblyEvaluate(new rn(n.bucket.zoom + 1), n.canonical), layoutTextSize: c["text-size"].possiblyEvaluate(new rn(n.bucket.zoom + 1), n.canonical), textMaxSize: c["text-size"].possiblyEvaluate(new rn(18)) };
          if (n.bucket.textSizeData.kind === "composite") {
            const { minZoom: E, maxZoom: A } = n.bucket.textSizeData;
            f.compositeTextSizes = [c["text-size"].possiblyEvaluate(new rn(E), n.canonical), c["text-size"].possiblyEvaluate(new rn(A), n.canonical)];
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const { minZoom: E, maxZoom: A } = n.bucket.iconSizeData;
            f.compositeIconSizes = [c["icon-size"].possiblyEvaluate(new rn(E), n.canonical), c["icon-size"].possiblyEvaluate(new rn(A), n.canonical)];
          }
          const _ = r.get("text-line-height") * qn, b = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point", C = r.get("text-keep-upright"), P = r.get("text-size");
          for (const E of n.bucket.features) {
            const A = r.get("text-font").evaluate(E, {}, n.canonical).join(","), B = P.evaluate(E, {}, n.canonical), U = f.layoutTextSize.evaluate(E, {}, n.canonical), H = f.layoutIconSize.evaluate(E, {}, n.canonical), J = { horizontal: {}, vertical: void 0 }, ie = E.text;
            let le, me = [0, 0];
            if (ie) {
              const Ee = ie.toString(), He = r.get("text-letter-spacing").evaluate(E, {}, n.canonical) * qn, rt = xf(Ee) ? He : 0, _t = r.get("text-anchor").evaluate(E, {}, n.canonical), Ft = d_(t, E, n.canonical);
              if (!Ft) {
                const Rt = r.get("text-radial-offset").evaluate(E, {}, n.canonical);
                me = Rt ? u_(_t, [Rt * qn, Jf]) : r.get("text-offset").evaluate(E, {}, n.canonical).map(((At) => At * qn));
              }
              let Mt = b ? "center" : r.get("text-justify").evaluate(E, {}, n.canonical);
              const zt = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(E, {}, n.canonical) * qn : 1 / 0, Jt = () => {
                n.bucket.allowVerticalPlacement && lc(Ee) && (J.vertical = Uh(ie, n.glyphMap, n.glyphPositions, n.imagePositions, A, zt, _, _t, "left", rt, me, p.ao.vertical, true, U, B));
              };
              if (!b && Ft) {
                const Rt = /* @__PURE__ */ new Set();
                if (Mt === "auto") for (let dt = 0; dt < Ft.values.length; dt += 2) Rt.add(Qf(Ft.values[dt]));
                else Rt.add(Mt);
                let At = false;
                for (const dt of Rt) if (!J.horizontal[dt]) if (At) J.horizontal[dt] = J.horizontal[0];
                else {
                  const cr = Uh(ie, n.glyphMap, n.glyphPositions, n.imagePositions, A, zt, _, "center", dt, rt, me, p.ao.horizontal, false, U, B);
                  cr && (J.horizontal[dt] = cr, At = cr.positionedLines.length === 1);
                }
                Jt();
              } else {
                Mt === "auto" && (Mt = Qf(_t));
                const Rt = Uh(ie, n.glyphMap, n.glyphPositions, n.imagePositions, A, zt, _, _t, Mt, rt, me, p.ao.horizontal, false, U, B);
                Rt && (J.horizontal[Mt] = Rt), Jt(), lc(Ee) && b && C && (J.vertical = Uh(ie, n.glyphMap, n.glyphPositions, n.imagePositions, A, zt, _, _t, Mt, rt, me, p.ao.vertical, false, U, B));
              }
            }
            let Oe = false;
            if (E.icon && E.icon.name) {
              const Ee = n.imageMap[E.icon.name];
              Ee && (le = $2(n.imagePositions[E.icon.name], r.get("icon-offset").evaluate(E, {}, n.canonical), r.get("icon-anchor").evaluate(E, {}, n.canonical)), Oe = !!Ee.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = Oe : n.bucket.sdfIcons !== Oe && Ct("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ee.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = true));
            }
            const Se = p_(J.horizontal) || J.vertical;
            n.bucket.iconsInText = !!Se && Se.iconsInText, (Se || le) && tC(n.bucket, E, J, le, n.imageMap, f, U, H, me, Oe, n.canonical, n.subdivisionGranularity);
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers();
        }, p.cI = Of, p.cJ = Ff, p.cK = Bf, p.cL = gy, p.cM = jf, p.cN = class {
          constructor(n) {
            this._marks = { start: [n.url, "start"].join("#"), end: [n.url, "end"].join("#"), measure: n.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n;
          }
        }, p.cO = function(n, t, r, c, f) {
          return o(this, void 0, void 0, (function* () {
            if (N()) try {
              return yield et(n, t, r, c, f);
            } catch {
            }
            return (function(_, b, C, P, E) {
              const A = _.width, B = _.height;
              it && Pt || (it = new OffscreenCanvas(A, B), Pt = it.getContext("2d", { willReadFrequently: true })), it.width = A, it.height = B, Pt.drawImage(_, 0, 0, A, B);
              const U = Pt.getImageData(b, C, P, E);
              return Pt.clearRect(0, 0, A, B), U.data;
            })(n, t, r, c, f);
          }));
        }, p.cP = iy, p.cQ = S, p.cR = my, p.cS = wc, p.cT = Ya, p.cU = function(n, t) {
          const r = /* @__PURE__ */ new Map();
          if (n != null) if (n.type === "Feature") r.set(ld(n, t), n);
          else for (const c of n.features) r.set(ld(c, t), c);
          return r;
        }, p.cV = function(n, t) {
          if (n == null) return true;
          if (n.type === "Feature") return ld(n, t) != null;
          if (n.type === "FeatureCollection") {
            const r = /* @__PURE__ */ new Set();
            for (const c of n.features) {
              const f = ld(c, t);
              if (f == null || r.has(f)) return false;
              r.add(f);
            }
            return true;
          }
          return false;
        }, p.cW = function(n, t, r) {
          var c, f, _, b;
          if (t.removeAll && n.clear(), t.remove) for (const C of t.remove) n.delete(C);
          if (t.add) for (const C of t.add) {
            const P = ld(C, r);
            P != null && n.set(P, C);
          }
          if (t.update) for (const C of t.update) {
            let P = n.get(C.id);
            if (P == null) continue;
            const E = !C.removeAllProperties && (((c = C.removeProperties) === null || c === void 0 ? void 0 : c.length) > 0 || ((f = C.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0);
            if ((C.newGeometry || C.removeAllProperties || E) && (P = Object.assign({}, P), n.set(C.id, P), E && (P.properties = Object.assign({}, P.properties))), C.newGeometry && (P.geometry = C.newGeometry), C.removeAllProperties) P.properties = {};
            else if (((_ = C.removeProperties) === null || _ === void 0 ? void 0 : _.length) > 0) for (const A of C.removeProperties) Object.prototype.hasOwnProperty.call(P.properties, A) && delete P.properties[A];
            if (((b = C.addOrUpdateProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const { key: A, value: B } of C.addOrUpdateProperties) P.properties[A] = B;
          }
        }, p.cX = so, p.ca = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n;
        }, p.cb = (n) => n.type === "symbol", p.cc = (n) => n.type === "circle", p.cd = (n) => n.type === "heatmap", p.ce = (n) => n.type === "line", p.cf = (n) => n.type === "fill", p.cg = (n) => n.type === "fill-extrusion", p.ch = (n) => n.type === "hillshade", p.ci = (n) => n.type === "color-relief", p.cj = (n) => n.type === "raster", p.ck = (n) => n.type === "background", p.cl = (n) => n.type === "custom", p.cm = Nt, p.cn = function(n, t, r) {
          const c = ht(t.x - r.x, t.y - r.y), f = ht(n.x - r.x, n.y - r.y);
          var _, b;
          return St(Math.atan2(c[0] * f[1] - c[1] * f[0], (_ = c)[0] * (b = f)[0] + _[1] * b[1]));
        }, p.co = Yt, p.cp = function(n, t) {
          return on[t] && (n instanceof MouseEvent || n instanceof WheelEvent);
        }, p.cq = function(n, t) {
          return ar[t] && "touches" in n;
        }, p.cr = function(n) {
          return ar[n] || on[n];
        }, p.cs = function(n, t, r) {
          var c = t[0], f = t[1];
          return n[0] = r[0] * c + r[4] * f + r[12], n[1] = r[1] * c + r[5] * f + r[13], n;
        }, p.ct = function(n, t) {
          const { x: r, y: c } = ad.fromLngLat(t);
          return !(n < 0 || n > 25 || c < 0 || c >= 1 || r < 0 || r >= 1);
        }, p.cu = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
        }, p.cv = class extends ca {
        }, p.cw = nC, p.cy = function(n) {
          return n.message === Sn;
        }, p.cz = be, p.d = fe, p.e = er, p.f = (n) => o(void 0, void 0, void 0, (function* () {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), p.g = ne, p.h = (n) => new Promise(((t, r) => {
          const c = new Image();
          c.onload = () => {
            t(c), URL.revokeObjectURL(c.src), c.onload = null, window.requestAnimationFrame((() => {
              c.src = kt;
            }));
          }, c.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const f = new Blob([new Uint8Array(n)], { type: "image/png" });
          c.src = n.byteLength ? URL.createObjectURL(f) : kt;
        })), p.i = ir, p.j = (n, t) => Fe(er(n, { type: "json" }), t), p.k = Xe, p.l = nt, p.m = Fe, p.n = (n, t) => Fe(er(n, { type: "arrayBuffer" }), t), p.o = function(n) {
          return new jf(n).readFields(M2, []);
        }, p.p = Iy, p.q = Yu, p.r = pi, p.s = Et, p.t = zh, p.u = Er, p.v = Te, p.w = Ct, p.x = yf, p.y = nl, p.z = oa;
      })), h("worker", ["./shared"], (function(p) {
        class o {
          constructor(re) {
            this.keyCache = {}, re && this.replace(re);
          }
          replace(re) {
            this._layerConfigs = {}, this._layers = {}, this.update(re, []);
          }
          update(re, ne) {
            for (const be of re) {
              this._layerConfigs[be.id] = be;
              const Ie = this._layers[be.id] = p.bJ(be);
              Ie._featureFilter = p.aa(Ie.filter), this.keyCache[be.id] && delete this.keyCache[be.id];
            }
            for (const be of ne) delete this.keyCache[be], delete this._layerConfigs[be], delete this._layers[be];
            this.familiesBySource = {};
            const ae = p.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const be of ae) {
              const Ie = be.map(((Xe) => this._layers[Xe.id])), Fe = Ie[0];
              if (Fe.visibility === "none") continue;
              const fe = Fe.source || "";
              let _e = this.familiesBySource[fe];
              _e || (_e = this.familiesBySource[fe] = {});
              const Ve = Fe.sourceLayer || "_geojsonTileLayer";
              let nt = _e[Ve];
              nt || (nt = _e[Ve] = []), nt.push(Ie);
            }
          }
        }
        class w {
          constructor(re) {
            const ne = {}, ae = [];
            for (const fe in re) {
              const _e = re[fe], Ve = ne[fe] = {};
              for (const nt in _e) {
                const Xe = _e[+nt];
                if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue;
                const wt = { x: 0, y: 0, w: Xe.bitmap.width + 2, h: Xe.bitmap.height + 2 };
                ae.push(wt), Ve[nt] = { rect: wt, metrics: Xe.metrics };
              }
            }
            const { w: be, h: Ie } = p.p(ae), Fe = new p.q({ width: be || 1, height: Ie || 1 });
            for (const fe in re) {
              const _e = re[fe];
              for (const Ve in _e) {
                const nt = _e[+Ve];
                if (!nt || nt.bitmap.width === 0 || nt.bitmap.height === 0) continue;
                const Xe = ne[fe][Ve].rect;
                p.q.copy(nt.bitmap, Fe, { x: 0, y: 0 }, { x: Xe.x + 1, y: Xe.y + 1 }, nt.bitmap);
              }
            }
            this.image = Fe, this.positions = ne;
          }
        }
        p.cD("GlyphAtlas", w);
        class S {
          constructor(re) {
            this.tileID = new p.Z(re.tileID.overscaledZ, re.tileID.wrap, re.tileID.canonical.z, re.tileID.canonical.x, re.tileID.canonical.y), this.uid = re.uid, this.zoom = re.zoom, this.pixelRatio = re.pixelRatio, this.tileSize = re.tileSize, this.source = re.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = re.showCollisionBoxes, this.collectResourceTiming = !!re.collectResourceTiming, this.returnDependencies = !!re.returnDependencies, this.promoteId = re.promoteId, this.inFlightDependencies = [], this.globalState = re.globalState;
          }
          parse(re, ne, ae, be, Ie) {
            return p._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = re, this.collisionBoxArray = new p.a8();
              const Fe = new p.cE(Object.keys(re.layers).sort()), fe = new p.cF(this.tileID, this.promoteId);
              fe.bucketLayerIDs = [];
              const _e = {}, Ve = { featureIndex: fe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ae, subdivisionGranularity: Ie }, nt = ne.familiesBySource[this.source];
              for (const _r in nt) {
                const wr = re.layers[_r];
                if (!wr) continue;
                wr.version === 1 && p.w(`Vector tile source "${this.source}" layer "${_r}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Hr = Fe.encode(_r), ye = [];
                for (let pt = 0; pt < wr.length; pt++) {
                  const Vt = wr.feature(pt), Ar = fe.getId(Vt, _r);
                  ye.push({ feature: Vt, id: Ar, index: pt, sourceLayerIndex: Hr });
                }
                for (const pt of nt[_r]) {
                  const Vt = pt[0];
                  Vt.source !== this.source && p.w(`layer.source = ${Vt.source} does not equal this.source = ${this.source}`), Vt.minzoom && this.zoom < Math.floor(Vt.minzoom) || Vt.maxzoom && this.zoom >= Vt.maxzoom || Vt.visibility !== "none" && (k(pt, this.zoom, ae, this.globalState), (_e[Vt.id] = Vt.createBucket({ index: fe.bucketLayerIDs.length, layers: pt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Hr, sourceID: this.source, globalState: this.globalState })).populate(ye, Ve, this.tileID.canonical), fe.bucketLayerIDs.push(pt.map(((Ar) => Ar.id))));
                }
              }
              const Xe = p.bN(Ve.glyphDependencies, ((_r) => Object.keys(_r).map(Number)));
              this.inFlightDependencies.forEach(((_r) => _r == null ? void 0 : _r.abort())), this.inFlightDependencies = [];
              let wt = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const _r = new AbortController();
                this.inFlightDependencies.push(_r), wt = be.sendAsync({ type: "GG", data: { stacks: Xe, source: this.source, tileID: this.tileID, type: "glyphs" } }, _r);
              }
              const Te = Object.keys(Ve.iconDependencies);
              let Ut = Promise.resolve({});
              if (Te.length) {
                const _r = new AbortController();
                this.inFlightDependencies.push(_r), Ut = be.sendAsync({ type: "GI", data: { icons: Te, source: this.source, tileID: this.tileID, type: "icons" } }, _r);
              }
              const or = Object.keys(Ve.patternDependencies);
              let Wt = Promise.resolve({});
              if (or.length) {
                const _r = new AbortController();
                this.inFlightDependencies.push(_r), Wt = be.sendAsync({ type: "GI", data: { icons: or, source: this.source, tileID: this.tileID, type: "patterns" } }, _r);
              }
              const [dr, Or, Qr] = yield Promise.all([wt, Ut, Wt]), en = new w(dr), sn = new p.cG(Or, Qr);
              for (const _r in _e) {
                const wr = _e[_r];
                wr instanceof p.a9 ? (k(wr.layers, this.zoom, ae, this.globalState), p.cH({ bucket: wr, glyphMap: dr, glyphPositions: en.positions, imageMap: Or, imagePositions: sn.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Ve.subdivisionGranularity })) : wr.hasPattern && (wr instanceof p.cI || wr instanceof p.cJ || wr instanceof p.cK) && (k(wr.layers, this.zoom, ae, this.globalState), wr.addFeatures(Ve, this.tileID.canonical, sn.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(_e).filter(((_r) => !_r.isEmpty())), featureIndex: fe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: en.image, imageAtlas: sn, glyphMap: this.returnDependencies ? dr : null, iconMap: this.returnDependencies ? Or : null, glyphPositions: this.returnDependencies ? en.positions : null };
            }));
          }
        }
        function k(Le, re, ne, ae) {
          const be = new p.F(re, { globalState: ae });
          for (const Ie of Le) Ie.recalculate(be, ne);
        }
        class I {
          constructor(re, ne, ae) {
            this.actor = re, this.layerIndex = ne, this.availableImages = ae, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              const ae = yield p.n(re.request, ne);
              try {
                return { vectorTile: new p.cL(new p.cM(ae.data)), rawData: ae.data, cacheControl: ae.cacheControl, expires: ae.expires };
              } catch (be) {
                const Ie = new Uint8Array(ae.data);
                let Fe = `Unable to parse the tile at ${re.request.url}, `;
                throw Fe += Ie[0] === 31 && Ie[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${be.message}`, new Error(Fe);
              }
            }));
          }
          loadTile(re) {
            return p._(this, void 0, void 0, (function* () {
              const ne = re.uid, ae = !!(re && re.request && re.request.collectResourceTiming) && new p.cN(re.request), be = new S(re);
              this.loading[ne] = be;
              const Ie = new AbortController();
              be.abort = Ie;
              try {
                const Fe = yield this.loadVectorTile(re, Ie);
                if (delete this.loading[ne], !Fe) return null;
                const fe = Fe.rawData, _e = {};
                Fe.expires && (_e.expires = Fe.expires), Fe.cacheControl && (_e.cacheControl = Fe.cacheControl);
                const Ve = {};
                if (ae) {
                  const Xe = ae.finish();
                  Xe && (Ve.resourceTiming = JSON.parse(JSON.stringify(Xe)));
                }
                be.vectorTile = Fe.vectorTile;
                const nt = be.parse(Fe.vectorTile, this.layerIndex, this.availableImages, this.actor, re.subdivisionGranularity);
                this.loaded[ne] = be, this.fetching[ne] = { rawTileData: fe, cacheControl: _e, resourceTiming: Ve };
                try {
                  const Xe = yield nt;
                  return p.e({ rawTileData: fe.slice(0) }, Xe, _e, Ve);
                } finally {
                  delete this.fetching[ne];
                }
              } catch (Fe) {
                throw delete this.loading[ne], be.status = "done", this.loaded[ne] = be, Fe;
              }
            }));
          }
          reloadTile(re) {
            return p._(this, void 0, void 0, (function* () {
              const ne = re.uid;
              if (!this.loaded || !this.loaded[ne]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ae = this.loaded[ne];
              if (ae.showCollisionBoxes = re.showCollisionBoxes, ae.globalState = re.globalState, ae.status === "parsing") {
                const be = yield ae.parse(ae.vectorTile, this.layerIndex, this.availableImages, this.actor, re.subdivisionGranularity);
                let Ie;
                if (this.fetching[ne]) {
                  const { rawTileData: Fe, cacheControl: fe, resourceTiming: _e } = this.fetching[ne];
                  delete this.fetching[ne], Ie = p.e({ rawTileData: Fe.slice(0) }, be, fe, _e);
                } else Ie = be;
                return Ie;
              }
              if (ae.status === "done" && ae.vectorTile) return ae.parse(ae.vectorTile, this.layerIndex, this.availableImages, this.actor, re.subdivisionGranularity);
            }));
          }
          abortTile(re) {
            return p._(this, void 0, void 0, (function* () {
              const ne = this.loading, ae = re.uid;
              ne && ne[ae] && ne[ae].abort && (ne[ae].abort.abort(), delete ne[ae]);
            }));
          }
          removeTile(re) {
            return p._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[re.uid] && delete this.loaded[re.uid];
            }));
          }
        }
        class z {
          constructor() {
            this.loaded = {};
          }
          loadTile(re) {
            return p._(this, void 0, void 0, (function* () {
              const { uid: ne, encoding: ae, rawImageData: be, redFactor: Ie, greenFactor: Fe, blueFactor: fe, baseShift: _e } = re, Ve = be.width + 2, nt = be.height + 2, Xe = p.b(be) ? new p.R({ width: Ve, height: nt }, yield p.cO(be, -1, -1, Ve, nt)) : be, wt = new p.cP(ne, Xe, ae, Ie, Fe, fe, _e);
              return this.loaded = this.loaded || {}, this.loaded[ne] = wt, wt;
            }));
          }
          removeTile(re) {
            const ne = this.loaded, ae = re.uid;
            ne && ne[ae] && delete ne[ae];
          }
        }
        var R, O, V = (function() {
          if (O) return R;
          function Le(ne, ae) {
            if (ne.length !== 0) {
              re(ne[0], ae);
              for (var be = 1; be < ne.length; be++) re(ne[be], !ae);
            }
          }
          function re(ne, ae) {
            for (var be = 0, Ie = 0, Fe = 0, fe = ne.length, _e = fe - 1; Fe < fe; _e = Fe++) {
              var Ve = (ne[Fe][0] - ne[_e][0]) * (ne[_e][1] + ne[Fe][1]), nt = be + Ve;
              Ie += Math.abs(be) >= Math.abs(Ve) ? be - nt + Ve : Ve - nt + be, be = nt;
            }
            be + Ie >= 0 != !!ae && ne.reverse();
          }
          return O = 1, R = function ne(ae, be) {
            var Ie, Fe = ae && ae.type;
            if (Fe === "FeatureCollection") for (Ie = 0; Ie < ae.features.length; Ie++) ne(ae.features[Ie], be);
            else if (Fe === "GeometryCollection") for (Ie = 0; Ie < ae.geometries.length; Ie++) ne(ae.geometries[Ie], be);
            else if (Fe === "Feature") ne(ae.geometry, be);
            else if (Fe === "Polygon") Le(ae.coordinates, be);
            else if (Fe === "MultiPolygon") for (Ie = 0; Ie < ae.coordinates.length; Ie++) Le(ae.coordinates[Ie], be);
            return ae;
          };
        })(), W = p.cQ(V);
        class N extends p.cS {
          constructor(re, ne) {
            super(new p.cM(), 0, ne, [], []), this.feature = re, this.type = re.type, this.properties = re.tags ? re.tags : {}, "id" in re && (typeof re.id == "string" ? this.id = parseInt(re.id, 10) : typeof re.id != "number" || isNaN(re.id) || (this.id = re.id));
          }
          loadGeometry() {
            const re = [], ne = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const ae of ne) {
              const be = [];
              for (const Ie of ae) be.push(new p.P(Ie[0], Ie[1]));
              re.push(be);
            }
            return re;
          }
        }
        class K extends p.cR {
          constructor(re, ne) {
            super(new p.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = ne ? ne.version : 1, this.extent = ne ? ne.extent : 4096, this.length = re.length, this.features = re;
          }
          feature(re) {
            return new N(this.features[re], this.extent);
          }
        }
        function Z(Le, re) {
          re.writeVarintField(15, Le.version || 1), re.writeStringField(1, Le.name || ""), re.writeVarintField(5, Le.extent || 4096);
          const ne = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let Ie = 0; Ie < Le.length; Ie++) ne.feature = Le.feature(Ie), re.writeMessage(2, X, ne);
          const ae = ne.keys;
          for (const Ie of ae) re.writeStringField(3, Ie);
          const be = ne.values;
          for (const Ie of be) re.writeMessage(4, Q, Ie);
        }
        function X(Le, re) {
          if (!Le.feature) return;
          const ne = Le.feature;
          ne.id !== void 0 && re.writeVarintField(1, ne.id), re.writeMessage(2, te, Le), re.writeVarintField(3, ne.type), re.writeMessage(4, se, ne);
        }
        function te(Le, re) {
          var _a3;
          for (const ne in (_a3 = Le.feature) == null ? void 0 : _a3.properties) {
            let ae = Le.feature.properties[ne], be = Le.keycache[ne];
            if (ae === null) continue;
            be === void 0 && (Le.keys.push(ne), be = Le.keys.length - 1, Le.keycache[ne] = be), re.writeVarint(be), typeof ae != "string" && typeof ae != "boolean" && typeof ae != "number" && (ae = JSON.stringify(ae));
            const Ie = typeof ae + ":" + ae;
            let Fe = Le.valuecache[Ie];
            Fe === void 0 && (Le.values.push(ae), Fe = Le.values.length - 1, Le.valuecache[Ie] = Fe), re.writeVarint(Fe);
          }
        }
        function q(Le, re) {
          return (re << 3) + (7 & Le);
        }
        function he(Le) {
          return Le << 1 ^ Le >> 31;
        }
        function se(Le, re) {
          const ne = Le.loadGeometry(), ae = Le.type;
          let be = 0, Ie = 0;
          for (const Fe of ne) {
            let fe = 1;
            ae === 1 && (fe = Fe.length), re.writeVarint(q(1, fe));
            const _e = ae === 3 ? Fe.length - 1 : Fe.length;
            for (let Ve = 0; Ve < _e; Ve++) {
              Ve === 1 && ae !== 1 && re.writeVarint(q(2, _e - 1));
              const nt = Fe[Ve].x - be, Xe = Fe[Ve].y - Ie;
              re.writeVarint(he(nt)), re.writeVarint(he(Xe)), be += nt, Ie += Xe;
            }
            Le.type === 3 && re.writeVarint(q(7, 1));
          }
        }
        function Q(Le, re) {
          const ne = typeof Le;
          ne === "string" ? re.writeStringField(1, Le) : ne === "boolean" ? re.writeBooleanField(7, Le) : ne === "number" && (Le % 1 != 0 ? re.writeDoubleField(3, Le) : Le < 0 ? re.writeSVarintField(6, Le) : re.writeVarintField(5, Le));
        }
        const oe = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (Le) => Le }, ve = Math.fround || (Be = new Float32Array(1), (Le) => (Be[0] = +Le, Be[0]));
        var Be;
        class Ne {
          constructor(re) {
            this.options = Object.assign(Object.create(oe), re), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(re) {
            const { log: ne, minZoom: ae, maxZoom: be } = this.options;
            ne && console.time("total time");
            const Ie = `prepare ${re.length} points`;
            ne && console.time(Ie), this.points = re;
            const Fe = [];
            for (let _e = 0; _e < re.length; _e++) {
              const Ve = re[_e];
              if (!Ve.geometry) continue;
              const [nt, Xe] = Ve.geometry.coordinates, wt = ve(at(nt)), Te = ve(xt(Xe));
              Fe.push(wt, Te, 1 / 0, _e, -1, 1), this.options.reduce && Fe.push(0);
            }
            let fe = this.trees[be + 1] = this._createTree(Fe);
            ne && console.timeEnd(Ie);
            for (let _e = be; _e >= ae; _e--) {
              const Ve = +Date.now();
              fe = this.trees[_e] = this._createTree(this._cluster(fe, _e)), ne && console.log("z%d: %d clusters in %dms", _e, fe.numItems, +Date.now() - Ve);
            }
            return ne && console.timeEnd("total time"), this;
          }
          getClusters(re, ne) {
            let ae = ((re[0] + 180) % 360 + 360) % 360 - 180;
            const be = Math.max(-90, Math.min(90, re[1]));
            let Ie = re[2] === 180 ? 180 : ((re[2] + 180) % 360 + 360) % 360 - 180;
            const Fe = Math.max(-90, Math.min(90, re[3]));
            if (re[2] - re[0] >= 360) ae = -180, Ie = 180;
            else if (ae > Ie) {
              const Xe = this.getClusters([ae, be, 180, Fe], ne), wt = this.getClusters([-180, be, Ie, Fe], ne);
              return Xe.concat(wt);
            }
            const fe = this.trees[this._limitZoom(ne)], _e = fe.range(at(ae), xt(Fe), at(Ie), xt(be)), Ve = fe.data, nt = [];
            for (const Xe of _e) {
              const wt = this.stride * Xe;
              nt.push(Ve[wt + 5] > 1 ? Pe(Ve, wt, this.clusterProps) : this.points[Ve[wt + 3]]);
            }
            return nt;
          }
          getChildren(re) {
            const ne = this._getOriginId(re), ae = this._getOriginZoom(re), be = "No cluster with the specified id.", Ie = this.trees[ae];
            if (!Ie) throw new Error(be);
            const Fe = Ie.data;
            if (ne * this.stride >= Fe.length) throw new Error(be);
            const fe = this.options.radius / (this.options.extent * Math.pow(2, ae - 1)), _e = Ie.within(Fe[ne * this.stride], Fe[ne * this.stride + 1], fe), Ve = [];
            for (const nt of _e) {
              const Xe = nt * this.stride;
              Fe[Xe + 4] === re && Ve.push(Fe[Xe + 5] > 1 ? Pe(Fe, Xe, this.clusterProps) : this.points[Fe[Xe + 3]]);
            }
            if (Ve.length === 0) throw new Error(be);
            return Ve;
          }
          getLeaves(re, ne, ae) {
            const be = [];
            return this._appendLeaves(be, re, ne = ne || 10, ae = ae || 0, 0), be;
          }
          getTile(re, ne, ae) {
            const be = this.trees[this._limitZoom(re)], Ie = Math.pow(2, re), { extent: Fe, radius: fe } = this.options, _e = fe / Fe, Ve = (ae - _e) / Ie, nt = (ae + 1 + _e) / Ie, Xe = { features: [] };
            return this._addTileFeatures(be.range((ne - _e) / Ie, Ve, (ne + 1 + _e) / Ie, nt), be.data, ne, ae, Ie, Xe), ne === 0 && this._addTileFeatures(be.range(1 - _e / Ie, Ve, 1, nt), be.data, Ie, ae, Ie, Xe), ne === Ie - 1 && this._addTileFeatures(be.range(0, Ve, _e / Ie, nt), be.data, -1, ae, Ie, Xe), Xe.features.length ? Xe : null;
          }
          getClusterExpansionZoom(re) {
            let ne = this._getOriginZoom(re) - 1;
            for (; ne <= this.options.maxZoom; ) {
              const ae = this.getChildren(re);
              if (ne++, ae.length !== 1) break;
              re = ae[0].properties.cluster_id;
            }
            return ne;
          }
          _appendLeaves(re, ne, ae, be, Ie) {
            const Fe = this.getChildren(ne);
            for (const fe of Fe) {
              const _e = fe.properties;
              if (_e && _e.cluster ? Ie + _e.point_count <= be ? Ie += _e.point_count : Ie = this._appendLeaves(re, _e.cluster_id, ae, be, Ie) : Ie < be ? Ie++ : re.push(fe), re.length === ae) break;
            }
            return Ie;
          }
          _createTree(re) {
            const ne = new p.aI(re.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ae = 0; ae < re.length; ae += this.stride) ne.add(re[ae], re[ae + 1]);
            return ne.finish(), ne.data = re, ne;
          }
          _addTileFeatures(re, ne, ae, be, Ie, Fe) {
            for (const fe of re) {
              const _e = fe * this.stride, Ve = ne[_e + 5] > 1;
              let nt, Xe, wt;
              if (Ve) nt = tt(ne, _e, this.clusterProps), Xe = ne[_e], wt = ne[_e + 1];
              else {
                const or = this.points[ne[_e + 3]];
                nt = or.properties;
                const [Wt, dr] = or.geometry.coordinates;
                Xe = at(Wt), wt = xt(dr);
              }
              const Te = { type: 1, geometry: [[Math.round(this.options.extent * (Xe * Ie - ae)), Math.round(this.options.extent * (wt * Ie - be))]], tags: nt };
              let Ut;
              Ut = Ve || this.options.generateId ? ne[_e + 3] : this.points[ne[_e + 3]].id, Ut !== void 0 && (Te.id = Ut), Fe.features.push(Te);
            }
          }
          _limitZoom(re) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+re), this.options.maxZoom + 1));
          }
          _cluster(re, ne) {
            const { radius: ae, extent: be, reduce: Ie, minPoints: Fe } = this.options, fe = ae / (be * Math.pow(2, ne)), _e = re.data, Ve = [], nt = this.stride;
            for (let Xe = 0; Xe < _e.length; Xe += nt) {
              if (_e[Xe + 2] <= ne) continue;
              _e[Xe + 2] = ne;
              const wt = _e[Xe], Te = _e[Xe + 1], Ut = re.within(_e[Xe], _e[Xe + 1], fe), or = _e[Xe + 5];
              let Wt = or;
              for (const dr of Ut) {
                const Or = dr * nt;
                _e[Or + 2] > ne && (Wt += _e[Or + 5]);
              }
              if (Wt > or && Wt >= Fe) {
                let dr, Or = wt * or, Qr = Te * or, en = -1;
                const sn = (Xe / nt << 5) + (ne + 1) + this.points.length;
                for (const _r of Ut) {
                  const wr = _r * nt;
                  if (_e[wr + 2] <= ne) continue;
                  _e[wr + 2] = ne;
                  const Hr = _e[wr + 5];
                  Or += _e[wr] * Hr, Qr += _e[wr + 1] * Hr, _e[wr + 4] = sn, Ie && (dr || (dr = this._map(_e, Xe, true), en = this.clusterProps.length, this.clusterProps.push(dr)), Ie(dr, this._map(_e, wr)));
                }
                _e[Xe + 4] = sn, Ve.push(Or / Wt, Qr / Wt, 1 / 0, sn, -1, Wt), Ie && Ve.push(en);
              } else {
                for (let dr = 0; dr < nt; dr++) Ve.push(_e[Xe + dr]);
                if (Wt > 1) for (const dr of Ut) {
                  const Or = dr * nt;
                  if (!(_e[Or + 2] <= ne)) {
                    _e[Or + 2] = ne;
                    for (let Qr = 0; Qr < nt; Qr++) Ve.push(_e[Or + Qr]);
                  }
                }
              }
            }
            return Ve;
          }
          _getOriginId(re) {
            return re - this.points.length >> 5;
          }
          _getOriginZoom(re) {
            return (re - this.points.length) % 32;
          }
          _map(re, ne, ae) {
            if (re[ne + 5] > 1) {
              const Fe = this.clusterProps[re[ne + 6]];
              return ae ? Object.assign({}, Fe) : Fe;
            }
            const be = this.points[re[ne + 3]].properties, Ie = this.options.map(be);
            return ae && Ie === be ? Object.assign({}, Ie) : Ie;
          }
        }
        function Pe(Le, re, ne) {
          return { type: "Feature", id: Le[re + 3], properties: tt(Le, re, ne), geometry: { type: "Point", coordinates: [(ae = Le[re], 360 * (ae - 0.5)), ht(Le[re + 1])] } };
          var ae;
        }
        function tt(Le, re, ne) {
          const ae = Le[re + 5], be = ae >= 1e4 ? `${Math.round(ae / 1e3)}k` : ae >= 1e3 ? Math.round(ae / 100) / 10 + "k" : ae, Ie = Le[re + 6], Fe = Ie === -1 ? {} : Object.assign({}, ne[Ie]);
          return Object.assign(Fe, { cluster: true, cluster_id: Le[re + 3], point_count: ae, point_count_abbreviated: be });
        }
        function at(Le) {
          return Le / 360 + 0.5;
        }
        function xt(Le) {
          const re = Math.sin(Le * Math.PI / 180), ne = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
          return ne < 0 ? 0 : ne > 1 ? 1 : ne;
        }
        function ht(Le) {
          const re = (180 - 360 * Le) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(re)) / Math.PI - 90;
        }
        function Ye(Le, re, ne, ae) {
          let be = ae;
          const Ie = re + (ne - re >> 1);
          let Fe, fe = ne - re;
          const _e = Le[re], Ve = Le[re + 1], nt = Le[ne], Xe = Le[ne + 1];
          for (let wt = re + 3; wt < ne; wt += 3) {
            const Te = Ke(Le[wt], Le[wt + 1], _e, Ve, nt, Xe);
            if (Te > be) Fe = wt, be = Te;
            else if (Te === be) {
              const Ut = Math.abs(wt - Ie);
              Ut < fe && (Fe = wt, fe = Ut);
            }
          }
          be > ae && (Fe - re > 3 && Ye(Le, re, Fe, ae), Le[Fe + 2] = be, ne - Fe > 3 && Ye(Le, Fe, ne, ae));
        }
        function Ke(Le, re, ne, ae, be, Ie) {
          let Fe = be - ne, fe = Ie - ae;
          if (Fe !== 0 || fe !== 0) {
            const _e = ((Le - ne) * Fe + (re - ae) * fe) / (Fe * Fe + fe * fe);
            _e > 1 ? (ne = be, ae = Ie) : _e > 0 && (ne += Fe * _e, ae += fe * _e);
          }
          return Fe = Le - ne, fe = re - ae, Fe * Fe + fe * fe;
        }
        function Lt(Le, re, ne, ae) {
          const be = { id: Le ?? null, type: re, geometry: ne, tags: ae, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (re === "Point" || re === "MultiPoint" || re === "LineString") ct(be, ne);
          else if (re === "Polygon") ct(be, ne[0]);
          else if (re === "MultiLineString") for (const Ie of ne) ct(be, Ie);
          else if (re === "MultiPolygon") for (const Ie of ne) ct(be, Ie[0]);
          return be;
        }
        function ct(Le, re) {
          for (let ne = 0; ne < re.length; ne += 3) Le.minX = Math.min(Le.minX, re[ne]), Le.minY = Math.min(Le.minY, re[ne + 1]), Le.maxX = Math.max(Le.maxX, re[ne]), Le.maxY = Math.max(Le.maxY, re[ne + 1]);
        }
        function bt(Le, re, ne, ae) {
          if (!re.geometry) return;
          const be = re.geometry.coordinates;
          if (be && be.length === 0) return;
          const Ie = re.geometry.type, Fe = Math.pow(ne.tolerance / ((1 << ne.maxZoom) * ne.extent), 2);
          let fe = [], _e = re.id;
          if (ne.promoteId ? _e = re.properties[ne.promoteId] : ne.generateId && (_e = ae || 0), Ie === "Point") Nt(be, fe);
          else if (Ie === "MultiPoint") for (const Ve of be) Nt(Ve, fe);
          else if (Ie === "LineString") Yt(be, fe, Fe, false);
          else if (Ie === "MultiLineString") {
            if (ne.lineMetrics) {
              for (const Ve of be) fe = [], Yt(Ve, fe, Fe, false), Le.push(Lt(_e, "LineString", fe, re.properties));
              return;
            }
            vt(be, fe, Fe, false);
          } else if (Ie === "Polygon") vt(be, fe, Fe, true);
          else {
            if (Ie !== "MultiPolygon") {
              if (Ie === "GeometryCollection") {
                for (const Ve of re.geometry.geometries) bt(Le, { id: _e, geometry: Ve, properties: re.properties }, ne, ae);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Ve of be) {
              const nt = [];
              vt(Ve, nt, Fe, true), fe.push(nt);
            }
          }
          Le.push(Lt(_e, Ie, fe, re.properties));
        }
        function Nt(Le, re) {
          re.push(jt(Le[0]), er(Le[1]), 0);
        }
        function Yt(Le, re, ne, ae) {
          let be, Ie, Fe = 0;
          for (let _e = 0; _e < Le.length; _e++) {
            const Ve = jt(Le[_e][0]), nt = er(Le[_e][1]);
            re.push(Ve, nt, 0), _e > 0 && (Fe += ae ? (be * nt - Ve * Ie) / 2 : Math.sqrt(Math.pow(Ve - be, 2) + Math.pow(nt - Ie, 2))), be = Ve, Ie = nt;
          }
          const fe = re.length - 3;
          re[2] = 1, Ye(re, 0, fe, ne), re[fe + 2] = 1, re.size = Math.abs(Fe), re.start = 0, re.end = re.size;
        }
        function vt(Le, re, ne, ae) {
          for (let be = 0; be < Le.length; be++) {
            const Ie = [];
            Yt(Le[be], Ie, ne, ae), re.push(Ie);
          }
        }
        function jt(Le) {
          return Le / 360 + 0.5;
        }
        function er(Le) {
          const re = Math.sin(Le * Math.PI / 180), ne = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
          return ne < 0 ? 0 : ne > 1 ? 1 : ne;
        }
        function yr(Le, re, ne, ae, be, Ie, Fe, fe) {
          if (ae /= re, Ie >= (ne /= re) && Fe < ae) return Le;
          if (Fe < ne || Ie >= ae) return null;
          const _e = [];
          for (const Ve of Le) {
            const nt = Ve.geometry;
            let Xe = Ve.type;
            const wt = be === 0 ? Ve.minX : Ve.minY, Te = be === 0 ? Ve.maxX : Ve.maxY;
            if (wt >= ne && Te < ae) {
              _e.push(Ve);
              continue;
            }
            if (Te < ne || wt >= ae) continue;
            let Ut = [];
            if (Xe === "Point" || Xe === "MultiPoint") Tr(nt, Ut, ne, ae, be);
            else if (Xe === "LineString") zr(nt, Ut, ne, ae, be, false, fe.lineMetrics);
            else if (Xe === "MultiLineString") yt(nt, Ut, ne, ae, be, false);
            else if (Xe === "Polygon") yt(nt, Ut, ne, ae, be, true);
            else if (Xe === "MultiPolygon") for (const or of nt) {
              const Wt = [];
              yt(or, Wt, ne, ae, be, true), Wt.length && Ut.push(Wt);
            }
            if (Ut.length) {
              if (fe.lineMetrics && Xe === "LineString") {
                for (const or of Ut) _e.push(Lt(Ve.id, Xe, or, Ve.tags));
                continue;
              }
              Xe !== "LineString" && Xe !== "MultiLineString" || (Ut.length === 1 ? (Xe = "LineString", Ut = Ut[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = Ut.length === 3 ? "Point" : "MultiPoint"), _e.push(Lt(Ve.id, Xe, Ut, Ve.tags));
            }
          }
          return _e.length ? _e : null;
        }
        function Tr(Le, re, ne, ae, be) {
          for (let Ie = 0; Ie < Le.length; Ie += 3) {
            const Fe = Le[Ie + be];
            Fe >= ne && Fe <= ae && Ct(re, Le[Ie], Le[Ie + 1], Le[Ie + 2]);
          }
        }
        function zr(Le, re, ne, ae, be, Ie, Fe) {
          let fe = rr(Le);
          const _e = be === 0 ? Dt : ir;
          let Ve, nt, Xe = Le.start;
          for (let Wt = 0; Wt < Le.length - 3; Wt += 3) {
            const dr = Le[Wt], Or = Le[Wt + 1], Qr = Le[Wt + 2], en = Le[Wt + 3], sn = Le[Wt + 4], _r = be === 0 ? dr : Or, wr = be === 0 ? en : sn;
            let Hr = false;
            Fe && (Ve = Math.sqrt(Math.pow(dr - en, 2) + Math.pow(Or - sn, 2))), _r < ne ? wr > ne && (nt = _e(fe, dr, Or, en, sn, ne), Fe && (fe.start = Xe + Ve * nt)) : _r > ae ? wr < ae && (nt = _e(fe, dr, Or, en, sn, ae), Fe && (fe.start = Xe + Ve * nt)) : Ct(fe, dr, Or, Qr), wr < ne && _r >= ne && (nt = _e(fe, dr, Or, en, sn, ne), Hr = true), wr > ae && _r <= ae && (nt = _e(fe, dr, Or, en, sn, ae), Hr = true), !Ie && Hr && (Fe && (fe.end = Xe + Ve * nt), re.push(fe), fe = rr(Le)), Fe && (Xe += Ve);
          }
          let wt = Le.length - 3;
          const Te = Le[wt], Ut = Le[wt + 1], or = be === 0 ? Te : Ut;
          or >= ne && or <= ae && Ct(fe, Te, Ut, Le[wt + 2]), wt = fe.length - 3, Ie && wt >= 3 && (fe[wt] !== fe[0] || fe[wt + 1] !== fe[1]) && Ct(fe, fe[0], fe[1], fe[2]), fe.length && re.push(fe);
        }
        function rr(Le) {
          const re = [];
          return re.size = Le.size, re.start = Le.start, re.end = Le.end, re;
        }
        function yt(Le, re, ne, ae, be, Ie) {
          for (const Fe of Le) zr(Fe, re, ne, ae, be, Ie, false);
        }
        function Ct(Le, re, ne, ae) {
          Le.push(re, ne, ae);
        }
        function Dt(Le, re, ne, ae, be, Ie) {
          const Fe = (Ie - re) / (ae - re);
          return Ct(Le, Ie, ne + (be - ne) * Fe, 1), Fe;
        }
        function ir(Le, re, ne, ae, be, Ie) {
          const Fe = (Ie - ne) / (be - ne);
          return Ct(Le, re + (ae - re) * Fe, Ie, 1), Fe;
        }
        function ut(Le, re) {
          const ne = [];
          for (let ae = 0; ae < Le.length; ae++) {
            const be = Le[ae], Ie = be.type;
            let Fe;
            if (Ie === "Point" || Ie === "MultiPoint" || Ie === "LineString") Fe = We(be.geometry, re);
            else if (Ie === "MultiLineString" || Ie === "Polygon") {
              Fe = [];
              for (const fe of be.geometry) Fe.push(We(fe, re));
            } else if (Ie === "MultiPolygon") {
              Fe = [];
              for (const fe of be.geometry) {
                const _e = [];
                for (const Ve of fe) _e.push(We(Ve, re));
                Fe.push(_e);
              }
            }
            ne.push(Lt(be.id, Ie, Fe, be.tags));
          }
          return ne;
        }
        function We(Le, re) {
          const ne = [];
          ne.size = Le.size, Le.start !== void 0 && (ne.start = Le.start, ne.end = Le.end);
          for (let ae = 0; ae < Le.length; ae += 3) ne.push(Le[ae] + re, Le[ae + 1], Le[ae + 2]);
          return ne;
        }
        function kt(Le, re) {
          if (Le.transformed) return Le;
          const ne = 1 << Le.z, ae = Le.x, be = Le.y;
          for (const Ie of Le.features) {
            const Fe = Ie.geometry, fe = Ie.type;
            if (Ie.geometry = [], fe === 1) for (let _e = 0; _e < Fe.length; _e += 2) Ie.geometry.push(et(Fe[_e], Fe[_e + 1], re, ne, ae, be));
            else for (let _e = 0; _e < Fe.length; _e++) {
              const Ve = [];
              for (let nt = 0; nt < Fe[_e].length; nt += 2) Ve.push(et(Fe[_e][nt], Fe[_e][nt + 1], re, ne, ae, be));
              Ie.geometry.push(Ve);
            }
          }
          return Le.transformed = true, Le;
        }
        function et(Le, re, ne, ae, be, Ie) {
          return [Math.round(ne * (Le * ae - be)), Math.round(ne * (re * ae - Ie))];
        }
        function it(Le, re, ne, ae, be) {
          const Ie = re === be.maxZoom ? 0 : be.tolerance / ((1 << re) * be.extent), Fe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Le.length, source: null, x: ne, y: ae, z: re, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const fe of Le) Pt(Fe, fe, Ie, be);
          return Fe;
        }
        function Pt(Le, re, ne, ae) {
          const be = re.geometry, Ie = re.type, Fe = [];
          if (Le.minX = Math.min(Le.minX, re.minX), Le.minY = Math.min(Le.minY, re.minY), Le.maxX = Math.max(Le.maxX, re.maxX), Le.maxY = Math.max(Le.maxY, re.maxY), Ie === "Point" || Ie === "MultiPoint") for (let fe = 0; fe < be.length; fe += 3) Fe.push(be[fe], be[fe + 1]), Le.numPoints++, Le.numSimplified++;
          else if (Ie === "LineString") Et(Fe, be, Le, ne, false, false);
          else if (Ie === "MultiLineString" || Ie === "Polygon") for (let fe = 0; fe < be.length; fe++) Et(Fe, be[fe], Le, ne, Ie === "Polygon", fe === 0);
          else if (Ie === "MultiPolygon") for (let fe = 0; fe < be.length; fe++) {
            const _e = be[fe];
            for (let Ve = 0; Ve < _e.length; Ve++) Et(Fe, _e[Ve], Le, ne, true, Ve === 0);
          }
          if (Fe.length) {
            let fe = re.tags || null;
            if (Ie === "LineString" && ae.lineMetrics) {
              fe = {};
              for (const Ve in re.tags) fe[Ve] = re.tags[Ve];
              fe.mapbox_clip_start = be.start / be.size, fe.mapbox_clip_end = be.end / be.size;
            }
            const _e = { geometry: Fe, type: Ie === "Polygon" || Ie === "MultiPolygon" ? 3 : Ie === "LineString" || Ie === "MultiLineString" ? 2 : 1, tags: fe };
            re.id !== null && (_e.id = re.id), Le.features.push(_e);
          }
        }
        function Et(Le, re, ne, ae, be, Ie) {
          const Fe = ae * ae;
          if (ae > 0 && re.size < (be ? Fe : ae)) return void (ne.numPoints += re.length / 3);
          const fe = [];
          for (let _e = 0; _e < re.length; _e += 3) (ae === 0 || re[_e + 2] > Fe) && (ne.numSimplified++, fe.push(re[_e], re[_e + 1])), ne.numPoints++;
          be && (function(_e, Ve) {
            let nt = 0;
            for (let Xe = 0, wt = _e.length, Te = wt - 2; Xe < wt; Te = Xe, Xe += 2) nt += (_e[Xe] - _e[Te]) * (_e[Xe + 1] + _e[Te + 1]);
            if (nt > 0 === Ve) for (let Xe = 0, wt = _e.length; Xe < wt / 2; Xe += 2) {
              const Te = _e[Xe], Ut = _e[Xe + 1];
              _e[Xe] = _e[wt - 2 - Xe], _e[Xe + 1] = _e[wt - 1 - Xe], _e[wt - 2 - Xe] = Te, _e[wt - 1 - Xe] = Ut;
            }
          })(fe, Ie), Le.push(fe);
        }
        const st = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class St {
          constructor(re, ne) {
            const ae = (ne = this.options = (function(Ie, Fe) {
              for (const fe in Fe) Ie[fe] = Fe[fe];
              return Ie;
            })(Object.create(st), ne)).debug;
            if (ae && console.time("preprocess data"), ne.maxZoom < 0 || ne.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (ne.promoteId && ne.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let be = (function(Ie, Fe) {
              const fe = [];
              if (Ie.type === "FeatureCollection") for (let _e = 0; _e < Ie.features.length; _e++) bt(fe, Ie.features[_e], Fe, _e);
              else bt(fe, Ie.type === "Feature" ? Ie : { geometry: Ie }, Fe);
              return fe;
            })(re, ne);
            this.tiles = {}, this.tileCoords = [], ae && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", ne.indexMaxZoom, ne.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), be = (function(Ie, Fe) {
              const fe = Fe.buffer / Fe.extent;
              let _e = Ie;
              const Ve = yr(Ie, 1, -1 - fe, fe, 0, -1, 2, Fe), nt = yr(Ie, 1, 1 - fe, 2 + fe, 0, -1, 2, Fe);
              return (Ve || nt) && (_e = yr(Ie, 1, -fe, 1 + fe, 0, -1, 2, Fe) || [], Ve && (_e = ut(Ve, 1).concat(_e)), nt && (_e = _e.concat(ut(nt, -1)))), _e;
            })(be, ne), be.length && this.splitTile(be, 0, 0, 0), ae && (be.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(re, ne, ae, be, Ie, Fe, fe) {
            const _e = [re, ne, ae, be], Ve = this.options, nt = Ve.debug;
            for (; _e.length; ) {
              be = _e.pop(), ae = _e.pop(), ne = _e.pop(), re = _e.pop();
              const Xe = 1 << ne, wt = ar(ne, ae, be);
              let Te = this.tiles[wt];
              if (!Te && (nt > 1 && console.time("creation"), Te = this.tiles[wt] = it(re, ne, ae, be, Ve), this.tileCoords.push({ z: ne, x: ae, y: be }), nt)) {
                nt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", ne, ae, be, Te.numFeatures, Te.numPoints, Te.numSimplified), console.timeEnd("creation"));
                const Hr = `z${ne}`;
                this.stats[Hr] = (this.stats[Hr] || 0) + 1, this.total++;
              }
              if (Te.source = re, Ie == null) {
                if (ne === Ve.indexMaxZoom || Te.numPoints <= Ve.indexMaxPoints) continue;
              } else {
                if (ne === Ve.maxZoom || ne === Ie) continue;
                if (Ie != null) {
                  const Hr = Ie - ne;
                  if (ae !== Fe >> Hr || be !== fe >> Hr) continue;
                }
              }
              if (Te.source = null, re.length === 0) continue;
              nt > 1 && console.time("clipping");
              const Ut = 0.5 * Ve.buffer / Ve.extent, or = 0.5 - Ut, Wt = 0.5 + Ut, dr = 1 + Ut;
              let Or = null, Qr = null, en = null, sn = null, _r = yr(re, Xe, ae - Ut, ae + Wt, 0, Te.minX, Te.maxX, Ve), wr = yr(re, Xe, ae + or, ae + dr, 0, Te.minX, Te.maxX, Ve);
              re = null, _r && (Or = yr(_r, Xe, be - Ut, be + Wt, 1, Te.minY, Te.maxY, Ve), Qr = yr(_r, Xe, be + or, be + dr, 1, Te.minY, Te.maxY, Ve), _r = null), wr && (en = yr(wr, Xe, be - Ut, be + Wt, 1, Te.minY, Te.maxY, Ve), sn = yr(wr, Xe, be + or, be + dr, 1, Te.minY, Te.maxY, Ve), wr = null), nt > 1 && console.timeEnd("clipping"), _e.push(Or || [], ne + 1, 2 * ae, 2 * be), _e.push(Qr || [], ne + 1, 2 * ae, 2 * be + 1), _e.push(en || [], ne + 1, 2 * ae + 1, 2 * be), _e.push(sn || [], ne + 1, 2 * ae + 1, 2 * be + 1);
            }
          }
          getTile(re, ne, ae) {
            re = +re, ne = +ne, ae = +ae;
            const be = this.options, { extent: Ie, debug: Fe } = be;
            if (re < 0 || re > 24) return null;
            const fe = 1 << re, _e = ar(re, ne = ne + fe & fe - 1, ae);
            if (this.tiles[_e]) return kt(this.tiles[_e], Ie);
            Fe > 1 && console.log("drilling down to z%d-%d-%d", re, ne, ae);
            let Ve, nt = re, Xe = ne, wt = ae;
            for (; !Ve && nt > 0; ) nt--, Xe >>= 1, wt >>= 1, Ve = this.tiles[ar(nt, Xe, wt)];
            return Ve && Ve.source ? (Fe > 1 && (console.log("found parent tile z%d-%d-%d", nt, Xe, wt), console.time("drilling down")), this.splitTile(Ve.source, nt, Xe, wt, re, ne, ae), Fe > 1 && console.timeEnd("drilling down"), this.tiles[_e] ? kt(this.tiles[_e], Ie) : null) : null;
          }
        }
        function ar(Le, re, ne) {
          return 32 * ((1 << Le) * ne + re) + Le;
        }
        class on extends I {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              const ae = re.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const be = this._geoJSONIndex.getTile(ae.z, ae.x, ae.y);
              if (!be) return null;
              const Ie = new K(be.features, { version: 2, extent: p.$ });
              let Fe = (function(fe) {
                const _e = new p.cM();
                return (function(Ve, nt) {
                  for (const Xe in Ve.layers) nt.writeMessage(3, Z, Ve.layers[Xe]);
                })(fe, _e), _e.finish();
              })(Ie);
              return Fe.byteOffset === 0 && Fe.byteLength === Fe.buffer.byteLength || (Fe = new Uint8Array(Fe)), { vectorTile: Ie, rawData: Fe.buffer };
            }));
          }
          loadData(re) {
            return p._(this, void 0, void 0, (function* () {
              var ne;
              (ne = this._pendingRequest) === null || ne === void 0 || ne.abort();
              const ae = !!(re && re.request && re.request.collectResourceTiming) && new p.cN(re.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(re, this._pendingRequest);
                const be = yield this._pendingData;
                this._geoJSONIndex = re.cluster ? new Ne((function({ superclusterOptions: Fe, clusterProperties: fe }) {
                  if (!fe || !Fe) return Fe;
                  const _e = {}, Ve = {}, nt = { accumulated: null, zoom: 0 }, Xe = { properties: null }, wt = Object.keys(fe);
                  for (const Te of wt) {
                    const [Ut, or] = fe[Te], Wt = p.cT(or), dr = p.cT(typeof Ut == "string" ? [Ut, ["accumulated"], ["get", Te]] : Ut);
                    _e[Te] = Wt.value, Ve[Te] = dr.value;
                  }
                  return Fe.map = (Te) => {
                    Xe.properties = Te;
                    const Ut = {};
                    for (const or of wt) Ut[or] = _e[or].evaluate(nt, Xe);
                    return Ut;
                  }, Fe.reduce = (Te, Ut) => {
                    Xe.properties = Ut;
                    for (const or of wt) nt.accumulated = Te[or], Te[or] = Ve[or].evaluate(nt, Xe);
                  }, Fe;
                })(re)).load(be.features) : (function(Fe, fe) {
                  return new St(Fe, fe);
                })(be, re.geojsonVtOptions), this.loaded = {};
                const Ie = { data: be };
                if (ae) {
                  const Fe = ae.finish();
                  Fe && (Ie.resourceTiming = {}, Ie.resourceTiming[re.source] = JSON.parse(JSON.stringify(Fe)));
                }
                return Ie;
              } catch (be) {
                if (delete this._pendingRequest, p.cy(be)) return { abandoned: true };
                throw be;
              }
            }));
          }
          getData() {
            return p._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(re) {
            const ne = this.loaded;
            return ne && ne[re.uid] ? super.reloadTile(re) : this.loadTile(re);
          }
          loadAndProcessGeoJSON(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              let ae = yield this.loadGeoJSON(re, ne);
              if (delete this._pendingRequest, typeof ae != "object") throw new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`);
              if (W(ae, true), re.filter) {
                const be = p.cT(re.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (be.result === "error") throw new Error(be.value.map(((Fe) => `${Fe.key}: ${Fe.message}`)).join(", "));
                ae = { type: "FeatureCollection", features: ae.features.filter(((Fe) => be.value.evaluate({ zoom: 0 }, Fe))) };
              }
              return ae;
            }));
          }
          loadGeoJSON(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              const { promoteId: ae } = re;
              if (re.request) {
                const be = yield p.j(re.request, ne);
                return this._dataUpdateable = p.cV(be.data, ae) ? p.cU(be.data, ae) : void 0, be.data;
              }
              if (typeof re.data == "string") try {
                const be = JSON.parse(re.data);
                return this._dataUpdateable = p.cV(be, ae) ? p.cU(be, ae) : void 0, be;
              } catch {
                throw new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`);
              }
              if (!re.dataDiff) throw new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${re.source}`);
              return p.cW(this._dataUpdateable, re.dataDiff, ae), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(re) {
            return p._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(re) {
            return this._geoJSONIndex.getClusterExpansionZoom(re.clusterId);
          }
          getClusterChildren(re) {
            return this._geoJSONIndex.getChildren(re.clusterId);
          }
          getClusterLeaves(re) {
            return this._geoJSONIndex.getLeaves(re.clusterId, re.limit, re.offset);
          }
        }
        class Sn {
          constructor(re) {
            this.self = re, this.actor = new p.J(re), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (ne, ae) => {
              if (this.externalWorkerSourceTypes[ne]) throw new Error(`Worker source with name "${ne}" already registered.`);
              this.externalWorkerSourceTypes[ne] = ae;
            }, this.self.addProtocol = p.cA, this.self.removeProtocol = p.cB, this.self.registerRTLTextPlugin = (ne) => {
              p.cX.setMethods(ne);
            }, this.actor.registerMessageHandler("LDT", ((ne, ae) => this._getDEMWorkerSource(ne, ae.source).loadTile(ae))), this.actor.registerMessageHandler("RDT", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(ne, ae.source).removeTile(ae);
            })))), this.actor.registerMessageHandler("GCEZ", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(ne, ae.type, ae.source).getClusterExpansionZoom(ae);
            })))), this.actor.registerMessageHandler("GCC", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(ne, ae.type, ae.source).getClusterChildren(ae);
            })))), this.actor.registerMessageHandler("GCL", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(ne, ae.type, ae.source).getClusterLeaves(ae);
            })))), this.actor.registerMessageHandler("LD", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).loadData(ae))), this.actor.registerMessageHandler("GD", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).getData())), this.actor.registerMessageHandler("LT", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).loadTile(ae))), this.actor.registerMessageHandler("RT", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).reloadTile(ae))), this.actor.registerMessageHandler("AT", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).abortTile(ae))), this.actor.registerMessageHandler("RMT", ((ne, ae) => this._getWorkerSource(ne, ae.type, ae.source).removeTile(ae))), this.actor.registerMessageHandler("RS", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              if (!this.workerSources[ne] || !this.workerSources[ne][ae.type] || !this.workerSources[ne][ae.type][ae.source]) return;
              const be = this.workerSources[ne][ae.type][ae.source];
              delete this.workerSources[ne][ae.type][ae.source], be.removeSource !== void 0 && be.removeSource(ae);
            })))), this.actor.registerMessageHandler("RM", ((ne) => p._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[ne], delete this.availableImages[ne], delete this.workerSources[ne], delete this.demWorkerSources[ne];
            })))), this.actor.registerMessageHandler("SR", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              this.referrer = ae;
            })))), this.actor.registerMessageHandler("SRPS", ((ne, ae) => this._syncRTLPluginState(ne, ae))), this.actor.registerMessageHandler("IS", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              this.self.importScripts(ae);
            })))), this.actor.registerMessageHandler("SI", ((ne, ae) => this._setImages(ne, ae))), this.actor.registerMessageHandler("UL", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(ne).update(ae.layers, ae.removedIds);
            })))), this.actor.registerMessageHandler("SL", ((ne, ae) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(ne).replace(ae);
            }))));
          }
          _setImages(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              this.availableImages[re] = ne;
              for (const ae in this.workerSources[re]) {
                const be = this.workerSources[re][ae];
                for (const Ie in be) be[Ie].availableImages = ne;
              }
            }));
          }
          _syncRTLPluginState(re, ne) {
            return p._(this, void 0, void 0, (function* () {
              return yield p.cX.syncState(ne, this.self.importScripts);
            }));
          }
          _getAvailableImages(re) {
            let ne = this.availableImages[re];
            return ne || (ne = []), ne;
          }
          _getLayerIndex(re) {
            let ne = this.layerIndexes[re];
            return ne || (ne = this.layerIndexes[re] = new o()), ne;
          }
          _getWorkerSource(re, ne, ae) {
            if (this.workerSources[re] || (this.workerSources[re] = {}), this.workerSources[re][ne] || (this.workerSources[re][ne] = {}), !this.workerSources[re][ne][ae]) {
              const be = { sendAsync: (Ie, Fe) => (Ie.targetMapId = re, this.actor.sendAsync(Ie, Fe)) };
              switch (ne) {
                case "vector":
                  this.workerSources[re][ne][ae] = new I(be, this._getLayerIndex(re), this._getAvailableImages(re));
                  break;
                case "geojson":
                  this.workerSources[re][ne][ae] = new on(be, this._getLayerIndex(re), this._getAvailableImages(re));
                  break;
                default:
                  this.workerSources[re][ne][ae] = new this.externalWorkerSourceTypes[ne](be, this._getLayerIndex(re), this._getAvailableImages(re));
              }
            }
            return this.workerSources[re][ne][ae];
          }
          _getDEMWorkerSource(re, ne) {
            return this.demWorkerSources[re] || (this.demWorkerSources[re] = {}), this.demWorkerSources[re][ne] || (this.demWorkerSources[re][ne] = new z()), this.demWorkerSources[re][ne];
          }
        }
        return p.i(self) && (self.worker = new Sn(self)), Sn;
      })), h("index", ["exports", "./shared"], (function(p, o) {
        var w = "5.7.0";
        function S() {
          var v = new o.A(4);
          return o.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let k, I;
        const z = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(v, e, s) {
          const u = requestAnimationFrame(((y) => {
            m(), e(y);
          })), { unsubscribe: m } = o.s(v.signal, "abort", (() => {
            m(), cancelAnimationFrame(u), s(o.c());
          }), false);
        }, frameAsync(v) {
          return new Promise(((e, s) => {
            this.frame(v, e, s);
          }));
        }, getImageData(v, e = 0) {
          return this.getImageCanvasContext(v).getImageData(-e, -e, v.width + 2 * e, v.height + 2 * e);
        }, getImageCanvasContext(v) {
          const e = window.document.createElement("canvas"), s = e.getContext("2d", { willReadFrequently: true });
          if (!s) throw new Error("failed to create canvas 2d context");
          return e.width = v.width, e.height = v.height, s.drawImage(v, 0, 0, v.width, v.height), s;
        }, resolveURL: (v) => (k || (k = document.createElement("a")), k.href = v, k.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (I == null && (I = matchMedia("(prefers-reduced-motion: reduce)")), I.matches);
        } };
        class R {
          static testProp(e) {
            if (!R.docStyle) return e[0];
            for (let s = 0; s < e.length; s++) if (e[s] in R.docStyle) return e[s];
            return e[0];
          }
          static create(e, s, u) {
            const m = window.document.createElement(e);
            return s !== void 0 && (m.className = s), u && u.appendChild(m), m;
          }
          static createNS(e, s) {
            return window.document.createElementNS(e, s);
          }
          static disableDrag() {
            R.docStyle && R.selectProp && (R.userSelect = R.docStyle[R.selectProp], R.docStyle[R.selectProp] = "none");
          }
          static enableDrag() {
            R.docStyle && R.selectProp && (R.docStyle[R.selectProp] = R.userSelect);
          }
          static setTransform(e, s) {
            e.style[R.transformProp] = s;
          }
          static addEventListener(e, s, u, m = {}) {
            e.addEventListener(s, u, "passive" in m ? m : m.capture);
          }
          static removeEventListener(e, s, u, m = {}) {
            e.removeEventListener(s, u, "passive" in m ? m : m.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", R.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", R.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", R.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e) {
            const s = e.getBoundingClientRect();
            return { x: s.width / e.offsetWidth || 1, y: s.height / e.offsetHeight || 1, boundingClientRect: s };
          }
          static getPoint(e, s, u) {
            const m = s.boundingClientRect;
            return new o.P((u.clientX - m.left) / s.x - e.clientLeft, (u.clientY - m.top) / s.y - e.clientTop);
          }
          static mousePos(e, s) {
            const u = R.getScale(e);
            return R.getPoint(e, u, s);
          }
          static touchPos(e, s) {
            const u = [], m = R.getScale(e);
            for (let y = 0; y < s.length; y++) u.push(R.getPoint(e, m, s[y]));
            return u;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const s = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), u = s.querySelectorAll("script");
            for (const m of u) m.remove();
            return R.clean(s), s.innerHTML;
          }
          static isPossiblyDangerous(e, s) {
            const u = s.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !u.includes("javascript:") && !u.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const s = e.children;
            for (const u of s) R.removeAttributes(u), R.clean(u);
          }
          static removeAttributes(e) {
            for (const { name: s, value: u } of e.attributes) R.isPossiblyDangerous(s, u) && e.removeAttribute(s);
          }
        }
        R.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, R.selectProp = R.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), R.transformProp = R.testProp(["transform", "WebkitTransform"]);
        const O = { supported: false, testSupport: function(v) {
          !N && W && (K ? Z(v) : V = v);
        } };
        let V, W, N = false, K = false;
        function Z(v) {
          const e = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, e);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, W), v.isContextLost()) return;
            O.supported = true;
          } catch {
          }
          v.deleteTexture(e), N = true;
        }
        var X;
        typeof document < "u" && (W = document.createElement("img"), W.onload = () => {
          V && Z(V), V = null, K = true;
        }, W.onerror = () => {
          N = true, V = null;
        }, W.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(v) {
          let e, s, u, m;
          v.resetRequestQueue = () => {
            e = [], s = 0, u = 0, m = {};
          }, v.addThrottleControl = (M) => {
            const D = u++;
            return m[D] = M, D;
          }, v.removeThrottleControl = (M) => {
            delete m[M], x();
          }, v.getImage = (M, D, F = true) => new Promise(((j, $) => {
            O.supported && (M.headers || (M.headers = {}), M.headers.accept = "image/webp,*/*"), o.e(M, { type: "image" }), e.push({ abortController: D, requestParameters: M, supportImageRefresh: F, state: "queued", onError: (G) => {
              $(G);
            }, onSuccess: (G) => {
              j(G);
            } }), x();
          }));
          const y = (M) => o._(this, void 0, void 0, (function* () {
            M.state = "running";
            const { requestParameters: D, supportImageRefresh: F, onError: j, onSuccess: $, abortController: G } = M, ee = F === false && !o.i(self) && !o.g(D.url) && (!D.headers || Object.keys(D.headers).reduce(((pe, ge) => pe && ge === "accept"), true));
            s++;
            const ue = ee ? T(D, G) : o.m(D, G);
            try {
              const pe = yield ue;
              delete M.abortController, M.state = "completed", pe.data instanceof HTMLImageElement || o.b(pe.data) ? $(pe) : pe.data && $({ data: yield (ce = pe.data, typeof createImageBitmap == "function" ? o.f(ce) : o.h(ce)), cacheControl: pe.cacheControl, expires: pe.expires });
            } catch (pe) {
              delete M.abortController, j(pe);
            } finally {
              s--, x();
            }
            var ce;
          })), x = () => {
            const M = (() => {
              for (const D of Object.keys(m)) if (m[D]()) return true;
              return false;
            })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let D = s; D < M && e.length > 0; D++) {
              const F = e.shift();
              F.abortController.signal.aborted ? D-- : y(F);
            }
          }, T = (M, D) => new Promise(((F, j) => {
            const $ = new Image(), G = M.url, ee = M.credentials;
            ee && ee === "include" ? $.crossOrigin = "use-credentials" : (ee && ee === "same-origin" || !o.d(G)) && ($.crossOrigin = "anonymous"), D.signal.addEventListener("abort", (() => {
              $.src = "", j(o.c());
            })), $.fetchPriority = "high", $.onload = () => {
              $.onerror = $.onload = null, F({ data: $ });
            }, $.onerror = () => {
              $.onerror = $.onload = null, D.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, $.src = G;
          }));
        })(X || (X = {})), X.resetRequestQueue();
        class te {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, s) {
            return this._transformRequestFn && this._transformRequestFn(e, s) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function q(v) {
          const e = [];
          if (typeof v == "string") e.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const s = [];
            for (const { id: u, url: m } of v) {
              const y = `${u}${m}`;
              s.indexOf(y) === -1 && (s.push(y), e.push({ id: u, url: m }));
            }
          }
          return e;
        }
        function he(v, e, s) {
          try {
            const u = new URL(v);
            return u.pathname += `${e}${s}`, u.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function se(v) {
          const { userImage: e } = v;
          return !!(e && e.render && e.render()) && (v.data.replace(new Uint8Array(e.data.buffer)), true);
        }
        class Q extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: s, promiseResolve: u } of this.requestors) u(this._getImagesForIds(s));
              this.requestors = [];
            }
          }
          getImage(e) {
            const s = this.images[e];
            if (s && !s.data && s.spriteData) {
              const u = s.spriteData;
              s.data = new o.R({ width: u.width, height: u.height }, u.context.getImageData(u.x, u.y, u.width, u.height).data), s.spriteData = null;
            }
            return s;
          }
          addImage(e, s) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, s) && (this.images[e] = s);
          }
          _validate(e, s) {
            let u = true;
            const m = s.data || s.spriteData;
            return this._validateStretch(s.stretchX, m && m.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))), u = false), this._validateStretch(s.stretchY, m && m.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))), u = false), this._validateContent(s.content, s) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))), u = false), u;
          }
          _validateStretch(e, s) {
            if (!e) return true;
            let u = 0;
            for (const m of e) {
              if (m[0] < u || m[1] < m[0] || s < m[1]) return false;
              u = m[1];
            }
            return true;
          }
          _validateContent(e, s) {
            if (!e) return true;
            if (e.length !== 4) return false;
            const u = s.spriteData, m = u && u.width || s.data.width, y = u && u.height || s.data.height;
            return !(e[0] < 0 || m < e[0] || e[1] < 0 || y < e[1] || e[2] < 0 || m < e[2] || e[3] < 0 || y < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, s, u = true) {
            const m = this.getImage(e);
            if (u && (m.data.width !== s.data.width || m.data.height !== s.data.height)) throw new Error(`size mismatch between old image (${m.data.width}x${m.data.height}) and new image (${s.data.width}x${s.data.height}).`);
            s.version = m.version + 1, this.images[e] = s, this.updatedImages[e] = true;
          }
          removeImage(e) {
            const s = this.images[e];
            delete this.images[e], delete this.patterns[e], s.userImage && s.userImage.onRemove && s.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((s, u) => {
              let m = true;
              if (!this.isLoaded()) for (const y of e) this.images[y] || (m = false);
              this.isLoaded() || m ? s(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: s });
            }));
          }
          _getImagesForIds(e) {
            const s = {};
            for (const u of e) {
              let m = this.getImage(u);
              m || (this.fire(new o.l("styleimagemissing", { id: u })), m = this.getImage(u)), m ? s[u] = { data: m.data.clone(), pixelRatio: m.pixelRatio, sdf: m.sdf, version: m.version, stretchX: m.stretchX, stretchY: m.stretchY, content: m.content, textFitWidth: m.textFitWidth, textFitHeight: m.textFitHeight, hasRenderCallback: !!(m.userImage && m.userImage.render) } : o.w(`Image "${u}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return s;
          }
          getPixelSize() {
            const { width: e, height: s } = this.atlasImage;
            return { width: e, height: s };
          }
          getPattern(e) {
            const s = this.patterns[e], u = this.getImage(e);
            if (!u) return null;
            if (s && s.position.version === u.version) return s.position;
            if (s) s.position.version = u.version;
            else {
              const m = { w: u.data.width + 2, h: u.data.height + 2, x: 0, y: 0 }, y = new o.I(m, u);
              this.patterns[e] = { bin: m, position: y };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const s = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new o.T(e, this.atlasImage, s.RGBA), this.atlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const y in this.patterns) e.push(this.patterns[y].bin);
            const { w: s, h: u } = o.p(e), m = this.atlasImage;
            m.resize({ width: s || 1, height: u || 1 });
            for (const y in this.patterns) {
              const { bin: x } = this.patterns[y], T = x.x + 1, M = x.y + 1, D = this.getImage(y).data, F = D.width, j = D.height;
              o.R.copy(D, m, { x: 0, y: 0 }, { x: T, y: M }, { width: F, height: j }), o.R.copy(D, m, { x: 0, y: j - 1 }, { x: T, y: M - 1 }, { width: F, height: 1 }), o.R.copy(D, m, { x: 0, y: 0 }, { x: T, y: M + j }, { width: F, height: 1 }), o.R.copy(D, m, { x: F - 1, y: 0 }, { x: T - 1, y: M }, { width: 1, height: j }), o.R.copy(D, m, { x: 0, y: 0 }, { x: T + F, y: M }, { width: 1, height: j });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const s of e) {
              if (this.callbackDispatchedThisFrame[s]) continue;
              this.callbackDispatchedThisFrame[s] = true;
              const u = this.getImage(s);
              u || o.w(`Image with ID: "${s}" was not found`), se(u) && this.updateImage(s, u);
            }
          }
        }
        const oe = 1e20;
        function ve(v, e, s, u, m, y, x, T, M) {
          for (let D = e; D < e + u; D++) Be(v, s * y + D, y, m, x, T, M);
          for (let D = s; D < s + m; D++) Be(v, D * y + e, 1, u, x, T, M);
        }
        function Be(v, e, s, u, m, y, x) {
          y[0] = 0, x[0] = -oe, x[1] = oe, m[0] = v[e];
          for (let T = 1, M = 0, D = 0; T < u; T++) {
            m[T] = v[e + T * s];
            const F = T * T;
            do {
              const j = y[M];
              D = (m[T] - m[j] + F - j * j) / (T - j) / 2;
            } while (D <= x[M] && --M > -1);
            M++, y[M] = T, x[M] = D, x[M + 1] = oe;
          }
          for (let T = 0, M = 0; T < u; T++) {
            for (; x[M + 1] < T; ) M++;
            const D = y[M], F = T - D;
            v[e + T * s] = m[D] + F * F;
          }
        }
        class Ne {
          constructor(e, s, u) {
            this.requestManager = e, this.localIdeographFontFamily = s, this.entries = {}, this.lang = u;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return o._(this, void 0, void 0, (function* () {
              const s = [];
              for (const y in e) for (const x of e[y]) s.push(this._getAndCacheGlyphsPromise(y, x));
              const u = yield Promise.all(s), m = {};
              for (const { stack: y, id: x, glyph: T } of u) m[y] || (m[y] = {}), m[y][x] = T && { id: T.id, bitmap: T.bitmap.clone(), metrics: T.metrics };
              return m;
            }));
          }
          _getAndCacheGlyphsPromise(e, s) {
            return o._(this, void 0, void 0, (function* () {
              let u = this.entries[e];
              u || (u = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let m = u.glyphs[s];
              if (m !== void 0) return { stack: e, id: s, glyph: m };
              if (m = this._tinySDF(u, e, s), m) return u.glyphs[s] = m, { stack: e, id: s, glyph: m };
              const y = Math.floor(s / 256);
              if (256 * y > 65535) throw new Error("glyphs > 65535 not supported");
              if (u.ranges[y]) return { stack: e, id: s, glyph: m };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!u.requests[y]) {
                const T = Ne.loadGlyphRange(e, y, this.url, this.requestManager);
                u.requests[y] = T;
              }
              const x = yield u.requests[y];
              for (const T in x) this._doesCharSupportLocalGlyph(+T) || (u.glyphs[+T] = x[+T]);
              return u.ranges[y] = true, { stack: e, id: s, glyph: x[s] || null };
            }));
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, s, u) {
            const m = this.localIdeographFontFamily;
            if (!m || !this._doesCharSupportLocalGlyph(u)) return;
            let y = e.tinySDF;
            if (!y) {
              let T = "400";
              /bold/i.test(s) ? T = "900" : /medium/i.test(s) ? T = "500" : /light/i.test(s) && (T = "200"), y = e.tinySDF = new Ne.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: m, fontWeight: T });
            }
            const x = y.draw(String.fromCharCode(u));
            return { id: u, bitmap: new o.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        Ne.loadGlyphRange = function(v, e, s, u) {
          return o._(this, void 0, void 0, (function* () {
            const m = 256 * e, y = m + 255, x = u.transformRequest(s.replace("{fontstack}", v).replace("{range}", `${m}-${y}`), "Glyphs"), T = yield o.n(x, new AbortController());
            if (!T || !T.data) throw new Error(`Could not load glyph range. range: ${e}, ${m}-${y}`);
            const M = {};
            for (const D of o.o(T.data)) M[D.id] = D;
            return M;
          }));
        }, Ne.TinySDF = class {
          constructor({ fontSize: v = 24, buffer: e = 3, radius: s = 8, cutoff: u = 0.25, fontFamily: m = "sans-serif", fontWeight: y = "normal", fontStyle: x = "normal", lang: T = null } = {}) {
            this.buffer = e, this.cutoff = u, this.radius = s, this.lang = T;
            const M = this.size = v + 4 * e, D = this._createCanvas(M), F = this.ctx = D.getContext("2d", { willReadFrequently: true });
            F.font = `${x} ${y} ${v}px ${m}`, F.textBaseline = "alphabetic", F.textAlign = "left", F.fillStyle = "black", this.gridOuter = new Float64Array(M * M), this.gridInner = new Float64Array(M * M), this.f = new Float64Array(M), this.z = new Float64Array(M + 1), this.v = new Uint16Array(M);
          }
          _createCanvas(v) {
            const e = document.createElement("canvas");
            return e.width = e.height = v, e;
          }
          draw(v) {
            const { width: e, actualBoundingBoxAscent: s, actualBoundingBoxDescent: u, actualBoundingBoxLeft: m, actualBoundingBoxRight: y } = this.ctx.measureText(v), x = Math.ceil(s), T = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(y - m))), M = Math.min(this.size - this.buffer, x + Math.ceil(u)), D = T + 2 * this.buffer, F = M + 2 * this.buffer, j = Math.max(D * F, 0), $ = new Uint8ClampedArray(j), G = { data: $, width: D, height: F, glyphWidth: T, glyphHeight: M, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
            if (T === 0 || M === 0) return G;
            const { ctx: ee, buffer: ue, gridInner: ce, gridOuter: pe } = this;
            this.lang && (ee.lang = this.lang), ee.clearRect(ue, ue, T, M), ee.fillText(v, ue, ue + x);
            const ge = ee.getImageData(ue, ue, T, M);
            pe.fill(oe, 0, j), ce.fill(0, 0, j);
            for (let Ce = 0; Ce < M; Ce++) for (let xe = 0; xe < T; xe++) {
              const ke = ge.data[4 * (Ce * T + xe) + 3] / 255;
              if (ke === 0) continue;
              const ze = (Ce + ue) * D + xe + ue;
              if (ke === 1) pe[ze] = 0, ce[ze] = oe;
              else {
                const we = 0.5 - ke;
                pe[ze] = we > 0 ? we * we : 0, ce[ze] = we < 0 ? we * we : 0;
              }
            }
            ve(pe, 0, 0, D, F, D, this.f, this.v, this.z), ve(ce, ue, ue, T, M, D, this.f, this.v, this.z);
            for (let Ce = 0; Ce < j; Ce++) {
              const xe = Math.sqrt(pe[Ce]) - Math.sqrt(ce[Ce]);
              $[Ce] = Math.round(255 - 255 * (xe / this.radius + this.cutoff));
            }
            return G;
          }
        };
        class Pe {
          constructor() {
            this.specification = o.v.light.position;
          }
          possiblyEvaluate(e, s) {
            return o.B(e.expression.evaluate(s));
          }
          interpolate(e, s, u) {
            return { x: o.C.number(e.x, s.x, u), y: o.C.number(e.y, s.y, u), z: o.C.number(e.z, s.z, u) };
          }
        }
        let tt;
        class at extends o.E {
          constructor(e) {
            super(), tt = tt || new o.r({ anchor: new o.D(o.v.light.anchor), position: new Pe(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.t(tt), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, s = {}) {
            if (!this._validate(o.x, e, s)) for (const u in e) {
              const m = e[u];
              u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), m) : this._transitionable.setValue(u, m);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, s, u) {
            return (!u || u.validate !== false) && o.y(this, e.call(o.z, { value: s, style: { glyphs: true, sprite: true }, styleSpec: o.v }));
          }
        }
        const xt = new o.r({ "sky-color": new o.D(o.v.sky["sky-color"]), "horizon-color": new o.D(o.v.sky["horizon-color"]), "fog-color": new o.D(o.v.sky["fog-color"]), "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]), "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]), "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"]) });
        class ht extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(xt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0));
          }
          setSky(e, s = {}) {
            if (!this._validate(o.G, e, s)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const u in e) {
                const m = e[u];
                u.endsWith("-transition") ? this._transitionable.setTransition(u.slice(0, -11), m) : this._transitionable.setValue(u, m);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, s, u = {}) {
            return (u == null ? void 0 : u.validate) !== false && o.y(this, e.call(o.z, o.e({ value: s, style: { glyphs: true, sprite: true }, styleSpec: o.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class Ye {
          constructor(e, s) {
            this.width = e, this.height = s, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, s) {
            const u = e.join(",") + String(s);
            return this.dashEntry[u] || (this.dashEntry[u] = this.addDash(e, s)), this.dashEntry[u];
          }
          getDashRanges(e, s, u) {
            const m = [];
            let y = e.length % 2 == 1 ? -e[e.length - 1] * u : 0, x = e[0] * u, T = true;
            m.push({ left: y, right: x, isDash: T, zeroLength: e[0] === 0 });
            let M = e[0];
            for (let D = 1; D < e.length; D++) {
              T = !T;
              const F = e[D];
              y = M * u, M += F, x = M * u, m.push({ left: y, right: x, isDash: T, zeroLength: F === 0 });
            }
            return m;
          }
          addRoundDash(e, s, u) {
            const m = s / 2;
            for (let y = -u; y <= u; y++) {
              const x = this.width * (this.nextRow + u + y);
              let T = 0, M = e[T];
              for (let D = 0; D < this.width; D++) {
                D / M.right > 1 && (M = e[++T]);
                const F = Math.abs(D - M.left), j = Math.abs(D - M.right), $ = Math.min(F, j);
                let G;
                const ee = y / u * (m + 1);
                if (M.isDash) {
                  const ue = m - Math.abs(ee);
                  G = Math.sqrt($ * $ + ue * ue);
                } else G = m - Math.sqrt($ * $ + ee * ee);
                this.data[x + D] = Math.max(0, Math.min(255, G + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let T = e.length - 1; T >= 0; --T) {
              const M = e[T], D = e[T + 1];
              M.zeroLength ? e.splice(T, 1) : D && D.isDash === M.isDash && (D.left = M.left, e.splice(T, 1));
            }
            const s = e[0], u = e[e.length - 1];
            s.isDash === u.isDash && (s.left = u.left - this.width, u.right = s.right + this.width);
            const m = this.width * this.nextRow;
            let y = 0, x = e[y];
            for (let T = 0; T < this.width; T++) {
              T / x.right > 1 && (x = e[++y]);
              const M = Math.abs(T - x.left), D = Math.abs(T - x.right), F = Math.min(M, D);
              this.data[m + T] = Math.max(0, Math.min(255, (x.isDash ? F : -F) + 128));
            }
          }
          addDash(e, s) {
            const u = s ? 7 : 0, m = 2 * u + 1;
            if (this.nextRow + m > this.height) return o.w("LineAtlas out of space"), null;
            let y = 0;
            for (let T = 0; T < e.length; T++) y += e[T];
            if (y !== 0) {
              const T = this.width / y, M = this.getDashRanges(e, this.width, T);
              s ? this.addRoundDash(M, T, u) : this.addRegularDash(M);
            }
            const x = { y: (this.nextRow + u + 0.5) / this.height, height: 2 * u / this.height, width: y };
            return this.nextRow += m, this.dirty = true, x;
          }
          bind(e) {
            const s = e.gl;
            this.texture ? (s.bindTexture(s.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, this.width, this.height, s.ALPHA, s.UNSIGNED_BYTE, this.data))) : (this.texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this.texture), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texImage2D(s.TEXTURE_2D, 0, s.ALPHA, this.width, this.height, 0, s.ALPHA, s.UNSIGNED_BYTE, this.data));
          }
        }
        const Ke = "maplibre_preloaded_worker_pool";
        class Lt {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < Lt.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[e] = true, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((s) => {
              s.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Ke];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const ct = Math.floor(z.hardwareConcurrency / 2);
        let bt, Nt;
        function Yt() {
          return bt || (bt = new Lt()), bt;
        }
        Lt.workerCount = o.H(globalThis) ? Math.max(Math.min(ct, 3), 1) : 1;
        class vt {
          constructor(e, s) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = s;
            const u = this.workerPool.acquire(s);
            for (let m = 0; m < u.length; m++) {
              const y = new o.J(u[m], s);
              y.name = `Worker ${m}`, this.actors.push(y);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, s) {
            const u = [];
            for (const m of this.actors) u.push(m.sendAsync({ type: e, data: s }));
            return Promise.all(u);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = true) {
            this.actors.forEach(((s) => {
              s.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, s) {
            for (const u of this.actors) u.registerMessageHandler(e, s);
          }
        }
        function jt() {
          return Nt || (Nt = new vt(Yt(), o.K), Nt.registerMessageHandler("GR", ((v, e, s) => o.m(e, s)))), Nt;
        }
        function er(v, e) {
          const s = o.L();
          return o.M(s, s, [1, 1, 0]), o.N(s, s, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? o.O(s, s, v.calculatePosMatrix(e.toUnwrapped())) : s;
        }
        function yr(v, e, s, u, m, y, x) {
          var T;
          const M = (function($, G, ee) {
            if ($) for (const ue of $) {
              const ce = G[ue];
              if (ce && ce.source === ee && ce.type === "fill-extrusion") return true;
            }
            else for (const ue in G) {
              const ce = G[ue];
              if (ce.source === ee && ce.type === "fill-extrusion") return true;
            }
            return false;
          })((T = m == null ? void 0 : m.layers) !== null && T !== void 0 ? T : null, e, v.id), D = y.maxPitchScaleFactor(), F = v.tilesIn(u, D, M);
          F.sort(Tr);
          const j = [];
          for (const $ of F) j.push({ wrappedTileID: $.tileID.wrapped().key, queryResults: $.tile.queryRenderedFeatures(e, s, v._state, $.queryGeometry, $.cameraQueryGeometry, $.scale, m, y, D, er(v.transform, $.tileID), x ? (G, ee) => x($.tileID, G, ee) : void 0) });
          return (function($, G) {
            for (const ee in $) for (const ue of $[ee]) zr(ue, G);
            return $;
          })((function($) {
            const G = {}, ee = {};
            for (const ue of $) {
              const ce = ue.queryResults, pe = ue.wrappedTileID, ge = ee[pe] = ee[pe] || {};
              for (const Ce in ce) {
                const xe = ce[Ce], ke = ge[Ce] = ge[Ce] || {}, ze = G[Ce] = G[Ce] || [];
                for (const we of xe) ke[we.featureIndex] || (ke[we.featureIndex] = true, ze.push(we));
              }
            }
            return G;
          })(j), v);
        }
        function Tr(v, e) {
          const s = v.tileID, u = e.tileID;
          return s.overscaledZ - u.overscaledZ || s.canonical.y - u.canonical.y || s.wrap - u.wrap || s.canonical.x - u.canonical.x;
        }
        function zr(v, e) {
          const s = v.feature, u = e.getFeatureState(s.layer["source-layer"], s.id);
          s.source = s.layer.source, s.layer["source-layer"] && (s.sourceLayer = s.layer["source-layer"]), s.state = u;
        }
        function rr(v, e, s) {
          return o._(this, void 0, void 0, (function* () {
            let u = v;
            if (v.url ? u = (yield o.j(e.transformRequest(v.url, "Source"), s)).data : yield z.frameAsync(s), !u) return null;
            const m = o.Q(o.e(u, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in u && u.vector_layers && (m.vectorLayerIds = u.vector_layers.map(((y) => y.id))), m;
          }));
        }
        class yt {
          constructor(e, s) {
            e && (s ? this.setSouthWest(e).setNorthEast(s) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this;
          }
          extend(e) {
            const s = this._sw, u = this._ne;
            let m, y;
            if (e instanceof o.S) m = e, y = e;
            else {
              if (!(e instanceof yt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(yt.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(o.S.convert(e)) : this;
              if (m = e._sw, y = e._ne, !m || !y) return this;
            }
            return s || u ? (s.lng = Math.min(m.lng, s.lng), s.lat = Math.min(m.lat, s.lat), u.lng = Math.max(y.lng, u.lng), u.lat = Math.max(y.lat, u.lat)) : (this._sw = new o.S(m.lng, m.lat), this._ne = new o.S(y.lng, y.lat)), this;
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: s, lat: u } = o.S.convert(e);
            let m = this._sw.lng <= s && s <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (m = this._sw.lng >= s && s >= this._ne.lng), this._sw.lat <= u && u <= this._ne.lat && m;
          }
          static convert(e) {
            return e instanceof yt ? e : e && new yt(e);
          }
          static fromLngLat(e, s = 0) {
            const u = 360 * s / 40075017, m = u / Math.cos(Math.PI / 180 * e.lat);
            return new yt(new o.S(e.lng - m, e.lat - u), new o.S(e.lng + m, e.lat + u));
          }
          adjustAntiMeridian() {
            const e = new o.S(this._sw.lng, this._sw.lat), s = new o.S(this._ne.lng, this._ne.lat);
            return new yt(e, e.lng > s.lng ? new o.S(s.lng + 360, s.lat) : s);
          }
        }
        class Ct {
          constructor(e, s, u) {
            this.bounds = yt.convert(this.validateBounds(e)), this.minzoom = s || 0, this.maxzoom = u || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const s = Math.pow(2, e.z), u = Math.floor(o.V(this.bounds.getWest()) * s), m = Math.floor(o.U(this.bounds.getNorth()) * s), y = Math.ceil(o.V(this.bounds.getEast()) * s), x = Math.ceil(o.U(this.bounds.getSouth()) * s);
            return e.x >= u && e.x < y && e.y >= m && e.y < x;
          }
        }
        class Dt extends o.E {
          constructor(e, s, u, m) {
            if (super(), this.id = e, this.dispatcher = u, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, o.e(this, o.Q(s, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, s), this._collectResourceTiming = s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(m);
          }
          load() {
            return o._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new o.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (o.e(this, e), e.bounds && (this.tileBounds = new Ct(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new o.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return o.e({}, this._options);
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              const s = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), u = { request: this.map._requestManager.transformRequest(s, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              u.request.collectResourceTiming = this._collectResourceTiming;
              let m = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((y, x) => {
                  e.reloadPromise = { resolve: y, reject: x };
                }));
              } else e.actor = this.dispatcher.getActor(), m = "LT";
              e.abortController = new AbortController();
              try {
                const y = yield e.actor.sendAsync({ type: m, data: u }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, y);
              } catch (y) {
                if (delete e.abortController, e.aborted) return;
                if (y && y.status !== 404) throw y;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, s) {
            if (s && s.resourceTiming && (e.resourceTiming = s.resourceTiming), s && this.map._refreshExpiredTiles && e.setExpiryData(s), e.loadVectorData(s, this.map.painter), e.reloadPromise) {
              const u = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(u.resolve).catch(u.reject);
            }
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class ir extends o.E {
          constructor(e, s, u, m) {
            super(), this.id = e, this.dispatcher = u, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = o.e({ type: "raster" }, s), o.e(this, o.Q(s, ["url", "scheme", "tileSize"]));
          }
          load() {
            return o._(this, arguments, void 0, (function* (e = false) {
              this._loaded = false, this.fire(new o.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const s = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, s && (o.e(this, s), s.bounds && (this.tileBounds = new Ct(s.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (s) {
                this._tileJSONRequest = null, this.fire(new o.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return o.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              const s = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const u = yield X.getImage(this.map._requestManager.transformRequest(s, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (u && u.data) {
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({ cacheControl: u.cacheControl, expires: u.expires });
                  const m = this.map.painter.context, y = m.gl, x = u.data;
                  e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: true }) : (e.texture = new o.T(m, x, y.RGBA, { useMipmap: true }), e.texture.bind(y.LINEAR, y.CLAMP_TO_EDGE, y.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u;
              }
            }));
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class ut extends ir {
          constructor(e, s, u, m) {
            super(e, s, u, m), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, s), this.encoding = s.encoding || "mapbox", this.redFactor = s.redFactor, this.greenFactor = s.greenFactor, this.blueFactor = s.blueFactor, this.baseShift = s.baseShift;
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              const s = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), u = this.map._requestManager.transformRequest(s, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const m = yield X.getImage(u, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (m && m.data) {
                  const y = m.data;
                  this.map._refreshExpiredTiles && (m.cacheControl || m.expires) && e.setExpiryData({ cacheControl: m.cacheControl, expires: m.expires });
                  const x = o.b(y) && o.W() ? y : yield this.readImageNow(y), T = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const M = yield e.actor.sendAsync({ type: "LDT", data: T });
                    e.dem = M, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
                  }
                }
              } catch (m) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (m) throw e.state = "errored", m;
              }
            }));
          }
          readImageNow(e) {
            return o._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && o.X()) {
                const s = e.width + 2, u = e.height + 2;
                try {
                  return new o.R({ width: s, height: u }, yield o.Y(e, -1, -1, s, u));
                } catch {
                }
              }
              return z.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const s = e.canonical, u = Math.pow(2, s.z), m = (s.x - 1 + u) % u, y = s.x === 0 ? e.wrap - 1 : e.wrap, x = (s.x + 1 + u) % u, T = s.x + 1 === u ? e.wrap + 1 : e.wrap, M = {};
            return M[new o.Z(e.overscaledZ, y, s.z, m, s.y).key] = { backfilled: false }, M[new o.Z(e.overscaledZ, T, s.z, x, s.y).key] = { backfilled: false }, s.y > 0 && (M[new o.Z(e.overscaledZ, y, s.z, m, s.y - 1).key] = { backfilled: false }, M[new o.Z(e.overscaledZ, e.wrap, s.z, s.x, s.y - 1).key] = { backfilled: false }, M[new o.Z(e.overscaledZ, T, s.z, x, s.y - 1).key] = { backfilled: false }), s.y + 1 < u && (M[new o.Z(e.overscaledZ, y, s.z, m, s.y + 1).key] = { backfilled: false }, M[new o.Z(e.overscaledZ, e.wrap, s.z, s.x, s.y + 1).key] = { backfilled: false }, M[new o.Z(e.overscaledZ, T, s.z, x, s.y + 1).key] = { backfilled: false }), M;
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        class We extends o.E {
          constructor(e, s, u, m) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: s.data }, this.actor = u.getActor(), this.setEventedParent(m), this._data = s.data, this._options = o.e({}, s), this._collectResourceTiming = s.collectResourceTiming, s.maxzoom !== void 0 && (this.maxzoom = s.maxzoom), s.type && (this.type = s.type), s.attribution && (this.attribution = s.attribution), this.promoteId = s.promoteId, s.clusterMaxZoom !== void 0 && this.maxzoom <= s.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${s.clusterMaxZoom}".`), this.workerOptions = o.e({ source: this.id, cluster: s.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(s.buffer !== void 0 ? s.buffer : 128), tolerance: this._pixelsToTileUnits(s.tolerance !== void 0 ? s.tolerance : 0.375), extent: o.$, maxZoom: this.maxzoom, lineMetrics: s.lineMetrics || false, generateId: s.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(s.clusterMaxZoom), minPoints: Math.max(2, s.clusterMinPoints || 2), extent: o.$, radius: this._pixelsToTileUnits(s.clusterRadius || 50), log: false, generateId: s.generateId || false }, clusterProperties: s.clusterProperties, filter: s.filter }, s.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (o.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const s = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${s}"`), s;
          }
          load() {
            return o._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = o.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return o._(this, void 0, void 0, (function* () {
              const e = o.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map(((s) => s.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return o._(this, void 0, void 0, (function* () {
              const e = new yt(), s = yield this.getData();
              let u;
              switch (s.type) {
                case "FeatureCollection":
                  u = s.features.map(((m) => this.getCoordinatesFromGeometry(m.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  u = this.getCoordinatesFromGeometry(s.geometry);
                  break;
                default:
                  u = this.getCoordinatesFromGeometry(s);
              }
              if (u.length == 0) return e;
              for (let m = 0; m < u.length - 1; m += 2) e.extend([u[m], u[m + 1]]);
              return e;
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, s, u) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: s, offset: u } });
          }
          _updateWorkerData() {
            return o._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: s } = this._pendingWorkerUpdate;
              if (!e && !s) return void o.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const u = o.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (u.request = this.map._requestManager.transformRequest(z.resolveURL(e), "Source"), u.request.collectResourceTiming = this._collectResourceTiming) : u.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : s && (u.dataDiff = s, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = true, this.fire(new o.l("dataloading", { dataType: "source" }));
              try {
                const m = yield this.actor.sendAsync({ type: "LD", data: u });
                if (this._isUpdatingWorker = false, this._removed || m.abandoned) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                this._data = m.data;
                let y = null;
                m.resourceTiming && m.resourceTiming[this.id] && (y = m.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && y && y.length > 0 && o.e(x, { resourceTiming: y }), this.fire(new o.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new o.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
              } catch (m) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new o.l("dataabort", { dataType: "source" }));
                this.fire(new o.k(m));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              const s = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const u = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              e.abortController = new AbortController();
              const m = yield this.actor.sendAsync({ type: s, data: u }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(m, this.map.painter, s === "RT");
            }));
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
            }));
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return o.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class kt extends o.E {
          constructor(e, s, u, m) {
            super(), this.flippedWindingOrder = false, this.id = e, this.dispatcher = u, this.coordinates = s.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(m), this.options = s;
          }
          load(e) {
            return o._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new o.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const s = yield X.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, s && s.data && (this.image = s.data, e && (this.coordinates = e), this._finishLoading());
              } catch (s) {
                this._request = null, this._loaded = true, this.fire(new o.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const s = e.map(o.a1.fromLngLat);
            var u;
            return this.tileID = (function(m) {
              const y = o.a2.fromPoints(m), x = y.width(), T = y.height(), M = Math.max(x, T), D = Math.max(0, Math.floor(-Math.log(M) / Math.LN2)), F = Math.pow(2, D);
              return new o.a4(D, Math.floor((y.minX + y.maxX) / 2 * F), Math.floor((y.minY + y.maxY) / 2 * F));
            })(s), this.terrainTileRanges = this._getOverlappingTileRanges(s), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = s.map(((m) => this.tileID.getTilePoint(m)._round())), this.flippedWindingOrder = ((u = this.tileCoords)[1].x - u[0].x) * (u[2].y - u[0].y) - (u[1].y - u[0].y) * (u[2].x - u[0].x) < 0, this.fire(new o.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, s = e.gl;
            this.texture || (this.texture = new o.T(e, this.image, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let u = false;
            for (const m in this.tiles) {
              const y = this.tiles[m];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, u = true);
            }
            u && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e) {
            const { minX: s, minY: u, maxX: m, maxY: y } = o.a2.fromPoints(e), x = {};
            for (let T = 0; T <= o.a3; T++) {
              const M = Math.pow(2, T), D = Math.floor(s * M), F = Math.floor(u * M), j = Math.floor(m * M), $ = Math.floor(y * M);
              x[T] = { minTileX: D, minTileY: F, maxTileX: j, maxTileY: $ };
            }
            return x;
          }
        }
        class et extends kt {
          constructor(e, s, u, m) {
            super(e, s, u, m), this.roundZoom = true, this.type = "video", this.options = s;
          }
          load() {
            return o._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e = this.options;
              this.urls = [];
              for (const s of e.urls) this.urls.push(this.map._requestManager.transformRequest(s, "Source").url);
              try {
                const s = yield o.a5(this.urls);
                if (this._loaded = true, !s) return;
                this.video = s, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (s) {
                this.fire(new o.k(s));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const s = this.video.seekable;
              e < s.start(0) || e > s.end(0) ? this.fire(new o.k(new o.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${s.start(0)} and ${s.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, s = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, s.RGBA, s.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e, this.video, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let u = false;
            for (const m in this.tiles) {
              const y = this.tiles[m];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, u = true);
            }
            u && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class it extends kt {
          constructor(e, s, u, m) {
            super(e, s, u, m), s.coordinates ? Array.isArray(s.coordinates) && s.coordinates.length === 4 && !s.coordinates.some(((y) => !Array.isArray(y) || y.length !== 2 || y.some(((x) => typeof x != "number")))) || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), s.animate && typeof s.animate != "boolean" && this.fire(new o.k(new o.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), s.canvas ? typeof s.canvas == "string" || s.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = s, this.animate = s.animate === void 0 || s.animate;
          }
          load() {
            return o._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const s = this.map.painter.context, u = s.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new o.T(s, this.canvas, u.RGBA, { premultiply: true });
            let m = false;
            for (const y in this.tiles) {
              const x = this.tiles[y];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, m = true);
            }
            m && this.fire(new o.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
            return false;
          }
        }
        const Pt = {}, Et = (v) => {
          switch (v) {
            case "geojson":
              return We;
            case "image":
              return kt;
            case "raster":
              return ir;
            case "raster-dem":
              return ut;
            case "vector":
              return Dt;
            case "video":
              return et;
            case "canvas":
              return it;
          }
          return Pt[v];
        }, st = "RTLPluginLoaded";
        class St extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = jt();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((s) => {
              throw this.status = "error", s;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return o._(this, arguments, void 0, (function* (s, u = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = z.resolveURL(s), !this.url) throw new Error(`requested url ${s} is invalid`);
              if (this.status === "unavailable") {
                if (!u) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return o._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(st));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let ar = null;
        function on() {
          return ar || (ar = new St()), ar;
        }
        class Sn {
          constructor(e, s) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = o.a7(), this.uses = 0, this.tileSize = s, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const s = e + this.timeAdded;
            s < this.fadeEndTime || (this.fadeEndTime = s);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, s, u) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(m, y) {
                const x = {};
                if (!y) return x;
                for (const T of m) {
                  const M = T.layerIds.map(((D) => y.getLayer(D))).filter(Boolean);
                  if (M.length !== 0) {
                    T.layers = M, T.stateDependentLayerIds && (T.stateDependentLayers = T.stateDependentLayerIds.map(((D) => M.filter(((F) => F.id === D))[0])));
                    for (const D of M) x[D.id] = T;
                  }
                }
                return x;
              })(e.buckets, s == null ? void 0 : s.style), this.hasSymbolBuckets = false;
              for (const m in this.buckets) {
                const y = this.buckets[m];
                if (y instanceof o.a9) {
                  if (this.hasSymbolBuckets = true, !u) break;
                  y.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const m in this.buckets) {
                const y = this.buckets[m];
                if (y instanceof o.a9 && y.hasRTLText) {
                  this.hasRTLText = true, on().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const m in this.buckets) {
                const y = this.buckets[m];
                this.queryPadding = Math.max(this.queryPadding, s.style.getLayer(m).queryRadius(y));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new o.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const u in this.buckets) {
              const m = this.buckets[u];
              m.uploadPending() && m.upload(e);
            }
            const s = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e, this.imageAtlas.image, s.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e, this.glyphAtlasImage, s.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, s, u, m, y, x, T, M, D, F, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: m, cameraQueryGeometry: y, scale: x, tileSize: this.tileSize, pixelPosMatrix: F, transform: M, params: T, queryPadding: this.queryPadding * D, getElevation: j }, e, s, u) : {};
          }
          querySourceFeatures(e, s) {
            const u = this.latestFeatureIndex;
            if (!u || !u.rawTileData) return;
            const m = u.loadVTLayers(), y = s && s.sourceLayer ? s.sourceLayer : "", x = m._geojsonTileLayer || m[y];
            if (!x) return;
            const T = o.aa(s && s.filter), { z: M, x: D, y: F } = this.tileID.canonical, j = { z: M, x: D, y: F };
            for (let $ = 0; $ < x.length; $++) {
              const G = x.feature($);
              if (T.needGeometry) {
                const ce = o.ab(G, true);
                if (!T.filter(new o.F(this.tileID.overscaledZ), ce, this.tileID.canonical)) continue;
              } else if (!T.filter(new o.F(this.tileID.overscaledZ), G)) continue;
              const ee = u.getId(G, y), ue = new o.ac(G, M, D, F, ee);
              ue.tile = j, e.push(ue);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const s = this.expirationTime;
            if (e.cacheControl) {
              const u = o.ad(e.cacheControl);
              u["max-age"] && (this.expirationTime = Date.now() + 1e3 * u["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const u = Date.now();
              let m = false;
              if (this.expirationTime > u) m = false;
              else if (s) if (this.expirationTime < s) m = true;
              else {
                const y = this.expirationTime - s;
                y ? this.expirationTime = u + Math.max(y, 3e4) : m = true;
              }
              else m = true;
              m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, s) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const u = this.latestFeatureIndex.loadVTLayers();
            for (const m in this.buckets) {
              if (!s.style.hasLayer(m)) continue;
              const y = this.buckets[m], x = y.layers[0].sourceLayer || "_geojsonTileLayer", T = u[x], M = e[x];
              if (!T || !M || Object.keys(M).length === 0) continue;
              y.update(M, T, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const D = s && s.style && s.style.getLayer(m);
              D && (this.queryPadding = Math.max(this.queryPadding, D.queryRadius(y)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < z.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = z.now() + e;
          }
          setDependencies(e, s) {
            const u = {};
            for (const m of s) u[m] = true;
            this.dependencies[e] = u;
          }
          hasDependency(e, s) {
            for (const u of e) {
              const m = this.dependencies[u];
              if (m) {
                for (const y of s) if (m[y]) return true;
              }
            }
            return false;
          }
        }
        class Le {
          constructor(e, s) {
            this.max = e, this.onRemove = s, this.reset();
          }
          reset() {
            for (const e in this.data) for (const s of this.data[e]) s.timeout && clearTimeout(s.timeout), this.onRemove(s.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, s, u) {
            const m = e.wrapped().key;
            this.data[m] === void 0 && (this.data[m] = []);
            const y = { value: s, timeout: void 0 };
            if (u !== void 0 && (y.timeout = setTimeout((() => {
              this.remove(e, y);
            }), u)), this.data[m].push(y), this.order.push(m), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const s = this.data[e].shift();
            return s.timeout && clearTimeout(s.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), s.value;
          }
          getByKey(e) {
            const s = this.data[e];
            return s ? s[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, s) {
            if (!this.has(e)) return this;
            const u = e.wrapped().key, m = s === void 0 ? 0 : this.data[u].indexOf(s), y = this.data[u][m];
            return this.data[u].splice(m, 1), y.timeout && clearTimeout(y.timeout), this.data[u].length === 0 && delete this.data[u], this.onRemove(y.value), this.order.splice(this.order.indexOf(u), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const s = this._getAndRemoveByKey(this.order[0]);
              s && this.onRemove(s);
            }
            return this;
          }
          filter(e) {
            const s = [];
            for (const u in this.data) for (const m of this.data[u]) e(m.value) || s.push(m);
            for (const u of s) this.remove(u.value.tileID, u);
          }
        }
        class re {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, s, u) {
            const m = String(s);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][m] = this.stateChanges[e][m] || {}, o.e(this.stateChanges[e][m], u), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const y in this.state[e]) y !== m && (this.deletedStates[e][y] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][m] === null) {
              this.deletedStates[e][m] = {};
              for (const y in this.state[e][m]) u[y] || (this.deletedStates[e][m][y] = null);
            } else for (const y in u) this.deletedStates[e] && this.deletedStates[e][m] && this.deletedStates[e][m][y] === null && delete this.deletedStates[e][m][y];
          }
          removeFeatureState(e, s, u) {
            if (this.deletedStates[e] === null) return;
            const m = String(s);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, u && s !== void 0) this.deletedStates[e][m] !== null && (this.deletedStates[e][m] = this.deletedStates[e][m] || {}, this.deletedStates[e][m][u] = null);
            else if (s !== void 0) if (this.stateChanges[e] && this.stateChanges[e][m]) for (u in this.deletedStates[e][m] = {}, this.stateChanges[e][m]) this.deletedStates[e][m][u] = null;
            else this.deletedStates[e][m] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, s) {
            const u = String(s), m = o.e({}, (this.state[e] || {})[u], (this.stateChanges[e] || {})[u]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const y = this.deletedStates[e][s];
              if (y === null) return {};
              for (const x in y) delete m[x];
            }
            return m;
          }
          initializeTileState(e, s) {
            e.setFeatureState(this.state, s);
          }
          coalesceChanges(e, s) {
            const u = {};
            for (const m in this.stateChanges) {
              this.state[m] = this.state[m] || {};
              const y = {};
              for (const x in this.stateChanges[m]) this.state[m][x] || (this.state[m][x] = {}), o.e(this.state[m][x], this.stateChanges[m][x]), y[x] = this.state[m][x];
              u[m] = y;
            }
            for (const m in this.deletedStates) {
              this.state[m] = this.state[m] || {};
              const y = {};
              if (this.deletedStates[m] === null) for (const x in this.state[m]) y[x] = {}, this.state[m][x] = {};
              else for (const x in this.deletedStates[m]) {
                if (this.deletedStates[m][x] === null) this.state[m][x] = {};
                else for (const T of Object.keys(this.deletedStates[m][x])) delete this.state[m][x][T];
                y[x] = this.state[m][x];
              }
              u[m] = u[m] || {}, o.e(u[m], y);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(u).length !== 0) for (const m in e) e[m].setFeatureState(u, s);
          }
        }
        const ne = 89.25;
        function ae(v, e) {
          const s = o.ah(e.lat, -o.ai, o.ai);
          return new o.P(o.V(e.lng) * v, o.U(s) * v);
        }
        function be(v, e) {
          return new o.a1(e.x / v, e.y / v).toLngLat();
        }
        function Ie(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(o.ae(90 - v.pitch)), Math.tan(o.ae(ne - v.pitch)));
        }
        function Fe(v, e) {
          const s = v.canonical, u = e / o.af(s.z), m = s.x + Math.pow(2, s.z) * v.wrap, y = o.ag(new Float64Array(16));
          return o.M(y, y, [m * u, s.y * u, 0]), o.N(y, y, [u / o.$, u / o.$, 1]), y;
        }
        function fe(v, e, s, u, m) {
          const y = o.a1.fromLngLat(v, e), x = m * o.aj(1, v.lat), T = x * Math.cos(o.ae(s)), M = Math.sqrt(x * x - T * T), D = M * Math.sin(o.ae(-u)), F = M * Math.cos(o.ae(-u));
          return new o.a1(y.x + D, y.y + F, y.z + T);
        }
        function _e(v, e, s) {
          const u = e.intersectsFrustum(v);
          if (!s || u === 0) return u;
          const m = e.intersectsPlane(s);
          return m === 0 ? 0 : u === 2 && m === 2 ? 2 : 1;
        }
        function Ve(v, e, s) {
          let u = 0;
          const m = (s - e) / 10;
          for (let y = 0; y < 10; y++) u += m * Math.pow(Math.cos(e + (y + 0.5) / 10 * (s - e)), v);
          return u;
        }
        function nt(v, e) {
          return function(s, u, m, y, x) {
            const T = 2 * ((v - 1) / o.ak(Math.cos(o.ae(ne - x)) / Math.cos(o.ae(ne))) - 1), M = Math.acos(m / y), D = 2 * Ve(T - 1, 0, o.ae(x / 2)), F = Math.min(o.ae(ne), M + o.ae(x / 2)), j = Ve(T - 1, Math.min(F, M - o.ae(x / 2)), F), $ = Math.atan(u / m), G = Math.hypot(u, m);
            let ee = s;
            return ee += o.ak(y / G / Math.max(0.5, Math.cos(o.ae(x / 2)))), ee += T * o.ak(Math.cos($)) / 2, ee -= o.ak(Math.max(1, j / D / e)) / 2, ee;
          };
        }
        const Xe = nt(9.314, 3);
        function wt(v, e) {
          const s = (e.roundZoom ? Math.round : Math.floor)(v.zoom + o.ak(v.tileSize / e.tileSize));
          return Math.max(0, s);
        }
        function Te(v, e) {
          const s = v.getCameraFrustum(), u = v.getClippingPlane(), m = v.screenPointToMercatorCoordinate(v.getCameraPoint()), y = o.a1.fromLngLat(v.center, v.elevation);
          m.z = y.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const x = v.getCoveringTilesDetailsProvider(), T = x.allowVariableZoom(v, e), M = wt(v, e), D = e.minzoom || 0, F = e.maxzoom !== void 0 ? e.maxzoom : v.maxZoom, j = Math.min(Math.max(0, M), F), $ = Math.pow(2, j), G = [$ * m.x, $ * m.y, 0], ee = [$ * y.x, $ * y.y, 0], ue = Math.hypot(y.x - m.x, y.y - m.y), ce = Math.abs(y.z - m.z), pe = Math.hypot(ue, ce), ge = (ke) => ({ zoom: 0, x: 0, y: 0, wrap: ke, fullyVisible: false }), Ce = [], xe = [];
          if (v.renderWorldCopies && x.allowWorldCopies()) for (let ke = 1; ke <= 3; ke++) Ce.push(ge(-ke)), Ce.push(ge(ke));
          for (Ce.push(ge(0)); Ce.length > 0; ) {
            const ke = Ce.pop(), ze = ke.x, we = ke.y;
            let je = ke.fullyVisible;
            const Qe = { x: ze, y: we, z: ke.zoom }, qe = x.getTileBoundingVolume(Qe, ke.wrap, v.elevation, e);
            if (!je) {
              const It = _e(s, qe, u);
              if (It === 0) continue;
              je = It === 2;
            }
            const Ze = x.distanceToTile2d(m.x, m.y, Qe, qe);
            let Je = M;
            T && (Je = (e.calculateTileZoom || Xe)(v.zoom + o.ak(v.tileSize / e.tileSize), Ze, ce, pe, v.fov)), Je = (e.roundZoom ? Math.round : Math.floor)(Je), Je = Math.max(0, Je);
            const Tt = Math.min(Je, F);
            if (ke.wrap = x.getWrap(y, Qe, ke.wrap), ke.zoom >= Tt) {
              if (ke.zoom < D) continue;
              const It = j - ke.zoom, ft = G[0] - 0.5 - (ze << It), Zt = G[1] - 0.5 - (we << It), xr = e.reparseOverscaled ? Math.max(ke.zoom, Je) : ke.zoom;
              xe.push({ tileID: new o.Z(ke.zoom === F ? xr : ke.zoom, ke.wrap, ke.zoom, ze, we), distanceSq: o.al([ee[0] - 0.5 - ze, ee[1] - 0.5 - we]), tileDistanceToCamera: Math.sqrt(ft * ft + Zt * Zt) });
            } else for (let It = 0; It < 4; It++) Ce.push({ zoom: ke.zoom + 1, x: (ze << 1) + It % 2, y: (we << 1) + (It >> 1), wrap: ke.wrap, fullyVisible: je });
          }
          return xe.sort(((ke, ze) => ke.distanceSq - ze.distanceSq)).map(((ke) => ke.tileID));
        }
        const Ut = o.a2.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class or extends o.E {
          constructor(e, s, u) {
            super(), this.id = e, this.dispatcher = u, this.on("data", ((m) => this._dataHandler(m))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((m, y, x, T) => {
              const M = new (Et(y.type))(m, y, x, T);
              if (M.id !== m) throw new Error(`Expected Source id to be ${m} instead of ${M.id}`);
              return M;
            })(e, s, u, this), this._tiles = {}, this._cache = new Le(0, ((m) => this._unloadTile(m))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new re(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e in this._tiles) {
              const s = this._tiles[e];
              if (s.state !== "loaded" && s.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, s, u) {
            return o._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, s, u);
              } catch (m) {
                e.state = "errored", m.status !== 404 ? this._source.fire(new o.k(m, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new o.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const s in this._tiles) {
              const u = this._tiles[s];
              u.upload(e), u.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(Wt).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const s = [];
            for (const u in this._tiles) this._isIdRenderable(u, e) && s.push(this._tiles[u]);
            return e ? s.sort(((u, m) => {
              const y = u.tileID, x = m.tileID, T = new o.P(y.canonical.x, y.canonical.y)._rotate(-this.transform.bearingInRadians), M = new o.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return y.overscaledZ - x.overscaledZ || M.y - T.y || M.x - T.x;
            })).map(((u) => u.tileID.key)) : s.map(((u) => u.tileID)).sort(Wt).map(((u) => u.key));
          }
          hasRenderableParent(e) {
            const s = this.findLoadedParent(e, 0);
            return !!s && this._isIdRenderable(s.tileID.key);
          }
          _isIdRenderable(e, s) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (s || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const s in this._tiles) e ? this._reloadTile(s, "expired") : this._tiles[s].state !== "errored" && this._reloadTile(s, "reloading");
            }
          }
          _reloadTile(e, s) {
            return o._(this, void 0, void 0, (function* () {
              const u = this._tiles[e];
              u && (u.state !== "loading" && (u.state = s), yield this._loadTile(u, e, s));
            }));
          }
          _tileLoaded(e, s, u) {
            e.timeAdded = z.now(), u === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(s, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new o.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const s = this.getRenderableIds();
            for (let m = 0; m < s.length; m++) {
              const y = s[m];
              if (e.neighboringTiles && e.neighboringTiles[y]) {
                const x = this.getTileByID(y);
                u(e, x), u(x, e);
              }
            }
            function u(m, y) {
              m.needsHillshadePrepare = true, m.needsTerrainPrepare = true;
              let x = y.tileID.canonical.x - m.tileID.canonical.x;
              const T = y.tileID.canonical.y - m.tileID.canonical.y, M = Math.pow(2, m.tileID.canonical.z), D = y.tileID.key;
              x === 0 && T === 0 || Math.abs(T) > 1 || (Math.abs(x) > 1 && (Math.abs(x + M) === 1 ? x += M : Math.abs(x - M) === 1 && (x -= M)), y.dem && m.dem && (m.dem.backfillBorder(y.dem, x, T), m.neighboringTiles && m.neighboringTiles[D] && (m.neighboringTiles[D].backfilled = true)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, s, u, m) {
            for (const y in this._tiles) {
              let x = this._tiles[y];
              if (m[y] || !x.hasData() || x.tileID.overscaledZ <= s || x.tileID.overscaledZ > u) continue;
              let T = x.tileID;
              for (; x && x.tileID.overscaledZ > s + 1; ) {
                const D = x.tileID.scaledTo(x.tileID.overscaledZ - 1);
                x = this._tiles[D.key], x && x.hasData() && (T = D);
              }
              let M = T;
              for (; M.overscaledZ > s; ) if (M = M.scaledTo(M.overscaledZ - 1), e[M.key] || e[M.canonical.key]) {
                m[T.key] = T;
                break;
              }
            }
          }
          findLoadedParent(e, s) {
            if (e.key in this._loadedParentTiles) {
              const u = this._loadedParentTiles[e.key];
              return u && u.tileID.overscaledZ >= s ? u : null;
            }
            for (let u = e.overscaledZ - 1; u >= s; u--) {
              const m = e.scaledTo(u), y = this._getLoadedTile(m);
              if (y) return y;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const s = this._tiles[e.key];
            return s && s.hasData() ? s : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const s = Math.ceil(e.width / this._source.tileSize) + 1, u = Math.ceil(e.height / this._source.tileSize) + 1, m = Math.floor(s * u * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), y = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, m) : m;
            this._cache.setMaxSize(y);
          }
          handleWrapJump(e) {
            const s = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, s) {
              const u = {};
              for (const m in this._tiles) {
                const y = this._tiles[m];
                y.tileID = y.tileID.unwrapTo(y.tileID.wrap + s), u[y.tileID.key] = y;
              }
              this._tiles = u;
              for (const m in this._timers) clearTimeout(this._timers[m]), delete this._timers[m];
              for (const m in this._tiles) this._setTileReloadTimer(m, this._tiles[m]);
            }
          }
          _updateCoveredAndRetainedTiles(e, s, u, m, y, x) {
            const T = {}, M = {}, D = Object.keys(e), F = z.now();
            for (const j of D) {
              const $ = e[j], G = this._tiles[j];
              if (!G || G.fadeEndTime !== 0 && G.fadeEndTime <= F) continue;
              const ee = this.findLoadedParent($, s), ue = this.findLoadedSibling($), ce = ee || ue || null;
              ce && (this._addTile(ce.tileID), T[ce.tileID.key] = ce.tileID), M[j] = $;
            }
            this._retainLoadedChildren(M, m, u, e);
            for (const j in T) e[j] || (this._coveredTiles[j] = true, e[j] = T[j]);
            if (x) {
              const j = {}, $ = {};
              for (const G of y) this._tiles[G.key].hasData() ? j[G.key] = G : $[G.key] = G;
              for (const G in $) {
                const ee = $[G].children(this._source.maxzoom);
                this._tiles[ee[0].key] && this._tiles[ee[1].key] && this._tiles[ee[2].key] && this._tiles[ee[3].key] && (j[ee[0].key] = e[ee[0].key] = ee[0], j[ee[1].key] = e[ee[1].key] = ee[1], j[ee[2].key] = e[ee[2].key] = ee[2], j[ee[3].key] = e[ee[3].key] = ee[3], delete $[G]);
              }
              for (const G in $) {
                const ee = $[G], ue = this.findLoadedParent(ee, this._source.minzoom), ce = this.findLoadedSibling(ee), pe = ue || ce || null;
                if (pe) {
                  j[pe.tileID.key] = e[pe.tileID.key] = pe.tileID;
                  for (const ge in j) j[ge].isChildOf(pe.tileID) && delete j[ge];
                }
              }
              for (const G in this._tiles) j[G] || (this._coveredTiles[G] = true);
            }
          }
          update(e, s) {
            if (!this._sourceLoaded || this._paused) return;
            let u;
            this.transform = e, this.terrain = s, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? u = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((F) => new o.Z(F.canonical.z, F.wrap, F.canonical.z, F.canonical.x, F.canonical.y))) : (u = Te(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: s, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (u = u.filter(((F) => this._source.hasTile(F))))) : u = [];
            const m = wt(e, this._source), y = Math.max(m - or.maxOverzooming, this._source.minzoom), x = Math.max(m + or.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const F = {};
              for (const j of u) if (j.canonical.z > this._source.minzoom) {
                const $ = j.scaledTo(j.canonical.z - 1);
                F[$.key] = $;
                const G = j.scaledTo(Math.max(this._source.minzoom, Math.min(j.canonical.z, 5)));
                F[G.key] = G;
              }
              u = u.concat(Object.values(F));
            }
            const T = u.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, T && this.fire(new o.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const M = this._updateRetainedTiles(u, m);
            dr(this._source.type) && this._updateCoveredAndRetainedTiles(M, y, x, m, u, s);
            for (const F in M) this._tiles[F].clearFadeHold();
            const D = o.am(this._tiles, M);
            for (const F of D) {
              const j = this._tiles[F];
              j.hasSymbolBuckets && !j.holdingForFade() ? j.setHoldDuration(this.map._fadeDuration) : j.hasSymbolBuckets && !j.symbolFadeFinished() || this._removeTile(F);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, s) {
            var u;
            const m = {}, y = {}, x = Math.max(s - or.maxOverzooming, this._source.minzoom), T = Math.max(s + or.maxUnderzooming, this._source.minzoom), M = {};
            for (const D of e) {
              const F = this._addTile(D);
              m[D.key] = D, F.hasData() || s < this._source.maxzoom && (M[D.key] = D);
            }
            this._retainLoadedChildren(M, s, T, m);
            for (const D of e) {
              let F = this._tiles[D.key];
              if (F.hasData()) continue;
              if (s + 1 > this._source.maxzoom) {
                const $ = D.children(this._source.maxzoom)[0], G = this.getTile($);
                if (G && G.hasData()) {
                  m[$.key] = $;
                  continue;
                }
              } else {
                const $ = D.children(this._source.maxzoom);
                if (m[$[0].key] && m[$[1].key] && m[$[2].key] && m[$[3].key]) continue;
              }
              let j = F.wasRequested();
              for (let $ = D.overscaledZ - 1; $ >= x; --$) {
                const G = D.scaledTo($);
                if (y[G.key]) break;
                if (y[G.key] = true, F = this.getTile(G), !F && j && (F = this._addTile(G)), F) {
                  const ee = F.hasData();
                  if ((ee || !(!((u = this.map) === null || u === void 0) && u.cancelPendingTileRequestsWhileZooming) || j) && (m[G.key] = G), j = F.wasRequested(), ee) break;
                }
              }
            }
            return m;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const s = [];
              let u, m = this._tiles[e].tileID;
              for (; m.overscaledZ > 0; ) {
                if (m.key in this._loadedParentTiles) {
                  u = this._loadedParentTiles[m.key];
                  break;
                }
                s.push(m.key);
                const y = m.scaledTo(m.overscaledZ - 1);
                if (u = this._getLoadedTile(y), u) break;
                m = y;
              }
              for (const y of s) this._loadedParentTiles[y] = u;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const s = this._tiles[e].tileID, u = this._getLoadedTile(s);
              this._loadedSiblingTiles[s.key] = u;
            }
          }
          _addTile(e) {
            let s = this._tiles[e.key];
            if (s) return s;
            s = this._cache.getAndRemove(e), s && (this._setTileReloadTimer(e.key, s), s.tileID = e, this._state.initializeTileState(s, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, s)));
            const u = s;
            return s || (s = new Sn(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(s, e.key, s.state)), s.uses++, this._tiles[e.key] = s, u || this._source.fire(new o.l("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s;
          }
          _setTileReloadTimer(e, s) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const u = s.getExpiryTimeout();
            u && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), u));
          }
          refreshTiles(e) {
            for (const s in this._tiles) (this._isIdRenderable(s) || this._tiles[s].state == "errored") && e.some(((u) => u.equals(this._tiles[s].tileID.canonical))) && this._reloadTile(s, "expired");
          }
          _removeTile(e) {
            const s = this._tiles[e];
            s && (s.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), s.uses > 0 || (s.hasData() && s.state !== "reloading" ? this._cache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = true, this._abortTile(s), this._unloadTile(s))));
          }
          _dataHandler(e) {
            const s = e.sourceDataType;
            e.dataType === "source" && s === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && s === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, s, u) {
            const m = [], y = this.transform;
            if (!y) return m;
            const x = y.getCoveringTilesDetailsProvider().allowWorldCopies(), T = u ? y.getCameraQueryGeometry(e) : e, M = (G) => y.screenPointToMercatorCoordinate(G, this.terrain), D = this.transformBbox(e, M, !x), F = this.transformBbox(T, M, !x), j = this.getIds(), $ = o.a2.fromPoints(F);
            for (let G = 0; G < j.length; G++) {
              const ee = this._tiles[j[G]];
              if (ee.holdingForFade()) continue;
              const ue = x ? [ee.tileID] : [ee.tileID.unwrapTo(-1), ee.tileID.unwrapTo(0)], ce = Math.pow(2, y.zoom - ee.tileID.overscaledZ), pe = s * ee.queryPadding * o.$ / ee.tileSize / ce;
              for (const ge of ue) {
                const Ce = $.map(((xe) => ge.getTilePoint(new o.a1(xe.x, xe.y))));
                if (Ce.expandBy(pe), Ce.intersects(Ut)) {
                  const xe = D.map(((ze) => ge.getTilePoint(ze))), ke = F.map(((ze) => ge.getTilePoint(ze)));
                  m.push({ tile: ee, tileID: x ? ge : ge.unwrapTo(0), queryGeometry: xe, cameraQueryGeometry: ke, scale: ce });
                }
              }
            }
            return m;
          }
          transformBbox(e, s, u) {
            let m = e.map(s);
            if (u) {
              const y = o.a2.fromPoints(e);
              y.shrinkBy(1e-3 * Math.min(y.width(), y.height()));
              const x = y.map(s);
              o.a2.fromPoints(m).covers(x) || (m = m.map(((T) => T.x > 0.5 ? new o.a1(T.x - 1, T.y, T.z) : T)));
            }
            return m;
          }
          getVisibleCoordinates(e) {
            const s = this.getRenderableIds(e).map(((u) => this._tiles[u].tileID));
            return this.transform && this.transform.populateCache(s), s;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (dr(this._source.type)) {
              const e = z.now();
              for (const s in this._tiles) if (this._tiles[s].fadeEndTime >= e) return true;
            }
            return false;
          }
          setFeatureState(e, s, u) {
            this._state.updateState(e = e || "_geojsonTileLayer", s, u);
          }
          removeFeatureState(e, s, u) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", s, u);
          }
          getFeatureState(e, s) {
            return this._state.getState(e = e || "_geojsonTileLayer", s);
          }
          setDependencies(e, s, u) {
            const m = this._tiles[e];
            m && m.setDependencies(s, u);
          }
          reloadTilesForDependencies(e, s) {
            for (const u in this._tiles) this._tiles[u].hasDependency(e, s) && this._reloadTile(u, "reloading");
            this._cache.filter(((u) => !u.hasDependency(e, s)));
          }
        }
        function Wt(v, e) {
          const s = Math.abs(2 * v.wrap) - +(v.wrap < 0), u = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return v.overscaledZ - e.overscaledZ || u - s || e.canonical.y - v.canonical.y || e.canonical.x - v.canonical.x;
        }
        function dr(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        or.maxOverzooming = 10, or.maxUnderzooming = 3;
        class Or {
          constructor(e, s) {
            this.reset(e, s);
          }
          reset(e, s) {
            this.points = e || [], this._distances = [0];
            for (let u = 1; u < this.points.length; u++) this._distances[u] = this._distances[u - 1] + this.points[u].dist(this.points[u - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = o.ah(e, 0, 1);
            let s = 1, u = this._distances[s];
            const m = e * this.paddedLength + this.padding;
            for (; u < m && s < this._distances.length; ) u = this._distances[++s];
            const y = s - 1, x = this._distances[y], T = u - x, M = T > 0 ? (m - x) / T : 0;
            return this.points[y].mult(1 - M).add(this.points[s].mult(M));
          }
        }
        function Qr(v, e) {
          let s = true;
          return v === "always" || v !== "never" && e !== "never" || (s = false), s;
        }
        class en {
          constructor(e, s, u) {
            const m = this.boxCells = [], y = this.circleCells = [];
            this.xCellCount = Math.ceil(e / u), this.yCellCount = Math.ceil(s / u);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) m.push([]), y.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = s, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, s, u, m, y) {
            this._forEachCell(s, u, m, y, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(s), this.bboxes.push(u), this.bboxes.push(m), this.bboxes.push(y);
          }
          insertCircle(e, s, u, m) {
            this._forEachCell(s - m, u - m, s + m, u + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(s), this.circles.push(u), this.circles.push(m);
          }
          _insertBoxCell(e, s, u, m, y, x) {
            this.boxCells[y].push(x);
          }
          _insertCircleCell(e, s, u, m, y, x) {
            this.circleCells[y].push(x);
          }
          _query(e, s, u, m, y, x, T) {
            if (u < 0 || e > this.width || m < 0 || s > this.height) return [];
            const M = [];
            if (e <= 0 && s <= 0 && this.width <= u && this.height <= m) {
              if (y) return [{ key: null, x1: e, y1: s, x2: u, y2: m }];
              for (let D = 0; D < this.boxKeys.length; D++) M.push({ key: this.boxKeys[D], x1: this.bboxes[4 * D], y1: this.bboxes[4 * D + 1], x2: this.bboxes[4 * D + 2], y2: this.bboxes[4 * D + 3] });
              for (let D = 0; D < this.circleKeys.length; D++) {
                const F = this.circles[3 * D], j = this.circles[3 * D + 1], $ = this.circles[3 * D + 2];
                M.push({ key: this.circleKeys[D], x1: F - $, y1: j - $, x2: F + $, y2: j + $ });
              }
            } else this._forEachCell(e, s, u, m, this._queryCell, M, { hitTest: y, overlapMode: x, seenUids: { box: {}, circle: {} } }, T);
            return M;
          }
          query(e, s, u, m) {
            return this._query(e, s, u, m, false, null);
          }
          hitTest(e, s, u, m, y, x) {
            return this._query(e, s, u, m, true, y, x).length > 0;
          }
          hitTestCircle(e, s, u, m, y) {
            const x = e - u, T = e + u, M = s - u, D = s + u;
            if (T < 0 || x > this.width || D < 0 || M > this.height) return false;
            const F = [];
            return this._forEachCell(x, M, T, D, this._queryCellCircle, F, { hitTest: true, overlapMode: m, circle: { x: e, y: s, radius: u }, seenUids: { box: {}, circle: {} } }, y), F.length > 0;
          }
          _queryCell(e, s, u, m, y, x, T, M) {
            const { seenUids: D, hitTest: F, overlapMode: j } = T, $ = this.boxCells[y];
            if ($ !== null) {
              const ee = this.bboxes;
              for (const ue of $) if (!D.box[ue]) {
                D.box[ue] = true;
                const ce = 4 * ue, pe = this.boxKeys[ue];
                if (e <= ee[ce + 2] && s <= ee[ce + 3] && u >= ee[ce + 0] && m >= ee[ce + 1] && (!M || M(pe)) && (!F || !Qr(j, pe.overlapMode)) && (x.push({ key: pe, x1: ee[ce], y1: ee[ce + 1], x2: ee[ce + 2], y2: ee[ce + 3] }), F)) return true;
              }
            }
            const G = this.circleCells[y];
            if (G !== null) {
              const ee = this.circles;
              for (const ue of G) if (!D.circle[ue]) {
                D.circle[ue] = true;
                const ce = 3 * ue, pe = this.circleKeys[ue];
                if (this._circleAndRectCollide(ee[ce], ee[ce + 1], ee[ce + 2], e, s, u, m) && (!M || M(pe)) && (!F || !Qr(j, pe.overlapMode))) {
                  const ge = ee[ce], Ce = ee[ce + 1], xe = ee[ce + 2];
                  if (x.push({ key: pe, x1: ge - xe, y1: Ce - xe, x2: ge + xe, y2: Ce + xe }), F) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e, s, u, m, y, x, T, M) {
            const { circle: D, seenUids: F, overlapMode: j } = T, $ = this.boxCells[y];
            if ($ !== null) {
              const ee = this.bboxes;
              for (const ue of $) if (!F.box[ue]) {
                F.box[ue] = true;
                const ce = 4 * ue, pe = this.boxKeys[ue];
                if (this._circleAndRectCollide(D.x, D.y, D.radius, ee[ce + 0], ee[ce + 1], ee[ce + 2], ee[ce + 3]) && (!M || M(pe)) && !Qr(j, pe.overlapMode)) return x.push(true), true;
              }
            }
            const G = this.circleCells[y];
            if (G !== null) {
              const ee = this.circles;
              for (const ue of G) if (!F.circle[ue]) {
                F.circle[ue] = true;
                const ce = 3 * ue, pe = this.circleKeys[ue];
                if (this._circlesCollide(ee[ce], ee[ce + 1], ee[ce + 2], D.x, D.y, D.radius) && (!M || M(pe)) && !Qr(j, pe.overlapMode)) return x.push(true), true;
              }
            }
          }
          _forEachCell(e, s, u, m, y, x, T, M) {
            const D = this._convertToXCellCoord(e), F = this._convertToYCellCoord(s), j = this._convertToXCellCoord(u), $ = this._convertToYCellCoord(m);
            for (let G = D; G <= j; G++) for (let ee = F; ee <= $; ee++) if (y.call(this, e, s, u, m, this.xCellCount * ee + G, x, T, M)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, s, u, m, y, x) {
            const T = m - e, M = y - s, D = u + x;
            return D * D > T * T + M * M;
          }
          _circleAndRectCollide(e, s, u, m, y, x, T) {
            const M = (x - m) / 2, D = Math.abs(e - (m + M));
            if (D > M + u) return false;
            const F = (T - y) / 2, j = Math.abs(s - (y + F));
            if (j > F + u) return false;
            if (D <= M || j <= F) return true;
            const $ = D - M, G = j - F;
            return $ * $ + G * G <= u * u;
          }
        }
        function sn(v, e, s) {
          const u = o.L();
          if (!v) {
            const { vecSouth: j, vecEast: $ } = wr(e), G = S();
            G[0] = $[0], G[1] = $[1], G[2] = j[0], G[3] = j[1], m = G, (F = (x = (y = G)[0]) * (D = y[3]) - (M = y[2]) * (T = y[1])) && (m[0] = D * (F = 1 / F), m[1] = -T * F, m[2] = -M * F, m[3] = x * F), u[0] = G[0], u[1] = G[1], u[4] = G[2], u[5] = G[3];
          }
          var m, y, x, T, M, D, F;
          return o.N(u, u, [1 / s, 1 / s, 1]), u;
        }
        function _r(v, e, s, u) {
          if (v) {
            const m = o.L();
            if (!e) {
              const { vecSouth: y, vecEast: x } = wr(s);
              m[0] = x[0], m[1] = x[1], m[4] = y[0], m[5] = y[1];
            }
            return o.N(m, m, [u, u, 1]), m;
          }
          return s.pixelsToClipSpaceMatrix;
        }
        function wr(v) {
          const e = Math.cos(v.rollInRadians), s = Math.sin(v.rollInRadians), u = Math.cos(v.pitchInRadians), m = Math.cos(v.bearingInRadians), y = Math.sin(v.bearingInRadians), x = o.ar();
          x[0] = -m * u * s - y * e, x[1] = -y * u * s + m * e;
          const T = o.as(x);
          T < 1e-9 ? o.at(x) : o.au(x, x, 1 / T);
          const M = o.ar();
          M[0] = m * u * e - y * s, M[1] = y * u * e + m * s;
          const D = o.as(M);
          return D < 1e-9 ? o.at(M) : o.au(M, M, 1 / D), { vecEast: M, vecSouth: x };
        }
        function Hr(v, e, s, u) {
          let m;
          u ? (m = [v, e, u(v, e), 1], o.aw(m, m, s)) : (m = [v, e, 0, 1], xo(m, m, s));
          const y = m[3];
          return { point: new o.P(m[0] / y, m[1] / y), signedDistanceFromCamera: y, isOccluded: false };
        }
        function ye(v, e) {
          return 0.5 + v / e * 0.5;
        }
        function pt(v, e) {
          return v.x >= -e[0] && v.x <= e[0] && v.y >= -e[1] && v.y <= e[1];
        }
        function Vt(v, e, s, u, m, y, x, T, M, D, F, j, $) {
          const G = s ? v.textSizeData : v.iconSizeData, ee = o.an(G, e.transform.zoom), ue = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], ce = s ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          ce.clear();
          const pe = v.lineVertexArray, ge = s ? v.text.placedSymbolArray : v.icon.placedSymbolArray, Ce = e.transform.width / e.transform.height;
          let xe = false;
          for (let ke = 0; ke < ge.length; ke++) {
            const ze = ge.get(ke);
            if (ze.hidden || ze.writingMode === o.ao.vertical && !xe) {
              Si(ze.numGlyphs, ce);
              continue;
            }
            xe = false;
            const we = new o.P(ze.anchorX, ze.anchorY), je = { getElevation: $, pitchedLabelPlaneMatrix: u, lineVertexArray: pe, pitchWithMap: y, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: we, unwrappedTileID: M, width: D, height: F, translation: j }, Qe = ni(ze.anchorX, ze.anchorY, je);
            if (!pt(Qe.point, ue)) {
              Si(ze.numGlyphs, ce);
              continue;
            }
            const qe = ye(e.transform.cameraToCenterDistance, Qe.signedDistanceFromCamera), Ze = o.ap(G, ee, ze), Je = y ? Ze * e.transform.getPitchedTextCorrection(ze.anchorX, ze.anchorY, M) / qe : Ze * qe, Tt = gt({ projectionContext: je, pitchedLabelPlaneMatrixInverse: m, symbol: ze, fontSize: Je, flip: false, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: ce, aspectRatio: Ce, rotateToLine: T });
            xe = Tt.useVertical, (Tt.notEnoughRoom || xe || Tt.needsFlipping && gt({ projectionContext: je, pitchedLabelPlaneMatrixInverse: m, symbol: ze, fontSize: Je, flip: true, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: ce, aspectRatio: Ce, rotateToLine: T }).notEnoughRoom) && Si(ze.numGlyphs, ce);
          }
          s ? v.text.dynamicLayoutVertexBuffer.updateData(ce) : v.icon.dynamicLayoutVertexBuffer.updateData(ce);
        }
        function Ar(v, e, s, u, m, y, x, T) {
          const M = y.glyphStartIndex + y.numGlyphs, D = y.lineStartIndex, F = y.lineStartIndex + y.lineLength, j = e.getoffsetX(y.glyphStartIndex), $ = e.getoffsetX(M - 1), G = qi(v * j, s, u, m, y.segment, D, F, T, x);
          if (!G) return null;
          const ee = qi(v * $, s, u, m, y.segment, D, F, T, x);
          return ee ? T.projectionCache.anyProjectionOccluded ? null : { first: G, last: ee } : null;
        }
        function Nr(v, e, s, u) {
          return v === o.ao.horizontal && Math.abs(s.y - e.y) > Math.abs(s.x - e.x) * u ? { useVertical: true } : (v === o.ao.vertical ? e.y < s.y : e.x > s.x) ? { needsFlipping: true } : null;
        }
        function gt(v) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: s, symbol: u, fontSize: m, flip: y, keepUpright: x, glyphOffsetArray: T, dynamicLayoutVertexArray: M, aspectRatio: D, rotateToLine: F } = v, j = m / 24, $ = u.lineOffsetX * j, G = u.lineOffsetY * j;
          let ee;
          if (u.numGlyphs > 1) {
            const ue = u.glyphStartIndex + u.numGlyphs, ce = u.lineStartIndex, pe = u.lineStartIndex + u.lineLength, ge = Ar(j, T, $, G, y, u, F, e);
            if (!ge) return { notEnoughRoom: true };
            const Ce = ci(ge.first.point.x, ge.first.point.y, e, s), xe = ci(ge.last.point.x, ge.last.point.y, e, s);
            if (x && !y) {
              const ke = Nr(u.writingMode, Ce, xe, D);
              if (ke) return ke;
            }
            ee = [ge.first];
            for (let ke = u.glyphStartIndex + 1; ke < ue - 1; ke++) {
              const ze = qi(j * T.getoffsetX(ke), $, G, y, u.segment, ce, pe, e, F);
              if (!ze) return { notEnoughRoom: true };
              ee.push(ze);
            }
            ee.push(ge.last);
          } else {
            if (x && !y) {
              const ce = an(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, pe = u.lineStartIndex + u.segment + 1, ge = new o.P(e.lineVertexArray.getx(pe), e.lineVertexArray.gety(pe)), Ce = an(ge.x, ge.y, e), xe = Ce.signedDistanceFromCamera > 0 ? Ce.point : pr(e.tileAnchorPoint, ge, ce, 1, e), ke = ci(ce.x, ce.y, e, s), ze = ci(xe.x, xe.y, e, s), we = Nr(u.writingMode, ke, ze, D);
              if (we) return we;
            }
            const ue = qi(j * T.getoffsetX(u.glyphStartIndex), $, G, y, u.segment, u.lineStartIndex, u.lineStartIndex + u.lineLength, e, F);
            if (!ue || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            ee = [ue];
          }
          for (const ue of ee) o.av(M, ue.point, ue.angle);
          return {};
        }
        function pr(v, e, s, u, m) {
          const y = v.add(v.sub(e)._unit()), x = an(y.x, y.y, m).point, T = s.sub(x);
          return s.add(T._mult(u / T.mag()));
        }
        function ur(v, e, s) {
          const u = e.projectionCache;
          if (u.projections[v]) return u.projections[v];
          const m = new o.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), y = an(m.x, m.y, e);
          if (y.signedDistanceFromCamera > 0) return u.projections[v] = y.point, u.anyProjectionOccluded = u.anyProjectionOccluded || y.isOccluded, y.point;
          const x = v - s.direction;
          return pr(s.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), m, s.previousVertex, s.absOffsetX - s.distanceFromAnchor + 1, e);
        }
        function an(v, e, s) {
          const u = v + s.translation[0], m = e + s.translation[1];
          let y;
          return s.pitchWithMap ? (y = Hr(u, m, s.pitchedLabelPlaneMatrix, s.getElevation), y.isOccluded = false) : (y = s.transform.projectTileCoordinates(u, m, s.unwrappedTileID, s.getElevation), y.point.x = (0.5 * y.point.x + 0.5) * s.width, y.point.y = (0.5 * -y.point.y + 0.5) * s.height), y;
        }
        function ci(v, e, s, u) {
          if (s.pitchWithMap) {
            const m = [v, e, 0, 1];
            return o.aw(m, m, u), s.transform.projectTileCoordinates(m[0] / m[3], m[1] / m[3], s.unwrappedTileID, s.getElevation).point;
          }
          return { x: v / s.width * 2 - 1, y: 1 - e / s.height * 2 };
        }
        function ni(v, e, s) {
          return s.transform.projectTileCoordinates(v, e, s.unwrappedTileID, s.getElevation);
        }
        function fr(v, e, s) {
          return v._unit()._perp()._mult(e * s);
        }
        function Ho(v, e, s, u, m, y, x, T, M) {
          if (T.projectionCache.offsets[v]) return T.projectionCache.offsets[v];
          const D = s.add(e);
          if (v + M.direction < u || v + M.direction >= m) return T.projectionCache.offsets[v] = D, D;
          const F = ur(v + M.direction, T, M), j = fr(F.sub(s), x, M.direction), $ = s.add(j), G = F.add(j);
          return T.projectionCache.offsets[v] = o.ax(y, D, $, G) || D, T.projectionCache.offsets[v];
        }
        function qi(v, e, s, u, m, y, x, T, M) {
          const D = u ? v - e : v + e;
          let F = D > 0 ? 1 : -1, j = 0;
          u && (F *= -1, j = Math.PI), F < 0 && (j += Math.PI);
          let $, G = F > 0 ? y + m : y + m + 1;
          T.projectionCache.cachedAnchorPoint ? $ = T.projectionCache.cachedAnchorPoint : ($ = an(T.tileAnchorPoint.x, T.tileAnchorPoint.y, T).point, T.projectionCache.cachedAnchorPoint = $);
          let ee, ue, ce = $, pe = $, ge = 0, Ce = 0;
          const xe = Math.abs(D), ke = [];
          let ze;
          for (; ge + Ce <= xe; ) {
            if (G += F, G < y || G >= x) return null;
            ge += Ce, pe = ce, ue = ee;
            const Qe = { absOffsetX: xe, direction: F, distanceFromAnchor: ge, previousVertex: pe };
            if (ce = ur(G, T, Qe), s === 0) ke.push(pe), ze = ce.sub(pe);
            else {
              let qe;
              const Ze = ce.sub(pe);
              qe = Ze.mag() === 0 ? fr(ur(G + F, T, Qe).sub(ce), s, F) : fr(Ze, s, F), ue || (ue = pe.add(qe)), ee = Ho(G, qe, ce, y, x, ue, s, T, Qe), ke.push(ue), ze = ee.sub(ue);
            }
            Ce = ze.mag();
          }
          const we = ze._mult((xe - ge) / Ce)._add(ue || pe), je = j + Math.atan2(ce.y - pe.y, ce.x - pe.x);
          return ke.push(we), { point: we, angle: M ? je : 0, path: ke };
        }
        const Xo = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Si(v, e) {
          for (let s = 0; s < v; s++) {
            const u = e.length;
            e.resize(u + 4), e.float32.set(Xo, 3 * u);
          }
        }
        function xo(v, e, s) {
          const u = e[0], m = e[1];
          return v[0] = s[0] * u + s[4] * m + s[12], v[1] = s[1] * u + s[5] * m + s[13], v[3] = s[3] * u + s[7] * m + s[15], v;
        }
        const Xr = 100;
        class Ji {
          constructor(e, s = new en(e.width + 200, e.height + 200, 25), u = new en(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = s, this.ignoredGrid = u, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Xr, this.screenBottomBoundary = e.height + Xr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, s, u, m, y, x, T, M, D, F, j, $) {
            const G = this.projectAndGetPerspectiveRatio(e.anchorPointX + M[0], e.anchorPointY + M[1], y, F, $), ee = u * G.perspectiveRatio;
            let ue;
            if (x || T) ue = this._projectCollisionBox(e, ee, m, y, x, T, M, G, F, j, $);
            else {
              const ze = G.x + (j ? j.x * ee : 0), we = G.y + (j ? j.y * ee : 0);
              ue = { allPointsOccluded: false, box: [ze + e.x1 * ee, we + e.y1 * ee, ze + e.x2 * ee, we + e.y2 * ee] };
            }
            const [ce, pe, ge, Ce] = ue.box, xe = x ? ue.allPointsOccluded : G.isOccluded;
            let ke = xe;
            return ke || (ke = G.perspectiveRatio < this.perspectiveRatioCutoff), ke || (ke = !this.isInsideGrid(ce, pe, ge, Ce)), ke || s !== "always" && this.grid.hitTest(ce, pe, ge, Ce, s, D) ? { box: [ce, pe, ge, Ce], placeable: false, offscreen: false, occluded: xe } : { box: [ce, pe, ge, Ce], placeable: true, offscreen: this.isOffscreen(ce, pe, ge, Ce), occluded: xe };
          }
          placeCollisionCircles(e, s, u, m, y, x, T, M, D, F, j, $, G, ee) {
            const ue = [], ce = new o.P(s.anchorX, s.anchorY), pe = this.getPerspectiveRatio(ce.x, ce.y, x, ee), ge = (D ? y * this.transform.getPitchedTextCorrection(s.anchorX, s.anchorY, x) / pe : y * pe) / o.aB, Ce = { getElevation: ee, pitchedLabelPlaneMatrix: T, lineVertexArray: u, pitchWithMap: D, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: ce, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: G }, xe = Ar(ge, m, s.lineOffsetX * ge, s.lineOffsetY * ge, false, s, false, Ce);
            let ke = false, ze = false, we = true;
            if (xe) {
              const je = 0.5 * j * pe + $, Qe = new o.P(-100, -100), qe = new o.P(this.screenRightBoundary, this.screenBottomBoundary), Ze = new Or(), Je = xe.first, Tt = xe.last;
              let It = [];
              for (let xr = Je.path.length - 1; xr >= 1; xr--) It.push(Je.path[xr]);
              for (let xr = 1; xr < Tt.path.length; xr++) It.push(Tt.path[xr]);
              const ft = 2.5 * je;
              if (D) {
                const xr = this.projectPathToScreenSpace(It, Ce);
                It = xr.some((($r) => $r.signedDistanceFromCamera <= 0)) ? [] : xr.map((($r) => $r.point));
              }
              let Zt = [];
              if (It.length > 0) {
                const xr = It[0].clone(), $r = It[0].clone();
                for (let Kr = 1; Kr < It.length; Kr++) xr.x = Math.min(xr.x, It[Kr].x), xr.y = Math.min(xr.y, It[Kr].y), $r.x = Math.max($r.x, It[Kr].x), $r.y = Math.max($r.y, It[Kr].y);
                Zt = xr.x >= Qe.x && $r.x <= qe.x && xr.y >= Qe.y && $r.y <= qe.y ? [It] : $r.x < Qe.x || xr.x > qe.x || $r.y < Qe.y || xr.y > qe.y ? [] : o.ay([It], Qe.x, Qe.y, qe.x, qe.y);
              }
              for (const xr of Zt) {
                Ze.reset(xr, 0.25 * je);
                let $r = 0;
                $r = Ze.length <= 0.5 * je ? 1 : Math.ceil(Ze.paddedLength / ft) + 1;
                for (let Kr = 0; Kr < $r; Kr++) {
                  const Wr = Kr / Math.max($r - 1, 1), fn = Ze.lerp(Wr), _n = fn.x + Xr, br = fn.y + Xr;
                  ue.push(_n, br, je, 0);
                  const Jr = _n - je, In = br - je, Fn = _n + je, Un = br + je;
                  if (we = we && this.isOffscreen(Jr, In, Fn, Un), ze = ze || this.isInsideGrid(Jr, In, Fn, Un), e !== "always" && this.grid.hitTestCircle(_n, br, je, e, F) && (ke = true, !M)) return { circles: [], offscreen: false, collisionDetected: ke };
                }
              }
            }
            return { circles: !M && ke || !ze || pe < this.perspectiveRatioCutoff ? [] : ue, offscreen: we, collisionDetected: ke };
          }
          projectPathToScreenSpace(e, s) {
            const u = (function(m, y) {
              const x = o.L();
              return o.aq(x, y.pitchedLabelPlaneMatrix), m.map(((T) => {
                const M = Hr(T.x, T.y, x, y.getElevation), D = y.transform.projectTileCoordinates(M.point.x, M.point.y, y.unwrappedTileID, y.getElevation);
                return D.point.x = (0.5 * D.point.x + 0.5) * y.width, D.point.y = (0.5 * -D.point.y + 0.5) * y.height, D;
              }));
            })(e, s);
            return (function(m) {
              let y = 0, x = 0, T = 0, M = 0;
              for (let D = 0; D < m.length; D++) m[D].isOccluded ? (T = D + 1, M = 0) : (M++, M > x && (x = M, y = T));
              return m.slice(y, y + x);
            })(u);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const s = [], u = new o.a2();
            for (const j of e) {
              const $ = new o.P(j.x + Xr, j.y + Xr);
              u.extend($), s.push($);
            }
            const { minX: m, minY: y, maxX: x, maxY: T } = u, M = this.grid.query(m, y, x, T).concat(this.ignoredGrid.query(m, y, x, T)), D = {}, F = {};
            for (const j of M) {
              const $ = j.key;
              if (D[$.bucketInstanceId] === void 0 && (D[$.bucketInstanceId] = {}), D[$.bucketInstanceId][$.featureIndex]) continue;
              const G = [new o.P(j.x1, j.y1), new o.P(j.x2, j.y1), new o.P(j.x2, j.y2), new o.P(j.x1, j.y2)];
              o.az(s, G) && (D[$.bucketInstanceId][$.featureIndex] = true, F[$.bucketInstanceId] === void 0 && (F[$.bucketInstanceId] = []), F[$.bucketInstanceId].push($.featureIndex));
            }
            return F;
          }
          insertCollisionBox(e, s, u, m, y, x) {
            (u ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: m, featureIndex: y, collisionGroupID: x, overlapMode: s }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, s, u, m, y, x) {
            const T = u ? this.ignoredGrid : this.grid, M = { bucketInstanceId: m, featureIndex: y, collisionGroupID: x, overlapMode: s };
            for (let D = 0; D < e.length; D += 4) T.insertCircle(M, e[D], e[D + 1], e[D + 2]);
          }
          projectAndGetPerspectiveRatio(e, s, u, m, y) {
            if (y) {
              let x;
              m ? (x = [e, s, m(e, s), 1], o.aw(x, x, y)) : (x = [e, s, 0, 1], xo(x, x, y));
              const T = x[3];
              return { x: (x[0] / T + 1) / 2 * this.transform.width + Xr, y: (-x[1] / T + 1) / 2 * this.transform.height + Xr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / T * 0.5, isOccluded: false, signedDistanceFromCamera: T };
            }
            {
              const x = this.transform.projectTileCoordinates(e, s, u, m);
              return { x: (x.point.x + 1) / 2 * this.transform.width + Xr, y: (1 - x.point.y) / 2 * this.transform.height + Xr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, s, u, m) {
            const y = this.transform.projectTileCoordinates(e, s, u, m);
            return 0.5 + this.transform.cameraToCenterDistance / y.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, s, u, m) {
            return u < Xr || e >= this.screenRightBoundary || m < Xr || s > this.screenBottomBoundary;
          }
          isInsideGrid(e, s, u, m) {
            return u >= 0 && e < this.gridRightBoundary && m >= 0 && s < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = o.ag([]);
            return o.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, s, u, m, y, x, T, M, D, F, j) {
            let $ = 1, G = 0, ee = 0, ue = 1;
            const ce = e.anchorPointX + T[0], pe = e.anchorPointY + T[1];
            if (x && !y) {
              const It = this.projectAndGetPerspectiveRatio(ce + 1, pe, m, D, j), ft = It.x - M.x, Zt = Math.atan((It.y - M.y) / ft) + (ft < 0 ? Math.PI : 0), xr = Math.sin(Zt), $r = Math.cos(Zt);
              $ = $r, G = xr, ee = -xr, ue = $r;
            } else if (!x && y) {
              const It = wr(this.transform);
              $ = It.vecEast[0], G = It.vecEast[1], ee = It.vecSouth[0], ue = It.vecSouth[1];
            }
            let ge = M.x, Ce = M.y, xe = s;
            y && (ge = ce, Ce = pe, xe = Math.pow(2, -(this.transform.zoom - u.overscaledZ)), xe *= this.transform.getPitchedTextCorrection(ce, pe, m), F || (xe *= o.ah(0.5 + M.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), F && (ge += $ * F.x * xe + ee * F.y * xe, Ce += G * F.x * xe + ue * F.y * xe);
            const ke = e.x1 * xe, ze = e.x2 * xe, we = (ke + ze) / 2, je = e.y1 * xe, Qe = e.y2 * xe, qe = (je + Qe) / 2, Ze = [{ offsetX: ke, offsetY: je }, { offsetX: we, offsetY: je }, { offsetX: ze, offsetY: je }, { offsetX: ze, offsetY: qe }, { offsetX: ze, offsetY: Qe }, { offsetX: we, offsetY: Qe }, { offsetX: ke, offsetY: Qe }, { offsetX: ke, offsetY: qe }];
            let Je = [];
            for (const { offsetX: It, offsetY: ft } of Ze) Je.push(new o.P(ge + $ * It + ee * ft, Ce + G * It + ue * ft));
            let Tt = false;
            if (y) {
              const It = Je.map(((ft) => this.projectAndGetPerspectiveRatio(ft.x, ft.y, m, D, j)));
              Tt = It.some(((ft) => !ft.isOccluded)), Je = It.map(((ft) => new o.P(ft.x, ft.y)));
            } else Tt = true;
            return { box: o.aA(Je), allPointsOccluded: !Tt };
          }
        }
        class ii {
          constructor(e, s, u, m) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? s : -s))) : m && u ? 1 : 0, this.placed = u;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Gr {
          constructor(e, s, u, m, y) {
            this.text = new ii(e ? e.text : null, s, u, y), this.icon = new ii(e ? e.icon : null, s, m, y);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Rl {
          constructor(e, s, u) {
            this.text = e, this.icon = s, this.skipFade = u;
          }
        }
        class ys {
          constructor(e, s, u, m, y) {
            this.bucketInstanceId = e, this.featureIndex = s, this.sourceLayerIndex = u, this.bucketIndex = m, this.tileID = y;
          }
        }
        class Ia {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const s = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: s, predicate: (u) => u.collisionGroupID === s };
            }
            return this.collisionGroups[e];
          }
        }
        function wo(v, e, s, u, m) {
          const { horizontalAlign: y, verticalAlign: x } = o.aH(v);
          return new o.P(-(y - 0.5) * e + u[0] * m, -(x - 0.5) * s + u[1] * m);
        }
        class Co {
          constructor(e, s, u, m, y) {
            this.transform = e.clone(), this.terrain = s, this.collisionIndex = new Ji(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = u, this.retainedQueryData = {}, this.collisionGroups = new Ia(m), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = y, y && (y.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const s = this.terrain;
            return s ? (u, m) => s.getElevation(e, u, m) : null;
          }
          getBucketParts(e, s, u, m) {
            const y = u.getBucket(s), x = u.latestFeatureIndex;
            if (!y || !x || s.id !== y.layerIds[0]) return;
            const T = u.collisionBoxArray, M = y.layers[0].layout, D = y.layers[0].paint, F = Math.pow(2, this.transform.zoom - u.tileID.overscaledZ), j = u.tileSize / o.$, $ = u.tileID.toUnwrapped(), G = M.get("text-rotation-alignment") === "map", ee = o.aC(u, 1, this.transform.zoom), ue = o.aD(this.collisionIndex.transform, u, D.get("text-translate"), D.get("text-translate-anchor")), ce = o.aD(this.collisionIndex.transform, u, D.get("icon-translate"), D.get("icon-translate-anchor")), pe = sn(G, this.transform, ee);
            this.retainedQueryData[y.bucketInstanceId] = new ys(y.bucketInstanceId, x, y.sourceLayerIndex, y.index, u.tileID);
            const ge = { bucket: y, layout: M, translationText: ue, translationIcon: ce, unwrappedTileID: $, pitchedLabelPlaneMatrix: pe, scale: F, textPixelRatio: j, holdingForFade: u.holdingForFade(), collisionBoxArray: T, partiallyEvaluatedTextSize: o.an(y.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(y.sourceID) };
            if (m) for (const Ce of y.sortKeyRanges) {
              const { sortKey: xe, symbolInstanceStart: ke, symbolInstanceEnd: ze } = Ce;
              e.push({ sortKey: xe, symbolInstanceStart: ke, symbolInstanceEnd: ze, parameters: ge });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: y.symbolInstances.length, parameters: ge });
          }
          attemptAnchorPlacement(e, s, u, m, y, x, T, M, D, F, j, $, G, ee, ue, ce, pe, ge, Ce, xe) {
            const ke = o.aE[e.textAnchor], ze = [e.textOffset0, e.textOffset1], we = wo(ke, u, m, ze, y), je = this.collisionIndex.placeCollisionBox(s, $, M, D, F, T, x, ce, j.predicate, Ce, we, xe);
            if ((!ge || this.collisionIndex.placeCollisionBox(ge, $, M, D, F, T, x, pe, j.predicate, Ce, we, xe).placeable) && je.placeable) {
              let Qe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[G.crossTileID] && this.prevPlacement.placements[G.crossTileID] && this.prevPlacement.placements[G.crossTileID].text && (Qe = this.prevPlacement.variableOffsets[G.crossTileID].anchor), G.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[G.crossTileID] = { textOffset: ze, width: u, height: m, anchor: ke, textBoxScale: y, prevAnchor: Qe }, this.markUsedJustification(ee, ke, G, ue), ee.allowVerticalPlacement && (this.markUsedOrientation(ee, ue, G), this.placedOrientations[G.crossTileID] = ue), { shift: we, placedGlyphBoxes: je };
            }
          }
          placeLayerBucketPart(e, s, u) {
            const { bucket: m, layout: y, translationText: x, translationIcon: T, unwrappedTileID: M, pitchedLabelPlaneMatrix: D, textPixelRatio: F, holdingForFade: j, collisionBoxArray: $, partiallyEvaluatedTextSize: G, collisionGroup: ee } = e.parameters, ue = y.get("text-optional"), ce = y.get("icon-optional"), pe = o.aF(y, "text-overlap", "text-allow-overlap"), ge = pe === "always", Ce = o.aF(y, "icon-overlap", "icon-allow-overlap"), xe = Ce === "always", ke = y.get("text-rotation-alignment") === "map", ze = y.get("text-pitch-alignment") === "map", we = y.get("icon-text-fit") !== "none", je = y.get("symbol-z-order") === "viewport-y", Qe = ge && (xe || !m.hasIconData() || ce), qe = xe && (ge || !m.hasTextData() || ue);
            !m.collisionArrays && $ && m.deserializeCollisionBoxes($);
            const Ze = this.retainedQueryData[m.bucketInstanceId].tileID, Je = this._getTerrainElevationFunc(Ze), Tt = this.transform.getFastPathSimpleProjectionMatrix(Ze), It = (ft, Zt, xr) => {
              var $r, Kr;
              if (s[ft.crossTileID]) return;
              if (j) return void (this.placements[ft.crossTileID] = new Rl(false, false, false));
              let Wr = false, fn = false, _n = true, br = null, Jr = { box: null, placeable: false, offscreen: null, occluded: false }, In = { placeable: false }, Fn = null, Un = null, fi = null, ao = 0, ns = 0, is = 0;
              Zt.textFeatureIndex ? ao = Zt.textFeatureIndex : ft.useRuntimeCollisionCircles && (ao = ft.featureIndex), Zt.verticalTextFeatureIndex && (ns = Zt.verticalTextFeatureIndex);
              const da = Zt.textBox;
              if (da) {
                const Ti = (En) => {
                  let Ln = o.ao.horizontal;
                  if (m.allowVerticalPlacement && !En && this.prevPlacement) {
                    const Hi = this.prevPlacement.placedOrientations[ft.crossTileID];
                    Hi && (this.placedOrientations[ft.crossTileID] = Hi, Ln = Hi, this.markUsedOrientation(m, Ln, ft));
                  }
                  return Ln;
                }, lo = (En, Ln) => {
                  if (m.allowVerticalPlacement && ft.numVerticalGlyphVertices > 0 && Zt.verticalTextBox) {
                    for (const Hi of m.writingModes) if (Hi === o.ao.vertical ? (Jr = Ln(), In = Jr) : Jr = En(), Jr && Jr.placeable) break;
                  } else Jr = En();
                }, mi = ft.textAnchorOffsetStartIndex, os = ft.textAnchorOffsetEndIndex;
                if (os === mi) {
                  const En = (Ln, Hi) => {
                    const Rn = this.collisionIndex.placeCollisionBox(Ln, pe, F, Ze, M, ze, ke, x, ee.predicate, Je, void 0, Tt);
                    return Rn && Rn.placeable && (this.markUsedOrientation(m, Hi, ft), this.placedOrientations[ft.crossTileID] = Hi), Rn;
                  };
                  lo((() => En(da, o.ao.horizontal)), (() => {
                    const Ln = Zt.verticalTextBox;
                    return m.allowVerticalPlacement && ft.numVerticalGlyphVertices > 0 && Ln ? En(Ln, o.ao.vertical) : { box: null, offscreen: null };
                  })), Ti(Jr && Jr.placeable);
                } else {
                  let En = o.aE[(Kr = ($r = this.prevPlacement) === null || $r === void 0 ? void 0 : $r.variableOffsets[ft.crossTileID]) === null || Kr === void 0 ? void 0 : Kr.anchor];
                  const Ln = (Rn, al, pa) => {
                    const Oo = Rn.x2 - Rn.x1, co = Rn.y2 - Rn.y1, ss = ft.textBoxScale, Fh = we && Ce === "never" ? al : null;
                    let Bi = null, Lh = pe === "never" ? 1 : 2, Hu = "never";
                    En && Lh++;
                    for (let gc = 0; gc < Lh; gc++) {
                      for (let vc = mi; vc < os; vc++) {
                        const as = m.textAnchorOffsets.get(vc);
                        if (En && as.textAnchor !== En) continue;
                        const $o = this.attemptAnchorPlacement(as, Rn, Oo, co, ss, ke, ze, F, Ze, M, ee, Hu, ft, m, pa, x, T, Fh, Je);
                        if ($o && (Bi = $o.placedGlyphBoxes, Bi && Bi.placeable)) return Wr = true, br = $o.shift, Bi;
                      }
                      En ? En = null : Hu = pe;
                    }
                    return u && !Bi && (Bi = { box: this.collisionIndex.placeCollisionBox(da, "always", F, Ze, M, ze, ke, x, ee.predicate, Je, void 0, Tt).box, offscreen: false, placeable: false, occluded: false }), Bi;
                  };
                  lo((() => Ln(da, Zt.iconBox, o.ao.horizontal)), (() => {
                    const Rn = Zt.verticalTextBox;
                    return m.allowVerticalPlacement && (!Jr || !Jr.placeable) && ft.numVerticalGlyphVertices > 0 && Rn ? Ln(Rn, Zt.verticalIconBox, o.ao.vertical) : { box: null, occluded: true, offscreen: null };
                  })), Jr && (Wr = Jr.placeable, _n = Jr.offscreen);
                  const Hi = Ti(Jr && Jr.placeable);
                  if (!Wr && this.prevPlacement) {
                    const Rn = this.prevPlacement.variableOffsets[ft.crossTileID];
                    Rn && (this.variableOffsets[ft.crossTileID] = Rn, this.markUsedJustification(m, Rn.anchor, ft, Hi));
                  }
                }
              }
              if (Fn = Jr, Wr = Fn && Fn.placeable, _n = Fn && Fn.offscreen, ft.useRuntimeCollisionCircles) {
                const Ti = m.text.placedSymbolArray.get(ft.centerJustifiedTextSymbolIndex), lo = o.ap(m.textSizeData, G, Ti), mi = y.get("text-padding");
                Un = this.collisionIndex.placeCollisionCircles(pe, Ti, m.lineVertexArray, m.glyphOffsetArray, lo, M, D, u, ze, ee.predicate, ft.collisionCircleDiameter, mi, x, Je), Un.circles.length && Un.collisionDetected && !u && o.w("Collisions detected, but collision boxes are not shown"), Wr = ge || Un.circles.length > 0 && !Un.collisionDetected, _n = _n && Un.offscreen;
              }
              if (Zt.iconFeatureIndex && (is = Zt.iconFeatureIndex), Zt.iconBox) {
                const Ti = (lo) => this.collisionIndex.placeCollisionBox(lo, Ce, F, Ze, M, ze, ke, T, ee.predicate, Je, we && br ? br : void 0, Tt);
                In && In.placeable && Zt.verticalIconBox ? (fi = Ti(Zt.verticalIconBox), fn = fi.placeable) : (fi = Ti(Zt.iconBox), fn = fi.placeable), _n = _n && fi.offscreen;
              }
              const ha = ue || ft.numHorizontalGlyphVertices === 0 && ft.numVerticalGlyphVertices === 0, Fs = ce || ft.numIconVertices === 0;
              ha || Fs ? Fs ? ha || (fn = fn && Wr) : Wr = fn && Wr : fn = Wr = fn && Wr;
              const Ls = fn && fi.placeable;
              if (Wr && Fn.placeable && this.collisionIndex.insertCollisionBox(Fn.box, pe, y.get("text-ignore-placement"), m.bucketInstanceId, In && In.placeable && ns ? ns : ao, ee.ID), Ls && this.collisionIndex.insertCollisionBox(fi.box, Ce, y.get("icon-ignore-placement"), m.bucketInstanceId, is, ee.ID), Un && Wr && this.collisionIndex.insertCollisionCircles(Un.circles, pe, y.get("text-ignore-placement"), m.bucketInstanceId, ao, ee.ID), u && this.storeCollisionData(m.bucketInstanceId, xr, Zt, Fn, fi, Un), ft.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (m.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[ft.crossTileID] = new Rl((Wr || Qe) && !(Fn == null ? void 0 : Fn.occluded), (fn || qe) && !(fi == null ? void 0 : fi.occluded), _n || m.justReloaded), s[ft.crossTileID] = true;
            };
            if (je) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const ft = m.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Zt = ft.length - 1; Zt >= 0; --Zt) {
                const xr = ft[Zt];
                It(m.symbolInstances.get(xr), m.collisionArrays[xr], xr);
              }
            } else for (let ft = e.symbolInstanceStart; ft < e.symbolInstanceEnd; ft++) It(m.symbolInstances.get(ft), m.collisionArrays[ft], ft);
            m.justReloaded = false;
          }
          storeCollisionData(e, s, u, m, y, x) {
            if (u.textBox || u.iconBox) {
              let T, M;
              this.collisionBoxArrays.has(e) ? T = this.collisionBoxArrays.get(e) : (T = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, T)), T.has(s) ? M = T.get(s) : (M = { text: null, icon: null }, T.set(s, M)), u.textBox && (M.text = m.box), u.iconBox && (M.icon = y.box);
            }
            if (x) {
              let T = this.collisionCircleArrays[e];
              T === void 0 && (T = this.collisionCircleArrays[e] = []);
              for (let M = 0; M < x.circles.length; M += 4) T.push(x.circles[M + 0] - Xr), T.push(x.circles[M + 1] - Xr), T.push(x.circles[M + 2]), T.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, s, u, m) {
            let y;
            y = m === o.ao.vertical ? u.verticalPlacedTextSymbolIndex : { left: u.leftJustifiedTextSymbolIndex, center: u.centerJustifiedTextSymbolIndex, right: u.rightJustifiedTextSymbolIndex }[o.aG(s)];
            const x = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex, u.verticalPlacedTextSymbolIndex];
            for (const T of x) T >= 0 && (e.text.placedSymbolArray.get(T).crossTileID = y >= 0 && T !== y ? 0 : u.crossTileID);
          }
          markUsedOrientation(e, s, u) {
            const m = s === o.ao.horizontal || s === o.ao.horizontalOnly ? s : 0, y = s === o.ao.vertical ? s : 0, x = [u.leftJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.rightJustifiedTextSymbolIndex];
            for (const T of x) e.text.placedSymbolArray.get(T).placedOrientation = m;
            u.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(u.verticalPlacedTextSymbolIndex).placedOrientation = y);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const s = this.prevPlacement;
            let u = false;
            this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
            const m = s ? s.symbolFadeChange(e) : 1, y = s ? s.opacities : {}, x = s ? s.variableOffsets : {}, T = s ? s.placedOrientations : {};
            for (const M in this.placements) {
              const D = this.placements[M], F = y[M];
              F ? (this.opacities[M] = new Gr(F, m, D.text, D.icon), u = u || D.text !== F.text.placed || D.icon !== F.icon.placed) : (this.opacities[M] = new Gr(null, m, D.text, D.icon, D.skipFade), u = u || D.text || D.icon);
            }
            for (const M in y) {
              const D = y[M];
              if (!this.opacities[M]) {
                const F = new Gr(D, m, false, false);
                F.isHidden() || (this.opacities[M] = F, u = u || D.text.placed || D.icon.placed);
              }
            }
            for (const M in x) this.variableOffsets[M] || !this.opacities[M] || this.opacities[M].isHidden() || (this.variableOffsets[M] = x[M]);
            for (const M in T) this.placedOrientations[M] || !this.opacities[M] || this.opacities[M].isHidden() || (this.placedOrientations[M] = T[M]);
            if (s && s.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            u ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, s) {
            const u = {};
            for (const m of s) {
              const y = m.getBucket(e);
              y && m.latestFeatureIndex && e.id === y.layerIds[0] && this.updateBucketOpacities(y, m.tileID, u, m.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, s, u, m) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const y = e.layers[0], x = y.layout, T = new Gr(null, 0, false, false, true), M = x.get("text-allow-overlap"), D = x.get("icon-allow-overlap"), F = y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset"), j = x.get("text-rotation-alignment") === "map", $ = x.get("text-pitch-alignment") === "map", G = x.get("icon-text-fit") !== "none", ee = new Gr(null, 0, M && (D || !e.hasIconData() || x.get("icon-optional")), D && (M || !e.hasTextData() || x.get("text-optional")), true);
            !e.collisionArrays && m && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(m);
            const ue = (pe, ge, Ce) => {
              for (let xe = 0; xe < ge / 4; xe++) pe.opacityVertexArray.emplaceBack(Ce);
              pe.hasVisibleVertices = pe.hasVisibleVertices || Ce !== Ko;
            }, ce = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let pe = 0; pe < e.symbolInstances.length; pe++) {
              const ge = e.symbolInstances.get(pe), { numHorizontalGlyphVertices: Ce, numVerticalGlyphVertices: xe, crossTileID: ke } = ge;
              let ze = this.opacities[ke];
              u[ke] ? ze = T : ze || (ze = ee, this.opacities[ke] = ze), u[ke] = true;
              const we = ge.numIconVertices > 0, je = this.placedOrientations[ge.crossTileID], Qe = je === o.ao.vertical, qe = je === o.ao.horizontal || je === o.ao.horizontalOnly;
              if (Ce > 0 || xe > 0) {
                const Je = Ra(ze.text);
                ue(e.text, Ce, Qe ? Ko : Je), ue(e.text, xe, qe ? Ko : Je);
                const Tt = ze.text.isHidden();
                [ge.rightJustifiedTextSymbolIndex, ge.centerJustifiedTextSymbolIndex, ge.leftJustifiedTextSymbolIndex].forEach(((Zt) => {
                  Zt >= 0 && (e.text.placedSymbolArray.get(Zt).hidden = Tt || Qe ? 1 : 0);
                })), ge.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ge.verticalPlacedTextSymbolIndex).hidden = Tt || qe ? 1 : 0);
                const It = this.variableOffsets[ge.crossTileID];
                It && this.markUsedJustification(e, It.anchor, ge, je);
                const ft = this.placedOrientations[ge.crossTileID];
                ft && (this.markUsedJustification(e, "left", ge, ft), this.markUsedOrientation(e, ft, ge));
              }
              if (we) {
                const Je = Ra(ze.icon), Tt = !(G && ge.verticalPlacedIconSymbolIndex && Qe);
                ge.placedIconSymbolIndex >= 0 && (ue(e.icon, ge.numIconVertices, Tt ? Je : Ko), e.icon.placedSymbolArray.get(ge.placedIconSymbolIndex).hidden = ze.icon.isHidden()), ge.verticalPlacedIconSymbolIndex >= 0 && (ue(e.icon, ge.numVerticalIconVertices, Tt ? Ko : Je), e.icon.placedSymbolArray.get(ge.verticalPlacedIconSymbolIndex).hidden = ze.icon.isHidden());
              }
              const Ze = ce && ce.has(pe) ? ce.get(pe) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Je = e.collisionArrays[pe];
                if (Je) {
                  let Tt = new o.P(0, 0);
                  if (Je.textBox || Je.verticalTextBox) {
                    let It = true;
                    if (F) {
                      const ft = this.variableOffsets[ke];
                      ft ? (Tt = wo(ft.anchor, ft.width, ft.height, ft.textOffset, ft.textBoxScale), j && Tt._rotate($ ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : It = false;
                    }
                    if (Je.textBox || Je.verticalTextBox) {
                      let ft;
                      Je.textBox && (ft = Qe), Je.verticalTextBox && (ft = qe), Ea(e.textCollisionBox.collisionVertexArray, ze.text.placed, !It || ft, Ze.text, Tt.x, Tt.y);
                    }
                  }
                  if (Je.iconBox || Je.verticalIconBox) {
                    const It = !!(!qe && Je.verticalIconBox);
                    let ft;
                    Je.iconBox && (ft = It), Je.verticalIconBox && (ft = !It), Ea(e.iconCollisionBox.collisionVertexArray, ze.icon.placed, ft, Ze.icon, G ? Tt.x : 0, G ? Tt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, s) {
            const u = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
            return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * u > e;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ea(v, e, s, u, m, y) {
          u && u.length !== 0 || (u = [0, 0, 0, 0]);
          const x = u[0] - Xr, T = u[1] - Xr, M = u[2] - Xr, D = u[3] - Xr;
          v.emplaceBack(e ? 1 : 0, s ? 1 : 0, m || 0, y || 0, x, T), v.emplaceBack(e ? 1 : 0, s ? 1 : 0, m || 0, y || 0, M, T), v.emplaceBack(e ? 1 : 0, s ? 1 : 0, m || 0, y || 0, M, D), v.emplaceBack(e ? 1 : 0, s ? 1 : 0, m || 0, y || 0, x, D);
        }
        const zl = Math.pow(2, 25), Al = Math.pow(2, 24), Yo = Math.pow(2, 17), Dl = Math.pow(2, 16), iu = Math.pow(2, 9), ou = Math.pow(2, 8), su = Math.pow(2, 1);
        function Ra(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const e = v.placed ? 1 : 0, s = Math.floor(127 * v.opacity);
          return s * zl + e * Al + s * Yo + e * Dl + s * iu + e * ou + s * su + e;
        }
        const Ko = 0;
        class za {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, s, u, m, y) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (s.getBucketParts(x, m, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, y()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, x.sort(((T, M) => T.sortKey - M.sortKey))); this._currentPartIndex < x.length; ) if (s.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, u), this._currentPartIndex++, y()) return true;
            return false;
          }
        }
        class Aa {
          constructor(e, s, u, m, y, x, T, M) {
            this.placement = new Co(e, s, x, T, M), this._currentPlacementIndex = u.length - 1, this._forceFullPlacement = m, this._showCollisionBoxes = y, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, s, u) {
            const m = z.now(), y = () => !this._forceFullPlacement && z.now() - m > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = s[e[this._currentPlacementIndex]], T = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= T) && (!x.maxzoom || x.maxzoom > T)) {
                if (this._inProgressLayer || (this._inProgressLayer = new za(x)), this._inProgressLayer.continuePlacement(u[x.source], this.placement, this._showCollisionBoxes, x, y)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const Jo = 512 / o.$ / 2;
        class Da {
          constructor(e, s, u) {
            this.tileID = e, this.bucketInstanceId = u, this._symbolsByKey = {};
            const m = /* @__PURE__ */ new Map();
            for (let y = 0; y < s.length; y++) {
              const x = s.get(y), T = x.key, M = m.get(T);
              M ? M.push(x) : m.set(T, [x]);
            }
            for (const [y, x] of m) {
              const T = { positions: x.map(((M) => ({ x: Math.floor(M.anchorX * Jo), y: Math.floor(M.anchorY * Jo) }))), crossTileIDs: x.map(((M) => M.crossTileID)) };
              if (T.positions.length > 128) {
                const M = new o.aI(T.positions.length, 16, Uint16Array);
                for (const { x: D, y: F } of T.positions) M.add(D, F);
                M.finish(), delete T.positions, T.index = M;
              }
              this._symbolsByKey[y] = T;
            }
          }
          getScaledCoordinates(e, s) {
            const { x: u, y: m, z: y } = this.tileID.canonical, { x, y: T, z: M } = s.canonical, D = Jo / Math.pow(2, M - y), F = (T * o.$ + e.anchorY) * D, j = m * o.$ * Jo;
            return { x: Math.floor((x * o.$ + e.anchorX) * D - u * o.$ * Jo), y: Math.floor(F - j) };
          }
          findMatches(e, s, u) {
            const m = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z);
            for (let y = 0; y < e.length; y++) {
              const x = e.get(y);
              if (x.crossTileID) continue;
              const T = this._symbolsByKey[x.key];
              if (!T) continue;
              const M = this.getScaledCoordinates(x, s);
              if (T.index) {
                const D = T.index.range(M.x - m, M.y - m, M.x + m, M.y + m).sort();
                for (const F of D) {
                  const j = T.crossTileIDs[F];
                  if (!u[j]) {
                    u[j] = true, x.crossTileID = j;
                    break;
                  }
                }
              } else if (T.positions) for (let D = 0; D < T.positions.length; D++) {
                const F = T.positions[D], j = T.crossTileIDs[D];
                if (Math.abs(F.x - M.x) <= m && Math.abs(F.y - M.y) <= m && !u[j]) {
                  u[j] = true, x.crossTileID = j;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class Fa {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class au {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const s = Math.round((e - this.lng) / 360);
            if (s !== 0) for (const u in this.indexes) {
              const m = this.indexes[u], y = {};
              for (const x in m) {
                const T = m[x];
                T.tileID = T.tileID.unwrapTo(T.tileID.wrap + s), y[T.tileID.key] = T;
              }
              this.indexes[u] = y;
            }
            this.lng = e;
          }
          addBucket(e, s, u) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === s.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let y = 0; y < s.symbolInstances.length; y++) s.symbolInstances.get(y).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const m = this.usedCrossTileIDs[e.overscaledZ];
            for (const y in this.indexes) {
              const x = this.indexes[y];
              if (Number(y) > e.overscaledZ) for (const T in x) {
                const M = x[T];
                M.tileID.isChildOf(e) && M.findMatches(s.symbolInstances, e, m);
              }
              else {
                const T = x[e.scaledTo(Number(y)).key];
                T && T.findMatches(s.symbolInstances, e, m);
              }
            }
            for (let y = 0; y < s.symbolInstances.length; y++) {
              const x = s.symbolInstances.get(y);
              x.crossTileID || (x.crossTileID = u.generate(), m[x.crossTileID] = true);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Da(e, s.symbolInstances, s.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e, s) {
            for (const u of s.getCrossTileIDsLists()) for (const m of u) delete this.usedCrossTileIDs[e][m];
          }
          removeStaleBuckets(e) {
            let s = false;
            for (const u in this.indexes) {
              const m = this.indexes[u];
              for (const y in m) e[m[y].bucketInstanceId] || (this.removeBucketCrossTileIDs(u, m[y]), delete m[y], s = true);
            }
            return s;
          }
        }
        class Qo {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Fa(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, s, u) {
            let m = this.layerIndexes[e.id];
            m === void 0 && (m = this.layerIndexes[e.id] = new au());
            let y = false;
            const x = {};
            m.handleWrapJump(u);
            for (const T of s) {
              const M = T.getBucket(e);
              M && e.id === M.layerIds[0] && (M.bucketInstanceId || (M.bucketInstanceId = ++this.maxBucketInstanceId), m.addBucket(T.tileID, M, this.crossTileIDs) && (y = true), x[M.bucketInstanceId] = true);
            }
            return m.removeStaleBuckets(x) && (y = true), y;
          }
          pruneUnusedLayers(e) {
            const s = {};
            e.forEach(((u) => {
              s[u] = true;
            }));
            for (const u in this.layerIndexes) s[u] || delete this.layerIndexes[u];
          }
        }
        var _s = "void main() {fragColor=vec4(1.0);}";
        const Di = { prelude: Sr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Sr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Sr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Sr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Sr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Sr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Sr(_s, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Sr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Sr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Sr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Sr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Sr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Sr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Sr(_s, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Sr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Sr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Sr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Sr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Sr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Sr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Sr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Sr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Sr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Sr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Sr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Sr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Sr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Sr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Sr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Sr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Sr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Sr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Sr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Sr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Sr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Sr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Sr(v, e) {
          const s = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, u = e.match(/in ([\w]+) ([\w]+)/g), m = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), y = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = y ? y.concat(m) : m, T = {};
          return { fragmentSource: v = v.replace(s, ((M, D, F, j, $) => (T[$] = true, D === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
in ${F} ${j} ${$};
#else
uniform ${F} ${j} u_${$};
#endif
` : `
#ifdef HAS_UNIFORM_u_${$}
    ${F} ${j} ${$} = u_${$};
#endif
`))), vertexSource: e = e.replace(s, ((M, D, F, j, $) => {
            const G = j === "float" ? "vec2" : "vec4", ee = $.match(/color/) ? "color" : G;
            return T[$] ? D === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${F} ${G} a_${$};
out ${F} ${j} ${$};
#else
uniform ${F} ${j} u_${$};
#endif
` : ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = a_${$};
#else
    ${F} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = unpack_mix_${ee}(a_${$}, u_${$}_t);
#else
    ${F} ${j} ${$} = u_${$};
#endif
` : D === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${F} ${G} a_${$};
#else
uniform ${F} ${j} u_${$};
#endif
` : ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${F} ${j} ${$} = a_${$};
#else
    ${F} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${F} ${j} ${$} = unpack_mix_${ee}(a_${$}, u_${$}_t);
#else
    ${F} ${j} ${$} = u_${$};
#endif
`;
          })), staticAttributes: u, staticUniforms: x };
        }
        class Ao {
          constructor(e, s, u) {
            this.vertexBuffer = e, this.indexBuffer = s, this.segments = u;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var So = o.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Qi = "#define PROJECTION_MERCATOR", Do = "mercator";
        class kr {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return Do;
          }
          get shaderDefine() {
            return Qi;
          }
          get shaderPreludeCode() {
            return Di.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Di.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return o.aK.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, s, u, m, y) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new o.aL();
            x.emplaceBack(0, 0), x.emplaceBack(o.$, 0), x.emplaceBack(0, o.$), x.emplaceBack(o.$, o.$);
            const T = e.createVertexBuffer(x, So.members), M = o.aM.simpleSegment(0, 0, 4, 2), D = new o.aN();
            D.emplaceBack(1, 0, 2), D.emplaceBack(1, 2, 3);
            const F = e.createIndexBuffer(D);
            return this._cachedMesh = new Ao(T, F, M), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class bs {
          constructor(e = 0, s = 0, u = 0, m = 0) {
            if (isNaN(e) || e < 0 || isNaN(s) || s < 0 || isNaN(u) || u < 0 || isNaN(m) || m < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = s, this.left = u, this.right = m;
          }
          interpolate(e, s, u) {
            return s.top != null && e.top != null && (this.top = o.C.number(e.top, s.top, u)), s.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, s.bottom, u)), s.left != null && e.left != null && (this.left = o.C.number(e.left, s.left, u)), s.right != null && e.right != null && (this.right = o.C.number(e.right, s.right, u)), this;
          }
          getCenter(e, s) {
            const u = o.ah((this.left + e - this.right) / 2, 0, e), m = o.ah((this.top + s - this.bottom) / 2, 0, s);
            return new o.P(u, m);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new bs(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fl(v, e) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const s = e.lng - v.center.lng;
          e.lng += s > 180 ? -360 : s < -180 ? 360 : 0;
        }
        function Ll(v) {
          return Math.max(0, Math.floor(v));
        }
        class ui {
          constructor(e, s, u, m, y, x) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = x === void 0 || !!x, this._minZoom = s || 0, this._maxZoom = u || 22, this._minPitch = m ?? 0, this._maxPitch = y ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ll(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new bs(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e, s, u) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Ll(this._zoom), this._scale = o.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new bs(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !u && e.autoCalculateNearFarZ, s && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new o.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const s = o.aO(e, -180, 180) * Math.PI / 180;
            var u, m, y, x, T, M, D, F, j;
            this._bearingInRadians !== s && (this._unmodified = false, this._bearingInRadians = s, this._calcMatrices(), this._rotationMatrix = S(), u = this._rotationMatrix, y = -this._bearingInRadians, x = (m = this._rotationMatrix)[0], T = m[1], M = m[2], D = m[3], F = Math.sin(y), j = Math.cos(y), u[0] = x * j + M * F, u[1] = T * j + D * F, u[2] = x * -F + M * j, u[3] = T * -F + D * j);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const s = o.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== s && (this._unmodified = false, this._pitchInRadians = s, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const s = e / 180 * Math.PI;
            this._rollInRadians !== s && (this._unmodified = false, this._rollInRadians = s, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return o.aP(this._fovInRadians);
          }
          setFov(e) {
            e = o.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = o.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const s = this.getConstrained(this._center, e).zoom;
            this._zoom !== s && (this._unmodified = false, this._zoom = s, this._tileZoom = Math.max(0, Math.floor(s)), this._scale = o.af(s), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, s) {
            this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = s, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, s, u) {
            this._unmodified = false, this._edgeInsets.interpolate(e, s, u), this._constrain(), this._calcMatrices();
          }
          resize(e, s, u = true) {
            this._width = e, this._height = s, u && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new yt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-o.ai, o.ai]);
          }
          getConstrained(e, s) {
            return this._callbacks.getConstrained(e, s);
          }
          getCameraQueryGeometry(e, s) {
            if (s.length === 1) return [s[0], e];
            {
              const { minX: u, minY: m, maxX: y, maxY: x } = o.a2.fromPoints(s).extend(e);
              return [new o.P(u, m), new o.P(y, m), new o.P(y, x), new o.P(u, x), new o.P(u, m)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e = this._unmodified, { center: s, zoom: u } = this.getConstrained(this.center, this.zoom);
            this.setCenter(s), this.setZoom(u), this._unmodified = e, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = o.ag(new Float64Array(16));
              o.N(e, e, [this._width / 2, -this._height / 2, 1]), o.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = o.ag(new Float64Array(16)), o.N(e, e, [1, -1, 1]), o.M(e, e, [-1, -1, 0]), o.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, s, u, m) {
            const y = u !== void 0 ? u : this.bearing, x = m = m !== void 0 ? m : this.pitch, T = o.a1.fromLngLat(e, s), M = -Math.cos(o.ae(x)), D = Math.sin(o.ae(x)), F = D * Math.sin(o.ae(y)), j = -D * Math.cos(o.ae(y));
            let $ = this.elevation;
            const G = s - $;
            let ee;
            M * G >= 0 || Math.abs(M) < 0.1 ? (ee = 1e4, $ = s + ee * M) : ee = -G / M;
            let ue, ce, pe = o.aQ(1, T.y), ge = 0;
            do {
              if (ge += 1, ge > 10) break;
              ce = ee / pe, ue = new o.a1(T.x + F * ce, T.y + j * ce), pe = 1 / ue.meterInMercatorCoordinateUnits();
            } while (Math.abs(ee - ce * pe) > 1e-12);
            return { center: ue.toLngLat(), elevation: $, zoom: o.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / ce / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const s = o.aj(1, this.center.lat) * this.worldSize, u = this.cameraToCenterDistance / s, m = o.a1.fromLngLat(this.center, this.elevation), y = fe(this.center, this.elevation, this.pitch, this.bearing, u);
            this._elevation = e;
            const x = this.calculateCenterFromCameraLngLatAlt(y.toLngLat(), o.aQ(y.z, m.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return fe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const s = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / s, e.canonical.y / s, 1 / s / o.$, 1 / s / o.$];
          }
        }
        class Nn {
          constructor(e, s) {
            this.min = e, this.max = s, this.center = o.aR([], o.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const s = [e % 2 == 0, e < 2], u = o.aT(this.min), m = o.aT(this.max);
            for (let y = 0; y < s.length; y++) u[y] = s[y] ? this.min[y] : this.center[y], m[y] = s[y] ? this.center[y] : this.max[y];
            return m[2] = this.max[2], new Nn(u, m);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let s = true;
            for (let u = 0; u < e.planes.length; u++) {
              const m = this.intersectsPlane(e.planes[u]);
              if (m === 0) return 0;
              m === 1 && (s = false);
            }
            return s ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let s = e[3], u = e[3];
            for (let m = 0; m < 3; m++) e[m] > 0 ? (s += e[m] * this.min[m], u += e[m] * this.max[m]) : (u += e[m] * this.min[m], s += e[m] * this.max[m]);
            return s >= 0 ? 2 : u < 0 ? 0 : 1;
          }
        }
        class di {
          distanceToTile2d(e, s, u, m) {
            const y = m.distanceX([e, s]), x = m.distanceY([e, s]);
            return Math.hypot(y, x);
          }
          getWrap(e, s, u) {
            return u;
          }
          getTileBoundingVolume(e, s, u, m) {
            var y, x;
            let T = 0, M = 0;
            if (m == null ? void 0 : m.terrain) {
              const F = new o.Z(e.z, s, e.z, e.x, e.y), j = m.terrain.getMinMaxElevation(F);
              T = (y = j.minElevation) !== null && y !== void 0 ? y : Math.min(0, u), M = (x = j.maxElevation) !== null && x !== void 0 ? x : Math.max(0, u);
            }
            const D = 1 << e.z;
            return new Nn([s + e.x / D, e.y / D, T], [s + (e.x + 1) / D, (e.y + 1) / D, M]);
          }
          allowVariableZoom(e, s) {
            const u = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, m = o.ah(78.5 - u / 2, 0, 60);
            return !!s.terrain || e.pitch > m;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Mn {
          constructor(e, s, u) {
            this.points = e, this.planes = s, this.aabb = u;
          }
          static fromInvProjectionMatrix(e, s = 1, u = 0, m, y) {
            const x = y ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], T = Math.pow(2, u), M = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((($) => (function(G, ee, ue, ce) {
              const pe = o.aw([], G, ee), ge = 1 / pe[3] / ue * ce;
              return o.aY(pe, pe, [ge, ge, 1 / pe[3], ge]);
            })($, e, s, T)));
            m && (function($, G, ee, ue) {
              const ce = ue ? 4 : 0, pe = ue ? 0 : 4;
              let ge = 0;
              const Ce = [], xe = [];
              for (let we = 0; we < 4; we++) {
                const je = o.aU([], $[we + pe], $[we + ce]), Qe = o.aZ(je);
                o.aR(je, je, 1 / Qe), Ce.push(Qe), xe.push(je);
              }
              for (let we = 0; we < 4; we++) {
                const je = o.a_($[we + ce], xe[we], ee);
                ge = je !== null && je >= 0 ? Math.max(ge, je) : Math.max(ge, Ce[we]);
              }
              const ke = (function(we, je) {
                const Qe = o.aU([], we[je[0]], we[je[1]]), qe = o.aU([], we[je[2]], we[je[1]]), Ze = [0, 0, 0, 0];
                return o.aV(Ze, o.aW([], Qe, qe)), Ze[3] = -o.aX(Ze, we[je[0]]), Ze;
              })($, G), ze = (function(we, je) {
                const Qe = o.a$(we), qe = o.b0([], we, 1 / Qe), Ze = o.aU([], je, o.aR([], qe, o.aX(je, qe))), Je = o.a$(Ze);
                if (Je > 0) {
                  const Tt = Math.sqrt(1 - qe[3] * qe[3]), It = o.aR([], qe, -qe[3]), ft = o.aS([], It, o.aR([], Ze, Tt / Je));
                  return o.b1(je, ft);
                }
                return null;
              })(ee, ke);
              if (ze !== null) {
                const we = ze / o.aX(xe[0], ke);
                ge = Math.min(ge, we);
              }
              for (let we = 0; we < 4; we++) {
                const je = Math.min(ge, Ce[we]);
                $[we + pe] = [$[we + ce][0] + xe[we][0] * je, $[we + ce][1] + xe[we][1] * je, $[we + ce][2] + xe[we][2] * je, 1];
              }
            })(M, x[0], m, y);
            const D = x.map((($) => {
              const G = o.aU([], M[$[0]], M[$[1]]), ee = o.aU([], M[$[2]], M[$[1]]), ue = o.aV([], o.aW([], G, ee)), ce = -o.aX(ue, M[$[1]]);
              return ue.concat(ce);
            })), F = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const $ of M) for (let G = 0; G < 3; G++) F[G] = Math.min(F[G], $[G]), j[G] = Math.max(j[G], $[G]);
            return new Mn(M, D, new Nn(F, j));
          }
        }
        class tn {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, s, u) {
            return this._helper.interpolatePadding(e, s, u);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, s, u = true) {
            this._helper.resize(e, s, u);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, s) {
            this._helper.overrideNearFarZ(e, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, s) {
          }
          constructor(e, s, u, m, y) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new ui({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (x, T) => this.getConstrained(x, T) }, e, s, u, m, y), this._coveringTilesDetailsProvider = new di();
          }
          clone() {
            const e = new tn();
            return e.apply(this), e;
          }
          apply(e, s, u) {
            this._helper.apply(e, s, u);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const s = [new o.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const u = this.screenPointToMercatorCoordinate(new o.P(0, 0)), m = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)), y = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)), T = Math.floor(Math.min(u.x, m.x, y.x, x.x)), M = Math.floor(Math.max(u.x, m.x, y.x, x.x)), D = 1;
              for (let F = T - D; F <= M + D; F++) F !== 0 && s.push(new o.b2(F, e));
            }
            return s;
          }
          getCameraFrustum() {
            return Mn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const s = this.screenPointToLocation(this.centerPoint, e), u = e ? e.getElevationForLngLatZoom(s, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(u);
          }
          setLocationAtPoint(e, s) {
            const u = o.aj(this.elevation, this.center.lat), m = this.screenPointToMercatorCoordinateAtZ(s, u), y = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, u), x = o.a1.fromLngLat(e), T = new o.a1(x.x - (m.x - y.x), x.y - (m.y - y.y));
            this.setCenter(T == null ? void 0 : T.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, s) {
            return s ? this.coordinatePoint(o.a1.fromLngLat(e), s.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a1.fromLngLat(e));
          }
          screenPointToLocation(e, s) {
            var u;
            return (u = this.screenPointToMercatorCoordinate(e, s)) === null || u === void 0 ? void 0 : u.toLngLat();
          }
          screenPointToMercatorCoordinate(e, s) {
            if (s) {
              const u = s.pointCoordinate(e);
              if (u != null) return u;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, s) {
            const u = s || 0, m = [e.x, e.y, 0, 1], y = [e.x, e.y, 1, 1];
            o.aw(m, m, this._pixelMatrixInverse), o.aw(y, y, this._pixelMatrixInverse);
            const x = m[3], T = y[3], M = m[1] / x, D = y[1] / T, F = m[2] / x, j = y[2] / T, $ = F === j ? 0 : (u - F) / (j - F);
            return new o.a1(o.C.number(m[0] / x, y[0] / T, $) / this.worldSize, o.C.number(M, D, $) / this.worldSize, u);
          }
          coordinatePoint(e, s = 0, u = this._pixelMatrix) {
            const m = [e.x * this.worldSize, e.y * this.worldSize, s, 1];
            return o.aw(m, m, u), new o.P(m[0] / m[3], m[1] / m[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Ie(this));
            return new yt().extend(this.screenPointToLocation(new o.P(0, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, s) {
            return s ? s.pointCoordinate(e) != null : e.y > this.height / 2 - Ie(this);
          }
          calculatePosMatrix(e, s = false, u) {
            var m;
            const y = (m = e.key) !== null && m !== void 0 ? m : o.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), x = s ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(y)) {
              const D = x.get(y);
              return u ? D.f32 : D.f64;
            }
            const T = Fe(e, this.worldSize);
            o.O(T, s ? this._alignedProjMatrix : this._viewProjMatrix, T);
            const M = { f64: T, f32: new Float32Array(T) };
            return x.set(y, M), u ? M.f32 : M.f64;
          }
          calculateFogMatrix(e) {
            const s = e.key, u = this._fogMatrixCacheF32;
            if (u.has(s)) return u.get(s);
            const m = Fe(e, this.worldSize);
            return o.O(m, this._fogMatrix, m), u.set(s, new Float32Array(m)), u.get(s);
          }
          getConstrained(e, s) {
            s = o.ah(+s, this.minZoom, this.maxZoom);
            const u = { center: new o.S(e.lng, e.lat), zoom: s };
            let m = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && m === null) {
              const Ce = 179.9999999999;
              m = [-Ce, Ce];
            }
            const y = this.tileSize * o.af(u.zoom);
            let x = 0, T = y, M = 0, D = y, F = 0, j = 0;
            const { x: $, y: G } = this.size;
            if (this._helper._latRange) {
              const Ce = this._helper._latRange;
              x = o.U(Ce[1]) * y, T = o.U(Ce[0]) * y, T - x < G && (F = G / (T - x));
            }
            m && (M = o.aO(o.V(m[0]) * y, 0, y), D = o.aO(o.V(m[1]) * y, 0, y), D < M && (D += y), D - M < $ && (j = $ / (D - M)));
            const { x: ee, y: ue } = ae(y, e);
            let ce, pe;
            const ge = Math.max(j || 0, F || 0);
            if (ge) {
              const Ce = new o.P(j ? (D + M) / 2 : ee, F ? (T + x) / 2 : ue);
              return u.center = be(y, Ce).wrap(), u.zoom += o.ak(ge), u;
            }
            if (this._helper._latRange) {
              const Ce = G / 2;
              ue - Ce < x && (pe = x + Ce), ue + Ce > T && (pe = T - Ce);
            }
            if (m) {
              const Ce = (M + D) / 2;
              let xe = ee;
              this._helper._renderWorldCopies && (xe = o.aO(ee, Ce - y / 2, Ce + y / 2));
              const ke = $ / 2;
              xe - ke < M && (ce = M + ke), xe + ke > D && (ce = D - ke);
            }
            if (ce !== void 0 || pe !== void 0) {
              const Ce = new o.P(ce ?? ee, pe ?? ue);
              u.center = be(y, Ce).wrap();
            }
            return u;
          }
          calculateCenterFromCameraLngLatAlt(e, s, u, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, s, u, m);
          }
          _calculateNearFarZIfNeeded(e, s, u) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const m = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), y = e - m * this._helper._pixelPerMeter / Math.cos(s), x = m < 0 ? y : e, T = Math.PI / 2 + this.pitchInRadians, M = o.ae(this.fov) * (Math.abs(Math.cos(o.ae(this.roll))) * this.height + Math.abs(Math.sin(o.ae(this.roll))) * this.width) / this.height * (0.5 + u.y / this.height), D = Math.sin(M) * x / Math.sin(o.ah(Math.PI - T - M, 0.01, Math.PI - 0.01)), F = Ie(this), j = Math.atan(F / this._helper.cameraToCenterDistance), $ = o.ae(0.75), G = j > $ ? 2 * j * (0.5 + u.y / (2 * F)) : $, ee = Math.sin(G) * x / Math.sin(o.ah(Math.PI - T - G, 0.01, Math.PI - 0.01)), ue = Math.min(D, ee);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - s) * ue + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, s = ae(this.worldSize, this.center), u = s.x, m = s.y;
            this._helper._pixelPerMeter = o.aj(1, this.center.lat) * this.worldSize;
            const y = o.ae(Math.min(this.pitch, ne)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(y));
            let T;
            this._calculateNearFarZIfNeeded(x, y, e), T = new Float64Array(16), o.b4(T, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.aq(this._invProjMatrix, T), T[8] = 2 * -e.x / this._helper._width, T[9] = 2 * e.y / this._helper._height, this._projectionMatrix = o.b5(T), o.N(T, T, [1, -1, 1]), o.M(T, T, [0, 0, -this._helper.cameraToCenterDistance]), o.b6(T, T, -this.rollInRadians), o.b7(T, T, this.pitchInRadians), o.b6(T, T, -this.bearingInRadians), o.M(T, T, [-u, -m, 0]), this._mercatorMatrix = o.N([], T, [this.worldSize, this.worldSize, this.worldSize]), o.N(T, T, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, T), o.M(T, T, [0, 0, -this.elevation]), this._viewProjMatrix = T, this._invViewProjMatrix = o.aq([], T);
            const M = [0, 0, -1, 1];
            o.aw(M, M, this._invViewProjMatrix), this._cameraPosition = [M[0] / M[3], M[1] / M[3], M[2] / M[3]], this._fogMatrix = new Float64Array(16), o.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-u, -m, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, T);
            const D = this._helper._width % 2 / 2, F = this._helper._height % 2 / 2, j = Math.cos(this.bearingInRadians), $ = Math.sin(-this.bearingInRadians), G = u - Math.round(u) + j * D + $ * F, ee = m - Math.round(m) + j * F + $ * D, ue = new Float64Array(T);
            if (o.M(ue, ue, [G > 0.5 ? G - 1 : G, ee > 0.5 ? ee - 1 : ee, 0]), this._alignedProjMatrix = ue, T = o.aq(new Float64Array(16), this._pixelMatrix), !T) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = T, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new o.P(0, 0)), s = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return o.aw(s, s, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = o.aj(1, this.center.lat) * this.worldSize;
            return fe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, s) {
            const u = o.a1.fromLngLat(e), m = [u.x * this.worldSize, u.y * this.worldSize, s, 1];
            return o.aw(m, m, this._viewProjMatrix), m[2] / m[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: s, aligned: u, applyTerrainMatrix: m } = e, y = this._helper.getMercatorTileCoordinates(s), x = s ? this.calculatePosMatrix(s, u, true) : null;
            let T;
            return T = s && s.terrainRttPosMatrix32f && m ? s.terrainRttPosMatrix32f : x || o.b8(), { mainMatrix: T, tileMercatorCoords: y, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: T };
          }
          isLocationOccluded(e) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, s, u) {
            return 1;
          }
          transformLightDirection(e) {
            return o.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, s, u, m) {
            const y = this.calculatePosMatrix(u);
            let x;
            m ? (x = [e, s, m(e, s), 1], o.aw(x, x, y)) : (x = [e, s, 0, 1], xo(x, x, y));
            const T = x[3];
            return { point: new o.P(x[0] / T, x[1] / T), signedDistanceFromCamera: T, isOccluded: false };
          }
          populateCache(e) {
            for (const s of e) this.calculatePosMatrix(s);
          }
          getMatrixForModel(e, s) {
            const u = o.a1.fromLngLat(e, s), m = u.meterInMercatorCoordinateUnits(), y = o.b9();
            return o.M(y, y, [u.x, u.y, u.z]), o.b6(y, y, Math.PI), o.b7(y, y, Math.PI / 2), o.N(y, y, [-m, m, m]), y;
          }
          getProjectionDataForCustomLayer(e = true) {
            const s = new o.Z(0, 0, 0, 0, 0), u = this.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: e }), m = Fe(s, this.worldSize);
            o.O(m, this._viewProjMatrix, m), u.tileMercatorCoords = [0, 0, 1, 1];
            const y = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter], x = o.ba();
            return o.N(x, m, y), u.fallbackMatrix = x, u.mainMatrix = x, u;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function Zd() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function hi(v) {
          if (v.useSlerp) if (v.k < 1) {
            const e = o.bb(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), s = o.bb(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), u = new Float64Array(4);
            o.bc(u, e, s, v.k);
            const m = o.bd(u);
            v.tr.setRoll(m.roll), v.tr.setPitch(m.pitch), v.tr.setBearing(m.bearing);
          } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(o.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(o.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(o.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function Fi(v, e, s, u, m) {
          const y = m.padding, x = ae(m.worldSize, s.getNorthWest()), T = ae(m.worldSize, s.getNorthEast()), M = ae(m.worldSize, s.getSouthEast()), D = ae(m.worldSize, s.getSouthWest()), F = o.ae(-u), j = x.rotate(F), $ = T.rotate(F), G = M.rotate(F), ee = D.rotate(F), ue = new o.P(Math.max(j.x, $.x, ee.x, G.x), Math.max(j.y, $.y, ee.y, G.y)), ce = new o.P(Math.min(j.x, $.x, ee.x, G.x), Math.min(j.y, $.y, ee.y, G.y)), pe = ue.sub(ce), ge = (m.width - (y.left + y.right + e.left + e.right)) / pe.x, Ce = (m.height - (y.top + y.bottom + e.top + e.bottom)) / pe.y;
          if (Ce < 0 || ge < 0) return void Zd();
          const xe = Math.min(o.ak(m.scale * Math.min(ge, Ce)), v.maxZoom), ke = o.P.convert(v.offset), ze = new o.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(o.ae(u)), we = ke.add(ze).mult(m.scale / o.af(xe));
          return { center: be(m.worldSize, x.add(M).div(2).sub(we)), zoom: xe, bearing: u };
        }
        class oi {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e, s) {
            return { easingOffset: e, easingCenter: s.center };
          }
          handleMapControlsRollPitchBearingZoom(e, s) {
            e.bearingDelta && s.setBearing(s.bearing + e.bearingDelta), e.pitchDelta && s.setPitch(s.pitch + e.pitchDelta), e.rollDelta && s.setRoll(s.roll + e.rollDelta), e.zoomDelta && s.setZoom(s.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, s, u) {
            e.around.distSqr(s.centerPoint) < 0.01 || s.setLocationAtPoint(u, e.around);
          }
          cameraForBoxAndBearing(e, s, u, m, y) {
            return Fi(e, s, u, m, y);
          }
          handleJumpToCenterZoom(e, s) {
            e.zoom !== (s.zoom !== void 0 ? +s.zoom : e.zoom) && e.setZoom(+s.zoom), s.center !== void 0 && e.setCenter(o.S.convert(s.center));
          }
          handleEaseTo(e, s) {
            const u = e.zoom, m = e.padding, y = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, x = { roll: s.roll === void 0 ? e.roll : s.roll, pitch: s.pitch === void 0 ? e.pitch : s.pitch, bearing: s.bearing === void 0 ? e.bearing : s.bearing }, T = s.zoom !== void 0, M = !e.isPaddingEqual(s.padding);
            let D = false;
            const F = T ? +s.zoom : e.zoom;
            let j = e.centerPoint.add(s.offsetAsPoint);
            const $ = e.screenPointToLocation(j), { center: G, zoom: ee } = e.getConstrained(o.S.convert(s.center || $), F ?? u);
            Fl(e, G);
            const ue = ae(e.worldSize, $), ce = ae(e.worldSize, G).sub(ue), pe = o.af(ee - u);
            return D = ee !== u, { easeFunc: (ge) => {
              if (D && e.setZoom(o.C.number(u, ee, ge)), o.be(y, x) || hi({ startEulerAngles: y, endEulerAngles: x, tr: e, k: ge, useSlerp: y.roll != x.roll }), M && (e.interpolatePadding(m, s.padding, ge), j = e.centerPoint.add(s.offsetAsPoint)), s.around) e.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const Ce = o.af(e.zoom - u), xe = ee > u ? Math.min(2, pe) : Math.max(0.5, pe), ke = Math.pow(xe, 1 - ge), ze = be(e.worldSize, ue.add(ce.mult(ge * ke)).mult(Ce));
                e.setLocationAtPoint(e.renderWorldCopies ? ze.wrap() : ze, j);
              }
            }, isZooming: D, elevationCenter: G };
          }
          handleFlyTo(e, s) {
            const u = s.zoom !== void 0, m = e.zoom, y = e.getConstrained(o.S.convert(s.center || s.locationAtOffset), u ? +s.zoom : m), x = y.center, T = y.zoom;
            Fl(e, x);
            const M = ae(e.worldSize, s.locationAtOffset), D = ae(e.worldSize, x).sub(M), F = D.mag(), j = o.af(T - m);
            let $;
            if (s.minZoom !== void 0) {
              const G = Math.min(+s.minZoom, m, T), ee = e.getConstrained(x, G).zoom;
              $ = o.af(ee - m);
            }
            return { easeFunc: (G, ee, ue, ce) => {
              e.setZoom(G === 1 ? T : m + o.ak(ee));
              const pe = G === 1 ? x : be(e.worldSize, M.add(D.mult(ue)).mult(ee));
              e.setLocationAtPoint(e.renderWorldCopies ? pe.wrap() : pe, ce);
            }, scaleOfZoom: j, targetCenter: x, scaleOfMinZoom: $, pixelPathLength: F };
          }
        }
        class cn {
          constructor(e, s, u) {
            this.blendFunction = e, this.blendColor = s, this.mask = u;
          }
        }
        cn.Replace = [1, 0], cn.disabled = new cn(cn.Replace, o.bf.transparent, [false, false, false, false]), cn.unblended = new cn(cn.Replace, o.bf.transparent, [true, true, true, true]), cn.alphaBlended = new cn([1, 771], o.bf.transparent, [true, true, true, true]);
        const xs = 2305;
        class lr {
          constructor(e, s, u) {
            this.enable = e, this.mode = s, this.frontFace = u;
          }
        }
        lr.disabled = new lr(false, 1029, xs), lr.backCCW = new lr(true, 1029, xs), lr.frontCCW = new lr(true, 1028, xs);
        class vr {
          constructor(e, s, u) {
            this.func = e, this.mask = s, this.range = u;
          }
        }
        vr.ReadOnly = false, vr.ReadWrite = true, vr.disabled = new vr(519, vr.ReadOnly, [0, 1]);
        const Fo = 7680;
        class Dr {
          constructor(e, s, u, m, y, x) {
            this.test = e, this.ref = s, this.mask = u, this.fail = m, this.depthFail = y, this.pass = x;
          }
        }
        Dr.disabled = new Dr({ func: 519, mask: 0 }, 0, 0, Fo, Fo, Fo);
        const Li = /* @__PURE__ */ new WeakMap();
        function ko(v) {
          var e;
          if (Li.has(v)) return Li.get(v);
          {
            const s = (e = v.getParameter(v.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Li.set(v, s), s;
          }
        }
        class Po {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const s = e.context, u = s.gl;
            this._texFormat = u.RGBA, this._texType = u.UNSIGNED_BYTE;
            const m = new o.aL();
            m.emplaceBack(-1, -1), m.emplaceBack(2, -1), m.emplaceBack(-1, 2);
            const y = new o.aN();
            y.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ao(s.createVertexBuffer(m, So.members), s.createIndexBuffer(y), o.aM.simpleSegment(0, 0, m.length, y.length)), this._resultBuffer = new Uint8Array(4), s.activeTexture.set(u.TEXTURE1);
            const x = u.createTexture();
            u.bindTexture(u.TEXTURE_2D, x), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texImage2D(u.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = s.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(x), ko(u) && (this._pbo = u.createBuffer(), u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.bufferData(u.PIXEL_PACK_BUFFER, 4, u.STREAM_READ), u.bindBuffer(u.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, s) {
            const u = this._updateCount;
            return this._readbackQueue ? u >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : u >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, s), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, s = e.gl;
            e.activeTexture.set(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, s) {
            const u = this._cachedRenderContext.context, m = u.gl;
            if (this._bindFramebuffer(), u.viewport.set([0, 0, this._texWidth, this._texHeight]), u.clear({ color: o.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(u, m.TRIANGLES, vr.disabled, Dr.disabled, cn.unblended, lr.disabled, /* @__PURE__ */ ((y, x) => ({ u_input: y, u_output_expected: x }))(e, s), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ko(m)) {
              m.bindBuffer(m.PIXEL_PACK_BUFFER, this._pbo), m.readBuffer(m.COLOR_ATTACHMENT0), m.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), m.bindBuffer(m.PIXEL_PACK_BUFFER, null);
              const y = m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE, 0);
              m.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: y };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && ko(e)) {
              const s = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (s === e.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (s === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Po._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let s = 0;
            return s += e[0] / 256, s += e[1] / 65536, s += e[2] / 16777216, e[3] < 127 && (s = -s), s / 128;
          }
        }
        const Bl = o.$ / 128;
        function lu(v, e) {
          const s = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, u = s + (v.generateBorders ? 2 : 0), m = s + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), y = u + 1, x = m + 1, T = v.generateBorders ? -1 : 0, M = v.generateBorders || v.extendToNorthPole ? -1 : 0, D = s + (v.generateBorders ? 1 : 0), F = s + (v.generateBorders || v.extendToSouthPole ? 1 : 0), j = y * x, $ = u * m * 6, G = y * x > 65536;
          if (G && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const ee = G || e === "32bit", ue = new Int16Array(2 * j);
          let ce = 0;
          for (let Ce = M; Ce <= F; Ce++) for (let xe = T; xe <= D; xe++) {
            let ke = xe / s * o.$;
            xe === -1 && (ke = -Bl), xe === s + 1 && (ke = o.$ + Bl);
            let ze = Ce / s * o.$;
            Ce === -1 && (ze = v.extendToNorthPole ? o.bh : -Bl), Ce === s + 1 && (ze = v.extendToSouthPole ? o.bi : o.$ + Bl), ue[ce++] = ke, ue[ce++] = ze;
          }
          const pe = ee ? new Uint32Array($) : new Uint16Array($);
          let ge = 0;
          for (let Ce = 0; Ce < m; Ce++) for (let xe = 0; xe < u; xe++) {
            const ke = xe + 1 + Ce * y, ze = xe + (Ce + 1) * y, we = xe + 1 + (Ce + 1) * y;
            pe[ge++] = xe + Ce * y, pe[ge++] = ze, pe[ge++] = ke, pe[ge++] = ke, pe[ge++] = ze, pe[ge++] = we;
          }
          return { vertices: ue.buffer.slice(0), indices: pe.buffer.slice(0), uses32bitIndices: ee };
        }
        const Xs = new o.aK({ fill: new o.bj(128, 2), line: new o.bj(512, 0), tile: new o.bj(128, 32), stencil: new o.bj(128, 1), circle: 3 });
        class La {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Di.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Di.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Xs;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Po(e));
            const s = o.U(this._errorQueryLatitudeDegrees), u = 2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) - 0.5 * Math.PI, m = this._errorMeasurement.updateErrorLoop(s, u), y = z.now();
            m !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = m, this._errorMeasurementLastChangeTime = y);
            const x = Math.min(Math.max((y - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = o.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bl(x));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, s, u, m, y) {
            const x = (y === "stencil" ? Xs.stencil : Xs.tile).getGranularityForZoomLevel(s.z);
            return this._getMesh(e, { granularity: x, generateBorders: u, extendToNorthPole: s.y === 0 && m, extendToSouthPole: s.y === (1 << s.z) - 1 && m });
          }
          _getMesh(e, s) {
            const u = this._getMeshKey(s);
            if (u in this._tileMeshCache) return this._tileMeshCache[u];
            const m = (function(y, x) {
              const T = lu(x, "16bit"), M = o.aL.deserialize({ arrayBuffer: T.vertices, length: T.vertices.byteLength / 2 / 2 }), D = o.aN.deserialize({ arrayBuffer: T.indices, length: T.indices.byteLength / 2 / 3 });
              return new Ao(y.createVertexBuffer(M, So.members), y.createIndexBuffer(D), o.aM.simpleSegment(0, 0, M.length, D.length));
            })(e, s);
            return this._tileMeshCache[u] = m, m;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = z.now();
            let s = false;
            return s = s || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, s = s || this._errorMeasurement && this._errorMeasurement.awaitingQuery, s;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Ol = new o.r({ type: new o.D(o.v.projection.type) });
        class $l extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(Ol), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new kr(), this._verticalPerspectiveProjection = new La();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof o.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, s, u, m, y) {
            return this.currentProjection.getMeshFromTileID(e, s, u, m, y);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function jl(v) {
          const e = Ys(v.worldSize, v.center.lat);
          return 2 * Math.PI * e;
        }
        function eo(v, e, s, u, m) {
          const y = 1 / (1 << m), x = e / o.$ * y + u * y, T = o.bo((v / o.$ * y + s * y) * Math.PI * 2 + Math.PI, 2 * Math.PI), M = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, D = Math.cos(M), F = new Float64Array(3);
          return F[0] = Math.sin(T) * D, F[1] = Math.sin(M), F[2] = Math.cos(T) * D, F;
        }
        function Vn(v) {
          return (function(e, s) {
            const u = Math.cos(s), m = new Float64Array(3);
            return m[0] = Math.sin(e) * u, m[1] = Math.sin(s), m[2] = Math.cos(e) * u, m;
          })(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function Ys(v, e) {
          return v / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Ba(v) {
          const e = Math.asin(v[1]) / Math.PI * 180, s = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (s > 1e-6) {
            const u = v[0] / s, m = Math.acos(v[2] / s), y = (u > 0 ? m : -m) / Math.PI * 180;
            return new o.S(o.aO(y, -180, 180), e);
          }
          return new o.S(0, e);
        }
        function ws(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function wn(v, e) {
          const s = ws(v), u = ws(e);
          return o.ak(u / s);
        }
        function Hd(v, e) {
          const s = v.rotate(e.bearingInRadians), u = e.zoom + wn(e.center.lat, 0), m = o.bk(1 / ws(e.center.lat), 1 / ws(Math.min(Math.abs(e.center.lat), 60)), o.bn(u, 7, 3, 0, 1)), y = 360 / jl({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new o.S(e.center.lng - s.x * y * m, o.ah(e.center.lat + s.y * y, -o.ai, o.ai));
        }
        function Oa(v) {
          const e = 0.5 * v, s = Math.sin(e), u = Math.cos(e);
          return Math.log(s + u) - Math.log(u - s);
        }
        function cu(v, e, s, u) {
          const m = v.lat + s * u;
          if (Math.abs(s) > 1) {
            const y = (Math.sign(v.lat + s) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, x = Math.abs(v.lat + s) * Math.PI / 180, T = Oa(y + u * (x - y)), M = Oa(y), D = Oa(x);
            return new o.S(v.lng + e * ((T - M) / (D - M)), m);
          }
          return new o.S(v.lng + e * u, m);
        }
        class Jp {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e, s, u, m) {
            const y = `${e.z}_${e.x}_${e.y}_${(m == null ? void 0 : m.terrain) ? "t" : ""}`, x = this._cache.get(y);
            if (x) return x;
            const T = this._cachePrevious.get(y);
            if (T) return this._cache.set(y, T), T;
            const M = this._boundingVolumeFactory(e, s, u, m);
            return this._cache.set(y, M), this._hadAnyChanges = true, M;
          }
        }
        class Ks {
          constructor(e, s, u, m) {
            this.min = u, this.max = m, this.points = e, this.planes = s;
          }
          static fromAabb(e, s) {
            const u = [];
            for (let m = 0; m < 8; m++) u.push([1 & ~m ? e[0] : s[0], (m >> 1 & 1) == 1 ? s[1] : e[1], (m >> 2 & 1) == 1 ? s[2] : e[2]]);
            return new Ks(u, [[-1, 0, 0, s[0]], [1, 0, 0, -e[0]], [0, -1, 0, s[1]], [0, 1, 0, -e[1]], [0, 0, -1, s[2]], [0, 0, 1, -e[2]]], e, s);
          }
          static fromCenterSizeAngles(e, s, u) {
            const m = o.br([], u[0], u[1], u[2]), y = o.bs([], [s[0], 0, 0], m), x = o.bs([], [0, s[1], 0], m), T = o.bs([], [0, 0, s[2]], m), M = [...e], D = [...e];
            for (let j = 0; j < 8; j++) for (let $ = 0; $ < 3; $++) {
              const G = e[$] + y[$] * (1 & ~j ? -1 : 1) + x[$] * ((j >> 1 & 1) == 1 ? 1 : -1) + T[$] * ((j >> 2 & 1) == 1 ? 1 : -1);
              M[$] = Math.min(M[$], G), D[$] = Math.max(D[$], G);
            }
            const F = [];
            for (let j = 0; j < 8; j++) {
              const $ = [...e];
              o.aS($, $, o.aR([], y, 1 & ~j ? -1 : 1)), o.aS($, $, o.aR([], x, (j >> 1 & 1) == 1 ? 1 : -1)), o.aS($, $, o.aR([], T, (j >> 2 & 1) == 1 ? 1 : -1)), F.push($);
            }
            return new Ks(F, [[...y, -o.aX(y, F[0])], [...x, -o.aX(x, F[0])], [...T, -o.aX(T, F[0])], [-y[0], -y[1], -y[2], -o.aX(y, F[7])], [-x[0], -x[1], -x[2], -o.aX(x, F[7])], [-T[0], -T[1], -T[2], -o.aX(T, F[7])]], M, D);
          }
          intersectsFrustum(e) {
            let s = true;
            const u = this.points.length, m = this.planes.length, y = e.planes.length, x = e.points.length;
            for (let T = 0; T < y; T++) {
              const M = e.planes[T];
              let D = 0;
              for (let F = 0; F < u; F++) {
                const j = this.points[F];
                M[0] * j[0] + M[1] * j[1] + M[2] * j[2] + M[3] >= 0 && D++;
              }
              if (D === 0) return 0;
              D < u && (s = false);
            }
            if (s) return 2;
            for (let T = 0; T < m; T++) {
              const M = this.planes[T];
              let D = 0;
              for (let F = 0; F < x; F++) {
                const j = e.points[F];
                M[0] * j[0] + M[1] * j[1] + M[2] * j[2] + M[3] >= 0 && D++;
              }
              if (D === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const s = this.points.length;
            let u = 0;
            for (let m = 0; m < s; m++) {
              const y = this.points[m];
              e[0] * y[0] + e[1] * y[1] + e[2] * y[2] + e[3] >= 0 && u++;
            }
            return u === s ? 2 : u === 0 ? 0 : 1;
          }
        }
        function Xn(v, e, s) {
          const u = v - e;
          return u < 0 ? -u : Math.max(0, u - s);
        }
        function $a(v, e, s, u, m) {
          const y = v - s;
          let x;
          return x = y < 0 ? Math.min(-y, 1 + y - m) : y > 1 ? Math.min(Math.max(y - m, 0), 1 - y) : 0, Math.max(x, Xn(e, u, m));
        }
        class To {
          constructor() {
            this._boundingVolumeCache = new Jp(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, s, u, m) {
            const y = 1 << u.z, x = 1 / y, T = u.x / y, M = u.y / y;
            let D = 2;
            return D = Math.min(D, $a(e, s, T, M, x)), D = Math.min(D, $a(e, s, T + 0.5, -M - x, x)), D = Math.min(D, $a(e, s, T + 0.5, 2 - M - x, x)), D;
          }
          getWrap(e, s, u) {
            const m = 1 << s.z, y = 1 / m, x = s.x / m, T = Xn(e.x, x, y), M = Xn(e.x, x - 1, y), D = Xn(e.x, x + 1, y), F = Math.min(T, M, D);
            return F === D ? 1 : F === M ? -1 : 0;
          }
          allowVariableZoom(e, s) {
            return wt(e, s) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e, s, u, m) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, s, u, m);
          }
          _computeTileBoundingVolume(e, s, u, m) {
            var y, x;
            let T = 0, M = 0;
            if (m == null ? void 0 : m.terrain) {
              const D = new o.Z(e.z, s, e.z, e.x, e.y), F = m.terrain.getMinMaxElevation(D);
              T = (y = F.minElevation) !== null && y !== void 0 ? y : Math.min(0, u), M = (x = F.maxElevation) !== null && x !== void 0 ? x : Math.max(0, u);
            }
            if (T /= o.bu, M /= o.bu, T += 1, M += 1, e.z <= 0) return Ks.fromAabb([-M, -M, -M], [M, M, M]);
            if (e.z === 1) return Ks.fromAabb([e.x === 0 ? -M : 0, e.y === 0 ? 0 : -M, -M], [e.x === 0 ? 0 : M, e.y === 0 ? M : 0, M]);
            {
              const D = [eo(0, 0, e.x, e.y, e.z), eo(o.$, 0, e.x, e.y, e.z), eo(o.$, o.$, e.x, e.y, e.z), eo(0, o.$, e.x, e.y, e.z)], F = [];
              for (const Ze of D) F.push(o.aR([], Ze, M));
              if (M !== T) for (const Ze of D) F.push(o.aR([], Ze, T));
              e.y === 0 && F.push([0, 1, 0]), e.y === (1 << e.z) - 1 && F.push([0, -1, 0]);
              const j = [1, 1, 1], $ = [-1, -1, -1];
              for (const Ze of F) for (let Je = 0; Je < 3; Je++) j[Je] = Math.min(j[Je], Ze[Je]), $[Je] = Math.max($[Je], Ze[Je]);
              const G = eo(o.$ / 2, o.$ / 2, e.x, e.y, e.z), ee = o.aW([], [0, 1, 0], G);
              o.aV(ee, ee);
              const ue = o.aW([], G, ee);
              o.aV(ue, ue);
              const ce = o.aW([], D[2], D[1]);
              o.aV(ce, ce);
              const pe = o.aW([], D[0], D[3]);
              o.aV(pe, pe), F.push(o.aR([], G, M)), e.y >= (1 << e.z) / 2 && F.push(o.aR([], eo(o.$ / 2, 0, e.x, e.y, e.z), M)), e.y < (1 << e.z) / 2 && F.push(o.aR([], eo(o.$ / 2, o.$, e.x, e.y, e.z), M));
              const ge = ja(G, F), Ce = ja(ue, F), xe = [-G[0], -G[1], -G[2], ge.max], ke = [G[0], G[1], G[2], -ge.min], ze = [-ue[0], -ue[1], -ue[2], Ce.max], we = [ue[0], ue[1], ue[2], -Ce.min], je = [...ce, 0], Qe = [...pe, 0], qe = [];
              return e.y === 0 ? qe.push(o.bt(Qe, je, xe), o.bt(Qe, je, ke)) : qe.push(o.bt(ze, je, xe), o.bt(ze, je, ke), o.bt(ze, Qe, xe), o.bt(ze, Qe, ke)), e.y === (1 << e.z) - 1 ? qe.push(o.bt(Qe, je, xe), o.bt(Qe, je, ke)) : qe.push(o.bt(we, je, xe), o.bt(we, je, ke), o.bt(we, Qe, xe), o.bt(we, Qe, ke)), new Ks(qe, [xe, ke, ze, we, je, Qe], j, $);
            }
          }
        }
        function ja(v, e) {
          let s = 1 / 0, u = -1 / 0;
          for (const m of e) {
            const y = o.aX(v, m);
            s = Math.min(s, y), u = Math.max(u, y);
          }
          return { min: s, max: u };
        }
        class Na {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, s, u) {
            return this._helper.interpolatePadding(e, s, u);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, s) {
            this._helper.resize(e, s);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, s) {
            this._helper.overrideNearFarZ(e, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = o.bv(), this._projectionMatrix = o.b9(), this._globeViewProjMatrix32f = o.b8(), this._globeViewProjMatrixNoCorrection = o.b9(), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), this._globeProjMatrixInverted = o.b9(), this._cameraPosition = o.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new ui({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, s) => this.getConstrained(e, s) }), this._coveringTilesDetailsProvider = new To();
          }
          clone() {
            const e = new Na();
            return e.apply(this), e;
          }
          apply(e, s) {
            this._globeLatitudeErrorCorrectionRadians = s || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = o.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: s, applyGlobeMatrix: u } = e, m = this._helper.getMercatorTileCoordinates(s);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: m, clippingPlane: this._cachedClippingPlane, projectionTransition: u ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const s = this.pitchInRadians, u = this.cameraToCenterDistance / e, m = Math.sin(s) * u, y = Math.cos(s) * u + 1, x = 1 / Math.sqrt(m * m + y * y) * 1;
            let T = -m, M = y;
            const D = Math.sqrt(T * T + M * M);
            T /= D, M /= D;
            const F = [0, T, M];
            o.bw(F, F, [0, 0, 0], -this.bearingInRadians), o.bx(F, F, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.by(F, F, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / o.aZ(F);
            return o.aR(F, F, j), [...F, -x * j];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Vn(e));
          }
          transformLightDirection(e) {
            const s = this._helper._center.lng * Math.PI / 180, u = this._helper._center.lat * Math.PI / 180, m = Math.cos(u), y = [Math.sin(s) * m, Math.sin(u), Math.cos(s) * m], x = [y[2], 0, -y[0]], T = [0, 0, 0];
            o.aW(T, x, y), o.aV(x, x), o.aV(T, T);
            const M = [0, 0, 0];
            return o.aV(M, [x[0] * e[0] + T[0] * e[1] + y[0] * e[2], x[1] * e[0] + T[1] * e[1] + y[1] * e[2], x[2] * e[0] + T[2] * e[1] + y[2] * e[2]]), M;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, s, u) {
            const m = (function(T, M, D) {
              const F = 1 / (1 << D.z);
              return new o.a1(T / o.$ * F + D.x * F, M / o.$ * F + D.y * F);
            })(e, s, u.canonical), y = (x = m.y, [o.bo(m.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(y[1]);
          }
          projectTileCoordinates(e, s, u, m) {
            const y = u.canonical, x = eo(e, s, y.x, y.y, y.z), T = 1 + (m ? m(e, s) : 0) / o.bu, M = [x[0] * T, x[1] * T, x[2] * T, 1];
            o.aw(M, M, this._globeViewProjMatrixNoCorrection);
            const D = this._cachedClippingPlane, F = D[0] * x[0] + D[1] * x[1] + D[2] * x[2] + D[3] < 0;
            return { point: new o.P(M[0] / M[3], M[1] / M[3]), signedDistanceFromCamera: M[3], isOccluded: F };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Ys(this.worldSize, this.center.lat), s = o.ba(), u = o.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), o.b4(s, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const m = this.centerOffset;
            s[8] = 2 * -m.x / this._helper._width, s[9] = 2 * m.y / this._helper._height, this._projectionMatrix = o.b5(s), this._globeProjMatrixInverted = o.ba(), o.aq(this._globeProjMatrixInverted, s), o.M(s, s, [0, 0, -this.cameraToCenterDistance]), o.b6(s, s, this.rollInRadians), o.b7(s, s, -this.pitchInRadians), o.b6(s, s, this.bearingInRadians), o.M(s, s, [0, 0, -e]);
            const y = o.bp();
            y[0] = e, y[1] = e, y[2] = e, o.b7(u, s, this.center.lat * Math.PI / 180), o.bz(u, u, -this.center.lng * Math.PI / 180), o.N(u, u, y), this._globeViewProjMatrixNoCorrection = u, o.b7(s, s, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.bz(s, s, -this.center.lng * Math.PI / 180), o.N(s, s, y), this._globeViewProjMatrix32f = new Float32Array(s), this._globeViewProjMatrixNoCorrectionInverted = o.ba(), o.aq(this._globeViewProjMatrixNoCorrectionInverted, u);
            const x = o.bp();
            this._cameraPosition = o.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, o.bw(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), o.bx(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), o.bw(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), o.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bx(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), o.by(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const T = o.b5(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(T, T, [1, 1, -1]), this._cachedFrustum = Mn.fromInvProjectionMatrix(T, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const s = o.ba();
            return o.ag(s), s;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new o.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, s) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const u = Vn(e);
            o.aR(u, u, 1 + s / o.bu);
            const m = o.bv();
            return o.aw(m, [u[0], u[1], u[2], 1], this._globeViewProjMatrixNoCorrection), m[2] / m[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, s = 0.5 * this.height, u = [new o.P(0, 0), new o.P(e, 0), new o.P(this.width, 0), new o.P(this.width, s), new o.P(this.width, this.height), new o.P(e, this.height), new o.P(0, this.height), new o.P(0, s)], m = [];
            for (const j of u) m.push(this.unprojectScreenPoint(j));
            let y = 0, x = 0, T = 0, M = 0;
            const D = this.center;
            for (const j of m) {
              const $ = o.bA(D.lng, j.lng), G = o.bA(D.lat, j.lat);
              $ < x && (x = $), $ > y && (y = $), G < M && (M = G), G > T && (T = G);
            }
            const F = [D.lng + x, D.lat + M, D.lng + y, D.lat + T];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (F[3] = 90, F[0] = -180, F[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (F[1] = -90, F[0] = -180, F[2] = 180), new yt(F);
          }
          getConstrained(e, s) {
            const u = o.ah(e.lat, -o.ai, o.ai), m = o.ah(+s, this.minZoom + wn(0, u), this.maxZoom);
            return { center: new o.S(e.lng, u), zoom: m };
          }
          calculateCenterFromCameraLngLatAlt(e, s, u, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, s, u, m);
          }
          setLocationAtPoint(e, s) {
            const u = Vn(this.unprojectScreenPoint(s)), m = Vn(e), y = o.bp();
            o.bB(y);
            const x = o.bp();
            o.by(x, u, y, -this.center.lng * Math.PI / 180), o.bx(x, x, y, this.center.lat * Math.PI / 180);
            const T = m[0] * m[0] + m[2] * m[2], M = x[0] * x[0];
            if (T < M) return;
            const D = Math.sqrt(T - M), F = -D, j = o.bC(m[0], m[2], x[0], D), $ = o.bC(m[0], m[2], x[0], F), G = o.bp();
            o.by(G, m, y, -j);
            const ee = o.bC(G[1], G[2], x[1], x[2]), ue = o.bp();
            o.by(ue, m, y, -$);
            const ce = o.bC(ue[1], ue[2], x[1], x[2]), pe = 0.5 * Math.PI, ge = ee >= -pe && ee <= pe, Ce = ce >= -pe && ce <= pe;
            let xe, ke;
            if (ge && Ce) {
              const Qe = this.center.lng * Math.PI / 180, qe = this.center.lat * Math.PI / 180;
              o.bD(j, Qe) + o.bD(ee, qe) < o.bD($, Qe) + o.bD(ce, qe) ? (xe = j, ke = ee) : (xe = $, ke = ce);
            } else if (ge) xe = j, ke = ee;
            else {
              if (!Ce) return;
              xe = $, ke = ce;
            }
            const ze = xe / Math.PI * 180, we = ke / Math.PI * 180, je = this.center.lat;
            this.setCenter(new o.S(ze, o.ah(we, -90, 90))), this.setZoom(this.zoom + wn(je, this.center.lat));
          }
          locationToScreenPoint(e, s) {
            const u = Vn(e);
            if (s) {
              const m = s.getElevationForLngLatZoom(e, this._helper._tileZoom);
              o.aR(u, u, 1 + m / o.bu);
            }
            return this._projectSurfacePointToScreen(u);
          }
          _projectSurfacePointToScreen(e) {
            const s = o.bv();
            return o.aw(s, [...e, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], new o.P((0.5 * s[0] + 0.5) * this.width, (0.5 * -s[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, s) {
            if (s) {
              const u = s.pointCoordinate(e);
              if (u) return u;
            }
            return o.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, s) {
            var u;
            return (u = this.screenPointToMercatorCoordinate(e, s)) === null || u === void 0 ? void 0 : u.toLngLat();
          }
          isPointOnMapSurface(e, s) {
            const u = this._cameraPosition, m = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(u, m);
          }
          getRayDirectionFromPixel(e) {
            const s = o.bv();
            s[0] = e.x / this.width * 2 - 1, s[1] = -1 * (e.y / this.height * 2 - 1), s[2] = 1, s[3] = 1, o.aw(s, s, this._globeViewProjMatrixNoCorrectionInverted), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3];
            const u = o.bp();
            u[0] = s[0] - this._cameraPosition[0], u[1] = s[1] - this._cameraPosition[1], u[2] = s[2] - this._cameraPosition[2];
            const m = o.bp();
            return o.aV(m, u), m;
          }
          isSurfacePointVisible(e) {
            const s = this._cachedClippingPlane;
            return s[0] * e[0] + s[1] * e[1] + s[2] * e[2] + s[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return false;
            const s = o.bv();
            return o.aw(s, [...e, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3], s[0] > -1 && s[0] < 1 && s[1] > -1 && s[1] < 1 && s[2] > -1 && s[2] < 1;
          }
          rayPlanetIntersection(e, s) {
            const u = o.aX(e, s), m = o.bp(), y = o.bp();
            o.aR(y, s, u), o.aU(m, e, y);
            const x = 1 - o.aX(m, m);
            if (x < 0) return null;
            const T = o.aX(e, e) - 1, M = -u + (u < 0 ? 1 : -1) * Math.sqrt(x), D = T / M, F = M;
            return { tMin: Math.min(D, F), tMax: Math.max(D, F) };
          }
          unprojectScreenPoint(e) {
            const s = this._cameraPosition, u = this.getRayDirectionFromPixel(e), m = this.rayPlanetIntersection(s, u);
            if (m) {
              const F = o.bp();
              o.aS(F, s, [u[0] * m.tMin, u[1] * m.tMin, u[2] * m.tMin]);
              const j = o.bp();
              return o.aV(j, F), Ba(j);
            }
            const y = this._cachedClippingPlane, x = y[0] * u[0] + y[1] * u[1] + y[2] * u[2], T = -o.b1(y, s) / x, M = o.bp();
            if (T > 0) o.aS(M, s, [u[0] * T, u[1] * T, u[2] * T]);
            else {
              const F = o.bp();
              o.aS(F, s, [2 * u[0], 2 * u[1], 2 * u[2]]);
              const j = o.b1(this._cachedClippingPlane, F);
              o.aU(M, F, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j]);
            }
            const D = (function(F) {
              const j = o.bp();
              return j[0] = F[0] * -F[3], j[1] = F[1] * -F[3], j[2] = F[2] * -F[3], { center: j, radius: Math.sqrt(1 - F[3] * F[3]) };
            })(y);
            return Ba((function(F, j, $) {
              const G = o.bp();
              o.aU(G, $, F);
              const ee = o.bp();
              return o.bq(ee, F, G, j / o.a$(G)), ee;
            })(D.center, D.radius, M));
          }
          getMatrixForModel(e, s) {
            const u = o.S.convert(e), m = 1 / o.bu, y = o.b9();
            return o.bz(y, y, u.lng / 180 * Math.PI), o.b7(y, y, -u.lat / 180 * Math.PI), o.M(y, y, [0, 0, 1 + s / o.bu]), o.b7(y, y, 0.5 * Math.PI), o.N(y, y, [m, m, m]), y;
          }
          getProjectionDataForCustomLayer(e = true) {
            const s = this.getProjectionData({ overscaledTileID: new o.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return s.tileMercatorCoords = [0, 0, 1, 1], s;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class Va {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, s, u) {
            return this._helper.interpolatePadding(e, s, u);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, s, u = true) {
            this._helper.resize(e, s, u);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, s) {
            this._helper.overrideNearFarZ(e, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, s) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = s, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new ui({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, s) => this.getConstrained(e, s) }), this._globeness = 1, this._mercatorTransform = new tn(), this._verticalPerspectiveTransform = new Na();
          }
          clone() {
            const e = new Va();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const s = this._mercatorTransform.getProjectionData(e), u = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? u.mainMatrix : s.mainMatrix, clippingPlane: u.clippingPlane, tileMercatorCoords: u.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: s.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return o.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return o.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, s, u) {
            const m = this._mercatorTransform.getPitchedTextCorrection(e, s, u), y = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, s, u);
            return o.bk(m, y, this._globeness);
          }
          projectTileCoordinates(e, s, u, m) {
            return this.currentTransform.projectTileCoordinates(e, s, u, m);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, s) {
            return this.currentTransform.lngLatToCameraDepth(e, s);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, s) {
            return this.currentTransform.getConstrained(e, s);
          }
          calculateCenterFromCameraLngLatAlt(e, s, u, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, s, u, m);
          }
          setLocationAtPoint(e, s) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, s), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, s), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, s) {
            return this.currentTransform.locationToScreenPoint(e, s);
          }
          screenPointToMercatorCoordinate(e, s) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, s);
          }
          screenPointToLocation(e, s) {
            return this.currentTransform.screenPointToLocation(e, s);
          }
          isPointOnMapSurface(e, s) {
            return this.currentTransform.isPointOnMapSurface(e, s);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, s) {
            return this.currentTransform.getMatrixForModel(e, s);
          }
          getProjectionDataForCustomLayer(e = true) {
            const s = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return s;
            const u = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return u.fallbackMatrix = s.mainMatrix, u;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class si {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e, s) {
            const u = Hd(e, s);
            return Math.abs(u.lng - s.center.lng) > 180 && (u.lng = s.center.lng + 179.5 * Math.sign(u.lng - s.center.lng)), { easingCenter: u, easingOffset: new o.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, s) {
            const u = e.around, m = s.screenPointToLocation(u);
            e.bearingDelta && s.setBearing(s.bearing + e.bearingDelta), e.pitchDelta && s.setPitch(s.pitch + e.pitchDelta), e.rollDelta && s.setRoll(s.roll + e.rollDelta);
            const y = s.zoom;
            e.zoomDelta && s.setZoom(s.zoom + e.zoomDelta);
            const x = s.zoom - y;
            if (x === 0) return;
            const T = o.bA(s.center.lng, m.lng), M = T / (Math.abs(T / 180) + 1), D = o.bA(s.center.lat, m.lat), F = s.getRayDirectionFromPixel(u), j = s.cameraPosition, $ = -1 * o.aX(j, F), G = o.bp();
            o.aS(G, j, [F[0] * $, F[1] * $, F[2] * $]);
            const ee = o.aZ(G) - 1, ue = Math.exp(0.5 * -Math.max(ee - 0.3, 0)), ce = Ys(s.worldSize, s.center.lat) / Math.min(s.width, s.height), pe = o.bn(ce, 0.9, 0.5, 1, 0.25), ge = (1 - o.af(-x)) * Math.min(ue, pe), Ce = s.center.lat, xe = s.zoom, ke = new o.S(s.center.lng + M * ge, o.ah(s.center.lat + D * ge, -o.ai, o.ai));
            s.setLocationAtPoint(m, u);
            const ze = s.center, we = o.bn(Math.abs(T), 45, 85, 0, 1), je = o.bn(ce, 0.75, 0.35, 0, 1), Qe = Math.pow(Math.max(we, je), 0.25), qe = o.bA(ze.lng, ke.lng), Ze = o.bA(ze.lat, ke.lat);
            s.setCenter(new o.S(ze.lng + qe * Qe, ze.lat + Ze * Qe).wrap()), s.setZoom(xe + wn(Ce, s.center.lat));
          }
          handleMapControlsPan(e, s, u) {
            if (!e.panDelta) return;
            const m = s.center.lat, y = s.zoom;
            s.setCenter(Hd(e.panDelta, s).wrap()), s.setZoom(y + wn(m, s.center.lat));
          }
          cameraForBoxAndBearing(e, s, u, m, y) {
            const x = Fi(e, s, u, m, y), T = s.left / y.width * 2 - 1, M = (y.width - s.right) / y.width * 2 - 1, D = s.top / y.height * -2 + 1, F = (y.height - s.bottom) / y.height * -2 + 1, j = o.bA(u.getWest(), u.getEast()) < 0, $ = j ? u.getEast() : u.getWest(), G = j ? u.getWest() : u.getEast(), ee = Math.max(u.getNorth(), u.getSouth()), ue = Math.min(u.getNorth(), u.getSouth()), ce = $ + 0.5 * o.bA($, G), pe = ee + 0.5 * o.bA(ee, ue), ge = y.clone();
            ge.setCenter(x.center), ge.setBearing(x.bearing), ge.setPitch(0), ge.setRoll(0), ge.setZoom(x.zoom);
            const Ce = ge.modelViewProjectionMatrix, xe = [Vn(u.getNorthWest()), Vn(u.getNorthEast()), Vn(u.getSouthWest()), Vn(u.getSouthEast()), Vn(new o.S(G, pe)), Vn(new o.S($, pe)), Vn(new o.S(ce, ee)), Vn(new o.S(ce, ue))], ke = Vn(x.center);
            let ze = Number.POSITIVE_INFINITY;
            for (const we of xe) T < 0 && (ze = si.getLesserNonNegativeNonNull(ze, si.solveVectorScale(we, ke, Ce, "x", T))), M > 0 && (ze = si.getLesserNonNegativeNonNull(ze, si.solveVectorScale(we, ke, Ce, "x", M))), D > 0 && (ze = si.getLesserNonNegativeNonNull(ze, si.solveVectorScale(we, ke, Ce, "y", D))), F < 0 && (ze = si.getLesserNonNegativeNonNull(ze, si.solveVectorScale(we, ke, Ce, "y", F)));
            if (Number.isFinite(ze) && ze !== 0) return x.zoom = ge.zoom + o.ak(ze), x;
            Zd();
          }
          handleJumpToCenterZoom(e, s) {
            const u = e.center.lat, m = e.getConstrained(s.center ? o.S.convert(s.center) : e.center, e.zoom).center;
            e.setCenter(m.wrap());
            const y = s.zoom !== void 0 ? +s.zoom : e.zoom + wn(u, m.lat);
            e.zoom !== y && e.setZoom(y);
          }
          handleEaseTo(e, s) {
            const u = e.zoom, m = e.center, y = e.padding, x = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, T = { roll: s.roll === void 0 ? e.roll : s.roll, pitch: s.pitch === void 0 ? e.pitch : s.pitch, bearing: s.bearing === void 0 ? e.bearing : s.bearing }, M = s.zoom !== void 0, D = !e.isPaddingEqual(s.padding);
            let F = false;
            const j = s.center ? o.S.convert(s.center) : m, $ = e.getConstrained(j, u).center;
            Fl(e, $);
            const G = e.clone();
            G.setCenter($), G.setZoom(M ? +s.zoom : u + wn(m.lat, j.lat)), G.setBearing(s.bearing);
            const ee = new o.P(o.ah(e.centerPoint.x + s.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + s.offsetAsPoint.y, 0, e.height));
            G.setLocationAtPoint($, ee);
            const ue = (s.offset && s.offsetAsPoint.mag()) > 0 ? G.center : $, ce = M ? +s.zoom : u + wn(m.lat, ue.lat), pe = u + wn(m.lat, 0), ge = ce + wn(ue.lat, 0), Ce = o.bA(m.lng, ue.lng), xe = o.bA(m.lat, ue.lat), ke = o.af(ge - pe);
            return F = ce !== u, { easeFunc: (ze) => {
              if (o.be(x, T) || hi({ startEulerAngles: x, endEulerAngles: T, tr: e, k: ze, useSlerp: x.roll != T.roll }), D && e.interpolatePadding(y, s.padding, ze), s.around) o.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const we = ge > pe ? Math.min(2, ke) : Math.max(0.5, ke), je = Math.pow(we, 1 - ze), Qe = cu(m, Ce, xe, ze * je);
                e.setCenter(Qe.wrap());
              }
              if (F) {
                const we = o.C.number(pe, ge, ze) + wn(0, e.center.lat);
                e.setZoom(we);
              }
            }, isZooming: F, elevationCenter: ue };
          }
          handleFlyTo(e, s) {
            const u = s.zoom !== void 0, m = e.center, y = e.zoom, x = e.padding, T = !e.isPaddingEqual(s.padding), M = e.getConstrained(o.S.convert(s.center || s.locationAtOffset), y).center, D = u ? +s.zoom : e.zoom + wn(e.center.lat, M.lat), F = e.clone();
            F.setCenter(M), F.setZoom(D), F.setBearing(s.bearing);
            const j = new o.P(o.ah(e.centerPoint.x + s.offsetAsPoint.x, 0, e.width), o.ah(e.centerPoint.y + s.offsetAsPoint.y, 0, e.height));
            F.setLocationAtPoint(M, j);
            const $ = F.center;
            Fl(e, $);
            const G = (function(xe, ke, ze) {
              const we = Vn(ke), je = Vn(ze), Qe = o.aX(we, je), qe = Math.acos(Qe), Ze = jl(xe);
              return qe / (2 * Math.PI) * Ze;
            })(e, m, $), ee = y + wn(m.lat, 0), ue = D + wn($.lat, 0), ce = o.af(ue - ee);
            let pe;
            if (typeof s.minZoom == "number") {
              const xe = +s.minZoom + wn($.lat, 0), ke = Math.min(xe, ee, ue) + wn(0, $.lat), ze = e.getConstrained($, ke).zoom + wn($.lat, 0);
              pe = o.af(ze - ee);
            }
            const ge = o.bA(m.lng, $.lng), Ce = o.bA(m.lat, $.lat);
            return { easeFunc: (xe, ke, ze, we) => {
              const je = cu(m, ge, Ce, ze);
              T && e.interpolatePadding(x, s.padding, xe);
              const Qe = xe === 1 ? $ : je;
              e.setCenter(Qe.wrap());
              const qe = ee + o.ak(ke);
              e.setZoom(xe === 1 ? D : qe + wn(0, Qe.lat));
            }, scaleOfZoom: ce, targetCenter: $, scaleOfMinZoom: pe, pixelPathLength: G };
          }
          static solveVectorScale(e, s, u, m, y) {
            const x = m === "x" ? [u[0], u[4], u[8], u[12]] : [u[1], u[5], u[9], u[13]], T = [u[3], u[7], u[11], u[15]], M = e[0] * x[0] + e[1] * x[1] + e[2] * x[2], D = e[0] * T[0] + e[1] * T[1] + e[2] * T[2], F = s[0] * x[0] + s[1] * x[1] + s[2] * x[2], j = s[0] * T[0] + s[1] * T[1] + s[2] * T[2];
            return F + y * D === M + y * j || T[3] * (M - F) + x[3] * (j - D) + M * j == F * D ? null : (F + x[3] - y * j - y * T[3]) / (F - M - y * j + y * D);
          }
          static getLesserNonNegativeNonNull(e, s) {
            return s !== null && s >= 0 && s < e ? s : e;
          }
        }
        class Xd {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new oi(), this._verticalPerspectiveCameraHelper = new si();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, s) {
            return this.currentHelper.handlePanInertia(e, s);
          }
          handleMapControlsRollPitchBearingZoom(e, s) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, s);
          }
          handleMapControlsPan(e, s, u) {
            this.currentHelper.handleMapControlsPan(e, s, u);
          }
          cameraForBoxAndBearing(e, s, u, m, y) {
            return this.currentHelper.cameraForBoxAndBearing(e, s, u, m, y);
          }
          handleJumpToCenterZoom(e, s) {
            this.currentHelper.handleJumpToCenterZoom(e, s);
          }
          handleEaseTo(e, s) {
            return this.currentHelper.handleEaseTo(e, s);
          }
          handleFlyTo(e, s) {
            return this.currentHelper.handleFlyTo(e, s);
          }
        }
        const Nl = (v, e) => o.y(v, e && e.filter(((s) => s.identifier !== "source.canvas"))), Qp = o.bE();
        class uu extends o.E {
          constructor(e, s = {}) {
            var u, m;
            super(), this._rtlPluginLoaded = () => {
              for (const x in this.sourceCaches) {
                const T = this.sourceCaches[x].getSource().type;
                T !== "vector" && T !== "geojson" || this.sourceCaches[x].reload();
              }
            }, this.map = e, this.dispatcher = new vt(Yt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((x, T) => this.getGlyphs(x, T))), this.dispatcher.registerMessageHandler("GI", ((x, T) => this.getImages(x, T))), this.imageManager = new Q(), this.imageManager.setEventedParent(this);
            const y = ((u = e._container) === null || u === void 0 ? void 0 : u.lang) || typeof document < "u" && ((m = document.documentElement) === null || m === void 0 ? void 0 : m.lang) || void 0;
            this.glyphManager = new Ne(e._requestManager, s.localIdeographFontFamily, y), this.lineAtlas = new Ye(256, 512), this.crossTileSymbolIndex = new Qo(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bF(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bG()), on().on(st, this._rtlPluginLoaded), this.on("data", ((x) => {
              if (x.dataType !== "source" || x.sourceDataType !== "metadata") return;
              const T = this.sourceCaches[x.sourceId];
              if (!T) return;
              const M = T.getSource();
              if (M && M.vectorLayerIds) for (const D in this._layers) {
                const F = this._layers[D];
                F.source === M.id && this._validateLayer(F);
              }
            }));
          }
          setGlobalStateProperty(e, s) {
            var u, m, y;
            this._checkLoaded();
            const x = s === null ? (y = (m = (u = this.stylesheet.state) === null || u === void 0 ? void 0 : u[e]) === null || m === void 0 ? void 0 : m.default) !== null && y !== void 0 ? y : null : s;
            if (o.bH(x, this._globalState[e])) return this;
            this._globalState[e] = x, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const s = [];
            for (const u in e) !o.bH(this._globalState[u], e[u].default) && (s.push(u), this._globalState[u] = e[u].default);
            this._applyGlobalStateChanges(s);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const s = /* @__PURE__ */ new Set();
            for (const u in this._layers) {
              const m = this._layers[u], y = m.getLayoutAffectingGlobalStateRefs(), x = m.getPaintAffectingGlobalStateRefs();
              for (const T of e) if (y.has(T) && s.add(m.source), x.has(T)) for (const { name: M, value: D } of x.get(T)) this._updatePaintProperty(m, M, D);
            }
            for (const u in this.sourceCaches) s.has(u) && (this._reloadSource(u), this._changed = true);
          }
          loadURL(e, s = {}, u) {
            this.fire(new o.l("dataloading", { dataType: "style" })), s.validate = typeof s.validate != "boolean" || s.validate;
            const m = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const y = this._loadStyleRequest;
            o.j(m, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, s, u);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !y.signal.aborted && this.fire(new o.k(x));
            }));
          }
          loadJSON(e, s = {}, u) {
            this.fire(new o.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), z.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, s.validate = s.validate !== false, this._load(e, s, u);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", { dataType: "style" })), this._load(Qp, { validate: false });
          }
          _load(e, s, u) {
            var m, y, x;
            let T = s.transformStyle ? s.transformStyle(u, e) : e;
            if (!s.validate || !Nl(this, o.z(T))) {
              T = Object.assign({}, T), this._loaded = true, this.stylesheet = T;
              for (const M in T.sources) this.addSource(M, T.sources[M], { validate: false });
              T.sprite ? this._loadSprite(T.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(T.glyphs), this._createLayers(), this.light = new at(this.stylesheet.light), this._setProjectionInternal(((m = this.stylesheet.projection) === null || m === void 0 ? void 0 : m.type) || "mercator"), this.sky = new ht(this.stylesheet.sky), this.map.setTerrain((y = this.stylesheet.terrain) !== null && y !== void 0 ? y : null), this.setGlobalState((x = this.stylesheet.state) !== null && x !== void 0 ? x : null), this.fire(new o.l("data", { dataType: "style" })), this.fire(new o.l("style.load"));
            }
          }
          _createLayers() {
            const e = o.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map(((s) => s.id)), this._layers = {}, this._serializedLayers = null;
            for (const s of e) {
              const u = o.bJ(s);
              u.setEventedParent(this, { layer: { id: s.id } }), this._layers[s.id] = u;
            }
          }
          _loadSprite(e, s = false, u = void 0) {
            let m;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(y, x, T, M) {
              return o._(this, void 0, void 0, (function* () {
                const D = q(y), F = T > 1 ? "@2x" : "", j = {}, $ = {};
                for (const { id: G, url: ee } of D) {
                  const ue = x.transformRequest(he(ee, F, ".json"), "SpriteJSON");
                  j[G] = o.j(ue, M);
                  const ce = x.transformRequest(he(ee, F, ".png"), "SpriteImage");
                  $[G] = X.getImage(ce, M);
                }
                return yield Promise.all([...Object.values(j), ...Object.values($)]), (function(G, ee) {
                  return o._(this, void 0, void 0, (function* () {
                    const ue = {};
                    for (const ce in G) {
                      ue[ce] = {};
                      const pe = z.getImageCanvasContext((yield ee[ce]).data), ge = (yield G[ce]).data;
                      for (const Ce in ge) {
                        const { width: xe, height: ke, x: ze, y: we, sdf: je, pixelRatio: Qe, stretchX: qe, stretchY: Ze, content: Je, textFitWidth: Tt, textFitHeight: It } = ge[Ce];
                        ue[ce][Ce] = { data: null, pixelRatio: Qe, sdf: je, stretchX: qe, stretchY: Ze, content: Je, textFitWidth: Tt, textFitHeight: It, spriteData: { width: xe, height: ke, x: ze, y: we, context: pe } };
                      }
                    }
                    return ue;
                  }));
                })(j, $);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((y) => {
              if (this._spriteRequest = null, y) for (const x in y) {
                this._spritesImagesIds[x] = [];
                const T = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((M) => !(M in y))) : [];
                for (const M of T) this.imageManager.removeImage(M), this._changedImages[M] = true;
                for (const M in y[x]) {
                  const D = x === "default" ? M : `${x}:${M}`;
                  this._spritesImagesIds[x].push(D), D in this.imageManager.images ? this.imageManager.updateImage(D, y[x][M], false) : this.imageManager.addImage(D, y[x][M]), s && (this._changedImages[D] = true);
                }
              }
            })).catch(((y) => {
              this._spriteRequest = null, m = y, this.fire(new o.k(m));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), s && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" })), u && u(m);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const s = this.sourceCaches[e.source];
            if (!s) return;
            const u = e.sourceLayer;
            if (!u) return;
            const m = s.getSource();
            (m.type === "geojson" || m.vectorLayerIds && m.vectorLayerIds.indexOf(u) === -1) && this.fire(new o.k(new Error(`Source layer "${u}" does not exist on source "${m.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, s = false) {
            const u = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(s ? o.bK(u) : u);
            const m = [];
            for (const y of e) if (u[y]) {
              const x = s ? o.bK(u[y]) : u[y];
              m.push(x);
            }
            return m;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const s = Object.keys(this._layers);
            for (const u of s) {
              const m = this._layers[u];
              m.type !== "custom" && (e[u] = m.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, s, u;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((s = this.sky) === null || s === void 0) && s.hasTransition() || !((u = this.projection) === null || u === void 0) && u.hasTransition()) return true;
            for (const m in this.sourceCaches) if (this.sourceCaches[m].hasTransition()) return true;
            for (const m in this._layers) if (this._layers[m].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const s = this._changed;
            if (s) {
              const m = Object.keys(this._updatedLayers), y = Object.keys(this._removedLayers);
              (m.length || y.length) && this._updateWorkerLayers(m, y);
              for (const x in this._updatedSources) {
                const T = this._updatedSources[x];
                if (T === "reload") this._reloadSource(x);
                else {
                  if (T !== "clear") throw new Error(`Invalid action ${T}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const u = {};
            for (const m in this.sourceCaches) {
              const y = this.sourceCaches[m];
              u[m] = y.used, y.used = false;
            }
            for (const m of this._order) {
              const y = this._layers[m];
              y.recalculate(e, this._availableImages), !y.isHidden(e.zoom) && y.source && (this.sourceCaches[y.source].used = true);
            }
            for (const m in u) {
              const y = this.sourceCaches[m];
              !!u[m] != !!y.used && y.fire(new o.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: m }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, s && this.fire(new o.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const s in this.sourceCaches) this.sourceCaches[s].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e, s) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, false), removedIds: s });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e, s = {}) {
            var u;
            this._checkLoaded();
            const m = this.serialize();
            if (e = s.transformStyle ? s.transformStyle(m, e) : e, ((u = s.validate) === null || u === void 0 || u) && Nl(this, o.z(e))) return false;
            (e = o.bK(e)).layers = o.bI(e.layers);
            const y = o.bL(m, e), x = this._getOperationsToPerform(y);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return false;
            for (const T of x.operations) T();
            return this.stylesheet = e, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e) {
            const s = [], u = [];
            for (const m of e) switch (m.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                s.push((() => this.addLayer.apply(this, m.args)));
                break;
              case "removeLayer":
                s.push((() => this.removeLayer.apply(this, m.args)));
                break;
              case "setPaintProperty":
                s.push((() => this.setPaintProperty.apply(this, m.args)));
                break;
              case "setLayoutProperty":
                s.push((() => this.setLayoutProperty.apply(this, m.args)));
                break;
              case "setFilter":
                s.push((() => this.setFilter.apply(this, m.args)));
                break;
              case "addSource":
                s.push((() => this.addSource.apply(this, m.args)));
                break;
              case "removeSource":
                s.push((() => this.removeSource.apply(this, m.args)));
                break;
              case "setLayerZoomRange":
                s.push((() => this.setLayerZoomRange.apply(this, m.args)));
                break;
              case "setLight":
                s.push((() => this.setLight.apply(this, m.args)));
                break;
              case "setGeoJSONSourceData":
                s.push((() => this.setGeoJSONSourceData.apply(this, m.args)));
                break;
              case "setGlyphs":
                s.push((() => this.setGlyphs.apply(this, m.args)));
                break;
              case "setSprite":
                s.push((() => this.setSprite.apply(this, m.args)));
                break;
              case "setTerrain":
                s.push((() => this.map.setTerrain.apply(this, m.args)));
                break;
              case "setSky":
                s.push((() => this.setSky.apply(this, m.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, m.args);
                break;
              case "setGlobalState":
                s.push((() => this.setGlobalState.apply(this, m.args)));
                break;
              case "setTransition":
                s.push((() => {
                }));
                break;
              default:
                u.push(m.command);
            }
            return { operations: s, unimplemented: u };
          }
          addImage(e, s) {
            if (this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, s), this._afterImageUpdated(e);
          }
          updateImage(e, s) {
            this.imageManager.updateImage(e, s);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, s, u = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(o.z.source, `sources.${e}`, s, null, u)) return;
            this.map && this.map._collectResourceTiming && (s.collectResourceTiming = true);
            const m = this.sourceCaches[e] = new or(e, s, this.dispatcher);
            m.style = this, m.setEventedParent(this, (() => ({ isSourceLoaded: m.loaded(), source: m.serialize(), sourceId: e }))), m.onAdd(this.map), this._changed = true;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const u in this._layers) if (this._layers[u].source === e) return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${u}" is using it.`)));
            const s = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], s.fire(new o.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), s.setEventedParent(null), s.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e, s) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const u = this.sourceCaches[e].getSource();
            if (u.type !== "geojson") throw new Error(`geojsonSource.type is ${u.type}, which is !== 'geojson`);
            u.setData(s), this._changed = true;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, s, u = {}) {
            this._checkLoaded();
            const m = e.id;
            if (this.getLayer(m)) return void this.fire(new o.k(new Error(`Layer "${m}" already exists on this map.`)));
            let y;
            if (e.type === "custom") {
              if (Nl(this, o.bM(e))) return;
              y = o.bJ(e);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(m, e.source), e = o.bK(e), e = o.e(e, { source: m })), this._validate(o.z.layer, `layers.${m}`, e, { arrayIndex: -1 }, u)) return;
              y = o.bJ(e), this._validateLayer(y), y.setEventedParent(this, { layer: { id: m } });
            }
            const x = s ? this._order.indexOf(s) : this._order.length;
            if (s && x === -1) this.fire(new o.k(new Error(`Cannot add layer "${m}" before non-existing layer "${s}".`)));
            else {
              if (this._order.splice(x, 0, m), this._layerOrderChanged = true, this._layers[m] = y, this._removedLayers[m] && y.source && y.type !== "custom") {
                const T = this._removedLayers[m];
                delete this._removedLayers[m], T.type !== y.type ? this._updatedSources[y.source] = "clear" : (this._updatedSources[y.source] = "reload", this.sourceCaches[y.source].pause());
              }
              this._updateLayer(y), y.onAdd && y.onAdd(this.map);
            }
          }
          moveLayer(e, s) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e]) return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === s) return;
            const u = this._order.indexOf(e);
            this._order.splice(u, 1);
            const m = s ? this._order.indexOf(s) : this._order.length;
            s && m === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${s}".`))) : (this._order.splice(m, 0, e), this._layerOrderChanged = true);
          }
          removeLayer(e) {
            this._checkLoaded();
            const s = this._layers[e];
            if (!s) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            s.setEventedParent(null);
            const u = this._order.indexOf(e);
            this._order.splice(u, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e] = s, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], s.onRemove && s.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, s, u) {
            this._checkLoaded();
            const m = this.getLayer(e);
            m ? m.minzoom === s && m.maxzoom === u || (s != null && (m.minzoom = s), u != null && (m.maxzoom = u), this._updateLayer(m)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, s, u = {}) {
            this._checkLoaded();
            const m = this.getLayer(e);
            if (m) {
              if (!o.bH(m.filter, s)) return s == null ? (m.setFilter(void 0), void this._updateLayer(m)) : void (this._validate(o.z.filter, `layers.${m.id}.filter`, s, null, u) || (m.setFilter(o.bK(s)), this._updateLayer(m)));
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return o.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, s, u, m = {}) {
            this._checkLoaded();
            const y = this.getLayer(e);
            y ? o.bH(y.getLayoutProperty(s), u) || (y.setLayoutProperty(s, u, m), this._updateLayer(y)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, s) {
            const u = this.getLayer(e);
            if (u) return u.getLayoutProperty(s);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, s, u, m = {}) {
            this._checkLoaded();
            const y = this.getLayer(e);
            y ? o.bH(y.getPaintProperty(s), u) || this._updatePaintProperty(y, s, u, m) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, s, u, m = {}) {
            e.setPaintProperty(s, u, m) && this._updateLayer(e), this._changed = true, this._updatedPaintProps[e.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e, s) {
            return this.getLayer(e).getPaintProperty(s);
          }
          setFeatureState(e, s) {
            this._checkLoaded();
            const u = e.source, m = e.sourceLayer, y = this.sourceCaches[u];
            if (y === void 0) return void this.fire(new o.k(new Error(`The source '${u}' does not exist in the map's style.`)));
            const x = y.getSource().type;
            x === "geojson" && m ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || m ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), y.setFeatureState(m, e.id, s)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, s) {
            this._checkLoaded();
            const u = e.source, m = this.sourceCaches[u];
            if (m === void 0) return void this.fire(new o.k(new Error(`The source '${u}' does not exist in the map's style.`)));
            const y = m.getSource().type, x = y === "vector" ? e.sourceLayer : void 0;
            y !== "vector" || x ? s && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : m.removeFeatureState(x, e.id, s) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const s = e.source, u = e.sourceLayer, m = this.sourceCaches[s];
            if (m !== void 0) return m.getSource().type !== "vector" || u ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), m.getFeatureState(u, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
          }
          getTransition() {
            return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = o.bN(this.sourceCaches, ((y) => y.serialize())), s = this._serializeByIds(this._order, true), u = this.map.getTerrain() || void 0, m = this.stylesheet;
            return o.bO({ version: m.version, name: m.name, metadata: m.metadata, light: m.light, sky: m.sky, center: m.center, zoom: m.zoom, bearing: m.bearing, pitch: m.pitch, sprite: m.sprite, glyphs: m.glyphs, transition: m.transition, projection: m.projection, sources: e, layers: s, terrain: u }, ((y) => y !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = true, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e) {
            const s = (x) => this._layers[x].type === "fill-extrusion", u = {}, m = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const T = this._order[x];
              if (s(T)) {
                u[T] = x;
                for (const M of e) {
                  const D = M[T];
                  if (D) for (const F of D) m.push(F);
                }
              }
            }
            m.sort(((x, T) => T.intersectionZ - x.intersectionZ));
            const y = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const T = this._order[x];
              if (s(T)) for (let M = m.length - 1; M >= 0; M--) {
                const D = m[M].feature;
                if (u[D.layer.id] < x) break;
                y.push(D), m.pop();
              }
              else for (const M of e) {
                const D = M[T];
                if (D) for (const F of D) y.push(F.feature);
              }
            }
            return y;
          }
          queryRenderedFeatures(e, s, u) {
            s && s.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", s.filter, null, s);
            const m = {};
            if (s && s.layers) {
              if (!(Array.isArray(s.layers) || s.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const D of s.layers) {
                const F = this._layers[D];
                if (!F) return this.fire(new o.k(new Error(`The layer '${D}' does not exist in the map's style and cannot be queried for features.`))), [];
                m[F.source] = true;
              }
            }
            const y = [];
            s.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), T = s.layers instanceof Set ? s.layers : Array.isArray(s.layers) ? new Set(s.layers) : null, M = Object.assign(Object.assign({}, s), { layers: T });
            for (const D in this.sourceCaches) s.layers && !m[D] || y.push(yr(this.sourceCaches[D], this._layers, x, e, M, u, this.map.terrain ? (F, j, $) => this.map.terrain.getElevation(F, j, $) : void 0));
            return this.placement && y.push((function(D, F, j, $, G, ee, ue) {
              const ce = {}, pe = ee.queryRenderedSymbols($), ge = [];
              for (const Ce of Object.keys(pe).map(Number)) ge.push(ue[Ce]);
              ge.sort(Tr);
              for (const Ce of ge) {
                const xe = Ce.featureIndex.lookupSymbolFeatures(pe[Ce.bucketInstanceId], F, Ce.bucketIndex, Ce.sourceLayerIndex, G.filter, G.layers, G.availableImages, D);
                for (const ke in xe) {
                  const ze = ce[ke] = ce[ke] || [], we = xe[ke];
                  we.sort(((je, Qe) => {
                    const qe = Ce.featureSortOrder;
                    if (qe) {
                      const Ze = qe.indexOf(je.featureIndex);
                      return qe.indexOf(Qe.featureIndex) - Ze;
                    }
                    return Qe.featureIndex - je.featureIndex;
                  }));
                  for (const je of we) ze.push(je);
                }
              }
              return (function(Ce, xe, ke) {
                for (const ze in Ce) for (const we of Ce[ze]) zr(we, ke[xe[ze].source]);
                return Ce;
              })(ce, D, j);
            })(this._layers, x, this.sourceCaches, e, M, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(y);
          }
          querySourceFeatures(e, s) {
            s && s.filter && this._validate(o.z.filter, "querySourceFeatures.filter", s.filter, null, s);
            const u = this.sourceCaches[e];
            return u ? (function(m, y) {
              const x = m.getRenderableIds().map(((D) => m.getTileByID(D))), T = [], M = {};
              for (let D = 0; D < x.length; D++) {
                const F = x[D], j = F.tileID.canonical.key;
                M[j] || (M[j] = true, F.querySourceFeatures(T, y));
              }
              return T;
            })(u, s) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, s = {}) {
            this._checkLoaded();
            const u = this.light.getLight();
            let m = false;
            for (const x in e) if (!o.bH(e[x], u[x])) {
              m = true;
              break;
            }
            if (!m) return;
            const y = { now: z.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, s), this.light.updateTransitions(y);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, s = {}) {
            this._checkLoaded();
            const u = this.getSky();
            let m = false;
            if (!e && !u) return;
            if (e && !u) m = true;
            else if (!e && u) m = true;
            else for (const x in e) if (!o.bH(e[x], u[x])) {
              m = true;
              break;
            }
            if (!m) return;
            const y = { now: z.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, s), this.sky.updateTransitions(y);
          }
          _setProjectionInternal(e) {
            const s = (function(u) {
              if (Array.isArray(u)) {
                const m = new $l({ type: u });
                return { projection: m, transform: new Va(), cameraHelper: new Xd(m) };
              }
              switch (u) {
                case "mercator":
                  return { projection: new kr(), transform: new tn(), cameraHelper: new oi() };
                case "globe": {
                  const m = new $l({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: m, transform: new Va(), cameraHelper: new Xd(m) };
                }
                case "vertical-perspective":
                  return { projection: new La(), transform: new Na(), cameraHelper: new si() };
                default:
                  return o.w(`Unknown projection name: ${u}. Falling back to mercator projection.`), { projection: new kr(), transform: new tn(), cameraHelper: new oi() };
              }
            })(e);
            this.projection = s.projection, this.map.migrateProjection(s.transform, s.cameraHelper);
            for (const u in this.sourceCaches) this.sourceCaches[u].reload();
          }
          _validate(e, s, u, m, y = {}) {
            return (!y || y.validate !== false) && Nl(this, e.call(o.z, o.e({ key: s, style: this.serialize(), value: u, styleSpec: o.v }, m)));
          }
          _remove(e = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), on().off(st, this._rtlPluginLoaded);
            for (const s in this._layers) this._layers[s].setEventedParent(null);
            for (const s in this.sourceCaches) {
              const u = this.sourceCaches[s];
              u.setEventedParent(null), u.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const s in this.sourceCaches) this.sourceCaches[s].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, s, u, m, y = false) {
            let x = false, T = false;
            const M = {};
            for (const D of this._order) {
              const F = this._layers[D];
              if (F.type !== "symbol") continue;
              if (!M[F.source]) {
                const $ = this.sourceCaches[F.source];
                M[F.source] = $.getRenderableIds(true).map(((G) => $.getTileByID(G))).sort(((G, ee) => ee.tileID.overscaledZ - G.tileID.overscaledZ || (G.tileID.isLessThan(ee.tileID) ? -1 : 1)));
              }
              const j = this.crossTileSymbolIndex.addLayer(F, M[F.source], e.center.lng);
              x = x || j;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((y = y || this._layerOrderChanged || u === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(z.now(), e.zoom)) && (this.pauseablePlacement = new Aa(e, this.map.terrain, this._order, y, s, u, m, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, M), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(z.now()), T = true), x && this.pauseablePlacement.placement.setStale()), T || x) for (const D of this._order) {
              const F = this._layers[D];
              F.type === "symbol" && this.placement.updateLayerOpacities(F, M[F.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(z.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, s) {
            return o._(this, void 0, void 0, (function* () {
              const u = yield this.imageManager.getImages(s.icons);
              this._updateTilesForChangedImages();
              const m = this.sourceCaches[s.source];
              return m && m.setDependencies(s.tileID.key, s.type, s.icons), u;
            }));
          }
          getGlyphs(e, s) {
            return o._(this, void 0, void 0, (function* () {
              const u = yield this.glyphManager.getGlyphs(s.stacks), m = this.sourceCaches[s.source];
              return m && m.setDependencies(s.tileID.key, s.type, [""]), u;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, s = {}) {
            this._checkLoaded(), e && this._validate(o.z.glyphs, "glyphs", e, null, s) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, s, u = {}, m) {
            this._checkLoaded();
            const y = [{ id: e, url: s }], x = [...q(this.stylesheet.sprite), ...y];
            this._validate(o.z.sprite, "sprite", x, null, u) || (this.stylesheet.sprite = x, this._loadSprite(y, true, m));
          }
          removeSprite(e) {
            this._checkLoaded();
            const s = q(this.stylesheet.sprite);
            if (s.find(((u) => u.id === e))) {
              if (this._spritesImagesIds[e]) for (const u of this._spritesImagesIds[e]) this.imageManager.removeImage(u), this._changedImages[u] = true;
              s.splice(s.findIndex(((u) => u.id === e)), 1), this.stylesheet.sprite = s.length > 0 ? s : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", { dataType: "style" }));
            } else this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return q(this.stylesheet.sprite);
          }
          setSprite(e, s = {}, u) {
            this._checkLoaded(), e && this._validate(o.z.sprite, "sprite", e, null, s) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, true, u) : (this._unloadSprite(), u && u(null)));
          }
        }
        var ef = o.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class tf {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, s, u, m, y, x, T, M, D) {
            this.context = e;
            let F = this.boundPaintVertexBuffers.length !== m.length;
            for (let j = 0; !F && j < m.length; j++) this.boundPaintVertexBuffers[j] !== m[j] && (F = true);
            !this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== u || F || this.boundIndexBuffer !== y || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== T || this.boundDynamicVertexBuffer2 !== M || this.boundDynamicVertexBuffer3 !== D ? this.freshBind(s, u, m, y, x, T, M, D) : (e.bindVertexArray.set(this.vao), T && T.bind(), y && y.dynamicDraw && y.bind(), M && M.bind(), D && D.bind());
          }
          freshBind(e, s, u, m, y, x, T, M) {
            const D = e.numAttributes, F = this.context, j = F.gl;
            this.vao && this.destroy(), this.vao = F.createVertexArray(), F.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = u, this.boundIndexBuffer = m, this.boundVertexOffset = y, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = T, this.boundDynamicVertexBuffer3 = M, s.enableAttributes(j, e);
            for (const $ of u) $.enableAttributes(j, e);
            x && x.enableAttributes(j, e), T && T.enableAttributes(j, e), M && M.enableAttributes(j, e), s.bind(), s.setVertexAttribPointers(j, e, y);
            for (const $ of u) $.bind(), $.setVertexAttribPointers(j, e, y);
            x && (x.bind(), x.setVertexAttribPointers(j, e, y)), m && m.bind(), T && (T.bind(), T.setVertexAttribPointers(j, e, y)), M && (M.bind(), M.setVertexAttribPointers(j, e, y)), F.currentNumAttributes = D;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Vl = (v, e, s, u, m) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: e, u_fog_color: s ? s.properties.get("fog-color") : o.bf.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: m ? 0 : s ? s.calculateFogBlendOpacity(u) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : o.bf.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: m ? 1 : 0 }), du = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Cs(v) {
          const e = [];
          for (let s = 0; s < v.length; s++) {
            if (v[s] === null) continue;
            const u = v[s].split(" ");
            e.push(u.pop());
          }
          return e;
        }
        class hu {
          constructor(e, s, u, m, y, x, T, M, D = []) {
            const F = e.gl;
            this.program = F.createProgram();
            const j = Cs(s.staticAttributes), $ = u ? u.getBinderAttributes() : [], G = j.concat($), ee = Di.prelude.staticUniforms ? Cs(Di.prelude.staticUniforms) : [], ue = T.staticUniforms ? Cs(T.staticUniforms) : [], ce = s.staticUniforms ? Cs(s.staticUniforms) : [], pe = u ? u.getBinderUniforms() : [], ge = ee.concat(ue).concat(ce).concat(pe), Ce = [];
            for (const qe of ge) Ce.indexOf(qe) < 0 && Ce.push(qe);
            const xe = u ? u.defines() : [];
            ko(F) && xe.unshift("#version 300 es"), y && xe.push("#define OVERDRAW_INSPECTOR;"), x && xe.push("#define TERRAIN3D;"), M && xe.push(M), D && xe.push(...D);
            let ke = xe.concat(Di.prelude.fragmentSource, T.fragmentSource, s.fragmentSource).join(`
`), ze = xe.concat(Di.prelude.vertexSource, T.vertexSource, s.vertexSource).join(`
`);
            ko(F) || (ke = (function(qe) {
              return qe.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(ke), ze = (function(qe) {
              return qe.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(ze));
            const we = F.createShader(F.FRAGMENT_SHADER);
            if (F.isContextLost()) return void (this.failedToCreate = true);
            if (F.shaderSource(we, ke), F.compileShader(we), !F.getShaderParameter(we, F.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${F.getShaderInfoLog(we)}`);
            F.attachShader(this.program, we);
            const je = F.createShader(F.VERTEX_SHADER);
            if (F.isContextLost()) return void (this.failedToCreate = true);
            if (F.shaderSource(je, ze), F.compileShader(je), !F.getShaderParameter(je, F.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${F.getShaderInfoLog(je)}`);
            F.attachShader(this.program, je), this.attributes = {};
            const Qe = {};
            this.numAttributes = G.length;
            for (let qe = 0; qe < this.numAttributes; qe++) G[qe] && (F.bindAttribLocation(this.program, qe, G[qe]), this.attributes[G[qe]] = qe);
            if (F.linkProgram(this.program), !F.getProgramParameter(this.program, F.LINK_STATUS)) throw new Error(`Program failed to link: ${F.getProgramInfoLog(this.program)}`);
            F.deleteShader(je), F.deleteShader(we);
            for (let qe = 0; qe < Ce.length; qe++) {
              const Ze = Ce[qe];
              if (Ze && !Qe[Ze]) {
                const Je = F.getUniformLocation(this.program, Ze);
                Je && (Qe[Ze] = Je);
              }
            }
            this.fixedUniforms = m(e, Qe), this.terrainUniforms = ((qe, Ze) => ({ u_depth: new o.bP(qe, Ze.u_depth), u_terrain: new o.bP(qe, Ze.u_terrain), u_terrain_dim: new o.bg(qe, Ze.u_terrain_dim), u_terrain_matrix: new o.bR(qe, Ze.u_terrain_matrix), u_terrain_unpack: new o.bS(qe, Ze.u_terrain_unpack), u_terrain_exaggeration: new o.bg(qe, Ze.u_terrain_exaggeration) }))(e, Qe), this.projectionUniforms = ((qe, Ze) => ({ u_projection_matrix: new o.bR(qe, Ze.u_projection_matrix), u_projection_tile_mercator_coords: new o.bS(qe, Ze.u_projection_tile_mercator_coords), u_projection_clipping_plane: new o.bS(qe, Ze.u_projection_clipping_plane), u_projection_transition: new o.bg(qe, Ze.u_projection_transition), u_projection_fallback_matrix: new o.bR(qe, Ze.u_projection_fallback_matrix) }))(e, Qe), this.binderUniforms = u ? u.getUniforms(e, Qe) : [];
          }
          draw(e, s, u, m, y, x, T, M, D, F, j, $, G, ee, ue, ce, pe, ge, Ce) {
            const xe = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(u), e.setStencilMode(m), e.setColorMode(y), e.setCullFace(x), M) {
              e.activeTexture.set(xe.TEXTURE2), xe.bindTexture(xe.TEXTURE_2D, M.depthTexture), e.activeTexture.set(xe.TEXTURE3), xe.bindTexture(xe.TEXTURE_2D, M.texture);
              for (const ze in this.terrainUniforms) this.terrainUniforms[ze].set(M[ze]);
            }
            if (D) for (const ze in D) this.projectionUniforms[du[ze]].set(D[ze]);
            if (T) for (const ze in this.fixedUniforms) this.fixedUniforms[ze].set(T[ze]);
            ce && ce.setUniforms(e, this.binderUniforms, ee, { zoom: ue });
            let ke = 0;
            switch (s) {
              case xe.LINES:
                ke = 2;
                break;
              case xe.TRIANGLES:
                ke = 3;
                break;
              case xe.LINE_STRIP:
                ke = 1;
            }
            for (const ze of G.get()) {
              const we = ze.vaos || (ze.vaos = {});
              (we[F] || (we[F] = new tf())).bind(e, this, j, ce ? ce.getPaintVertexBuffers() : [], $, ze.vertexOffset, pe, ge, Ce), xe.drawElements(s, ze.primitiveLength * ke, xe.UNSIGNED_SHORT, ze.primitiveOffset * ke * 2);
            }
          }
        }
        function Ul(v, e, s) {
          const u = 1 / o.aC(s, 1, e.transform.tileZoom), m = Math.pow(2, s.tileID.overscaledZ), y = s.tileSize * Math.pow(2, e.transform.tileZoom) / m, x = y * (s.tileID.canonical.x + s.tileID.wrap * m), T = y * s.tileID.canonical.y;
          return { u_image: 0, u_texsize: s.imageAtlasTexture.size, u_scale: [u, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [x >> 16, T >> 16], u_pixel_coord_lower: [65535 & x, 65535 & T] };
        }
        const to = (v, e, s, u) => {
          const m = v.style.light, y = m.properties.get("position"), x = [y.x, y.y, y.z], T = o.bV();
          m.properties.get("anchor") === "viewport" && o.bW(T, v.transform.bearingInRadians), o.bX(x, x, T);
          const M = v.transform.transformLightDirection(x), D = m.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: M, u_lightintensity: m.properties.get("intensity"), u_lightcolor: [D.r, D.g, D.b], u_vertical_gradient: +e, u_opacity: s, u_fill_translate: u };
        }, rf = (v, e, s, u, m, y, x) => o.e(to(v, e, s, u), Ul(y, v, x), { u_height_factor: -Math.pow(2, m.overscaledZ) / x.tileSize / 8 }), ql = (v, e, s, u) => o.e(Ul(e, v, s), { u_fill_translate: u }), Ua = (v, e) => ({ u_world: v, u_fill_translate: e }), qa = (v, e, s, u, m) => o.e(ql(v, e, s, m), { u_world: u }), nf = (v, e, s, u, m) => {
          const y = v.transform;
          let x, T, M = 0;
          if (s.paint.get("circle-pitch-alignment") === "map") {
            const D = o.aC(e, 1, y.zoom);
            x = true, T = [D, D], M = D / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * m;
          } else x = false, T = y.pixelsToGLUnits;
          return { u_camera_to_center_distance: y.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: T, u_globe_extrude_scale: M, u_translate: u };
        }, Gl = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), of = (v) => ({ u_viewport_size: [v.width, v.height] }), Ss = (v, e = 1) => ({ u_color: v, u_overlay: 0, u_overlay_scale: e }), Yd = (v, e, s, u) => {
          const m = o.aC(v, 1, e) / (o.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * u;
          return { u_extrude_scale: o.aC(v, 1, e), u_intensity: s, u_globe_extrude_scale: m };
        }, pu = (v, e, s, u) => {
          const m = o.L();
          o.bY(m, 0, v.width, v.height, 0, 0, 1);
          const y = v.context.gl;
          return { u_matrix: m, u_world: [y.drawingBufferWidth, y.drawingBufferHeight], u_image: s, u_color_ramp: u, u_opacity: e.paint.get("heatmap-opacity") };
        }, sf = (v, e, s) => {
          const u = s.paint.get("hillshade-accent-color");
          let m;
          switch (s.paint.get("hillshade-method")) {
            case "basic":
              m = 4;
              break;
            case "combined":
              m = 1;
              break;
            case "igor":
              m = 2;
              break;
            case "multidirectional":
              m = 3;
              break;
            default:
              m = 0;
          }
          const y = s.getIlluminationProperties();
          for (let x = 0; x < y.directionRadians.length; x++) s.paint.get("hillshade-illumination-anchor") === "viewport" && (y.directionRadians[x] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: fu(0, e.tileID), u_exaggeration: s.paint.get("hillshade-exaggeration"), u_altitudes: y.altitudeRadians, u_azimuths: y.directionRadians, u_accent: u, u_method: m, u_highlights: y.highlightColor, u_shadows: y.shadowColor };
        }, Kd = (v, e) => {
          const s = e.stride, u = o.L();
          return o.bY(u, 0, o.$, -o.$, 0, 0, 1), o.M(u, u, [0, -o.$, 0]), { u_matrix: u, u_image: 1, u_dimension: [s, s], u_zoom: v.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function fu(v, e) {
          const s = Math.pow(2, e.canonical.z), u = e.canonical.y;
          return [new o.a1(0, u / s).toLngLat().lat, new o.a1(0, (u + 1) / s).toLngLat().lat];
        }
        const Jd = (v, e, s = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: s, u_opacity: v.paint.get("color-relief-opacity") }), Wl = (v, e, s, u) => {
          const m = v.transform;
          return { u_translation: gu(v, e, s), u_ratio: u / o.aC(e, 1, m.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / m.pixelsToGLUnits[0], 1 / m.pixelsToGLUnits[1]] };
        }, Qd = (v, e, s, u, m) => o.e(Wl(v, e, s, u), { u_image: 0, u_image_height: m }), eh = (v, e, s, u, m) => {
          const y = v.transform, x = mu(e, y);
          return { u_translation: gu(v, e, s), u_texsize: e.imageAtlasTexture.size, u_ratio: u / o.aC(e, 1, y.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [x, m.fromScale, m.toScale], u_fade: m.t, u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]] };
        }, ks = (v, e, s, u, m, y) => {
          const x = v.lineAtlas, T = mu(e, v.transform), M = s.layout.get("line-cap") === "round", D = x.getDash(m.from, M), F = x.getDash(m.to, M), j = D.width * y.fromScale, $ = F.width * y.toScale;
          return o.e(Wl(v, e, s, u), { u_patternscale_a: [T / j, -D.height / 2], u_patternscale_b: [T / $, -F.height / 2], u_sdfgamma: x.width / (256 * Math.min(j, $) * v.pixelRatio) / 2, u_image: 0, u_tex_y_a: D.y, u_tex_y_b: F.y, u_mix: y.t });
        };
        function mu(v, e) {
          return 1 / o.aC(v, 1, e.tileZoom);
        }
        function gu(v, e, s) {
          return o.aD(v.transform, e, s.paint.get("line-translate"), s.paint.get("line-translate-anchor"));
        }
        const Ga = (v, e, s, u, m) => {
          return { u_tl_parent: v, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * u.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: u.paint.get("raster-brightness-min"), u_brightness_high: u.paint.get("raster-brightness-max"), u_saturation_factor: (x = u.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (y = u.paint.get("raster-contrast"), y > 0 ? 1 / (1 - y) : 1 + y), u_spin_weights: af(u.paint.get("raster-hue-rotate")), u_coords_top: [m[0].x, m[0].y, m[1].x, m[1].y], u_coords_bottom: [m[3].x, m[3].y, m[2].x, m[2].y] };
          var y, x;
        };
        function af(v) {
          v *= Math.PI / 180;
          const e = Math.sin(v), s = Math.cos(v);
          return [(2 * s + 1) / 3, (-Math.sqrt(3) * e - s + 1) / 3, (Math.sqrt(3) * e - s + 1) / 3];
        }
        const Wa = (v, e, s, u, m, y, x, T, M, D, F, j, $) => {
          const G = x.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: G.cameraToCenterDistance, u_pitch: G.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +s, u_aspect_ratio: G.width / G.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: T, u_coord_matrix: M, u_is_text: +F, u_pitch_with_map: +u, u_is_along_line: m, u_is_variable_anchor: y, u_texsize: j, u_texture: 0, u_translation: D, u_pitched_scale: $ };
        }, th = (v, e, s, u, m, y, x, T, M, D, F, j, $, G) => {
          const ee = x.transform;
          return o.e(Wa(v, e, s, u, m, y, x, T, M, D, F, j, G), { u_gamma_scale: u ? Math.cos(ee.pitch * Math.PI / 180) * ee.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, lf = (v, e, s, u, m, y, x, T, M, D, F, j, $) => o.e(th(v, e, s, u, m, y, x, T, M, D, true, F, 0, $), { u_texsize_icon: j, u_texture_icon: 1 }), rh = (v, e) => ({ u_opacity: v, u_color: e }), nh = (v, e, s, u, m) => o.e((function(y, x, T, M) {
          const D = T.imageManager.getPattern(y.from.toString()), F = T.imageManager.getPattern(y.to.toString()), { width: j, height: $ } = T.imageManager.getPixelSize(), G = Math.pow(2, M.tileID.overscaledZ), ee = M.tileSize * Math.pow(2, T.transform.tileZoom) / G, ue = ee * (M.tileID.canonical.x + M.tileID.wrap * G), ce = ee * M.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: D.tl, u_pattern_br_a: D.br, u_pattern_tl_b: F.tl, u_pattern_br_b: F.br, u_texsize: [j, $], u_mix: x.t, u_pattern_size_a: D.displaySize, u_pattern_size_b: F.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / o.aC(M, 1, T.transform.tileZoom), u_pixel_coord_upper: [ue >> 16, ce >> 16], u_pixel_coord_lower: [65535 & ue, 65535 & ce] };
        })(s, m, e, u), { u_opacity: v }), vu = (v, e) => {
        }, yu = { fillExtrusion: (v, e) => ({ u_lightpos: new o.bT(v, e.u_lightpos), u_lightpos_globe: new o.bT(v, e.u_lightpos_globe), u_lightintensity: new o.bg(v, e.u_lightintensity), u_lightcolor: new o.bT(v, e.u_lightcolor), u_vertical_gradient: new o.bg(v, e.u_vertical_gradient), u_opacity: new o.bg(v, e.u_opacity), u_fill_translate: new o.bU(v, e.u_fill_translate) }), fillExtrusionPattern: (v, e) => ({ u_lightpos: new o.bT(v, e.u_lightpos), u_lightpos_globe: new o.bT(v, e.u_lightpos_globe), u_lightintensity: new o.bg(v, e.u_lightintensity), u_lightcolor: new o.bT(v, e.u_lightcolor), u_vertical_gradient: new o.bg(v, e.u_vertical_gradient), u_height_factor: new o.bg(v, e.u_height_factor), u_opacity: new o.bg(v, e.u_opacity), u_fill_translate: new o.bU(v, e.u_fill_translate), u_image: new o.bP(v, e.u_image), u_texsize: new o.bU(v, e.u_texsize), u_pixel_coord_upper: new o.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.bU(v, e.u_pixel_coord_lower), u_scale: new o.bT(v, e.u_scale), u_fade: new o.bg(v, e.u_fade) }), fill: (v, e) => ({ u_fill_translate: new o.bU(v, e.u_fill_translate) }), fillPattern: (v, e) => ({ u_image: new o.bP(v, e.u_image), u_texsize: new o.bU(v, e.u_texsize), u_pixel_coord_upper: new o.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.bU(v, e.u_pixel_coord_lower), u_scale: new o.bT(v, e.u_scale), u_fade: new o.bg(v, e.u_fade), u_fill_translate: new o.bU(v, e.u_fill_translate) }), fillOutline: (v, e) => ({ u_world: new o.bU(v, e.u_world), u_fill_translate: new o.bU(v, e.u_fill_translate) }), fillOutlinePattern: (v, e) => ({ u_world: new o.bU(v, e.u_world), u_image: new o.bP(v, e.u_image), u_texsize: new o.bU(v, e.u_texsize), u_pixel_coord_upper: new o.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.bU(v, e.u_pixel_coord_lower), u_scale: new o.bT(v, e.u_scale), u_fade: new o.bg(v, e.u_fade), u_fill_translate: new o.bU(v, e.u_fill_translate) }), circle: (v, e) => ({ u_camera_to_center_distance: new o.bg(v, e.u_camera_to_center_distance), u_scale_with_map: new o.bP(v, e.u_scale_with_map), u_pitch_with_map: new o.bP(v, e.u_pitch_with_map), u_extrude_scale: new o.bU(v, e.u_extrude_scale), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_globe_extrude_scale: new o.bg(v, e.u_globe_extrude_scale), u_translate: new o.bU(v, e.u_translate) }), collisionBox: (v, e) => ({ u_pixel_extrude_scale: new o.bU(v, e.u_pixel_extrude_scale) }), collisionCircle: (v, e) => ({ u_viewport_size: new o.bU(v, e.u_viewport_size) }), debug: (v, e) => ({ u_color: new o.bQ(v, e.u_color), u_overlay: new o.bP(v, e.u_overlay), u_overlay_scale: new o.bg(v, e.u_overlay_scale) }), depth: vu, clippingMask: vu, heatmap: (v, e) => ({ u_extrude_scale: new o.bg(v, e.u_extrude_scale), u_intensity: new o.bg(v, e.u_intensity), u_globe_extrude_scale: new o.bg(v, e.u_globe_extrude_scale) }), heatmapTexture: (v, e) => ({ u_matrix: new o.bR(v, e.u_matrix), u_world: new o.bU(v, e.u_world), u_image: new o.bP(v, e.u_image), u_color_ramp: new o.bP(v, e.u_color_ramp), u_opacity: new o.bg(v, e.u_opacity) }), hillshade: (v, e) => ({ u_image: new o.bP(v, e.u_image), u_latrange: new o.bU(v, e.u_latrange), u_exaggeration: new o.bg(v, e.u_exaggeration), u_altitudes: new o.b_(v, e.u_altitudes), u_azimuths: new o.b_(v, e.u_azimuths), u_accent: new o.bQ(v, e.u_accent), u_method: new o.bP(v, e.u_method), u_shadows: new o.bZ(v, e.u_shadows), u_highlights: new o.bZ(v, e.u_highlights) }), hillshadePrepare: (v, e) => ({ u_matrix: new o.bR(v, e.u_matrix), u_image: new o.bP(v, e.u_image), u_dimension: new o.bU(v, e.u_dimension), u_zoom: new o.bg(v, e.u_zoom), u_unpack: new o.bS(v, e.u_unpack) }), colorRelief: (v, e) => ({ u_image: new o.bP(v, e.u_image), u_unpack: new o.bS(v, e.u_unpack), u_dimension: new o.bU(v, e.u_dimension), u_elevation_stops: new o.bP(v, e.u_elevation_stops), u_color_stops: new o.bP(v, e.u_color_stops), u_color_ramp_size: new o.bP(v, e.u_color_ramp_size), u_opacity: new o.bg(v, e.u_opacity) }), line: (v, e) => ({ u_translation: new o.bU(v, e.u_translation), u_ratio: new o.bg(v, e.u_ratio), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new o.bU(v, e.u_units_to_pixels) }), lineGradient: (v, e) => ({ u_translation: new o.bU(v, e.u_translation), u_ratio: new o.bg(v, e.u_ratio), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new o.bU(v, e.u_units_to_pixels), u_image: new o.bP(v, e.u_image), u_image_height: new o.bg(v, e.u_image_height) }), linePattern: (v, e) => ({ u_translation: new o.bU(v, e.u_translation), u_texsize: new o.bU(v, e.u_texsize), u_ratio: new o.bg(v, e.u_ratio), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_image: new o.bP(v, e.u_image), u_units_to_pixels: new o.bU(v, e.u_units_to_pixels), u_scale: new o.bT(v, e.u_scale), u_fade: new o.bg(v, e.u_fade) }), lineSDF: (v, e) => ({ u_translation: new o.bU(v, e.u_translation), u_ratio: new o.bg(v, e.u_ratio), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new o.bU(v, e.u_units_to_pixels), u_patternscale_a: new o.bU(v, e.u_patternscale_a), u_patternscale_b: new o.bU(v, e.u_patternscale_b), u_sdfgamma: new o.bg(v, e.u_sdfgamma), u_image: new o.bP(v, e.u_image), u_tex_y_a: new o.bg(v, e.u_tex_y_a), u_tex_y_b: new o.bg(v, e.u_tex_y_b), u_mix: new o.bg(v, e.u_mix) }), raster: (v, e) => ({ u_tl_parent: new o.bU(v, e.u_tl_parent), u_scale_parent: new o.bg(v, e.u_scale_parent), u_buffer_scale: new o.bg(v, e.u_buffer_scale), u_fade_t: new o.bg(v, e.u_fade_t), u_opacity: new o.bg(v, e.u_opacity), u_image0: new o.bP(v, e.u_image0), u_image1: new o.bP(v, e.u_image1), u_brightness_low: new o.bg(v, e.u_brightness_low), u_brightness_high: new o.bg(v, e.u_brightness_high), u_saturation_factor: new o.bg(v, e.u_saturation_factor), u_contrast_factor: new o.bg(v, e.u_contrast_factor), u_spin_weights: new o.bT(v, e.u_spin_weights), u_coords_top: new o.bS(v, e.u_coords_top), u_coords_bottom: new o.bS(v, e.u_coords_bottom) }), symbolIcon: (v, e) => ({ u_is_size_zoom_constant: new o.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bP(v, e.u_is_size_feature_constant), u_size_t: new o.bg(v, e.u_size_t), u_size: new o.bg(v, e.u_size), u_camera_to_center_distance: new o.bg(v, e.u_camera_to_center_distance), u_pitch: new o.bg(v, e.u_pitch), u_rotate_symbol: new o.bP(v, e.u_rotate_symbol), u_aspect_ratio: new o.bg(v, e.u_aspect_ratio), u_fade_change: new o.bg(v, e.u_fade_change), u_label_plane_matrix: new o.bR(v, e.u_label_plane_matrix), u_coord_matrix: new o.bR(v, e.u_coord_matrix), u_is_text: new o.bP(v, e.u_is_text), u_pitch_with_map: new o.bP(v, e.u_pitch_with_map), u_is_along_line: new o.bP(v, e.u_is_along_line), u_is_variable_anchor: new o.bP(v, e.u_is_variable_anchor), u_texsize: new o.bU(v, e.u_texsize), u_texture: new o.bP(v, e.u_texture), u_translation: new o.bU(v, e.u_translation), u_pitched_scale: new o.bg(v, e.u_pitched_scale) }), symbolSDF: (v, e) => ({ u_is_size_zoom_constant: new o.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bP(v, e.u_is_size_feature_constant), u_size_t: new o.bg(v, e.u_size_t), u_size: new o.bg(v, e.u_size), u_camera_to_center_distance: new o.bg(v, e.u_camera_to_center_distance), u_pitch: new o.bg(v, e.u_pitch), u_rotate_symbol: new o.bP(v, e.u_rotate_symbol), u_aspect_ratio: new o.bg(v, e.u_aspect_ratio), u_fade_change: new o.bg(v, e.u_fade_change), u_label_plane_matrix: new o.bR(v, e.u_label_plane_matrix), u_coord_matrix: new o.bR(v, e.u_coord_matrix), u_is_text: new o.bP(v, e.u_is_text), u_pitch_with_map: new o.bP(v, e.u_pitch_with_map), u_is_along_line: new o.bP(v, e.u_is_along_line), u_is_variable_anchor: new o.bP(v, e.u_is_variable_anchor), u_texsize: new o.bU(v, e.u_texsize), u_texture: new o.bP(v, e.u_texture), u_gamma_scale: new o.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_is_halo: new o.bP(v, e.u_is_halo), u_translation: new o.bU(v, e.u_translation), u_pitched_scale: new o.bg(v, e.u_pitched_scale) }), symbolTextAndIcon: (v, e) => ({ u_is_size_zoom_constant: new o.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bP(v, e.u_is_size_feature_constant), u_size_t: new o.bg(v, e.u_size_t), u_size: new o.bg(v, e.u_size), u_camera_to_center_distance: new o.bg(v, e.u_camera_to_center_distance), u_pitch: new o.bg(v, e.u_pitch), u_rotate_symbol: new o.bP(v, e.u_rotate_symbol), u_aspect_ratio: new o.bg(v, e.u_aspect_ratio), u_fade_change: new o.bg(v, e.u_fade_change), u_label_plane_matrix: new o.bR(v, e.u_label_plane_matrix), u_coord_matrix: new o.bR(v, e.u_coord_matrix), u_is_text: new o.bP(v, e.u_is_text), u_pitch_with_map: new o.bP(v, e.u_pitch_with_map), u_is_along_line: new o.bP(v, e.u_is_along_line), u_is_variable_anchor: new o.bP(v, e.u_is_variable_anchor), u_texsize: new o.bU(v, e.u_texsize), u_texsize_icon: new o.bU(v, e.u_texsize_icon), u_texture: new o.bP(v, e.u_texture), u_texture_icon: new o.bP(v, e.u_texture_icon), u_gamma_scale: new o.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new o.bg(v, e.u_device_pixel_ratio), u_is_halo: new o.bP(v, e.u_is_halo), u_translation: new o.bU(v, e.u_translation), u_pitched_scale: new o.bg(v, e.u_pitched_scale) }), background: (v, e) => ({ u_opacity: new o.bg(v, e.u_opacity), u_color: new o.bQ(v, e.u_color) }), backgroundPattern: (v, e) => ({ u_opacity: new o.bg(v, e.u_opacity), u_image: new o.bP(v, e.u_image), u_pattern_tl_a: new o.bU(v, e.u_pattern_tl_a), u_pattern_br_a: new o.bU(v, e.u_pattern_br_a), u_pattern_tl_b: new o.bU(v, e.u_pattern_tl_b), u_pattern_br_b: new o.bU(v, e.u_pattern_br_b), u_texsize: new o.bU(v, e.u_texsize), u_mix: new o.bg(v, e.u_mix), u_pattern_size_a: new o.bU(v, e.u_pattern_size_a), u_pattern_size_b: new o.bU(v, e.u_pattern_size_b), u_scale_a: new o.bg(v, e.u_scale_a), u_scale_b: new o.bg(v, e.u_scale_b), u_pixel_coord_upper: new o.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new o.bU(v, e.u_pixel_coord_lower), u_tile_units_to_pixels: new o.bg(v, e.u_tile_units_to_pixels) }), terrain: (v, e) => ({ u_texture: new o.bP(v, e.u_texture), u_ele_delta: new o.bg(v, e.u_ele_delta), u_fog_matrix: new o.bR(v, e.u_fog_matrix), u_fog_color: new o.bQ(v, e.u_fog_color), u_fog_ground_blend: new o.bg(v, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new o.bg(v, e.u_fog_ground_blend_opacity), u_horizon_color: new o.bQ(v, e.u_horizon_color), u_horizon_fog_blend: new o.bg(v, e.u_horizon_fog_blend), u_is_globe_mode: new o.bg(v, e.u_is_globe_mode) }), terrainDepth: (v, e) => ({ u_ele_delta: new o.bg(v, e.u_ele_delta) }), terrainCoords: (v, e) => ({ u_texture: new o.bP(v, e.u_texture), u_terrain_coords_id: new o.bg(v, e.u_terrain_coords_id), u_ele_delta: new o.bg(v, e.u_ele_delta) }), projectionErrorMeasurement: (v, e) => ({ u_input: new o.bg(v, e.u_input), u_output_expected: new o.bg(v, e.u_output_expected) }), atmosphere: (v, e) => ({ u_sun_pos: new o.bT(v, e.u_sun_pos), u_atmosphere_blend: new o.bg(v, e.u_atmosphere_blend), u_globe_position: new o.bT(v, e.u_globe_position), u_globe_radius: new o.bg(v, e.u_globe_radius), u_inv_proj_matrix: new o.bR(v, e.u_inv_proj_matrix) }), sky: (v, e) => ({ u_sky_color: new o.bQ(v, e.u_sky_color), u_horizon_color: new o.bQ(v, e.u_horizon_color), u_horizon: new o.bU(v, e.u_horizon), u_horizon_normal: new o.bU(v, e.u_horizon_normal), u_sky_horizon_blend: new o.bg(v, e.u_sky_horizon_blend), u_sky_blend: new o.bg(v, e.u_sky_blend) }) };
        class ih {
          constructor(e, s, u) {
            this.context = e;
            const m = e.gl;
            this.buffer = m.createBuffer(), this.dynamicDraw = !!u, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? m.DYNAMIC_DRAW : m.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const s = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Zl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Lo {
          constructor(e, s, u, m) {
            this.length = s.length, this.attributes = u, this.itemSize = s.bytesPerElement, this.dynamicDraw = m, this.context = e;
            const y = e.gl;
            this.buffer = y.createBuffer(), e.bindVertexBuffer.set(this.buffer), y.bufferData(y.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const s = this.context.gl;
            this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, s) {
            for (let u = 0; u < this.attributes.length; u++) {
              const m = s.attributes[this.attributes[u].name];
              m !== void 0 && e.enableVertexAttribArray(m);
            }
          }
          setVertexAttribPointers(e, s, u) {
            for (let m = 0; m < this.attributes.length; m++) {
              const y = this.attributes[m], x = s.attributes[y.name];
              x !== void 0 && e.vertexAttribPointer(x, y.components, e[Zl[y.type]], false, this.itemSize, y.offset + this.itemSize * (u || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Lr {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class _u extends Lr {
          getDefault() {
            return o.bf.transparent;
          }
          set(e) {
            const s = this.current;
            (e.r !== s.r || e.g !== s.g || e.b !== s.b || e.a !== s.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class bu extends Lr {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = false);
          }
        }
        class oh extends Lr {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = false);
          }
        }
        class xu extends Lr {
          getDefault() {
            return [true, true, true, true];
          }
          set(e) {
            const s = this.current;
            (e[0] !== s[0] || e[1] !== s[1] || e[2] !== s[2] || e[3] !== s[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Ps extends Lr {
          getDefault() {
            return true;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = false);
          }
        }
        class wu extends Lr {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = false);
          }
        }
        class cf extends Lr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const s = this.current;
            (e.func !== s.func || e.ref !== s.ref || e.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
          }
        }
        class uf extends Lr {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const s = this.current;
            (e[0] !== s[0] || e[1] !== s[1] || e[2] !== s[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
          }
        }
        class df extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            e ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = e, this.dirty = false;
          }
        }
        class hf extends Lr {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const s = this.current;
            (e[0] !== s[0] || e[1] !== s[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class sh extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            e ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = e, this.dirty = false;
          }
        }
        class pf extends Lr {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = false);
          }
        }
        class ah extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            e ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = e, this.dirty = false;
          }
        }
        class Hl extends Lr {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const s = this.current;
            (e[0] !== s[0] || e[1] !== s[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class Xl extends Lr {
          getDefault() {
            return o.bf.transparent;
          }
          set(e) {
            const s = this.current;
            (e.r !== s.r || e.g !== s.g || e.b !== s.b || e.a !== s.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Yl extends Lr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = false);
          }
        }
        class Cu extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            e ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = e, this.dirty = false;
          }
        }
        class Ts extends Lr {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = false);
          }
        }
        class Za extends Lr {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = false);
          }
        }
        class Js extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = false);
          }
        }
        class Gi extends Lr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = false);
          }
        }
        class lh extends Lr {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const s = this.current;
            (e[0] !== s[0] || e[1] !== s[1] || e[2] !== s[2] || e[3] !== s[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class ch extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Su extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindRenderbuffer(s.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Ms extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindTexture(s.TEXTURE_2D, e), this.current = e, this.dirty = false;
          }
        }
        class Kl extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindBuffer(s.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Jl extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            const s = this.gl;
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Ha extends Lr {
          getDefault() {
            return null;
          }
          set(e) {
            var s;
            if (e === this.current && !this.dirty) return;
            const u = this.gl;
            ko(u) ? u.bindVertexArray(e) : (s = u.getExtension("OES_vertex_array_object")) === null || s === void 0 || s.bindVertexArrayOES(e), this.current = e, this.dirty = false;
          }
        }
        class Ql extends Lr {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
          }
        }
        class uh extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class Qs extends Lr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class es extends Lr {
          constructor(e, s) {
            super(e), this.context = e, this.parent = s;
          }
          getDefault() {
            return null;
          }
        }
        class dh extends es {
          setDirty() {
            this.dirty = true;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
          }
        }
        class ku extends es {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Mr extends es {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        const Xa = "Framebuffer is not complete";
        class ff {
          constructor(e, s, u, m, y) {
            this.context = e, this.width = s, this.height = u;
            const x = e.gl, T = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new dh(e, T), m) this.depthAttachment = y ? new Mr(e, T) : new ku(e, T);
            else if (y) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error(Xa);
          }
          destroy() {
            const e = this.context.gl, s = this.colorAttachment.get();
            if (s && e.deleteTexture(s), this.depthAttachment) {
              const u = this.depthAttachment.get();
              u && e.deleteRenderbuffer(u);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class hh {
          constructor(e) {
            var s, u;
            if (this.gl = e, this.clearColor = new _u(this), this.clearDepth = new bu(this), this.clearStencil = new oh(this), this.colorMask = new xu(this), this.depthMask = new Ps(this), this.stencilMask = new wu(this), this.stencilFunc = new cf(this), this.stencilOp = new uf(this), this.stencilTest = new df(this), this.depthRange = new hf(this), this.depthTest = new sh(this), this.depthFunc = new pf(this), this.blend = new ah(this), this.blendFunc = new Hl(this), this.blendColor = new Xl(this), this.blendEquation = new Yl(this), this.cullFace = new Cu(this), this.cullFaceSide = new Ts(this), this.frontFace = new Za(this), this.program = new Js(this), this.activeTexture = new Gi(this), this.viewport = new lh(this), this.bindFramebuffer = new ch(this), this.bindRenderbuffer = new Su(this), this.bindTexture = new Ms(this), this.bindVertexBuffer = new Kl(this), this.bindElementBuffer = new Jl(this), this.bindVertexArray = new Ha(this), this.pixelStoreUnpack = new Ql(this), this.pixelStoreUnpackPremultiplyAlpha = new uh(this), this.pixelStoreUnpackFlipY = new Qs(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), ko(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const m = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (s = e.RGBA16F) !== null && s !== void 0 ? s : m == null ? void 0 : m.RGBA16F_EXT, this.RGB16F = (u = e.RGB16F) !== null && u !== void 0 ? u : m == null ? void 0 : m.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const m = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = m == null ? void 0 : m.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e, s) {
            return new ih(this, e, s);
          }
          createVertexBuffer(e, s, u) {
            return new Lo(this, e, s, u);
          }
          createRenderbuffer(e, s, u) {
            const m = this.gl, y = m.createRenderbuffer();
            return this.bindRenderbuffer.set(y), m.renderbufferStorage(m.RENDERBUFFER, e, s, u), this.bindRenderbuffer.set(null), y;
          }
          createFramebuffer(e, s, u, m) {
            return new ff(this, e, s, u, m);
          }
          clear({ color: e, depth: s, stencil: u }) {
            const m = this.gl;
            let y = 0;
            e && (y |= m.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), s !== void 0 && (y |= m.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(true)), u !== void 0 && (y |= m.STENCIL_BUFFER_BIT, this.clearStencil.set(u), this.stencilMask.set(255)), m.clear(y);
          }
          setCullFace(e) {
            e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(false);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e) {
            o.bH(e.blendFunction, cn.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return ko(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var s;
            return ko(this.gl) ? this.gl.deleteVertexArray(e) : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let ts;
        function ph(v, e, s, u, m) {
          const y = v.context, x = v.transform, T = y.gl, M = v.useProgram("collisionBox"), D = [];
          let F = 0, j = 0;
          for (let pe = 0; pe < u.length; pe++) {
            const ge = u[pe], Ce = e.getTile(ge).getBucket(s);
            if (!Ce) continue;
            const xe = m ? Ce.textCollisionBox : Ce.iconCollisionBox, ke = Ce.collisionCircleArray;
            ke.length > 0 && (D.push({ circleArray: ke, circleOffset: j, coord: ge }), F += ke.length / 4, j = F), xe && M.draw(y, T.LINES, vr.disabled, Dr.disabled, v.colorModeForRenderPass(), lr.disabled, Gl(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(ge), x.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: true, applyTerrainMatrix: true }), s.id, xe.layoutVertexBuffer, xe.indexBuffer, xe.segments, null, v.transform.zoom, null, null, xe.collisionVertexBuffer);
          }
          if (!m || !D.length) return;
          const $ = v.useProgram("collisionCircle"), G = new o.b$();
          G.resize(4 * F), G._trim();
          let ee = 0;
          for (const pe of D) for (let ge = 0; ge < pe.circleArray.length / 4; ge++) {
            const Ce = 4 * ge, xe = pe.circleArray[Ce + 0], ke = pe.circleArray[Ce + 1], ze = pe.circleArray[Ce + 2], we = pe.circleArray[Ce + 3];
            G.emplace(ee++, xe, ke, ze, we, 0), G.emplace(ee++, xe, ke, ze, we, 1), G.emplace(ee++, xe, ke, ze, we, 2), G.emplace(ee++, xe, ke, ze, we, 3);
          }
          (!ts || ts.length < 2 * F) && (ts = (function(pe) {
            const ge = 2 * pe, Ce = new o.c1();
            Ce.resize(ge), Ce._trim();
            for (let xe = 0; xe < ge; xe++) {
              const ke = 6 * xe;
              Ce.uint16[ke + 0] = 4 * xe + 0, Ce.uint16[ke + 1] = 4 * xe + 1, Ce.uint16[ke + 2] = 4 * xe + 2, Ce.uint16[ke + 3] = 4 * xe + 2, Ce.uint16[ke + 4] = 4 * xe + 3, Ce.uint16[ke + 5] = 4 * xe + 0;
            }
            return Ce;
          })(F));
          const ue = y.createIndexBuffer(ts, true), ce = y.createVertexBuffer(G, o.c0.members, true);
          for (const pe of D) {
            const ge = of(v.transform);
            $.draw(y, T.TRIANGLES, vr.disabled, Dr.disabled, v.colorModeForRenderPass(), lr.disabled, ge, v.style.map.terrain && v.style.map.terrain.getTerrainData(pe.coord), null, s.id, ce, ue, o.aM.simpleSegment(0, 2 * pe.circleOffset, pe.circleArray.length, pe.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          ce.destroy(), ue.destroy();
        }
        const mf = o.ag(new Float32Array(16));
        function fh(v, e, s, u, m, y) {
          const { horizontalAlign: x, verticalAlign: T } = o.aH(v);
          return new o.P((-(x - 0.5) * e / m + u[0]) * y, (-(T - 0.5) * s / m + u[1]) * y);
        }
        function gf(v, e, s, u, m, y) {
          const x = e.tileAnchorPoint.add(new o.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let T = u.mult(y);
            s || (T = T.rotate(-m));
            const M = x.add(T);
            return Hr(M.x, M.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (s) {
            const T = an(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(v), M = Math.atan(T.y / T.x) + (T.x < 0 ? Math.PI : 0);
            return v.add(u.rotate(M));
          }
          return v.add(u);
        }
        function Pu(v, e, s, u, m, y, x, T, M, D, F, j) {
          const $ = v.text.placedSymbolArray, G = v.text.dynamicLayoutVertexArray, ee = v.icon.dynamicLayoutVertexArray, ue = {};
          G.clear();
          for (let ce = 0; ce < $.length; ce++) {
            const pe = $.get(ce), ge = pe.hidden || !pe.crossTileID || v.allowVerticalPlacement && !pe.placedOrientation ? null : u[pe.crossTileID];
            if (ge) {
              const Ce = new o.P(pe.anchorX, pe.anchorY), xe = { getElevation: j, width: m.width, height: m.height, pitchedLabelPlaneMatrix: y, pitchWithMap: s, transform: m, tileAnchorPoint: Ce, translation: D, unwrappedTileID: F }, ke = s ? ni(Ce.x, Ce.y, xe) : an(Ce.x, Ce.y, xe), ze = ye(m.cameraToCenterDistance, ke.signedDistanceFromCamera);
              let we = o.ap(v.textSizeData, T, pe) * ze / o.aB;
              s && (we *= v.tilePixelRatio / x);
              const { width: je, height: Qe, anchor: qe, textOffset: Ze, textBoxScale: Je } = ge, Tt = fh(qe, je, Qe, Ze, Je, we), It = m.getPitchedTextCorrection(Ce.x + D[0], Ce.y + D[1], F), ft = gf(ke.point, xe, e, Tt, -m.bearingInRadians, It), Zt = v.allowVerticalPlacement && pe.placedOrientation === o.ao.vertical ? Math.PI / 2 : 0;
              for (let xr = 0; xr < pe.numGlyphs; xr++) o.av(G, ft, Zt);
              M && pe.associatedIconIndex >= 0 && (ue[pe.associatedIconIndex] = { shiftedAnchor: ft, angle: Zt });
            } else Si(pe.numGlyphs, G);
          }
          if (M) {
            ee.clear();
            const ce = v.icon.placedSymbolArray;
            for (let pe = 0; pe < ce.length; pe++) {
              const ge = ce.get(pe);
              if (ge.hidden) Si(ge.numGlyphs, ee);
              else {
                const Ce = ue[pe];
                if (Ce) for (let xe = 0; xe < ge.numGlyphs; xe++) o.av(ee, Ce.shiftedAnchor, Ce.angle);
                else Si(ge.numGlyphs, ee);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(ee);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(G);
        }
        function ec(v, e, s) {
          return s.iconsInText && e ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function Ya(v, e, s, u, m, y, x, T, M, D, F, j, $) {
          const G = v.context, ee = G.gl, ue = v.transform, ce = T === "map", pe = M === "map", ge = T !== "viewport" && s.layout.get("symbol-placement") !== "point", Ce = ce && !pe && !ge, xe = !s.layout.get("symbol-sort-key").isConstant();
          let ke = false;
          const ze = v.getDepthModeForSublayer(0, vr.ReadOnly), we = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), je = [], Qe = ue.getCircleRadiusCorrection();
          for (const qe of u) {
            const Ze = e.getTile(qe), Je = Ze.getBucket(s);
            if (!Je) continue;
            const Tt = m ? Je.text : Je.icon;
            if (!Tt || !Tt.segments.get().length || !Tt.hasVisibleVertices) continue;
            const It = Tt.programConfigurations.get(s.id), ft = m || Je.sdfIcons, Zt = m ? Je.textSizeData : Je.iconSizeData, xr = pe || ue.pitch !== 0, $r = v.useProgram(ec(ft, m, Je), It), Kr = o.an(Zt, ue.zoom), Wr = v.style.map.terrain && v.style.map.terrain.getTerrainData(qe);
            let fn, _n, br, Jr, In = [0, 0], Fn = null;
            if (m) _n = Ze.glyphAtlasTexture, br = ee.LINEAR, fn = Ze.glyphAtlasTexture.size, Je.iconsInText && (In = Ze.imageAtlasTexture.size, Fn = Ze.imageAtlasTexture, Jr = xr || v.options.rotating || v.options.zooming || Zt.kind === "composite" || Zt.kind === "camera" ? ee.LINEAR : ee.NEAREST);
            else {
              const En = s.layout.get("icon-size").constantOr(0) !== 1 || Je.iconsNeedLinear;
              _n = Ze.imageAtlasTexture, br = ft || v.options.rotating || v.options.zooming || En || xr ? ee.LINEAR : ee.NEAREST, fn = Ze.imageAtlasTexture.size;
            }
            const Un = o.aC(Ze, 1, v.transform.zoom), fi = sn(ce, v.transform, Un), ao = o.L();
            o.aq(ao, fi);
            const ns = _r(pe, ce, v.transform, Un), is = o.aD(ue, Ze, y, x), da = ue.getProjectionData({ overscaledTileID: qe, applyGlobeMatrix: !$, applyTerrainMatrix: true }), ha = we && Je.hasTextData(), Fs = s.layout.get("icon-text-fit") !== "none" && ha && Je.hasIconData();
            if (ge) {
              const En = v.style.map.terrain ? (Hi, Rn) => v.style.map.terrain.getElevation(qe, Hi, Rn) : null, Ln = s.layout.get("text-rotation-alignment") === "map";
              Vt(Je, v, m, fi, ao, pe, D, Ln, qe.toUnwrapped(), ue.width, ue.height, is, En);
            }
            const Ls = m && we || Fs, Ti = ge || Ls ? mf : pe ? fi : v.transform.clipSpaceToPixelsMatrix, lo = ft && s.paint.get(m ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let mi;
            mi = ft ? Je.iconsInText ? lf(Zt.kind, Kr, Ce, pe, ge, Ls, v, Ti, ns, is, fn, In, Qe) : th(Zt.kind, Kr, Ce, pe, ge, Ls, v, Ti, ns, is, m, fn, 0, Qe) : Wa(Zt.kind, Kr, Ce, pe, ge, Ls, v, Ti, ns, is, m, fn, Qe);
            const os = { program: $r, buffers: Tt, uniformValues: mi, projectionData: da, atlasTexture: _n, atlasTextureIcon: Fn, atlasInterpolation: br, atlasInterpolationIcon: Jr, isSDF: ft, hasHalo: lo };
            if (xe && Je.canOverlap) {
              ke = true;
              const En = Tt.segments.get();
              for (const Ln of En) je.push({ segments: new o.aM([Ln]), sortKey: Ln.sortKey, state: os, terrainData: Wr });
            } else je.push({ segments: Tt.segments, sortKey: 0, state: os, terrainData: Wr });
          }
          ke && je.sort(((qe, Ze) => qe.sortKey - Ze.sortKey));
          for (const qe of je) {
            const Ze = qe.state;
            if (G.activeTexture.set(ee.TEXTURE0), Ze.atlasTexture.bind(Ze.atlasInterpolation, ee.CLAMP_TO_EDGE), Ze.atlasTextureIcon && (G.activeTexture.set(ee.TEXTURE1), Ze.atlasTextureIcon && Ze.atlasTextureIcon.bind(Ze.atlasInterpolationIcon, ee.CLAMP_TO_EDGE)), Ze.isSDF) {
              const Je = Ze.uniformValues;
              Ze.hasHalo && (Je.u_is_halo = 1, Ka(Ze.buffers, qe.segments, s, v, Ze.program, ze, F, j, Je, Ze.projectionData, qe.terrainData)), Je.u_is_halo = 0;
            }
            Ka(Ze.buffers, qe.segments, s, v, Ze.program, ze, F, j, Ze.uniformValues, Ze.projectionData, qe.terrainData);
          }
        }
        function Ka(v, e, s, u, m, y, x, T, M, D, F) {
          const j = u.context;
          m.draw(j, j.gl.TRIANGLES, y, x, T, lr.backCCW, M, F, D, s.id, v.layoutVertexBuffer, v.indexBuffer, e, s.paint, u.transform.zoom, v.programConfigurations.get(s.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function Tu(v, e, s, u, m) {
          const y = v.context, x = y.gl, T = Dr.disabled, M = new cn([x.ONE, x.ONE], o.bf.transparent, [true, true, true, true]), D = e.getBucket(s);
          if (!D) return;
          const F = u.key;
          let j = s.heatmapFbos.get(F);
          j || (j = Ja(y, e.tileSize, e.tileSize), s.heatmapFbos.set(F, j)), y.bindFramebuffer.set(j.framebuffer), y.viewport.set([0, 0, e.tileSize, e.tileSize]), y.clear({ color: o.bf.transparent });
          const $ = D.programConfigurations.get(s.id), G = v.useProgram("heatmap", $, !m), ee = v.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), ue = v.style.map.terrain.getTerrainData(u);
          G.draw(y, x.TRIANGLES, vr.disabled, T, M, lr.disabled, Yd(e, v.transform.zoom, s.paint.get("heatmap-intensity"), 1), ue, ee, s.id, D.layoutVertexBuffer, D.indexBuffer, D.segments, s.paint, v.transform.zoom, $);
        }
        function mh(v, e, s, u, m) {
          const y = v.context, x = y.gl, T = v.transform;
          y.setColorMode(v.colorModeForRenderPass());
          const M = Qa(y, e), D = s.key, F = e.heatmapFbos.get(D);
          if (!F) return;
          y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, F.colorAttachment.get()), y.activeTexture.set(x.TEXTURE1), M.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const j = T.getProjectionData({ overscaledTileID: s, applyTerrainMatrix: m, applyGlobeMatrix: !u });
          v.useProgram("heatmapTexture").draw(y, x.TRIANGLES, vr.disabled, Dr.disabled, v.colorModeForRenderPass(), lr.disabled, pu(v, e, 0, 1), null, j, e.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, e.paint, T.zoom), F.destroy(), e.heatmapFbos.delete(D);
        }
        function Ja(v, e, s) {
          var u, m;
          const y = v.gl, x = y.createTexture();
          y.bindTexture(y.TEXTURE_2D, x), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.LINEAR), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.LINEAR);
          const T = (u = v.HALF_FLOAT) !== null && u !== void 0 ? u : y.UNSIGNED_BYTE, M = (m = v.RGBA16F) !== null && m !== void 0 ? m : y.RGBA;
          y.texImage2D(y.TEXTURE_2D, 0, M, e, s, 0, y.RGBA, T, null);
          const D = v.createFramebuffer(e, s, false, false);
          return D.colorAttachment.set(x), D;
        }
        function Qa(v, e) {
          return e.colorRampTexture || (e.colorRampTexture = new o.T(v, e.colorRamp, v.gl.RGBA)), e.colorRampTexture;
        }
        function el(v, e, s, u, m) {
          if (!s || !u || !u.imageAtlas) return;
          const y = u.imageAtlas.patternPositions;
          let x = y[s.to.toString()], T = y[s.from.toString()];
          if (!x && T && (x = T), !T && x && (T = x), !x || !T) {
            const M = m.getPaintProperty(e);
            x = y[M], T = y[M];
          }
          x && T && v.setConstantPatternPositions(x, T);
        }
        function tc(v, e, s, u, m, y, x, T) {
          const M = v.context.gl, D = "fill-pattern", F = s.paint.get(D), j = F && F.constantOr(1), $ = s.getCrossfadeParameters();
          let G, ee, ue, ce, pe;
          const ge = v.transform, Ce = s.paint.get("fill-translate"), xe = s.paint.get("fill-translate-anchor");
          x ? (ee = j && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", G = M.LINES) : (ee = j ? "fillPattern" : "fill", G = M.TRIANGLES);
          const ke = F.constantOr(null);
          for (const ze of u) {
            const we = e.getTile(ze);
            if (j && !we.patternsLoaded()) continue;
            const je = we.getBucket(s);
            if (!je) continue;
            const Qe = je.programConfigurations.get(s.id), qe = v.useProgram(ee, Qe), Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(ze);
            j && (v.context.activeTexture.set(M.TEXTURE0), we.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE), Qe.updatePaintBuffers($)), el(Qe, D, ke, we, s);
            const Je = ge.getProjectionData({ overscaledTileID: ze, applyGlobeMatrix: !T, applyTerrainMatrix: true }), Tt = o.aD(ge, we, Ce, xe);
            if (x) {
              ce = je.indexBuffer2, pe = je.segments2;
              const ft = [M.drawingBufferWidth, M.drawingBufferHeight];
              ue = ee === "fillOutlinePattern" && j ? qa(v, $, we, ft, Tt) : Ua(ft, Tt);
            } else ce = je.indexBuffer, pe = je.segments, ue = j ? ql(v, $, we, Tt) : { u_fill_translate: Tt };
            const It = v.stencilModeForClipping(ze);
            qe.draw(v.context, G, m, It, y, lr.backCCW, ue, Ze, Je, s.id, je.layoutVertexBuffer, ce, pe, s.paint, v.transform.zoom, Qe);
          }
        }
        function Mu(v, e, s, u, m, y, x, T) {
          const M = v.context, D = M.gl, F = "fill-extrusion-pattern", j = s.paint.get(F), $ = j.constantOr(1), G = s.getCrossfadeParameters(), ee = s.paint.get("fill-extrusion-opacity"), ue = j.constantOr(null), ce = v.transform;
          for (const pe of u) {
            const ge = e.getTile(pe), Ce = ge.getBucket(s);
            if (!Ce) continue;
            const xe = v.style.map.terrain && v.style.map.terrain.getTerrainData(pe), ke = Ce.programConfigurations.get(s.id), ze = v.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", ke);
            $ && (v.context.activeTexture.set(D.TEXTURE0), ge.imageAtlasTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE), ke.updatePaintBuffers(G));
            const we = ce.getProjectionData({ overscaledTileID: pe, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            el(ke, F, ue, ge, s);
            const je = o.aD(ce, ge, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), Qe = s.paint.get("fill-extrusion-vertical-gradient"), qe = $ ? rf(v, Qe, ee, je, pe, G, ge) : to(v, Qe, ee, je);
            ze.draw(M, M.gl.TRIANGLES, m, y, x, lr.backCCW, qe, xe, we, s.id, Ce.layoutVertexBuffer, Ce.indexBuffer, Ce.segments, s.paint, v.transform.zoom, ke, v.style.map.terrain && Ce.centroidVertexBuffer);
          }
        }
        function Is(v, e, s, u, m, y, x, T, M) {
          var D;
          const F = v.style.projection, j = v.context, $ = v.transform, G = j.gl, ee = [`#define NUM_ILLUMINATION_SOURCES ${s.paint.get("hillshade-highlight-color").values.length}`], ue = v.useProgram("hillshade", null, false, ee), ce = !v.options.moving;
          for (const pe of u) {
            const ge = e.getTile(pe), Ce = ge.fbo;
            if (!Ce) continue;
            const xe = F.getMeshFromTileID(j, pe.canonical, T, true, "raster"), ke = (D = v.style.map.terrain) === null || D === void 0 ? void 0 : D.getTerrainData(pe);
            j.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, Ce.colorAttachment.get());
            const ze = $.getProjectionData({ overscaledTileID: pe, aligned: ce, applyGlobeMatrix: !M, applyTerrainMatrix: true });
            ue.draw(j, G.TRIANGLES, y, m[pe.overscaledZ], x, lr.backCCW, sf(v, ge, s), ke, ze, s.id, xe.vertexBuffer, xe.indexBuffer, xe.segments);
          }
        }
        function Iu(v, e, s, u, m, y, x, T, M) {
          var D;
          const F = v.style.projection, j = v.context, $ = v.transform, G = j.gl, ee = v.useProgram("colorRelief"), ue = !v.options.moving;
          let ce = true, pe = 0;
          for (const ge of u) {
            const Ce = e.getTile(ge), xe = Ce.dem;
            if (ce) {
              const qe = G.getParameter(G.MAX_TEXTURE_SIZE), { elevationTexture: Ze, colorTexture: Je } = s.getColorRampTextures(j, qe, xe.getUnpackVector());
              j.activeTexture.set(G.TEXTURE1), Ze.bind(G.NEAREST, G.CLAMP_TO_EDGE), j.activeTexture.set(G.TEXTURE4), Je.bind(G.LINEAR, G.CLAMP_TO_EDGE), ce = false, pe = Ze.size[0];
            }
            if (!xe || !xe.data) continue;
            const ke = xe.stride, ze = xe.getPixels();
            if (j.activeTexture.set(G.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(false), Ce.demTexture = Ce.demTexture || v.getTileTexture(ke), Ce.demTexture) {
              const qe = Ce.demTexture;
              qe.update(ze, { premultiply: false }), qe.bind(G.LINEAR, G.CLAMP_TO_EDGE);
            } else Ce.demTexture = new o.T(j, ze, G.RGBA, { premultiply: false }), Ce.demTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
            const we = F.getMeshFromTileID(j, ge.canonical, T, true, "raster"), je = (D = v.style.map.terrain) === null || D === void 0 ? void 0 : D.getTerrainData(ge), Qe = $.getProjectionData({ overscaledTileID: ge, aligned: ue, applyGlobeMatrix: !M, applyTerrainMatrix: true });
            ee.draw(j, G.TRIANGLES, y, m[ge.overscaledZ], x, lr.backCCW, Jd(s, Ce.dem, pe), je, Qe, s.id, we.vertexBuffer, we.indexBuffer, we.segments);
          }
        }
        const rc = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];
        function Es(v, e, s, u, m, y, x, T, M = false, D = false) {
          const F = u[u.length - 1].overscaledZ, j = v.context, $ = j.gl, G = v.useProgram("raster"), ee = v.transform, ue = v.style.projection, ce = v.colorModeForRenderPass(), pe = !v.options.moving;
          for (const ge of u) {
            const Ce = v.getDepthModeForSublayer(ge.overscaledZ - F, s.paint.get("raster-opacity") === 1 ? vr.ReadWrite : vr.ReadOnly, $.LESS), xe = e.getTile(ge);
            xe.registerFadeDuration(s.paint.get("raster-fade-duration"));
            const ke = e.findLoadedParent(ge, 0), ze = e.findLoadedSibling(ge), we = Eu(xe, ke || ze || null, e, s, v.transform, v.style.map.terrain);
            let je, Qe;
            const qe = s.paint.get("raster-resampling") === "nearest" ? $.NEAREST : $.LINEAR;
            j.activeTexture.set($.TEXTURE0), xe.texture.bind(qe, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), j.activeTexture.set($.TEXTURE1), ke ? (ke.texture.bind(qe, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), je = Math.pow(2, ke.tileID.overscaledZ - xe.tileID.overscaledZ), Qe = [xe.tileID.canonical.x * je % 1, xe.tileID.canonical.y * je % 1]) : xe.texture.bind(qe, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), xe.texture.useMipmap && j.extTextureFilterAnisotropic && v.transform.pitch > 20 && $.texParameterf($.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(ge), Je = ee.getProjectionData({ overscaledTileID: ge, aligned: pe, applyGlobeMatrix: !D, applyTerrainMatrix: true }), Tt = Ga(Qe || [0, 0], je || 1, we, s, T), It = ue.getMeshFromTileID(j, ge.canonical, y, x, "raster");
            G.draw(j, $.TRIANGLES, Ce, m ? m[ge.overscaledZ] : Dr.disabled, ce, M ? lr.frontCCW : lr.backCCW, Tt, Ze, Je, s.id, It.vertexBuffer, It.indexBuffer, It.segments);
          }
        }
        function Eu(v, e, s, u, m, y) {
          const x = u.paint.get("raster-fade-duration");
          if (!y && x > 0) {
            const T = z.now(), M = (T - v.timeAdded) / x, D = e ? (T - e.timeAdded) / x : -1, F = s.getSource(), j = wt(m, { tileSize: F.tileSize, roundZoom: F.roundZoom }), $ = !e || Math.abs(e.tileID.overscaledZ - j) > Math.abs(v.tileID.overscaledZ - j), G = $ && v.refreshedUponExpiration ? 1 : o.ah($ ? M : 1 - D, 0, 1);
            return v.refreshedUponExpiration && M >= 1 && (v.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - G } : { opacity: G, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const gh = new o.bf(1, 0, 0, 1), vh = new o.bf(0, 1, 0, 1), nc = new o.bf(0, 0, 1, 1), Ru = new o.bf(1, 0, 1, 1), vf = new o.bf(0, 1, 1, 1);
        function zu(v, e, s, u) {
          Mo(v, 0, e + s / 2, v.transform.width, s, u);
        }
        function yn(v, e, s, u) {
          Mo(v, e - s / 2, 0, s, v.transform.height, u);
        }
        function Mo(v, e, s, u, m, y) {
          const x = v.context, T = x.gl;
          T.enable(T.SCISSOR_TEST), T.scissor(e * v.pixelRatio, s * v.pixelRatio, u * v.pixelRatio, m * v.pixelRatio), x.clear({ color: y }), T.disable(T.SCISSOR_TEST);
        }
        function Wi(v, e, s) {
          const u = v.context, m = u.gl, y = v.useProgram("debug"), x = vr.disabled, T = Dr.disabled, M = v.colorModeForRenderPass(), D = "$debug", F = v.style.map.terrain && v.style.map.terrain.getTerrainData(s);
          u.activeTexture.set(m.TEXTURE0);
          const j = e.getTileByID(s.key).latestRawTileData, $ = Math.floor((j && j.byteLength || 0) / 1024), G = e.getTile(s).tileSize, ee = 512 / Math.min(G, 512) * (s.overscaledZ / v.transform.zoom) * 0.5;
          let ue = s.canonical.toString();
          s.overscaledZ !== s.canonical.z && (ue += ` => ${s.overscaledZ}`), (function(pe, ge) {
            pe.initDebugOverlayCanvas();
            const Ce = pe.debugOverlayCanvas, xe = pe.context.gl, ke = pe.debugOverlayCanvas.getContext("2d");
            ke.clearRect(0, 0, Ce.width, Ce.height), ke.shadowColor = "white", ke.shadowBlur = 2, ke.lineWidth = 1.5, ke.strokeStyle = "white", ke.textBaseline = "top", ke.font = "bold 36px Open Sans, sans-serif", ke.fillText(ge, 5, 5), ke.strokeText(ge, 5, 5), pe.debugOverlayTexture.update(Ce), pe.debugOverlayTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE);
          })(v, `${ue} ${$}kB`);
          const ce = v.transform.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: true, applyTerrainMatrix: true });
          y.draw(u, m.TRIANGLES, x, T, cn.alphaBlended, lr.disabled, Ss(o.bf.transparent, ee), null, ce, D, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), y.draw(u, m.LINE_STRIP, x, T, M, lr.disabled, Ss(o.bf.red), F, ce, D, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function ic(v, e, s, u) {
          const { isRenderingGlobe: m } = u, y = v.context, x = y.gl, T = v.transform, M = v.colorModeForRenderPass(), D = v.getDepthModeFor3D(), F = v.useProgram("terrain");
          y.bindFramebuffer.set(null), y.viewport.set([0, 0, v.width, v.height]);
          for (const j of s) {
            const $ = e.getTerrainMesh(j.tileID), G = v.renderToTexture.getTexture(j), ee = e.getTerrainData(j.tileID);
            y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, G.texture);
            const ue = e.getMeshFrameDelta(T.zoom), ce = T.calculateFogMatrix(j.tileID.toUnwrapped()), pe = Vl(ue, ce, v.style.sky, T.pitch, m), ge = T.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            F.draw(y, x.TRIANGLES, D, Dr.disabled, M, lr.backCCW, pe, ee, ge, "terrain", $.vertexBuffer, $.indexBuffer, $.segments);
          }
        }
        function tl(v, e) {
          if (!e.mesh) {
            const s = new o.aL();
            s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(1, 1), s.emplaceBack(-1, 1);
            const u = new o.aN();
            u.emplaceBack(0, 1, 2), u.emplaceBack(0, 2, 3), e.mesh = new Ao(v.createVertexBuffer(s, So.members), v.createIndexBuffer(u), o.aM.simpleSegment(0, 0, s.length, u.length));
          }
          return e.mesh;
        }
        class yh {
          constructor(e, s) {
            this.context = new hh(e), this.transform = s, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: o.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = or.maxUnderzooming + or.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Qo();
          }
          resize(e, s, u) {
            if (this.width = Math.floor(e * u), this.height = Math.floor(s * u), this.pixelRatio = u, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const m of this.style._order) this.style._layers[m].resize();
          }
          setup() {
            const e = this.context, s = new o.aL();
            s.emplaceBack(0, 0), s.emplaceBack(o.$, 0), s.emplaceBack(0, o.$), s.emplaceBack(o.$, o.$), this.tileExtentBuffer = e.createVertexBuffer(s, So.members), this.tileExtentSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const u = new o.aL();
            u.emplaceBack(0, 0), u.emplaceBack(o.$, 0), u.emplaceBack(0, o.$), u.emplaceBack(o.$, o.$), this.debugBuffer = e.createVertexBuffer(u, So.members), this.debugSegments = o.aM.simpleSegment(0, 0, 4, 5);
            const m = new o.c6();
            m.emplaceBack(0, 0, 0, 0), m.emplaceBack(o.$, 0, o.$, 0), m.emplaceBack(0, o.$, 0, o.$), m.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = e.createVertexBuffer(m, ef.members), this.rasterBoundsSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const y = new o.aL();
            y.emplaceBack(0, 0), y.emplaceBack(o.$, 0), y.emplaceBack(0, o.$), y.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(y, So.members), this.rasterBoundsSegmentsPosOnly = o.aM.simpleSegment(0, 0, 4, 5);
            const x = new o.aL();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(x, So.members), this.viewportSegments = o.aM.simpleSegment(0, 0, 4, 2);
            const T = new o.c7();
            T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(T);
            const M = new o.aN();
            M.emplaceBack(1, 0, 2), M.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(M);
            const D = this.context.gl;
            this.stencilClearMode = new Dr({ func: D.ALWAYS, mask: 0 }, 0, 255, D.ZERO, D.ZERO, D.ZERO), this.tileExtentMesh = new Ao(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, s = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const u = o.L();
            o.bY(u, 0, this.width, this.height, 0, 0, 1), o.N(u, u, [s.drawingBufferWidth, s.drawingBufferHeight, 0]);
            const m = { mainMatrix: u, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: u };
            this.useProgram("clippingMask", null, true).draw(e, s.TRIANGLES, vr.disabled, this.stencilClearMode, cn.disabled, lr.disabled, null, null, m, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, s, u) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !s || !s.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + s.length > 256 && this.clearStencil();
            const m = this.context;
            m.setColorMode(cn.disabled), m.setDepthMode(vr.disabled);
            const y = {};
            for (const x of s) y[x.key] = this.nextStencilID++;
            this._renderTileMasks(y, s, u, true), this._renderTileMasks(y, s, u, false), this._tileClippingMaskIDs = y;
          }
          _renderTileMasks(e, s, u, m) {
            const y = this.context, x = y.gl, T = this.style.projection, M = this.transform, D = this.useProgram("clippingMask");
            for (const F of s) {
              const j = e[F.key], $ = this.style.map.terrain && this.style.map.terrain.getTerrainData(F), G = T.getMeshFromTileID(this.context, F.canonical, m, true, "stencil"), ee = M.getProjectionData({ overscaledTileID: F, applyGlobeMatrix: !u, applyTerrainMatrix: true });
              D.draw(y, x.TRIANGLES, vr.disabled, new Dr({ func: x.ALWAYS, mask: 0 }, j, 255, x.KEEP, x.KEEP, x.REPLACE), cn.disabled, u ? lr.disabled : lr.backCCW, null, $, ee, "$clipping", G.vertexBuffer, G.indexBuffer, G.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, s = e.gl, u = this.style.projection, m = this.transform, y = this.useProgram("depth"), x = this.getDepthModeFor3D(), T = Te(m, { tileSize: m.tileSize });
            for (const M of T) {
              const D = this.style.map.terrain && this.style.map.terrain.getTerrainData(M), F = u.getMeshFromTileID(this.context, M.canonical, true, true, "raster"), j = m.getProjectionData({ overscaledTileID: M, applyGlobeMatrix: true, applyTerrainMatrix: true });
              y.draw(e, s.TRIANGLES, x, Dr.disabled, cn.disabled, lr.backCCW, null, D, j, "$clipping", F.vertexBuffer, F.indexBuffer, F.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, s = this.context.gl;
            return new Dr({ func: s.NOTEQUAL, mask: 255 }, e, 255, s.KEEP, s.KEEP, s.REPLACE);
          }
          stencilModeForClipping(e) {
            const s = this.context.gl;
            return new Dr({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, s.KEEP, s.KEEP, s.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const s = this.context.gl, u = e.sort(((x, T) => T.overscaledZ - x.overscaledZ)), m = u[u.length - 1].overscaledZ, y = u[0].overscaledZ - m + 1;
            if (y > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + y > 256 && this.clearStencil();
              const x = {};
              for (let T = 0; T < y; T++) x[T + m] = new Dr({ func: s.GEQUAL, mask: 255 }, T + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID += y, [x, u];
            }
            return [{ [m]: Dr.disabled }, u];
          }
          stencilConfigForOverlapTwoPass(e) {
            const s = this.context.gl, u = e.sort(((x, T) => T.overscaledZ - x.overscaledZ)), m = u[u.length - 1].overscaledZ, y = u[0].overscaledZ - m + 1;
            if (this.clearStencil(), y > 1) {
              const x = {}, T = {};
              for (let M = 0; M < y; M++) x[M + m] = new Dr({ func: s.GREATER, mask: 255 }, y + 1 + M, 255, s.KEEP, s.KEEP, s.REPLACE), T[M + m] = new Dr({ func: s.GREATER, mask: 255 }, 1 + M, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID = 2 * y + 1, [x, T, u];
            }
            return this.nextStencilID = 3, [{ [m]: new Dr({ func: s.GREATER, mask: 255 }, 2, 255, s.KEEP, s.KEEP, s.REPLACE) }, { [m]: new Dr({ func: s.GREATER, mask: 255 }, 1, 255, s.KEEP, s.KEEP, s.REPLACE) }, u];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new cn([e.CONSTANT_COLOR, e.ONE], new o.bf(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? cn.unblended : cn.alphaBlended;
          }
          getDepthModeForSublayer(e, s, u) {
            if (!this.opaquePassEnabledForLayer()) return vr.disabled;
            const m = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new vr(u || this.context.gl.LEQUAL, s, [m, m]);
          }
          getDepthModeFor3D() {
            return new vr(this.context.gl.LEQUAL, vr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, s) {
            var u, m;
            this.style = e, this.options = s, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(z.now()), this.imageManager.beginFrame();
            const y = this.style._order, x = this.style.sourceCaches, T = {}, M = {}, D = {}, F = { isRenderingToTexture: false, isRenderingGlobe: ((u = e.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0 };
            for (const $ in x) {
              const G = x[$];
              G.used && G.prepare(this.context), T[$] = G.getVisibleCoordinates(false), M[$] = T[$].slice().reverse(), D[$] = G.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let $ = 0; $ < y.length; $++) if (this.style._layers[y[$]].is3D()) {
              this.opaquePassCutoff = $;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const $ of y) {
              const G = this.style._layers[$];
              if (!G.hasOffscreenPass() || G.isHidden(this.transform.zoom)) continue;
              const ee = M[G.source];
              (G.type === "custom" || ee.length) && this.renderLayer(this, x[G.source], G, ee, F);
            }
            if ((m = this.style.projection) === null || m === void 0 || m.updateGPUdependent({ context: this.context, useProgram: ($) => this.useProgram($) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: s.showOverdrawInspector ? o.bf.black : o.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function($, G) {
              const ee = $.context, ue = ee.gl, ce = ((ze, we, je) => {
                const Qe = Math.cos(we.rollInRadians), qe = Math.sin(we.rollInRadians), Ze = Ie(we), Je = we.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: ze.properties.get("sky-color"), u_horizon_color: ze.properties.get("horizon-color"), u_horizon: [(we.width / 2 - Ze * qe) * je, (we.height / 2 + Ze * Qe) * je], u_horizon_normal: [-qe, Qe], u_sky_horizon_blend: ze.properties.get("sky-horizon-blend") * we.height / 2 * je, u_sky_blend: Je };
              })(G, $.style.map.transform, $.pixelRatio), pe = new vr(ue.LEQUAL, vr.ReadWrite, [0, 1]), ge = Dr.disabled, Ce = $.colorModeForRenderPass(), xe = $.useProgram("sky"), ke = tl(ee, G);
              xe.draw(ee, ue.TRIANGLES, pe, ge, Ce, lr.disabled, ce, null, void 0, "sky", ke.vertexBuffer, ke.indexBuffer, ke.segments);
            })(this, this.style.sky), this._showOverdrawInspector = s.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = y.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const $ = this.style._layers[y[this.currentLayer]], G = x[$.source], ee = T[$.source];
              this._renderTileClippingMasks($, ee, false), this.renderLayer(this, G, $, ee, F);
            }
            this.renderPass = "translucent";
            let j = false;
            for (this.currentLayer = 0; this.currentLayer < y.length; this.currentLayer++) {
              const $ = this.style._layers[y[this.currentLayer]], G = x[$.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer($, F)) continue;
              this.opaquePassEnabledForLayer() || j || (j = true, F.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const ee = ($.type === "symbol" ? D : M)[$.source];
              this._renderTileClippingMasks($, T[$.source], !!this.renderToTexture), this.renderLayer(this, G, $, ee, F);
            }
            if (F.isRenderingGlobe && (function($, G, ee) {
              const ue = $.context, ce = ue.gl, pe = $.useProgram("atmosphere"), ge = new vr(ce.LEQUAL, vr.ReadOnly, [0, 1]), Ce = $.transform, xe = (function(Je, Tt) {
                const It = Je.properties.get("position"), ft = [-It.x, -It.y, -It.z], Zt = o.ag(new Float64Array(16));
                return Je.properties.get("anchor") === "map" && (o.b6(Zt, Zt, Tt.rollInRadians), o.b7(Zt, Zt, -Tt.pitchInRadians), o.b6(Zt, Zt, Tt.bearingInRadians), o.b7(Zt, Zt, Tt.center.lat * Math.PI / 180), o.bz(Zt, Zt, -Tt.center.lng * Math.PI / 180)), o.c5(ft, ft, Zt), ft;
              })(ee, $.transform), ke = Ce.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), ze = G.properties.get("atmosphere-blend") * ke.projectionTransition;
              if (ze === 0) return;
              const we = Ys(Ce.worldSize, Ce.center.lat), je = Ce.inverseProjectionMatrix, Qe = new Float64Array(4);
              Qe[3] = 1, o.aw(Qe, Qe, Ce.modelViewProjectionMatrix), Qe[0] /= Qe[3], Qe[1] /= Qe[3], Qe[2] /= Qe[3], Qe[3] = 1, o.aw(Qe, Qe, je), Qe[0] /= Qe[3], Qe[1] /= Qe[3], Qe[2] /= Qe[3], Qe[3] = 1;
              const qe = /* @__PURE__ */ ((Je, Tt, It, ft, Zt) => ({ u_sun_pos: Je, u_atmosphere_blend: Tt, u_globe_position: It, u_globe_radius: ft, u_inv_proj_matrix: Zt }))(xe, ze, [Qe[0], Qe[1], Qe[2]], we, je), Ze = tl(ue, G);
              pe.draw(ue, ce.TRIANGLES, ge, Dr.disabled, cn.alphaBlended, lr.disabled, qe, null, null, "atmosphere", Ze.vertexBuffer, Ze.indexBuffer, Ze.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const $ = (function(G, ee) {
                let ue = null;
                const ce = Object.values(G._layers).flatMap(((xe) => xe.source && !xe.isHidden(ee) ? [G.sourceCaches[xe.source]] : [])), pe = ce.filter(((xe) => xe.getSource().type === "vector")), ge = ce.filter(((xe) => xe.getSource().type !== "vector")), Ce = (xe) => {
                  (!ue || ue.getSource().maxzoom < xe.getSource().maxzoom) && (ue = xe);
                };
                return pe.forEach(((xe) => Ce(xe))), ue || ge.forEach(((xe) => Ce(xe))), ue;
              })(this.style, this.transform.zoom);
              $ && (function(G, ee, ue) {
                for (let ce = 0; ce < ue.length; ce++) Wi(G, ee, ue[ce]);
              })(this, $, $.getVisibleCoordinates());
            }
            this.options.showPadding && (function($) {
              const G = $.transform.padding;
              zu($, $.transform.height - (G.top || 0), 3, gh), zu($, G.bottom || 0, 3, vh), yn($, G.left || 0, 3, nc), yn($, $.transform.width - (G.right || 0), 3, Ru);
              const ee = $.transform.centerPoint;
              (function(ue, ce, pe, ge) {
                Mo(ue, ce - 1, pe - 10, 2, 20, ge), Mo(ue, ce - 10, pe - 1, 20, 2, ge);
              })($, ee.x, $.transform.height - ee.y, vf);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const s = this.terrainFacilitator.matrix, u = this.transform.modelViewProjectionMatrix;
            let m = this.terrainFacilitator.dirty;
            m || (m = e ? !o.c8(s, u) : !o.c9(s, u)), m || (m = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), m && (o.ca(s, u), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(y, x) {
              const T = y.context, M = T.gl, D = y.transform, F = cn.unblended, j = new vr(M.LEQUAL, vr.ReadWrite, [0, 1]), $ = x.sourceCache.getRenderableTiles(), G = y.useProgram("terrainDepth");
              T.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), T.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), T.clear({ color: o.bf.transparent, depth: 1 });
              for (const ee of $) {
                const ue = x.getTerrainMesh(ee.tileID), ce = x.getTerrainData(ee.tileID), pe = D.getProjectionData({ overscaledTileID: ee.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), ge = { u_ele_delta: x.getMeshFrameDelta(D.zoom) };
                G.draw(T, M.TRIANGLES, j, Dr.disabled, F, lr.backCCW, ge, ce, pe, "terrain", ue.vertexBuffer, ue.indexBuffer, ue.segments);
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain), (function(y, x) {
              const T = y.context, M = T.gl, D = y.transform, F = cn.unblended, j = new vr(M.LEQUAL, vr.ReadWrite, [0, 1]), $ = x.getCoordsTexture(), G = x.sourceCache.getRenderableTiles(), ee = y.useProgram("terrainCoords");
              T.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), T.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), T.clear({ color: o.bf.transparent, depth: 1 }), x.coordsIndex = [];
              for (const ue of G) {
                const ce = x.getTerrainMesh(ue.tileID), pe = x.getTerrainData(ue.tileID);
                T.activeTexture.set(M.TEXTURE0), M.bindTexture(M.TEXTURE_2D, $.texture);
                const ge = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(D.zoom) }, Ce = D.getProjectionData({ overscaledTileID: ue.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                ee.draw(T, M.TRIANGLES, j, Dr.disabled, F, lr.backCCW, ge, pe, Ce, "terrain", ce.vertexBuffer, ce.indexBuffer, ce.segments), x.coordsIndex.push(ue.tileID.key);
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, s, u, m, y) {
            u.isHidden(this.transform.zoom) || (u.type === "background" || u.type === "custom" || (m || []).length) && (this.id = u.id, o.cb(u) ? (function(x, T, M, D, F, j) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: $ } = j, G = Dr.disabled, ee = x.colorModeForRenderPass();
              (M._unevaluatedLayout.hasValue("text-variable-anchor") || M._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ue, ce, pe, ge, Ce, xe, ke, ze, we) {
                const je = ce.transform, Qe = ce.style.map.terrain, qe = Ce === "map", Ze = xe === "map";
                for (const Je of ue) {
                  const Tt = ge.getTile(Je), It = Tt.getBucket(pe);
                  if (!It || !It.text || !It.text.segments.get().length) continue;
                  const ft = o.an(It.textSizeData, je.zoom), Zt = o.aC(Tt, 1, ce.transform.zoom), xr = sn(qe, ce.transform, Zt), $r = pe.layout.get("icon-text-fit") !== "none" && It.hasIconData();
                  if (ft) {
                    const Kr = Math.pow(2, je.zoom - Tt.tileID.overscaledZ), Wr = Qe ? (fn, _n) => Qe.getElevation(Je, fn, _n) : null;
                    Pu(It, qe, Ze, we, je, xr, Kr, ft, $r, o.aD(je, Tt, ke, ze), Je.toUnwrapped(), Wr);
                  }
                }
              })(D, x, M, T, M.layout.get("text-rotation-alignment"), M.layout.get("text-pitch-alignment"), M.paint.get("text-translate"), M.paint.get("text-translate-anchor"), F), M.paint.get("icon-opacity").constantOr(1) !== 0 && Ya(x, T, M, D, false, M.paint.get("icon-translate"), M.paint.get("icon-translate-anchor"), M.layout.get("icon-rotation-alignment"), M.layout.get("icon-pitch-alignment"), M.layout.get("icon-keep-upright"), G, ee, $), M.paint.get("text-opacity").constantOr(1) !== 0 && Ya(x, T, M, D, true, M.paint.get("text-translate"), M.paint.get("text-translate-anchor"), M.layout.get("text-rotation-alignment"), M.layout.get("text-pitch-alignment"), M.layout.get("text-keep-upright"), G, ee, $), T.map.showCollisionBoxes && (ph(x, T, M, D, true), ph(x, T, M, D, false));
            })(e, s, u, m, this.style.placement.variableOffsets, y) : o.cc(u) ? (function(x, T, M, D, F) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = F, $ = M.paint.get("circle-opacity"), G = M.paint.get("circle-stroke-width"), ee = M.paint.get("circle-stroke-opacity"), ue = !M.layout.get("circle-sort-key").isConstant();
              if ($.constantOr(1) === 0 && (G.constantOr(1) === 0 || ee.constantOr(1) === 0)) return;
              const ce = x.context, pe = ce.gl, ge = x.transform, Ce = x.getDepthModeForSublayer(0, vr.ReadOnly), xe = Dr.disabled, ke = x.colorModeForRenderPass(), ze = [], we = ge.getCircleRadiusCorrection();
              for (let je = 0; je < D.length; je++) {
                const Qe = D[je], qe = T.getTile(Qe), Ze = qe.getBucket(M);
                if (!Ze) continue;
                const Je = M.paint.get("circle-translate"), Tt = M.paint.get("circle-translate-anchor"), It = o.aD(ge, qe, Je, Tt), ft = Ze.programConfigurations.get(M.id), Zt = x.useProgram("circle", ft), xr = Ze.layoutVertexBuffer, $r = Ze.indexBuffer, Kr = x.style.map.terrain && x.style.map.terrain.getTerrainData(Qe), Wr = { programConfiguration: ft, program: Zt, layoutVertexBuffer: xr, indexBuffer: $r, uniformValues: nf(x, qe, M, It, we), terrainData: Kr, projectionData: ge.getProjectionData({ overscaledTileID: Qe, applyGlobeMatrix: !j, applyTerrainMatrix: true }) };
                if (ue) {
                  const fn = Ze.segments.get();
                  for (const _n of fn) ze.push({ segments: new o.aM([_n]), sortKey: _n.sortKey, state: Wr });
                } else ze.push({ segments: Ze.segments, sortKey: 0, state: Wr });
              }
              ue && ze.sort(((je, Qe) => je.sortKey - Qe.sortKey));
              for (const je of ze) {
                const { programConfiguration: Qe, program: qe, layoutVertexBuffer: Ze, indexBuffer: Je, uniformValues: Tt, terrainData: It, projectionData: ft } = je.state;
                qe.draw(ce, pe.TRIANGLES, Ce, xe, ke, lr.backCCW, Tt, It, ft, M.id, Ze, Je, je.segments, M.paint, x.transform.zoom, Qe);
              }
            })(e, s, u, m, y) : o.cd(u) ? (function(x, T, M, D, F) {
              if (M.paint.get("heatmap-opacity") === 0) return;
              const j = x.context, { isRenderingToTexture: $, isRenderingGlobe: G } = F;
              if (x.style.map.terrain) {
                for (const ee of D) {
                  const ue = T.getTile(ee);
                  T.hasRenderableParent(ee) || (x.renderPass === "offscreen" ? Tu(x, ue, M, ee, G) : x.renderPass === "translucent" && mh(x, M, ee, $, G));
                }
                j.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(ee, ue, ce, pe) {
                const ge = ee.context, Ce = ge.gl, xe = ee.transform, ke = Dr.disabled, ze = new cn([Ce.ONE, Ce.ONE], o.bf.transparent, [true, true, true, true]);
                (function(we, je, Qe) {
                  const qe = we.gl;
                  we.activeTexture.set(qe.TEXTURE1), we.viewport.set([0, 0, je.width / 4, je.height / 4]);
                  let Ze = Qe.heatmapFbos.get(o.c2);
                  Ze ? (qe.bindTexture(qe.TEXTURE_2D, Ze.colorAttachment.get()), we.bindFramebuffer.set(Ze.framebuffer)) : (Ze = Ja(we, je.width / 4, je.height / 4), Qe.heatmapFbos.set(o.c2, Ze));
                })(ge, ee, ce), ge.clear({ color: o.bf.transparent });
                for (let we = 0; we < pe.length; we++) {
                  const je = pe[we];
                  if (ue.hasRenderableParent(je)) continue;
                  const Qe = ue.getTile(je), qe = Qe.getBucket(ce);
                  if (!qe) continue;
                  const Ze = qe.programConfigurations.get(ce.id), Je = ee.useProgram("heatmap", Ze), Tt = xe.getProjectionData({ overscaledTileID: je, applyGlobeMatrix: true, applyTerrainMatrix: false }), It = xe.getCircleRadiusCorrection();
                  Je.draw(ge, Ce.TRIANGLES, vr.disabled, ke, ze, lr.backCCW, Yd(Qe, xe.zoom, ce.paint.get("heatmap-intensity"), It), null, Tt, ce.id, qe.layoutVertexBuffer, qe.indexBuffer, qe.segments, ce.paint, xe.zoom, Ze);
                }
                ge.viewport.set([0, 0, ee.width, ee.height]);
              })(x, T, M, D) : x.renderPass === "translucent" && (function(ee, ue) {
                const ce = ee.context, pe = ce.gl;
                ce.setColorMode(ee.colorModeForRenderPass());
                const ge = ue.heatmapFbos.get(o.c2);
                ge && (ce.activeTexture.set(pe.TEXTURE0), pe.bindTexture(pe.TEXTURE_2D, ge.colorAttachment.get()), ce.activeTexture.set(pe.TEXTURE1), Qa(ce, ue).bind(pe.LINEAR, pe.CLAMP_TO_EDGE), ee.useProgram("heatmapTexture").draw(ce, pe.TRIANGLES, vr.disabled, Dr.disabled, ee.colorModeForRenderPass(), lr.disabled, pu(ee, ue, 0, 1), null, null, ue.id, ee.viewportBuffer, ee.quadTriangleIndexBuffer, ee.viewportSegments, ue.paint, ee.transform.zoom));
              })(x, M);
            })(e, s, u, m, y) : o.ce(u) ? (function(x, T, M, D, F) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = F, $ = M.paint.get("line-opacity"), G = M.paint.get("line-width");
              if ($.constantOr(1) === 0 || G.constantOr(1) === 0) return;
              const ee = x.getDepthModeForSublayer(0, vr.ReadOnly), ue = x.colorModeForRenderPass(), ce = M.paint.get("line-dasharray"), pe = M.paint.get("line-pattern"), ge = pe.constantOr(1), Ce = M.paint.get("line-gradient"), xe = M.getCrossfadeParameters(), ke = ge ? "linePattern" : ce ? "lineSDF" : Ce ? "lineGradient" : "line", ze = x.context, we = ze.gl, je = x.transform;
              let Qe = true;
              for (const qe of D) {
                const Ze = T.getTile(qe);
                if (ge && !Ze.patternsLoaded()) continue;
                const Je = Ze.getBucket(M);
                if (!Je) continue;
                const Tt = Je.programConfigurations.get(M.id), It = x.context.program.get(), ft = x.useProgram(ke, Tt), Zt = Qe || ft.program !== It, xr = x.style.map.terrain && x.style.map.terrain.getTerrainData(qe), $r = pe.constantOr(null);
                if ($r && Ze.imageAtlas) {
                  const br = Ze.imageAtlas, Jr = br.patternPositions[$r.to.toString()], In = br.patternPositions[$r.from.toString()];
                  Jr && In && Tt.setConstantPatternPositions(Jr, In);
                }
                const Kr = je.getProjectionData({ overscaledTileID: qe, applyGlobeMatrix: !j, applyTerrainMatrix: true }), Wr = je.getPixelScale(), fn = ge ? eh(x, Ze, M, Wr, xe) : ce ? ks(x, Ze, M, Wr, ce, xe) : Ce ? Qd(x, Ze, M, Wr, Je.lineClipsArray.length) : Wl(x, Ze, M, Wr);
                if (ge) ze.activeTexture.set(we.TEXTURE0), Ze.imageAtlasTexture.bind(we.LINEAR, we.CLAMP_TO_EDGE), Tt.updatePaintBuffers(xe);
                else if (ce && (Zt || x.lineAtlas.dirty)) ze.activeTexture.set(we.TEXTURE0), x.lineAtlas.bind(ze);
                else if (Ce) {
                  const br = Je.gradients[M.id];
                  let Jr = br.texture;
                  if (M.gradientVersion !== br.version) {
                    let In = 256;
                    if (M.stepInterpolant) {
                      const Fn = T.getSource().maxzoom, Un = qe.canonical.z === Fn ? Math.ceil(1 << x.transform.maxZoom - qe.canonical.z) : 1;
                      In = o.ah(o.c3(Je.maxLineLength / o.$ * 1024 * Un), 256, ze.maxTextureSize);
                    }
                    br.gradient = o.c4({ expression: M.gradientExpression(), evaluationKey: "lineProgress", resolution: In, image: br.gradient || void 0, clips: Je.lineClipsArray }), br.texture ? br.texture.update(br.gradient) : br.texture = new o.T(ze, br.gradient, we.RGBA), br.version = M.gradientVersion, Jr = br.texture;
                  }
                  ze.activeTexture.set(we.TEXTURE0), Jr.bind(M.stepInterpolant ? we.NEAREST : we.LINEAR, we.CLAMP_TO_EDGE);
                }
                const _n = x.stencilModeForClipping(qe);
                ft.draw(ze, we.TRIANGLES, ee, _n, ue, lr.disabled, fn, xr, Kr, M.id, Je.layoutVertexBuffer, Je.indexBuffer, Je.segments, M.paint, x.transform.zoom, Tt, Je.layoutVertexBuffer2), Qe = false;
              }
            })(e, s, u, m, y) : o.cf(u) ? (function(x, T, M, D, F) {
              const j = M.paint.get("fill-color"), $ = M.paint.get("fill-opacity");
              if ($.constantOr(1) === 0) return;
              const { isRenderingToTexture: G } = F, ee = x.colorModeForRenderPass(), ue = M.paint.get("fill-pattern"), ce = x.opaquePassEnabledForLayer() && !ue.constantOr(1) && j.constantOr(o.bf.transparent).a === 1 && $.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === ce) {
                const pe = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? vr.ReadWrite : vr.ReadOnly);
                tc(x, T, M, D, pe, ee, false, G);
              }
              if (x.renderPass === "translucent" && M.paint.get("fill-antialias")) {
                const pe = x.getDepthModeForSublayer(M.getPaintProperty("fill-outline-color") ? 2 : 0, vr.ReadOnly);
                tc(x, T, M, D, pe, ee, true, G);
              }
            })(e, s, u, m, y) : o.cg(u) ? (function(x, T, M, D, F) {
              const j = M.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: $ } = F;
              if (x.renderPass === "translucent") {
                const G = new vr(x.context.gl.LEQUAL, vr.ReadWrite, x.depthRangeFor3D);
                if (j !== 1 || M.paint.get("fill-extrusion-pattern").constantOr(1)) Mu(x, T, M, D, G, Dr.disabled, cn.disabled, $), Mu(x, T, M, D, G, x.stencilModeFor3D(), x.colorModeForRenderPass(), $);
                else {
                  const ee = x.colorModeForRenderPass();
                  Mu(x, T, M, D, G, Dr.disabled, ee, $);
                }
              }
            })(e, s, u, m, y) : o.ch(u) ? (function(x, T, M, D, F) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = F, $ = x.context, G = x.style.projection.useSubdivision, ee = x.getDepthModeForSublayer(0, vr.ReadOnly), ue = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(ce, pe, ge, Ce, xe, ke, ze) {
                const we = ce.context, je = we.gl;
                for (const Qe of ge) {
                  const qe = pe.getTile(Qe), Ze = qe.dem;
                  if (!Ze || !Ze.data || !qe.needsHillshadePrepare) continue;
                  const Je = Ze.dim, Tt = Ze.stride, It = Ze.getPixels();
                  if (we.activeTexture.set(je.TEXTURE1), we.pixelStoreUnpackPremultiplyAlpha.set(false), qe.demTexture = qe.demTexture || ce.getTileTexture(Tt), qe.demTexture) {
                    const Zt = qe.demTexture;
                    Zt.update(It, { premultiply: false }), Zt.bind(je.NEAREST, je.CLAMP_TO_EDGE);
                  } else qe.demTexture = new o.T(we, It, je.RGBA, { premultiply: false }), qe.demTexture.bind(je.NEAREST, je.CLAMP_TO_EDGE);
                  we.activeTexture.set(je.TEXTURE0);
                  let ft = qe.fbo;
                  if (!ft) {
                    const Zt = new o.T(we, { width: Je, height: Je, data: null }, je.RGBA);
                    Zt.bind(je.LINEAR, je.CLAMP_TO_EDGE), ft = qe.fbo = we.createFramebuffer(Je, Je, true, false), ft.colorAttachment.set(Zt.texture);
                  }
                  we.bindFramebuffer.set(ft.framebuffer), we.viewport.set([0, 0, Je, Je]), ce.useProgram("hillshadePrepare").draw(we, je.TRIANGLES, xe, ke, ze, lr.disabled, Kd(qe.tileID, Ze), null, null, Ce.id, ce.rasterBoundsBuffer, ce.quadTriangleIndexBuffer, ce.rasterBoundsSegments), qe.needsHillshadePrepare = false;
                }
              })(x, T, D, M, ee, Dr.disabled, ue), $.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (G) {
                const [ce, pe, ge] = x.stencilConfigForOverlapTwoPass(D);
                Is(x, T, M, ge, ce, ee, ue, false, j), Is(x, T, M, ge, pe, ee, ue, true, j);
              } else {
                const [ce, pe] = x.getStencilConfigForOverlapAndUpdateStencilID(D);
                Is(x, T, M, pe, ce, ee, ue, false, j);
              }
            })(e, s, u, m, y) : o.ci(u) ? (function(x, T, M, D, F) {
              if (x.renderPass !== "translucent" || !D.length) return;
              const { isRenderingToTexture: j } = F, $ = x.style.projection.useSubdivision, G = x.getDepthModeForSublayer(0, vr.ReadOnly), ee = x.colorModeForRenderPass();
              if ($) {
                const [ue, ce, pe] = x.stencilConfigForOverlapTwoPass(D);
                Iu(x, T, M, pe, ue, G, ee, false, j), Iu(x, T, M, pe, ce, G, ee, true, j);
              } else {
                const [ue, ce] = x.getStencilConfigForOverlapAndUpdateStencilID(D);
                Iu(x, T, M, ce, ue, G, ee, false, j);
              }
            })(e, s, u, m, y) : o.cj(u) ? (function(x, T, M, D, F) {
              if (x.renderPass !== "translucent" || M.paint.get("raster-opacity") === 0 || !D.length) return;
              const { isRenderingToTexture: j } = F, $ = T.getSource(), G = x.style.projection.useSubdivision;
              if ($ instanceof kt) Es(x, T, M, D, null, false, false, $.tileCoords, $.flippedWindingOrder, j);
              else if (G) {
                const [ee, ue, ce] = x.stencilConfigForOverlapTwoPass(D);
                Es(x, T, M, ce, ee, false, true, rc, false, j), Es(x, T, M, ce, ue, true, true, rc, false, j);
              } else {
                const [ee, ue] = x.getStencilConfigForOverlapAndUpdateStencilID(D);
                Es(x, T, M, ue, ee, false, true, rc, false, j);
              }
            })(e, s, u, m, y) : o.ck(u) ? (function(x, T, M, D, F) {
              const j = M.paint.get("background-color"), $ = M.paint.get("background-opacity");
              if ($ === 0) return;
              const { isRenderingToTexture: G } = F, ee = x.context, ue = ee.gl, ce = x.style.projection, pe = x.transform, ge = pe.tileSize, Ce = M.paint.get("background-pattern");
              if (x.isPatternMissing(Ce)) return;
              const xe = !Ce && j.a === 1 && $ === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== xe) return;
              const ke = Dr.disabled, ze = x.getDepthModeForSublayer(0, xe === "opaque" ? vr.ReadWrite : vr.ReadOnly), we = x.colorModeForRenderPass(), je = x.useProgram(Ce ? "backgroundPattern" : "background"), Qe = D || Te(pe, { tileSize: ge, terrain: x.style.map.terrain });
              Ce && (ee.activeTexture.set(ue.TEXTURE0), x.imageManager.bind(x.context));
              const qe = M.getCrossfadeParameters();
              for (const Ze of Qe) {
                const Je = pe.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !G, applyTerrainMatrix: true }), Tt = Ce ? nh($, x, Ce, { tileID: Ze, tileSize: ge }, qe) : rh($, j), It = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ze), ft = ce.getMeshFromTileID(ee, Ze.canonical, false, true, "raster");
                je.draw(ee, ue.TRIANGLES, ze, ke, we, lr.backCCW, Tt, It, Je, M.id, ft.vertexBuffer, ft.indexBuffer, ft.segments);
              }
            })(e, 0, u, m, y) : o.cl(u) && (function(x, T, M, D) {
              const { isRenderingGlobe: F } = D, j = x.context, $ = M.implementation, G = x.style.projection, ee = x.transform, ue = ee.getProjectionDataForCustomLayer(F), ce = { farZ: ee.farZ, nearZ: ee.nearZ, fov: ee.fov * Math.PI / 180, modelViewProjectionMatrix: ee.modelViewProjectionMatrix, projectionMatrix: ee.projectionMatrix, shaderData: { variantName: G.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${G.shaderPreludeCode.vertexSource}`, define: G.shaderDefine }, defaultProjectionData: ue }, pe = $.renderingMode ? $.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const ge = $.prerender;
                ge && (x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), ge.call($, j.gl, ce), j.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), j.setStencilMode(Dr.disabled);
                const ge = pe === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, vr.ReadOnly);
                j.setDepthMode(ge), $.render(j.gl, ce), j.setDirty(), x.setBaseState(), j.bindFramebuffer.set(null);
              }
            })(e, 0, u, y));
          }
          saveTileTexture(e) {
            const s = this._tileTextures[e.size[0]];
            s ? s.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const s = this._tileTextures[e];
            return s && s.length > 0 ? s.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return false;
            if (!e.from || !e.to) return true;
            const s = this.imageManager.getPattern(e.from.toString()), u = this.imageManager.getPattern(e.to.toString());
            return !s || !u;
          }
          useProgram(e, s, u = false, m = []) {
            this.cache = this.cache || {};
            const y = !!this.style.map.terrain, x = this.style.projection, T = u ? Di.projectionMercator : x.shaderPreludeCode, M = u ? Qi : x.shaderDefine, D = e + (s ? s.cacheKey : "") + `/${u ? Do : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (y ? "/terrain" : "") + (m ? `/${m.join("/")}` : "");
            return this.cache[D] || (this.cache[D] = new hu(this.context, Di[e], s, yu[e], this._showOverdrawInspector, y, T, M, m)), this.cache[D];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: s } = this.context.gl;
            return this.width !== e || this.height !== s;
          }
        }
        function Rs(v, e) {
          let s, u = false, m = null, y = null;
          const x = () => {
            m = null, u && (v.apply(y, s), m = setTimeout(x, e), u = false);
          };
          return (...T) => (u = true, y = this, s = T, m || x(), m);
        }
        class oc {
          constructor(e) {
            this._getCurrentHash = () => {
              const s = window.location.hash.replace("#", "");
              if (this._hashName) {
                let u;
                return s.split("&").map(((m) => m.split("="))).forEach(((m) => {
                  m[0] === this._hashName && (u = m);
                })), (u && u[1] || "").split("/");
              }
              return s.split("/");
            }, this._onHashChange = () => {
              const s = this._getCurrentHash();
              if (!this._isValidHash(s)) return false;
              const u = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(s[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: u, pitch: +(s[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const s = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, s);
            }, this._removeHash = () => {
              const s = this._getCurrentHash();
              if (s.length === 0) return;
              const u = s.join("/");
              let m = u;
              m.split("&").length > 0 && (m = m.split("&")[0]), this._hashName && (m = `${this._hashName}=${u}`);
              let y = window.location.hash.replace(m, "");
              y.startsWith("#&") ? y = y.slice(0, 1) + y.slice(2) : y === "#" && (y = "");
              let x = window.location.href.replace(/(#.+)?$/, y);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = Rs(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const s = this._map.getCenter(), u = Math.round(100 * this._map.getZoom()) / 100, m = Math.ceil((u * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), y = Math.pow(10, m), x = Math.round(s.lng * y) / y, T = Math.round(s.lat * y) / y, M = this._map.getBearing(), D = this._map.getPitch();
            let F = "";
            if (F += e ? `/${x}/${T}/${u}` : `${u}/${T}/${x}`, (M || D) && (F += "/" + Math.round(10 * M) / 10), D && (F += `/${Math.round(D)}`), this._hashName) {
              const j = this._hashName;
              let $ = false;
              const G = window.location.hash.slice(1).split("&").map(((ee) => {
                const ue = ee.split("=")[0];
                return ue === j ? ($ = true, `${ue}=${F}`) : ee;
              })).filter(((ee) => ee));
              return $ || G.push(`${j}=${F}`), `#${G.join("&")}`;
            }
            return `#${F}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return false;
            try {
              new o.S(+e[2], +e[1]);
            } catch {
              return false;
            }
            const s = +e[0], u = +(e[3] || 0), m = +(e[4] || 0);
            return s >= this._map.getMinZoom() && s <= this._map.getMaxZoom() && u >= -180 && u <= 180 && m >= this._map.getMinPitch() && m <= this._map.getMaxPitch();
          }
        }
        const Bo = { linearity: 0.3, easing: o.cm(0, 0, 0.3, 1) }, Au = o.e({ deceleration: 2500, maxSpeed: 1400 }, Bo), _h = o.e({ deceleration: 20, maxSpeed: 1400 }, Bo), bh = o.e({ deceleration: 1e3, maxSpeed: 360 }, Bo), xh = o.e({ deceleration: 1e3, maxSpeed: 90 }, Bo), wh = o.e({ deceleration: 1e3, maxSpeed: 360 }, Bo);
        class Ch {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: z.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, s = z.now();
            for (; e.length > 0 && s - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const s = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: y } of this._inertiaBuffer) s.zoom += y.zoomDelta || 0, s.bearing += y.bearingDelta || 0, s.pitch += y.pitchDelta || 0, s.roll += y.rollDelta || 0, y.panDelta && s.pan._add(y.panDelta), y.around && (s.around = y.around), y.pinchAround && (s.pinchAround = y.pinchAround);
            const u = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, m = {};
            if (s.pan.mag()) {
              const y = ea(s.pan.mag(), u, o.e({}, Au, e || {})), x = s.pan.mult(y.amount / s.pan.mag()), T = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              m.center = T.easingCenter, m.offset = T.easingOffset, ro(m, y);
            }
            if (s.zoom) {
              const y = ea(s.zoom, u, _h);
              m.zoom = this._map.transform.zoom + y.amount, ro(m, y);
            }
            if (s.bearing) {
              const y = ea(s.bearing, u, bh);
              m.bearing = this._map.transform.bearing + o.ah(y.amount, -179, 179), ro(m, y);
            }
            if (s.pitch) {
              const y = ea(s.pitch, u, xh);
              m.pitch = this._map.transform.pitch + y.amount, ro(m, y);
            }
            if (s.roll) {
              const y = ea(s.roll, u, wh);
              m.roll = this._map.transform.roll + o.ah(y.amount, -179, 179), ro(m, y);
            }
            if (m.zoom || m.bearing) {
              const y = s.pinchAround === void 0 ? s.around : s.pinchAround;
              m.around = y ? this._map.unproject(y) : this._map.getCenter();
            }
            return this.clear(), o.e(m, { noMoveStart: true });
          }
        }
        function ro(v, e) {
          (!v.duration || v.duration < e.duration) && (v.duration = e.duration, v.easing = e.easing);
        }
        function ea(v, e, s) {
          const { maxSpeed: u, linearity: m, deceleration: y } = s, x = o.ah(v * m / (e / 1e3), -u, u), T = Math.abs(x) / (y * m);
          return { easing: s.easing, duration: 1e3 * T, amount: x * (T / 2) };
        }
        class ki extends o.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, s, u, m = {}) {
            u = u instanceof MouseEvent ? u : new MouseEvent(e, u);
            const y = R.mousePos(s.getCanvas(), u), x = s.unproject(y);
            super(e, o.e({ point: y, lngLat: x, originalEvent: u }, m)), this._defaultPrevented = false, this.target = s;
          }
        }
        class ta extends o.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, s, u) {
            const m = e === "touchend" ? u.changedTouches : u.touches, y = R.touchPos(s.getCanvasContainer(), m), x = y.map(((M) => s.unproject(M))), T = y.reduce(((M, D, F, j) => M.add(D.div(j.length))), new o.P(0, 0));
            super(e, { points: y, point: T, lngLats: x, lngLat: s.unproject(T), originalEvent: u }), this._defaultPrevented = false;
          }
        }
        class Du extends o.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, s, u) {
            super(e, { originalEvent: u }), this._defaultPrevented = false;
          }
        }
        class Sh {
          constructor(e, s) {
            this._map = e, this._clickTolerance = s.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Du(e.type, this._map, e));
          }
          mousedown(e, s) {
            return this._mousedownPos = s, this._firePreventable(new ki(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new ki(e.type, this._map, e));
          }
          click(e, s) {
            this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || this._map.fire(new ki(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new ki(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new ki(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new ki(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new ta(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new ta(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new ta(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new ta(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class kh {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new ki(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ki("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ki(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ra {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain);
          }
        }
        class Fu {
          constructor(e, s) {
            this._map = e, this._tr = new ra(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = s.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e, s) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (R.disableDrag(), this._startPos = this._lastPos = s, this._active = true);
          }
          mousemoveWindow(e, s) {
            if (!this._active) return;
            const u = s;
            if (this._lastPos.equals(u) || !this._box && u.dist(this._startPos) < this._clickTolerance) return;
            const m = this._startPos;
            this._lastPos = u, this._box || (this._box = R.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const y = Math.min(m.x, u.x), x = Math.max(m.x, u.x), T = Math.min(m.y, u.y), M = Math.max(m.y, u.y);
            R.setTransform(this._box, `translate(${y}px,${T}px)`), this._box.style.width = x - y + "px", this._box.style.height = M - T + "px";
          }
          mouseupWindow(e, s) {
            if (!this._active || e.button !== 0) return;
            const u = this._startPos, m = s;
            if (this.reset(), R.suppressClick(), u.x !== m.x || u.y !== m.y) return this._map.fire(new o.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (y) => y.fitScreenCoordinates(u, m, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (R.remove(this._box), this._box = null), R.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, s) {
            return this._map.fire(new o.l(e, { originalEvent: s }));
          }
        }
        function na(v, e) {
          if (v.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${e.length}`);
          const s = {};
          for (let u = 0; u < v.length; u++) s[v[u].identifier] = e[u];
          return s;
        }
        class Ph {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e, s, u) {
            (this.centroid || u.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), u.length === this.numTouches && (this.centroid = (function(m) {
              const y = new o.P(0, 0);
              for (const x of m) y._add(x);
              return y.div(m.length);
            })(s), this.touches = na(u, s)));
          }
          touchmove(e, s, u) {
            if (this.aborted || !this.centroid) return;
            const m = na(u, s);
            for (const y in this.touches) {
              const x = m[y];
              (!x || x.dist(this.touches[y]) > 30) && (this.aborted = true);
            }
          }
          touchend(e, s, u) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = true), u.length === 0) {
              const m = !this.aborted && this.centroid;
              if (this.reset(), m) return m;
            }
          }
        }
        class Pi {
          constructor(e) {
            this.singleTap = new Ph(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, s, u) {
            this.singleTap.touchstart(e, s, u);
          }
          touchmove(e, s, u) {
            this.singleTap.touchmove(e, s, u);
          }
          touchend(e, s, u) {
            const m = this.singleTap.touchend(e, s, u);
            if (m) {
              const y = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(m) < 30;
              if (y && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = m, this.count === this.numTaps) return this.reset(), m;
            }
          }
        }
        class no {
          constructor(e) {
            this._tr = new ra(e), this._zoomIn = new Pi({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Pi({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, s, u) {
            this._zoomIn.touchstart(e, s, u), this._zoomOut.touchstart(e, s, u);
          }
          touchmove(e, s, u) {
            this._zoomIn.touchmove(e, s, u), this._zoomOut.touchmove(e, s, u);
          }
          touchend(e, s, u) {
            const m = this._zoomIn.touchend(e, s, u), y = this._zoomOut.touchend(e, s, u), x = this._tr;
            return m ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(m) }, { originalEvent: e }) }) : y ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(y) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ia {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const s = this._moveFunction(...e);
            if (s.bearingDelta || s.pitchDelta || s.rollDelta || s.around || s.panDelta) return this._active = true, s;
          }
          dragStart(e, s) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(s) ? s[0] : s, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e, s) {
            if (!this.isEnabled()) return;
            const u = this._lastPoint;
            if (!u) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const m = Array.isArray(s) ? s[0] : s;
            return !this._moved && m.dist(u) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = m, this._move(u, m));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && R.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const io = 0, oa = 2, yf = { [io]: 1, [oa]: 2 };
        class rl {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const s = R.mouseButton(e);
            this._eventButton = s;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(s, u) {
              const m = yf[u];
              return s.buttons === void 0 || (s.buttons & m) !== m;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return R.mouseButton(e) === this._eventButton;
          }
        }
        class _f {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class bf {
          constructor(e = new rl({ checkCorrectEvent: () => true }), s = new _f()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = s;
          }
          _executeRelevantHandler(e, s, u) {
            return e instanceof MouseEvent ? s(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? u(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((s) => this.mouseMoveStateManager.startMove(s)), ((s) => this.oneFingerTouchMoveStateManager.startMove(s)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((s) => this.mouseMoveStateManager.endMove(s)), ((s) => this.oneFingerTouchMoveStateManager.endMove(s)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((s) => this.mouseMoveStateManager.isValidStartEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidStartEvent(s)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((s) => this.mouseMoveStateManager.isValidMoveEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(s)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((s) => this.mouseMoveStateManager.isValidEndEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidEndEvent(s)));
          }
        }
        const nl = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class il {
          constructor(e, s) {
            this._clickTolerance = e.clickTolerance || 1, this._map = s, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new o.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, s, u) {
            return this._calculateTransform(e, s, u);
          }
          touchmove(e, s, u) {
            if (this._active) {
              if (!this._shouldBePrevented(u.length)) return e.preventDefault(), this._calculateTransform(e, s, u);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, s, u) {
            this._calculateTransform(e, s, u), this._active && this._shouldBePrevented(u.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, s, u) {
            u.length > 0 && (this._active = true);
            const m = na(u, s), y = new o.P(0, 0), x = new o.P(0, 0);
            let T = 0;
            for (const D in m) {
              const F = m[D], j = this._touches[D];
              j && (y._add(F), x._add(F.sub(j)), T++, m[D] = F);
            }
            if (this._touches = m, this._shouldBePrevented(T) || !x.mag()) return;
            const M = x.div(T);
            return this._sum._add(M), this._sum.mag() < this._clickTolerance ? void 0 : { around: y.div(T), panDelta: M };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class oo {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e, s, u) {
            this._firstTwoTouches || u.length < 2 || (this._firstTwoTouches = [u[0].identifier, u[1].identifier], this._start([s[0], s[1]]));
          }
          touchmove(e, s, u) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [m, y] = this._firstTwoTouches, x = Bt(u, s, m), T = Bt(u, s, y);
            if (!x || !T) return;
            const M = this._aroundCenter ? null : x.add(T).div(2);
            return this._move([x, T], M, e);
          }
          touchend(e, s, u) {
            if (!this._firstTwoTouches) return;
            const [m, y] = this._firstTwoTouches, x = Bt(u, s, m), T = Bt(u, s, y);
            x && T || (this._active && R.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = true, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Bt(v, e, s) {
          for (let u = 0; u < v.length; u++) if (v[u].identifier === s) return e[u];
        }
        function Lu(v, e) {
          return Math.log(v / e) / Math.LN2;
        }
        class sc extends oo {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, s) {
            const u = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Lu(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Lu(this._distance, u), pinchAround: s };
          }
        }
        function Bu(v, e) {
          return 180 * v.angleWith(e) / Math.PI;
        }
        class sa extends oo {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, s, u) {
            const m = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Bu(this._vector, m), pinchAround: s };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const s = 25 / (Math.PI * this._minDiameter) * 360, u = Bu(e, this._startVector);
            return Math.abs(u) < s;
          }
        }
        function zs(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class ac extends oo {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, s, u) {
            super.touchstart(e, s, u), this._currentTouchCount = u.length;
          }
          _start(e) {
            this._lastPoints = e, zs(e[0].sub(e[1])) && (this._valid = false);
          }
          _move(e, s, u) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const m = e[0].sub(this._lastPoints[0]), y = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(m, y, u.timeStamp), this._valid ? (this._lastPoints = e, this._active = true, { pitchDelta: (m.y + y.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, s, u) {
            if (this._valid !== void 0) return this._valid;
            const m = e.mag() >= 2, y = s.mag() >= 2;
            if (!m && !y) return;
            if (!m || !y) return this._firstMove === void 0 && (this._firstMove = u), u - this._firstMove < 100 && void 0;
            const x = e.y > 0 == s.y > 0;
            return zs(e) && zs(s) && x;
          }
        }
        const Er = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class lc {
          constructor(e) {
            this._tr = new ra(e);
            const s = Er;
            this._panStep = s.panStep, this._bearingStep = s.bearingStep, this._pitchStep = s.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let s = 0, u = 0, m = 0, y = 0, x = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                s = 1;
                break;
              case 189:
              case 109:
              case 173:
                s = -1;
                break;
              case 37:
                e.shiftKey ? u = -1 : (e.preventDefault(), y = -1);
                break;
              case 39:
                e.shiftKey ? u = 1 : (e.preventDefault(), y = 1);
                break;
              case 38:
                e.shiftKey ? m = 1 : (e.preventDefault(), x = -1);
                break;
              case 40:
                e.shiftKey ? m = -1 : (e.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (u = 0, m = 0), { cameraAnimation: (T) => {
              const M = this._tr;
              T.easeTo({ duration: 300, easeId: "keyboardHandler", easing: xf, zoom: s ? Math.round(M.zoom) + s * (e.shiftKey ? 2 : 1) : M.zoom, bearing: M.bearing + u * this._bearingStep, pitch: M.pitch + m * this._pitchStep, offset: [-y * this._panStep, -x * this._panStep], center: M.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function xf(v) {
          return v * (2 - v);
        }
        const cc = 4.000244140625, wf = 1 / 450;
        class Th {
          constructor(e, s) {
            this._onTimeout = (u) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(u);
            }, this._map = e, this._tr = new ra(e), this._triggerRenderFrame = s, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = wf;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let s = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const u = z.now(), m = u - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = u, s !== 0 && s % cc == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = s, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(m * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), e.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = e, this._delta -= s, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const s = R.mousePos(this._map.getCanvas(), e), u = this._tr;
            this._aroundPoint = this._aroundCenter ? u.transform.locationToScreenPoint(o.S.convert(u.center)) : s, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const T = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += T), typeof this._targetZoom == "number" && (this._targetZoom += T);
            }
            if (this._delta !== 0) {
              const T = this._type === "wheel" && Math.abs(this._delta) > cc ? this._wheelZoomRate : this._defaultZoomRate;
              let M = 2 / (1 + Math.exp(-Math.abs(this._delta * T)));
              this._delta < 0 && M !== 0 && (M = 1 / M);
              const D = typeof this._targetZoom != "number" ? e.scale : o.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.ak(D * M)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const s = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, u = this._startZoom, m = this._easing;
            let y, x = false;
            if (this._type === "wheel" && u && m) {
              const T = z.now() - this._lastWheelEventTime, M = Math.min((T + 5) / 200, 1), D = m(M);
              y = o.C.number(u, s, D), M < 1 ? this._frameId || (this._frameId = true) : x = true;
            } else y = s, x = true;
            return this._active = true, x && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = y, { noInertia: true, needsRenderFrame: !x, zoomDelta: y - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let s = o.co;
            if (this._prevEase) {
              const u = this._prevEase, m = (z.now() - u.start) / u.duration, y = u.easing(m + 0.01) - u.easing(m), x = 0.27 / Math.sqrt(y * y + 1e-4) * 0.01, T = Math.sqrt(0.0729 - x * x);
              s = o.cm(x, T, 0.25, 1);
            }
            return this._prevEase = { start: z.now(), duration: e, easing: s }, s;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Ou {
          constructor(e, s) {
            this._clickZoom = e, this._tapZoom = s;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class $u {
          constructor(e) {
            this._tr = new ra(e), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e, s) {
            return e.preventDefault(), { cameraAnimation: (u) => {
              u.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(s) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Mh {
          constructor() {
            this._tap = new Pi({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, s, u) {
            if (!this._swipePoint) if (this._tapTime) {
              const m = s[0], y = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(m) < 30;
              y && x ? u.length > 0 && (this._swipePoint = m, this._swipeTouch = u[0].identifier) : this.reset();
            } else this._tap.touchstart(e, s, u);
          }
          touchmove(e, s, u) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (u[0].identifier !== this._swipeTouch) return;
                const m = s[0], y = m.y - this._swipePoint.y;
                return this._swipePoint = m, e.preventDefault(), this._active = true, { zoomDelta: y / 128 };
              }
            } else this._tap.touchmove(e, s, u);
          }
          touchend(e, s, u) {
            if (this._tapTime) this._swipePoint && u.length === 0 && this.reset();
            else {
              const m = this._tap.touchend(e, s, u);
              m && (this._tapTime = e.timeStamp, this._tapPoint = m);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ih {
          constructor(e, s, u) {
            this._el = e, this._mousePan = s, this._touchPan = u;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class ju {
          constructor(e, s, u, m) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = s, this._mousePitch = u, this._mouseRoll = m;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Eh {
          constructor(e, s, u, m) {
            this._el = e, this._touchZoom = s, this._touchRotate = u, this._tapDragZoom = m, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Rh {
          constructor(e, s) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = s, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = R.create("div", "maplibregl-cooperative-gesture-screen", e);
            let s = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (s = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const u = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), m = document.createElement("div");
            m.className = "maplibregl-desktop-message", m.textContent = s, this._container.appendChild(m);
            const y = document.createElement("div");
            y.className = "maplibregl-mobile-message", y.textContent = u, this._container.appendChild(y), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (R.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, s) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", { gestureType: e, originalEvent: s })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const so = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class rn extends o.l {
        }
        function aa(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class Nu {
          constructor(e, s) {
            this.handleWindowEvent = (m) => {
              this.handleEvent(m, `${m.type}Window`);
            }, this.handleEvent = (m, y) => {
              if (m.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const x = m.type === "renderFrame" ? void 0 : m, T = { needsRenderFrame: false }, M = {}, D = {};
              for (const { handlerName: $, handler: G, allowed: ee } of this._handlers) {
                if (!G.isEnabled()) continue;
                let ue;
                if (this._blockedByActive(D, ee, $)) G.reset();
                else if (G[y || m.type]) {
                  if (o.cp(m, y || m.type)) {
                    const ce = R.mousePos(this._map.getCanvas(), m);
                    ue = G[y || m.type](m, ce);
                  } else if (o.cq(m, y || m.type)) {
                    const ce = this._getMapTouches(m.touches), pe = R.touchPos(this._map.getCanvas(), ce);
                    ue = G[y || m.type](m, pe, ce);
                  } else o.cr(y || m.type) || (ue = G[y || m.type](m));
                  this.mergeHandlerResult(T, M, ue, $, x), ue && ue.needsRenderFrame && this._triggerRenderFrame();
                }
                (ue || G.isActive()) && (D[$] = G);
              }
              const F = {};
              for (const $ in this._previousActiveHandlers) D[$] || (F[$] = x);
              this._previousActiveHandlers = D, (Object.keys(F).length || aa(T)) && (this._changes.push([T, M, F]), this._triggerRenderFrame()), (Object.keys(D).length || aa(T)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: j } = T;
              j && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], j(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ch(e), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(s);
            const u = this._el;
            this._listeners = [[u, "touchstart", { passive: true }], [u, "touchmove", { passive: false }], [u, "touchend", void 0], [u, "touchcancel", void 0], [u, "mousedown", void 0], [u, "mousemove", void 0], [u, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [u, "mouseover", void 0], [u, "mouseout", void 0], [u, "dblclick", void 0], [u, "click", void 0], [u, "keydown", { capture: false }], [u, "keyup", void 0], [u, "wheel", { passive: false }], [u, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [m, y, x] of this._listeners) R.addEventListener(m, y, m === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [e, s, u] of this._listeners) R.removeEventListener(e, s, e === document ? this.handleWindowEvent : this.handleEvent, u);
          }
          _addDefaultHandlers(e) {
            const s = this._map, u = s.getCanvasContainer();
            this._add("mapEvent", new Sh(s, e));
            const m = s.boxZoom = new Fu(s, e);
            this._add("boxZoom", m), e.interactive && e.boxZoom && m.enable();
            const y = s.cooperativeGestures = new Rh(s, e.cooperativeGestures);
            this._add("cooperativeGestures", y), e.cooperativeGestures && y.enable();
            const x = new no(s), T = new $u(s);
            s.doubleClickZoom = new Ou(T, x), this._add("tapZoom", x), this._add("clickZoom", T), e.interactive && e.doubleClickZoom && s.doubleClickZoom.enable();
            const M = new Mh();
            this._add("tapDragZoom", M);
            const D = s.touchPitch = new ac(s);
            this._add("touchPitch", D), e.interactive && e.touchPitch && s.touchPitch.enable(e.touchPitch);
            const F = () => s.project(s.getCenter()), j = (function({ enable: xe, clickTolerance: ke, aroundCenter: ze = true, minPixelCenterThreshold: we = 100, rotateDegreesPerPixelMoved: je = 0.8 }, Qe) {
              const qe = new rl({ checkCorrectEvent: (Ze) => R.mouseButton(Ze) === 0 && Ze.ctrlKey || R.mouseButton(Ze) === 2 && !Ze.ctrlKey });
              return new ia({ clickTolerance: ke, move: (Ze, Je) => {
                const Tt = Qe();
                if (ze && Math.abs(Tt.y - Ze.y) > we) return { bearingDelta: o.cn(new o.P(Ze.x, Je.y), Je, Tt) };
                let It = (Je.x - Ze.x) * je;
                return ze && Je.y < Tt.y && (It = -It), { bearingDelta: It };
              }, moveStateManager: qe, enable: xe, assignEvents: nl });
            })(e, F), $ = (function({ enable: xe, clickTolerance: ke, pitchDegreesPerPixelMoved: ze = -0.5 }) {
              const we = new rl({ checkCorrectEvent: (je) => R.mouseButton(je) === 0 && je.ctrlKey || R.mouseButton(je) === 2 });
              return new ia({ clickTolerance: ke, move: (je, Qe) => ({ pitchDelta: (Qe.y - je.y) * ze }), moveStateManager: we, enable: xe, assignEvents: nl });
            })(e), G = (function({ enable: xe, clickTolerance: ke, rollDegreesPerPixelMoved: ze = 0.3 }, we) {
              const je = new rl({ checkCorrectEvent: (Qe) => R.mouseButton(Qe) === 2 && Qe.ctrlKey });
              return new ia({ clickTolerance: ke, move: (Qe, qe) => {
                const Ze = we();
                let Je = (qe.x - Qe.x) * ze;
                return qe.y < Ze.y && (Je = -Je), { rollDelta: Je };
              }, moveStateManager: je, enable: xe, assignEvents: nl });
            })(e, F);
            s.dragRotate = new ju(e, j, $, G), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", $, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", G, ["mousePitch"]), e.interactive && e.dragRotate && s.dragRotate.enable();
            const ee = (function({ enable: xe, clickTolerance: ke }) {
              const ze = new rl({ checkCorrectEvent: (we) => R.mouseButton(we) === 0 && !we.ctrlKey });
              return new ia({ clickTolerance: ke, move: (we, je) => ({ around: je, panDelta: je.sub(we) }), activateOnStart: true, moveStateManager: ze, enable: xe, assignEvents: nl });
            })(e), ue = new il(e, s);
            s.dragPan = new Ih(u, ee, ue), this._add("mousePan", ee), this._add("touchPan", ue, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && s.dragPan.enable(e.dragPan);
            const ce = new sa(), pe = new sc();
            s.touchZoomRotate = new Eh(u, pe, ce, M), this._add("touchRotate", ce, ["touchPan", "touchZoom"]), this._add("touchZoom", pe, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && s.touchZoomRotate.enable(e.touchZoomRotate);
            const ge = s.scrollZoom = new Th(s, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ge, ["mousePan"]), e.interactive && e.scrollZoom && s.scrollZoom.enable(e.scrollZoom);
            const Ce = s.keyboard = new lc(s);
            this._add("keyboard", Ce), e.interactive && e.keyboard && s.keyboard.enable(), this._add("blockableMapEvent", new kh(s));
          }
          _add(e, s, u) {
            this._handlers.push({ handlerName: e, handler: s, allowed: u }), this._handlersById[e] = s;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: s } of this._handlers) s.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!so(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, s, u) {
            for (const m in e) if (m !== u && (!s || s.indexOf(m) < 0)) return true;
            return false;
          }
          _getMapTouches(e) {
            const s = [];
            for (const u of e) this._el.contains(u.target) && s.push(u);
            return s;
          }
          mergeHandlerResult(e, s, u, m, y) {
            if (!u) return;
            o.e(e, u);
            const x = { handlerName: m, originalEvent: u.originalEvent || y };
            u.zoomDelta !== void 0 && (s.zoom = x), u.panDelta !== void 0 && (s.drag = x), u.rollDelta !== void 0 && (s.roll = x), u.pitchDelta !== void 0 && (s.pitch = x), u.bearingDelta !== void 0 && (s.rotate = x);
          }
          _applyChanges() {
            const e = {}, s = {}, u = {};
            for (const [m, y, x] of this._changes) m.panDelta && (e.panDelta = (e.panDelta || new o.P(0, 0))._add(m.panDelta)), m.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + m.pitchDelta), m.rollDelta && (e.rollDelta = (e.rollDelta || 0) + m.rollDelta), m.around !== void 0 && (e.around = m.around), m.pinchAround !== void 0 && (e.pinchAround = m.pinchAround), m.noInertia && (e.noInertia = m.noInertia), o.e(s, y), o.e(u, x);
            this._updateMapTransform(e, s, u), this._changes = [];
          }
          _updateMapTransform(e, s, u) {
            const m = this._map, y = m._getTransformForUpdate(), x = m.terrain;
            if (!(aa(e) || x && this._terrainMovement)) return this._fireEvents(s, u, true);
            m._stop(true);
            let { panDelta: T, zoomDelta: M, bearingDelta: D, pitchDelta: F, rollDelta: j, around: $, pinchAround: G } = e;
            G !== void 0 && ($ = G), $ = $ || m.transform.centerPoint, x && !y.isPointOnMapSurface($) && ($ = y.centerPoint);
            const ee = { panDelta: T, zoomDelta: M, rollDelta: j, pitchDelta: F, bearingDelta: D, around: $ };
            this._map.cameraHelper.useGlobeControls && !y.isPointOnMapSurface($) && ($ = y.centerPoint);
            const ue = $.distSqr(y.centerPoint) < 0.01 ? y.center : y.screenPointToLocation(T ? $.sub(T) : $);
            x ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ee, y), this._terrainMovement || !s.drag && !s.zoom ? s.drag && this._terrainMovement ? y.setCenter(y.screenPointToLocation(y.centerPoint.sub(T))) : this._map.cameraHelper.handleMapControlsPan(ee, y, ue) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(ee, y, ue))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ee, y), this._map.cameraHelper.handleMapControlsPan(ee, y, ue)), m._applyUpdatedTransform(y), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(s, u, true);
          }
          _fireEvents(e, s, u) {
            const m = so(this._eventsInProgress), y = so(e), x = {};
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._eventsInProgress[j] || (x[`${j}start`] = $), this._eventsInProgress[j] = e[j];
            }
            !m && y && this._fireEvent("movestart", y.originalEvent);
            for (const j in x) this._fireEvent(j, x[j]);
            y && this._fireEvent("move", y.originalEvent);
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._fireEvent(j, $);
            }
            const T = {};
            let M;
            for (const j in this._eventsInProgress) {
              const { handlerName: $, originalEvent: G } = this._eventsInProgress[j];
              this._handlersById[$].isActive() || (delete this._eventsInProgress[j], M = s[$] || G, T[`${j}end`] = M);
            }
            for (const j in T) this._fireEvent(j, T[j]);
            const D = so(this._eventsInProgress), F = (m || y) && !D;
            if (F && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j);
            }
            if (u && F) {
              this._updatingCamera = true;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
              !j || !j.essential && z.prefersReducedMotion ? (this._map.fire(new o.l("moveend", { originalEvent: M })), $(this._map.getBearing()) && this._map.resetNorth()) : ($(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = true, this._map.easeTo(j, { originalEvent: M })), this._updatingCamera = false;
            }
          }
          _fireEvent(e, s) {
            this._map.fire(new o.l(e, s ? { originalEvent: s } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new rn("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class zh extends o.E {
          constructor(e, s, u) {
            super(), this._renderFrameCallback = () => {
              const m = Math.min((z.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(m)), m < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e, this._bearingSnap = u.bearingSnap, this.cameraHelper = s, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, s) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = s;
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, s) {
            return this.jumpTo({ center: e }, s);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, s) {
            return this.jumpTo({ elevation: e }, s), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, s, u) {
            return e = o.P.convert(e).mult(-1), this.panTo(this.transform.center, o.e({ offset: e }, s), u);
          }
          panTo(e, s, u) {
            return this.easeTo(o.e({ center: e }, s), u);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, s) {
            return this.jumpTo({ zoom: e }, s), this;
          }
          zoomTo(e, s, u) {
            return this.easeTo(o.e({ zoom: e }, s), u);
          }
          zoomIn(e, s) {
            return this.zoomTo(this.getZoom() + 1, e, s), this;
          }
          zoomOut(e, s) {
            return this.zoomTo(this.getZoom() - 1, e, s), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, s) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new o.l("movestart", s)).fire(new o.l("move", s)).fire(new o.l("moveend", s))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, s) {
            return this.jumpTo({ bearing: e }, s), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, s) {
            return this.jumpTo({ padding: e }, s), this;
          }
          rotateTo(e, s, u) {
            return this.easeTo(o.e({ bearing: e }, s), u);
          }
          resetNorth(e, s) {
            return this.rotateTo(0, o.e({ duration: 1e3 }, e), s), this;
          }
          resetNorthPitch(e, s) {
            return this.easeTo(o.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), s), this;
          }
          snapToNorth(e, s) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, s) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, s) {
            return this.jumpTo({ pitch: e }, s), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, s) {
            return this.jumpTo({ roll: e }, s), this;
          }
          cameraForBounds(e, s) {
            e = yt.convert(e).adjustAntiMeridian();
            const u = s && s.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), u, s);
          }
          _cameraForBoxAndBearing(e, s, u, m) {
            const y = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (m = o.e({ padding: y, offset: [0, 0], maxZoom: this.transform.maxZoom }, m)).padding == "number") {
              const D = m.padding;
              m.padding = { top: D, bottom: D, right: D, left: D };
            }
            const x = o.e(y, m.padding);
            m.padding = x;
            const T = this.transform, M = new yt(e, s);
            return this.cameraHelper.cameraForBoxAndBearing(m, x, M, u, T);
          }
          fitBounds(e, s, u) {
            return this._fitInternal(this.cameraForBounds(e, s), s, u);
          }
          fitScreenCoordinates(e, s, u, m, y) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(s)), u, m), m, y);
          }
          _fitInternal(e, s, u) {
            return e ? (delete (s = o.e(e, s)).padding, s.linear ? this.easeTo(s, u) : this.flyTo(s, u)) : this;
          }
          jumpTo(e, s) {
            this.stop();
            const u = this._getTransformForUpdate();
            let m = false, y = false, x = false;
            const T = u.zoom;
            this.cameraHelper.handleJumpToCenterZoom(u, e);
            const M = u.zoom !== T;
            return "elevation" in e && u.elevation !== +e.elevation && u.setElevation(+e.elevation), "bearing" in e && u.bearing !== +e.bearing && (m = true, u.setBearing(+e.bearing)), "pitch" in e && u.pitch !== +e.pitch && (y = true, u.setPitch(+e.pitch)), "roll" in e && u.roll !== +e.roll && (x = true, u.setRoll(+e.roll)), e.padding == null || u.isPaddingEqual(e.padding) || u.setPadding(e.padding), this._applyUpdatedTransform(u), this.fire(new o.l("movestart", s)).fire(new o.l("move", s)), M && this.fire(new o.l("zoomstart", s)).fire(new o.l("zoom", s)).fire(new o.l("zoomend", s)), m && this.fire(new o.l("rotatestart", s)).fire(new o.l("rotate", s)).fire(new o.l("rotateend", s)), y && this.fire(new o.l("pitchstart", s)).fire(new o.l("pitch", s)).fire(new o.l("pitchend", s)), x && this.fire(new o.l("rollstart", s)).fire(new o.l("roll", s)).fire(new o.l("rollend", s)), this.fire(new o.l("moveend", s));
          }
          calculateCameraOptionsFromTo(e, s, u, m = 0) {
            const y = o.a1.fromLngLat(e, s), x = o.a1.fromLngLat(u, m), T = x.x - y.x, M = x.y - y.y, D = x.z - y.z, F = Math.hypot(T, M, D);
            if (F === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(T, M), $ = o.ak(this.transform.cameraToCenterDistance / F / this.transform.tileSize), G = 180 * Math.atan2(T, -M) / Math.PI;
            let ee = 180 * Math.acos(j / F) / Math.PI;
            return ee = D < 0 ? 90 - ee : 90 + ee, { center: x.toLngLat(), elevation: m, zoom: $, pitch: ee, bearing: G };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, s, u, m, y) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(e, s, u, m);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: u, pitch: m, roll: y };
          }
          easeTo(e, s) {
            this._stop(false, e.easeId), ((e = o.e({ offset: [0, 0], duration: 500, easing: o.co }, e)).animate === false || !e.essential && z.prefersReducedMotion) && (e.duration = 0);
            const u = this._getTransformForUpdate(), m = this.getBearing(), y = u.pitch, x = u.roll, T = "bearing" in e ? this._normalizeBearing(e.bearing, m) : m, M = "pitch" in e ? +e.pitch : y, D = "roll" in e ? this._normalizeBearing(e.roll, x) : x, F = "padding" in e ? e.padding : u.padding, j = o.P.convert(e.offset);
            let $, G;
            e.around && ($ = o.S.convert(e.around), G = u.locationToScreenPoint($));
            const ee = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, ue = this.cameraHelper.handleEaseTo(u, { bearing: T, pitch: M, roll: D, padding: F, around: $, aroundPoint: G, offsetAsPoint: j, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || m !== T, this._pitching = this._pitching || M !== y, this._rolling = this._rolling || D !== x, this._padding = !u.isPaddingEqual(F), this._zooming = this._zooming || ue.isZooming, this._easeId = e.easeId, this._prepareEase(s, e.noMoveStart, ee), this.terrain && this._prepareElevation(ue.elevationCenter), this._ease(((ce) => {
              ue.easeFunc(ce), this.terrain && !e.freezeElevation && this._updateElevation(ce), this._applyUpdatedTransform(u), this._fireMoveEvents(s);
            }), ((ce) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(s, ce);
            }), e), this;
          }
          _prepareEase(e, s, u = {}) {
            this._moving = true, s || u.moving || this.fire(new o.l("movestart", e)), this._zooming && !u.zooming && this.fire(new o.l("zoomstart", e)), this._rotating && !u.rotating && this.fire(new o.l("rotatestart", e)), this._pitching && !u.pitching && this.fire(new o.l("pitchstart", e)), this._rolling && !u.rolling && this.fire(new o.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const s = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && s !== this._elevationTarget) {
              const u = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (u - (s - (u * e + this._elevationStart)) / (1 - e)), this._elevationTarget = s;
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const s = e.getCameraLngLat(), u = e.getCameraAltitude(), m = this.terrain ? this.terrain.getElevationForLngLatZoom(s, e.zoom) : 0;
            if (u < m) {
              const y = this.calculateCameraOptionsFromTo(s, m, e.center, e.elevation);
              return { pitch: y.pitch, zoom: y.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const s = [];
            if (s.push(((m) => this._elevateCameraIfInsideTerrain(m))), this.transformCameraUpdate && s.push(((m) => this.transformCameraUpdate(m))), !s.length) return;
            const u = e.clone();
            for (const m of s) {
              const y = u.clone(), { center: x, zoom: T, roll: M, pitch: D, bearing: F, elevation: j } = m(y);
              x && y.setCenter(x), j !== void 0 && y.setElevation(j), T !== void 0 && y.setZoom(T), M !== void 0 && y.setRoll(M), D !== void 0 && y.setPitch(D), F !== void 0 && y.setBearing(F), u.apply(y);
            }
            this.transform.apply(u);
          }
          _fireMoveEvents(e) {
            this.fire(new o.l("move", e)), this._zooming && this.fire(new o.l("zoom", e)), this._rotating && this.fire(new o.l("rotate", e)), this._pitching && this.fire(new o.l("pitch", e)), this._rolling && this.fire(new o.l("roll", e));
          }
          _afterEase(e, s) {
            if (this._easeId && s && this._easeId === s) return;
            delete this._easeId;
            const u = this._zooming, m = this._rotating, y = this._pitching, x = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, u && this.fire(new o.l("zoomend", e)), m && this.fire(new o.l("rotateend", e)), y && this.fire(new o.l("pitchend", e)), x && this.fire(new o.l("rollend", e)), this.fire(new o.l("moveend", e));
          }
          flyTo(e, s) {
            if (!e.essential && z.prefersReducedMotion) {
              const Je = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Je, s);
            }
            this.stop(), e = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.co }, e);
            const u = this._getTransformForUpdate(), m = u.bearing, y = u.pitch, x = u.roll, T = u.padding, M = "bearing" in e ? this._normalizeBearing(e.bearing, m) : m, D = "pitch" in e ? +e.pitch : y, F = "roll" in e ? this._normalizeBearing(e.roll, x) : x, j = "padding" in e ? e.padding : u.padding, $ = o.P.convert(e.offset);
            let G = u.centerPoint.add($);
            const ee = u.screenPointToLocation(G), ue = this.cameraHelper.handleFlyTo(u, { bearing: M, pitch: D, roll: F, padding: j, locationAtOffset: ee, offsetAsPoint: $, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let ce = e.curve;
            const pe = Math.max(u.width, u.height), ge = pe / ue.scaleOfZoom, Ce = ue.pixelPathLength;
            typeof ue.scaleOfMinZoom == "number" && (ce = Math.sqrt(pe / ue.scaleOfMinZoom / Ce * 2));
            const xe = ce * ce;
            function ke(Je) {
              const Tt = (ge * ge - pe * pe + (Je ? -1 : 1) * xe * xe * Ce * Ce) / (2 * (Je ? ge : pe) * xe * Ce);
              return Math.log(Math.sqrt(Tt * Tt + 1) - Tt);
            }
            function ze(Je) {
              return (Math.exp(Je) - Math.exp(-Je)) / 2;
            }
            function we(Je) {
              return (Math.exp(Je) + Math.exp(-Je)) / 2;
            }
            const je = ke(false);
            let Qe = function(Je) {
              return we(je) / we(je + ce * Je);
            }, qe = function(Je) {
              return pe * ((we(je) * (ze(Tt = je + ce * Je) / we(Tt)) - ze(je)) / xe) / Ce;
              var Tt;
            }, Ze = (ke(true) - je) / ce;
            if (Math.abs(Ce) < 2e-6 || !isFinite(Ze)) {
              if (Math.abs(pe - ge) < 1e-6) return this.easeTo(e, s);
              const Je = ge < pe ? -1 : 1;
              Ze = Math.abs(Math.log(ge / pe)) / ce, qe = () => 0, Qe = (Tt) => Math.exp(Je * ce * Tt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Ze / ("screenSpeed" in e ? +e.screenSpeed / ce : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = true, this._rotating = m !== M, this._pitching = D !== y, this._rolling = F !== x, this._padding = !u.isPaddingEqual(j), this._prepareEase(s, false), this.terrain && this._prepareElevation(ue.targetCenter), this._ease(((Je) => {
              const Tt = Je * Ze, It = 1 / Qe(Tt), ft = qe(Tt);
              this._rotating && u.setBearing(o.C.number(m, M, Je)), this._pitching && u.setPitch(o.C.number(y, D, Je)), this._rolling && u.setRoll(o.C.number(x, F, Je)), this._padding && (u.interpolatePadding(T, j, Je), G = u.centerPoint.add($)), ue.easeFunc(Je, It, ft, G), this.terrain && !e.freezeElevation && this._updateElevation(Je), this._applyUpdatedTransform(u), this._fireMoveEvents(s);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(s);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, s) {
            var u;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const m = this._onEaseEnd;
              delete this._onEaseEnd, m.call(this, s);
            }
            return e || (u = this.handlers) === null || u === void 0 || u.stop(false), this;
          }
          _ease(e, s, u) {
            u.animate === false || u.duration === 0 ? (e(1), s()) : (this._easeStart = z.now(), this._easeOptions = u, this._onEaseFrame = e, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, s) {
            e = o.aO(e, -180, 180);
            const u = Math.abs(e - s);
            return Math.abs(e - 360 - s) < u && (e -= 360), Math.abs(e + 360 - s) < u && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const Vu = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Uu {
          constructor(e = Vu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (s) => {
              !s || s.sourceDataType !== "metadata" && s.sourceDataType !== "visibility" && s.dataType !== "style" && s.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = R.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = R.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = R.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            R.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, s) {
            const u = this._map._getUIString(`AttributionControl.${s}`);
            e.title = u, e.setAttribute("aria-label", u);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((m) => typeof m != "string" ? "" : m))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const m = this._map.style.stylesheet;
              this.styleOwner = m.owner, this.styleId = m.id;
            }
            const s = this._map.style.sourceCaches;
            for (const m in s) {
              const y = s[m];
              if (y.used || y.usedForTerrain) {
                const x = y.getSource();
                x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
              }
            }
            e = e.filter(((m) => String(m).trim())), e.sort(((m, y) => m.length - y.length)), e = e.filter(((m, y) => {
              for (let x = y + 1; x < e.length; x++) if (e[x].indexOf(m) >= 0) return false;
              return true;
            }));
            const u = e.join(" | ");
            u !== this._attribHTML && (this._attribHTML = u, e.length ? (this._innerContainer.innerHTML = R.sanitize(u), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Ah {
          constructor(e = {}) {
            this._updateCompact = () => {
              const s = this._container.children;
              if (s.length) {
                const u = s[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && u.classList.add("maplibregl-compact") : u.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = R.create("div", "maplibregl-ctrl");
            const s = R.create("a", "maplibregl-ctrl-logo");
            return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://maplibre.org/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            R.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Io {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e) {
            const s = ++this._id;
            return this._queue.push({ callback: e, id: s, cancelled: false }), s;
          }
          remove(e) {
            const s = this._currentlyRunning, u = s ? this._queue.concat(s) : this._queue;
            for (const m of u) if (m.id === e) return void (m.cancelled = true);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const s = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const u of s) if (!u.cancelled && (u.callback(e), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var uc = o.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Xt extends o.E {
          constructor(e) {
            super(), this._lastTilesetChange = z.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = true, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e, s) {
            this.sourceCache.update(e, s), this._renderableTilesKeys = [];
            const u = {};
            for (const m of Te(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: s, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) u[m.key] = true, this._renderableTilesKeys.push(m.key), this._tiles[m.key] || (m.terrainRttPosMatrix32f = new Float64Array(16), o.bY(m.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[m.key] = new Sn(m, this.tileSize), this._lastTilesetChange = z.now());
            for (const m in this._tiles) u[m] || delete this._tiles[m];
          }
          freeRtt(e) {
            for (const s in this._tiles) {
              const u = this._tiles[s];
              (!e || u.tileID.equals(e) || u.tileID.isChildOf(e) || e.isChildOf(u.tileID)) && (u.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, s) {
            return s ? this._getTerrainCoordsForTileRanges(e, s) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const s = {};
            for (const u of this._renderableTilesKeys) {
              const m = this._tiles[u].tileID, y = e.clone(), x = o.ba();
              if (m.canonical.equals(e.canonical)) o.bY(x, 0, o.$, o.$, 0, 0, 1);
              else if (m.canonical.isChildOf(e.canonical)) {
                const T = m.canonical.z - e.canonical.z, M = m.canonical.x - (m.canonical.x >> T << T), D = m.canonical.y - (m.canonical.y >> T << T), F = o.$ >> T;
                o.bY(x, 0, F, F, 0, 0, 1), o.M(x, x, [-M * F, -D * F, 0]);
              } else {
                if (!e.canonical.isChildOf(m.canonical)) continue;
                {
                  const T = e.canonical.z - m.canonical.z, M = e.canonical.x - (e.canonical.x >> T << T), D = e.canonical.y - (e.canonical.y >> T << T), F = o.$ >> T;
                  o.bY(x, 0, o.$, o.$, 0, 0, 1), o.M(x, x, [M * F, D * F, 0]), o.N(x, x, [1 / 2 ** T, 1 / 2 ** T, 0]);
                }
              }
              y.terrainRttPosMatrix32f = new Float32Array(x), s[u] = y;
            }
            return s;
          }
          _getTerrainCoordsForTileRanges(e, s) {
            const u = {};
            for (const m of this._renderableTilesKeys) {
              const y = this._tiles[m].tileID;
              if (!this._isWithinTileRanges(y, s)) continue;
              const x = e.clone(), T = o.ba();
              if (y.canonical.z === e.canonical.z) {
                const M = e.canonical.x - y.canonical.x, D = e.canonical.y - y.canonical.y;
                o.bY(T, 0, o.$, o.$, 0, 0, 1), o.M(T, T, [M * o.$, D * o.$, 0]);
              } else if (y.canonical.z > e.canonical.z) {
                const M = y.canonical.z - e.canonical.z, D = y.canonical.x - (y.canonical.x >> M << M), F = y.canonical.y - (y.canonical.y >> M << M), j = e.canonical.x - (y.canonical.x >> M), $ = e.canonical.y - (y.canonical.y >> M), G = o.$ >> M;
                o.bY(T, 0, G, G, 0, 0, 1), o.M(T, T, [-D * G + j * o.$, -F * G + $ * o.$, 0]);
              } else {
                const M = e.canonical.z - y.canonical.z, D = e.canonical.x - (e.canonical.x >> M << M), F = e.canonical.y - (e.canonical.y >> M << M), j = (e.canonical.x >> M) - y.canonical.x, $ = (e.canonical.y >> M) - y.canonical.y, G = o.$ << M;
                o.bY(T, 0, G, G, 0, 0, 1), o.M(T, T, [D * o.$ + j * G, F * o.$ + $ * G, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(T), u[m] = x;
            }
            return u;
          }
          getSourceTile(e, s) {
            const u = this.sourceCache._source;
            let m = e.overscaledZ - this.deltaZoom;
            if (m > u.maxzoom && (m = u.maxzoom), m < u.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(m).key);
            let y = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!y || !y.dem) && s) for (; m >= u.minzoom && (!y || !y.dem); ) y = this.sourceCache.getTileByID(e.scaledTo(m--).key);
            return y;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, s) {
            return s[e.canonical.z] && e.canonical.x >= s[e.canonical.z].minTileX && e.canonical.x <= s[e.canonical.z].maxTileX && e.canonical.y >= s[e.canonical.z].minTileY && e.canonical.y <= s[e.canonical.z].maxTileY;
          }
        }
        class sr {
          constructor(e, s, u) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new Xt(s), this.options = u, this.exaggeration = typeof u.exaggeration == "number" ? u.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, s, u, m = o.$) {
            var y;
            if (!(s >= 0 && s < m && u >= 0 && u < m)) return 0;
            const x = this.getTerrainData(e), T = (y = x.tile) === null || y === void 0 ? void 0 : y.dem;
            if (!T) return 0;
            const M = o.cs([], [s / m * o.$, u / m * o.$], x.u_terrain_matrix), D = [M[0] * T.dim, M[1] * T.dim], F = Math.floor(D[0]), j = Math.floor(D[1]), $ = D[0] - F, G = D[1] - j;
            return T.get(F, j) * (1 - $) * (1 - G) + T.get(F + 1, j) * $ * (1 - G) + T.get(F, j + 1) * (1 - $) * G + T.get(F + 1, j + 1) * $ * G;
          }
          getElevationForLngLatZoom(e, s) {
            if (!o.ct(s, e.wrap())) return 0;
            const { tileID: u, mercatorX: m, mercatorY: y } = this._getOverscaledTileIDFromLngLatZoom(e, s);
            return this.getElevation(u, m % o.$, y % o.$, o.$);
          }
          getElevation(e, s, u, m = o.$) {
            return this.getDEMElevation(e, s, u, m) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const m = this.painter.context, y = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(m, y, m.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(m, new o.R({ width: 1, height: 1 }), m.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.ag([]);
            }
            const s = this.sourceCache.getSourceTile(e, true);
            if (s && s.dem && (!s.demTexture || s.needsTerrainPrepare)) {
              const m = this.painter.context;
              s.demTexture = this.painter.getTileTexture(s.dem.stride), s.demTexture ? s.demTexture.update(s.dem.getPixels(), { premultiply: false }) : s.demTexture = new o.T(m, s.dem.getPixels(), m.gl.RGBA, { premultiply: false }), s.demTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), s.needsTerrainPrepare = false;
            }
            const u = s && s + s.tileID.key + e.key;
            if (u && !this._demMatrixCache[u]) {
              const m = this.sourceCache.sourceCache._source.maxzoom;
              let y = e.canonical.z - s.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= m ? y = e.canonical.z - m : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = e.canonical.x - (e.canonical.x >> y << y), T = e.canonical.y - (e.canonical.y >> y << y), M = o.cu(new Float64Array(16), [1 / (o.$ << y), 1 / (o.$ << y), 0]);
              o.M(M, M, [x * o.$, T * o.$, 0]), this._demMatrixCache[e.key] = { matrix: M, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: s && s.dem && s.dem.dim || 1, u_terrain_matrix: u ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: s && s.dem && s.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (s && s.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: s };
          }
          getFramebuffer(e) {
            const s = this.painter, u = s.width / devicePixelRatio, m = s.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === u && this._fbo.height === m || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(s.context, { width: u, height: m, data: null }, s.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(s.context, { width: u, height: m, data: null }, s.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = s.context.createFramebuffer(u, m, true, false), this._fbo.depthAttachment.set(s.context.createRenderbuffer(s.context.gl.DEPTH_COMPONENT16, u, m))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const s = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let y = 0, x = 0; y < this._coordsTextureSize; y++) for (let T = 0; T < this._coordsTextureSize; T++, x += 4) s[x + 0] = 255 & T, s[x + 1] = 255 & y, s[x + 2] = T >> 8 << 4 | y >> 8, s[x + 3] = 0;
            const u = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(s.buffer)), m = new o.T(e, u, e.gl.RGBA, { premultiply: false });
            return m.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = m, m;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(true);
            const s = new Uint8Array(4), u = this.painter.context, m = u.gl, y = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), T = Math.round(this.painter.height / devicePixelRatio);
            u.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), m.readPixels(y, T - x - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, s), u.bindFramebuffer.set(null);
            const M = s[0] + (s[2] >> 4 << 8), D = s[1] + ((15 & s[2]) << 8), F = this.coordsIndex[255 - s[3]], j = F && this.sourceCache.getTileByID(F);
            if (!j) return null;
            const $ = this._coordsTextureSize, G = (1 << j.tileID.canonical.z) * $;
            return new o.a1((j.tileID.canonical.x * $ + M) / G + j.tileID.wrap, (j.tileID.canonical.y * $ + D) / G, this.getElevation(j.tileID, M, D, $));
          }
          depthAtPoint(e) {
            const s = new Uint8Array(4), u = this.painter.context, m = u.gl;
            return u.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), m.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, s), u.bindFramebuffer.set(null), (s[0] / 16777216 + s[1] / 65536 + s[2] / 256 + s[3]) / 256;
          }
          getTerrainMesh(e) {
            var s;
            const u = ((s = this.painter.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0, m = u && e.canonical.y === 0, y = u && e.canonical.y === (1 << e.canonical.z) - 1, x = `m_${m ? "n" : ""}_${y ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const T = this.painter.context, M = new o.cv(), D = new o.aN(), F = this.meshSize, j = o.$ / F, $ = F * F;
            for (let we = 0; we <= F; we++) for (let je = 0; je <= F; je++) M.emplaceBack(je * j, we * j, 0);
            for (let we = 0; we < $; we += F + 1) for (let je = 0; je < F; je++) D.emplaceBack(je + we, F + je + we + 1, F + je + we + 2), D.emplaceBack(je + we, F + je + we + 2, je + we + 1);
            const G = M.length, ee = G + (F + 1), ue = (F + 1) * F, ce = m ? o.bh : 0, pe = m ? 0 : 1, ge = y ? o.bi : o.$, Ce = y ? 0 : 1;
            for (let we = 0; we <= F; we++) M.emplaceBack(we * j, ce, pe);
            for (let we = 0; we <= F; we++) M.emplaceBack(we * j, ge, Ce);
            for (let we = 0; we < F; we++) D.emplaceBack(ue + we, ee + we, ee + we + 1), D.emplaceBack(ue + we, ee + we + 1, ue + we + 1), D.emplaceBack(0 + we, G + we + 1, G + we), D.emplaceBack(0 + we, 0 + we + 1, G + we + 1);
            const xe = M.length, ke = xe + 2 * (F + 1);
            for (const we of [0, 1]) for (let je = 0; je <= F; je++) for (const Qe of [0, 1]) M.emplaceBack(we * o.$, je * j, Qe);
            for (let we = 0; we < 2 * F; we += 2) D.emplaceBack(xe + we, xe + we + 1, xe + we + 3), D.emplaceBack(xe + we, xe + we + 3, xe + we + 2), D.emplaceBack(ke + we, ke + we + 3, ke + we + 1), D.emplaceBack(ke + we, ke + we + 2, ke + we + 3);
            const ze = new Ao(T.createVertexBuffer(M, uc.members), T.createIndexBuffer(D), o.aM.simpleSegment(0, 0, M.length, D.length));
            return this._meshCache[x] = ze, ze;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * o.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, s) {
            var u;
            const { tileID: m } = this._getOverscaledTileIDFromLngLatZoom(e, s);
            return (u = this.getMinMaxElevation(m).minElevation) !== null && u !== void 0 ? u : 0;
          }
          getMinMaxElevation(e) {
            const s = this.getTerrainData(e).tile, u = { minElevation: null, maxElevation: null };
            return s && s.dem && (u.minElevation = s.dem.min * this.exaggeration, u.maxElevation = s.dem.max * this.exaggeration), u;
          }
          _getOverscaledTileIDFromLngLatZoom(e, s) {
            const u = o.a1.fromLngLat(e.wrap()), m = (1 << s) * o.$, y = u.x * m, x = u.y * m, T = Math.floor(y / o.$), M = Math.floor(x / o.$);
            return { tileID: new o.Z(s, 0, s, T, M), mercatorX: y, mercatorY: x };
          }
        }
        class dc {
          constructor(e, s, u) {
            this._context = e, this._size = s, this._tileSize = u, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const s = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), u = new o.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return u.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), s.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), s.colorAttachment.set(u.texture), { id: e, fbo: s, texture: u, stamp: -1, inUse: false };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((s) => e.id !== s)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const s of this._recentlyUsed) if (!this._objects[s].inUse) return this._objects[s];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = false;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === false;
          }
        }
        const rs = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class hc {
          constructor(e, s) {
            this.painter = e, this.terrain = s, this.pool = new dc(e.context, 30, s.sourceCache.tileSize * s.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, s) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((u) => !e._layers[u].isHidden(s))), this._coordsAscending = {};
            for (const u in e.sourceCaches) {
              this._coordsAscending[u] = {};
              const m = e.sourceCaches[u].getVisibleCoordinates(), y = e.sourceCaches[u].getSource(), x = y instanceof kt ? y.terrainTileRanges : null;
              for (const T of m) {
                const M = this.terrain.sourceCache.getTerrainCoords(T, x);
                for (const D in M) this._coordsAscending[u][D] || (this._coordsAscending[u][D] = []), this._coordsAscending[u][D].push(M[D]);
              }
            }
            this._coordsAscendingStr = {};
            for (const u of e._order) {
              const m = e._layers[u], y = m.source;
              if (rs[m.type] && !this._coordsAscendingStr[y]) {
                this._coordsAscendingStr[y] = {};
                for (const x in this._coordsAscending[y]) this._coordsAscendingStr[y][x] = this._coordsAscending[y][x].map(((T) => T.key)).sort().join();
              }
            }
            for (const u of this._renderableTiles) for (const m in this._coordsAscendingStr) {
              const y = this._coordsAscendingStr[m][u.tileID.key];
              y && y !== u.rttCoords[m] && (u.rtt = []);
            }
          }
          renderLayer(e, s) {
            if (e.isHidden(this.painter.transform.zoom)) return false;
            const u = Object.assign(Object.assign({}, s), { isRenderingToTexture: true }), m = e.type, y = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (rs[m] && (this._prevType && rs[this._prevType] || this._stacks.push([]), this._prevType = m, this._stacks[this._stacks.length - 1].push(e.id), !x)) return true;
            if (rs[this._prevType] || rs[m] && x) {
              this._prevType = m;
              const T = this._stacks.length - 1, M = this._stacks[T] || [];
              for (const D of this._renderableTiles) {
                if (this.pool.isFull() && (ic(this.painter, this.terrain, this._rttTiles, u), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(D), D.rtt[T]) {
                  const j = this.pool.getObjectForId(D.rtt[T].id);
                  if (j.stamp === D.rtt[T].stamp) {
                    this.pool.useObject(j);
                    continue;
                  }
                }
                const F = this.pool.getOrCreateFreeObject();
                this.pool.useObject(F), this.pool.stampObject(F), D.rtt[T] = { id: F.id, stamp: F.stamp }, y.context.bindFramebuffer.set(F.fbo.framebuffer), y.context.clear({ color: o.bf.transparent, stencil: 0 }), y.currentStencilSource = void 0;
                for (let j = 0; j < M.length; j++) {
                  const $ = y.style._layers[M[j]], G = $.source ? this._coordsAscending[$.source][D.tileID.key] : [D.tileID];
                  y.context.viewport.set([0, 0, F.fbo.width, F.fbo.height]), y._renderTileClippingMasks($, G, true), y.renderLayer(y, y.style.sourceCaches[$.source], $, G, u), $.source && (D.rttCoords[$.source] = this._coordsAscendingStr[$.source][D.tileID.key]);
                }
              }
              return ic(this.painter, this.terrain, this._rttTiles, u), this._rttTiles = [], this.pool.freeAllObjects(), rs[m];
            }
            return false;
          }
        }
        const pi = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Dh = w, Zi = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Vu, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Cf = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class ol {
          constructor(e, s, u = false) {
            this.mousedown = (y) => {
              this.startMove(y, R.mousePos(this.element, y)), R.addEventListener(window, "mousemove", this.mousemove), R.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (y) => {
              this.move(y, R.mousePos(this.element, y));
            }, this.mouseup = (y) => {
              this._rotatePitchHandler.dragEnd(y), this.offTemp();
            }, this.touchstart = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = R.touchPos(this.element, y.targetTouches)[0], this.startMove(y, this._startPos), R.addEventListener(window, "touchmove", this.touchmove, { passive: false }), R.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._lastPos = R.touchPos(this.element, y.targetTouches)[0], this.move(y, this._lastPos));
            }, this.touchend = (y) => {
              y.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = s;
            const m = new bf();
            this._rotatePitchHandler = new ia({ clickTolerance: 3, move: (y, x) => {
              const T = s.getBoundingClientRect(), M = new o.P((T.bottom - T.top) / 2, (T.right - T.left) / 2);
              return { bearingDelta: o.cn(new o.P(y.x, x.y), x, M), pitchDelta: u ? -0.5 * (x.y - y.y) : void 0 };
            }, moveStateManager: m, enable: true, assignEvents: () => {
            } }), this.map = e, R.addEventListener(s, "mousedown", this.mousedown), R.addEventListener(s, "touchstart", this.touchstart, { passive: false }), R.addEventListener(s, "touchcancel", this.reset);
          }
          startMove(e, s) {
            this._rotatePitchHandler.dragStart(e, s), R.disableDrag();
          }
          move(e, s) {
            const u = this.map, { bearingDelta: m, pitchDelta: y } = this._rotatePitchHandler.dragMove(e, s) || {};
            m && u.setBearing(u.getBearing() + m), y && u.setPitch(u.getPitch() + y);
          }
          off() {
            const e = this.element;
            R.removeEventListener(e, "mousedown", this.mousedown), R.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), R.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), R.removeEventListener(window, "touchend", this.touchend), R.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            R.enableDrag(), R.removeEventListener(window, "mousemove", this.mousemove), R.removeEventListener(window, "mouseup", this.mouseup), R.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), R.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Yr;
        function Cn(v, e, s, u = false) {
          if (u || !s.getCoveringTilesDetailsProvider().allowWorldCopies()) return v == null ? void 0 : v.wrap();
          const m = new o.S(v.lng, v.lat);
          if (v = new o.S(v.lng, v.lat), e) {
            const y = new o.S(v.lng - 360, v.lat), x = new o.S(v.lng + 360, v.lat), T = s.locationToScreenPoint(v).distSqr(e);
            s.locationToScreenPoint(y).distSqr(e) < T ? v = y : s.locationToScreenPoint(x).distSqr(e) < T && (v = x);
          }
          for (; Math.abs(v.lng - s.center.lng) > 180; ) {
            const y = s.locationToScreenPoint(v);
            if (y.x >= 0 && y.y >= 0 && y.x <= s.width && y.y <= s.height) break;
            v.lng > s.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== m.lng && s.isPointOnMapSurface(s.locationToScreenPoint(v)) ? v : m;
        }
        const pc = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function la(v, e, s) {
          const u = v.classList;
          for (const m in pc) u.remove(`maplibregl-${s}-anchor-${m}`);
          u.add(`maplibregl-${s}-anchor-${e}`);
        }
        class ca extends o.E {
          constructor(e) {
            if (super(), this._onKeyPress = (s) => {
              const u = s.code, m = s.charCode || s.keyCode;
              u !== "Space" && u !== "Enter" && m !== 32 && m !== 13 || this.togglePopup();
            }, this._onMapClick = (s) => {
              const u = s.originalEvent.target, m = this._element;
              this._popup && (u === m || m.contains(u)) && this.togglePopup();
            }, this._update = (s) => {
              if (!this._map) return;
              const u = this._map.loaded() && !this._map.isMoving();
              ((s == null ? void 0 : s.type) === "terrain" || (s == null ? void 0 : s.type) === "render" && !u) && this._map.once("render", this._update), this._lngLat = Cn(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let m = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? m = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (m = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let y = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? y = "rotateX(0deg)" : this._pitchAlignment === "map" && (y = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || s && s.type !== "moveend" || (this._pos = this._pos.round()), R.setTransform(this._element, `${pc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${y} ${m}`), z.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(s && s.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (s) => {
              if (!this._isDragging) {
                const u = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = s.point.dist(this._pointerdownPos) >= u;
              }
              this._isDragging && (this._pos = s.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (s) => {
              this._element.contains(s.originalEvent.target) && (s.preventDefault(), this._positionDelta = s.point.sub(this._pos).add(this._offset), this._pointerdownPos = s.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || false, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = o.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = R.create("div");
              const s = R.createNS("http://www.w3.org/2000/svg", "svg"), u = 41, m = 27;
              s.setAttributeNS(null, "display", "block"), s.setAttributeNS(null, "height", `${u}px`), s.setAttributeNS(null, "width", `${m}px`), s.setAttributeNS(null, "viewBox", `0 0 ${m} ${u}`);
              const y = R.createNS("http://www.w3.org/2000/svg", "g");
              y.setAttributeNS(null, "stroke", "none"), y.setAttributeNS(null, "stroke-width", "1"), y.setAttributeNS(null, "fill", "none"), y.setAttributeNS(null, "fill-rule", "evenodd");
              const x = R.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const T = R.createNS("http://www.w3.org/2000/svg", "g");
              T.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), T.setAttributeNS(null, "fill", "#000000");
              const M = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const pe of M) {
                const ge = R.createNS("http://www.w3.org/2000/svg", "ellipse");
                ge.setAttributeNS(null, "opacity", "0.04"), ge.setAttributeNS(null, "cx", "10.5"), ge.setAttributeNS(null, "cy", "5.80029008"), ge.setAttributeNS(null, "rx", pe.rx), ge.setAttributeNS(null, "ry", pe.ry), T.appendChild(ge);
              }
              const D = R.createNS("http://www.w3.org/2000/svg", "g");
              D.setAttributeNS(null, "fill", this._color);
              const F = R.createNS("http://www.w3.org/2000/svg", "path");
              F.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), D.appendChild(F);
              const j = R.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const $ = R.createNS("http://www.w3.org/2000/svg", "path");
              $.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild($);
              const G = R.createNS("http://www.w3.org/2000/svg", "g");
              G.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), G.setAttributeNS(null, "fill", "#FFFFFF");
              const ee = R.createNS("http://www.w3.org/2000/svg", "g");
              ee.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ue = R.createNS("http://www.w3.org/2000/svg", "circle");
              ue.setAttributeNS(null, "fill", "#000000"), ue.setAttributeNS(null, "opacity", "0.25"), ue.setAttributeNS(null, "cx", "5.5"), ue.setAttributeNS(null, "cy", "5.5"), ue.setAttributeNS(null, "r", "5.4999962");
              const ce = R.createNS("http://www.w3.org/2000/svg", "circle");
              ce.setAttributeNS(null, "fill", "#FFFFFF"), ce.setAttributeNS(null, "cx", "5.5"), ce.setAttributeNS(null, "cy", "5.5"), ce.setAttributeNS(null, "r", "5.4999962"), ee.appendChild(ue), ee.appendChild(ce), x.appendChild(T), x.appendChild(D), x.appendChild(j), x.appendChild(G), x.appendChild(ee), s.appendChild(x), s.setAttributeNS(null, "height", u * this._scale + "px"), s.setAttributeNS(null, "width", m * this._scale + "px"), this._element.appendChild(s), this._offset = o.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((s) => {
              s.preventDefault();
            })), this._element.addEventListener("mousedown", ((s) => {
              s.preventDefault();
            })), la(this._element, this._anchor, "marker"), e && e.className) for (const s of e.className.split(" ")) this._element.classList.add(s);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), R.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = o.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const m = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [m, -1 * (38.1 - 13.5 + m)], "bottom-right": [-m, -1 * (38.1 - 13.5 + m)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = false) {
            var s, u;
            const m = (s = this._map) === null || s === void 0 ? void 0 : s.terrain, y = this._map.transform.isLocationOccluded(this._lngLat);
            if (!m || y) {
              const G = y ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== G && (this._element.style.opacity = G));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, T = x.terrain.depthAtPoint(this._pos), M = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, M) - T < 6e-3) return void (this._element.style.opacity = this._opacity);
            const D = -this._offset.y / x.transform.pixelsPerMeter, F = Math.sin(x.getPitch() * Math.PI / 180) * D, j = x.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), $ = x.transform.lngLatToCameraDepth(this._lngLat, M + F) - j > 6e-3;
            !((u = this._popup) === null || u === void 0) && u.isOpen() && $ && this._popup.remove(), this._element.style.opacity = $ ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = o.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, s) {
            return (this._opacity === void 0 || e === void 0 && s === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), s !== void 0 && (this._opacityWhenCovered = s), this._map && this._updateOpacity(true), this;
          }
        }
        const qu = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let ua = 0, As = false;
        const sl = { maxWidth: 100, unit: "metric" };
        function fc(v, e, s) {
          const u = s && s.maxWidth || 100, m = v._container.clientHeight / 2, y = v._container.clientWidth / 2, x = v.unproject([y - u / 2, m]), T = v.unproject([y + u / 2, m]), M = Math.round(v.project(T).x - v.project(x).x), D = Math.min(u, M, v._container.clientWidth), F = x.distanceTo(T);
          if (s && s.unit === "imperial") {
            const j = 3.2808 * F;
            j > 5280 ? Ds(e, D, j / 5280, v._getUIString("ScaleControl.Miles")) : Ds(e, D, j, v._getUIString("ScaleControl.Feet"));
          } else s && s.unit === "nautical" ? Ds(e, D, F / 1852, v._getUIString("ScaleControl.NauticalMiles")) : F >= 1e3 ? Ds(e, D, F / 1e3, v._getUIString("ScaleControl.Kilometers")) : Ds(e, D, F, v._getUIString("ScaleControl.Meters"));
        }
        function Ds(v, e, s, u) {
          const m = (function(y) {
            const x = Math.pow(10, `${Math.floor(y)}`.length - 1);
            let T = y / x;
            return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : (function(M) {
              const D = Math.pow(10, Math.ceil(-Math.log(M) / Math.LN10));
              return Math.round(M * D) / D;
            })(T), x * T;
          })(s);
          v.style.width = e * (m / s) + "px", v.innerHTML = `${m}&nbsp;${u}`;
        }
        const Gu = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Wu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function mc(v) {
          if (v) {
            if (typeof v == "number") {
              const e = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new o.P(0, 0), top: new o.P(0, v), "top-left": new o.P(e, e), "top-right": new o.P(-e, e), bottom: new o.P(0, -v), "bottom-left": new o.P(e, -e), "bottom-right": new o.P(-e, -e), left: new o.P(v, 0), right: new o.P(-v, 0) };
            }
            if (v instanceof o.P || Array.isArray(v)) {
              const e = o.P.convert(v);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: o.P.convert(v.center || [0, 0]), top: o.P.convert(v.top || [0, 0]), "top-left": o.P.convert(v["top-left"] || [0, 0]), "top-right": o.P.convert(v["top-right"] || [0, 0]), bottom: o.P.convert(v.bottom || [0, 0]), "bottom-left": o.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(v["bottom-right"] || [0, 0]), left: o.P.convert(v.left || [0, 0]), right: o.P.convert(v.right || [0, 0]) };
          }
          return mc(new o.P(0, 0));
        }
        const Zu = w;
        p.AJAXError = o.cz, p.Event = o.l, p.Evented = o.E, p.LngLat = o.S, p.MercatorCoordinate = o.a1, p.Point = o.P, p.addProtocol = o.cA, p.config = o.a, p.removeProtocol = o.cB, p.AttributionControl = Uu, p.BoxZoomHandler = Fu, p.CanvasSource = it, p.CooperativeGesturesHandler = Rh, p.DoubleClickZoomHandler = Ou, p.DragPanHandler = Ih, p.DragRotateHandler = ju, p.EdgeInsets = bs, p.FullscreenControl = class extends o.E {
          constructor(v = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let s = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = s == null ? void 0 : s.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) s = s.shadowRoot.fullscreenElement;
              s === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = R.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            R.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = R.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            R.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, p.GeoJSONSource = We, p.GeolocateControl = class extends o.E {
          constructor(v) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const s = new o.S(e.coords.longitude, e.coords.latitude), u = e.coords.accuracy, m = this._map.getBearing(), y = o.e({ bearing: m }, this.options.fitBoundsOptions), x = yt.fromLngLat(s, u);
              this._map.fitBounds(x, y, { geolocateSource: true });
            }, this._updateMarker = (e) => {
              if (e) {
                const s = new o.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(s).addTo(this._map), this._userLocationDotMarker.setLngLat(s).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && As) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = R.create("button", "maplibregl-ctrl-geolocate", this._container), R.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === false) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                } else {
                  const s = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = R.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ca({ element: this._dotElement }), this._circleElement = R.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ca({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((s) => {
                  const u = (s == null ? void 0 : s[0]) instanceof ResizeObserverEntry;
                  s.geolocateSource || this._watchState !== "ACTIVE_LOCK" || u || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")));
                }));
              }
            }, this.options = o.e({}, qu, v);
          }
          onAdd(v) {
            return this._map = v, this._container = R.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return o._(this, arguments, void 0, (function* (e = false) {
                if (Yr !== void 0 && !e) return Yr;
                if (window.navigator.permissions === void 0) return Yr = !!window.navigator.geolocation, Yr;
                try {
                  Yr = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Yr = !!window.navigator.geolocation;
                }
                return Yr;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), R.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ua = 0, As = false;
          }
          _isOutOfMapMaxBounds(v) {
            const e = this._map.getMaxBounds(), s = v.coords;
            return e && (s.longitude < e.getWest() || s.longitude > e.getEast() || s.latitude < e.getSouth() || s.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const v = this._map.getBounds(), e = v.getSouthEast(), s = v.getNorthEast(), u = e.distanceTo(s), m = Math.ceil(this._accuracy / (u / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${m}px`, this._circleElement.style.height = `${m}px`;
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ua--, As = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ua++, ua > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, As = true) : (v = this.options.positionOptions, As = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, p.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const e = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = R.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = R.create("button", "maplibregl-ctrl-globe", this._container), R.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            R.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, p.Hash = oc, p.ImageSource = kt, p.KeyboardHandler = lc, p.LngLatBounds = yt, p.LogoControl = Ah, p.Map = class extends zh {
          constructor(v) {
            var e, s;
            o.cw.mark(o.cx.create);
            const u = Object.assign(Object.assign(Object.assign({}, Zi), v), { canvasContextAttributes: Object.assign(Object.assign({}, Zi.canvasContextAttributes), v.canvasContextAttributes) });
            if (u.minZoom != null && u.maxZoom != null && u.minZoom > u.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (u.minPitch != null && u.maxPitch != null && u.minPitch > u.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (u.minPitch != null && u.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (u.maxPitch != null && u.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const m = new tn(), y = new oi();
            if (u.minZoom !== void 0 && m.setMinZoom(u.minZoom), u.maxZoom !== void 0 && m.setMaxZoom(u.maxZoom), u.minPitch !== void 0 && m.setMinPitch(u.minPitch), u.maxPitch !== void 0 && m.setMaxPitch(u.maxPitch), u.renderWorldCopies !== void 0 && m.setRenderWorldCopies(u.renderWorldCopies), super(m, y, { bearingSnap: u.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Io(), this._controls = [], this._mapId = o.a7(), this._contextLost = (T) => {
              T.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", { originalEvent: T }));
            }, this._contextRestored = (T) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", { originalEvent: T }));
            }, this._onMapScroll = (T) => {
              if (T.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = u.interactive, this._maxTileCacheSize = u.maxTileCacheSize, this._maxTileCacheZoomLevels = u.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, u.canvasContextAttributes), this._trackResize = u.trackResize === true, this._bearingSnap = u.bearingSnap, this._centerClampedToGround = u.centerClampedToGround, this._refreshExpiredTiles = u.refreshExpiredTiles === true, this._fadeDuration = u.fadeDuration, this._crossSourceCollisions = u.crossSourceCollisions === true, this._collectResourceTiming = u.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, pi), u.locale), this._clickTolerance = u.clickTolerance, this._overridePixelRatio = u.pixelRatio, this._maxCanvasSize = u.maxCanvasSize, this.transformCameraUpdate = u.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = u.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = X.addThrottleControl((() => this.isMoving())), this._requestManager = new te(u.transformRequest), typeof u.container == "string") {
              if (this._container = document.getElementById(u.container), !this._container) throw new Error(`Container '${u.container}' not found.`);
            } else {
              if (!(u.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = u.container;
            }
            if (u.maxBounds && this.setMaxBounds(u.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let T = false;
              const M = Rs(((D) => {
                this._trackResize && !this._removed && (this.resize(D), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((D) => {
                T ? M(D) : T = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Nu(this, u), this._hash = u.hash && new oc(typeof u.hash == "string" && u.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: u.center, elevation: u.elevation, zoom: u.zoom, bearing: u.bearing, pitch: u.pitch, roll: u.roll }), u.bounds && (this.resize(), this.fitBounds(u.bounds, o.e({}, u.fitBoundsOptions, { duration: 0 }))));
            const x = typeof u.style == "string" || ((s = (e = u.style) === null || e === void 0 ? void 0 : e.projection) === null || s === void 0 ? void 0 : s.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = u.localIdeographFontFamily, this._validateStyle = u.validateStyle, u.style && this.setStyle(u.style, { localIdeographFontFamily: u.localIdeographFontFamily }), u.attributionControl && this.addControl(new Uu(typeof u.attributionControl == "boolean" ? void 0 : u.attributionControl)), u.maplibreLogo && this.addControl(new Ah(), u.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const T = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(T);
              }
            })), this.on("data", ((T) => {
              this._update(T.dataType === "style"), this.fire(new o.l(`${T.dataType}data`, T));
            })), this.on("dataloading", ((T) => {
              this.fire(new o.l(`${T.dataType}dataloading`, T));
            })), this.on("dataabort", ((T) => {
              this.fire(new o.l("sourcedataabort", T));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, e) {
            return this.style.setGlobalStateProperty(v, e), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, e) {
            if (e === void 0 && (e = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s = v.onAdd(this);
            this._controls.push(v);
            const u = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? u.insertBefore(s, u.firstChild) : u.appendChild(s), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(v);
            return e > -1 && this._controls.splice(e, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          coveringTiles(v) {
            return Te(this.transform, v);
          }
          calculateCameraOptionsFromTo(v, e, s, u) {
            return u == null && this.terrain && (u = this.terrain.getElevationForLngLatZoom(s, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, e, s, u);
          }
          resize(v, e = true) {
            const [s, u] = this._containerDimensions(), m = this._getClampedPixelRatio(s, u);
            if (this._resizeCanvas(s, u, m), this.painter.resize(s, u, m), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const T = this._getClampedPixelRatio(s, u);
              this._resizeCanvas(s, u, T), this.painter.resize(s, u, T);
            }
            this._resizeTransform(e);
            const y = !this._moving;
            return y && (this.stop(), this.fire(new o.l("movestart", v)).fire(new o.l("move", v))), this.fire(new o.l("resize", v)), y && this.fire(new o.l("moveend", v)), this;
          }
          _resizeTransform(v = true) {
            var e;
            const [s, u] = this._containerDimensions();
            this.transform.resize(s, u, v), (e = this._requestedCameraState) === null || e === void 0 || e.resize(s, u, v);
          }
          _getClampedPixelRatio(v, e) {
            const { 0: s, 1: u } = this._maxCanvasSize, m = this.getPixelRatio(), y = v * m, x = e * m;
            return Math.min(y > s ? s / y : 1, x > u ? u / x : 1) * m;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(yt.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(o.S.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(o.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, e, s) {
            if (v === "mouseenter" || v === "mouseover") {
              let u = false;
              return { layers: e, listener: s, delegates: { mousemove: (y) => {
                const x = e.filter(((M) => this.getLayer(M))), T = x.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: x }) : [];
                T.length ? u || (u = true, s.call(this, new ki(v, this, y.originalEvent, { features: T }))) : u = false;
              }, mouseout: () => {
                u = false;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let u = false;
              return { layers: e, listener: s, delegates: { mousemove: (x) => {
                const T = e.filter(((M) => this.getLayer(M)));
                (T.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: T }) : []).length ? u = true : u && (u = false, s.call(this, new ki(v, this, x.originalEvent)));
              }, mouseout: (x) => {
                u && (u = false, s.call(this, new ki(v, this, x.originalEvent)));
              } } };
            }
            {
              const u = (m) => {
                const y = e.filter(((T) => this.getLayer(T))), x = y.length !== 0 ? this.queryRenderedFeatures(m.point, { layers: y }) : [];
                x.length && (m.features = x, s.call(this, m), delete m.features);
              };
              return { layers: e, listener: s, delegates: { [v]: u } };
            }
          }
          _saveDelegatedListener(v, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(e);
          }
          _removeDelegatedListener(v, e, s) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const u = this._delegatedListeners[v];
            for (let m = 0; m < u.length; m++) {
              const y = u[m];
              if (y.listener === s && y.layers.length === e.length && y.layers.every(((x) => e.includes(x)))) {
                for (const x in y.delegates) this.off(x, y.delegates[x]);
                return void u.splice(m, 1);
              }
            }
          }
          on(v, e, s) {
            if (s === void 0) return super.on(v, e);
            const u = typeof e == "string" ? [e] : e, m = this._createDelegatedListener(v, u, s);
            this._saveDelegatedListener(v, m);
            for (const y in m.delegates) this.on(y, m.delegates[y]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, u, s);
            } };
          }
          once(v, e, s) {
            if (s === void 0) return super.once(v, e);
            const u = typeof e == "string" ? [e] : e, m = this._createDelegatedListener(v, u, s);
            for (const y in m.delegates) {
              const x = m.delegates[y];
              m.delegates[y] = (...T) => {
                this._removeDelegatedListener(v, u, s), x(...T);
              };
            }
            this._saveDelegatedListener(v, m);
            for (const y in m.delegates) this.once(y, m.delegates[y]);
            return this;
          }
          off(v, e, s) {
            return s === void 0 ? super.off(v, e) : (this._removeDelegatedListener(v, typeof e == "string" ? [e] : e, s), this);
          }
          queryRenderedFeatures(v, e) {
            if (!this.style) return [];
            let s;
            const u = v instanceof o.P || Array.isArray(v), m = u ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (u ? {} : v) || {}, m instanceof o.P || typeof m[0] == "number") s = [o.P.convert(m)];
            else {
              const y = o.P.convert(m[0]), x = o.P.convert(m[1]);
              s = [y, new o.P(x.x, y.y), x, new o.P(y.x, x.y), y];
            }
            return this.style.queryRenderedFeatures(s, e, this.transform);
          }
          querySourceFeatures(v, e) {
            return this.style.querySourceFeatures(v, e);
          }
          setStyle(v, e) {
            return (e = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== false && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(v, e));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const e = this._locale[v];
            if (e == null) throw new Error(`Missing UI string '${v}'`);
            return e;
          }
          _updateStyle(v, e) {
            var s, u;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(v, e)));
            const m = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new uu(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, e, m) : this.style.loadJSON(v, e, m), this) : ((u = (s = this.style) === null || s === void 0 ? void 0 : s.projection) === null || u === void 0 || u.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new uu(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, e) {
            if (typeof v == "string") {
              const s = this._requestManager.transformRequest(v, "Style");
              o.j(s, new AbortController()).then(((u) => {
                this._updateDiff(u.data, e);
              })).catch(((u) => {
                u && this.fire(new o.k(u));
              }));
            } else typeof v == "object" && this._updateDiff(v, e);
          }
          _updateDiff(v, e) {
            try {
              this.style.setState(v, e) && this._update(true);
            } catch (s) {
              o.w(`Unable to perform style diff: ${s.message || s.error || s}.  Rebuilding the style from scratch.`), this._updateStyle(v, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
          }
          addSource(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, e), this._update(true);
          }
          isSourceLoaded(v) {
            const e = this.style && this.style.sourceCaches[v];
            if (e !== void 0) return e.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const e = this.style.sourceCaches[v.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && e.reload();
              for (const s in this.style._layers) {
                const u = this.style._layers[s];
                u.type === "hillshade" && u.source === v.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), u.type === "color-relief" && u.source === v.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new sr(this.painter, e, v), this.painter.renderToTexture = new hc(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (s) => {
                var u;
                s.dataType === "style" ? this.terrain.sourceCache.freeRtt() : s.dataType === "source" && s.tile && (s.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((u = s.source) === null || u === void 0 ? void 0 : u.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(s.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, e;
            return (e = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const e in v) {
              const s = v[e]._tiles;
              for (const u in s) {
                const m = s[u];
                if (m.state !== "loaded" && m.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(true);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, e, s) {
            if (s) {
              const u = this.getSource(s);
              if (!u) throw new Error(`There is no source with ID "${s}", cannot set LOD parameters`);
              u.calculateTileZoom = nt(Math.max(1, v), Math.max(1, e));
            } else for (const u in this.style.sourceCaches) this.style.sourceCaches[u].getSource().calculateTileZoom = nt(Math.max(1, v), Math.max(1, e));
            return this._update(true), this;
          }
          refreshTiles(v, e) {
            const s = this.style.sourceCaches[v];
            if (!s) throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
            e === void 0 ? s.reload(true) : s.refreshTiles(e.map(((u) => new o.a4(u.z, u.x, u.y))));
          }
          addImage(v, e, s = {}) {
            const { pixelRatio: u = 1, sdf: m = false, stretchX: y, stretchY: x, content: T, textFitWidth: M, textFitHeight: D } = s;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || o.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: F, height: j, data: $ } = e, G = e;
                return this.style.addImage(v, { data: new o.R({ width: F, height: j }, new Uint8Array($)), pixelRatio: u, stretchX: y, stretchY: x, content: T, textFitWidth: M, textFitHeight: D, sdf: m, version: 0, userImage: G }), G.onAdd && G.onAdd(this, v), this;
              }
            }
            {
              const { width: F, height: j, data: $ } = z.getImageData(e);
              this.style.addImage(v, { data: new o.R({ width: F, height: j }, $), pixelRatio: u, stretchX: y, stretchY: x, content: T, textFitWidth: M, textFitHeight: D, sdf: m, version: 0 });
            }
          }
          updateImage(v, e) {
            const s = this.style.getImage(v);
            if (!s) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const u = e instanceof HTMLImageElement || o.b(e) ? z.getImageData(e) : e, { width: m, height: y, data: x } = u;
            if (m === void 0 || y === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (m !== s.data.width || y !== s.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const T = !(e instanceof HTMLImageElement || o.b(e));
            return s.data.replace(x, T), this.style.updateImage(v, s), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new o.k(new Error("Missing required image id"))), false);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return X.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, e), this._update(true);
          }
          moveLayer(v, e) {
            return this.style.moveLayer(v, e), this._update(true);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(true);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, e, s) {
            return this.style.setLayerZoomRange(v, e, s), this._update(true);
          }
          setFilter(v, e, s = {}) {
            return this.style.setFilter(v, e, s), this._update(true);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, e, s, u = {}) {
            return this.style.setPaintProperty(v, e, s, u), this._update(true);
          }
          getPaintProperty(v, e) {
            return this.style.getPaintProperty(v, e);
          }
          setLayoutProperty(v, e, s, u = {}) {
            return this.style.setLayoutProperty(v, e, s, u), this._update(true);
          }
          getLayoutProperty(v, e) {
            return this.style.getLayoutProperty(v, e);
          }
          setGlyphs(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, e), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, e, s = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, e, s, ((u) => {
              u || this._update(true);
            })), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, e, ((s) => {
              s || this._update(true);
            })), this;
          }
          setLight(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(v, e), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(v, e), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, e) {
            return this.style.setFeatureState(v, e), this._update();
          }
          removeFeatureState(v, e) {
            return this.style.removeFeatureState(v, e), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, e = 0;
            return this._container && (v = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [v, e];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const e = this._canvasContainer = R.create("div", "maplibregl-canvas-container", v);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = R.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const s = this._containerDimensions(), u = this._getClampedPixelRatio(s[0], s[1]);
            this._resizeCanvas(s[0], s[1], u);
            const m = this._controlContainer = R.create("div", "maplibregl-control-container", v), y = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              y[x] = R.create("div", `maplibregl-ctrl-${x} `, m);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(v, e, s) {
            this._canvas.width = Math.floor(s * v), this._canvas.height = Math.floor(s * e), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((u) => {
              e = { requestedAttributes: v }, u && (e.statusMessage = u.statusMessage, e.type = u.type);
            }), { once: true });
            let s = null;
            if (s = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !s) {
              const u = "Failed to initialize WebGL";
              throw e ? (e.message = u, new Error(JSON.stringify(e))) : new Error(u);
            }
            this.painter = new yh(s, this.transform), O.testSupport(s);
          }
          migrateProjection(v, e) {
            super.migrateProjection(v, e), this.painter.transform = v, this.fire(new o.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var e, s, u, m, y;
            const x = this._idleTriggered ? this._fadeDuration : 0, T = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let M = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const j = this.transform.zoom, $ = z.now();
              this.style.zoomHistory.update(j, $);
              const G = new o.F(j, { now: $, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), ee = G.crossFadingFactor();
              ee === 1 && ee === this._crossFadingFactor || (M = true, this._crossFadingFactor = ee), this.style.update(G);
            }
            const D = ((s = this.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0 !== T;
            (u = this.style.projection) === null || u === void 0 || u.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((m = this.style.projection) === null || m === void 0 ? void 0 : m.transitionState, (y = this.style.projection) === null || y === void 0 ? void 0 : y.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || D) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, D), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = true, o.cw.mark(o.cx.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || M) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const F = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return F || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || F || (this._fullyLoaded = true, o.cw.mark(o.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const s of this._controls) s.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), X.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (e == null ? void 0 : e.loseContext) && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), R.remove(this._canvasContainer), R.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), o.cw.clearMetrics(), this._removed = true, this.fire(new o.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), z.frame(this._frameRequest, ((v) => {
              o.cw.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (e) {
                if (!o.cy(e) && !(function(s) {
                  return s.message === Xa;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return Dh;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(true);
          }
        }, p.MapMouseEvent = ki, p.MapTouchEvent = ta, p.MapWheelEvent = Du, p.Marker = ca, p.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), s = e === this._map.getMaxZoom(), u = e === this._map.getMinZoom();
              this._zoomInButton.disabled = s, this._zoomOutButton.disabled = u, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", u.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, s) => {
              const u = this._map._getUIString(`NavigationControl.${s}`);
              e.title = u, e.setAttribute("aria-label", u);
            }, this.options = o.e({}, Cf, v), this._container = R.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), R.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), R.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = R.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ol(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            R.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, e) {
            const s = R.create("button", v, this._container);
            return s.type = "button", s.addEventListener("click", e), s;
          }
        }, p.Popup = class extends o.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && R.remove(this._content), this._container && (R.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = R.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = R.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Cn(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const s = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let u = this.options.anchor;
              const m = mc(this.options.offset);
              if (!u) {
                const x = this._container.offsetWidth, T = this._container.offsetHeight;
                let M;
                M = s.y + m.bottom.y < T ? ["top"] : s.y > this._map.transform.height - T ? ["bottom"] : [], s.x < x / 2 ? M.push("left") : s.x > this._map.transform.width - x / 2 && M.push("right"), u = M.length === 0 ? "bottom" : M.join("-");
              }
              let y = s.add(m[u]);
              this.options.subpixelPositioning || (y = y.round()), R.setTransform(this._container, `${pc[u]} translate(${y.x}px,${y.y}px)`), la(this._container, u, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = o.e(Object.create(Gu), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = o.S.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const e = document.createDocumentFragment(), s = document.createElement("body");
            let u;
            for (s.innerHTML = v; u = s.firstChild, u; ) e.appendChild(u);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = R.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = R.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(Wu);
            v && v.focus();
          }
        }, p.RasterDEMTileSource = ut, p.RasterTileSource = ir, p.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              fc(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, fc(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, sl), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = R.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            R.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, p.ScrollZoomHandler = Th, p.Style = uu, p.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = R.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = R.create("button", "maplibregl-ctrl-terrain", this._container), R.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            R.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, p.TwoFingersTouchPitchHandler = ac, p.TwoFingersTouchRotateHandler = sa, p.TwoFingersTouchZoomHandler = sc, p.TwoFingersTouchZoomRotateHandler = Eh, p.VectorTileSource = Dt, p.VideoSource = et, p.addSourceType = (v, e) => o._(void 0, void 0, void 0, (function* () {
          if (Et(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((s, u) => {
            Pt[s] = u;
          })(v, e);
        })), p.clearPrewarmedResources = function() {
          const v = bt;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(Ke), bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, p.createTileMesh = lu, p.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, p.getRTLTextPluginStatus = function() {
          return on().getRTLTextPluginStatus();
        }, p.getVersion = function() {
          return Zu;
        }, p.getWorkerCount = function() {
          return Lt.workerCount;
        }, p.getWorkerUrl = function() {
          return o.a.WORKER_URL;
        }, p.importScriptInWorkers = function(v) {
          return jt().broadcast("IS", v);
        }, p.prewarm = function() {
          Yt().acquire(Ke);
        }, p.setMaxParallelImageRequests = function(v) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, p.setRTLTextPlugin = function(v, e) {
          return on().setRTLTextPlugin(v, e);
        }, p.setWorkerCount = function(v) {
          Lt.workerCount = v;
        }, p.setWorkerUrl = function(v) {
          o.a.WORKER_URL = v;
        };
      }));
      var g = l;
      return g;
    }));
  })(xp)), xp.exports;
}
var Ml = BR();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const OR = Symbol("map"), El = OR, Gd = Symbol("isLoaded"), $R = Symbol("isInitialized"), A1 = $R, zv = Symbol("componentId"), Av = Symbol("sourceId"), D1 = Symbol("sourceLayerRegistry"), jR = Symbol("marker"), NR = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function VR(a, i, l, d) {
  return (h) => l.emit(d, { type: h.type, map: i, component: a, event: h });
}
function UR(a, i) {
  const l = Ml.LngLat.convert(a), d = Ml.LngLat.convert(i);
  return l.lng === d.lng && l.lat === d.lat;
}
var Hp = ((a) => (a.TOP_LEFT = "top-left", a.TOP_RIGHT = "top-right", a.BOTTOM_LEFT = "bottom-left", a.BOTTOM_RIGHT = "bottom-right", a))(Hp || {});
const Wd = Object.values(Hp), v0 = /* @__PURE__ */ new Map(), qR = Symbol("default");
function GR(a, i, l = qR) {
  var _a3;
  let d = v0.get(l);
  return d || (d = CC({ isLoaded: false, isMounted: false, language: null }), v0.set(l, d)), d.isLoaded = ((_a3 = i.value) == null ? void 0 : _a3.loaded()) || false, d.isMounted = false, d.component = a, d.map = i.value, d;
}
const F1 = ot({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (a) => a in Hp }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(a, i) {
  const l = S_(Qc()), d = Ws(), h = Ws(), g = Me(false), p = Me(false), o = /* @__PURE__ */ new Map(), w = GR(l, h, a.mapKey);
  Zr(El, h), Zr(Gd, p), Zr(A1, g), Zr(zv, l.uid), Zr(Av, ""), Kt(() => a.bearing, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setBearing(z));
  }), Kt(() => a.bounds, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.fitBounds(z, a.fitBoundsOptions));
  }), Kt(() => a.center, (z) => {
    var _a3, _b2;
    const R = (_a3 = h.value) == null ? void 0 : _a3.getCenter();
    z && R && !UR(z, R) && ((_b2 = h.value) == null ? void 0 : _b2.setCenter(z));
  }), Kt(() => a.maxBounds, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setMaxBounds(z));
  }), Kt(() => a.maxPitch, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setMaxPitch(z));
  }), Kt(() => a.maxZoom, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setMaxZoom(z));
  }), Kt(() => a.minPitch, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setMinPitch(z));
  }), Kt(() => a.minZoom, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setMinZoom(z));
  }), Kt(() => a.pitch, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setPitch(z));
  }), Kt(() => a.renderWorldCopies, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setRenderWorldCopies(z));
  }), Kt(() => a.mapStyle, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setStyle(z));
  }), Kt(() => a.transformRequest, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setTransformRequest(z));
  }), Kt(() => a.zoom, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setZoom(z));
  }), Kt(() => a.zoom, (z) => {
    var _a3;
    z && ((_a3 = h.value) == null ? void 0 : _a3.setZoom(z));
  });
  function S() {
    w.isMounted = true;
    const z = { ...a, style: a.mapStyle, container: d.value };
    for (const R of Object.keys(z)) z[R] === void 0 && delete z[R];
    if (h.value = S_(new Ml.Map(z)), w.map = h.value, g.value = true, o.set("__load", () => (p.value = true, w.isLoaded = true)), h.value.on("load", o.get("__load")), o.set("__moveend", () => i.emit("update:center", h.value.getCenter())), h.value.on("moveend", o.get("__moveend")), o.set("__zoomend", () => i.emit("update:zoom", h.value.getZoom())), h.value.on("zoomend", o.get("__zoomend")), o.set("__pitchend", () => i.emit("update:pitch", h.value.getPitch())), h.value.on("pitchend", o.get("__pitchend")), o.set("__rotateend", () => i.emit("update:bearing", h.value.getBearing())), h.value.on("rotateend", o.get("__rotateend")), l.vnode.props) {
      for (const R of NR) if (l.vnode.props["onMap:" + R]) {
        const O = `map:${R}`, V = VR(l, h.value, i, O);
        o.set(R, V), h.value.on(R, V);
      }
    }
    h.value.getCanvas().addEventListener("webglcontextlost", I);
  }
  async function k() {
    w.isMounted = false, w.isLoaded = false, p.value = false, h.value && (h.value.getCanvas().removeEventListener("webglcontextlost", I), g.value = false, o.forEach((z, R) => {
      h.value.off(R.startsWith("__") ? R.substring(2) : R, z);
    }), h.value.remove());
  }
  function I() {
    k(), Vi(S);
  }
  return Tn(S), Ci(k), i.expose({ map: h }), () => [L("div", { ref: d, style: { height: a.height, width: a.width } }), g.value && i.slots.default ? i.slots.default({}) : void 0];
}, render() {
  return null;
} });
function WR(a, i, l) {
  Kt(a, (d) => {
    var _a3, _b2;
    d && Wd.indexOf(d) === -1 || (((_a3 = i.value) == null ? void 0 : _a3.hasControl(l)) && i.value.removeControl(l), (_b2 = i.value) == null ? void 0 : _b2.addControl(l, d));
  }, { immediate: true });
}
function Xp(a, i) {
  const l = hr(El), d = hr(A1), h = Ws();
  return h.value = a(), WR(() => i.position, l, h.value), Ci(() => {
    var _a3;
    return d.value && ((_a3 = l.value) == null ? void 0 : _a3.removeControl(h.value));
  }), { control: h, map: l };
}
class ZR {
  constructor(i, l) {
    __publicField(this, "container");
    this.isAdded = i, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return Hp.TOP_LEFT;
  }
  onAdd() {
    return Vi(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(i) {
    this.container.className = i;
  }
}
const Yp = ot({ name: "MglCustomControl", props: { position: { type: String, validator: (a) => Wd.indexOf(a) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(a, { slots: i }) {
  const l = Me(false), { control: d } = Xp(() => new ZR(l, a.class), a);
  return Kt(() => a.class, () => d.value.setClasses(a.class)), () => {
    var _a3;
    return l.value ? L(Kb, { to: d.value.container }, (_a3 = i.default) == null ? void 0 : _a3.call(i, {})) : Pr("custom-component");
  };
}, render() {
  return null;
} }), L1 = ot({ name: "MglFullscreenControl", props: { position: { type: String, validator: (a) => Wd.indexOf(a) !== -1 }, container: { type: Object, default: null } }, setup(a) {
  const { control: i, map: l } = Xp(() => new Ml.FullscreenControl({ container: a.container || void 0 }), a);
  function d() {
    Vi(() => {
      var _a3;
      return (_a3 = l.value) == null ? void 0 : _a3.resize();
    });
  }
  i.value.on("fullscreenstart", d), i.value.on("fullscreenend", d), Ci(() => {
    i.value.off("fullscreenstart", d), i.value.off("fullscreenend", d);
  });
}, render() {
  return null;
} }), B1 = ot({ name: "MglNavigationControl", props: { position: { type: String, validator: (a) => Wd.indexOf(a) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(a) {
  Xp(() => new Ml.NavigationControl({ showCompass: a.showCompass, showZoom: a.showZoom, visualizePitch: a.visualizePitch }), a);
}, render() {
  return null;
} });
var O1 = ((a) => (a.IMPERIAL = "imperial", a.METRIC = "metric", a.NAUTICAL = "nautical", a))(O1 || {});
const HR = Object.values(O1), $1 = ot({ name: "MglScaleControl", props: { position: { type: String, validator: (a) => Wd.indexOf(a) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (a) => HR.indexOf(a) !== -1 } }, setup(a) {
  Xp(() => new Ml.ScaleControl({ maxWidth: a.maxWidth, unit: a.unit }), a);
}, render() {
  return null;
} }), XR = ot({ name: "MglMarker", emits: ["dragstart", "drag", "dragend", "update:coordinates"], props: { coordinates: { type: [Object, Array], required: true }, className: String, offset: [Object, Array], anchor: String, color: String, draggable: Boolean, clickTolerance: Number, rotation: Number, rotationAlignment: String, pitchAlignment: String, scale: Number, opacity: String, opacityWhenCovered: String, subpixelPositioning: { type: Boolean, default: false } }, setup(a, { slots: i, emit: l }) {
  const d = hr(El), h = Ws(), g = Me(), p = Me(false), o = /* @__PURE__ */ new Map();
  function w(S, k) {
    const I = (z) => {
      k && k(), l(S, z);
    };
    h.value.on(S, I), o.set(S, I);
  }
  return Zr(jR, h), Tn(() => {
    const S = { ...a };
    i.marker && (S.element = g.value), h.value = new Ml.Marker(S), h.value.setLngLat(a.coordinates).addTo(d.value), w("dragstart"), w("drag", () => {
      var _a3;
      l("update:coordinates", (_a3 = h.value) == null ? void 0 : _a3.getLngLat());
    }), w("dragend", () => {
      var _a3;
      l("update:coordinates", (_a3 = h.value) == null ? void 0 : _a3.getLngLat());
    }), p.value = true;
  }), Kt(() => a.coordinates, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setLngLat(S);
  }, { deep: true }), Kt(() => a.draggable, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setDraggable(S);
  }), Kt(() => a.offset, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setOffset(S || [0, 0]);
  }), Kt(() => a.pitchAlignment, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setPitchAlignment(S || "auto");
  }), Kt(() => a.rotation, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setRotation(S);
  }), Kt(() => a.rotationAlignment, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setRotationAlignment(S || "auto");
  }), Kt(() => a.opacity, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setOpacity(S, a.opacityWhenCovered);
  }), Kt(() => a.opacityWhenCovered, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setOpacity(a.opacity, S);
  }), Kt(() => a.subpixelPositioning, (S) => {
    var _a3;
    return (_a3 = h.value) == null ? void 0 : _a3.setSubpixelPositioning(S);
  }), Kt(() => a.className, (S, k) => {
    var _a3, _b2;
    k && ((_a3 = h.value) == null ? void 0 : _a3.removeClassName(k)), S && ((_b2 = h.value) == null ? void 0 : _b2.addClassName(S));
  }), Ci(() => {
    var _a3;
    o.forEach((S, k) => {
      var _a4;
      (_a4 = h.value) == null ? void 0 : _a4.off(k, S);
    }), (_a3 = h.value) == null ? void 0 : _a3.remove();
  }), () => [L("div", i.default && p.value ? i.default({}) : void 0), L("div", { ref: g }, i.marker ? i.marker() : void 0)];
}, render() {
  return null;
} });
let YR = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(i, l) {
    this.unmountHandlers.set(i, l);
  }
  unregisterUnmountHandler(i) {
    this.unmountHandlers.delete(i);
  }
  unmount() {
    this.unmountHandlers.forEach((i) => i());
  }
}, Dv = (_a2 = class {
  static genSourceOpts(i) {
    const l = { ...i };
    for (const d of Object.keys(l)) (l[d] === void 0 || d === "sourceId") && delete l[d];
    return l;
  }
  static getSourceRef(i, l) {
    const d = typeof l == "string", h = String(i) + (d ? l : "");
    let g = _a2.REFS.get(h);
    return g || (g = Me(d ? null : void 0), _a2.REFS.set(h, g)), g;
  }
}, __publicField(_a2, "REFS", /* @__PURE__ */ new Map()), _a2);
function KR(a, i, l) {
  const d = hr(El), h = hr(Gd);
  function g() {
    h.value && (d.value.addSource(i.sourceId, Dv.genSourceOpts(i)), a.value = d.value.getSource(i.sourceId));
  }
  return Kt(h, g, { immediate: true }), d.value.on("style.load", g), Ci(() => {
    h.value && (l.unmount(), d.value.removeSource(i.sourceId)), d.value.off("style.load", g);
  });
}
const JR = ot({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(a, { slots: i }) {
  const l = hr(zv), d = Dv.getSourceRef(l, a.sourceId), h = new YR(), g = { ...a, type: "geojson" };
  return Zr(Av, a.sourceId), Zr(D1, h), KR(d, g, h), Kt([wC(a.data) ? a.data : () => a.data, d], ([p, o]) => {
    o == null ? void 0 : o.setData(p || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [Pr("GeoJSON Source"), d.value && i.default ? i.default({}) : void 0];
} }), Zo = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function Ta() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function QR(a, i, l, d) {
  const h = { id: a, type: i, source: l.source || d, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const g of Object.keys(h)) h[g] === void 0 && delete h[g];
  return h;
}
function ez(a, i, l) {
  if (l.props) for (const d of Zo) {
    const h = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[h] && a.on(d, i, l.props[h]);
  }
}
function tz(a, i, l) {
  if (l.props) for (const d of Zo) {
    const h = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[h] && a.off(d, i, l.props[h]);
  }
}
function j1(a, i) {
  const l = hr(El), d = hr(Gd), h = hr(D1);
  function g() {
    d.value && (i && tz(l.value, a, i.vnode), l.value.getLayer(a) && l.value.removeLayer(a));
  }
  h.registerUnmountHandler(a, g), Ci(() => {
    h.unregisterUnmountHandler(a), g();
  });
}
ot({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...Zo], setup(a) {
  const i = hr(El), l = hr(Gd);
  return j1(a.layerId), Kt(() => a.layout, (d) => {
    if (d) for (const [h, g] of Object.entries(d)) i.value.setLayoutProperty(a.layerId, h, g);
  }), Kt(() => a.paint, (d) => {
    if (d) for (const [h, g] of Object.entries(d)) i.value.setPaintProperty(a.layerId, h, g);
  }), Kt(l, (d) => {
    d && i.value.addLayer({ id: a.layerId, type: "background", metadata: a.metadata, minzoom: a.minzoom, maxzoom: a.maxzoom, layout: a.layout, paint: a.paint }, a.before || void 0);
  }, { immediate: true }), () => Pr("Background Layer");
} });
function Ma(a, i) {
  const l = hr(Av);
  if (!l && !i.source) return;
  const d = Qc(), h = hr(El), g = hr(Gd), p = hr(zv), o = Dv.getSourceRef(p, i.source || l);
  return j1(i.layerId, d), Kt(() => i.minzoom, () => h.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Kt(() => i.maxzoom, () => h.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Kt(() => i.layout, (w) => {
    if (w) for (const [S, k] of Object.entries(w)) h.value.setLayoutProperty(i.layerId, S, k);
  }, { deep: true }), Kt(() => i.paint, (w) => {
    if (w) for (const [S, k] of Object.entries(w)) h.value.setPaintProperty(i.layerId, S, k);
  }, { deep: true }), Kt(() => i.filter, (w) => h.value.setFilter(i.layerId, w), { deep: true }), Kt([g, o], ([w, S]) => {
    w && (S || S === void 0) && (h.value.addLayer(QR(i.layerId, a, i, l), i.before || void 0), ez(h.value, i.layerId, d.vnode));
  }, { immediate: true }), () => Pr(`${a} Layer`);
}
ot({ name: "MglCircleLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("circle", a);
} });
ot({ name: "MglFillLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("fill", a);
} });
ot({ name: "MglFillExtrusionLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("fill-extrusion", a);
} });
ot({ name: "MglHeatmapLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("heatmap", a);
} });
ot({ name: "MglHillshadeLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("hillshade", a);
} });
const rz = ot({ name: "MglLineLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("line", a);
} });
ot({ name: "MglRasterLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("raster", a);
} });
ot({ name: "MglSymbolLayer", props: Ta(), emits: [...Zo], setup(a) {
  return Ma("symbol", a);
} });
const nz = 0.3, iz = ot({ __name: "MapCompass", props: Zs({ pitch: {}, size: {}, tracking: { type: Boolean } }, { bearing: { default: 0 }, bearingModifiers: {} }), emits: Zs(["toggleTracking"], ["update:bearing"]), setup(a, { emit: i }) {
  Pa((q) => ({ "1c8003b6": Y(l).primaryColor, "11ea132b": Y(l).modalColor, "1738aa7c": Y(l).borderColor, "34c26392": Y(l).textColorBase }));
  const l = Sa(), d = a, h = Zc(a, "bearing"), g = i, p = De(() => `transform: rotate(${-h.value % 360}deg)`), o = De(() => `transform: rotateX(${Math.min(45, d.pitch ? d.pitch : 0)}deg); transition: all 0.3s ease;`), w = De(() => d.size || 40), S = De(() => w.value / 6), k = De(() => S.value / 2), I = De(() => w.value / 8), z = De(() => I.value / 2), R = De(() => w.value / 3), O = De(() => ({ width: `${S.value}px`, height: `${S.value}px`, top: "0px", left: `calc(50% - ${S.value / 2}px)`, transform: `translateY(-${k.value}px)` })), V = De(() => ({ width: `${I.value}px`, height: `${I.value}px`, top: `calc(50% - ${I.value / 2}px)`, right: "0px", transform: `translateX(${z.value}px)` })), W = De(() => ({ width: `${I.value}px`, height: `${I.value}px`, bottom: "0px", left: `calc(50% - ${I.value / 2}px)`, transform: `translateY(${z.value}px)` })), N = De(() => ({ width: `${I.value}px`, height: `${I.value}px`, top: `calc(50% - ${I.value / 2}px)`, left: "0px", transform: `translateX(-${z.value}px)` })), K = De(() => ({ height: `${R.value}px`, width: "100%", top: `calc(50% - ${R.value / 2}px)`, fontSize: `${R.value}px`, lineHeight: `${R.value}px` })), Z = De(() => ({ width: `${w.value}px`, height: `${w.value}px` })), X = ["N", "E", "S", "W"], te = De(() => {
    const q = h.value > 0 ? h.value : 360 + h.value;
    return X[Math.round(q % 360 / 90) % 4];
  });
  return Tn(() => {
    const q = document.querySelector(".map-compass");
    q.onclick = () => {
      g("toggleTracking"), d.tracking || (h.value = 0);
    }, q && q.addEventListener("wheel", (he) => {
      if (d.tracking) return;
      he.preventDefault();
      const se = (h.value + he.deltaY * nz) % 360;
      h.value = Math.round(se >= 0 ? se : 360 + se);
    });
  }), (q, he) => (lt(), $t("div", { style: _i(o.value) }, [mt("div", { class: Wo(["map-compass", { "tracking-active": d.tracking }]), style: _i(Z.value) }, [mt("div", { class: "compass-panel", style: _i(p.value) }, [mt("div", { class: "pin north-pin", style: _i(O.value) }, null, 4), mt("div", { class: "pin east-pin", style: _i(V.value) }, null, 4), mt("div", { class: "pin south-pin", style: _i(W.value) }, null, 4), mt("div", { class: "pin west-pin", style: _i(N.value) }, null, 4)], 4), mt("span", { class: "compass-orientation-text", style: _i(K.value) }, Qt(te.value), 5)], 6)], 4));
} }), oz = jn(iz, [["__scopeId", "data-v-0f30b63f"]]), vi = [];
for (let a = 0; a < 256; ++a) vi.push((a + 256).toString(16).slice(1));
function sz(a, i = 0) {
  return (vi[a[i + 0]] + vi[a[i + 1]] + vi[a[i + 2]] + vi[a[i + 3]] + "-" + vi[a[i + 4]] + vi[a[i + 5]] + "-" + vi[a[i + 6]] + vi[a[i + 7]] + "-" + vi[a[i + 8]] + vi[a[i + 9]] + "-" + vi[a[i + 10]] + vi[a[i + 11]] + vi[a[i + 12]] + vi[a[i + 13]] + vi[a[i + 14]] + vi[a[i + 15]]).toLowerCase();
}
let Tm;
const az = new Uint8Array(16);
function lz() {
  if (!Tm) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Tm = crypto.getRandomValues.bind(crypto);
  }
  return Tm(az);
}
const cz = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), y0 = { randomUUID: cz };
function Td(a, i, l) {
  var _a3;
  if (y0.randomUUID && !a) return y0.randomUUID();
  a = a || {};
  const d = a.random ?? ((_a3 = a.rng) == null ? void 0 : _a3.call(a)) ?? lz();
  if (d.length < 16) throw new Error("Random bytes length must be >= 16");
  return d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, sz(d);
}
function Go() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function uz() {
  return { ...Go(), version: 1, signature: void 0 };
}
class Pl {
  constructor(i = Td(), l, d, h) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = i, this.routes = l || { id: Td(), meta: Go(), routes: [] }, this.drafts = d || { id: Td(), meta: Go(), drafts: [] }, this.meta = { ...uz(), ...h };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(i) {
    return new Pl(i.id, i.routes, i.drafts, i.meta);
  }
  clone() {
    return Pl.fromStorage(this.toStorage());
  }
  updateName(i) {
    this.meta.name = i, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(i) {
    this.meta.description = i, this.meta.modification_timestamp = Date.now();
  }
  addTag(i) {
    this.meta.tags.includes(i) || (this.meta.tags.push(i), this.meta.modification_timestamp = Date.now());
  }
  removeTag(i) {
    const l = this.meta.tags.indexOf(i);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class dz {
  constructor(i = [], l = Td(), d = Go()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = d || Go(), this.routesInternal = i;
  }
  get name() {
    return this.meta || (this.meta = Go()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Go()), this.meta.name = i;
  }
  get routes() {
    return js(this.routesInternal);
  }
  set routes(i) {
    this.routesInternal = js(i);
  }
  findRoute(i) {
    return this.routesInternal.find((l) => l.id === i);
  }
  existRoute(i) {
    return this.routesInternal.some((l) => l.id === i);
  }
  addRoute(i) {
    if (this.existRoute(i.id)) throw new Error(`[CartoSketch.Route] Route ${i.id} already exist`);
    this.routesInternal.push(js(i)), this.updateModificationTime();
  }
  updateRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${i.id} not found`);
    this.routesInternal[l] = js(i), this.updateModificationTime();
  }
  removeRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((i) => i.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((i) => i.exportToStorage()) });
  }
}
class Mm {
  constructor(i = Td(), l = [], d = {}, h) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = i, this.meta = { ...Go(), record_timespan: 0, ...h }, this.properties = d, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = Go()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Go()), this.meta.name = i;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(i) {
    this.meta.distance = i;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(i) {
    this.meta.record_timespan = i;
  }
  setPoints(i) {
    this.points = js(i), this.updateModificationTime();
  }
  appendPoint(i) {
    this.points.push(js(i)), this.updateModificationTime();
  }
  getPoints() {
    return js(this.points);
  }
  setProperties(i) {
    const l = js(i);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((i) => [i.longitude, i.latitude]) } };
  }
  exportToStorage() {
    return js({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var ln = ((a) => (a.MIGRATION_FAILED = "MIGRATION_FAILED", a.INVALID_VERSION = "INVALID_VERSION", a.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", a.ROLLBACK_FAILED = "ROLLBACK_FAILED", a.VALIDATION_FAILED = "VALIDATION_FAILED", a.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", a.DATA_CORRUPTION = "DATA_CORRUPTION", a))(ln || {});
class gn extends SC {
  constructor(i, l = "MIGRATION_FAILED", d) {
    super(i, d);
    __publicField(this, "code");
    __publicField(this, "domain", kC.GENERIC);
    this.code = l;
  }
}
class us extends gn {
  constructor(i, l = "INVALID_VERSION", d, h, g) {
    super(i, l, g), this.currentVersion = d, this.targetVersion = h;
  }
}
class Vr extends gn {
  constructor(i, l, d, h) {
    super(i, "VALIDATION_FAILED", h), this.field = l, this.value = d;
  }
}
class _0 extends gn {
  constructor(i, l, d) {
    super(i, "DATA_CORRUPTION", d), this.corruptedData = l;
  }
}
class hz extends gn {
  constructor(i, l, d, h) {
    super(i, "ROLLBACK_FAILED", h), this.originalError = l, this.rollbackError = d;
  }
}
class gd {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(i) {
    try {
      if (typeof i == "object" && i !== null && "version" in i) {
        const l = i.version;
        if (typeof l == "number" && l >= 0) return $n(l);
      }
      if (this.isRouteCollectionFormat(i)) return $n(0);
      if (this.isSketchArrayFormat(i)) return $n(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const d = l instanceof us ? l : new us(`Failed to extract version from data: ${l}`, ln.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static isRouteCollectionFormat(i) {
    return typeof i == "object" && i !== null && "routes" in i && !("sketches" in i) && Array.isArray(i.routes);
  }
  static isSketchArrayFormat(i) {
    return Array.isArray(i) && i.length > 0 && this.isSketchObject(i[0]);
  }
  static isSketchObject(i) {
    return typeof i == "object" && i !== null && "id" in i && "meta" in i && "routes" in i && "drafts" in i;
  }
  static validateVersion(i) {
    try {
      if (i < this.MIN_SUPPORTED_VERSION) throw new us(`Version ${i} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, ln.UNSUPPORTED_VERSION, i);
      if (i > this.CURRENT_VERSION) throw new us(`Version ${i} is above current version ${this.CURRENT_VERSION}`, ln.UNSUPPORTED_VERSION, i, this.CURRENT_VERSION);
      return $n(void 0);
    } catch (l) {
      const d = l instanceof us ? l : new us(`Version validation failed: ${l}`, ln.INVALID_VERSION, i, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static addVersionMetadata(i, l = this.CURRENT_VERSION) {
    return { ...i, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(i) {
    try {
      if (typeof i == "object" && i !== null && this.VERSION_KEY in i) {
        const l = i[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return $n(l);
      }
      return $n(null);
    } catch (l) {
      const d = l instanceof us ? l : new us(`Failed to extract version metadata: ${l}`, ln.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static isValidVersionInfo(i) {
    return typeof i == "object" && i !== null && "version" in i && "timestamp" in i && typeof i.version == "number" && typeof i.timestamp == "number";
  }
  static determineMigrationPath(i, l) {
    try {
      const d = this.validateVersion(i);
      if (d.isErr()) throw d.error;
      const h = this.validateVersion(l);
      if (h.isErr()) throw h.error;
      if (i === l) return $n([]);
      const g = [], p = i < l ? 1 : -1;
      for (let o = i; o !== l; o += p) g.push(o + p);
      return $n(g);
    } catch (d) {
      const h = d instanceof us ? d : new us(`Failed to determine migration path: ${d}`, ln.INVALID_VERSION, i, l, d instanceof Error ? d : new Error(String(d)));
      return Fr(h);
    }
  }
  static isMigrationNeeded(i) {
    return this.extractVersion(i).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(gd, "CURRENT_VERSION", 1);
__publicField(gd, "VERSION_KEY", "_data_version");
__publicField(gd, "MIN_SUPPORTED_VERSION", 0);
class Ns {
  static validateSketchData(i) {
    try {
      if (!i || typeof i != "object") throw new Vr("Sketch data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes", "drafts"];
      for (const g of d) if (!(g in l)) throw new Vr(`Missing required field: ${g}`, g, l[g]);
      if (typeof l.id != "string" || !l.id) throw new Vr("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new Vr("Sketch meta must be an object", "meta", l.meta);
      const h = this.validateRouteCollectionData(l.routes);
      if (h.isErr()) throw h.error;
      if (!l.drafts || typeof l.drafts != "object") throw new Vr("Sketch drafts must be an object", "drafts", l.drafts);
      return $n(l);
    } catch (l) {
      if (l instanceof Vr) return Fr(l);
      const d = new Vr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateRouteCollectionData(i) {
    try {
      if (!i || typeof i != "object") throw new Vr("Route collection data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes"];
      for (const h of d) if (!(h in l)) throw new Vr(`Missing required field: ${h}`, h, l[h]);
      if (typeof l.id != "string" || !l.id) throw new Vr("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new Vr("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new Vr("Routes must be an array", "routes", l.routes);
      for (let h = 0; h < l.routes.length; h++) {
        const g = l.routes[h], p = this.validateRouteItem(g);
        if (p.isErr()) throw new Vr(`Invalid route at index ${h}: ${p.error.message}`, `routes[${h}]`, g, p.error);
      }
      return $n(l);
    } catch (l) {
      if (l instanceof Vr) return Fr(l);
      const d = new Vr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateRouteItem(i) {
    try {
      if (!i || typeof i != "object") throw new Vr("Route item must be an object", "data", i);
      const l = i, d = ["id", "meta", "properties", "points"];
      for (const h of d) if (!(h in l)) throw new Vr(`Missing required field: ${h}`, h, l[h]);
      if (typeof l.id != "string" || !l.id) throw new Vr("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new Vr("Route points must be an array", "points", l.points);
      for (let h = 0; h < l.points.length; h++) {
        const g = l.points[h];
        if (!g || typeof g != "object") throw new Vr(`Route point at index ${h} must be an object`, `points[${h}]`, g);
        const p = g;
        if (typeof p.latitude != "number" || typeof p.longitude != "number") throw new Vr(`Route point at index ${h} must have numeric latitude and longitude`, `points[${h}]`, g);
      }
      return $n(l);
    } catch (l) {
      if (l instanceof Vr) return Fr(l);
      const d = new Vr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateSketchArray(i) {
    try {
      if (!Array.isArray(i)) throw new Vr("Sketch array must be an array", "data", i);
      if (i.length === 0) throw new Vr("Sketch array cannot be empty", "data.length", i.length);
      for (let l = 0; l < i.length; l++) {
        const d = i[l], h = this.validateSketchData(d);
        if (h.isErr()) throw new Vr(`Invalid sketch at index ${l}: ${h.error.message}`, `[${l}]`, d, h.error);
      }
      return $n(i);
    } catch (l) {
      if (l instanceof Vr) return Fr(l);
      const d = new Vr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateData(i, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(i);
      case "route-collection":
        return this.validateRouteCollectionData(i);
      case "sketch-array":
        return this.validateSketchArray(i);
      default:
        return Fr(new Vr(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(i, l) {
    try {
      const d = this.validateData(i, l);
      return d.isErr() ? Fr(new _0(`Data validation failed: ${d.error.message}`, i, d.error)) : $n({ isValid: true, errors: [], warnings: [] });
    } catch (d) {
      return Fr(new _0(`Data integrity check failed: ${d}`, i, d instanceof Error ? d : new Error(String(d))));
    }
  }
}
class pz {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(i) {
    try {
      const l = Ns.validateRouteCollectionData(i);
      if (l.isErr()) return Fr(new gn(`Invalid route collection data: ${l.error.message}`, ln.VALIDATION_FAILED, l.error));
      const d = l.value, h = new Pl();
      h.meta.name = d.meta.name || "Migrated Routes", h.meta.description = d.meta.description || "Migrated from route collection", h.meta.creation_timestamp = d.meta.creation_timestamp, h.meta.modification_timestamp = Date.now(), h.routes = d;
      const g = [h.toStorage()];
      return $n(g);
    } catch (l) {
      return Fr(new gn(`Route collection to sketch migration failed: ${l}`, ln.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(i) {
    try {
      const l = Ns.validateSketchArray(i);
      if (l.isErr()) return Fr(new gn(`Invalid sketch array data for rollback: ${l.error.message}`, ln.VALIDATION_FAILED, l.error));
      const d = l.value;
      if (d.length === 0) return Fr(new gn("Cannot rollback: empty sketch array", ln.MIGRATION_FAILED));
      const h = d[0];
      return $n(h.routes);
    } catch (l) {
      return Fr(new gn(`Route collection to sketch rollback failed: ${l}`, ln.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(i) {
    return Ns.validateRouteCollectionData(i).map(() => {
    }).mapErr((l) => new Vr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Ns.validateSketchArray(i).map(() => {
    }).mapErr((l) => new Vr(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class fz {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return Fr(new gn("Sketch V1 to V2 migration not yet implemented", ln.STRATEGY_NOT_FOUND));
  }
  validateBefore(i) {
    return Ns.validateSketchArray(i).map(() => {
    }).mapErr((l) => new Vr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Fr(new Vr("Sketch V2 validation not yet implemented", void 0, i));
  }
}
const _mz = class _mz {
  static register(i) {
    const l = this.getStrategyKey(i.fromVersion, i.toVersion);
    this.strategies.set(l, i);
  }
  static getStrategy(i, l) {
    const d = this.getStrategyKey(i, l), h = this.strategies.get(d);
    return h ? $n(h) : Fr(new gn(`No migration strategy found for version ${i} to ${l}`, ln.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(i, l) {
    const d = this.getStrategyKey(i, l);
    return this.strategies.has(d);
  }
  static getStrategyKey(i, l) {
    return `${i}->${l}`;
  }
};
__publicField(_mz, "strategies", /* @__PURE__ */ new Map());
_mz.register(new pz()), _mz.register(new fz());
let mz = _mz;
class gz {
  static createStrategy(i, l) {
    return mz.getStrategy(i, l);
  }
  static createStrategiesForPath(i) {
    try {
      const l = [];
      for (let d = 0; d < i.length; d++) {
        const h = d === 0 ? i[0] - 1 : i[d - 1], g = i[d], p = this.createStrategy(h, g);
        if (p.isErr()) return Fr(p.error);
        l.push(p.value);
      }
      return $n(l);
    } catch (l) {
      return Fr(new gn(`Failed to create strategies for migration path: ${l}`, ln.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class vz {
  static isMigrationNeeded(i) {
    return gd.isMigrationNeeded(i);
  }
  static getDataVersion(i) {
    return gd.extractVersion(i);
  }
  static migrateToCurrent(i, l = {}) {
    return this.migrateToVersion(i, gd.getCurrentVersion(), l);
  }
  static migrateToVersion(i, l, d = {}) {
    try {
      const h = { ...this.DEFAULT_OPTIONS, ...d }, g = gd.extractVersion(i);
      if (g.isErr()) return Fr(new gn(`Failed to extract current version: ${g.error.message}`, ln.INVALID_VERSION, g.error));
      const p = g.value;
      if (p === l) return $n({ data: i, fromVersion: p, toVersion: l, migratedVersions: [] });
      const o = gd.determineMigrationPath(p, l);
      if (o.isErr()) return Fr(new gn(`Failed to determine migration path: ${o.error.message}`, ln.INVALID_VERSION, o.error));
      const w = o.value, S = gz.createStrategiesForPath(w);
      if (S.isErr()) return Fr(S.error);
      const k = S.value;
      if (h.validateBefore) {
        const O = this.validateDataBeforeMigration(i, p);
        if (O.isErr()) return Fr(new gn(`Pre-migration validation failed: ${O.error.message}`, ln.VALIDATION_FAILED, O.error));
      }
      const I = h.enableRollback ? i : void 0;
      let z = i;
      const R = [];
      for (const O of k) {
        const V = this.executeMigrationWithRetry(O, z, h);
        if (V.isErr()) {
          if (h.enableRollback && I) {
            const W = this.rollbackToVersion(I);
            if (W.isErr()) return Fr(new hz(`Migration failed and rollback also failed: ${W.error.message}`, V.error, W.error));
          }
          return Fr(V.error);
        }
        z = V.value, R.push(O.toVersion);
      }
      if (h.validateAfter) {
        const O = this.validateDataAfterMigration(z, l);
        if (O.isErr()) return Fr(new gn(`Post-migration validation failed: ${O.error.message}`, ln.VALIDATION_FAILED, O.error));
      }
      return $n({ data: z, fromVersion: p, toVersion: l, migratedVersions: R, rollbackData: h.enableRollback ? I : void 0 });
    } catch (h) {
      return Fr(new gn(`Migration service error: ${h}`, ln.MIGRATION_FAILED, h instanceof Error ? h : new Error(String(h))));
    }
  }
  static executeMigrationWithRetry(i, l, d) {
    let h = null;
    for (let g = 0; g <= (d.maxRetries || 0); g++) {
      try {
        const p = i.migrate(l);
        if (p.isErr()) {
          h = p.error;
          continue;
        }
        if (i.validateAfter) {
          const o = i.validateAfter(p.value);
          if (o.isErr()) {
            h = new gn(`Post-migration validation failed: ${o.error.message}`, ln.VALIDATION_FAILED, o.error);
            continue;
          }
        }
        return $n(p.value);
      } catch (p) {
        h = new gn(`Migration attempt ${g + 1} failed: ${p}`, ln.MIGRATION_FAILED, p instanceof Error ? p : new Error(String(p)));
      }
      g < (d.maxRetries || 0) && d.retryDelay && console.warn(`Migration failed, retrying in ${d.retryDelay}ms...`);
    }
    return Fr(h || new gn("Migration failed after all retry attempts", ln.MIGRATION_FAILED));
  }
  static rollbackToVersion(i) {
    try {
      return $n(i);
    } catch (l) {
      return Fr(new gn(`Rollback failed: ${l}`, ln.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(i, l) {
    switch (l) {
      case 0:
        return Ns.validateRouteCollectionData(i).map(() => {
        }).mapErr((d) => new gn(`Route collection validation failed: ${d.message}`, ln.VALIDATION_FAILED, d));
      case 1:
        return Ns.validateSketchArray(i).map(() => {
        }).mapErr((d) => new gn(`Sketch array validation failed: ${d.message}`, ln.VALIDATION_FAILED, d));
      default:
        return Fr(new gn(`Unknown version for pre-migration validation: ${l}`, ln.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(i, l) {
    switch (l) {
      case 1:
        return Ns.validateSketchArray(i).map(() => {
        }).mapErr((d) => new gn(`Sketch array validation failed: ${d.message}`, ln.VALIDATION_FAILED, d));
      default:
        return Fr(new gn(`Unknown version for post-migration validation: ${l}`, ln.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(i, l) {
    return Ns.checkDataIntegrity(i, l);
  }
}
__publicField(vz, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const Fv = yv("sketches", () => {
  const a = Me([]), i = Me(null), l = Me(null), d = De(() => {
    if (!i.value) return null;
    const se = a.value.find((Q) => Q.id === i.value);
    return se ? new dz(se.routes.routes.map((Q) => new Mm(Q.id, Q.points, Q.properties, Q.meta)), se.routes.id, se.routes.meta) : null;
  }), h = De(() => d.value ? d.value.routes.map((se) => ({ id: se.id, name: se.name, points: se.getPoints(), meta: se.meta })) : []), g = De(() => i.value && a.value.find((se) => se.id === i.value) || null), p = De(() => g.value ? g.value.drafts.drafts : []);
  async function o() {
    const se = await xx("sketches");
    if (se) {
      const Q = vz.migrateToCurrent(se, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (Q.isErr()) {
        console.error("[SketchStore] Data migration failed:", Q.error), await w();
        return;
      }
      const oe = Q.value;
      oe.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${oe.fromVersion} to ${oe.toVersion}`), Array.isArray(oe.data) ? (a.value = oe.data.map((ve) => Pl.fromStorage(ve)), a.value.forEach((ve) => {
        ve.routes.routes.forEach(async (Be) => {
          if (Be.points.length > 1 && !Be.meta.distance) try {
            Be.meta.distance = await cm(Be.points);
          } catch (Ne) {
            console.warn("Failed to calculate route distance:", Ne), Be.meta.distance = 0;
          }
        });
      }), !i.value && a.value.length > 0 && (i.value = a.value[0].id)) : await w();
    } else await w();
  }
  async function w() {
    const se = new Pl();
    se.meta.name = "Default Sketch", a.value = [se], i.value = se.id, await mo("sketches", a.value.map((Q) => Q.toStorage())), await go();
  }
  async function S(se = "New Sketch") {
    const Q = new Pl();
    return Q.meta.name = se, a.value.push(Q), await mo("sketches", a.value.map((oe) => oe.toStorage())), await go(), Q;
  }
  async function k(se, Q) {
    const oe = a.value.find((ve) => ve.id === se);
    oe && (Q.name !== void 0 && oe.updateName(Q.name), Q.description !== void 0 && oe.updateDescription(Q.description), Q.tags !== void 0 && (oe.meta.tags.forEach((ve) => oe.removeTag(ve)), Q.tags.forEach((ve) => oe.addTag(ve))), await mo("sketches", a.value.map((ve) => ve.toStorage())), await go());
  }
  async function I(se) {
    const Q = a.value.findIndex((oe) => oe.id === se);
    Q !== -1 && (a.value.splice(Q, 1), i.value === se && (i.value = a.value.length > 0 ? a.value[0].id : null), await mo("sketches", a.value.map((oe) => oe.toStorage())), await go());
  }
  function z(se) {
    i.value = se, l.value = null;
  }
  async function R(se, Q = {}, oe = {}) {
    g.value || await w();
    const ve = new Mm(void 0, [], Q, oe);
    return ve.meta.name = se, g.value && g.value.routes.routes.push(ve.exportToStorage()), await mo("sketches", a.value.map((Be) => Be.toStorage())), await go(), ve;
  }
  async function O(se) {
    if (!g.value) return;
    const Q = g.value.routes.routes.findIndex((oe) => oe.id === se);
    Q !== -1 && (g.value.routes.routes.splice(Q, 1), l.value === se && (l.value = null), await mo("sketches", a.value.map((oe) => oe.toStorage())), await go());
  }
  async function V(se, Q) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((ve) => ve.id === se);
    if (oe) {
      if (oe.points.push(Q), oe.meta.modification_timestamp = Date.now(), oe.points.length > 1) try {
        if (oe.meta.distance) {
          const ve = await cm([oe.points[oe.points.length - 2], Q]);
          oe.meta.distance += ve;
        } else {
          const ve = await cm(oe.points);
          oe.meta.distance = ve;
        }
      } catch (ve) {
        console.warn("Failed to calculate route distance:", ve), oe.meta.distance || (oe.meta.distance = 0);
      }
      await mo("sketches", a.value.map((ve) => ve.toStorage())), await go();
    }
  }
  async function W(se, Q) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((ve) => ve.id === se);
    oe && (Q.meta !== void 0 && (oe.meta = { ...oe.meta, ...Q.meta }), Q.properties !== void 0 && (oe.properties = { ...oe.properties, ...Q.properties }), oe.meta.modification_timestamp = Date.now(), await mo("sketches", a.value.map((ve) => ve.toStorage())), await go());
  }
  async function N(se) {
    if (!g.value) return;
    const Q = g.value.routes.routes.find((oe) => oe.id === se);
    Q && (Q.points = [], Q.meta.modification_timestamp = Date.now(), await mo("sketches", a.value.map((oe) => oe.toStorage())), await go());
  }
  function K(se) {
    if (!g.value) return null;
    const Q = g.value.routes.routes.find((oe) => oe.id === se);
    return Q ? new Mm(Q.id, Q.points, Q.properties, Q.meta) : null;
  }
  function Z(se) {
    l.value = se;
  }
  async function X(se, Q = {}, oe = {}) {
    g.value || await w();
    const ve = { id: crypto.randomUUID(), meta: { ...Go(), ...oe }, shape: se, properties: Q };
    return g.value && g.value.drafts.drafts.push(ve), await mo("sketches", a.value.map((Be) => Be.toStorage())), await go(), ve;
  }
  async function te(se, Q) {
    if (!g.value) return;
    const oe = g.value.drafts.drafts.find((ve) => ve.id === se);
    oe && (Q.shape !== void 0 && (oe.shape = Q.shape), Q.properties !== void 0 && (oe.properties = { ...oe.properties, ...Q.properties }), Q.meta !== void 0 && (oe.meta = { ...oe.meta, ...Q.meta }, oe.meta.modification_timestamp = Date.now()), await mo("sketches", a.value.map((ve) => ve.toStorage())), await go());
  }
  async function q(se) {
    if (!g.value) return;
    const Q = g.value.drafts.drafts.findIndex((oe) => oe.id === se);
    Q !== -1 && (g.value.drafts.drafts.splice(Q, 1), await mo("sketches", a.value.map((oe) => oe.toStorage())), await go());
  }
  function he(se) {
    return g.value && g.value.drafts.drafts.find((Q) => Q.id === se) || null;
  }
  return { sketches: a, currentSketchId: i, currentRouteId: l, routeCollection: d, routes: h, currentSketch: g, currentDrafts: p, init: o, createSketch: S, updateSketch: k, deleteSketch: I, setCurrentSketchId: z, addRoute: R, deleteRoute: O, addPointToRoute: V, updateRoute: W, clearRoutePoints: N, getRouteById: K, setCurrentRouteId: Z, addDraft: X, updateDraft: te, deleteDraft: q, getDraftById: he };
}), N1 = yv("routes", () => {
  const a = Fv(), i = De(() => a.routeCollection), l = De({ get: () => a.currentRouteId, set: (q) => a.setCurrentRouteId(q) }), d = Me(0);
  Kt(l, (q) => {
    var _a3, _b2;
    q && (d.value = ((_b2 = (_a3 = a.getRouteById(q)) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const h = Me(false), g = Me(-1), p = Me(null);
  let o;
  const w = De(() => a.routes);
  function S(q) {
    p.value = q;
  }
  async function k() {
    await a.init();
  }
  async function I(q, he = {}) {
    return await a.addRoute(q, he);
  }
  async function z(q) {
    await a.deleteRoute(q);
  }
  async function R(q, he) {
    await a.addPointToRoute(q, he);
  }
  async function O(q, he) {
    await a.updateRoute(q, he);
  }
  async function V(q) {
    await a.clearRoutePoints(q);
  }
  function W(q) {
    return a.getRouteById(q);
  }
  function N(q) {
    a.setCurrentRouteId(q);
  }
  function K(q) {
    h.value || !p.value || (h.value = true, q && R(l.value, q), g.value = p.value.addLocationListener((he) => {
      l.value && R(l.value, he);
    }), a.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), o = setInterval(async () => {
      const he = a.getRouteById(l.value);
      he.recordTimespan !== void 0 && he.meta.modification_timestamp && (d.value = he.recordTimespan + (Date.now() - he.meta.modification_timestamp), await a.updateRoute(l.value, { meta: { record_timespan: d.value } }));
    }, 100));
  }
  function Z() {
    !h.value || !p.value || (g.value !== -1 && (p.value.removeLocationListener(g.value), g.value = -1), o && (clearTimeout(o), o = void 0), h.value = false);
  }
  async function X(q) {
    try {
      if (!p.value) throw new Error("Geolocation service not available");
      if (h.value) Z();
      else if (l.value) K();
      else {
        const he = await I(q("trackerView.nameNewRoute"));
        N(he.id), K(p.value.getLastKnownLocation());
      }
    } catch (he) {
      throw console.error(he), he;
    }
  }
  function te() {
    g.value !== -1 && p.value && (p.value.removeLocationListener(g.value), g.value = -1), h.value = false;
  }
  return { routeCollection: i, routes: w, currentRouteId: l, isRecording: h, watchingHandler: g, currentRouteRecordTimespan: d, setLocator: S, init: k, addRoute: I, deleteRoute: z, addPointToRoute: R, updateRoute: O, clearRoutePoints: V, getRouteById: W, setCurrentRouteId: N, startRecording: K, stopRecording: Z, toggleRecording: X, cleanup: te };
}), yz = { class: "upload-container" }, _z = { class: "action-buttons" }, bz = ot({ __name: "TextFileUploaderDialog", props: Zs({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: Zs(["update:value", "confirm"], ["update:show"]), setup(a, { emit: i }) {
  const l = Zp(), d = a, h = i, g = Zc(a, "show");
  let p = [];
  const o = (k) => {
    p = [];
    for (const I of k) {
      const z = I.file;
      if (z) if (d.types.includes(z.type)) {
        const R = new FileReader();
        R.onload = (O) => {
          var _a3;
          ((_a3 = O.target) == null ? void 0 : _a3.result) && p.push(O.target.result), p.length === k.length && h("update:value", p);
        }, R.readAsText(z);
      } else l.warning(`Skipped file ${I.name} due to unsupported type ${z.type}`);
    }
  }, w = () => {
    h("confirm", p), g.value = false;
  }, S = (k) => {
    var _a3, _b2;
    return d.types.includes(((_a3 = k.file.file) == null ? void 0 : _a3.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = k.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${d.types.join("', '")}']`), false);
  };
  return (k, I) => (lt(), gr(Y(zd), { show: g.value, "onUpdate:show": I[2] || (I[2] = (z) => g.value = z), preset: "dialog", title: "Dialog" }, { header: $e(() => [...I[3] || (I[3] = [Cr(" File Upload ", -1)])]), default: $e(() => [mt("div", yz, [Re(Y(FR), { multiple: d.multiple ?? false, onChange: I[0] || (I[0] = ({ fileList: z }) => o(z)), onBeforeUpload: S }, { default: $e(() => [Re(Y(T1), null, { default: $e(() => [Re(Y(xn), { size: 36, name: "upload", class: "upload-icon" }, { default: $e(() => [(lt(), gr(eu(d.icon ?? Y(Vx))))]), _: 1 }), mt("div", null, Qt(d.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: $e(() => [mt("div", _z, [Re(Y(jr), { onClick: I[1] || (I[1] = (z) => g.value = false) }, { default: $e(() => [...I[4] || (I[4] = [Cr(" Cancel ", -1)])]), _: 1 }), Re(Y(jr), { type: "primary", onClick: w }, { default: $e(() => [...I[5] || (I[5] = [Cr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), xz = jn(bz, [["__scopeId", "data-v-14c5a0c1"]]), wz = ot({ __name: "MglDrawer", props: Zs({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: Zs(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(a, { emit: i }) {
  Pa((z) => ({ a1b7bba2: Y(h).modalColor, "305889d2": Y(h).borderRadius, "60287bc6": k.value, "048a7f4c": S.value }));
  const l = a, d = i, h = Sa(), g = PC("route-drawer"), p = De(() => l.position || "left"), o = De(() => {
    var _a3, _b2, _c, _d2;
    return Math.min(Kg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d2 = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d2.clientWidth) ?? 1 / 0) - 48);
  }), w = De(() => {
    var _a3, _b2, _c, _d2;
    return Math.min(Kg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d2 = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d2.clientHeight) ?? 1 / 0) - 48);
  }), S = De(() => p.value === "left" ? `${-16 - o.value}px` : p.value === "right" ? `${16 + o.value}px` : p.value === "top" ? `${-16 - w.value}px` : p.value === "bottom" ? `${16 + w.value}px` : "0px"), k = De(() => p.value === "left" || p.value === "right" ? `${o.value}px` : `${w.value}px`), I = Zc(a, "show");
  return Kt(o, () => d("update:width", o.value)), Kt(w, () => d("update:height", w.value)), (z, R) => (lt(), gr(Ro, { name: `slide-${p.value}` }, { default: $e(() => [fs(mt("div", { ref: "route-drawer", class: Wo(["route-drawer", `route-drawer--${p.value}`]), onClick: R[0] || (R[0] = (O) => d("click", O)), onContextmenu: R[1] || (R[1] = (O) => d("contextmenu", O)) }, [Dp(z.$slots, "default", {}, void 0, true)], 34), [[Gs, I.value]])]), _: 3 }, 8, ["name"]));
} }), Cz = jn(wz, [["__scopeId", "data-v-72b274a7"]]), Sz = { class: "menu-list" }, kz = ["onClick", "onContextmenu", "onTouchstart"], Pz = { class: "swipe-container" }, Tz = { style: { height: "fit-content", padding: "8px 12px" } }, Mz = ["onClick"], Iz = { style: { padding: "16px" } }, Ez = 120, Rz = 40, zz = ot({ __name: "SelectableSwipeableMenuList", props: Zs({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: Zs(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(a, { emit: i }) {
  Pa((X) => ({ af602246: Y(p).hoverColor, "2c598f52": Y(p).primaryColor, f032366a: Y(p).bodyColor, "6ce963b2": o.value }));
  const l = a, d = Zc(a, "selection"), h = Zc(a, "multipleSelection"), g = i, p = Sa(), o = Me("0s"), w = Me({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), S = Me(false), k = Me(0), I = Me(0), z = Me(null);
  function R(X, te) {
    w.value.activeId !== te && N();
    const q = X.touches[0];
    w.value = { startX: q.clientX, delta: w.value.delta ?? 0, currentX: q.clientX, containerWidth: X.currentTarget.offsetWidth, activeId: te, leftMax: Ez, rightMax: Rz };
  }
  function O(X) {
    w.value.activeId && (w.value.currentX = X.touches[0].clientX, w.value.delta += w.value.currentX - w.value.startX, w.value.delta = Kg(w.value.delta, -w.value.leftMax, w.value.rightMax), w.value.startX = X.touches[0].clientX);
  }
  function V() {
    if (!w.value.activeId) return;
    o.value = `${Math.abs(w.value.delta) / w.value.containerWidth * 0.3}s`, setTimeout(() => {
      o.value = "0s";
    }, 300);
    const X = w.value.delta < 0 ? w.value.leftMax : w.value.rightMax;
    w.value.delta = Math.abs(w.value.delta) > X * 0.4 ? Math.sign(w.value.delta) * X : 0, w.value.delta === 0 && Math.abs(w.value.delta) < 5;
  }
  function W(X, te) {
    X.stopPropagation(), !(w.value.delta > 5) && (N(), d.value !== te.id && (d.value = te.id));
  }
  function N() {
    w.value.delta > 0 || (w.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function K(X, te) {
    if (X.stopPropagation(), X.preventDefault(), S.value) {
      S.value = false;
      return;
    }
    z.value = te, k.value = X.clientX, I.value = X.clientY, S.value = true, g("contextmenu", X, te);
  }
  function Z(X) {
    const te = [...h.value];
    if (te.includes(X)) {
      const q = te.indexOf(X);
      te.splice(q, 1);
    } else te.push(X);
    h.value = te;
  }
  return (X, te) => (lt(), $t(qr, null, [mt("div", Sz, [(lt(true), $t(qr, null, ti(l.items, (q) => (lt(), $t("div", { key: q.id, class: Wo(["menu-list-item", ...q.id === d.value ? ["active"] : []]), style: _i({ "touch-action": w.value.activeId === q.id ? "pan-y" : "auto" }), onClick: (he) => W(he, q), onContextmenu: Id((he) => K(he, q), ["prevent"]), onTouchstart: (he) => R(he, q.id), onTouchmove: O, onTouchend: V }, [mt("div", Pz, [mt("div", { class: "content-col", style: _i({ transform: `translateX(${w.value.activeId === q.id || w.value.delta > 0 ? w.value.delta : 0}px)`, willChange: w.value.activeId === q.id ? "transform" : "auto", flexDirection: w.value.delta >= 0 || w.value.activeId !== q.id ? "row" : "row-reverse" }) }, [Dp(X.$slots, "item", { item: q }, () => [mt("div", Tz, [mt("div", null, Qt(q.name ?? "Untitled"), 1)])], true)], 4), mt("div", { class: "actions-col", style: _i({ width: `${w.value.activeId === q.id && w.value.delta < 0 ? -w.value.delta : 0}px`, visibility: w.value.activeId === q.id && w.value.delta < 0 ? "visible" : "hidden", willChange: w.value.activeId === q.id ? "width" : "auto" }) }, [(lt(true), $t(qr, null, ti(l.swipeActions, (he) => (lt(), $t("button", { key: he.name, class: "menu-action", style: _i({ background: he.color || Y(p).primaryColorSuppl }), onClick: () => {
    he.action(q.id), w.value.activeId = null;
  } }, Qt(he.label), 13, Mz))), 128))], 4), mt("div", { class: "select-col", style: _i({ width: `${w.value.delta > 0 ? w.value.delta : 0}px`, backgroundColor: d.value === q.id ? Y(p).primaryColor : "transparent", visibility: w.value.delta > 0 ? "visible" : "hidden" }) }, [mt("div", Iz, [Re(Y(CM), { checked: h.value.includes(q.id), style: _i({ border: d.value === q.id ? `1px solid ${Y(p).bodyColor}` : "none", BorderRadius: d.value === q.id ? Y(p).borderRadiusSmall : "none" }), "onUpdate:checked": () => Z(q.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, kz))), 128))]), Re(Y(wx), { show: S.value, x: k.value, y: I.value, options: l.menuOptions.map((q) => {
    var _a3;
    return { ...q, label: ((_a3 = q.label) == null ? void 0 : _a3.value) ?? q.label };
  }), placement: "bottom-start", trigger: "manual", onClick: te[0] || (te[0] = (q) => S.value = false), onClickoutside: te[1] || (te[1] = (q) => S.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), Az = jn(zz, [["__scopeId", "data-v-b353d352"]]), Dz = { class: "drawer-floating" }, Fz = { class: "drawer-container" }, Lz = { class: "drawer-header" }, Bz = { class: "drawer-title" }, Oz = { class: "drawer-content" }, $z = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, jz = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, Nz = { key: 0 }, Vz = ot({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: Zs(["update:width"], ["update:show"]), setup(a, { emit: i }) {
  Pa((se) => ({ "38b2b83c": Y(w).borderRadius, "3ddcb48b": Y(w).hoverColor, "485009dd": Y(w).primaryColorPressed, "4f454a85": Y(w).primaryColor, "73f3b15d": Y(w).bodyColor }));
  const d = new ru().isMobile, { t: h } = Ri(), g = l1(), p = i, o = N1(), w = Sa(), S = Zc(a, "show"), k = Me(false), I = Me(0), z = Me(0), R = Me(null), O = Me(false), V = Me(""), W = Me(null), N = [{ label: De(() => h("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    k.value = false, o.addRoute(h("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], K = [{ label: De(() => h("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a3;
    ((_a3 = R.value) == null ? void 0 : _a3.id) && (V.value = R.value.name || "", O.value = true);
  } } }, { label: De(() => h("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    R.value && o.deleteRoute(R.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...N], Z = [{ label: De(() => h("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (se) => {
    const Q = o.routes.find((oe) => oe.id === se);
    W.value = se, V.value = (Q == null ? void 0 : Q.name) || "", O.value = true;
  } }, { label: De(() => h("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (se) => o.deleteRoute(se), color: w.value.errorColorSuppl }];
  function X(se) {
    if (se.stopPropagation(), se.preventDefault(), W.value = o.currentRouteId, k.value) {
      k.value = false;
      return;
    }
    I.value = se.clientX, z.value = se.clientY, k.value = true;
  }
  async function te(se) {
    V.value.trim() && (await o.updateRoute(se, { meta: { name: V.value.trim() } }), O.value = false);
  }
  const q = Me([]);
  function he() {
    g.warning({ title: h("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: h("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: h("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: h("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      q.value.forEach((se) => {
        o.deleteRoute(se), q.value = q.value.filter((Q) => Q !== se);
      });
    } });
  }
  return (se, Q) => (lt(), $t(qr, null, [Re(Cz, { show: S.value, "onUpdate:show": Q[3] || (Q[3] = (oe) => S.value = oe), position: Y(d) ? "bottom" : "left", onClick: Q[4] || (Q[4] = () => Y(o).currentRouteId = null), "onUpdate:width": Q[5] || (Q[5] = (oe) => p("update:width", oe)), onContextmenu: Q[6] || (Q[6] = (oe) => X(oe)) }, { default: $e(() => [mt("div", Dz, [Y(d) && S.value ? Dp(se.$slots, "bottom-floating", { key: 0 }, void 0, true) : Pr("", true)]), mt("div", Fz, [mt("div", Lz, [mt("p", Bz, Qt(Y(h)("components.trackerViewRouteDrawer.routes")), 1), q.value.length > 0 ? (lt(), gr(Y(jr), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: he }, { icon: $e(() => [Re(Y(xn), { component: Y(qp) }, null, 8, ["component"])]), _: 1 })) : Pr("", true)]), mt("div", Oz, [Re(Az, { selection: Y(o).currentRouteId, "onUpdate:selection": Q[0] || (Q[0] = (oe) => Y(o).currentRouteId = oe), "multiple-selection": q.value, "onUpdate:multipleSelection": Q[1] || (Q[1] = (oe) => q.value = oe), items: Y(o).routes, "menu-options": K, "swipe-actions": Z, onContextmenu: Q[2] || (Q[2] = (oe, ve) => {
    W.value = (ve == null ? void 0 : ve.id) ?? null, R.value = ve ?? null;
  }) }, { item: $e(({ item: oe }) => {
    var _a3;
    return [mt("div", $z, [mt("div", null, Qt(oe.name ?? Y(h)("components.trackerViewRouteDrawer.nameNewRoute")), 1), mt("div", jz, [mt("div", null, Qt(Y(h)("components.trackerViewRouteDrawer.points", { num: oe.points.length })), 1), oe.points.length > 1 && ((_a3 = oe.meta) == null ? void 0 : _a3.distance) ? (lt(), $t("div", Nz, Qt(Y(h)("components.trackerViewRouteDrawer.distance", { distance: Y(TC)(oe.meta.distance) })), 1)) : Pr("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), Re(Y(wx), { show: k.value, x: I.value, y: z.value, options: N.map((oe) => ({ ...oe, label: oe.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: Q[7] || (Q[7] = (oe) => k.value = false) }, null, 8, ["show", "x", "y", "options"]), Re(Y(zd), { show: O.value, "onUpdate:show": Q[10] || (Q[10] = (oe) => O.value = oe), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: Q[11] || (Q[11] = () => {
    W.value && te(W.value);
  }) }, { default: $e(() => [Re(Y(yo), { value: V.value, "onUpdate:value": Q[8] || (Q[8] = (oe) => V.value = oe), placeholder: "Enter new route name", onKeyup: Q[9] || (Q[9] = Jb(() => {
    W.value && te(W.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), Uz = jn(Vz, [["__scopeId", "data-v-a6ce157e"]]), V1 = yv("map", () => {
  const a = Me(7), i = Me([0, 0]), l = Me(0), d = Me(0), h = Me(false);
  async function g() {
    const z = await xx("mapState");
    z && (a.value = z.zoom, i.value = z.center, l.value = z.bearing, h.value = z.isTrackingOrientation, d.value = z.lastUpdateTime);
  }
  async function p() {
    d.value = Date.now();
    const z = { zoom: a.value, center: i.value, bearing: l.value, isTrackingOrientation: h.value, lastUpdateTime: d.value };
    await mo("mapState", JSON.parse(JSON.stringify(z))), await go();
  }
  function o(z) {
    a.value = z;
  }
  function w(z) {
    i.value = z.toLngLatLike();
  }
  function S(z) {
    l.value = z;
  }
  function k(z) {
    h.value = z;
  }
  function I() {
    a.value = 7, i.value = [0, 0], l.value = 0, h.value = false;
  }
  return Kt([a, i, l, h], p, { deep: true }), { zoom: a, center: i, bearing: l, isTrackingOrientation: h, lastUpdateTime: d, init: g, save: p, setZoom: o, setCenter: w, setBearing: S, setTrackingOrientation: k, resetToDefault: I };
});
function qz() {
  for (const a of Ca.handlers) a.callback(360 - Ca.bearing);
}
var Ca;
((a) => {
  a.bearing = 0;
  let i = false;
  a.handlers = [];
  function l(p) {
    if (!(jk(p.alpha) || typeof p.webkitCompassHeading < "u")) {
      g();
      return;
    }
    a.bearing = p.alpha, typeof p.webkitCompassHeading < "u" && (a.bearing = p.webkitCompassHeading), qz();
  }
  a.updater = l;
  function d(p) {
    const o = a.handlers.length > 0 ? a.handlers[a.handlers.length - 1].id + 1 : 0;
    return a.handlers.push({ callback: p, id: o }), o;
  }
  a.addHandler = d;
  function h() {
    i || (window.addEventListener("deviceorientation", l, true), i = true);
  }
  a.start = h;
  function g() {
    i && (window.removeEventListener("deviceorientation", l, true), i = false);
  }
  a.stop = g;
})(Ca || (Ca = {}));
function xi() {
  return xi = Object.assign ? Object.assign.bind() : function(a) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) ({}).hasOwnProperty.call(l, d) && (a[d] = l[d]);
    }
    return a;
  }, xi.apply(null, arguments);
}
var Ii;
(function(a) {
  a.Commit = "commit", a.Provisional = "provisional", a.Finish = "finish";
})(Ii || (Ii = {}));
const bi = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, dv = "currentlyDrawing", Md = "edited", hv = "closingPoint", U1 = "snappingPoint", pv = "coordinatePoint", Gz = "coordinatePointFeatureId", Ep = "coordinatePointIds", wp = 10;
function Im(a) {
  return !!(a && typeof a == "object" && a !== null && !Array.isArray(a));
}
function b0(a) {
  return !!(a && typeof a == "object" && "properties" in a && typeof a.properties == "object" && a.properties !== null && "mode" in a.properties);
}
function x0(a) {
  return !!(function(i) {
    return typeof i == "number" && !isNaN(new Date(i).valueOf());
  })(a);
}
const Wz = "Feature mode property does not match the mode being added to";
var Yc;
(function(a) {
  a.Drawing = "drawing", a.Select = "select", a.Static = "static", a.Render = "render";
})(Yc || (Yc = {}));
const Zz = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class Kp {
  get state() {
    return this._state;
  }
  set state(i) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(i) {
    if (typeof i != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = i;
  }
  registerBehaviors(i) {
  }
  constructor(i, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = Zz, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = Yc.Drawing, this.mode = "base", l || this.updateOptions(i);
  }
  updateOptions(i) {
    i != null && i.styles && (this.styles = xi({}, this._styles, i.styles)), i != null && i.pointerDistance && (this.pointerDistance = i.pointerDistance), i != null && i.validation && (this.validate = i && i.validation), i != null && i.projection && (this.projection = i.projection), (i == null ? void 0 : i.pointerEvents) !== void 0 && (this.pointerEvents = i.pointerEvents);
  }
  allowPointerEvent(i, l) {
    return typeof i == "boolean" ? i : typeof i != "function" || i(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(i) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = i.store, this.store.registerOnChange(i.onChange), this.setDoubleClickToZoom = i.setDoubleClickToZoom, this.project = i.project, this.unproject = i.unproject, this.onSelect = i.onSelect, this.onDeselect = i.onDeselect, this.setCursor = i.setCursor, this.onStyleChange = i.onChange, this.onFinish = i.onFinish, this.coordinatePrecision = i.coordinatePrecision, this.registerBehaviors({ mode: i.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: i.coordinatePrecision, projection: this.projection });
  }
  validateFeature(i) {
    return this.performFeatureValidation(i);
  }
  afterFeatureAdded(i) {
  }
  afterFeatureUpdated(i) {
  }
  performFeatureValidation(i) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(d, h) {
      let g;
      if (Im(d)) if (d.id == null) g = "Feature has no id";
      else if (typeof d.id != "string" && typeof d.id != "number") g = "Feature must be string or number as per GeoJSON spec";
      else if (h(d.id)) if (Im(d.geometry)) if (Im(d.properties)) if (typeof d.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(d.geometry.type)) if (Array.isArray(d.geometry.coordinates)) {
        if (!d.properties.mode || typeof d.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else g = "Feature coordinates is not an array";
      else g = "Feature is not Point, LineString or Polygon";
      else g = "Feature has no properties";
      else g = "Feature has no geometry";
      else g = "Feature must match the id strategy (default is UUID4)";
      else g = "Feature is not object";
      return g ? { valid: false, reason: g } : { valid: true };
    })(i, this.store.idStrategy.isValidId);
    if (this.validate) {
      const d = this.validate(i, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Provisional });
      return { valid: l.valid && d.valid, reason: d.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(i, l) {
    const d = this.performFeatureValidation(i);
    return d.valid ? i.properties.mode !== this.mode ? { valid: false, reason: Wz } : l(i) : { valid: false, reason: d.reason };
  }
  onFinish(i, l) {
  }
  onDeselect(i) {
  }
  onSelect(i) {
  }
  onKeyDown(i) {
  }
  onKeyUp(i) {
  }
  onMouseMove(i) {
  }
  onClick(i) {
  }
  onDragStart(i, l) {
  }
  onDrag(i, l) {
  }
  onDragEnd(i, l) {
  }
  getHexColorStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getNumericStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getStylingValue(i, l, d) {
    return i === void 0 ? l : typeof i == "function" ? i(d) : i;
  }
}
class Hz extends Kp {
  constructor(...i) {
    super(...i), this.type = Yc.Select;
  }
}
function ka(a, i) {
  const l = (S) => S * Math.PI / 180, d = l(a[1]), h = l(a[0]), g = l(i[1]), p = g - d, o = l(i[0]) - h, w = Math.sin(p / 2) * Math.sin(p / 2) + Math.cos(d) * Math.cos(g) * Math.sin(o / 2) * Math.sin(o / 2);
  return 2 * Math.atan2(Math.sqrt(w), Math.sqrt(1 - w)) * 6371e3 / 1e3;
}
const q1 = 63710088e-1;
function Yi(a) {
  return a % 360 * Math.PI / 180;
}
function Xz(a) {
  return a / 6371.0088;
}
function Kc(a) {
  return a % (2 * Math.PI) * 180 / Math.PI;
}
function Dn(a, i = 9) {
  const l = Math.pow(10, i);
  return Math.round(a * l) / l;
}
const w0 = 57.29577951308232, C0 = 0.017453292519943295, Rp = 6378137, An = (a, i) => ({ x: a === 0 ? 0 : a * C0 * Rp, y: i === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + i * C0 / 2)) * Rp }), Jc = (a, i) => ({ lng: a === 0 ? 0 : w0 * (a / Rp), lat: i === 0 ? 0 : (2 * Math.atan(Math.exp(i / Rp)) - Math.PI / 2) * w0 });
function Yz(a) {
  let i;
  if (a.geometry.type === "Polygon") i = a.geometry.coordinates;
  else {
    if (a.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    i = [a.geometry.coordinates];
  }
  const l = [];
  for (let g = 0; g < i.length; g++) for (let p = 0; p < i[g].length - 1; p++) for (let o = 0; o < i.length; o++) for (let w = 0; w < i[o].length - 1; w++) h(g, p, o, w);
  return l.length > 0;
  function d(g) {
    return g < 0 || g > 1;
  }
  function h(g, p, o, w) {
    const S = i[g][p], k = i[g][p + 1], I = i[o][w], z = i[o][w + 1], R = (function(W, N, K, Z) {
      if (ap(W, K) || ap(W, Z) || ap(N, K) || ap(Z, K)) return null;
      const X = W[0], te = W[1], q = N[0], he = N[1], se = K[0], Q = K[1], oe = Z[0], ve = Z[1], Be = (X - q) * (Q - ve) - (te - he) * (se - oe);
      return Be === 0 ? null : [((X * he - te * q) * (se - oe) - (X - q) * (se * ve - Q * oe)) / Be, ((X * he - te * q) * (Q - ve) - (te - he) * (se * ve - Q * oe)) / Be];
    })(S, k, I, z);
    if (R === null) return;
    let O, V;
    O = k[0] !== S[0] ? (R[0] - S[0]) / (k[0] - S[0]) : (R[1] - S[1]) / (k[1] - S[1]), V = z[0] !== I[0] ? (R[0] - I[0]) / (z[0] - I[0]) : (R[1] - I[1]) / (z[1] - I[1]), d(O) || d(V) || (R.toString(), l.push(R));
  }
}
function ap(a, i) {
  return a[0] === i[0] && a[1] === i[1];
}
function Lv(a, i) {
  return S0(a[0]) <= i && S0(a[1]) <= i;
}
function G1(a) {
  return a.length === 2 && typeof a[0] == "number" && typeof a[1] == "number" && a[0] !== 1 / 0 && a[1] !== 1 / 0 && (l = a[0]) >= -180 && l <= 180 && (i = a[1]) >= -90 && i <= 90;
  var i, l;
}
function S0(a) {
  let i = 1, l = 0;
  for (; Math.round(a * i) / i !== a; ) i *= 10, l++;
  return l;
}
const Us = (a, i) => {
  const { x: l, y: d } = a, { x: h, y: g } = i, p = h - l, o = g - d;
  return Math.sqrt(o * o + p * p);
};
class Ki {
  constructor({ store: i, mode: l, project: d, unproject: h, pointerDistance: g, coordinatePrecision: p, projection: o }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = i, this.mode = l, this.project = d, this.unproject = h, this.pointerDistance = g, this.coordinatePrecision = p, this.projection = o;
  }
}
function W1({ unproject: a, point: i, pointerDistance: l }) {
  const d = l / 2, { x: h, y: g } = i;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[a(h - d, g - d), a(h + d, g - d), a(h + d, g + d), a(h - d, g + d), a(h - d, g - d)].map((p) => [p.lng, p.lat])] } };
}
let zp = class extends Ki {
  constructor(i) {
    super(i);
  }
  create(i) {
    const { containerX: l, containerY: d } = i;
    return W1({ unproject: this.unproject, point: { x: l, y: d }, pointerDistance: this.pointerDistance });
  }
};
class Ap extends Ki {
  constructor(i) {
    super(i);
  }
  measure(i, l) {
    const { x: d, y: h } = this.project(l[0], l[1]);
    return Us({ x: d, y: h }, { x: i.containerX, y: i.containerY });
  }
}
class fv extends Ki {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (h) => this.getSnappable(h, (g) => !!(g.properties && g.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (h, g) => this.getSnappable(h, (p) => !!(p.properties && p.properties.mode === this.mode && p.id !== g)).coordinate, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), h = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return h.forEach((p) => {
      let o;
      if (p.geometry.type === "Polygon") o = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        o = p.geometry.coordinates;
      }
      o.forEach((w, S) => {
        const k = this.pixelDistance.measure(i, w);
        k < g.minDist && k < this.pointerDistance && (g.coordinate = w, g.minDist = k, g.featureId = p.id, g.featureCoordinateIndex = S);
      });
    }), g;
  }
}
function k0(a, i, l) {
  const d = Yi(a[0]), h = Yi(a[1]), g = Yi(l), p = Xz(i), o = Math.asin(Math.sin(h) * Math.cos(p) + Math.cos(h) * Math.sin(p) * Math.cos(g));
  return [Kc(d + Math.atan2(Math.sin(g) * Math.sin(p) * Math.cos(h), Math.cos(p) - Math.sin(h) * Math.sin(o))), Kc(o)];
}
function P0(a, i) {
  const l = Yi(a[0]), d = Yi(i[0]), h = Yi(a[1]), g = Yi(i[1]), p = Math.sin(d - l) * Math.cos(g), o = Math.cos(h) * Math.sin(g) - Math.sin(h) * Math.cos(g) * Math.cos(d - l);
  return Kc(Math.atan2(p, o));
}
function Kz({ x: a, y: i }, { x: l, y: d }) {
  const h = l - a, g = d - i;
  if (h === 0 && g === 0) return 0;
  let p = Math.atan2(g, h);
  return p *= 180 / Math.PI, p > 180 ? p -= 360 : p < -180 && (p += 360), p;
}
function Jz(a, i, l) {
  const d = [], h = a.length;
  let g, p, o, w = 0;
  for (let k = 0; k < a.length && !(i >= w && k === a.length - 1); k++) {
    if (w > i && d.length === 0) {
      if (g = i - w, !g) return d.push(a[k]), d;
      p = P0(a[k], a[k - 1]) - 180, o = k0(a[k], g, p), d.push(o);
    }
    if (w >= l) return g = l - w, g ? (p = P0(a[k], a[k - 1]) - 180, o = k0(a[k], g, p), d.push(o), d) : (d.push(a[k]), d);
    if (w >= i && d.push(a[k]), k === a.length - 1) return d;
    w += ka(a[k], a[k + 1]);
  }
  if (w < i && a.length === h) throw new Error("Start position is beyond line");
  const S = a[a.length - 1];
  return [S, S];
}
function lp(a) {
  return a * (Math.PI / 180);
}
function T0(a) {
  return a * (180 / Math.PI);
}
class Qz extends Ki {
  constructor(i) {
    super(i), this.config = void 0, this.config = i;
  }
  generateInsertionCoordinates(i, l, d) {
    const h = [i, l];
    let g = 0;
    for (let S = 0; S < h.length - 1; S++) g += ka(h[0], h[1]);
    if (g <= d) return h;
    let p = g / d - 1;
    Number.isInteger(p) || (p = Math.floor(p) + 1);
    const o = [];
    for (let S = 0; S < p; S++) {
      const k = Jz(h, d * S, d * (S + 1));
      o.push(k);
    }
    const w = [];
    for (let S = 0; S < o.length; S++) w.push(o[S][1]);
    return this.limitCoordinates(w);
  }
  generateInsertionGeodesicCoordinates(i, l, d) {
    const h = ka(i, l), g = (function(p, o, w) {
      const S = [], k = lp(p[1]), I = lp(p[0]), z = lp(o[1]), R = lp(o[0]);
      w += 1;
      const O = 2 * Math.asin(Math.sqrt(Math.sin((z - k) / 2) ** 2 + Math.cos(k) * Math.cos(z) * Math.sin((R - I) / 2) ** 2));
      if (O === 0 || isNaN(O)) return S;
      for (let V = 0; V <= w; V++) {
        const W = V / w, N = Math.sin((1 - W) * O) / Math.sin(O), K = Math.sin(W * O) / Math.sin(O), Z = N * Math.cos(k) * Math.cos(I) + K * Math.cos(z) * Math.cos(R), X = N * Math.cos(k) * Math.sin(I) + K * Math.cos(z) * Math.sin(R), te = N * Math.sin(k) + K * Math.sin(z);
        if (isNaN(Z) || isNaN(X) || isNaN(te)) continue;
        const q = Math.atan2(te, Math.sqrt(Z ** 2 + X ** 2)), he = Math.atan2(X, Z);
        isNaN(q) || isNaN(he) || S.push([T0(he), T0(q)]);
      }
      return S.slice(1, -1);
    })(i, l, Math.floor(h / d));
    return this.limitCoordinates(g);
  }
  limitCoordinates(i) {
    return i.map((l) => [Dn(l[0], this.config.coordinatePrecision), Dn(l[1], this.config.coordinatePrecision)]);
  }
}
function eA(a, i) {
  return a[0] === i[0] && a[1] === i[1];
}
function tA(a, i) {
  if (a.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (a.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < a.geometry.coordinates.length; l++) {
    if (!G1(a.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!Lv(a.geometry.coordinates[l], i)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function M0(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2));
}
function gl(a, i) {
  const l = (function(d, h) {
    const [g, p, o] = d, [w, S, k] = h;
    return g * w + p * S + o * k;
  })(a, i) / (M0(a) * M0(i));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function Em(a) {
  const i = Yi(a[1]), l = Yi(a[0]);
  return [Math.cos(i) * Math.cos(l), Math.cos(i) * Math.sin(l), Math.sin(i)];
}
function vl(a) {
  const [i, l, d] = a, h = Kc(Math.asin(d));
  return [Kc(Math.atan2(l, i)), h];
}
function rA(a, i, l) {
  const d = Em(a), h = Em(i), g = Em(l), [p, o, w] = g, [S, k, I] = (function(ve, Be) {
    const [Ne, Pe, tt] = ve, [at, xt, ht] = Be;
    return [Pe * ht - tt * xt, tt * at - Ne * ht, Ne * xt - Pe * at];
  })(d, h), z = k * w - I * o, R = I * p - S * w, O = S * o - k * p, V = O * k - R * I, W = z * I - O * S, N = R * S - z * k, K = 1 / Math.sqrt(Math.pow(V, 2) + Math.pow(W, 2) + Math.pow(N, 2)), Z = [V * K, W * K, N * K], X = [-1 * V * K, -1 * W * K, -1 * N * K], te = gl(d, h), q = gl(d, Z), he = gl(h, Z), se = gl(d, X), Q = gl(h, X);
  let oe;
  return oe = q < se && q < Q || he < se && he < Q ? Z : X, gl(d, oe) > te || gl(h, oe) > te ? ka(vl(oe), vl(d)) <= ka(vl(oe), vl(h)) ? [vl(d), true, false] : [vl(h), false, true] : [vl(oe), false, false];
}
function nA(a, i, l) {
  const d = i.x - a.x, h = i.y - a.y, g = Math.max(0, Math.min(1, ((l.x - a.x) * d + (l.y - a.y) * h) / (d * d + h * h)));
  return { x: a.x + g * d, y: a.y + g * h };
}
class Z1 extends Ki {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (h) => {
      const g = this.getSnappable(h, (p) => !!(p.properties && p.properties.mode === this.mode));
      return g.coordinate ? [Dn(g.coordinate[0], this.config.coordinatePrecision), Dn(g.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (h, g) => {
      const p = this.getSnappable(h, (o) => !!(o.properties && o.properties.mode === this.mode && o.id !== g));
      return p.coordinate ? [Dn(p.coordinate[0], this.config.coordinatePrecision), Dn(p.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), h = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return h.forEach((p) => {
      let o;
      if (p.geometry.type === "Polygon") o = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        o = p.geometry.coordinates;
      }
      const w = [];
      for (let z = 0; z < o.length - 1; z++) w.push([o[z], o[z + 1]]);
      let S;
      const k = [i.lng, i.lat];
      if (this.config.projection === "web-mercator" ? S = (function(z, R) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, W = 0;
        for (let N of R) {
          const K = N[0], Z = N[1];
          let X, te = 1 / 0;
          const q = An(K[0], K[1]), he = An(Z[0], Z[1]), se = An(z[0], z[1]);
          if (K[0] === z[0] && K[1] === z[1]) X = K;
          else if (Z[0] === z[0] && Z[1] === z[1]) X = Z;
          else {
            const { x: Q, y: oe } = nA(q, he, se), { lng: ve, lat: Be } = Jc(Q, oe);
            X = [ve, Be];
          }
          X && (te = Us(se, An(X[0], X[1])), te < V && (O = X, V = te, W = R.indexOf(N)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, lineIndex: W, distance: V };
      })(k, w) : this.config.projection === "globe" && (S = (function(z, R) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, W = 0;
        for (let N of R) {
          const K = N[0], Z = N[1];
          let X, te = 1 / 0;
          K[0] === z[0] && K[1] === z[1] ? X = K : Z[0] === z[0] && Z[1] === z[1] ? X = Z : [X] = rA(K, Z, z), X && (te = ka(z, X), te < V && (O = X, V = te, W = R.indexOf(N)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, distance: V, lineIndex: W };
      })(k, w)), !S) return;
      const I = this.pixelDistance.measure(i, S.coordinate);
      I < g.minDistance && I < this.pointerDistance && (g.featureId = p.id, g.coordinate = [Dn(S.coordinate[0], this.config.coordinatePrecision), Dn(S.coordinate[1], this.config.coordinatePrecision)], g.featureCoordinateIndex = S.lineIndex, g.minDistance = I);
    }), g;
  }
}
const iA = { cancel: "Escape", finish: "Enter" }, oA = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class H1 extends Kp {
  constructor(i) {
    super(i, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = iA, this.snapping = void 0, this.cursors = oA, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = xi({}, this.cursors, i.cursors)), i != null && i.snapping && (this.snapping = i.snapping), (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : i != null && i.keyEvents && (this.keyEvents = xi({}, this.keyEvents, i.keyEvents)), i != null && i.insertCoordinates && (this.insertCoordinates = i.insertCoordinates), i && i.editable && (this.editable = i.editable);
  }
  updateSnappedCoordinate(i) {
    const l = this.snapCoordinate(i);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [d] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [U1]: true } }]);
        this.snappedPointId = d;
      }
      i.lng = l[0], i.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const i = this.store.getGeometryCopy(this.currentId);
    i.coordinates.pop(), this.updateGeometries([...i.coordinates], void 0, Ii.Commit), this.store.updateProperty([{ id: this.currentId, property: dv, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(i, l, d) {
    if (!this.currentId) return;
    const h = { type: "LineString", coordinates: i };
    if (this.validate && !this.validate({ type: "Feature", geometry: h }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: d }).valid) return;
    const g = [{ id: this.currentId, geometry: h }];
    this.closingPointId && l && g.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), d === "commit" && (this.lastCommittedCoordinates = h.coordinates), this.store.updateGeometry(g);
  }
  generateInsertCoordinates(i, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const d = ka(i, l) / (this.insertCoordinates.value + 1);
    let h = [];
    return this.projection === "globe" ? h = this.insertPoint.generateInsertionGeodesicCoordinates(i, l, d) : this.projection === "web-mercator" && (h = this.insertPoint.generateInsertionCoordinates(i, l, d)), h;
  }
  createLine(i) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [i, i] }, properties: { mode: this.mode, [dv]: true } }]);
    this.lastCommittedCoordinates = [i, i], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(i) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [d] = this.store.create([{ geometry: { type: "Point", coordinates: [...i] }, properties: { mode: this.mode, [hv]: true } }]);
    this.closingPointId = d, this.setCursor(this.cursors.close);
    const h = [...l, i];
    this.updateGeometries(h, void 0, Ii.Commit), this.currentCoordinate++;
  }
  updateToLine(i, l) {
    if (!this.currentId) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates, [h, g] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : d[d.length - 2], { x: p, y: o } = this.project(h, g);
    if (Us({ x: p, y: o }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const w = [...d, i];
    this.updateGeometries(w, d[d.length - 1], Ii.Commit), this.currentCoordinate++;
  }
  registerBehaviors(i) {
    this.coordinateSnapping = new fv(i, new Ap(i), new zp(i)), this.insertPoint = new Qz(i), this.clickBoundingBox = new zp(i), this.pixelDistance = new Ap(i), this.lineSnapping = new Z1(i, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new fv(i, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(i) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = i;
    const l = this.updateSnappedCoordinate(i) || [i.lng, i.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates;
    if (d.pop(), this.closingPointId) {
      const [g, p] = d[d.length - 1], { x: o, y: w } = this.project(g, p);
      Us({ x: o, y: w }, { x: i.containerX, y: i.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let h = [...d, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const g = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], p = l;
      if (!eA(g, p)) {
        const o = this.generateInsertCoordinates(g, p);
        h = [...this.lastCommittedCoordinates.slice(0, -1), ...o, l];
      }
    }
    this.updateGeometries(h, void 0, Ii.Provisional);
  }
  onRightClick(i) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: d } = this.coordinateSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
    if (!l || d === void 0) return;
    const h = this.store.getGeometryCopy(l);
    let g;
    if (h.type === "LineString" && (g = h.coordinates, !(g.length <= 2))) {
      if (g.splice(d, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: h, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: h }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(i) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(i) || [i.lng, i.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: i.containerX, y: i.containerY });
  }
  onClick(i) {
    (i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(i), this.mouseMove = false, i.button === "right" ? this.onRightClick(i) : i.button === "left" && this.onLeftClick(i));
  }
  onKeyDown() {
  }
  onKeyUp(i) {
    i.key === this.keyEvents.cancel && this.cleanUp(), i.key === this.keyEvents.finish && this.close();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.editable) return;
    let d;
    if (this.state === "started") {
      const h = this.lineSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
      h.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = h.featureCoordinateIndex, this.editedFeatureId = h.featureId, d = h.coordinate);
      const g = this.coordinateSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
      g.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = g.featureCoordinateIndex, this.editedFeatureId = g.featureId, d = g.coordinate);
    }
    if (this.editedFeatureId && d) {
      if (!this.editedPointId) {
        const [h] = this.store.create([{ geometry: { type: "Point", coordinates: d }, properties: { mode: this.mode, [Md]: true } }]);
        this.editedPointId = h;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const d = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? d.coordinates[this.editedFeatureCoordinateIndex] = [i.lng, i.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, d.coordinates.splice(this.editedInsertIndex, 0, [i.lng, i.lat]), this.editedFeatureCoordinateIndex++);
    const h = { type: "LineString", coordinates: d.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: h, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: h }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Md, value: true }]));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: Md, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const i = this.currentId, l = this.closingPointId, d = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      i !== void 0 && this.store.delete([i]), d !== void 0 && this.store.delete([d]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(i) {
    const l = xi({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "LineString" && i.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, i), l.zIndex = wp, l;
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = i.properties[hv];
      return l.pointColor = this.getHexColorStylingValue(d ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, i), l.pointWidth = this.getNumericStylingValue(d ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, i), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => tA(l, this.coordinatePrecision));
  }
  lineStringFilter(i) {
    return !!(i.geometry.type === "LineString" && i.properties && i.properties.mode === this.mode);
  }
  snapCoordinate(i) {
    var l, d, h;
    let g;
    if ((l = this.snapping) != null && l.toLine) {
      let p;
      p = this.currentId ? this.lineSnapping.getSnappableCoordinate(i, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(i), p && (g = p);
    }
    return (d = this.snapping) != null && d.toCoordinate && (g = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(i, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(i)), (h = this.snapping) != null && h.toCustom && (g = this.snapping.toCustom(i, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), g;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === i.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const sA = "Feature is not a Point", aA = "Feature has invalid coordinates", lA = "Feature has coordinates with excessive precision";
function cA(a, i) {
  return a.geometry.type !== "Point" ? { valid: false, reason: sA } : G1(a.geometry.coordinates) ? Lv(a.geometry.coordinates, i) ? { valid: true } : { valid: false, reason: lA } : { valid: false, reason: aA };
}
const uA = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class X1 extends Kp {
  constructor(i) {
    super(i, true), this.mode = "point", this.cursors = uA, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = xi({}, this.cursors, i.cursors)), i != null && i.editable && (this.editable = i.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(i, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, i)) {
      if (this.editable) {
        const d = this.getNearestPointFeature(i);
        this.editedFeatureId = d == null ? void 0 : d.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, i) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [i.lng, i.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Md, value: true }])));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: Md, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(i) {
    this.pixelDistance = new Ap(i), this.clickBoundingBox = new zp(i);
  }
  styleFeature(i) {
    const l = xi({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = !!(i.id && this.editedFeatureId === i.id);
      l.pointWidth = this.getNumericStylingValue(d ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(d ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, i), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => cA(l, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const l = { type: "Point", coordinates: [i.lng, i.lat] }, d = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: d }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Finish }).valid) return;
    const [h] = this.store.create([{ geometry: l, properties: d }]);
    this.onFinish(h, { mode: this.mode, action: "draw" });
  }
  onRightClick(i) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(i);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(i) {
    const l = this.clickBoundingBox.create(i), d = this.store.search(l);
    let h, g = 1 / 0;
    for (let p = 0; p < d.length; p++) {
      const o = d[p];
      if (o.geometry.type !== "Point" || o.properties.mode !== this.mode) continue;
      const w = this.pixelDistance.measure(i, o.geometry.coordinates);
      w > g || w > this.pointerDistance || (g = w, h = o);
    }
    return h;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class dA extends Ki {
  constructor(i) {
    super(i);
  }
  createOrUpdate(i) {
    const l = this.store.getGeometryCopy(i), d = this.store.getPropertiesCopy(i);
    let h;
    if (l.type === "Polygon") h = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      h = l.coordinates;
    }
    const g = this.store.getPropertiesCopy(i), p = g.coordinatePointIds;
    if (p) if (p && p.every((o) => this.store.has(o))) {
      const o = g.coordinatePointIds, w = o.map((S) => this.store.getGeometryCopy(S).coordinates);
      if (o.length !== h.length) {
        this.deleteCoordinatePoints(o);
        const S = this.createPoints(h, d.mode, i);
        this.setFeatureCoordinatePoints(i, S);
      } else h.forEach((S, k) => {
        S[0] === w[k][0] && S[1] === w[k][1] || this.store.updateGeometry([{ id: o[k], geometry: { type: "Point", coordinates: S } }]);
      });
    } else {
      const o = p.filter((S) => this.store.has(S));
      o.length && this.deleteCoordinatePoints(o);
      const w = this.createPoints(h, d.mode, i);
      this.setFeatureCoordinatePoints(i, w);
    }
    else {
      const o = this.createPoints(h, d.mode, i);
      this.setFeatureCoordinatePoints(i, o);
    }
  }
  deletePointsByFeatureIds(i) {
    for (const l of i) this.deleteIfPresent(l);
  }
  getUpdated(i, l) {
    const d = this.store.getPropertiesCopy(i);
    if (d.coordinatePointIds) return d.coordinatePointIds.map((h, g) => ({ id: h, geometry: xi({}, this.store.getGeometryCopy(h), { coordinates: l[g] }) }));
  }
  createPoints(i, l, d) {
    return this.store.create(i.map((h, g) => ({ geometry: { type: "Point", coordinates: h }, properties: { mode: l, [pv]: true, [Gz]: d, index: g } })));
  }
  setFeatureCoordinatePoints(i, l) {
    this.store.updateProperty([{ id: i, property: Ep, value: l }]);
  }
  deleteCoordinatePoints(i) {
    const l = i.filter((d) => this.store.has(d));
    this.store.delete(l);
  }
  deleteIfPresent(i) {
    const l = this.store.getPropertiesCopy(i).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(i, null));
  }
}
function mv(a, i) {
  const l = a, d = i, h = Yi(l[1]), g = Yi(d[1]);
  let p = Yi(d[0] - l[0]);
  p > Math.PI && (p -= 2 * Math.PI), p < -Math.PI && (p += 2 * Math.PI);
  const o = Math.log(Math.tan(g / 2 + Math.PI / 4) / Math.tan(h / 2 + Math.PI / 4)), w = (Kc(Math.atan2(p, o)) + 360) % 360;
  return w > 180 ? -(360 - w) : w;
}
function Y1(a, i, l) {
  let d = i;
  i < 0 && (d = -Math.abs(d));
  const h = d / q1, g = a[0] * Math.PI / 180, p = Yi(a[1]), o = Yi(l), w = h * Math.cos(o);
  let S = p + w;
  Math.abs(S) > Math.PI / 2 && (S = S > 0 ? Math.PI - S : -Math.PI - S);
  const k = Math.log(Math.tan(S / 2 + Math.PI / 4) / Math.tan(p / 2 + Math.PI / 4)), I = Math.abs(k) > 1e-11 ? w / k : Math.cos(p), z = [(180 * (g + h * Math.sin(o) / I) / Math.PI + 540) % 360 - 180, 180 * S / Math.PI];
  return z[0] += z[0] - a[0] > 180 ? -360 : a[0] - z[0] > 180 ? 360 : 0, z;
}
function hA(a, i, l, d, h) {
  const g = d(a[0], a[1]), p = d(i[0], i[1]), { lng: o, lat: w } = h((g.x + p.x) / 2, (g.y + p.y) / 2);
  return [Dn(o, l), Dn(w, l)];
}
function pA(a, i, l) {
  const d = Y1(a, 1e3 * ka(a, i) / 2, mv(a, i));
  return [Dn(d[0], l), Dn(d[1], l)];
}
function I0({ featureCoords: a, precision: i, unproject: l, project: d, projection: h }) {
  const g = [];
  for (let p = 0; p < a.length - 1; p++) {
    let o;
    if (h === "web-mercator") o = hA(a[p], a[p + 1], i, d, l);
    else {
      if (h !== "globe") throw new Error("Invalid projection");
      o = pA(a[p], a[p + 1], i);
    }
    g.push(o);
  }
  return g;
}
class fA extends Ki {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = i, this.selectionPointBehavior = l, this.coordinatePointBehavior = d;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(i) {
  }
  insert(i, l, d) {
    const h = this.store.getGeometryCopy(l), { midPointFeatureId: g, midPointSegment: p } = this.store.getPropertiesCopy(l), o = this.store.getGeometryCopy(g), w = o.type === "Polygon" ? o.coordinates[0] : o.coordinates;
    w.splice(p + 1, 0, h.coordinates), o.coordinates = o.type === "Polygon" ? [w] : w, this.store.updateGeometry([{ id: g, geometry: o }]), this.store.getPropertiesCopy(i)[Ep] && this.coordinatePointBehavior.createOrUpdate(i), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(w, g, d), this.selectionPointBehavior.create(w, o.type, g);
  }
  create(i, l, d) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(h, g, p, o, w, S) {
      return I0({ featureCoords: h, precision: p, project: o, unproject: w, projection: S }).map((k, I) => ({ geometry: { type: "Point", coordinates: k }, properties: g(I) }));
    })(i, (h) => ({ mode: this.mode, [bi.MID_POINT]: true, midPointSegment: h, midPointFeatureId: l }), d, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(i) {
    if (this._midPoints.length !== 0) return I0({ featureCoords: i, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, d) => ({ id: this._midPoints[d], geometry: { type: "Point", coordinates: l } }));
  }
}
class mA extends Ki {
  constructor(i) {
    super(i), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(i) {
  }
  create(i, l, d) {
    this._selectionPoints = this.store.create((function(h, g, p) {
      const o = [], w = g === "Polygon" ? h.length - 1 : h.length;
      for (let S = 0; S < w; S++) o.push({ geometry: { type: "Point", coordinates: h[S] }, properties: p(S) });
      return o;
    })(i, l, (h) => ({ mode: this.mode, index: h, [bi.SELECTION_POINT]: true, [bi.SELECTION_POINT_FEATURE_ID]: d })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(i) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, d) => ({ id: l, geometry: { type: "Point", coordinates: i[d] } }));
  }
  getOneUpdated(i, l) {
    if (this._selectionPoints[i] !== void 0) return { id: this._selectionPoints[i], geometry: { type: "Point", coordinates: l } };
  }
}
function K1(a, i) {
  let l = false;
  for (let p = 0, o = i.length; p < o; p++) {
    const w = i[p];
    for (let S = 0, k = w.length, I = k - 1; S < k; I = S++) (h = w[S])[1] > (d = a)[1] != (g = w[I])[1] > d[1] && d[0] < (g[0] - h[0]) * (d[1] - h[1]) / (g[1] - h[1]) + h[0] && (l = !l);
  }
  var d, h, g;
  return l;
}
const gv = (a, i, l) => {
  const d = (g) => g * g, h = (g, p) => d(g.x - p.x) + d(g.y - p.y);
  return Math.sqrt(((g, p, o) => {
    const w = h(p, o);
    if (w === 0) return h(g, p);
    let S = ((g.x - p.x) * (o.x - p.x) + (g.y - p.y) * (o.y - p.y)) / w;
    return S = Math.max(0, Math.min(1, S)), h(g, { x: p.x + S * (o.x - p.x), y: p.y + S * (o.y - p.y) });
  })(a, i, l));
};
class gA extends Ki {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = i, this.createClickBoundingBox = l, this.pixelDistance = d;
  }
  find(i, l) {
    let d, h, g, p, o = 1 / 0, w = 1 / 0, S = 1 / 0;
    const k = this.createClickBoundingBox.create(i), I = this.store.search(k);
    for (let z = 0; z < I.length; z++) {
      const R = I[z], O = R.geometry;
      if (O.type === "Point") {
        if (R.properties.selectionPoint || R.properties.coordinatePoint || !l && R.properties[bi.MID_POINT]) continue;
        const V = this.pixelDistance.measure(i, O.coordinates);
        R.properties[bi.MID_POINT] && V < this.pointerDistance && V < S ? (S = V, g = R) : !R.properties[bi.MID_POINT] && V < this.pointerDistance && V < o && (o = V, d = R);
      } else if (O.type === "LineString") {
        if (d) continue;
        for (let V = 0; V < O.coordinates.length - 1; V++) {
          const W = O.coordinates[V], N = O.coordinates[V + 1], K = gv({ x: i.containerX, y: i.containerY }, this.project(W[0], W[1]), this.project(N[0], N[1]));
          K < this.pointerDistance && K < w && (w = K, h = R);
        }
      } else if (O.type === "Polygon") {
        if (d || h) continue;
        K1([i.lng, i.lat], O.coordinates) && (p = R);
      }
    }
    return { clickedFeature: d || h || p, clickedMidPoint: g };
  }
}
class vA extends Ki {
  constructor(i, l, d, h, g) {
    super(i), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = i, this.featuresAtCursorEvent = l, this.selectionPoints = d, this.midPoints = h, this.coordinatePoints = g;
  }
  startDragging(i, l) {
    this.draggedFeatureId = l, this.dragPosition = [i.lng, i.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(i, l) {
    const { clickedFeature: d } = this.featuresAtCursorEvent.find(i, true);
    return !(!d || d.id !== l);
  }
  drag(i, l) {
    if (!this.draggedFeatureId) return;
    const d = this.store.getGeometryCopy(this.draggedFeatureId), h = [i.lng, i.lat];
    if (d.type === "Polygon" || d.type === "LineString") {
      let g, p;
      if (d.type === "Polygon" ? (g = d.coordinates[0], p = g.length - 1) : (g = d.coordinates, p = g.length), !this.dragPosition) return false;
      for (let k = 0; k < p; k++) {
        const I = g[k];
        let z, R;
        if (this.config.projection === "web-mercator") {
          const O = An(this.dragPosition[0], this.dragPosition[1]), V = An(h[0], h[1]), W = An(I[0], I[1]), N = { x: O.x - V.x, y: O.y - V.y }, K = W.x - N.x, Z = W.y - N.y, { lng: X, lat: te } = Jc(K, Z);
          z = X, R = te;
        } else {
          const O = [this.dragPosition[0] - h[0], this.dragPosition[1] - h[1]];
          z = I[0] - O[0], R = I[1] - O[1];
        }
        if (z = Dn(z, this.config.coordinatePrecision), R = Dn(R, this.config.coordinatePrecision), z > 180 || z < -180 || R > 90 || R < -90) return false;
        g[k] = [z, R];
      }
      d.type === "Polygon" && (g[g.length - 1] = [g[0][0], g[0][1]]);
      const o = this.selectionPoints.getUpdated(g) || [], w = this.midPoints.getUpdated(g) || [], S = this.coordinatePoints.getUpdated(this.draggedFeatureId, g) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ii.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: d }, ...o, ...w, ...S]), this.dragPosition = [i.lng, i.lat];
    } else d.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: h } }]), this.dragPosition = [i.lng, i.lat]);
  }
}
class yA extends Ki {
  constructor(i, l, d, h, g, p, o) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = h, this.coordinatePoints = g, this.coordinateSnapping = p, this.lineSnapping = o;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let h;
    if (l.type === "LineString") h = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      h = l.coordinates[0];
    }
    for (let g = 0; g < h.length; g++) {
      const p = this.pixelDistance.measure(i, h[g]);
      if (p < this.pointerDistance && p < d.dist) {
        const o = l.type === "Polygon" && (g === h.length - 1 || g === 0);
        d.dist = p, d.index = o ? 0 : g, d.isFirstOrLastPolygonCoord = o;
      }
    }
    return d;
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), h = this.getClosestCoordinate(i, d);
    return h.index === -1 ? -1 : h.index;
  }
  snapCoordinate(i, l, d) {
    let h = [i.lng, i.lat];
    const g = (p) => !!(p.properties && p.properties.mode === d.properties.mode && p.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let p;
      p = this.lineSnapping.getSnappable(i, g).coordinate, p && (h = p);
    }
    if (l.toCoordinate) {
      let p;
      p = this.coordinateSnapping.getSnappable(i, g).coordinate, p && (h = p);
    }
    if (l != null && l.toCustom) {
      let p;
      p = l.toCustom(i, { currentCoordinate: this.draggedCoordinate.index, currentId: d.id, getCurrentGeometrySnapshot: d.id ? () => this.store.getGeometryCopy(d.id) : () => null, project: this.project, unproject: this.unproject }), p && (h = p);
    }
    return h;
  }
  drag(i, l, d, h) {
    const g = this.draggedCoordinate.id;
    if (g === null) return false;
    const p = this.draggedCoordinate.index, o = this.store.getGeometryCopy(g), w = this.store.getPropertiesCopy(g), S = o.type === "LineString" ? o.coordinates : o.coordinates[0], k = o.type === "Polygon" && (p === S.length - 1 || p === 0), I = { type: "Feature", id: g, geometry: o, properties: w }, z = this.snapCoordinate(i, h, I);
    if (i.lng > 180 || i.lng < -180 || i.lat > 90 || i.lat < -90) return false;
    if (k) {
      const N = S.length - 1;
      S[0] = z, S[N] = z;
    } else S[p] = z;
    const R = this.selectionPoints.getOneUpdated(p, z), O = R ? [R] : [], V = this.midPoints.getUpdated(S) || [], W = this.coordinatePoints.getUpdated(g, S) || [];
    return !(o.type !== "Point" && !l && Yz({ geometry: o }) || d && !d(I, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ii.Provisional }).valid || (this.store.updateGeometry([{ id: g, geometry: o }, ...O, ...V, ...W]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function E0(a) {
  let i = 0, l = 0, d = 0;
  return (a.geometry.type === "Polygon" ? a.geometry.coordinates[0].slice(0, -1) : a.geometry.coordinates).forEach((h) => {
    i += h[0], l += h[1], d++;
  }, true), [i / d, l / d];
}
const J1 = (a, i) => {
  if (i === 0 || i === 360 || i === -360) return a;
  const l = 0.017453292519943295 * i, d = (a.geometry.type === "Polygon" ? a.geometry.coordinates[0] : a.geometry.coordinates).map(([p, o]) => An(p, o)), h = d.reduce((p, o) => ({ x: p.x + o.x, y: p.y + o.y }), { x: 0, y: 0 });
  h.x /= d.length, h.y /= d.length;
  const g = d.map((p) => ({ x: h.x + (p.x - h.x) * Math.cos(l) - (p.y - h.y) * Math.sin(l), y: h.y + (p.x - h.x) * Math.sin(l) + (p.y - h.y) * Math.cos(l) })).map(({ x: p, y: o }) => [Jc(p, o).lng, Jc(p, o).lat]);
  return a.geometry.type === "Polygon" ? a.geometry.coordinates[0] = g : a.geometry.coordinates = g, a;
};
function vv(a) {
  const i = (a.geometry.type === "Polygon" ? a.geometry.coordinates[0] : a.geometry.coordinates).map((l) => {
    const { x: d, y: h } = An(l[0], l[1]);
    return [d, h];
  });
  return a.geometry.type === "Polygon" ? (function(l) {
    let d = 0, h = 0, g = 0;
    const p = l.length;
    for (let o = 0; o < p - 1; o++) {
      const [w, S] = l[o], [k, I] = l[o + 1], z = w * I - k * S;
      d += z, h += (w + k) * z, g += (S + I) * z;
    }
    return d /= 2, h /= 6 * d, g /= 6 * d, { x: h, y: g };
  })(i) : (function(l) {
    const d = l.length;
    let h = 0, g = 0;
    for (let p = 0; p < d; p++) {
      const [o, w] = l[p];
      h += o, g += w;
    }
    return { x: h / d, y: g / d };
  })(i);
}
class _A extends Ki {
  constructor(i, l, d, h) {
    super(i), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = i, this.selectionPoints = l, this.midPoints = d, this.coordinatePoints = h;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(i, l, d) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const h = this.selectedGeometry;
    if (h.type !== "Polygon" && h.type !== "LineString") return;
    const g = [i.lng, i.lat];
    let p;
    const o = { type: "Feature", geometry: h, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = vv(o));
      const z = An(i.lng, i.lat);
      if (p = Kz(this.selectedGeometryWebMercatorCentroid, z), p === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = p);
      J1(o, -(this.lastBearing - p));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = E0({ geometry: h })), p = mv(this.selectedGeometryCentroid, g), !this.lastBearing) return void (this.lastBearing = p + 180);
      (function(z, R) {
        if (R === 0 || R === 360 || R === -360) return z;
        const O = E0(z);
        (z.geometry.type === "Polygon" ? z.geometry.coordinates[0] : z.geometry.coordinates).forEach((V) => {
          const W = mv(O, V) + R, N = (function(Z, X) {
            Z[0] += Z[0] - X[0] > 180 ? -360 : X[0] - Z[0] > 180 ? 360 : 0;
            const te = q1, q = X[1] * Math.PI / 180, he = Z[1] * Math.PI / 180, se = he - q;
            let Q = Math.abs(Z[0] - X[0]) * Math.PI / 180;
            Q > Math.PI && (Q -= 2 * Math.PI);
            const oe = Math.log(Math.tan(he / 2 + Math.PI / 4) / Math.tan(q / 2 + Math.PI / 4)), ve = Math.abs(oe) > 1e-11 ? se / oe : Math.cos(q);
            return Math.sqrt(se * se + ve * ve * Q * Q) * te;
          })(O, V), K = Y1(O, N, W);
          V[0] = K[0], V[1] = K[1];
        });
      })(o, -(this.lastBearing - (p + 180)));
    }
    const w = h.type === "Polygon" ? h.coordinates[0] : h.coordinates;
    w.forEach((z) => {
      z[0] = Dn(z[0], this.coordinatePrecision), z[1] = Dn(z[1], this.coordinatePrecision);
    });
    const S = this.midPoints.getUpdated(w) || [], k = this.selectionPoints.getUpdated(w) || [], I = this.coordinatePoints.getUpdated(l, w) || [];
    if (d && !d({ id: l, type: "Feature", geometry: h, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ii.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: h }, ...k, ...S, ...I]), this.projection === "web-mercator" ? this.lastBearing = p : this.projection === "globe" && (this.lastBearing = p + 180);
  }
}
class bA extends Ki {
  constructor(i, l) {
    super(i), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = i, this.dragCoordinateResizeBehavior = l;
  }
  scale(i, l, d) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const h = this.dragCoordinateResizeBehavior.getDraggableIndex(i, l);
      this.dragCoordinateResizeBehavior.startDragging(l, h);
    }
    this.dragCoordinateResizeBehavior.drag(i, "center-fixed", d);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function Q1({ coordinates: a, originX: i, originY: l, xScale: d, yScale: h }) {
  d === 1 && h === 1 || a.forEach((g) => {
    const { x: p, y: o } = An(g[0], g[1]), w = i + (p - i) * d, S = l + (o - l) * h, { lng: k, lat: I } = Jc(w, S);
    g[0] = k, g[1] = I;
  });
}
let xA = class extends Ki {
  constructor(i, l, d, h, g) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = h, this.coordinatePoints = g;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let h;
    if (l.type === "LineString") h = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      h = l.coordinates[0];
    }
    for (let g = 0; g < h.length; g++) {
      const p = this.pixelDistance.measure(i, h[g]);
      if (p < this.pointerDistance && p < d.dist) {
        const o = l.type === "Polygon" && (g === h.length - 1 || g === 0);
        d.dist = p, d.index = o ? 0 : g, d.isFirstOrLastPolygonCoord = o;
      }
    }
    return d;
  }
  isValidDragWebMercator(i, l, d) {
    switch (i) {
      case 0:
        if (l <= 0 || d >= 0) return false;
        break;
      case 1:
        if (d >= 0) return false;
        break;
      case 2:
        if (l >= 0 || d >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || d <= 0) return false;
        break;
      case 5:
        if (d <= 0) return false;
        break;
      case 6:
        if (l <= 0 || d <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const i = this.getFeature(this.draggedCoordinate.id);
    if (!i) return null;
    const l = this.getNormalisedCoordinates(i.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: i, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: h, updatedCoords: g, selectedCoordinate: p } = l, o = vv(d);
    if (!o) return null;
    const w = An(p[0], p[1]), { closestBBoxIndex: S } = this.getIndexesWebMercator(h, w), k = An(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: S, updatedCoords: g, webMercatorCursor: k, webMercatorSelected: w, webMercatorOrigin: o }), g;
  }
  centerFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: h, updatedCoords: g, selectedCoordinate: p } = l, o = vv(d);
    if (!o) return null;
    const w = An(p[0], p[1]), { closestBBoxIndex: S } = this.getIndexesWebMercator(h, w), k = An(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: S, updatedCoords: g, webMercatorCursor: k, webMercatorSelected: w, webMercatorOrigin: o }), g;
  }
  scaleFixedWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: h, updatedCoords: g }) {
    if (!this.isValidDragWebMercator(i, l.x - h.x, l.y - h.y)) return null;
    let p = Us(l, h) / Us(l, d);
    return p < 0 && (p = this.minimumScale), Q1({ coordinates: g, originX: l.x, originY: l.y, xScale: p, yScale: p }), g;
  }
  oppositeFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: h, selectedCoordinate: g } = l, p = An(g[0], g[1]), { oppositeBboxIndex: o, closestBBoxIndex: w } = this.getIndexesWebMercator(d, p), S = { x: d[o][0], y: d[o][1] }, k = An(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: w, updatedCoords: h, webMercatorCursor: k, webMercatorSelected: p, webMercatorOrigin: S }), h;
  }
  oppositeWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: h, selectedCoordinate: g } = l, p = An(g[0], g[1]), { oppositeBboxIndex: o, closestBBoxIndex: w } = this.getIndexesWebMercator(d, p), S = { x: d[o][0], y: d[o][1] }, k = An(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: w, updatedCoords: h, webMercatorCursor: k, webMercatorSelected: p, webMercatorOrigin: S }), h;
  }
  scaleWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: h, updatedCoords: g }) {
    const p = l.x - h.x, o = l.y - h.y;
    if (!this.isValidDragWebMercator(i, p, o)) return null;
    let w = 1;
    p !== 0 && i !== 1 && i !== 5 && (w = 1 - (l.x - d.x - p) / p);
    let S = 1;
    return o !== 0 && i !== 3 && i !== 7 && (S = 1 - (l.y - d.y - o) / o), this.validateScale(w, S) ? (w < 0 && (w = this.minimumScale), S < 0 && (S = this.minimumScale), this.performWebMercatorScale(g, l.x, l.y, w, S), g) : null;
  }
  getFeature(i) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(i);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: i, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(i) {
    return i.type === "Polygon" ? i.coordinates[0] : i.coordinates;
  }
  validateScale(i, l) {
    const d = !isNaN(i) && l < Number.MAX_SAFE_INTEGER, h = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return d && h;
  }
  performWebMercatorScale(i, l, d, h, g) {
    i.forEach((p) => {
      const { x: o, y: w } = An(p[0], p[1]), S = l + (o - l) * h, k = d + (w - d) * g, { lng: I, lat: z } = Jc(S, k);
      p[0] = I, p[1] = z;
    });
  }
  getBBoxWebMercator(i) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (i = i.map((o) => {
      const { x: w, y: S } = An(o[0], o[1]);
      return [w, S];
    })).forEach(([o, w]) => {
      o < l[0] && (l[0] = o), w < l[1] && (l[1] = w), o > l[2] && (l[2] = o), w > l[3] && (l[3] = w);
    });
    const [d, h, g, p] = l;
    return [[d, p], [(d + g) / 2, p], [g, p], [g, p + (h - p) / 2], [g, h], [(d + g) / 2, h], [d, h], [d, p + (h - p) / 2]];
  }
  getIndexesWebMercator(i, l) {
    let d, h = 1 / 0;
    for (let g = 0; g < i.length; g++) {
      const p = Us({ x: l.x, y: l.y }, { x: i[g][0], y: i[g][1] });
      p < h && (d = g, h = p);
    }
    if (d === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[d], closestBBoxIndex: d };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), h = this.getClosestCoordinate(i, d);
    return h.index === -1 ? -1 : h.index;
  }
  drag(i, l, d) {
    if (!this.draggedCoordinate.id) return false;
    const h = this.getFeature(this.draggedCoordinate.id);
    if (!h) return false;
    let g = null;
    if (l === "center" ? g = this.centerWebMercatorDrag(i) : l === "opposite" ? g = this.oppositeWebMercatorDrag(i) : l === "center-fixed" ? g = this.centerFixedWebMercatorDrag(i) : l === "opposite-fixed" && (g = this.oppositeFixedWebMercatorDrag(i)), !g) return false;
    for (let k = 0; k < g.length; k++) {
      const I = g[k];
      if (I[0] = Dn(I[0], this.coordinatePrecision), I[1] = Dn(I[1], this.coordinatePrecision), !Lv(I, this.coordinatePrecision)) return false;
    }
    const p = this.midPoints.getUpdated(g) || [], o = this.selectionPoints.getUpdated(g) || [], w = this.coordinatePoints.getUpdated(h.id, g) || [], S = { type: h.geometry.type, coordinates: h.geometry.type === "Polygon" ? [g] : g };
    return !(d && !d({ id: this.draggedCoordinate.id, type: "Feature", geometry: S, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ii.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: S }, ...o, ...p, ...w]), 0));
  }
};
const wA = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, R0 = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class ew extends Hz {
  constructor(i) {
    super(i, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = wA, this.cursors = R0, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    if (super.updateOptions(i), this.cursors = i && i.cursors ? xi({}, this.cursors, i.cursors) : R0, (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : i != null && i.keyEvents && (this.keyEvents = xi({}, this.keyEvents, i.keyEvents)), (i == null ? void 0 : i.dragEventThrottle) !== void 0 && (this.dragEventThrottle = i.dragEventThrottle), (i == null ? void 0 : i.allowManualDeselection) !== void 0 && (this.allowManualDeselection = i.allowManualDeselection), i != null && i.flags) {
      this.flags = xi({}, this.flags, i.flags), this.validations = {};
      for (const l in this.flags) {
        const d = this.flags[l].feature;
        d && d.validation && (this.validations[l] = d.validation);
      }
    }
  }
  selectFeature(i) {
    this.select(i, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(i) {
    this.pixelDistance = new Ap(i), this.clickBoundingBox = new zp(i), this.featuresAtMouseEvent = new gA(i, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new mA(i), this.coordinatePoints = new dA(i), this.midPoints = new fA(i, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new fv(i, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new Z1(i, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new _A(i, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new vA(i, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new yA(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new xA(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new bA(i, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const i = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: bi.SELECTED, value: false }));
    this.store.updateProperty(i), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(i) {
    if (!this.selectionPoints.ids.length) return;
    let l, d = 1 / 0;
    if (this.selectionPoints.ids.forEach((z) => {
      const R = this.store.getGeometryCopy(z), O = this.pixelDistance.measure(i, R.coordinates);
      O < this.pointerDistance && O < d && (d = O, l = this.store.getPropertiesCopy(z));
    }), !l) return;
    const h = l.selectionPointFeatureId, g = l.index, p = this.store.getPropertiesCopy(h), o = this.flags[p.mode], w = this.validations[p.mode];
    if (!(o && o.feature && o.feature.coordinates && o.feature.coordinates.deletable)) return;
    const S = this.store.getGeometryCopy(h);
    let k;
    if (S.type === "Polygon") {
      if (k = S.coordinates[0], k.length <= 4) return;
    } else if (S.type === "LineString" && (k = S.coordinates, k.length <= 2)) return;
    if (!k || (S.type !== "Polygon" || g !== 0 && g !== k.length - 1 ? k.splice(g, 1) : (k.shift(), k.pop(), k.push([k[0][0], k[0][1]])), w && !w({ id: h, type: "Feature", geometry: S, properties: p }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ii.Commit }).valid)) return;
    const I = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(I), this.store.updateGeometry([{ id: h, geometry: S }]), p.coordinatePointIds && this.coordinatePoints.createOrUpdate(h), this.selectionPoints.create(k, S.type, h), o && o.feature && o.feature.coordinates && o.feature.coordinates.midpoints && this.midPoints.create(k, h, this.coordinatePrecision);
  }
  select(i, l = true) {
    if (this.selected[0] === i) return;
    const { mode: d } = this.store.getPropertiesCopy(i), h = this.flags[d];
    if (!h || !h.feature) return;
    const g = this.selected[0];
    if (g) {
      if (g === i) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [i], this.store.updateProperty([{ id: i, property: bi.SELECTED, value: true }]), this.onSelect(i);
    const { type: p, coordinates: o } = this.store.getGeometryCopy(i);
    if (p !== "LineString" && p !== "Polygon") return;
    const w = p === "LineString" ? o : o[0];
    w && h && h.feature.coordinates && (this.selectionPoints.create(w, p, i), h.feature.coordinates.midpoints && this.midPoints.create(w, i, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const { clickedFeature: l, clickedMidPoint: d } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
    if (this.selected.length && d) this.midPoints.insert(this.selected[0], d.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  canScale(i) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => i.heldKeys.includes(l));
  }
  canRotate(i) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => i.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(i) {
    const l = this.canRotate(i), d = this.canScale(i);
    (l || d) && i.preventDefault();
  }
  onKeyDown(i) {
    this.preventDefaultKeyEvent(i);
  }
  onKeyUp(i) {
    if (this.preventDefaultKeyEvent(i), this.keyEvents.delete && i.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && i.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.selected.length) return;
    const d = this.store.getPropertiesCopy(this.selected[0]), h = this.flags[d.mode];
    if (!(h && h.feature && (h.feature.draggable || h.feature.coordinates && h.feature.coordinates.draggable || h.feature.coordinates && h.feature.coordinates.resizable || h.feature.coordinates && typeof h.feature.coordinates.midpoints == "object" && h.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const g = this.selected[0], p = this.dragCoordinate.getDraggableIndex(i, g);
    if (h && h.feature && h.feature.coordinates && (h.feature.coordinates.draggable || h.feature.coordinates.resizable) && p !== -1) return this.setCursor(this.cursors.dragStart), h.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(g, p) : this.dragCoordinate.startDragging(g, p), void l(false);
    if (h && h.feature && h.feature.coordinates && typeof h.feature.coordinates.midpoints == "object" && h.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: o } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
      if (this.selected.length && o) {
        this.midPoints.insert(g, o.id, this.coordinatePrecision);
        const w = this.dragCoordinate.getDraggableIndex(i, g);
        return this.dragCoordinate.startDragging(g, w), void l(false);
      }
    }
    return h && h.feature && h.feature.draggable && this.dragFeature.canDrag(i, g) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(i, g), void l(false)) : void 0;
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i)) return;
    const d = this.selected[0];
    if (!d) return;
    const h = this.store.getPropertiesCopy(d), g = this.flags[h.mode], p = (g && g.feature && g.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const o = this.validations[h.mode];
    if (g && g.feature && g.feature.rotateable && this.canRotate(i)) return l(false), void this.rotateFeature.rotate(i, d, o);
    if (g && g.feature && g.feature.scaleable && this.canScale(i)) return l(false), void this.scaleFeature.scale(i, d, o);
    if (this.dragCoordinateResizeFeature.isDragging() && g.feature && g.feature.coordinates && g.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(i, g.feature.coordinates.resizable, o);
    }
    if (this.dragCoordinate.isDragging()) {
      var w;
      const S = (w = g.feature) == null || (w = w.coordinates) == null ? void 0 : w.snappable;
      let k = { toCoordinate: false };
      return S === true ? k = { toCoordinate: true } : typeof S == "object" && (k = S), void this.dragCoordinate.drag(i, p, o, k);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(i, o) : l(true);
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(i) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((g) => {
      if (l) return;
      const p = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, p.coordinates) < this.pointerDistance && (l = true);
    });
    let d = false;
    if (this.selectionPoints.ids.forEach((g) => {
      const p = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, p.coordinates) < this.pointerDistance && (l = false, d = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: h } = this.featuresAtMouseEvent.find(i, true);
    this.setCursor(this.selected.length > 0 && (h && h.id === this.selected[0] || d) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(i) {
    const l = xi({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.properties.mode === this.mode && i.geometry.type === "Point") {
      if (i.properties.selectionPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, i), l.zIndex = 30, l;
      if (i.properties.midPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, i), l.zIndex = 50, l;
    } else if (i.properties[bi.SELECTED]) {
      if (i.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, i), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, i), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, i), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, i), l.zIndex = wp, l;
      if (i.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, i), l.zIndex = wp, l;
      if (i.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, i), l.zIndex = wp, l;
    }
    return l;
  }
  afterFeatureUpdated(i) {
    if (this.selected.length && i.id === this.selected[0]) {
      var l, d;
      const h = this.flags[i.properties.mode];
      if (h == null || (l = h.feature) == null || !l.coordinates) return;
      const g = i.geometry.type, p = i.id;
      let o;
      if (this.selectionPoints.delete(), this.midPoints.delete(), g === "Polygon") o = i.geometry.coordinates[0];
      else {
        if (g !== "LineString") return;
        o = i.geometry.coordinates;
      }
      this.selectionPoints.create(o, g, p), h != null && (d = h.feature) != null && (d = d.coordinates) != null && d.midpoints && this.midPoints.create(g === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates, p, this.coordinatePrecision);
    }
  }
}
class CA extends Kp {
  constructor(...i) {
    super(...i), this.type = Yc.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return xi({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function tw(a, i, l, d, h) {
  for (; d > l; ) {
    if (d - l > 600) {
      const w = d - l + 1, S = i - l + 1, k = Math.log(w), I = 0.5 * Math.exp(2 * k / 3), z = 0.5 * Math.sqrt(k * I * (w - I) / w) * (S - w / 2 < 0 ? -1 : 1);
      tw(a, i, Math.max(l, Math.floor(i - S * I / w + z)), Math.min(d, Math.floor(i + (w - S) * I / w + z)), h);
    }
    const g = a[i];
    let p = l, o = d;
    for (vd(a, l, i), h(a[d], g) > 0 && vd(a, l, d); p < o; ) {
      for (vd(a, p, o), p++, o--; h(a[p], g) < 0; ) p++;
      for (; h(a[o], g) > 0; ) o--;
    }
    h(a[l], g) === 0 ? vd(a, l, o) : (o++, vd(a, o, d)), o <= i && (l = o + 1), i <= o && (d = o - 1);
  }
}
function vd(a, i, l) {
  const d = a[i];
  a[i] = a[l], a[l] = d;
}
function jc(a, i) {
  bd(a, 0, a.children.length, i, a);
}
function bd(a, i, l, d, h) {
  h || (h = qc([])), h.minX = 1 / 0, h.minY = 1 / 0, h.maxX = -1 / 0, h.maxY = -1 / 0;
  for (let g = i; g < l; g++) {
    const p = a.children[g];
    xd(h, a.leaf ? d(p) : p);
  }
  return h;
}
function xd(a, i) {
  return a.minX = Math.min(a.minX, i.minX), a.minY = Math.min(a.minY, i.minY), a.maxX = Math.max(a.maxX, i.maxX), a.maxY = Math.max(a.maxY, i.maxY), a;
}
function SA(a, i) {
  return a.minX - i.minX;
}
function kA(a, i) {
  return a.minY - i.minY;
}
function Rm(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function cp(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function PA(a, i) {
  const l = Math.max(a.minX, i.minX), d = Math.max(a.minY, i.minY), h = Math.min(a.maxX, i.maxX), g = Math.min(a.maxY, i.maxY);
  return Math.max(0, h - l) * Math.max(0, g - d);
}
function zm(a, i) {
  return a.minX <= i.minX && a.minY <= i.minY && i.maxX <= a.maxX && i.maxY <= a.maxY;
}
function up(a, i) {
  return i.minX <= a.maxX && i.minY <= a.maxY && i.maxX >= a.minX && i.maxY >= a.minY;
}
function qc(a) {
  return { children: a, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function z0(a, i, l, d, h) {
  const g = [i, l];
  for (; g.length; ) {
    if ((l = g.pop()) - (i = g.pop()) <= d) continue;
    const p = i + Math.ceil((l - i) / d / 2) * d;
    tw(a, p, i, l, h), g.push(i, p, p, l);
  }
}
class TA {
  constructor(i) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, i), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(i) {
    let l = this.data;
    const d = [];
    if (!up(i, l)) return d;
    const h = this.toBBox, g = [];
    for (; l; ) {
      for (let p = 0; p < l.children.length; p++) {
        const o = l.children[p], w = l.leaf ? h(o) : o;
        up(i, w) && (l.leaf ? d.push(o) : zm(i, w) ? this._all(o, d) : g.push(o));
      }
      l = g.pop();
    }
    return d;
  }
  collides(i) {
    let l = this.data;
    if (up(i, l)) {
      const d = [];
      for (; l; ) {
        for (let h = 0; h < l.children.length; h++) {
          const g = l.children[h], p = l.leaf ? this.toBBox(g) : g;
          if (up(i, p)) {
            if (l.leaf || zm(i, p)) return true;
            d.push(g);
          }
        }
        l = d.pop();
      }
    }
    return false;
  }
  load(i) {
    if (i.length < this._minEntries) {
      for (let d = 0; d < i.length; d++) this.insert(i[d]);
      return;
    }
    let l = this._build(i.slice(), 0, i.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const d = this.data;
        this.data = l, l = d;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(i) {
    this._insert(i, this.data.height - 1);
  }
  clear() {
    this.data = qc([]);
  }
  remove(i) {
    let l = this.data;
    const d = this.toBBox(i), h = [], g = [];
    let p, o, w = false;
    for (; l || h.length; ) {
      if (l || (l = h.pop(), o = h[h.length - 1], p = g.pop(), w = true), l.leaf) {
        const S = l.children.indexOf(i);
        S !== -1 && (l.children.splice(S, 1), h.push(l), this._condense(h));
      }
      w || l.leaf || !zm(l, d) ? o ? (p++, l = o.children[p], w = false) : l = null : (h.push(l), g.push(p), p = 0, o = l, l = l.children[0]);
    }
  }
  toBBox(i) {
    return i;
  }
  compareMinX(i, l) {
    return i.minX - l.minX;
  }
  compareMinY(i, l) {
    return i.minY - l.minY;
  }
  _all(i, l) {
    const d = [];
    for (; i; ) i.leaf ? l.push(...i.children) : d.push(...i.children), i = d.pop();
    return l;
  }
  _build(i, l, d, h) {
    const g = d - l + 1;
    let p, o = this._maxEntries;
    if (g <= o) return p = qc(i.slice(l, d + 1)), jc(p, this.toBBox), p;
    h || (h = Math.ceil(Math.log(g) / Math.log(o)), o = Math.ceil(g / Math.pow(o, h - 1))), p = qc([]), p.leaf = false, p.height = h;
    const w = Math.ceil(g / o), S = w * Math.ceil(Math.sqrt(o));
    z0(i, l, d, S, this.compareMinX);
    for (let k = l; k <= d; k += S) {
      const I = Math.min(k + S - 1, d);
      z0(i, k, I, w, this.compareMinY);
      for (let z = k; z <= I; z += w) {
        const R = Math.min(z + w - 1, I);
        p.children.push(this._build(i, z, R, h - 1));
      }
    }
    return jc(p, this.toBBox), p;
  }
  _chooseSubtree(i, l, d, h) {
    for (; h.push(l), !l.leaf && h.length - 1 !== d; ) {
      let o, w = 1 / 0, S = 1 / 0;
      for (let k = 0; k < l.children.length; k++) {
        const I = l.children[k], z = Rm(I), R = (g = i, p = I, (Math.max(p.maxX, g.maxX) - Math.min(p.minX, g.minX)) * (Math.max(p.maxY, g.maxY) - Math.min(p.minY, g.minY)) - z);
        R < S ? (S = R, w = z < w ? z : w, o = I) : R === S && z < w && (w = z, o = I);
      }
      l = o || l.children[0];
    }
    var g, p;
    return l;
  }
  _insert(i, l, d) {
    const h = d ? i : this.toBBox(i), g = [], p = this._chooseSubtree(h, this.data, l, g);
    for (p.children.push(i), xd(p, h); l >= 0 && g[l].children.length > this._maxEntries; ) this._split(g, l), l--;
    this._adjustParentBBoxes(h, g, l);
  }
  _split(i, l) {
    const d = i[l], h = d.children.length, g = this._minEntries;
    this._chooseSplitAxis(d, g, h);
    const p = this._chooseSplitIndex(d, g, h), o = qc(d.children.splice(p, d.children.length - p));
    o.height = d.height, o.leaf = d.leaf, jc(d, this.toBBox), jc(o, this.toBBox), l ? i[l - 1].children.push(o) : this._splitRoot(d, o);
  }
  _splitRoot(i, l) {
    this.data = qc([i, l]), this.data.height = i.height + 1, this.data.leaf = false, jc(this.data, this.toBBox);
  }
  _chooseSplitIndex(i, l, d) {
    let h, g = 1 / 0, p = 1 / 0;
    for (let o = l; o <= d - l; o++) {
      const w = bd(i, 0, o, this.toBBox), S = bd(i, o, d, this.toBBox), k = PA(w, S), I = Rm(w) + Rm(S);
      k < g ? (g = k, h = o, p = I < p ? I : p) : k === g && I < p && (p = I, h = o);
    }
    return h || d - l;
  }
  _chooseSplitAxis(i, l, d) {
    const h = i.leaf ? this.compareMinX : SA, g = i.leaf ? this.compareMinY : kA;
    this._allDistMargin(i, l, d, h) < this._allDistMargin(i, l, d, g) && i.children.sort(h);
  }
  _allDistMargin(i, l, d, h) {
    i.children.sort(h);
    const g = this.toBBox, p = bd(i, 0, l, g), o = bd(i, d - l, d, g);
    let w = cp(p) + cp(o);
    for (let S = l; S < d - l; S++) {
      const k = i.children[S];
      xd(p, i.leaf ? g(k) : k), w += cp(p);
    }
    for (let S = d - l - 1; S >= l; S--) {
      const k = i.children[S];
      xd(o, i.leaf ? g(k) : k), w += cp(o);
    }
    return w;
  }
  _adjustParentBBoxes(i, l, d) {
    for (let h = d; h >= 0; h--) xd(l[h], i);
  }
  _condense(i) {
    for (let l, d = i.length - 1; d >= 0; d--) i[d].children.length === 0 ? d > 0 ? (l = i[d - 1].children, l.splice(l.indexOf(i[d]), 1)) : this.clear() : jc(i[d], this.toBBox);
  }
}
class MA {
  constructor(i) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new TA(i && i.maxEntries ? i.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(i, l) {
    this.idToNode.set(i.id, l), this.nodeToId.set(l, i.id);
  }
  toBBox(i) {
    const l = [], d = [];
    let h;
    if (i.geometry.type === "Polygon") h = i.geometry.coordinates[0];
    else if (i.geometry.type === "LineString") h = i.geometry.coordinates;
    else {
      if (i.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      h = [i.geometry.coordinates];
    }
    for (let o = 0; o < h.length; o++) d.push(h[o][1]), l.push(h[o][0]);
    const g = Math.min(...d), p = Math.max(...d);
    return { minX: Math.min(...l), minY: g, maxX: Math.max(...l), maxY: p };
  }
  insert(i) {
    if (this.idToNode.get(String(i.id))) throw new Error("Feature already exists");
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  load(i) {
    const l = [], d = /* @__PURE__ */ new Set();
    i.forEach((h) => {
      const g = this.toBBox(h);
      if (this.setMaps(h, g), d.has(String(h.id))) throw new Error(`Duplicate feature ID found ${h.id}`);
      d.add(String(h.id)), l.push(g);
    }), this.tree.load(l);
  }
  update(i) {
    this.remove(i.id);
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  remove(i) {
    const l = this.idToNode.get(i);
    if (!l) throw new Error(`${i} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(i) {
    return this.tree.search(this.toBBox(i)).map((l) => this.nodeToId.get(l));
  }
  collides(i) {
    return this.tree.collides(this.toBBox(i));
  }
}
const IA = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
  const i = 16 * Math.random() | 0;
  return (a == "x" ? i : 3 & i | 8).toString(16);
}), isValidId: (a) => typeof a == "string" && a.length === 36 };
class EA {
  constructor(i) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new MA(), this.tracked = !i || i.tracked !== false, this.idStrategy = i && i.idStrategy ? i.idStrategy : IA;
  }
  clone(i) {
    return JSON.parse(JSON.stringify(i));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(i) {
    return !!this.store[i];
  }
  load(i, l, d, h) {
    if (i.length === 0) return [];
    let g = this.clone(i);
    const p = [], o = [];
    return g = g.filter((w) => {
      w.id == null && (w.id = this.idStrategy.getId());
      const S = w.id;
      if (l) {
        const k = l(w);
        if (!k.valid) return o.push({ id: S, valid: false, reason: k.reason }), false;
      }
      if (this.tracked) {
        if (w.properties.createdAt) {
          if (!x0(w.properties.createdAt)) return o.push({ id: w.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else w.properties.createdAt = +/* @__PURE__ */ new Date();
        if (w.properties.updatedAt) {
          if (!x0(w.properties.updatedAt)) return o.push({ id: w.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else w.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(S) ? (o.push({ id: S, valid: false, reason: `Feature already exists with this id: ${S}` }), false) : (this.store[S] = w, p.push(S), d && d(w), o.push({ id: S, valid: true }), true);
    }), this.spatialIndex.load(g), p.length > 0 && this._onChange(p, "create", h), o;
  }
  search(i, l) {
    const d = this.spatialIndex.search(i).map((h) => this.store[h]);
    return this.clone(l ? d.filter(l) : d);
  }
  registerOnChange(i) {
    this._onChange = (l, d, h) => {
      i(l, d, h);
    };
  }
  getGeometryCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(i, l) {
    const d = [];
    i.forEach(({ id: h, property: g, value: p }) => {
      const o = this.store[h];
      if (!o) throw new Error(`No feature with this (${h}), can not update geometry`);
      d.push(h), p === void 0 ? delete o.properties[g] : o.properties[g] = p, this.tracked && (o.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  updateGeometry(i, l) {
    const d = [];
    i.forEach(({ id: h, geometry: g }) => {
      d.push(h);
      const p = this.store[h];
      if (!p) throw new Error(`No feature with this (${h}), can not update geometry`);
      p.geometry = this.clone(g), this.spatialIndex.update(p), this.tracked && (p.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  create(i, l) {
    const d = [];
    return i.forEach(({ geometry: h, properties: g }) => {
      let p, o = xi({}, g);
      this.tracked && (p = +/* @__PURE__ */ new Date(), g ? (o.createdAt = typeof g.createdAt == "number" ? g.createdAt : p, o.updatedAt = typeof g.updatedAt == "number" ? g.updatedAt : p) : o = { createdAt: p, updatedAt: p });
      const w = this.getId(), S = { id: w, type: "Feature", geometry: h, properties: o };
      this.store[w] = S, this.spatialIndex.insert(S), d.push(w);
    }), this._onChange && this._onChange([...d], "create", l), d;
  }
  delete(i, l) {
    i.forEach((d) => {
      if (!this.store[d]) throw new Error(`No feature with id ${d}, can not delete`);
      delete this.store[d], this.spatialIndex.remove(d);
    }), this._onChange && this._onChange([...i], "delete", l);
  }
  copy(i) {
    return this.clone(this.store[i]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((i) => this.store[i]));
  }
  copyAllWhere(i) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && i(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class Nc {
  constructor({ name: i, callback: l, unregister: d, register: h }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = i, this.register = () => {
      this.registered || (this.registered = true, h(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, d(l));
    }, this.callback = l;
  }
}
var RA = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(a) {
    this._nextKeyUpIsContextMenu = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof a.minPixelDragDistance == "number" ? a.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof a.minPixelDragDistanceSelecting == "number" ? a.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof a.minPixelDragDistanceDrawing == "number" ? a.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof a.coordinatePrecision == "number" ? a.coordinatePrecision : 9;
  }
  getButton(a) {
    return a.button === -1 ? "neither" : a.button === 0 ? "left" : a.button === 1 ? "middle" : a.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(a) {
    const i = this.getMapEventElement(), { left: l, top: d } = i.getBoundingClientRect();
    return { containerX: a.clientX - l, containerY: a.clientY - d };
  }
  getDrawEventFromEvent(a, i = false) {
    const l = this.getLngLatFromEvent(a);
    if (!l) return null;
    const { lng: d, lat: h } = l, { containerX: g, containerY: p } = this.getMapElementXYPosition(a), o = this.getButton(a), w = Array.from(this._heldKeys);
    return { lng: Dn(d, this._coordinatePrecision), lat: Dn(h, this._coordinatePrecision), containerX: g, containerY: p, button: o, heldKeys: w, isContextMenu: i };
  }
  register(a) {
    this._currentModeCallbacks = a, this._listeners = this.getAdapterListeners(), this._listeners.forEach((i) => {
      i.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new Nc({ name: "pointerdown", callback: (a) => {
      if (!this._currentModeCallbacks || !a.isPrimary) return;
      const i = this.getDrawEventFromEvent(a);
      i && (this._dragState = "pre-dragging", this._lastDrawEvent = i);
    }, register: (a) => {
      this.getMapEventElement().addEventListener("pointerdown", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("pointerdown", a);
    } }), new Nc({ name: "pointermove", callback: (a) => {
      if (!this._currentModeCallbacks || !a.isPrimary) return;
      a.preventDefault();
      const i = this.getDrawEventFromEvent(a);
      if (i) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(i), this._lastDrawEvent = i;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, d = { x: i.containerX, y: i.containerY }, h = this._currentModeCallbacks.getState(), g = Us(l, d);
        let p = false;
        if (p = h === "drawing" ? g < this._minPixelDragDistanceDrawing : h === "selecting" ? g < this._minPixelDragDistanceSelecting : g < this._minPixelDragDistance, p) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(i, (o) => {
          this.setDraggability.bind(this)(o);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(i, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (a) => {
      this.getMapEventElement().addEventListener("pointermove", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("pointermove", a);
    } }), new Nc({ name: "contextmenu", callback: (a) => {
      this._currentModeCallbacks && (a.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (a) => {
      this.getMapEventElement().addEventListener("contextmenu", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("contextmenu", a);
    } }), new Nc({ name: "pointerup", callback: (a) => {
      if (!this._currentModeCallbacks || a.target !== this.getMapEventElement() || !a.isPrimary) return;
      const i = this.getDrawEventFromEvent(a);
      i && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(i, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (i.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(i)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (a) => {
      this.getMapEventElement().addEventListener("pointerup", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("pointerup", a);
    } }), new Nc({ name: "keyup", callback: (a) => {
      this._currentModeCallbacks && (this._heldKeys.delete(a.key), this._currentModeCallbacks.onKeyUp({ key: a.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => a.preventDefault() }));
    }, register: (a) => {
      this.getMapEventElement().addEventListener("keyup", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("keyup", a);
    } }), new Nc({ name: "keydown", callback: (a) => {
      this._currentModeCallbacks && (this._heldKeys.add(a.key), this._currentModeCallbacks.onKeyDown({ key: a.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => a.preventDefault() }));
    }, register: (a) => {
      this.getMapEventElement().addEventListener("keydown", a);
    }, unregister: (a) => {
      this.getMapEventElement().removeEventListener("keydown", a);
    } })];
  }
  unregister() {
    this._listeners.forEach((a) => {
      a.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
class zA {
  constructor(i) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = i.adapter, this._mode = new CA();
    const l = /* @__PURE__ */ new Set(), d = i.modes.reduce((k, I) => {
      if (l.has(I.mode)) throw new Error(`There is already a ${I.mode} mode provided`);
      return l.add(I.mode), k[I.mode] = I, k;
    }, {}), h = Object.keys(d);
    if (h.length === 0) throw new Error("No modes provided");
    h.forEach((k) => {
      if (d[k].type === Yc.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = k;
      }
    }), this._modes = xi({}, d, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new EA({ tracked: !!i.tracked, idStrategy: i.idStrategy ? i.idStrategy : void 0 });
    const g = (k) => {
      const I = [], z = this._store.copyAll().filter((R) => !k.includes(R.id) || (I.push(R), false));
      return { changed: I, unchanged: z };
    }, p = (k, I) => {
      this._enabled && this._eventListeners.finish.forEach((z) => {
        z(k, I);
      });
    }, o = (k, I, z) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((V) => {
        V(k, I, z);
      });
      const { changed: R, unchanged: O } = g(k);
      I === "create" ? this._adapter.render({ created: R, deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles()) : I === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: R }, this.getModeStyles()) : I === "delete" ? this._adapter.render({ created: [], deletedIds: k, unchanged: O, updated: [] }, this.getModeStyles()) : I === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles());
    }, w = (k) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((R) => {
        R(k);
      });
      const { changed: I, unchanged: z } = g([k]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: z, updated: I }, this.getModeStyles());
    }, S = (k) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((R) => {
        R();
      });
      const { changed: I, unchanged: z } = g([k]);
      I && this._adapter.render({ created: [], deletedIds: [], unchanged: z, updated: I }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((k) => {
      this._modes[k].register({ mode: k, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: o, onSelect: w, onDeselect: S, onFinish: p, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const i = {};
    return Object.keys(this._modes).forEach((l) => {
      i[l] = (d) => this._instanceSelectMode && d.properties[bi.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(d) : this._modes[l].styleFeature.bind(this._modes[l])(d);
    }), i;
  }
  featuresAtLocation({ lng: i, lat: l }, d) {
    const h = d && d.pointerDistance !== void 0 ? d.pointerDistance : 30, g = !d || d.ignoreSelectFeatures === void 0 || d.ignoreSelectFeatures, p = !(!d || d.ignoreCoordinatePoints === void 0) && d.ignoreCoordinatePoints, o = !(!d || d.ignoreCurrentlyDrawing === void 0) && d.ignoreCurrentlyDrawing, w = !(!d || d.ignoreClosingPoints === void 0) && d.ignoreClosingPoints, S = this._adapter.unproject.bind(this._adapter), k = this._adapter.project.bind(this._adapter), I = k(i, l), z = W1({ unproject: S, point: I, pointerDistance: h });
    return this._store.search(z).filter((R) => {
      if (g && (R.properties[bi.MID_POINT] || R.properties[bi.SELECTION_POINT]) || p && R.properties[pv] || w && R.properties[hv] || o && R.properties[dv]) return false;
      if (R.geometry.type === "Point") {
        const O = R.geometry.coordinates, V = k(O[0], O[1]);
        return Us(I, V) < h;
      }
      if (R.geometry.type === "LineString") {
        const O = R.geometry.coordinates;
        for (let V = 0; V < O.length - 1; V++) {
          const W = O[V], N = O[V + 1];
          if (gv(I, k(W[0], W[1]), k(N[0], N[1])) < h) return true;
        }
        return false;
      }
      if (K1([i, l], R.geometry.coordinates)) return true;
      if (d != null && d.includePolygonsWithinPointerDistance) {
        const O = R.geometry.coordinates;
        for (const V of O) for (let W = 0; W < V.length - 1; W++) {
          const N = V[W], K = V[W + 1], Z = k(N[0], N[1]), X = k(K[0], K[1]);
          if (gv(I, Z, X) < h) return true;
        }
      }
      return false;
    });
  }
  getSelectModeOrThrow() {
    const i = this.getSelectMode({ switchToSelectMode: true });
    if (!i) throw new Error("No select mode defined in instance");
    return i;
  }
  getSelectMode({ switchToSelectMode: i }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return i && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(i) {
    return !!(i.properties[bi.MID_POINT] || i.properties[bi.SELECTION_POINT] || i.properties[pv] || i.properties[U1]);
  }
  setModeStyles(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].styles = l;
  }
  updateModeOptions(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(i) {
    if (this._store.has(i)) return this._store.copy(i);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(i) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[i], this._mode.start();
  }
  removeFeatures(i) {
    this.checkEnabled();
    const l = [];
    i.forEach((d) => {
      if (!this._store.has(d)) throw new Error(`No feature with id ${d}, can not delete`);
      const h = this._store.copy(d);
      h.properties[bi.SELECTED] && this.deselectFeature(d), h.properties[Ep] && l.push(...h.properties[Ep]);
    }), this._store.delete([...i, ...l], { origin: "api" });
  }
  selectFeature(i) {
    this.getSelectModeOrThrow().selectFeature(i);
  }
  deselectFeature(i) {
    this.getSelectModeOrThrow().deselectFeature(i);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(i) {
    return this._store.has(i);
  }
  updateFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(d && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== d.geometry.type) throw new Error(`Geometry type mismatch: expected ${d.geometry.type}, got ${l.type}`);
    const h = d.properties.mode, g = this._modes[h];
    if (!g) throw new Error(`No mode with name ${h} present in instance`);
    const p = xi({}, d, { geometry: l }), o = g.validateFeature(p);
    if (!o.valid) throw new Error(`Feature validation failed: ${o.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: d.id, geometry: l }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(p);
      const w = p.properties[bi.SELECTED], S = this.getSelectMode({ switchToSelectMode: false });
      S && w && S.afterFeatureUpdated(p);
    }
  }
  transformFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    let d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const h = d.properties.mode, g = this._modes[h];
    if (!g) throw new Error(`No mode with name ${h} present in instance`);
    let p;
    if (d.geometry.type === "Polygon") p = d.geometry.coordinates[0];
    else {
      if (d.geometry.type !== "LineString") throw new Error(`Feature geometry type ${d.geometry.type} is not supported for transformation`);
      p = d.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: o, y: w } = An(l.origin[0], l.origin[1]);
      Q1({ coordinates: p, originX: o, originY: w, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (d = J1(d, l.options.angle || 0), p = d.geometry.type === "Polygon" ? d.geometry.coordinates[0] : d.geometry.coordinates);
    if (p = p.map((o) => [Dn(o[0], this._adapter.getCoordinatePrecision()), Dn(o[1], this._adapter.getCoordinatePrecision())]), d.geometry.coordinates = d.geometry.type === "Polygon" ? [p] : p, this._store.updateGeometry([{ id: d.id, geometry: d.geometry }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(d);
      const o = d.properties[bi.SELECTED], w = this.getSelectMode({ switchToSelectMode: false });
      w && o && w.afterFeatureUpdated(d);
    }
  }
  addFeatures(i) {
    return this.checkEnabled(), i.length === 0 ? [] : this._store.load(i, (l) => {
      if (b0(l)) {
        const d = l.properties.mode, h = this._modes[d];
        if (!h) return { id: l.id, valid: false, reason: `${d} mode is not in the list of instantiated modes` };
        const g = h.validateFeature.bind(h)(l);
        return { id: l.id, valid: g.valid, reason: g.reason ? g.reason : g.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (b0(l)) {
        const d = this._modes[l.properties.mode];
        d && d.afterFeatureAdded && d.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((i) => {
        i();
      });
    }, getState: () => this._mode.state, onClick: (i) => {
      this._mode.onClick(i);
    }, onMouseMove: (i) => {
      this._mode.onMouseMove(i);
    }, onKeyDown: (i) => {
      this._mode.onKeyDown(i);
    }, onKeyUp: (i) => {
      this._mode.onKeyUp(i);
    }, onDragStart: (i, l) => {
      this._mode.onDragStart(i, l);
    }, onDrag: (i, l) => {
      this._mode.onDrag(i, l);
    }, onDragEnd: (i, l) => {
      this._mode.onDragEnd(i, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(i, l) {
    const { lng: d, lat: h } = i;
    return this.featuresAtLocation({ lng: d, lat: h }, l);
  }
  getFeaturesAtPointerEvent(i, l) {
    const d = this._adapter.getLngLatFromEvent.bind(this._adapter)(i);
    return d === null ? [] : this.featuresAtLocation(d, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) || d.push(l);
  }
  off(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) && d.splice(d.indexOf(l), 1);
  }
}
const AA = ot({ __name: "MapContainer", props: { styleUrl: {}, geojsonSource: {}, drawerModes: {}, onMapInit: { type: Function }, onMapTouchStart: { type: Function }, onMapTouchEnd: { type: Function }, onMapClick: { type: Function } }, setup(a, { expose: i }) {
  const l = a, d = Ws(null), h = Ws(null), g = RS(), p = V1(), o = Ri();
  Kt([() => g.settings.mapLanguage, () => o.locale.value], (R) => {
    R && d.value && w(d.value, R[0] === "interface" ? R[1] : R[0]);
  });
  const w = (R, O) => {
    const V = O === "zh-CN" ? "zh" : "en", W = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const N of W) R.setLayoutProperty(N, "text-field", ["get", `name:${V}`]);
  };
  function S(R) {
    const O = R.getStyle().layers;
    let V;
    for (let W = 0; W < O.length; W++) {
      const N = O[W];
      if (N.type === "symbol" && N.layout && typeof N.layout == "object" && "text-field" in N.layout) {
        V = N.id;
        break;
      }
    }
    R.addLayer({ id: "3d-buildings", source: "openfreemap", "source-layer": "building", type: "fill-extrusion", minzoom: 15, filter: ["!=", ["get", "hide_3d"], true], paint: { "fill-extrusion-color": ["interpolate", ["linear"], ["get", "render_height"], 0, "lightgray", 200, "royalblue", 400, "lightblue"], "fill-extrusion-height": ["interpolate", ["linear"], ["zoom"], 15, 0, 16, ["get", "render_height"]], "fill-extrusion-base": ["case", [">=", ["get", "zoom"], 16], ["get", "render_min_height"], 0] } }, V);
  }
  function k(R) {
    R.removeLayer("3d-buildings");
  }
  function I(R) {
    var _a3, _b2;
    d.value = R.map, (_a3 = d.value) == null ? void 0 : _a3.addSource("openfreemap", { url: "https://tiles.openfreemap.org/planet", type: "vector" }), d.value && w(d.value, o.locale.value), p.isTrackingOrientation && (z(), z()), (_b2 = d.value) == null ? void 0 : _b2.on("click", l.onMapClick), l.onMapInit(R);
  }
  const z = /* @__PURE__ */ (() => {
    let R = null;
    return () => {
      var _a3;
      p.setTrackingOrientation(!p.isTrackingOrientation), p.isTrackingOrientation ? R = Ca.addHandler((O) => {
        var _a4, _b2, _c, _d2;
        if (p.isTrackingOrientation) {
          if (((_a4 = d.value) == null ? void 0 : _a4.isEasing()) || ((_b2 = d.value) == null ? void 0 : _b2.isMoving()) || ((_c = d.value) == null ? void 0 : _c.isRotating()) || ((_d2 = d.value) == null ? void 0 : _d2.isZooming())) return;
          p.setBearing(O);
        }
      }) : R !== null && (R = null, p.setBearing(0), (_a3 = d.value) == null ? void 0 : _a3.setBearing(0));
    };
  })();
  return i({ setupBuildingLayer: S, removeBuildingLayer: k, toggleOrientationTracking: z, map: d, draw: h }), (R, O) => (lt(), gr(Y(F1), { bearing: Y(p).bearing, "onUpdate:bearing": O[0] || (O[0] = (V) => Y(p).bearing = V), zoom: Y(p).zoom, "onUpdate:zoom": O[1] || (O[1] = (V) => Y(p).zoom = V), center: Y(p).center, "onUpdate:center": O[2] || (O[2] = (V) => Y(p).center = V), "map-style": R.styleUrl, height: "100%", "onMap:load": I, "onMap:touchstart": R.onMapTouchStart, "onMap:touchend": R.onMapTouchEnd }, { default: $e(() => [Re(Y(JR), { "source-id": "geojson", data: R.geojsonSource, "line-metrics": true }, { default: $e(() => [Re(Y(rz), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-gradient": ["interpolate", ["linear"], ["line-progress"], 0, "#00ff00", 0.7, "#00DD00", 0.9, "#00BB00", 1, "#008800"], "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"]), Dp(R.$slots, "default")]), _: 3 }, 8, ["bearing", "zoom", "center", "map-style", "onMap:touchstart", "onMap:touchend"]));
} }), DA = ot({ __name: "MapControls", setup(a) {
  return (i, l) => (lt(), $t("div", null, [Re(Y(B1), { position: "top-left" }), Re(Y(L1), { position: "top-left" }), Re(Y($1), { position: "bottom-left" })]));
} }), FA = jn(DA, [["__scopeId", "data-v-ad570dc0"]]), LA = ["title", "onClick"], BA = ot({ __name: "DrawingTools", props: { activeDrawMethod: {} }, emits: ["update:activeDrawMethod", "setDrawMode"], setup(a, { emit: i }) {
  const { t: l } = Ri(), h = new ru().isMobile, g = false, p = [{ mode: new X1(), name: l("trackerView.terraDrawTools.point"), icon: kv }, { mode: new H1(), name: l("trackerView.terraDrawTools.line"), icon: jx }, { mode: new ew({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: l("trackerView.terraDrawTools.select"), icon: $x }], o = a, w = i, S = (k) => {
    o.activeDrawMethod === k.mode ? (w("setDrawMode", "select"), w("update:activeDrawMethod", "select")) : (w("update:activeDrawMethod", k.mode), w("setDrawMode", k.mode));
  };
  return (k, I) => !Y(h) || g ? (lt(), gr(Y(Yp), { key: 0, position: "top-right" }, { default: $e(() => [(lt(), $t(qr, null, ti(p, (z) => mt("button", { key: z.name, class: Wo(["btn-control", { active: z.mode.mode === k.activeDrawMethod }]), title: z.name, onClick: (R) => S(z.mode) }, [Re(Y(xn), { size: 20 }, { default: $e(() => [(lt(), gr(eu(z.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, LA)), 64))]), _: 1 })) : Pr("", true);
} }), OA = jn(BA, [["__scopeId", "data-v-0c23bdfa"]]), $A = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20width='337pt'%20height='570pt'%20viewBox='0%200%20337%20570'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='%23010101ff'%3e%3c/g%3e%3cg%20id='%23fefefeff'%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20166.30%2034.31%20C%20170.55%2032.66%20175.49%2034.16%20177.91%2038.06%20C%20207.78%2088.56%20237.82%20138.97%20267.41%20189.64%20C%20272.78%20198.93%20278.71%20207.92%20283.33%20217.62%20C%20287.47%20225.84%20291.89%20234.58%20291.29%20244.05%20C%20290.88%20251.07%20284.88%20258.19%20277.33%20256.73%20C%20262.96%20252.68%20250.07%20244.73%20235.92%20240.03%20C%20214.99%20231.74%20192.42%20228.24%20170.00%20227.63%20C%20148.91%20228.22%20127.73%20231.43%20107.84%20238.63%20C%2092.90%20243.30%2079.32%20251.36%2064.47%20256.24%20C%2059.30%20258.15%2052.76%20255.48%2050.66%20250.31%20C%2046.78%20243.23%2049.19%20234.81%2051.89%20227.76%20C%2056.51%20217.17%2062.04%20206.98%2068.16%20197.18%20C%2098.26%20145.68%20128.69%2094.38%20159.14%2043.09%20C%20160.98%2039.80%20162.80%2036.10%20166.30%2034.31%20M%20165.46%2076.51%20C%20161.14%2084.39%20156.35%2091.99%20151.68%2099.66%20C%20146.23%20109.46%20140.40%20119.03%20134.68%20128.66%20C%20119.48%20155.09%20104.18%20181.47%2088.70%20207.74%20C%2086.55%20211.59%2083.58%20214.95%2081.76%20218.99%20C%2081.46%20221.46%2084.20%20221.79%2085.93%20221.02%20C%2093.56%20218.30%20100.92%20214.75%20108.82%20212.83%20C%20115.18%20211.22%20121.55%20209.66%20127.87%20207.89%20C%20150.73%20202.18%20174.79%20200.91%20198.04%20204.96%20C%20208.80%20206.29%20219.05%20209.99%20229.58%20212.41%20C%20237.78%20214.21%20245.35%20217.94%20253.21%20220.76%20C%20254.77%20221.45%20256.47%20221.24%20258.11%20221.06%20C%20258.49%20217.46%20255.67%20214.84%20254.00%20211.98%20C%20250.02%20205.59%20246.07%20199.18%20242.44%20192.58%20C%20220.66%20155.66%20199.60%20118.31%20177.40%2081.64%20C%20175.00%2077.57%20172.96%2073.26%20170.00%2069.54%20C%20168.29%2071.72%20166.77%2074.06%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20151.49%20254.95%20C%20168.99%20253.67%20186.81%20253.49%20204.06%20257.20%20C%20231.32%20262.97%20256.80%20276.81%20276.54%20296.49%20C%20293.71%20313.66%20306.14%20335.33%20313.41%20358.45%20C%20317.29%20371.60%20319.91%20385.24%20319.78%20398.99%20C%20321.35%20441.96%20301.66%20484.35%20269.99%20512.99%20C%20242.00%20538.39%20203.57%20551.09%20166.00%20549.73%20C%20133.58%20548.88%20101.34%20537.42%2076.23%20516.74%20C%2050.26%20494.62%2031.18%20463.95%2024.80%20430.27%20C%2021.58%20416.77%2021.93%20402.83%2022.47%20389.07%20C%2025.30%20359.23%2037.09%20330.28%2055.98%20306.99%20C%2079.44%20278.07%20114.56%20259.24%20151.49%20254.95%20M%20154.41%20286.41%20C%20133.59%20288.80%20113.47%20297.07%2096.91%20309.90%20C%2081.77%20321.39%2070.09%20337.09%2062.38%20354.40%20C%2053.40%20373.52%2050.49%20395.10%2052.40%20416.04%20C%2055.41%20439.33%2065.12%20461.74%2080.46%20479.57%20C%2096.06%20498.43%20118.19%20511.54%20141.99%20516.98%20C%20179.65%20526.00%20222.00%20516.17%20250.33%20489.33%20C%20272.99%20467.84%20287.59%20437.39%20288.11%20405.99%20C%20289.17%20369.33%20272.14%20332.49%20243.21%20309.87%20C%20231.81%20301.36%20219.11%20294.50%20205.43%20290.50%20C%20188.99%20285.41%20171.44%20284.58%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3cg%20id='%234da0e9ff'%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20165.46%2076.51%20C%20166.77%2074.06%20168.29%2071.72%20170.00%2069.54%20C%20172.96%2073.26%20175.00%2077.57%20177.40%2081.64%20C%20199.60%20118.31%20220.66%20155.66%20242.44%20192.58%20C%20246.07%20199.18%20250.02%20205.59%20254.00%20211.98%20C%20255.67%20214.84%20258.49%20217.46%20258.11%20221.06%20C%20256.47%20221.24%20254.77%20221.45%20253.21%20220.76%20C%20245.35%20217.94%20237.78%20214.21%20229.58%20212.41%20C%20219.05%20209.99%20208.80%20206.29%20198.04%20204.96%20C%20174.79%20200.91%20150.73%20202.18%20127.87%20207.89%20C%20121.55%20209.66%20115.18%20211.22%20108.82%20212.83%20C%20100.92%20214.75%2093.56%20218.30%2085.93%20221.02%20C%2084.20%20221.79%2081.46%20221.46%2081.76%20218.99%20C%2083.58%20214.95%2086.55%20211.59%2088.70%20207.74%20C%20104.18%20181.47%20119.48%20155.09%20134.68%20128.66%20C%20140.40%20119.03%20146.23%20109.46%20151.68%2099.66%20C%20156.35%2091.99%20161.14%2084.39%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20154.41%20286.41%20C%20171.44%20284.58%20188.99%20285.41%20205.43%20290.50%20C%20219.11%20294.50%20231.81%20301.36%20243.21%20309.87%20C%20272.14%20332.49%20289.17%20369.33%20288.11%20405.99%20C%20287.59%20437.39%20272.99%20467.84%20250.33%20489.33%20C%20222.00%20516.17%20179.65%20526.00%20141.99%20516.98%20C%20118.19%20511.54%2096.06%20498.43%2080.46%20479.57%20C%2065.12%20461.74%2055.41%20439.33%2052.40%20416.04%20C%2050.49%20395.10%2053.40%20373.52%2062.38%20354.40%20C%2070.09%20337.09%2081.77%20321.39%2096.91%20309.90%20C%20113.47%20297.07%20133.59%20288.80%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3c/svg%3e", jA = { style: { filter: "drop-shadow(0px 2px 4px #888)" } }, NA = ["src"], VA = ot({ __name: "LocationMarker", props: { isWatchingCurrentLocation: { type: Boolean }, deviceBearing: {} }, setup(a) {
  const i = hr("geolocation");
  return (l, d) => Y(i) && Y(i).isServiceRunning() && l.isWatchingCurrentLocation ? (lt(), gr(Y(XR), { key: 0, coordinates: Y(i).getLastKnownLocation().toLngLatLike() }, { marker: $e(() => [mt("div", jA, [mt("img", { src: Y($A), style: _i({ height: "4em", width: "4em", transform: `rotate(${l.deviceBearing}deg)`, "transform-origin": "2em 2.83em" }) }, null, 12, NA)])]), _: 1 }, 8, ["coordinates"])) : Pr("", true);
} }), UA = { style: { "font-family": "monospace", "padding-left": "8px" } }, qA = ot({ __name: "RecordingButton", props: { isRecording: { type: Boolean }, recordTimespan: {}, isRouteDrawerOpen: { type: Boolean } }, emits: ["toggleRecording"], setup(a, { emit: i }) {
  Pa((w) => {
    var _a3, _b2;
    return { "2835388b": (_a3 = Y(Sd).Button.common) == null ? void 0 : _a3.primaryColorSuppl, "6cac94de": (_b2 = Y(Sd).Button.common) == null ? void 0 : _b2.errorColorSuppl };
  });
  const { t: l } = Ri(), h = new ru().isMobile, g = false, p = i;
  function o(w) {
    const S = w / 1e3, k = S / 60, I = k / 60, z = S % 60, R = k % 60, O = I;
    let V = "";
    return Math.floor(O) > 0 && (V += `${String(Math.floor(O))}h `), Math.floor(R) > 0 && (V += `${String(Math.floor(R))}m `), V += `${String(z.toFixed(1)).padStart(4, "0")}s`, V;
  }
  return (w, S) => Y(h) || g ? (lt(), $t("div", { key: 0, class: Wo(["mobile-record-button-container", { "drawer-open": w.isRouteDrawerOpen }]) }, [Re(Y(Cx), { theme: Y(Sd) }, { default: $e(() => [Re(Y(jr), { type: w.isRecording ? "error" : "primary", size: "large", class: Wo(["mobile-record-button", w.isRecording ? "recording" : "not-recording"]), onClick: S[0] || (S[0] = (k) => p("toggleRecording")) }, { icon: $e(() => [Re(Y(xn), { size: 20 }, { default: $e(() => [(lt(), gr(eu(w.isRecording ? Y(mP) : Y(uP)), { size: w.isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: $e(() => [Cr(" " + Qt(w.isRecording ? Y(l)("trackerView.uiRecordingStatus.on") : Y(l)("trackerView.uiRecordingStatus.off")) + " ", 1), mt("p", UA, Qt(w.recordTimespan ? `(${o(w.recordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : Pr("", true);
} }), GA = jn(qA, [["__scopeId", "data-v-bcc27af9"]]), WA = ot({ __name: "BuildingLayerToggle", props: { isShowingBuildingLayer: { type: Boolean } }, emits: ["toggle"], setup(a, { emit: i }) {
  const l = i, d = () => {
    l("toggle");
  };
  return (h, g) => (lt(), gr(Y(Yp), { position: "top-left" }, { default: $e(() => [mt("button", { class: Wo(["btn-control", { active: h.isShowingBuildingLayer }]), onClick: d }, [Re(Y(xn), { size: 20 }, { default: $e(() => [Re(Y(Wk))]), _: 1 })], 2)]), _: 1 }));
} }), ZA = jn(WA, [["__scopeId", "data-v-c189f5ba"]]), HA = ot({ __name: "CurrentLocationToggle", props: { locator: {}, isWatchingCurrentLocation: { type: Boolean } }, emits: ["toggle"], setup(a, { emit: i }) {
  const d = new ru().isMobile, h = false, g = i, p = () => {
    g("toggle");
  };
  return (o, w) => (lt(), gr(Y(Yp), { position: "top-left" }, { default: $e(() => [Y(d) && o.locator.isUsingGPS() || h ? (lt(), $t("button", { key: 0, class: Wo(["btn-control", { active: o.isWatchingCurrentLocation }]), onClick: p }, [Re(Y(xn), { size: 20 }, { default: $e(() => [Re(Y(Yk))]), _: 1 })], 2)) : Pr("", true)]), _: 1 }));
} }), XA = jn(HA, [["__scopeId", "data-v-afaa8b50"]]);
class YA extends RA.TerraDrawBaseAdapter {
  constructor(i) {
    super(i), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = i.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = i.renderBelowLayerId, this._prefixId = i.prefixId || "td";
  }
  _addGeoJSONSource(i, l) {
    this._map.addSource(i, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(i) {
    return this._map.addLayer({ id: i + "-outline", source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(i, l) {
    l === "Point" && this._addPointLayer(i), l === "LineString" && this._addLineLayer(i), l === "Polygon" && (this._addFillLayer(i), this._addFillOutlineLayer(i));
  }
  _addGeoJSONLayer(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._addGeoJSONSource(d, l), this._addLayer(d, i), d;
  }
  _setGeoJSONLayerData(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._map.getSource(d).setData({ type: "FeatureCollection", features: l }), d;
  }
  updateChangedIds(i) {
    [...i.updated, ...i.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), i.deletedIds.length > 0 && (this.changedIds.deletion = true), i.created.length === 0 && i.updated.length === 0 && i.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(i) {
    const { left: l, top: d } = this._container.getBoundingClientRect();
    return this.unproject(i.clientX - l, i.clientY - d);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(i) {
    i ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(i, l) {
    const { x: d, y: h } = this._map.project({ lng: i, lat: l });
    return { x: d, y: h };
  }
  unproject(i, l) {
    const { lng: d, lat: h } = this._map.unproject({ x: i, y: l });
    return { lng: d, lat: h };
  }
  setCursor(i) {
    const l = this._map.getCanvas();
    i === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = i;
  }
  setDoubleClickToZoom(i) {
    i ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(i, l) {
    this.updateChangedIds(i), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const d = [...i.created, ...i.updated, ...i.unchanged], h = [], g = [], p = [];
      for (let k = 0; k < d.length; k++) {
        const I = d[k], { properties: z } = I, R = l[z.mode](I);
        I.geometry.type === "Point" ? (z.pointColor = R.pointColor, z.pointOutlineColor = R.pointOutlineColor, z.pointOutlineWidth = R.pointOutlineWidth, z.pointWidth = R.pointWidth, z.zIndex = R.zIndex, h.push(I)) : I.geometry.type === "LineString" ? (z.lineStringColor = R.lineStringColor, z.lineStringWidth = R.lineStringWidth, g.push(I)) : I.geometry.type === "Polygon" && (z.polygonFillColor = R.polygonFillColor, z.polygonFillOpacity = R.polygonFillOpacity, z.polygonOutlineColor = R.polygonOutlineColor, z.polygonOutlineWidth = R.polygonOutlineWidth, p.push(I));
      }
      const o = this.changedIds.deletion || this.changedIds.styling, w = o || this.changedIds.linestrings, S = o || this.changedIds.polygons;
      (o || this.changedIds.points) && this._setGeoJSONLayerData("Point", h), w && this._setGeoJSONLayerData("LineString", g), S && this._setGeoJSONLayerData("Polygon", p), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(i) {
    var l;
    super.register(i);
    const d = this._addGeoJSONLayer("Polygon", []), h = this._addGeoJSONLayer("LineString", []), g = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(g, this._renderBeforeLayerId), this._map.moveLayer(h, g), this._map.moveLayer(d + "-outline", h), this._map.moveLayer(d, h)), (l = this._currentModeCallbacks) != null && l.onReady && this._currentModeCallbacks.onReady();
  }
}
const KA = { class: "map-layout-container" }, JA = { class: "map-layout" }, QA = { key: 0, style: { width: "100%", height: "100%" } }, e3 = { style: { "z-index": "99", position: "absolute", right: "4px", top: "9em" } }, t3 = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, r3 = ot({ __name: "TrackerView", setup(a) {
  Pa((vt) => {
    var _a3;
    return { "711d3d66": (_a3 = Y(Sd).Button.common) == null ? void 0 : _a3.successColorSuppl, "022e29ef": Y(d).boxShadow3, "7a403d45": Y(d).borderRadius, "2c6efc50": Y(d).borderColor };
  });
  const l = new ru().isMobile, d = Sa(), h = V1(), g = Zp(), p = hr("geolocation"), { t: o } = Ri(), S = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", k = Ws(null), I = Ws(null), z = Me("select"), R = N1();
  R.setLocator(p);
  const O = hr("noSleep"), V = De(() => {
    var _a3;
    return R.currentRouteId ? ((_a3 = R.routes.find((jt) => jt.id === R.currentRouteId)) == null ? void 0 : _a3.points) || [] : [];
  }), W = Me(false), N = De(() => V.value.length > 1 || V.value.length === 0 ? { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: R.currentRouteId }, geometry: { type: "LineString", coordinates: V.value.map((vt) => [vt.longitude, vt.latitude]) } }] } : { type: "FeatureCollection", features: [] }), K = [{ mode: new X1(), name: o("trackerView.terraDrawTools.point"), icon: kv }, { mode: new H1(), name: o("trackerView.terraDrawTools.line"), icon: jx }, { mode: new ew({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: o("trackerView.terraDrawTools.select"), icon: $x }], Z = Me(false), X = Me(true), te = /* @__PURE__ */ (() => {
    let vt = true;
    return async function() {
      try {
        R.isRecording || (vt = R.currentRouteId === null), await R.toggleRecording(o), !R.isRecording && vt && (ve.value = true, setTimeout(() => {
          ve.value = false;
        }, 3e3)), R.isRecording ? O.enable() : O.disable();
      } catch (jt) {
        console.error(jt), O.disable();
      }
    };
  })(), q = Me(async () => {
  });
  function he() {
    Q.value = false, g.warning("Not implemented yet");
  }
  const se = Me(0), Q = Me(false);
  Kt(Q, (vt) => {
    var _a3;
    const jt = (_a3 = k.value) == null ? void 0 : _a3.map;
    jt && jt.easeTo({ padding: l ? { bottom: vt ? se.value : 0 } : { left: vt ? se.value : 0 }, duration: 500 });
  });
  const oe = () => Q.value = !Q.value, ve = Me(false), Be = Me(false), Ne = Me(0), Pe = Me(false);
  Tn(async () => {
    if (await R.init(), await h.init(), Date.now() - h.lastUpdateTime > 6e3 && h.lastUpdateTime !== 0) {
      const vt = p.getLastKnownLocation();
      vt.latitude !== 0 || vt.longitude !== 0 ? h.setCenter(vt) : console.warn("[TrackerView] No valid last known location available, skipping map center update");
    }
    Ca.addHandler((vt) => {
      Ne.value = vt;
    }), Ca.start(), Be.value = true;
  });
  const tt = false;
  let at = 0;
  const xt = (vt) => {
    var _a3;
    if (at = vt, h.isTrackingOrientation) {
      const jt = (_a3 = k.value) == null ? void 0 : _a3.map;
      if ((jt == null ? void 0 : jt.isEasing()) || (jt == null ? void 0 : jt.isMoving()) || (jt == null ? void 0 : jt.isRotating()) || (jt == null ? void 0 : jt.isZooming()) || Pe.value) return;
      h.setBearing(vt);
    }
  }, ht = /* @__PURE__ */ (() => {
    let vt = null;
    return () => {
      var _a3;
      if (h.setTrackingOrientation(!h.isTrackingOrientation), h.isTrackingOrientation) vt = Ca.addHandler(xt);
      else if (vt !== null) {
        vt = null, h.setBearing(0);
        const jt = (_a3 = k.value) == null ? void 0 : _a3.map;
        jt && jt.setBearing(0);
      }
    };
  })(), Ye = (vt) => {
    I.value = new zA({ adapter: new YA({ map: vt.map }), modes: K.map((jt) => jt.mode) }), I.value.start();
  }, Ke = () => {
    Pe.value = true;
  }, Lt = () => {
    Pe.value = false, h.isTrackingOrientation && xt(at);
  }, ct = () => {
    Q.value = false;
  }, bt = (vt) => {
    I.value && (vt === "select" ? (I.value.setMode("select"), z.value = "select") : (z.value = vt, I.value.start(), I.value.setMode(vt)));
  }, Nt = () => {
    var _a3;
    if (X.value = !X.value, X.value) {
      const vt = (_a3 = k.value) == null ? void 0 : _a3.map;
      if (vt) {
        const jt = p.getLastKnownLocation();
        jt.latitude !== 0 || jt.longitude !== 0 ? vt.flyTo({ center: jt.toLngLatLike(), zoom: 18 }) : console.warn("[TrackerView] No valid current location available for navigation");
      }
    }
  }, Yt = () => {
    var _a3, _b2, _c;
    Z.value = !Z.value;
    const vt = (_a3 = k.value) == null ? void 0 : _a3.map;
    vt && (Z.value ? (_b2 = k.value) == null ? void 0 : _b2.setupBuildingLayer(vt) : (_c = k.value) == null ? void 0 : _c.removeBuildingLayer(vt));
  };
  return (vt, jt) => (lt(), $t("div", KA, [mt("div", JA, [Re(Ro, { name: "map-load" }, { default: $e(() => [Be.value ? (lt(), $t("div", QA, [Re(AA, { ref_key: "mapContainerRef", ref: k, "style-url": S, "geojson-source": N.value, "drawer-modes": K, "on-map-init": Ye, "on-map-touch-start": Ke, "on-map-touch-end": Lt, "on-map-click": ct }, { default: $e(() => [Re(FA), Re(XA, { locator: Y(p), "is-watching-current-location": X.value, onToggle: Nt }, null, 8, ["locator", "is-watching-current-location"]), Re(ZA, { "is-showing-building-layer": Z.value, onToggle: Yt }, null, 8, ["is-showing-building-layer"]), Re(OA, { "active-draw-method": z.value, "onUpdate:activeDrawMethod": jt[0] || (jt[0] = (er) => z.value = er), onSetDrawMode: bt }, null, 8, ["active-draw-method"]), Re(Y(Yp), { position: "bottom-left" }, { default: $e(() => [Re(Y(bv), { trigger: "manual", show: ve.value }, { trigger: $e(() => [mt("button", { class: Wo(["btn-control", { active: Q.value }]), onClick: oe }, [Re(Y(xn), { size: 24 }, { default: $e(() => [Re(Y(Pv))]), _: 1 })], 2)]), default: $e(() => [mt("span", null, Qt(Y(o)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), Re(VA, { "is-watching-current-location": X.value, "device-bearing": Ne.value }, null, 8, ["is-watching-current-location", "device-bearing"])]), _: 1 }, 8, ["geojson-source"]), mt("div", e3, [Y(l) || tt ? (lt(), gr(oz, { key: 0, bearing: Y(h).bearing, "onUpdate:bearing": jt[1] || (jt[1] = (er) => Y(h).bearing = er), tracking: Y(h).isTrackingOrientation, onToggleTracking: Y(ht) }, null, 8, ["bearing", "tracking", "onToggleTracking"])) : Pr("", true)])])) : (lt(), $t("div", t3, [Re(Y(QE), { size: "large" }, { description: $e(() => [Re(Y($s), null, { default: $e(() => [Cr(Qt(Y(o)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 })]))]), _: 1 })]), Re(xz, { show: W.value, "onUpdate:show": jt[2] || (jt[2] = (er) => W.value = er), types: ["application/json", "text/plain"], onConfirm: q.value }, null, 8, ["show", "onConfirm"]), Re(Uz, { show: Q.value, "onUpdate:show": jt[3] || (jt[3] = (er) => Q.value = er), "onUpdate:width": jt[4] || (jt[4] = (er) => se.value = er) }, { "bottom-floating": $e(() => [Re(Y(Cx), { theme: Y(Sd) }, { default: $e(() => [V.value.length > 1 ? (lt(), gr(Y(jr), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: he }, { default: $e(() => [...jt[5] || (jt[5] = [Cr(" Follow ", -1)])]), _: 1 })) : Pr("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), Re(GA, { "is-recording": Y(R).isRecording, "record-timespan": Y(R).currentRouteRecordTimespan, "is-route-drawer-open": Q.value, onToggleRecording: Y(te) }, null, 8, ["is-recording", "record-timespan", "is-route-drawer-open", "onToggleRecording"])]));
} }), rw = jn(r3, [["__scopeId", "data-v-9b2adda5"]]), n3 = Object.freeze(Object.defineProperty({ __proto__: null, default: rw }, Symbol.toStringTag, { value: "Module" })), i3 = { class: "container" }, o3 = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, s3 = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, a3 = { style: { "font-weight": "500" } }, l3 = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, c3 = ot({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(a, { emit: i }) {
  const { t: l } = Ri(), d = a, h = i;
  function g(o) {
    h("select", o);
  }
  function p(o) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && h("remove", o);
  }
  return (o, w) => (lt(), $t("div", i3, [Re(Y(Ud), { class: "select-listview", hoverable: "" }, { default: $e(() => [(lt(true), $t(qr, null, ti(d.list, (S) => (lt(), gr(Y(qd), { key: S.id, title: S.name, onClick: (k) => g(S.id) }, { prefix: $e(() => [mt("div", o3, [Re(Y(xn), { size: "20" }, { default: $e(() => [Re(Y(Nx))]), _: 1 })])]), suffix: $e(() => [Re(Y(jr), { quaternary: "", circle: "", onClick: Id((k) => p(S.id), ["stop"]) }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(qp))]), _: 1 })]), _: 2 }, 1032, ["onClick"])]), default: $e(() => [mt("div", s3, [mt("div", a3, Qt(S.name), 1), mt("div", l3, [(lt(true), $t(qr, null, ti(S.tags, (k) => (lt(), gr(Y(bo), { key: k, size: "small", type: "info" }, { default: $e(() => [Cr(Qt(k.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), u3 = jn(c3, [["__scopeId", "data-v-dc2c6049"]]), d3 = ot({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(a, { emit: i }) {
  const { t: l } = Ri(), d = a, h = [{ title: l("sketchEdit.import"), icon: Vx, callback: () => {
    o("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Ad, callback: () => o("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: lP, callback: () => {
    g.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], g = Me(false), p = Me(d.placement);
  Kt(d, () => {
    g.value = d.active, p.value = d.placement;
  }, { deep: true }), Kt(g, () => {
    o("update:active", g.value);
  });
  const o = i;
  return (w, S) => (lt(), gr(Y(u1), { show: g.value, "onUpdate:show": S[2] || (S[2] = (k) => g.value = k), width: 502, placement: p.value, "auto-focus": false }, { default: $e(() => [Re(Y(d1), { title: Y(l)("sketchEdit.cartoSketchLibrary") }, { footer: $e(() => [Re(Y(vM), null, { default: $e(() => [(lt(), $t(qr, null, ti(h, (k) => Re(Y(jr), { key: k.title, secondary: k.secondary, type: k.type, title: k.title, onClick: k.callback }, { icon: $e(() => [Re(Y(xn), { size: k.iconSize }, { default: $e(() => [(lt(), gr(eu(k.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: $e(() => [Re(u3, { list: a.list, onRemove: S[0] || (S[0] = (k) => o("remove", k)), onSelect: S[1] || (S[1] = (k) => o("select", k)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), h3 = ["title", "onClick"], dp = 20, p3 = ot({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(a, { emit: i }) {
  const { t: l } = Ri(), d = i, h = [{ title: l("sketchEdit.save"), icon: Jk, iconSize: dp, callback: () => d("save") }, { title: l("sketchEdit.open"), icon: nP, iconSize: dp, callback: () => d("open") }, { title: l("sketchEdit.newComponent"), icon: Ad, iconSize: dp, callback: () => d("create") }, { title: l("sketchEdit.editMetadata"), icon: zS, iconSize: dp, callback: () => d("edit-meta") }];
  return (g, p) => (lt(), gr(Y(G_), { justify: "space-between", align: "center" }, { default: $e(() => [Re(Y($s), { strong: "" }, { default: $e(() => [Cr(Qt(g.sketchName || Y(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), Re(Y(G_), { align: "center" }, { default: $e(() => [g.sketchName !== void 0 ? (lt(), gr(Y(bo), { key: 0, type: "info", size: "small" }, { default: $e(() => [Cr(Qt(g.draftCount || 0) + " " + Qt(Y(l)("sketchEdit.drafts")) + ", " + Qt(g.routeCount || 0) + " " + Qt(Y(l)("sketchEdit.routes")), 1)]), _: 1 })) : Pr("", true), (lt(), $t(qr, null, ti(h, (o, w) => mt("div", { key: w, title: o.title, class: "tool-tip-item", onClick: o.callback }, [Re(Y(xn), { size: o.iconSize }, { default: $e(() => [(lt(), gr(eu(o.icon)))]), _: 2 }, 1032, ["size"])], 8, h3)), 64))]), _: 1 })]), _: 1 }));
} }), f3 = jn(p3, [["__scopeId", "data-v-5b012717"]]), m3 = { key: 0, class: "empty-state" }, g3 = ot({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(a, { emit: i }) {
  const { t: l } = Ri(), d = i;
  return (h, g) => (lt(), $t(qr, null, [Re(Y(Ud), { hoverable: "" }, { default: $e(() => [(lt(true), $t(qr, null, ti(h.components, (p) => (lt(), gr(Y(qd), { key: p.value, class: Wo({ "selected-component": h.selectedId === p.value }), onClick: () => d("select", p.value, p.type) }, { prefix: $e(() => [Re(Y(xn), { color: p.type === "draft" ? "#007bff" : "#28a745" }, { default: $e(() => [(lt(), gr(eu(p.type === "draft" ? Y(Nx) : Y(Pv))))]), _: 2 }, 1032, ["color"])]), suffix: $e(() => [Re(Y(NE), { onPositiveClick: (o) => d("delete", p.value, p.type) }, { trigger: $e(() => [Re(Y(jr), { quaternary: "", circle: "", size: "small" }, { default: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(qp))]), _: 1 })]), _: 1 })]), default: $e(() => [Cr(" " + Qt(Y(l)("sketchEdit.deleteComponent")), 1)]), _: 2 }, 1032, ["onPositiveClick"])]), default: $e(() => [Cr(" " + Qt(p.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), h.components.length === 0 ? (lt(), $t("div", m3, [Re(Y(Dd), { description: Y(l)("sketchEdit.noComponentsYet") }, { extra: $e(() => [Re(Y(jr), { size: "small", onClick: g[0] || (g[0] = (p) => d("create")) }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : Pr("", true)], 64));
} }), v3 = jn(g3, [["__scopeId", "data-v-3addb8a0"]]), y3 = { key: 0, class: "properties-panel" }, _3 = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, b3 = ot({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(a, { emit: i }) {
  const { t: l } = Ri(), d = i;
  return (h, g) => h.component ? (lt(), $t("div", y3, [Re(Y(cR), { type: "line", animated: "", "default-value": "properties" }, { default: $e(() => [Re(Y(l0), { name: "properties", tab: Y(l)("sketchEdit.properties") }, { default: $e(() => [Re(Y(Ld), null, { default: $e(() => [Re(Y(yi), { label: Y(l)("sketchEdit.visible") }, { default: $e(() => [Re(Y(S1), { value: h.component.properties.visible !== false, "onUpdate:value": g[0] || (g[0] = (p) => d("updateProperties", { visible: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), h.type === "draft" ? (lt(), $t(qr, { key: 0 }, [Re(Y(yi), { label: Y(l)("sketchEdit.fillColor") }, { default: $e(() => [Re(Y(bm), { value: h.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": g[1] || (g[1] = (p) => d("updateProperties", { fillColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.strokeColor") }, { default: $e(() => [Re(Y(bm), { value: h.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": g[2] || (g[2] = (p) => d("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.strokeThickness") }, { default: $e(() => [Re(Y(i0), { value: h.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": g[3] || (g[3] = (p) => d("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Pr("", true), h.type === "route" ? (lt(), $t(qr, { key: 1 }, [Re(Y(yi), { label: Y(l)("sketchEdit.strokeColor") }, { default: $e(() => [Re(Y(bm), { value: h.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": g[4] || (g[4] = (p) => d("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.strokeThickness") }, { default: $e(() => [Re(Y(i0), { value: h.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": g[5] || (g[5] = (p) => d("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Pr("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), Re(Y(l0), { name: "metadata", tab: Y(l)("sketchEdit.metadata") }, { default: $e(() => [Re(Y(Ld), null, { default: $e(() => [Re(Y(yi), { label: Y(l)("sketchEdit.name") }, { default: $e(() => [Re(Y(yo), { value: h.component.meta.name, "onUpdate:value": g[6] || (g[6] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: p, description: ((_a3 = h.component) == null ? void 0 : _a3.meta.description) ?? "", tags: ((_b2 = h.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.description") }, { default: $e(() => [Re(Y(yo), { value: h.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": g[7] || (g[7] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = h.component) == null ? void 0 : _a3.meta.name) ?? "", description: p, tags: ((_b2 = h.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.tags") }, { default: $e(() => [Re(Y(RI), { value: h.component.meta.tags || [], placeholder: Y(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": g[8] || (g[8] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = h.component) == null ? void 0 : _a3.meta.name) ?? "", description: ((_b2 = h.component) == null ? void 0 : _b2.meta.description) ?? "", tags: p });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: "UUID" }, { default: $e(() => [Re(Y(yo), { value: h.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (lt(), $t("div", _3, [Re(Y(Dd), { description: Y(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), x3 = jn(b3, [["__scopeId", "data-v-f700b4bc"]]), w3 = "dCeXFrS9lgSF8hm5C6nm", C3 = `https://api.maptiler.com/maps/basic-v2/style.json?key=${w3}`;
function S3() {
  const a = Me(7), i = Ws(null), l = Me([0, 0]);
  function d(p) {
    i.value = p.map;
  }
  function h(p) {
    l.value = p, i.value && i.value.setCenter(p);
  }
  function g(p) {
    a.value = p, i.value && i.value.setZoom(p);
  }
  return { zoom: a, map: i, center: l, styleUrl: C3, initMap: d, setCenter: h, setZoom: g };
}
function k3(a, i) {
  const l = [];
  return a.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "draft" });
  }), i.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "route" });
  }), l;
}
function P3() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function T3() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function M3() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const I3 = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, E3 = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, R3 = { class: "sketch-edit-container" }, z3 = { class: "grid-layout" }, A3 = { class: "meta-info-section" }, D3 = { class: "metadata-item" }, F3 = { class: "metadata-item" }, L3 = ot({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(a) {
  const i = a, { t: l } = Ri(), d = Zp(), h = Fv(), { zoom: g, styleUrl: p, initMap: o } = S3(), w = Me(false), S = Me(null), k = Me(null), I = Me(false), z = Me(""), R = Me("draft"), O = Me(false), V = Me({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), W = Me(""), N = De(() => h.currentSketch), K = De(() => h.currentDrafts), Z = De(() => {
    var _a3;
    return ((_a3 = N.value) == null ? void 0 : _a3.routes.routes) || [];
  }), X = De(() => !!N.value), te = De(() => !S.value || !k.value ? null : k.value === "draft" ? h.getDraftById(S.value) : h.getRouteById(S.value)), q = De(() => k3(K.value, Z.value));
  async function he() {
    if (N.value) try {
      await h.updateSketch(N.value.id, { name: N.value.meta.name, description: N.value.meta.description, tags: N.value.meta.tags }), d.success(l("sketchEdit.saveSuccess"));
    } catch (ht) {
      d.error(l("sketchEdit.saveError")), console.error(ht);
    }
  }
  async function se() {
    const ht = prompt(l("sketchEdit.enterSketchName"));
    ht && (await h.createSketch(ht), w.value = false);
  }
  async function Q() {
    if (!(!z.value.trim() || !N.value)) try {
      if (R.value === "draft") {
        const ht = await h.addDraft(P3(), T3(), { name: z.value });
        S.value = ht.id, k.value = "draft";
      } else {
        const ht = await h.addRoute(z.value, M3());
        S.value = ht.id, k.value = "route";
      }
      I.value = false, z.value = "", d.success(l("sketchEdit.componentCreated"));
    } catch (ht) {
      d.error(l("sketchEdit.componentCreateError")), console.error(ht);
    }
  }
  async function oe(ht, Ye) {
    try {
      Ye === "draft" ? await h.deleteDraft(ht) : await h.deleteRoute(ht), S.value === ht && (S.value = null, k.value = null), d.success(l("sketchEdit.componentDeleted"));
    } catch (Ke) {
      d.error(l("sketchEdit.componentDeleteError")), console.error(Ke);
    }
  }
  async function ve(ht) {
    if (!(!te.value || !k.value)) try {
      k.value === "draft" ? await h.updateDraft(S.value, { properties: ht }) : await h.updateRoute(S.value, { properties: ht }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (Ye) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(Ye);
    }
  }
  async function Be(ht) {
    if (!(!te.value || !k.value)) try {
      k.value === "draft" ? await h.updateDraft(S.value, { meta: ht }) : await h.updateRoute(S.value, { name: ht.name }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (Ye) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(Ye);
    }
  }
  function Ne() {
    N.value && (V.value = { name: N.value.meta.name, description: N.value.meta.description, tags: [...N.value.meta.tags], created_by: N.value.meta.created_by, modified_by: N.value.meta.modified_by }, O.value = true);
  }
  function Pe() {
    W.value.trim() && !V.value.tags.includes(W.value.trim()) && (V.value.tags.push(W.value.trim()), W.value = "");
  }
  function tt(ht) {
    V.value.tags = V.value.tags.filter((Ye) => Ye !== ht);
  }
  async function at() {
    if (N.value) try {
      await h.updateSketch(N.value.id, { name: V.value.name, description: V.value.description, tags: V.value.tags }), O.value = false, d.success(l("sketchEdit.saveSuccess"));
    } catch (ht) {
      d.error(l("sketchEdit.saveError")), console.error(ht);
    }
  }
  Tn(() => {
    i.sketchId && h.setCurrentSketchId(i.sketchId);
  }), Kt(() => h.currentSketchId, (ht) => {
    ht && (S.value = null, k.value = null);
  });
  const xt = (ht) => new Date(ht).toLocaleString();
  return (ht, Ye) => (lt(), $t(qr, null, [Re(d3, { active: w.value, "onUpdate:active": Ye[0] || (Ye[0] = (Ke) => w.value = Ke), list: Y(h).sketches.map((Ke) => ({ id: Ke.id, name: Ke.meta.name, tags: Ke.meta.tags })), placement: "right", onNew: se, onRemove: Ye[1] || (Ye[1] = (Ke) => Y(h).deleteSketch(Ke)), onSelect: Ye[2] || (Ye[2] = (Ke) => Y(h).setCurrentSketchId(Ke)) }, null, 8, ["active", "list"]), Re(Y(zd), { show: I.value, "onUpdate:show": Ye[6] || (Ye[6] = (Ke) => I.value = Ke), preset: "dialog", title: Y(l)("sketchEdit.createNewComponent") }, { action: $e(() => [Re(Y(jr), { onClick: Ye[5] || (Ye[5] = (Ke) => I.value = false) }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.cancel")), 1)]), _: 1 }), Re(Y(jr), { type: "primary", disabled: !z.value.trim(), onClick: Q }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: $e(() => [Re(Y(Ld), null, { default: $e(() => [mt("div", I3, [Re(Y(yi), { label: Y(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: $e(() => [Re(Y(yo), { value: z.value, "onUpdate:value": Ye[3] || (Ye[3] = (Ke) => z.value = Ke), placeholder: Y(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.type") }, { default: $e(() => [Re(Y(ev), { value: R.value, "onUpdate:value": Ye[4] || (Ye[4] = (Ke) => R.value = Ke), "consistent-menu-width": false, options: [{ label: Y(l)("sketchEdit.draftShape"), value: "draft" }, { label: Y(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), Re(Y(zd), { show: O.value, "onUpdate:show": Ye[11] || (Ye[11] = (Ke) => O.value = Ke), preset: "dialog", title: Y(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: $e(() => [Re(Y(jr), { onClick: Ye[10] || (Ye[10] = (Ke) => O.value = false) }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.cancel")), 1)]), _: 1 }), Re(Y(jr), { type: "primary", disabled: !V.value.name.trim(), onClick: at }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: $e(() => [Re(Y(Ld), null, { default: $e(() => [Re(Y(yi), { label: Y(l)("sketchEdit.name") }, { default: $e(() => [Re(Y(yo), { value: V.value.name, "onUpdate:value": Ye[7] || (Ye[7] = (Ke) => V.value.name = Ke), placeholder: Y(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.description") }, { default: $e(() => [Re(Y(yo), { value: V.value.description, "onUpdate:value": Ye[8] || (Ye[8] = (Ke) => V.value.description = Ke), type: "textarea", placeholder: Y(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(l)("sketchEdit.tags") }, { default: $e(() => [mt("div", E3, [Re(Y(yo), { value: W.value, "onUpdate:value": Ye[9] || (Ye[9] = (Ke) => W.value = Ke), placeholder: Y(l)("sketchEdit.addTagPlaceholder"), onKeydown: Jb(Id(Pe, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), Re(Y(jr), { onClick: Pe }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.add")), 1)]), _: 1 })]), (lt(true), $t(qr, null, ti(V.value.tags, (Ke) => (lt(), gr(Y(bo), { key: Ke, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: (Lt) => tt(Ke) }, { default: $e(() => [Cr(Qt(Ke), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), V.value.tags.length === 0 ? (lt(), gr(Y(Dd), { key: 0, description: Y(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : Pr("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), mt("div", R3, [mt("div", z3, [mt("div", A3, [Re(Y(vo), null, { default: $e(() => {
    var _a3;
    return [Re(f3, { "sketch-name": (_a3 = N.value) == null ? void 0 : _a3.meta.name, "draft-count": K.value.length, "route-count": Z.value.length, onSave: he, onOpen: Ye[12] || (Ye[12] = (Ke) => w.value = true), onCreate: Ye[13] || (Ye[13] = (Ke) => I.value = true), onEditMeta: Ne }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), Re(Y(a0), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: $e(() => [Re(Y(a0), { style: { height: "100%" }, direction: "vertical" }, { 1: $e(() => [Re(Y(vo), { style: { height: "100%" }, title: Y(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": $e(() => [Re(Y(jr), { quaternary: "", circle: "", onClick: Ye[16] || (Ye[16] = (Ke) => I.value = true) }, { icon: $e(() => [Re(Y(Ad))]), _: 1 })]), default: $e(() => [Re(v3, { components: q.value, "selected-id": S.value, onSelect: Ye[14] || (Ye[14] = (Ke, Lt) => {
    S.value = Ke, k.value = Lt;
  }), onDelete: oe, onCreate: Ye[15] || (Ye[15] = (Ke) => I.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: $e(() => [Re(Y(vo), { class: "map-container", "content-style": "padding: 0;" }, { default: $e(() => [Re(Y(F1), { "map-style": Y(p), center: [0, 0], zoom: Y(g), height: "100%", "onMap:load": Y(o) }, { default: $e(() => [Re(Y(B1), { position: "top-left" }), Re(Y($1), { position: "bottom-left" }), Re(Y(L1), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), X.value ? Pr("", true) : (lt(), gr(Y(Dd), { key: 0, description: Y(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(AS))]), _: 1 })]), extra: $e(() => [Re(Y(jr), { size: "small", onClick: Ye[17] || (Ye[17] = (Ke) => w.value = true) }, { default: $e(() => [Cr(Qt(Y(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: $e(() => [Re(Y(vo), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: $e(() => [te.value ? (lt(), gr(Y($s), { key: 0, depth: "3", class: "metadata" }, { default: $e(() => [mt("div", D3, Qt(Y(l)("sketchEdit.createdTimeBy", { user: te.value.meta.created_by, time: xt(te.value.meta.creation_timestamp) })), 1), mt("div", F3, Qt(Y(l)("sketchEdit.modifiedTimeBy", { user: te.value.meta.modified_by, time: xt(te.value.meta.modification_timestamp) })), 1)]), _: 1 })) : Pr("", true)]), default: $e(() => [Re(x3, { component: te.value, type: k.value, onUpdateProperties: ve, onUpdateMeta: Ye[18] || (Ye[18] = (Ke) => Be(Ke)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), B3 = jn(L3, [["__scopeId", "data-v-b8cdd1f5"]]), O3 = { class: "sketch-centre-view" }, $3 = { class: "header" }, j3 = { class: "title" }, N3 = { class: "card-header" }, V3 = { key: 0, class: "tags" }, U3 = { class: "card-content" }, q3 = { class: "meta-info" }, G3 = { class: "meta-item" }, W3 = { class: "meta-item" }, Z3 = { class: "meta-item" }, H3 = { key: 0, class: "empty-state" }, X3 = ot({ __name: "SketchCentreView", setup(a) {
  Pa((Q) => ({ "460cb2d9": Y(se).bodyColor }));
  const { t: i } = Ri(), l = l1(), d = Zp(), h = Sa(), g = Fv(), p = De(() => g.sketches), o = De({ get: () => g.currentSketchId, set: (Q) => g.setCurrentSketchId(Q) }), w = (Q) => {
    const oe = o.value === Q;
    return { borderColor: oe ? h.value.primaryColor : "", borderWidth: oe ? "2px" : "1px", padding: oe ? "0px" : "1px", zIndex: oe ? 0 : 1 };
  }, S = Me(false), k = Me(""), I = Me(""), z = Me(false), R = Me(""), O = async () => {
    await g.init();
  }, V = (Q) => new Date(Q).toLocaleDateString(), W = (Q) => Q.routes.routes.length, N = (Q) => Q.drafts.drafts.length, K = (Q) => {
    g.setCurrentSketchId(Q);
  }, Z = (Q) => {
    R.value = Q, z.value = true;
  }, X = async () => {
    if (!k.value.trim()) {
      d.error(i("sketchCentreView.nameRequired"));
      return;
    }
    const Q = await g.createSketch(k.value);
    await g.updateSketch(Q.id, { description: I.value }), g.setCurrentSketchId(Q.id), S.value = false, k.value = "", I.value = "", d.success(i("sketchCentreView.sketchCreated"));
  }, te = (Q) => {
    const oe = p.value.find((ve) => ve.id === Q);
    oe && l.warning({ title: i("sketchCentreView.deleteConfirmation.title"), content: i("sketchCentreView.deleteConfirmation.prompt", { name: oe.meta.name }), positiveText: i("sketchCentreView.deleteConfirmation.yes"), negativeText: i("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await g.deleteSketch(Q), d.success(i("sketchCentreView.sketchDeleted"));
    } });
  }, { width: q } = Sx(), he = De(() => Math.floor(q.value / 360));
  Tn(() => {
    O();
  });
  const se = Sa();
  return (Q, oe) => (lt(), $t("div", O3, [mt("div", $3, [mt("h1", j3, Qt(Y(i)("sketchCentreView.title")), 1), Re(Y(jr), { type: "primary", secondary: "", circle: "", onClick: oe[0] || (oe[0] = (ve) => S.value = true) }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(Ad))]), _: 1 })]), _: 1 })]), Re(Y(SE), { cols: he.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: $e(() => [(lt(true), $t(qr, null, ti(p.value, (ve) => (lt(), gr(Y(xE), { key: ve.id }, { default: $e(() => [Re(Y(vo), { class: Wo(["sketch-card", { selected: o.value === ve.id }]), style: _i(w(ve.id)), hoverable: "", bordered: "", clickable: "", onClick: (Be) => K(ve.id) }, { header: $e(() => [mt("div", N3, [Re(Y($s), { class: "sketch-name" }, { default: $e(() => [Cr(Qt(ve.meta.name), 1)]), _: 2 }, 1024), ve.meta.tags.length > 0 ? (lt(), $t("div", V3, [(lt(true), $t(qr, null, ti(ve.meta.tags.slice(0, 3), (Be) => (lt(), gr(Y(bo), { key: Be, size: "small", round: "", type: "info" }, { default: $e(() => [Cr(Qt(Be.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), ve.meta.tags.length > 3 ? (lt(), gr(Y(bo), { key: 0, size: "small", round: "", type: "info" }, { default: $e(() => [Cr(" +" + Qt(ve.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : Pr("", true)])) : Pr("", true)])]), "header-extra": $e(() => [Re(Y(ba), null, { default: $e(() => [Re(Y(jr), { quaternary: "", circle: "", size: "small", onClick: Id((Be) => Z(ve.id), ["stop"]) }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(eP))]), _: 1 })]), _: 2 }, 1032, ["onClick"]), Re(Y(jr), { quaternary: "", circle: "", size: "small", onClick: Id((Be) => te(ve.id), ["stop"]) }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(qp))]), _: 1 })]), _: 2 }, 1032, ["onClick"])]), _: 2 }, 1024)]), default: $e(() => [mt("div", U3, [Re(Y($s), { depth: "3", class: "description" }, { default: $e(() => [Cr(Qt(ve.meta.description || Y(i)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), mt("div", q3, [mt("div", G3, [Re(Y(xn), { size: 16 }, { default: $e(() => [Re(Y(Hk))]), _: 1 }), Re(Y($s), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [Cr(Qt(V(ve.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), mt("div", W3, [Re(Y(xn), { size: 16 }, { default: $e(() => [Re(Y(Pv))]), _: 1 }), Re(Y($s), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [Cr(Qt(W(ve)) + " " + Qt(Y(i)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), mt("div", Z3, [Re(Y(xn), { size: 16 }, { default: $e(() => [Re(Y(Ox))]), _: 1 }), Re(Y($s), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [Cr(Qt(N(ve)) + " " + Qt(Y(i)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), p.value.length === 0 ? (lt(), $t("div", H3, [Re(Y(xn), { size: "48", depth: "3" }, { default: $e(() => [Re(Y(kv))]), _: 1 }), Re(Y($s), { depth: "3" }, { default: $e(() => [Cr(Qt(Y(i)("sketchCentreView.emptyState")), 1)]), _: 1 }), Re(Y(jr), { type: "primary", onClick: oe[1] || (oe[1] = (ve) => S.value = true) }, { icon: $e(() => [Re(Y(xn), null, { default: $e(() => [Re(Y(Ad))]), _: 1 })]), default: $e(() => [Cr(" " + Qt(Y(i)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : Pr("", true), Re(Y(zd), { show: S.value, "onUpdate:show": oe[5] || (oe[5] = (ve) => S.value = ve), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: Y(i)("sketchCentreView.newSketch") }, { footer: $e(() => [Re(Y(ba), { justify: "end" }, { default: $e(() => [Re(Y(jr), { onClick: oe[4] || (oe[4] = (ve) => S.value = false) }, { default: $e(() => [Cr(Qt(Y(i)("sketchCentreView.cancel")), 1)]), _: 1 }), Re(Y(jr), { type: "primary", onClick: X }, { default: $e(() => [Cr(Qt(Y(i)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: $e(() => [Re(Y(Ld), { model: { name: k.value, description: I.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: $e(() => [Re(Y(yi), { label: Y(i)("sketchCentreView.sketchName"), required: "" }, { default: $e(() => [Re(Y(yo), { value: k.value, "onUpdate:value": oe[2] || (oe[2] = (ve) => k.value = ve), placeholder: Y(i)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Re(Y(yi), { label: Y(i)("sketchCentreView.description") }, { default: $e(() => [Re(Y(yo), { value: I.value, "onUpdate:value": oe[3] || (oe[3] = (ve) => I.value = ve), type: "textarea", placeholder: Y(i)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), Re(Y(u1), { show: z.value, "onUpdate:show": oe[6] || (oe[6] = (ve) => z.value = ve), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: $e(() => [Re(Y(d1), { title: Y(i)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: $e(() => [R.value ? (lt(), gr(B3, { key: 0, "sketch-id": R.value }, null, 8, ["sketch-id"])) : Pr("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), nw = jn(X3, [["__scopeId", "data-v-00cdfd4b"]]), Y3 = Object.freeze(Object.defineProperty({ __proto__: null, default: nw }, Symbol.toStringTag, { value: "Module" }));
var Am = {};
const K3 = "\xC1", J3 = "\xE1", Q3 = "\u0102", e5 = "\u0103", t5 = "\u223E", r5 = "\u223F", n5 = "\u223E\u0333", i5 = "\xC2", o5 = "\xE2", s5 = "\xB4", a5 = "\u0410", l5 = "\u0430", c5 = "\xC6", u5 = "\xE6", d5 = "\u2061", h5 = "\u{1D504}", p5 = "\u{1D51E}", f5 = "\xC0", m5 = "\xE0", g5 = "\u2135", v5 = "\u2135", y5 = "\u0391", _5 = "\u03B1", b5 = "\u0100", x5 = "\u0101", w5 = "\u2A3F", C5 = "&", S5 = "&", k5 = "\u2A55", P5 = "\u2A53", T5 = "\u2227", M5 = "\u2A5C", I5 = "\u2A58", E5 = "\u2A5A", R5 = "\u2220", z5 = "\u29A4", A5 = "\u2220", D5 = "\u29A8", F5 = "\u29A9", L5 = "\u29AA", B5 = "\u29AB", O5 = "\u29AC", $5 = "\u29AD", j5 = "\u29AE", N5 = "\u29AF", V5 = "\u2221", U5 = "\u221F", q5 = "\u22BE", G5 = "\u299D", W5 = "\u2222", Z5 = "\xC5", H5 = "\u237C", X5 = "\u0104", Y5 = "\u0105", K5 = "\u{1D538}", J5 = "\u{1D552}", Q5 = "\u2A6F", eD = "\u2248", tD = "\u2A70", rD = "\u224A", nD = "\u224B", iD = "'", oD = "\u2061", sD = "\u2248", aD = "\u224A", lD = "\xC5", cD = "\xE5", uD = "\u{1D49C}", dD = "\u{1D4B6}", hD = "\u2254", pD = "*", fD = "\u2248", mD = "\u224D", gD = "\xC3", vD = "\xE3", yD = "\xC4", _D = "\xE4", bD = "\u2233", xD = "\u2A11", wD = "\u224C", CD = "\u03F6", SD = "\u2035", kD = "\u223D", PD = "\u22CD", TD = "\u2216", MD = "\u2AE7", ID = "\u22BD", ED = "\u2305", RD = "\u2306", zD = "\u2305", AD = "\u23B5", DD = "\u23B6", FD = "\u224C", LD = "\u0411", BD = "\u0431", OD = "\u201E", $D = "\u2235", jD = "\u2235", ND = "\u2235", VD = "\u29B0", UD = "\u03F6", qD = "\u212C", GD = "\u212C", WD = "\u0392", ZD = "\u03B2", HD = "\u2136", XD = "\u226C", YD = "\u{1D505}", KD = "\u{1D51F}", JD = "\u22C2", QD = "\u25EF", e4 = "\u22C3", t4 = "\u2A00", r4 = "\u2A01", n4 = "\u2A02", i4 = "\u2A06", o4 = "\u2605", s4 = "\u25BD", a4 = "\u25B3", l4 = "\u2A04", c4 = "\u22C1", u4 = "\u22C0", d4 = "\u290D", h4 = "\u29EB", p4 = "\u25AA", f4 = "\u25B4", m4 = "\u25BE", g4 = "\u25C2", v4 = "\u25B8", y4 = "\u2423", _4 = "\u2592", b4 = "\u2591", x4 = "\u2593", w4 = "\u2588", C4 = "=\u20E5", S4 = "\u2261\u20E5", k4 = "\u2AED", P4 = "\u2310", T4 = "\u{1D539}", M4 = "\u{1D553}", I4 = "\u22A5", E4 = "\u22A5", R4 = "\u22C8", z4 = "\u29C9", A4 = "\u2510", D4 = "\u2555", F4 = "\u2556", L4 = "\u2557", B4 = "\u250C", O4 = "\u2552", $4 = "\u2553", j4 = "\u2554", N4 = "\u2500", V4 = "\u2550", U4 = "\u252C", q4 = "\u2564", G4 = "\u2565", W4 = "\u2566", Z4 = "\u2534", H4 = "\u2567", X4 = "\u2568", Y4 = "\u2569", K4 = "\u229F", J4 = "\u229E", Q4 = "\u22A0", eF = "\u2518", tF = "\u255B", rF = "\u255C", nF = "\u255D", iF = "\u2514", oF = "\u2558", sF = "\u2559", aF = "\u255A", lF = "\u2502", cF = "\u2551", uF = "\u253C", dF = "\u256A", hF = "\u256B", pF = "\u256C", fF = "\u2524", mF = "\u2561", gF = "\u2562", vF = "\u2563", yF = "\u251C", _F = "\u255E", bF = "\u255F", xF = "\u2560", wF = "\u2035", CF = "\u02D8", SF = "\u02D8", kF = "\xA6", PF = "\u{1D4B7}", TF = "\u212C", MF = "\u204F", IF = "\u223D", EF = "\u22CD", RF = "\u29C5", zF = "\\", AF = "\u27C8", DF = "\u2022", FF = "\u2022", LF = "\u224E", BF = "\u2AAE", OF = "\u224F", $F = "\u224E", jF = "\u224F", NF = "\u0106", VF = "\u0107", UF = "\u2A44", qF = "\u2A49", GF = "\u2A4B", WF = "\u2229", ZF = "\u22D2", HF = "\u2A47", XF = "\u2A40", YF = "\u2145", KF = "\u2229\uFE00", JF = "\u2041", QF = "\u02C7", eL = "\u212D", tL = "\u2A4D", rL = "\u010C", nL = "\u010D", iL = "\xC7", oL = "\xE7", sL = "\u0108", aL = "\u0109", lL = "\u2230", cL = "\u2A4C", uL = "\u2A50", dL = "\u010A", hL = "\u010B", pL = "\xB8", fL = "\xB8", mL = "\u29B2", gL = "\xA2", vL = "\xB7", yL = "\xB7", _L = "\u{1D520}", bL = "\u212D", xL = "\u0427", wL = "\u0447", CL = "\u2713", SL = "\u2713", kL = "\u03A7", PL = "\u03C7", TL = "\u02C6", ML = "\u2257", IL = "\u21BA", EL = "\u21BB", RL = "\u229B", zL = "\u229A", AL = "\u229D", DL = "\u2299", FL = "\xAE", LL = "\u24C8", BL = "\u2296", OL = "\u2295", $L = "\u2297", jL = "\u25CB", NL = "\u29C3", VL = "\u2257", UL = "\u2A10", qL = "\u2AEF", GL = "\u29C2", WL = "\u2232", ZL = "\u201D", HL = "\u2019", XL = "\u2663", YL = "\u2663", KL = ":", JL = "\u2237", QL = "\u2A74", e6 = "\u2254", t6 = "\u2254", r6 = ",", n6 = "@", i6 = "\u2201", o6 = "\u2218", s6 = "\u2201", a6 = "\u2102", l6 = "\u2245", c6 = "\u2A6D", u6 = "\u2261", d6 = "\u222E", h6 = "\u222F", p6 = "\u222E", f6 = "\u{1D554}", m6 = "\u2102", g6 = "\u2210", v6 = "\u2210", y6 = "\xA9", _6 = "\xA9", b6 = "\u2117", x6 = "\u2233", w6 = "\u21B5", C6 = "\u2717", S6 = "\u2A2F", k6 = "\u{1D49E}", P6 = "\u{1D4B8}", T6 = "\u2ACF", M6 = "\u2AD1", I6 = "\u2AD0", E6 = "\u2AD2", R6 = "\u22EF", z6 = "\u2938", A6 = "\u2935", D6 = "\u22DE", F6 = "\u22DF", L6 = "\u21B6", B6 = "\u293D", O6 = "\u2A48", $6 = "\u2A46", j6 = "\u224D", N6 = "\u222A", V6 = "\u22D3", U6 = "\u2A4A", q6 = "\u228D", G6 = "\u2A45", W6 = "\u222A\uFE00", Z6 = "\u21B7", H6 = "\u293C", X6 = "\u22DE", Y6 = "\u22DF", K6 = "\u22CE", J6 = "\u22CF", Q6 = "\xA4", eB = "\u21B6", tB = "\u21B7", rB = "\u22CE", nB = "\u22CF", iB = "\u2232", oB = "\u2231", sB = "\u232D", aB = "\u2020", lB = "\u2021", cB = "\u2138", uB = "\u2193", dB = "\u21A1", hB = "\u21D3", pB = "\u2010", fB = "\u2AE4", mB = "\u22A3", gB = "\u290F", vB = "\u02DD", yB = "\u010E", _B = "\u010F", bB = "\u0414", xB = "\u0434", wB = "\u2021", CB = "\u21CA", SB = "\u2145", kB = "\u2146", PB = "\u2911", TB = "\u2A77", MB = "\xB0", IB = "\u2207", EB = "\u0394", RB = "\u03B4", zB = "\u29B1", AB = "\u297F", DB = "\u{1D507}", FB = "\u{1D521}", LB = "\u2965", BB = "\u21C3", OB = "\u21C2", $B = "\xB4", jB = "\u02D9", NB = "\u02DD", VB = "`", UB = "\u02DC", qB = "\u22C4", GB = "\u22C4", WB = "\u22C4", ZB = "\u2666", HB = "\u2666", XB = "\xA8", YB = "\u2146", KB = "\u03DD", JB = "\u22F2", QB = "\xF7", eO = "\xF7", tO = "\u22C7", rO = "\u22C7", nO = "\u0402", iO = "\u0452", oO = "\u231E", sO = "\u230D", aO = "$", lO = "\u{1D53B}", cO = "\u{1D555}", uO = "\xA8", dO = "\u02D9", hO = "\u20DC", pO = "\u2250", fO = "\u2251", mO = "\u2250", gO = "\u2238", vO = "\u2214", yO = "\u22A1", _O = "\u2306", bO = "\u222F", xO = "\xA8", wO = "\u21D3", CO = "\u21D0", SO = "\u21D4", kO = "\u2AE4", PO = "\u27F8", TO = "\u27FA", MO = "\u27F9", IO = "\u21D2", EO = "\u22A8", RO = "\u21D1", zO = "\u21D5", AO = "\u2225", DO = "\u2913", FO = "\u2193", LO = "\u2193", BO = "\u21D3", OO = "\u21F5", $O = "\u0311", jO = "\u21CA", NO = "\u21C3", VO = "\u21C2", UO = "\u2950", qO = "\u295E", GO = "\u2956", WO = "\u21BD", ZO = "\u295F", HO = "\u2957", XO = "\u21C1", YO = "\u21A7", KO = "\u22A4", JO = "\u2910", QO = "\u231F", e8 = "\u230C", t8 = "\u{1D49F}", r8 = "\u{1D4B9}", n8 = "\u0405", i8 = "\u0455", o8 = "\u29F6", s8 = "\u0110", a8 = "\u0111", l8 = "\u22F1", c8 = "\u25BF", u8 = "\u25BE", d8 = "\u21F5", h8 = "\u296F", p8 = "\u29A6", f8 = "\u040F", m8 = "\u045F", g8 = "\u27FF", v8 = "\xC9", y8 = "\xE9", _8 = "\u2A6E", b8 = "\u011A", x8 = "\u011B", w8 = "\xCA", C8 = "\xEA", S8 = "\u2256", k8 = "\u2255", P8 = "\u042D", T8 = "\u044D", M8 = "\u2A77", I8 = "\u0116", E8 = "\u0117", R8 = "\u2251", z8 = "\u2147", A8 = "\u2252", D8 = "\u{1D508}", F8 = "\u{1D522}", L8 = "\u2A9A", B8 = "\xC8", O8 = "\xE8", $8 = "\u2A96", j8 = "\u2A98", N8 = "\u2A99", V8 = "\u2208", U8 = "\u23E7", q8 = "\u2113", G8 = "\u2A95", W8 = "\u2A97", Z8 = "\u0112", H8 = "\u0113", X8 = "\u2205", Y8 = "\u2205", K8 = "\u25FB", J8 = "\u2205", Q8 = "\u25AB", e$ = "\u2004", t$ = "\u2005", r$ = "\u2003", n$ = "\u014A", i$ = "\u014B", o$ = "\u2002", s$ = "\u0118", a$ = "\u0119", l$ = "\u{1D53C}", c$ = "\u{1D556}", u$ = "\u22D5", d$ = "\u29E3", h$ = "\u2A71", p$ = "\u03B5", f$ = "\u0395", m$ = "\u03B5", g$ = "\u03F5", v$ = "\u2256", y$ = "\u2255", _$ = "\u2242", b$ = "\u2A96", x$ = "\u2A95", w$ = "\u2A75", C$ = "=", S$ = "\u2242", k$ = "\u225F", P$ = "\u21CC", T$ = "\u2261", M$ = "\u2A78", I$ = "\u29E5", E$ = "\u2971", R$ = "\u2253", z$ = "\u212F", A$ = "\u2130", D$ = "\u2250", F$ = "\u2A73", L$ = "\u2242", B$ = "\u0397", O$ = "\u03B7", $$ = "\xD0", j$ = "\xF0", N$ = "\xCB", V$ = "\xEB", U$ = "\u20AC", q$ = "!", G$ = "\u2203", W$ = "\u2203", Z$ = "\u2130", H$ = "\u2147", X$ = "\u2147", Y$ = "\u2252", K$ = "\u0424", J$ = "\u0444", Q$ = "\u2640", ej = "\uFB03", tj = "\uFB00", rj = "\uFB04", nj = "\u{1D509}", ij = "\u{1D523}", oj = "\uFB01", sj = "\u25FC", aj = "\u25AA", lj = "fj", cj = "\u266D", uj = "\uFB02", dj = "\u25B1", hj = "\u0192", pj = "\u{1D53D}", fj = "\u{1D557}", mj = "\u2200", gj = "\u2200", vj = "\u22D4", yj = "\u2AD9", _j = "\u2131", bj = "\u2A0D", xj = "\xBD", wj = "\u2153", Cj = "\xBC", Sj = "\u2155", kj = "\u2159", Pj = "\u215B", Tj = "\u2154", Mj = "\u2156", Ij = "\xBE", Ej = "\u2157", Rj = "\u215C", zj = "\u2158", Aj = "\u215A", Dj = "\u215D", Fj = "\u215E", Lj = "\u2044", Bj = "\u2322", Oj = "\u{1D4BB}", $j = "\u2131", jj = "\u01F5", Nj = "\u0393", Vj = "\u03B3", Uj = "\u03DC", qj = "\u03DD", Gj = "\u2A86", Wj = "\u011E", Zj = "\u011F", Hj = "\u0122", Xj = "\u011C", Yj = "\u011D", Kj = "\u0413", Jj = "\u0433", Qj = "\u0120", eN = "\u0121", tN = "\u2265", rN = "\u2267", nN = "\u2A8C", iN = "\u22DB", oN = "\u2265", sN = "\u2267", aN = "\u2A7E", lN = "\u2AA9", cN = "\u2A7E", uN = "\u2A80", dN = "\u2A82", hN = "\u2A84", pN = "\u22DB\uFE00", fN = "\u2A94", mN = "\u{1D50A}", gN = "\u{1D524}", vN = "\u226B", yN = "\u22D9", _N = "\u22D9", bN = "\u2137", xN = "\u0403", wN = "\u0453", CN = "\u2AA5", SN = "\u2277", kN = "\u2A92", PN = "\u2AA4", TN = "\u2A8A", MN = "\u2A8A", IN = "\u2A88", EN = "\u2269", RN = "\u2A88", zN = "\u2269", AN = "\u22E7", DN = "\u{1D53E}", FN = "\u{1D558}", LN = "`", BN = "\u2265", ON = "\u22DB", $N = "\u2267", jN = "\u2AA2", NN = "\u2277", VN = "\u2A7E", UN = "\u2273", qN = "\u{1D4A2}", GN = "\u210A", WN = "\u2273", ZN = "\u2A8E", HN = "\u2A90", XN = "\u2AA7", YN = "\u2A7A", KN = ">", JN = ">", QN = "\u226B", eV = "\u22D7", tV = "\u2995", rV = "\u2A7C", nV = "\u2A86", iV = "\u2978", oV = "\u22D7", sV = "\u22DB", aV = "\u2A8C", lV = "\u2277", cV = "\u2273", uV = "\u2269\uFE00", dV = "\u2269\uFE00", hV = "\u02C7", pV = "\u200A", fV = "\xBD", mV = "\u210B", gV = "\u042A", vV = "\u044A", yV = "\u2948", _V = "\u2194", bV = "\u21D4", xV = "\u21AD", wV = "^", CV = "\u210F", SV = "\u0124", kV = "\u0125", PV = "\u2665", TV = "\u2665", MV = "\u2026", IV = "\u22B9", EV = "\u{1D525}", RV = "\u210C", zV = "\u210B", AV = "\u2925", DV = "\u2926", FV = "\u21FF", LV = "\u223B", BV = "\u21A9", OV = "\u21AA", $V = "\u{1D559}", jV = "\u210D", NV = "\u2015", VV = "\u2500", UV = "\u{1D4BD}", qV = "\u210B", GV = "\u210F", WV = "\u0126", ZV = "\u0127", HV = "\u224E", XV = "\u224F", YV = "\u2043", KV = "\u2010", JV = "\xCD", QV = "\xED", e9 = "\u2063", t9 = "\xCE", r9 = "\xEE", n9 = "\u0418", i9 = "\u0438", o9 = "\u0130", s9 = "\u0415", a9 = "\u0435", l9 = "\xA1", c9 = "\u21D4", u9 = "\u{1D526}", d9 = "\u2111", h9 = "\xCC", p9 = "\xEC", f9 = "\u2148", m9 = "\u2A0C", g9 = "\u222D", v9 = "\u29DC", y9 = "\u2129", _9 = "\u0132", b9 = "\u0133", x9 = "\u012A", w9 = "\u012B", C9 = "\u2111", S9 = "\u2148", k9 = "\u2110", P9 = "\u2111", T9 = "\u0131", M9 = "\u2111", I9 = "\u22B7", E9 = "\u01B5", R9 = "\u21D2", z9 = "\u2105", A9 = "\u221E", D9 = "\u29DD", F9 = "\u0131", L9 = "\u22BA", B9 = "\u222B", O9 = "\u222C", $9 = "\u2124", j9 = "\u222B", N9 = "\u22BA", V9 = "\u22C2", U9 = "\u2A17", q9 = "\u2A3C", G9 = "\u2063", W9 = "\u2062", Z9 = "\u0401", H9 = "\u0451", X9 = "\u012E", Y9 = "\u012F", K9 = "\u{1D540}", J9 = "\u{1D55A}", Q9 = "\u0399", e7 = "\u03B9", t7 = "\u2A3C", r7 = "\xBF", n7 = "\u{1D4BE}", i7 = "\u2110", o7 = "\u2208", s7 = "\u22F5", a7 = "\u22F9", l7 = "\u22F4", c7 = "\u22F3", u7 = "\u2208", d7 = "\u2062", h7 = "\u0128", p7 = "\u0129", f7 = "\u0406", m7 = "\u0456", g7 = "\xCF", v7 = "\xEF", y7 = "\u0134", _7 = "\u0135", b7 = "\u0419", x7 = "\u0439", w7 = "\u{1D50D}", C7 = "\u{1D527}", S7 = "\u0237", k7 = "\u{1D541}", P7 = "\u{1D55B}", T7 = "\u{1D4A5}", M7 = "\u{1D4BF}", I7 = "\u0408", E7 = "\u0458", R7 = "\u0404", z7 = "\u0454", A7 = "\u039A", D7 = "\u03BA", F7 = "\u03F0", L7 = "\u0136", B7 = "\u0137", O7 = "\u041A", $7 = "\u043A", j7 = "\u{1D50E}", N7 = "\u{1D528}", V7 = "\u0138", U7 = "\u0425", q7 = "\u0445", G7 = "\u040C", W7 = "\u045C", Z7 = "\u{1D542}", H7 = "\u{1D55C}", X7 = "\u{1D4A6}", Y7 = "\u{1D4C0}", K7 = "\u21DA", J7 = "\u0139", Q7 = "\u013A", eU = "\u29B4", tU = "\u2112", rU = "\u039B", nU = "\u03BB", iU = "\u27E8", oU = "\u27EA", sU = "\u2991", aU = "\u27E8", lU = "\u2A85", cU = "\u2112", uU = "\xAB", dU = "\u21E4", hU = "\u291F", pU = "\u2190", fU = "\u219E", mU = "\u21D0", gU = "\u291D", vU = "\u21A9", yU = "\u21AB", _U = "\u2939", bU = "\u2973", xU = "\u21A2", wU = "\u2919", CU = "\u291B", SU = "\u2AAB", kU = "\u2AAD", PU = "\u2AAD\uFE00", TU = "\u290C", MU = "\u290E", IU = "\u2772", EU = "{", RU = "[", zU = "\u298B", AU = "\u298F", DU = "\u298D", FU = "\u013D", LU = "\u013E", BU = "\u013B", OU = "\u013C", $U = "\u2308", jU = "{", NU = "\u041B", VU = "\u043B", UU = "\u2936", qU = "\u201C", GU = "\u201E", WU = "\u2967", ZU = "\u294B", HU = "\u21B2", XU = "\u2264", YU = "\u2266", KU = "\u27E8", JU = "\u21E4", QU = "\u2190", eq = "\u2190", tq = "\u21D0", rq = "\u21C6", nq = "\u21A2", iq = "\u2308", oq = "\u27E6", sq = "\u2961", aq = "\u2959", lq = "\u21C3", cq = "\u230A", uq = "\u21BD", dq = "\u21BC", hq = "\u21C7", pq = "\u2194", fq = "\u2194", mq = "\u21D4", gq = "\u21C6", vq = "\u21CB", yq = "\u21AD", _q = "\u294E", bq = "\u21A4", xq = "\u22A3", wq = "\u295A", Cq = "\u22CB", Sq = "\u29CF", kq = "\u22B2", Pq = "\u22B4", Tq = "\u2951", Mq = "\u2960", Iq = "\u2958", Eq = "\u21BF", Rq = "\u2952", zq = "\u21BC", Aq = "\u2A8B", Dq = "\u22DA", Fq = "\u2264", Lq = "\u2266", Bq = "\u2A7D", Oq = "\u2AA8", $q = "\u2A7D", jq = "\u2A7F", Nq = "\u2A81", Vq = "\u2A83", Uq = "\u22DA\uFE00", qq = "\u2A93", Gq = "\u2A85", Wq = "\u22D6", Zq = "\u22DA", Hq = "\u2A8B", Xq = "\u22DA", Yq = "\u2266", Kq = "\u2276", Jq = "\u2276", Qq = "\u2AA1", eG = "\u2272", tG = "\u2A7D", rG = "\u2272", nG = "\u297C", iG = "\u230A", oG = "\u{1D50F}", sG = "\u{1D529}", aG = "\u2276", lG = "\u2A91", cG = "\u2962", uG = "\u21BD", dG = "\u21BC", hG = "\u296A", pG = "\u2584", fG = "\u0409", mG = "\u0459", gG = "\u21C7", vG = "\u226A", yG = "\u22D8", _G = "\u231E", bG = "\u21DA", xG = "\u296B", wG = "\u25FA", CG = "\u013F", SG = "\u0140", kG = "\u23B0", PG = "\u23B0", TG = "\u2A89", MG = "\u2A89", IG = "\u2A87", EG = "\u2268", RG = "\u2A87", zG = "\u2268", AG = "\u22E6", DG = "\u27EC", FG = "\u21FD", LG = "\u27E6", BG = "\u27F5", OG = "\u27F5", $G = "\u27F8", jG = "\u27F7", NG = "\u27F7", VG = "\u27FA", UG = "\u27FC", qG = "\u27F6", GG = "\u27F6", WG = "\u27F9", ZG = "\u21AB", HG = "\u21AC", XG = "\u2985", YG = "\u{1D543}", KG = "\u{1D55D}", JG = "\u2A2D", QG = "\u2A34", eW = "\u2217", tW = "_", rW = "\u2199", nW = "\u2198", iW = "\u25CA", oW = "\u25CA", sW = "\u29EB", aW = "(", lW = "\u2993", cW = "\u21C6", uW = "\u231F", dW = "\u21CB", hW = "\u296D", pW = "\u200E", fW = "\u22BF", mW = "\u2039", gW = "\u{1D4C1}", vW = "\u2112", yW = "\u21B0", _W = "\u21B0", bW = "\u2272", xW = "\u2A8D", wW = "\u2A8F", CW = "[", SW = "\u2018", kW = "\u201A", PW = "\u0141", TW = "\u0142", MW = "\u2AA6", IW = "\u2A79", EW = "<", RW = "<", zW = "\u226A", AW = "\u22D6", DW = "\u22CB", FW = "\u22C9", LW = "\u2976", BW = "\u2A7B", OW = "\u25C3", $W = "\u22B4", jW = "\u25C2", NW = "\u2996", VW = "\u294A", UW = "\u2966", qW = "\u2268\uFE00", GW = "\u2268\uFE00", WW = "\xAF", ZW = "\u2642", HW = "\u2720", XW = "\u2720", YW = "\u21A6", KW = "\u21A6", JW = "\u21A7", QW = "\u21A4", eZ = "\u21A5", tZ = "\u25AE", rZ = "\u2A29", nZ = "\u041C", iZ = "\u043C", oZ = "\u2014", sZ = "\u223A", aZ = "\u2221", lZ = "\u205F", cZ = "\u2133", uZ = "\u{1D510}", dZ = "\u{1D52A}", hZ = "\u2127", pZ = "\xB5", fZ = "*", mZ = "\u2AF0", gZ = "\u2223", vZ = "\xB7", yZ = "\u229F", _Z = "\u2212", bZ = "\u2238", xZ = "\u2A2A", wZ = "\u2213", CZ = "\u2ADB", SZ = "\u2026", kZ = "\u2213", PZ = "\u22A7", TZ = "\u{1D544}", MZ = "\u{1D55E}", IZ = "\u2213", EZ = "\u{1D4C2}", RZ = "\u2133", zZ = "\u223E", AZ = "\u039C", DZ = "\u03BC", FZ = "\u22B8", LZ = "\u22B8", BZ = "\u2207", OZ = "\u0143", $Z = "\u0144", jZ = "\u2220\u20D2", NZ = "\u2249", VZ = "\u2A70\u0338", UZ = "\u224B\u0338", qZ = "\u0149", GZ = "\u2249", WZ = "\u266E", ZZ = "\u2115", HZ = "\u266E", XZ = "\xA0", YZ = "\u224E\u0338", KZ = "\u224F\u0338", JZ = "\u2A43", QZ = "\u0147", eH = "\u0148", tH = "\u0145", rH = "\u0146", nH = "\u2247", iH = "\u2A6D\u0338", oH = "\u2A42", sH = "\u041D", aH = "\u043D", lH = "\u2013", cH = "\u2924", uH = "\u2197", dH = "\u21D7", hH = "\u2197", pH = "\u2260", fH = "\u2250\u0338", mH = "\u200B", gH = "\u200B", vH = "\u200B", yH = "\u200B", _H = "\u2262", bH = "\u2928", xH = "\u2242\u0338", wH = "\u226B", CH = "\u226A", SH = `
`, kH = "\u2204", PH = "\u2204", TH = "\u{1D511}", MH = "\u{1D52B}", IH = "\u2267\u0338", EH = "\u2271", RH = "\u2271", zH = "\u2267\u0338", AH = "\u2A7E\u0338", DH = "\u2A7E\u0338", FH = "\u22D9\u0338", LH = "\u2275", BH = "\u226B\u20D2", OH = "\u226F", $H = "\u226F", jH = "\u226B\u0338", NH = "\u21AE", VH = "\u21CE", UH = "\u2AF2", qH = "\u220B", GH = "\u22FC", WH = "\u22FA", ZH = "\u220B", HH = "\u040A", XH = "\u045A", YH = "\u219A", KH = "\u21CD", JH = "\u2025", QH = "\u2266\u0338", eX = "\u2270", tX = "\u219A", rX = "\u21CD", nX = "\u21AE", iX = "\u21CE", oX = "\u2270", sX = "\u2266\u0338", aX = "\u2A7D\u0338", lX = "\u2A7D\u0338", cX = "\u226E", uX = "\u22D8\u0338", dX = "\u2274", hX = "\u226A\u20D2", pX = "\u226E", fX = "\u22EA", mX = "\u22EC", gX = "\u226A\u0338", vX = "\u2224", yX = "\u2060", _X = "\xA0", bX = "\u{1D55F}", xX = "\u2115", wX = "\u2AEC", CX = "\xAC", SX = "\u2262", kX = "\u226D", PX = "\u2226", TX = "\u2209", MX = "\u2260", IX = "\u2242\u0338", EX = "\u2204", RX = "\u226F", zX = "\u2271", AX = "\u2267\u0338", DX = "\u226B\u0338", FX = "\u2279", LX = "\u2A7E\u0338", BX = "\u2275", OX = "\u224E\u0338", $X = "\u224F\u0338", jX = "\u2209", NX = "\u22F5\u0338", VX = "\u22F9\u0338", UX = "\u2209", qX = "\u22F7", GX = "\u22F6", WX = "\u29CF\u0338", ZX = "\u22EA", HX = "\u22EC", XX = "\u226E", YX = "\u2270", KX = "\u2278", JX = "\u226A\u0338", QX = "\u2A7D\u0338", eY = "\u2274", tY = "\u2AA2\u0338", rY = "\u2AA1\u0338", nY = "\u220C", iY = "\u220C", oY = "\u22FE", sY = "\u22FD", aY = "\u2280", lY = "\u2AAF\u0338", cY = "\u22E0", uY = "\u220C", dY = "\u29D0\u0338", hY = "\u22EB", pY = "\u22ED", fY = "\u228F\u0338", mY = "\u22E2", gY = "\u2290\u0338", vY = "\u22E3", yY = "\u2282\u20D2", _Y = "\u2288", bY = "\u2281", xY = "\u2AB0\u0338", wY = "\u22E1", CY = "\u227F\u0338", SY = "\u2283\u20D2", kY = "\u2289", PY = "\u2241", TY = "\u2244", MY = "\u2247", IY = "\u2249", EY = "\u2224", RY = "\u2226", zY = "\u2226", AY = "\u2AFD\u20E5", DY = "\u2202\u0338", FY = "\u2A14", LY = "\u2280", BY = "\u22E0", OY = "\u2280", $Y = "\u2AAF\u0338", jY = "\u2AAF\u0338", NY = "\u2933\u0338", VY = "\u219B", UY = "\u21CF", qY = "\u219D\u0338", GY = "\u219B", WY = "\u21CF", ZY = "\u22EB", HY = "\u22ED", XY = "\u2281", YY = "\u22E1", KY = "\u2AB0\u0338", JY = "\u{1D4A9}", QY = "\u{1D4C3}", eK = "\u2224", tK = "\u2226", rK = "\u2241", nK = "\u2244", iK = "\u2244", oK = "\u2224", sK = "\u2226", aK = "\u22E2", lK = "\u22E3", cK = "\u2284", uK = "\u2AC5\u0338", dK = "\u2288", hK = "\u2282\u20D2", pK = "\u2288", fK = "\u2AC5\u0338", mK = "\u2281", gK = "\u2AB0\u0338", vK = "\u2285", yK = "\u2AC6\u0338", _K = "\u2289", bK = "\u2283\u20D2", xK = "\u2289", wK = "\u2AC6\u0338", CK = "\u2279", SK = "\xD1", kK = "\xF1", PK = "\u2278", TK = "\u22EA", MK = "\u22EC", IK = "\u22EB", EK = "\u22ED", RK = "\u039D", zK = "\u03BD", AK = "#", DK = "\u2116", FK = "\u2007", LK = "\u224D\u20D2", BK = "\u22AC", OK = "\u22AD", $K = "\u22AE", jK = "\u22AF", NK = "\u2265\u20D2", VK = ">\u20D2", UK = "\u2904", qK = "\u29DE", GK = "\u2902", WK = "\u2264\u20D2", ZK = "<\u20D2", HK = "\u22B4\u20D2", XK = "\u2903", YK = "\u22B5\u20D2", KK = "\u223C\u20D2", JK = "\u2923", QK = "\u2196", eJ = "\u21D6", tJ = "\u2196", rJ = "\u2927", nJ = "\xD3", iJ = "\xF3", oJ = "\u229B", sJ = "\xD4", aJ = "\xF4", lJ = "\u229A", cJ = "\u041E", uJ = "\u043E", dJ = "\u229D", hJ = "\u0150", pJ = "\u0151", fJ = "\u2A38", mJ = "\u2299", gJ = "\u29BC", vJ = "\u0152", yJ = "\u0153", _J = "\u29BF", bJ = "\u{1D512}", xJ = "\u{1D52C}", wJ = "\u02DB", CJ = "\xD2", SJ = "\xF2", kJ = "\u29C1", PJ = "\u29B5", TJ = "\u03A9", MJ = "\u222E", IJ = "\u21BA", EJ = "\u29BE", RJ = "\u29BB", zJ = "\u203E", AJ = "\u29C0", DJ = "\u014C", FJ = "\u014D", LJ = "\u03A9", BJ = "\u03C9", OJ = "\u039F", $J = "\u03BF", jJ = "\u29B6", NJ = "\u2296", VJ = "\u{1D546}", UJ = "\u{1D560}", qJ = "\u29B7", GJ = "\u201C", WJ = "\u2018", ZJ = "\u29B9", HJ = "\u2295", XJ = "\u21BB", YJ = "\u2A54", KJ = "\u2228", JJ = "\u2A5D", QJ = "\u2134", eQ = "\u2134", tQ = "\xAA", rQ = "\xBA", nQ = "\u22B6", iQ = "\u2A56", oQ = "\u2A57", sQ = "\u2A5B", aQ = "\u24C8", lQ = "\u{1D4AA}", cQ = "\u2134", uQ = "\xD8", dQ = "\xF8", hQ = "\u2298", pQ = "\xD5", fQ = "\xF5", mQ = "\u2A36", gQ = "\u2A37", vQ = "\u2297", yQ = "\xD6", _Q = "\xF6", bQ = "\u233D", xQ = "\u203E", wQ = "\u23DE", CQ = "\u23B4", SQ = "\u23DC", kQ = "\xB6", PQ = "\u2225", TQ = "\u2225", MQ = "\u2AF3", IQ = "\u2AFD", EQ = "\u2202", RQ = "\u2202", zQ = "\u041F", AQ = "\u043F", DQ = "%", FQ = ".", LQ = "\u2030", BQ = "\u22A5", OQ = "\u2031", $Q = "\u{1D513}", jQ = "\u{1D52D}", NQ = "\u03A6", VQ = "\u03C6", UQ = "\u03D5", qQ = "\u2133", GQ = "\u260E", WQ = "\u03A0", ZQ = "\u03C0", HQ = "\u22D4", XQ = "\u03D6", YQ = "\u210F", KQ = "\u210E", JQ = "\u210F", QQ = "\u2A23", eee = "\u229E", tee = "\u2A22", ree = "+", nee = "\u2214", iee = "\u2A25", oee = "\u2A72", see = "\xB1", aee = "\xB1", lee = "\u2A26", cee = "\u2A27", uee = "\xB1", dee = "\u210C", hee = "\u2A15", pee = "\u{1D561}", fee = "\u2119", mee = "\xA3", gee = "\u2AB7", vee = "\u2ABB", yee = "\u227A", _ee = "\u227C", bee = "\u2AB7", xee = "\u227A", wee = "\u227C", Cee = "\u227A", See = "\u2AAF", kee = "\u227C", Pee = "\u227E", Tee = "\u2AAF", Mee = "\u2AB9", Iee = "\u2AB5", Eee = "\u22E8", Ree = "\u2AAF", zee = "\u2AB3", Aee = "\u227E", Dee = "\u2032", Fee = "\u2033", Lee = "\u2119", Bee = "\u2AB9", Oee = "\u2AB5", $ee = "\u22E8", jee = "\u220F", Nee = "\u220F", Vee = "\u232E", Uee = "\u2312", qee = "\u2313", Gee = "\u221D", Wee = "\u221D", Zee = "\u2237", Hee = "\u221D", Xee = "\u227E", Yee = "\u22B0", Kee = "\u{1D4AB}", Jee = "\u{1D4C5}", Qee = "\u03A8", ete = "\u03C8", tte = "\u2008", rte = "\u{1D514}", nte = "\u{1D52E}", ite = "\u2A0C", ote = "\u{1D562}", ste = "\u211A", ate = "\u2057", lte = "\u{1D4AC}", cte = "\u{1D4C6}", ute = "\u210D", dte = "\u2A16", hte = "?", pte = "\u225F", fte = '"', mte = '"', gte = "\u21DB", vte = "\u223D\u0331", yte = "\u0154", _te = "\u0155", bte = "\u221A", xte = "\u29B3", wte = "\u27E9", Cte = "\u27EB", Ste = "\u2992", kte = "\u29A5", Pte = "\u27E9", Tte = "\xBB", Mte = "\u2975", Ite = "\u21E5", Ete = "\u2920", Rte = "\u2933", zte = "\u2192", Ate = "\u21A0", Dte = "\u21D2", Fte = "\u291E", Lte = "\u21AA", Bte = "\u21AC", Ote = "\u2945", $te = "\u2974", jte = "\u2916", Nte = "\u21A3", Vte = "\u219D", Ute = "\u291A", qte = "\u291C", Gte = "\u2236", Wte = "\u211A", Zte = "\u290D", Hte = "\u290F", Xte = "\u2910", Yte = "\u2773", Kte = "}", Jte = "]", Qte = "\u298C", ere = "\u298E", tre = "\u2990", rre = "\u0158", nre = "\u0159", ire = "\u0156", ore = "\u0157", sre = "\u2309", are = "}", lre = "\u0420", cre = "\u0440", ure = "\u2937", dre = "\u2969", hre = "\u201D", pre = "\u201D", fre = "\u21B3", mre = "\u211C", gre = "\u211B", vre = "\u211C", yre = "\u211D", _re = "\u211C", bre = "\u25AD", xre = "\xAE", wre = "\xAE", Cre = "\u220B", Sre = "\u21CB", kre = "\u296F", Pre = "\u297D", Tre = "\u230B", Mre = "\u{1D52F}", Ire = "\u211C", Ere = "\u2964", Rre = "\u21C1", zre = "\u21C0", Are = "\u296C", Dre = "\u03A1", Fre = "\u03C1", Lre = "\u03F1", Bre = "\u27E9", Ore = "\u21E5", $re = "\u2192", jre = "\u2192", Nre = "\u21D2", Vre = "\u21C4", Ure = "\u21A3", qre = "\u2309", Gre = "\u27E7", Wre = "\u295D", Zre = "\u2955", Hre = "\u21C2", Xre = "\u230B", Yre = "\u21C1", Kre = "\u21C0", Jre = "\u21C4", Qre = "\u21CC", ene = "\u21C9", tne = "\u219D", rne = "\u21A6", nne = "\u22A2", ine = "\u295B", one = "\u22CC", sne = "\u29D0", ane = "\u22B3", lne = "\u22B5", cne = "\u294F", une = "\u295C", dne = "\u2954", hne = "\u21BE", pne = "\u2953", fne = "\u21C0", mne = "\u02DA", gne = "\u2253", vne = "\u21C4", yne = "\u21CC", _ne = "\u200F", bne = "\u23B1", xne = "\u23B1", wne = "\u2AEE", Cne = "\u27ED", Sne = "\u21FE", kne = "\u27E7", Pne = "\u2986", Tne = "\u{1D563}", Mne = "\u211D", Ine = "\u2A2E", Ene = "\u2A35", Rne = "\u2970", zne = ")", Ane = "\u2994", Dne = "\u2A12", Fne = "\u21C9", Lne = "\u21DB", Bne = "\u203A", One = "\u{1D4C7}", $ne = "\u211B", jne = "\u21B1", Nne = "\u21B1", Vne = "]", Une = "\u2019", qne = "\u2019", Gne = "\u22CC", Wne = "\u22CA", Zne = "\u25B9", Hne = "\u22B5", Xne = "\u25B8", Yne = "\u29CE", Kne = "\u29F4", Jne = "\u2968", Qne = "\u211E", eie = "\u015A", tie = "\u015B", rie = "\u201A", nie = "\u2AB8", iie = "\u0160", oie = "\u0161", sie = "\u2ABC", aie = "\u227B", lie = "\u227D", cie = "\u2AB0", uie = "\u2AB4", die = "\u015E", hie = "\u015F", pie = "\u015C", fie = "\u015D", mie = "\u2ABA", gie = "\u2AB6", vie = "\u22E9", yie = "\u2A13", _ie = "\u227F", bie = "\u0421", xie = "\u0441", wie = "\u22A1", Cie = "\u22C5", Sie = "\u2A66", kie = "\u2925", Pie = "\u2198", Tie = "\u21D8", Mie = "\u2198", Iie = "\xA7", Eie = ";", Rie = "\u2929", zie = "\u2216", Aie = "\u2216", Die = "\u2736", Fie = "\u{1D516}", Lie = "\u{1D530}", Bie = "\u2322", Oie = "\u266F", $ie = "\u0429", jie = "\u0449", Nie = "\u0428", Vie = "\u0448", Uie = "\u2193", qie = "\u2190", Gie = "\u2223", Wie = "\u2225", Zie = "\u2192", Hie = "\u2191", Xie = "\xAD", Yie = "\u03A3", Kie = "\u03C3", Jie = "\u03C2", Qie = "\u03C2", eoe = "\u223C", toe = "\u2A6A", roe = "\u2243", noe = "\u2243", ioe = "\u2A9E", ooe = "\u2AA0", soe = "\u2A9D", aoe = "\u2A9F", loe = "\u2246", coe = "\u2A24", uoe = "\u2972", doe = "\u2190", hoe = "\u2218", poe = "\u2216", foe = "\u2A33", moe = "\u29E4", goe = "\u2223", voe = "\u2323", yoe = "\u2AAA", _oe = "\u2AAC", boe = "\u2AAC\uFE00", xoe = "\u042C", woe = "\u044C", Coe = "\u233F", Soe = "\u29C4", koe = "/", Poe = "\u{1D54A}", Toe = "\u{1D564}", Moe = "\u2660", Ioe = "\u2660", Eoe = "\u2225", Roe = "\u2293", zoe = "\u2293\uFE00", Aoe = "\u2294", Doe = "\u2294\uFE00", Foe = "\u221A", Loe = "\u228F", Boe = "\u2291", Ooe = "\u228F", $oe = "\u2291", joe = "\u2290", Noe = "\u2292", Voe = "\u2290", Uoe = "\u2292", qoe = "\u25A1", Goe = "\u25A1", Woe = "\u2293", Zoe = "\u228F", Hoe = "\u2291", Xoe = "\u2290", Yoe = "\u2292", Koe = "\u2294", Joe = "\u25AA", Qoe = "\u25A1", ese = "\u25AA", tse = "\u2192", rse = "\u{1D4AE}", nse = "\u{1D4C8}", ise = "\u2216", ose = "\u2323", sse = "\u22C6", ase = "\u22C6", lse = "\u2606", cse = "\u2605", use = "\u03F5", dse = "\u03D5", hse = "\xAF", pse = "\u2282", fse = "\u22D0", mse = "\u2ABD", gse = "\u2AC5", vse = "\u2286", yse = "\u2AC3", _se = "\u2AC1", bse = "\u2ACB", xse = "\u228A", wse = "\u2ABF", Cse = "\u2979", Sse = "\u2282", kse = "\u22D0", Pse = "\u2286", Tse = "\u2AC5", Mse = "\u2286", Ise = "\u228A", Ese = "\u2ACB", Rse = "\u2AC7", zse = "\u2AD5", Ase = "\u2AD3", Dse = "\u2AB8", Fse = "\u227B", Lse = "\u227D", Bse = "\u227B", Ose = "\u2AB0", $se = "\u227D", jse = "\u227F", Nse = "\u2AB0", Vse = "\u2ABA", Use = "\u2AB6", qse = "\u22E9", Gse = "\u227F", Wse = "\u220B", Zse = "\u2211", Hse = "\u2211", Xse = "\u266A", Yse = "\xB9", Kse = "\xB2", Jse = "\xB3", Qse = "\u2283", eae = "\u22D1", tae = "\u2ABE", rae = "\u2AD8", nae = "\u2AC6", iae = "\u2287", oae = "\u2AC4", sae = "\u2283", aae = "\u2287", lae = "\u27C9", cae = "\u2AD7", uae = "\u297B", dae = "\u2AC2", hae = "\u2ACC", pae = "\u228B", fae = "\u2AC0", mae = "\u2283", gae = "\u22D1", vae = "\u2287", yae = "\u2AC6", _ae = "\u228B", bae = "\u2ACC", xae = "\u2AC8", wae = "\u2AD4", Cae = "\u2AD6", Sae = "\u2926", kae = "\u2199", Pae = "\u21D9", Tae = "\u2199", Mae = "\u292A", Iae = "\xDF", Eae = "	", Rae = "\u2316", zae = "\u03A4", Aae = "\u03C4", Dae = "\u23B4", Fae = "\u0164", Lae = "\u0165", Bae = "\u0162", Oae = "\u0163", $ae = "\u0422", jae = "\u0442", Nae = "\u20DB", Vae = "\u2315", Uae = "\u{1D517}", qae = "\u{1D531}", Gae = "\u2234", Wae = "\u2234", Zae = "\u2234", Hae = "\u0398", Xae = "\u03B8", Yae = "\u03D1", Kae = "\u03D1", Jae = "\u2248", Qae = "\u223C", ele = "\u205F\u200A", tle = "\u2009", rle = "\u2009", nle = "\u2248", ile = "\u223C", ole = "\xDE", sle = "\xFE", ale = "\u02DC", lle = "\u223C", cle = "\u2243", ule = "\u2245", dle = "\u2248", hle = "\u2A31", ple = "\u22A0", fle = "\xD7", mle = "\u2A30", gle = "\u222D", vle = "\u2928", yle = "\u2336", _le = "\u2AF1", ble = "\u22A4", xle = "\u{1D54B}", wle = "\u{1D565}", Cle = "\u2ADA", Sle = "\u2929", kle = "\u2034", Ple = "\u2122", Tle = "\u2122", Mle = "\u25B5", Ile = "\u25BF", Ele = "\u25C3", Rle = "\u22B4", zle = "\u225C", Ale = "\u25B9", Dle = "\u22B5", Fle = "\u25EC", Lle = "\u225C", Ble = "\u2A3A", Ole = "\u20DB", $le = "\u2A39", jle = "\u29CD", Nle = "\u2A3B", Vle = "\u23E2", Ule = "\u{1D4AF}", qle = "\u{1D4C9}", Gle = "\u0426", Wle = "\u0446", Zle = "\u040B", Hle = "\u045B", Xle = "\u0166", Yle = "\u0167", Kle = "\u226C", Jle = "\u219E", Qle = "\u21A0", ece = "\xDA", tce = "\xFA", rce = "\u2191", nce = "\u219F", ice = "\u21D1", oce = "\u2949", sce = "\u040E", ace = "\u045E", lce = "\u016C", cce = "\u016D", uce = "\xDB", dce = "\xFB", hce = "\u0423", pce = "\u0443", fce = "\u21C5", mce = "\u0170", gce = "\u0171", vce = "\u296E", yce = "\u297E", _ce = "\u{1D518}", bce = "\u{1D532}", xce = "\xD9", wce = "\xF9", Cce = "\u2963", Sce = "\u21BF", kce = "\u21BE", Pce = "\u2580", Tce = "\u231C", Mce = "\u231C", Ice = "\u230F", Ece = "\u25F8", Rce = "\u016A", zce = "\u016B", Ace = "\xA8", Dce = "_", Fce = "\u23DF", Lce = "\u23B5", Bce = "\u23DD", Oce = "\u22C3", $ce = "\u228E", jce = "\u0172", Nce = "\u0173", Vce = "\u{1D54C}", Uce = "\u{1D566}", qce = "\u2912", Gce = "\u2191", Wce = "\u2191", Zce = "\u21D1", Hce = "\u21C5", Xce = "\u2195", Yce = "\u2195", Kce = "\u21D5", Jce = "\u296E", Qce = "\u21BF", eue = "\u21BE", tue = "\u228E", rue = "\u2196", nue = "\u2197", iue = "\u03C5", oue = "\u03D2", sue = "\u03D2", aue = "\u03A5", lue = "\u03C5", cue = "\u21A5", uue = "\u22A5", due = "\u21C8", hue = "\u231D", pue = "\u231D", fue = "\u230E", mue = "\u016E", gue = "\u016F", vue = "\u25F9", yue = "\u{1D4B0}", _ue = "\u{1D4CA}", bue = "\u22F0", xue = "\u0168", wue = "\u0169", Cue = "\u25B5", Sue = "\u25B4", kue = "\u21C8", Pue = "\xDC", Tue = "\xFC", Mue = "\u29A7", Iue = "\u299C", Eue = "\u03F5", Rue = "\u03F0", zue = "\u2205", Aue = "\u03D5", Due = "\u03D6", Fue = "\u221D", Lue = "\u2195", Bue = "\u21D5", Oue = "\u03F1", $ue = "\u03C2", jue = "\u228A\uFE00", Nue = "\u2ACB\uFE00", Vue = "\u228B\uFE00", Uue = "\u2ACC\uFE00", que = "\u03D1", Gue = "\u22B2", Wue = "\u22B3", Zue = "\u2AE8", Hue = "\u2AEB", Xue = "\u2AE9", Yue = "\u0412", Kue = "\u0432", Jue = "\u22A2", Que = "\u22A8", ede = "\u22A9", tde = "\u22AB", rde = "\u2AE6", nde = "\u22BB", ide = "\u2228", ode = "\u22C1", sde = "\u225A", ade = "\u22EE", lde = "|", cde = "\u2016", ude = "|", dde = "\u2016", hde = "\u2223", pde = "|", fde = "\u2758", mde = "\u2240", gde = "\u200A", vde = "\u{1D519}", yde = "\u{1D533}", _de = "\u22B2", bde = "\u2282\u20D2", xde = "\u2283\u20D2", wde = "\u{1D54D}", Cde = "\u{1D567}", Sde = "\u221D", kde = "\u22B3", Pde = "\u{1D4B1}", Tde = "\u{1D4CB}", Mde = "\u2ACB\uFE00", Ide = "\u228A\uFE00", Ede = "\u2ACC\uFE00", Rde = "\u228B\uFE00", zde = "\u22AA", Ade = "\u299A", Dde = "\u0174", Fde = "\u0175", Lde = "\u2A5F", Bde = "\u2227", Ode = "\u22C0", $de = "\u2259", jde = "\u2118", Nde = "\u{1D51A}", Vde = "\u{1D534}", Ude = "\u{1D54E}", qde = "\u{1D568}", Gde = "\u2118", Wde = "\u2240", Zde = "\u2240", Hde = "\u{1D4B2}", Xde = "\u{1D4CC}", Yde = "\u22C2", Kde = "\u25EF", Jde = "\u22C3", Qde = "\u25BD", ehe = "\u{1D51B}", the = "\u{1D535}", rhe = "\u27F7", nhe = "\u27FA", ihe = "\u039E", ohe = "\u03BE", she = "\u27F5", ahe = "\u27F8", lhe = "\u27FC", che = "\u22FB", uhe = "\u2A00", dhe = "\u{1D54F}", hhe = "\u{1D569}", phe = "\u2A01", fhe = "\u2A02", mhe = "\u27F6", ghe = "\u27F9", vhe = "\u{1D4B3}", yhe = "\u{1D4CD}", _he = "\u2A06", bhe = "\u2A04", xhe = "\u25B3", whe = "\u22C1", Che = "\u22C0", She = "\xDD", khe = "\xFD", Phe = "\u042F", The = "\u044F", Mhe = "\u0176", Ihe = "\u0177", Ehe = "\u042B", Rhe = "\u044B", zhe = "\xA5", Ahe = "\u{1D51C}", Dhe = "\u{1D536}", Fhe = "\u0407", Lhe = "\u0457", Bhe = "\u{1D550}", Ohe = "\u{1D56A}", $he = "\u{1D4B4}", jhe = "\u{1D4CE}", Nhe = "\u042E", Vhe = "\u044E", Uhe = "\xFF", qhe = "\u0178", Ghe = "\u0179", Whe = "\u017A", Zhe = "\u017D", Hhe = "\u017E", Xhe = "\u0417", Yhe = "\u0437", Khe = "\u017B", Jhe = "\u017C", Qhe = "\u2128", epe = "\u200B", tpe = "\u0396", rpe = "\u03B6", npe = "\u{1D537}", ipe = "\u2128", ope = "\u0416", spe = "\u0436", ape = "\u21DD", lpe = "\u{1D56B}", cpe = "\u2124", upe = "\u{1D4B5}", dpe = "\u{1D4CF}", hpe = "\u200D", ppe = "\u200C", fpe = { Aacute: K3, aacute: J3, Abreve: Q3, abreve: e5, ac: t5, acd: r5, acE: n5, Acirc: i5, acirc: o5, acute: s5, Acy: a5, acy: l5, AElig: c5, aelig: u5, af: d5, Afr: h5, afr: p5, Agrave: f5, agrave: m5, alefsym: g5, aleph: v5, Alpha: y5, alpha: _5, Amacr: b5, amacr: x5, amalg: w5, amp: C5, AMP: S5, andand: k5, And: P5, and: T5, andd: M5, andslope: I5, andv: E5, ang: R5, ange: z5, angle: A5, angmsdaa: D5, angmsdab: F5, angmsdac: L5, angmsdad: B5, angmsdae: O5, angmsdaf: $5, angmsdag: j5, angmsdah: N5, angmsd: V5, angrt: U5, angrtvb: q5, angrtvbd: G5, angsph: W5, angst: Z5, angzarr: H5, Aogon: X5, aogon: Y5, Aopf: K5, aopf: J5, apacir: Q5, ap: eD, apE: tD, ape: rD, apid: nD, apos: iD, ApplyFunction: oD, approx: sD, approxeq: aD, Aring: lD, aring: cD, Ascr: uD, ascr: dD, Assign: hD, ast: pD, asymp: fD, asympeq: mD, Atilde: gD, atilde: vD, Auml: yD, auml: _D, awconint: bD, awint: xD, backcong: wD, backepsilon: CD, backprime: SD, backsim: kD, backsimeq: PD, Backslash: TD, Barv: MD, barvee: ID, barwed: ED, Barwed: RD, barwedge: zD, bbrk: AD, bbrktbrk: DD, bcong: FD, Bcy: LD, bcy: BD, bdquo: OD, becaus: $D, because: jD, Because: ND, bemptyv: VD, bepsi: UD, bernou: qD, Bernoullis: GD, Beta: WD, beta: ZD, beth: HD, between: XD, Bfr: YD, bfr: KD, bigcap: JD, bigcirc: QD, bigcup: e4, bigodot: t4, bigoplus: r4, bigotimes: n4, bigsqcup: i4, bigstar: o4, bigtriangledown: s4, bigtriangleup: a4, biguplus: l4, bigvee: c4, bigwedge: u4, bkarow: d4, blacklozenge: h4, blacksquare: p4, blacktriangle: f4, blacktriangledown: m4, blacktriangleleft: g4, blacktriangleright: v4, blank: y4, blk12: _4, blk14: b4, blk34: x4, block: w4, bne: C4, bnequiv: S4, bNot: k4, bnot: P4, Bopf: T4, bopf: M4, bot: I4, bottom: E4, bowtie: R4, boxbox: z4, boxdl: A4, boxdL: D4, boxDl: F4, boxDL: L4, boxdr: B4, boxdR: O4, boxDr: $4, boxDR: j4, boxh: N4, boxH: V4, boxhd: U4, boxHd: q4, boxhD: G4, boxHD: W4, boxhu: Z4, boxHu: H4, boxhU: X4, boxHU: Y4, boxminus: K4, boxplus: J4, boxtimes: Q4, boxul: eF, boxuL: tF, boxUl: rF, boxUL: nF, boxur: iF, boxuR: oF, boxUr: sF, boxUR: aF, boxv: lF, boxV: cF, boxvh: uF, boxvH: dF, boxVh: hF, boxVH: pF, boxvl: fF, boxvL: mF, boxVl: gF, boxVL: vF, boxvr: yF, boxvR: _F, boxVr: bF, boxVR: xF, bprime: wF, breve: CF, Breve: SF, brvbar: kF, bscr: PF, Bscr: TF, bsemi: MF, bsim: IF, bsime: EF, bsolb: RF, bsol: zF, bsolhsub: AF, bull: DF, bullet: FF, bump: LF, bumpE: BF, bumpe: OF, Bumpeq: $F, bumpeq: jF, Cacute: NF, cacute: VF, capand: UF, capbrcup: qF, capcap: GF, cap: WF, Cap: ZF, capcup: HF, capdot: XF, CapitalDifferentialD: YF, caps: KF, caret: JF, caron: QF, Cayleys: eL, ccaps: tL, Ccaron: rL, ccaron: nL, Ccedil: iL, ccedil: oL, Ccirc: sL, ccirc: aL, Cconint: lL, ccups: cL, ccupssm: uL, Cdot: dL, cdot: hL, cedil: pL, Cedilla: fL, cemptyv: mL, cent: gL, centerdot: vL, CenterDot: yL, cfr: _L, Cfr: bL, CHcy: xL, chcy: wL, check: CL, checkmark: SL, Chi: kL, chi: PL, circ: TL, circeq: ML, circlearrowleft: IL, circlearrowright: EL, circledast: RL, circledcirc: zL, circleddash: AL, CircleDot: DL, circledR: FL, circledS: LL, CircleMinus: BL, CirclePlus: OL, CircleTimes: $L, cir: jL, cirE: NL, cire: VL, cirfnint: UL, cirmid: qL, cirscir: GL, ClockwiseContourIntegral: WL, CloseCurlyDoubleQuote: ZL, CloseCurlyQuote: HL, clubs: XL, clubsuit: YL, colon: KL, Colon: JL, Colone: QL, colone: e6, coloneq: t6, comma: r6, commat: n6, comp: i6, compfn: o6, complement: s6, complexes: a6, cong: l6, congdot: c6, Congruent: u6, conint: d6, Conint: h6, ContourIntegral: p6, copf: f6, Copf: m6, coprod: g6, Coproduct: v6, copy: y6, COPY: _6, copysr: b6, CounterClockwiseContourIntegral: x6, crarr: w6, cross: C6, Cross: S6, Cscr: k6, cscr: P6, csub: T6, csube: M6, csup: I6, csupe: E6, ctdot: R6, cudarrl: z6, cudarrr: A6, cuepr: D6, cuesc: F6, cularr: L6, cularrp: B6, cupbrcap: O6, cupcap: $6, CupCap: j6, cup: N6, Cup: V6, cupcup: U6, cupdot: q6, cupor: G6, cups: W6, curarr: Z6, curarrm: H6, curlyeqprec: X6, curlyeqsucc: Y6, curlyvee: K6, curlywedge: J6, curren: Q6, curvearrowleft: eB, curvearrowright: tB, cuvee: rB, cuwed: nB, cwconint: iB, cwint: oB, cylcty: sB, dagger: aB, Dagger: lB, daleth: cB, darr: uB, Darr: dB, dArr: hB, dash: pB, Dashv: fB, dashv: mB, dbkarow: gB, dblac: vB, Dcaron: yB, dcaron: _B, Dcy: bB, dcy: xB, ddagger: wB, ddarr: CB, DD: SB, dd: kB, DDotrahd: PB, ddotseq: TB, deg: MB, Del: IB, Delta: EB, delta: RB, demptyv: zB, dfisht: AB, Dfr: DB, dfr: FB, dHar: LB, dharl: BB, dharr: OB, DiacriticalAcute: $B, DiacriticalDot: jB, DiacriticalDoubleAcute: NB, DiacriticalGrave: VB, DiacriticalTilde: UB, diam: qB, diamond: GB, Diamond: WB, diamondsuit: ZB, diams: HB, die: XB, DifferentialD: YB, digamma: KB, disin: JB, div: QB, divide: eO, divideontimes: tO, divonx: rO, DJcy: nO, djcy: iO, dlcorn: oO, dlcrop: sO, dollar: aO, Dopf: lO, dopf: cO, Dot: uO, dot: dO, DotDot: hO, doteq: pO, doteqdot: fO, DotEqual: mO, dotminus: gO, dotplus: vO, dotsquare: yO, doublebarwedge: _O, DoubleContourIntegral: bO, DoubleDot: xO, DoubleDownArrow: wO, DoubleLeftArrow: CO, DoubleLeftRightArrow: SO, DoubleLeftTee: kO, DoubleLongLeftArrow: PO, DoubleLongLeftRightArrow: TO, DoubleLongRightArrow: MO, DoubleRightArrow: IO, DoubleRightTee: EO, DoubleUpArrow: RO, DoubleUpDownArrow: zO, DoubleVerticalBar: AO, DownArrowBar: DO, downarrow: FO, DownArrow: LO, Downarrow: BO, DownArrowUpArrow: OO, DownBreve: $O, downdownarrows: jO, downharpoonleft: NO, downharpoonright: VO, DownLeftRightVector: UO, DownLeftTeeVector: qO, DownLeftVectorBar: GO, DownLeftVector: WO, DownRightTeeVector: ZO, DownRightVectorBar: HO, DownRightVector: XO, DownTeeArrow: YO, DownTee: KO, drbkarow: JO, drcorn: QO, drcrop: e8, Dscr: t8, dscr: r8, DScy: n8, dscy: i8, dsol: o8, Dstrok: s8, dstrok: a8, dtdot: l8, dtri: c8, dtrif: u8, duarr: d8, duhar: h8, dwangle: p8, DZcy: f8, dzcy: m8, dzigrarr: g8, Eacute: v8, eacute: y8, easter: _8, Ecaron: b8, ecaron: x8, Ecirc: w8, ecirc: C8, ecir: S8, ecolon: k8, Ecy: P8, ecy: T8, eDDot: M8, Edot: I8, edot: E8, eDot: R8, ee: z8, efDot: A8, Efr: D8, efr: F8, eg: L8, Egrave: B8, egrave: O8, egs: $8, egsdot: j8, el: N8, Element: V8, elinters: U8, ell: q8, els: G8, elsdot: W8, Emacr: Z8, emacr: H8, empty: X8, emptyset: Y8, EmptySmallSquare: K8, emptyv: J8, EmptyVerySmallSquare: Q8, emsp13: e$, emsp14: t$, emsp: r$, ENG: n$, eng: i$, ensp: o$, Eogon: s$, eogon: a$, Eopf: l$, eopf: c$, epar: u$, eparsl: d$, eplus: h$, epsi: p$, Epsilon: f$, epsilon: m$, epsiv: g$, eqcirc: v$, eqcolon: y$, eqsim: _$, eqslantgtr: b$, eqslantless: x$, Equal: w$, equals: C$, EqualTilde: S$, equest: k$, Equilibrium: P$, equiv: T$, equivDD: M$, eqvparsl: I$, erarr: E$, erDot: R$, escr: z$, Escr: A$, esdot: D$, Esim: F$, esim: L$, Eta: B$, eta: O$, ETH: $$, eth: j$, Euml: N$, euml: V$, euro: U$, excl: q$, exist: G$, Exists: W$, expectation: Z$, exponentiale: H$, ExponentialE: X$, fallingdotseq: Y$, Fcy: K$, fcy: J$, female: Q$, ffilig: ej, fflig: tj, ffllig: rj, Ffr: nj, ffr: ij, filig: oj, FilledSmallSquare: sj, FilledVerySmallSquare: aj, fjlig: lj, flat: cj, fllig: uj, fltns: dj, fnof: hj, Fopf: pj, fopf: fj, forall: mj, ForAll: gj, fork: vj, forkv: yj, Fouriertrf: _j, fpartint: bj, frac12: xj, frac13: wj, frac14: Cj, frac15: Sj, frac16: kj, frac18: Pj, frac23: Tj, frac25: Mj, frac34: Ij, frac35: Ej, frac38: Rj, frac45: zj, frac56: Aj, frac58: Dj, frac78: Fj, frasl: Lj, frown: Bj, fscr: Oj, Fscr: $j, gacute: jj, Gamma: Nj, gamma: Vj, Gammad: Uj, gammad: qj, gap: Gj, Gbreve: Wj, gbreve: Zj, Gcedil: Hj, Gcirc: Xj, gcirc: Yj, Gcy: Kj, gcy: Jj, Gdot: Qj, gdot: eN, ge: tN, gE: rN, gEl: nN, gel: iN, geq: oN, geqq: sN, geqslant: aN, gescc: lN, ges: cN, gesdot: uN, gesdoto: dN, gesdotol: hN, gesl: pN, gesles: fN, Gfr: mN, gfr: gN, gg: vN, Gg: yN, ggg: _N, gimel: bN, GJcy: xN, gjcy: wN, gla: CN, gl: SN, glE: kN, glj: PN, gnap: TN, gnapprox: MN, gne: IN, gnE: EN, gneq: RN, gneqq: zN, gnsim: AN, Gopf: DN, gopf: FN, grave: LN, GreaterEqual: BN, GreaterEqualLess: ON, GreaterFullEqual: $N, GreaterGreater: jN, GreaterLess: NN, GreaterSlantEqual: VN, GreaterTilde: UN, Gscr: qN, gscr: GN, gsim: WN, gsime: ZN, gsiml: HN, gtcc: XN, gtcir: YN, gt: KN, GT: JN, Gt: QN, gtdot: eV, gtlPar: tV, gtquest: rV, gtrapprox: nV, gtrarr: iV, gtrdot: oV, gtreqless: sV, gtreqqless: aV, gtrless: lV, gtrsim: cV, gvertneqq: uV, gvnE: dV, Hacek: hV, hairsp: pV, half: fV, hamilt: mV, HARDcy: gV, hardcy: vV, harrcir: yV, harr: _V, hArr: bV, harrw: xV, Hat: wV, hbar: CV, Hcirc: SV, hcirc: kV, hearts: PV, heartsuit: TV, hellip: MV, hercon: IV, hfr: EV, Hfr: RV, HilbertSpace: zV, hksearow: AV, hkswarow: DV, hoarr: FV, homtht: LV, hookleftarrow: BV, hookrightarrow: OV, hopf: $V, Hopf: jV, horbar: NV, HorizontalLine: VV, hscr: UV, Hscr: qV, hslash: GV, Hstrok: WV, hstrok: ZV, HumpDownHump: HV, HumpEqual: XV, hybull: YV, hyphen: KV, Iacute: JV, iacute: QV, ic: e9, Icirc: t9, icirc: r9, Icy: n9, icy: i9, Idot: o9, IEcy: s9, iecy: a9, iexcl: l9, iff: c9, ifr: u9, Ifr: d9, Igrave: h9, igrave: p9, ii: f9, iiiint: m9, iiint: g9, iinfin: v9, iiota: y9, IJlig: _9, ijlig: b9, Imacr: x9, imacr: w9, image: C9, ImaginaryI: S9, imagline: k9, imagpart: P9, imath: T9, Im: M9, imof: I9, imped: E9, Implies: R9, incare: z9, in: "\u2208", infin: A9, infintie: D9, inodot: F9, intcal: L9, int: B9, Int: O9, integers: $9, Integral: j9, intercal: N9, Intersection: V9, intlarhk: U9, intprod: q9, InvisibleComma: G9, InvisibleTimes: W9, IOcy: Z9, iocy: H9, Iogon: X9, iogon: Y9, Iopf: K9, iopf: J9, Iota: Q9, iota: e7, iprod: t7, iquest: r7, iscr: n7, Iscr: i7, isin: o7, isindot: s7, isinE: a7, isins: l7, isinsv: c7, isinv: u7, it: d7, Itilde: h7, itilde: p7, Iukcy: f7, iukcy: m7, Iuml: g7, iuml: v7, Jcirc: y7, jcirc: _7, Jcy: b7, jcy: x7, Jfr: w7, jfr: C7, jmath: S7, Jopf: k7, jopf: P7, Jscr: T7, jscr: M7, Jsercy: I7, jsercy: E7, Jukcy: R7, jukcy: z7, Kappa: A7, kappa: D7, kappav: F7, Kcedil: L7, kcedil: B7, Kcy: O7, kcy: $7, Kfr: j7, kfr: N7, kgreen: V7, KHcy: U7, khcy: q7, KJcy: G7, kjcy: W7, Kopf: Z7, kopf: H7, Kscr: X7, kscr: Y7, lAarr: K7, Lacute: J7, lacute: Q7, laemptyv: eU, lagran: tU, Lambda: rU, lambda: nU, lang: iU, Lang: oU, langd: sU, langle: aU, lap: lU, Laplacetrf: cU, laquo: uU, larrb: dU, larrbfs: hU, larr: pU, Larr: fU, lArr: mU, larrfs: gU, larrhk: vU, larrlp: yU, larrpl: _U, larrsim: bU, larrtl: xU, latail: wU, lAtail: CU, lat: SU, late: kU, lates: PU, lbarr: TU, lBarr: MU, lbbrk: IU, lbrace: EU, lbrack: RU, lbrke: zU, lbrksld: AU, lbrkslu: DU, Lcaron: FU, lcaron: LU, Lcedil: BU, lcedil: OU, lceil: $U, lcub: jU, Lcy: NU, lcy: VU, ldca: UU, ldquo: qU, ldquor: GU, ldrdhar: WU, ldrushar: ZU, ldsh: HU, le: XU, lE: YU, LeftAngleBracket: KU, LeftArrowBar: JU, leftarrow: QU, LeftArrow: eq, Leftarrow: tq, LeftArrowRightArrow: rq, leftarrowtail: nq, LeftCeiling: iq, LeftDoubleBracket: oq, LeftDownTeeVector: sq, LeftDownVectorBar: aq, LeftDownVector: lq, LeftFloor: cq, leftharpoondown: uq, leftharpoonup: dq, leftleftarrows: hq, leftrightarrow: pq, LeftRightArrow: fq, Leftrightarrow: mq, leftrightarrows: gq, leftrightharpoons: vq, leftrightsquigarrow: yq, LeftRightVector: _q, LeftTeeArrow: bq, LeftTee: xq, LeftTeeVector: wq, leftthreetimes: Cq, LeftTriangleBar: Sq, LeftTriangle: kq, LeftTriangleEqual: Pq, LeftUpDownVector: Tq, LeftUpTeeVector: Mq, LeftUpVectorBar: Iq, LeftUpVector: Eq, LeftVectorBar: Rq, LeftVector: zq, lEg: Aq, leg: Dq, leq: Fq, leqq: Lq, leqslant: Bq, lescc: Oq, les: $q, lesdot: jq, lesdoto: Nq, lesdotor: Vq, lesg: Uq, lesges: qq, lessapprox: Gq, lessdot: Wq, lesseqgtr: Zq, lesseqqgtr: Hq, LessEqualGreater: Xq, LessFullEqual: Yq, LessGreater: Kq, lessgtr: Jq, LessLess: Qq, lesssim: eG, LessSlantEqual: tG, LessTilde: rG, lfisht: nG, lfloor: iG, Lfr: oG, lfr: sG, lg: aG, lgE: lG, lHar: cG, lhard: uG, lharu: dG, lharul: hG, lhblk: pG, LJcy: fG, ljcy: mG, llarr: gG, ll: vG, Ll: yG, llcorner: _G, Lleftarrow: bG, llhard: xG, lltri: wG, Lmidot: CG, lmidot: SG, lmoustache: kG, lmoust: PG, lnap: TG, lnapprox: MG, lne: IG, lnE: EG, lneq: RG, lneqq: zG, lnsim: AG, loang: DG, loarr: FG, lobrk: LG, longleftarrow: BG, LongLeftArrow: OG, Longleftarrow: $G, longleftrightarrow: jG, LongLeftRightArrow: NG, Longleftrightarrow: VG, longmapsto: UG, longrightarrow: qG, LongRightArrow: GG, Longrightarrow: WG, looparrowleft: ZG, looparrowright: HG, lopar: XG, Lopf: YG, lopf: KG, loplus: JG, lotimes: QG, lowast: eW, lowbar: tW, LowerLeftArrow: rW, LowerRightArrow: nW, loz: iW, lozenge: oW, lozf: sW, lpar: aW, lparlt: lW, lrarr: cW, lrcorner: uW, lrhar: dW, lrhard: hW, lrm: pW, lrtri: fW, lsaquo: mW, lscr: gW, Lscr: vW, lsh: yW, Lsh: _W, lsim: bW, lsime: xW, lsimg: wW, lsqb: CW, lsquo: SW, lsquor: kW, Lstrok: PW, lstrok: TW, ltcc: MW, ltcir: IW, lt: EW, LT: RW, Lt: zW, ltdot: AW, lthree: DW, ltimes: FW, ltlarr: LW, ltquest: BW, ltri: OW, ltrie: $W, ltrif: jW, ltrPar: NW, lurdshar: VW, luruhar: UW, lvertneqq: qW, lvnE: GW, macr: WW, male: ZW, malt: HW, maltese: XW, Map: "\u2905", map: YW, mapsto: KW, mapstodown: JW, mapstoleft: QW, mapstoup: eZ, marker: tZ, mcomma: rZ, Mcy: nZ, mcy: iZ, mdash: oZ, mDDot: sZ, measuredangle: aZ, MediumSpace: lZ, Mellintrf: cZ, Mfr: uZ, mfr: dZ, mho: hZ, micro: pZ, midast: fZ, midcir: mZ, mid: gZ, middot: vZ, minusb: yZ, minus: _Z, minusd: bZ, minusdu: xZ, MinusPlus: wZ, mlcp: CZ, mldr: SZ, mnplus: kZ, models: PZ, Mopf: TZ, mopf: MZ, mp: IZ, mscr: EZ, Mscr: RZ, mstpos: zZ, Mu: AZ, mu: DZ, multimap: FZ, mumap: LZ, nabla: BZ, Nacute: OZ, nacute: $Z, nang: jZ, nap: NZ, napE: VZ, napid: UZ, napos: qZ, napprox: GZ, natural: WZ, naturals: ZZ, natur: HZ, nbsp: XZ, nbump: YZ, nbumpe: KZ, ncap: JZ, Ncaron: QZ, ncaron: eH, Ncedil: tH, ncedil: rH, ncong: nH, ncongdot: iH, ncup: oH, Ncy: sH, ncy: aH, ndash: lH, nearhk: cH, nearr: uH, neArr: dH, nearrow: hH, ne: pH, nedot: fH, NegativeMediumSpace: mH, NegativeThickSpace: gH, NegativeThinSpace: vH, NegativeVeryThinSpace: yH, nequiv: _H, nesear: bH, nesim: xH, NestedGreaterGreater: wH, NestedLessLess: CH, NewLine: SH, nexist: kH, nexists: PH, Nfr: TH, nfr: MH, ngE: IH, nge: EH, ngeq: RH, ngeqq: zH, ngeqslant: AH, nges: DH, nGg: FH, ngsim: LH, nGt: BH, ngt: OH, ngtr: $H, nGtv: jH, nharr: NH, nhArr: VH, nhpar: UH, ni: qH, nis: GH, nisd: WH, niv: ZH, NJcy: HH, njcy: XH, nlarr: YH, nlArr: KH, nldr: JH, nlE: QH, nle: eX, nleftarrow: tX, nLeftarrow: rX, nleftrightarrow: nX, nLeftrightarrow: iX, nleq: oX, nleqq: sX, nleqslant: aX, nles: lX, nless: cX, nLl: uX, nlsim: dX, nLt: hX, nlt: pX, nltri: fX, nltrie: mX, nLtv: gX, nmid: vX, NoBreak: yX, NonBreakingSpace: _X, nopf: bX, Nopf: xX, Not: wX, not: CX, NotCongruent: SX, NotCupCap: kX, NotDoubleVerticalBar: PX, NotElement: TX, NotEqual: MX, NotEqualTilde: IX, NotExists: EX, NotGreater: RX, NotGreaterEqual: zX, NotGreaterFullEqual: AX, NotGreaterGreater: DX, NotGreaterLess: FX, NotGreaterSlantEqual: LX, NotGreaterTilde: BX, NotHumpDownHump: OX, NotHumpEqual: $X, notin: jX, notindot: NX, notinE: VX, notinva: UX, notinvb: qX, notinvc: GX, NotLeftTriangleBar: WX, NotLeftTriangle: ZX, NotLeftTriangleEqual: HX, NotLess: XX, NotLessEqual: YX, NotLessGreater: KX, NotLessLess: JX, NotLessSlantEqual: QX, NotLessTilde: eY, NotNestedGreaterGreater: tY, NotNestedLessLess: rY, notni: nY, notniva: iY, notnivb: oY, notnivc: sY, NotPrecedes: aY, NotPrecedesEqual: lY, NotPrecedesSlantEqual: cY, NotReverseElement: uY, NotRightTriangleBar: dY, NotRightTriangle: hY, NotRightTriangleEqual: pY, NotSquareSubset: fY, NotSquareSubsetEqual: mY, NotSquareSuperset: gY, NotSquareSupersetEqual: vY, NotSubset: yY, NotSubsetEqual: _Y, NotSucceeds: bY, NotSucceedsEqual: xY, NotSucceedsSlantEqual: wY, NotSucceedsTilde: CY, NotSuperset: SY, NotSupersetEqual: kY, NotTilde: PY, NotTildeEqual: TY, NotTildeFullEqual: MY, NotTildeTilde: IY, NotVerticalBar: EY, nparallel: RY, npar: zY, nparsl: AY, npart: DY, npolint: FY, npr: LY, nprcue: BY, nprec: OY, npreceq: $Y, npre: jY, nrarrc: NY, nrarr: VY, nrArr: UY, nrarrw: qY, nrightarrow: GY, nRightarrow: WY, nrtri: ZY, nrtrie: HY, nsc: XY, nsccue: YY, nsce: KY, Nscr: JY, nscr: QY, nshortmid: eK, nshortparallel: tK, nsim: rK, nsime: nK, nsimeq: iK, nsmid: oK, nspar: sK, nsqsube: aK, nsqsupe: lK, nsub: cK, nsubE: uK, nsube: dK, nsubset: hK, nsubseteq: pK, nsubseteqq: fK, nsucc: mK, nsucceq: gK, nsup: vK, nsupE: yK, nsupe: _K, nsupset: bK, nsupseteq: xK, nsupseteqq: wK, ntgl: CK, Ntilde: SK, ntilde: kK, ntlg: PK, ntriangleleft: TK, ntrianglelefteq: MK, ntriangleright: IK, ntrianglerighteq: EK, Nu: RK, nu: zK, num: AK, numero: DK, numsp: FK, nvap: LK, nvdash: BK, nvDash: OK, nVdash: $K, nVDash: jK, nvge: NK, nvgt: VK, nvHarr: UK, nvinfin: qK, nvlArr: GK, nvle: WK, nvlt: ZK, nvltrie: HK, nvrArr: XK, nvrtrie: YK, nvsim: KK, nwarhk: JK, nwarr: QK, nwArr: eJ, nwarrow: tJ, nwnear: rJ, Oacute: nJ, oacute: iJ, oast: oJ, Ocirc: sJ, ocirc: aJ, ocir: lJ, Ocy: cJ, ocy: uJ, odash: dJ, Odblac: hJ, odblac: pJ, odiv: fJ, odot: mJ, odsold: gJ, OElig: vJ, oelig: yJ, ofcir: _J, Ofr: bJ, ofr: xJ, ogon: wJ, Ograve: CJ, ograve: SJ, ogt: kJ, ohbar: PJ, ohm: TJ, oint: MJ, olarr: IJ, olcir: EJ, olcross: RJ, oline: zJ, olt: AJ, Omacr: DJ, omacr: FJ, Omega: LJ, omega: BJ, Omicron: OJ, omicron: $J, omid: jJ, ominus: NJ, Oopf: VJ, oopf: UJ, opar: qJ, OpenCurlyDoubleQuote: GJ, OpenCurlyQuote: WJ, operp: ZJ, oplus: HJ, orarr: XJ, Or: YJ, or: KJ, ord: JJ, order: QJ, orderof: eQ, ordf: tQ, ordm: rQ, origof: nQ, oror: iQ, orslope: oQ, orv: sQ, oS: aQ, Oscr: lQ, oscr: cQ, Oslash: uQ, oslash: dQ, osol: hQ, Otilde: pQ, otilde: fQ, otimesas: mQ, Otimes: gQ, otimes: vQ, Ouml: yQ, ouml: _Q, ovbar: bQ, OverBar: xQ, OverBrace: wQ, OverBracket: CQ, OverParenthesis: SQ, para: kQ, parallel: PQ, par: TQ, parsim: MQ, parsl: IQ, part: EQ, PartialD: RQ, Pcy: zQ, pcy: AQ, percnt: DQ, period: FQ, permil: LQ, perp: BQ, pertenk: OQ, Pfr: $Q, pfr: jQ, Phi: NQ, phi: VQ, phiv: UQ, phmmat: qQ, phone: GQ, Pi: WQ, pi: ZQ, pitchfork: HQ, piv: XQ, planck: YQ, planckh: KQ, plankv: JQ, plusacir: QQ, plusb: eee, pluscir: tee, plus: ree, plusdo: nee, plusdu: iee, pluse: oee, PlusMinus: see, plusmn: aee, plussim: lee, plustwo: cee, pm: uee, Poincareplane: dee, pointint: hee, popf: pee, Popf: fee, pound: mee, prap: gee, Pr: vee, pr: yee, prcue: _ee, precapprox: bee, prec: xee, preccurlyeq: wee, Precedes: Cee, PrecedesEqual: See, PrecedesSlantEqual: kee, PrecedesTilde: Pee, preceq: Tee, precnapprox: Mee, precneqq: Iee, precnsim: Eee, pre: Ree, prE: zee, precsim: Aee, prime: Dee, Prime: Fee, primes: Lee, prnap: Bee, prnE: Oee, prnsim: $ee, prod: jee, Product: Nee, profalar: Vee, profline: Uee, profsurf: qee, prop: Gee, Proportional: Wee, Proportion: Zee, propto: Hee, prsim: Xee, prurel: Yee, Pscr: Kee, pscr: Jee, Psi: Qee, psi: ete, puncsp: tte, Qfr: rte, qfr: nte, qint: ite, qopf: ote, Qopf: ste, qprime: ate, Qscr: lte, qscr: cte, quaternions: ute, quatint: dte, quest: hte, questeq: pte, quot: fte, QUOT: mte, rAarr: gte, race: vte, Racute: yte, racute: _te, radic: bte, raemptyv: xte, rang: wte, Rang: Cte, rangd: Ste, range: kte, rangle: Pte, raquo: Tte, rarrap: Mte, rarrb: Ite, rarrbfs: Ete, rarrc: Rte, rarr: zte, Rarr: Ate, rArr: Dte, rarrfs: Fte, rarrhk: Lte, rarrlp: Bte, rarrpl: Ote, rarrsim: $te, Rarrtl: jte, rarrtl: Nte, rarrw: Vte, ratail: Ute, rAtail: qte, ratio: Gte, rationals: Wte, rbarr: Zte, rBarr: Hte, RBarr: Xte, rbbrk: Yte, rbrace: Kte, rbrack: Jte, rbrke: Qte, rbrksld: ere, rbrkslu: tre, Rcaron: rre, rcaron: nre, Rcedil: ire, rcedil: ore, rceil: sre, rcub: are, Rcy: lre, rcy: cre, rdca: ure, rdldhar: dre, rdquo: hre, rdquor: pre, rdsh: fre, real: mre, realine: gre, realpart: vre, reals: yre, Re: _re, rect: bre, reg: xre, REG: wre, ReverseElement: Cre, ReverseEquilibrium: Sre, ReverseUpEquilibrium: kre, rfisht: Pre, rfloor: Tre, rfr: Mre, Rfr: Ire, rHar: Ere, rhard: Rre, rharu: zre, rharul: Are, Rho: Dre, rho: Fre, rhov: Lre, RightAngleBracket: Bre, RightArrowBar: Ore, rightarrow: $re, RightArrow: jre, Rightarrow: Nre, RightArrowLeftArrow: Vre, rightarrowtail: Ure, RightCeiling: qre, RightDoubleBracket: Gre, RightDownTeeVector: Wre, RightDownVectorBar: Zre, RightDownVector: Hre, RightFloor: Xre, rightharpoondown: Yre, rightharpoonup: Kre, rightleftarrows: Jre, rightleftharpoons: Qre, rightrightarrows: ene, rightsquigarrow: tne, RightTeeArrow: rne, RightTee: nne, RightTeeVector: ine, rightthreetimes: one, RightTriangleBar: sne, RightTriangle: ane, RightTriangleEqual: lne, RightUpDownVector: cne, RightUpTeeVector: une, RightUpVectorBar: dne, RightUpVector: hne, RightVectorBar: pne, RightVector: fne, ring: mne, risingdotseq: gne, rlarr: vne, rlhar: yne, rlm: _ne, rmoustache: bne, rmoust: xne, rnmid: wne, roang: Cne, roarr: Sne, robrk: kne, ropar: Pne, ropf: Tne, Ropf: Mne, roplus: Ine, rotimes: Ene, RoundImplies: Rne, rpar: zne, rpargt: Ane, rppolint: Dne, rrarr: Fne, Rrightarrow: Lne, rsaquo: Bne, rscr: One, Rscr: $ne, rsh: jne, Rsh: Nne, rsqb: Vne, rsquo: Une, rsquor: qne, rthree: Gne, rtimes: Wne, rtri: Zne, rtrie: Hne, rtrif: Xne, rtriltri: Yne, RuleDelayed: Kne, ruluhar: Jne, rx: Qne, Sacute: eie, sacute: tie, sbquo: rie, scap: nie, Scaron: iie, scaron: oie, Sc: sie, sc: aie, sccue: lie, sce: cie, scE: uie, Scedil: die, scedil: hie, Scirc: pie, scirc: fie, scnap: mie, scnE: gie, scnsim: vie, scpolint: yie, scsim: _ie, Scy: bie, scy: xie, sdotb: wie, sdot: Cie, sdote: Sie, searhk: kie, searr: Pie, seArr: Tie, searrow: Mie, sect: Iie, semi: Eie, seswar: Rie, setminus: zie, setmn: Aie, sext: Die, Sfr: Fie, sfr: Lie, sfrown: Bie, sharp: Oie, SHCHcy: $ie, shchcy: jie, SHcy: Nie, shcy: Vie, ShortDownArrow: Uie, ShortLeftArrow: qie, shortmid: Gie, shortparallel: Wie, ShortRightArrow: Zie, ShortUpArrow: Hie, shy: Xie, Sigma: Yie, sigma: Kie, sigmaf: Jie, sigmav: Qie, sim: eoe, simdot: toe, sime: roe, simeq: noe, simg: ioe, simgE: ooe, siml: soe, simlE: aoe, simne: loe, simplus: coe, simrarr: uoe, slarr: doe, SmallCircle: hoe, smallsetminus: poe, smashp: foe, smeparsl: moe, smid: goe, smile: voe, smt: yoe, smte: _oe, smtes: boe, SOFTcy: xoe, softcy: woe, solbar: Coe, solb: Soe, sol: koe, Sopf: Poe, sopf: Toe, spades: Moe, spadesuit: Ioe, spar: Eoe, sqcap: Roe, sqcaps: zoe, sqcup: Aoe, sqcups: Doe, Sqrt: Foe, sqsub: Loe, sqsube: Boe, sqsubset: Ooe, sqsubseteq: $oe, sqsup: joe, sqsupe: Noe, sqsupset: Voe, sqsupseteq: Uoe, square: qoe, Square: Goe, SquareIntersection: Woe, SquareSubset: Zoe, SquareSubsetEqual: Hoe, SquareSuperset: Xoe, SquareSupersetEqual: Yoe, SquareUnion: Koe, squarf: Joe, squ: Qoe, squf: ese, srarr: tse, Sscr: rse, sscr: nse, ssetmn: ise, ssmile: ose, sstarf: sse, Star: ase, star: lse, starf: cse, straightepsilon: use, straightphi: dse, strns: hse, sub: pse, Sub: fse, subdot: mse, subE: gse, sube: vse, subedot: yse, submult: _se, subnE: bse, subne: xse, subplus: wse, subrarr: Cse, subset: Sse, Subset: kse, subseteq: Pse, subseteqq: Tse, SubsetEqual: Mse, subsetneq: Ise, subsetneqq: Ese, subsim: Rse, subsub: zse, subsup: Ase, succapprox: Dse, succ: Fse, succcurlyeq: Lse, Succeeds: Bse, SucceedsEqual: Ose, SucceedsSlantEqual: $se, SucceedsTilde: jse, succeq: Nse, succnapprox: Vse, succneqq: Use, succnsim: qse, succsim: Gse, SuchThat: Wse, sum: Zse, Sum: Hse, sung: Xse, sup1: Yse, sup2: Kse, sup3: Jse, sup: Qse, Sup: eae, supdot: tae, supdsub: rae, supE: nae, supe: iae, supedot: oae, Superset: sae, SupersetEqual: aae, suphsol: lae, suphsub: cae, suplarr: uae, supmult: dae, supnE: hae, supne: pae, supplus: fae, supset: mae, Supset: gae, supseteq: vae, supseteqq: yae, supsetneq: _ae, supsetneqq: bae, supsim: xae, supsub: wae, supsup: Cae, swarhk: Sae, swarr: kae, swArr: Pae, swarrow: Tae, swnwar: Mae, szlig: Iae, Tab: Eae, target: Rae, Tau: zae, tau: Aae, tbrk: Dae, Tcaron: Fae, tcaron: Lae, Tcedil: Bae, tcedil: Oae, Tcy: $ae, tcy: jae, tdot: Nae, telrec: Vae, Tfr: Uae, tfr: qae, there4: Gae, therefore: Wae, Therefore: Zae, Theta: Hae, theta: Xae, thetasym: Yae, thetav: Kae, thickapprox: Jae, thicksim: Qae, ThickSpace: ele, ThinSpace: tle, thinsp: rle, thkap: nle, thksim: ile, THORN: ole, thorn: sle, tilde: ale, Tilde: lle, TildeEqual: cle, TildeFullEqual: ule, TildeTilde: dle, timesbar: hle, timesb: ple, times: fle, timesd: mle, tint: gle, toea: vle, topbot: yle, topcir: _le, top: ble, Topf: xle, topf: wle, topfork: Cle, tosa: Sle, tprime: kle, trade: Ple, TRADE: Tle, triangle: Mle, triangledown: Ile, triangleleft: Ele, trianglelefteq: Rle, triangleq: zle, triangleright: Ale, trianglerighteq: Dle, tridot: Fle, trie: Lle, triminus: Ble, TripleDot: Ole, triplus: $le, trisb: jle, tritime: Nle, trpezium: Vle, Tscr: Ule, tscr: qle, TScy: Gle, tscy: Wle, TSHcy: Zle, tshcy: Hle, Tstrok: Xle, tstrok: Yle, twixt: Kle, twoheadleftarrow: Jle, twoheadrightarrow: Qle, Uacute: ece, uacute: tce, uarr: rce, Uarr: nce, uArr: ice, Uarrocir: oce, Ubrcy: sce, ubrcy: ace, Ubreve: lce, ubreve: cce, Ucirc: uce, ucirc: dce, Ucy: hce, ucy: pce, udarr: fce, Udblac: mce, udblac: gce, udhar: vce, ufisht: yce, Ufr: _ce, ufr: bce, Ugrave: xce, ugrave: wce, uHar: Cce, uharl: Sce, uharr: kce, uhblk: Pce, ulcorn: Tce, ulcorner: Mce, ulcrop: Ice, ultri: Ece, Umacr: Rce, umacr: zce, uml: Ace, UnderBar: Dce, UnderBrace: Fce, UnderBracket: Lce, UnderParenthesis: Bce, Union: Oce, UnionPlus: $ce, Uogon: jce, uogon: Nce, Uopf: Vce, uopf: Uce, UpArrowBar: qce, uparrow: Gce, UpArrow: Wce, Uparrow: Zce, UpArrowDownArrow: Hce, updownarrow: Xce, UpDownArrow: Yce, Updownarrow: Kce, UpEquilibrium: Jce, upharpoonleft: Qce, upharpoonright: eue, uplus: tue, UpperLeftArrow: rue, UpperRightArrow: nue, upsi: iue, Upsi: oue, upsih: sue, Upsilon: aue, upsilon: lue, UpTeeArrow: cue, UpTee: uue, upuparrows: due, urcorn: hue, urcorner: pue, urcrop: fue, Uring: mue, uring: gue, urtri: vue, Uscr: yue, uscr: _ue, utdot: bue, Utilde: xue, utilde: wue, utri: Cue, utrif: Sue, uuarr: kue, Uuml: Pue, uuml: Tue, uwangle: Mue, vangrt: Iue, varepsilon: Eue, varkappa: Rue, varnothing: zue, varphi: Aue, varpi: Due, varpropto: Fue, varr: Lue, vArr: Bue, varrho: Oue, varsigma: $ue, varsubsetneq: jue, varsubsetneqq: Nue, varsupsetneq: Vue, varsupsetneqq: Uue, vartheta: que, vartriangleleft: Gue, vartriangleright: Wue, vBar: Zue, Vbar: Hue, vBarv: Xue, Vcy: Yue, vcy: Kue, vdash: Jue, vDash: Que, Vdash: ede, VDash: tde, Vdashl: rde, veebar: nde, vee: ide, Vee: ode, veeeq: sde, vellip: ade, verbar: lde, Verbar: cde, vert: ude, Vert: dde, VerticalBar: hde, VerticalLine: pde, VerticalSeparator: fde, VerticalTilde: mde, VeryThinSpace: gde, Vfr: vde, vfr: yde, vltri: _de, vnsub: bde, vnsup: xde, Vopf: wde, vopf: Cde, vprop: Sde, vrtri: kde, Vscr: Pde, vscr: Tde, vsubnE: Mde, vsubne: Ide, vsupnE: Ede, vsupne: Rde, Vvdash: zde, vzigzag: Ade, Wcirc: Dde, wcirc: Fde, wedbar: Lde, wedge: Bde, Wedge: Ode, wedgeq: $de, weierp: jde, Wfr: Nde, wfr: Vde, Wopf: Ude, wopf: qde, wp: Gde, wr: Wde, wreath: Zde, Wscr: Hde, wscr: Xde, xcap: Yde, xcirc: Kde, xcup: Jde, xdtri: Qde, Xfr: ehe, xfr: the, xharr: rhe, xhArr: nhe, Xi: ihe, xi: ohe, xlarr: she, xlArr: ahe, xmap: lhe, xnis: che, xodot: uhe, Xopf: dhe, xopf: hhe, xoplus: phe, xotime: fhe, xrarr: mhe, xrArr: ghe, Xscr: vhe, xscr: yhe, xsqcup: _he, xuplus: bhe, xutri: xhe, xvee: whe, xwedge: Che, Yacute: She, yacute: khe, YAcy: Phe, yacy: The, Ycirc: Mhe, ycirc: Ihe, Ycy: Ehe, ycy: Rhe, yen: zhe, Yfr: Ahe, yfr: Dhe, YIcy: Fhe, yicy: Lhe, Yopf: Bhe, yopf: Ohe, Yscr: $he, yscr: jhe, YUcy: Nhe, yucy: Vhe, yuml: Uhe, Yuml: qhe, Zacute: Ghe, zacute: Whe, Zcaron: Zhe, zcaron: Hhe, Zcy: Xhe, zcy: Yhe, Zdot: Khe, zdot: Jhe, zeetrf: Qhe, ZeroWidthSpace: epe, Zeta: tpe, zeta: rpe, zfr: npe, Zfr: ipe, ZHcy: ope, zhcy: spe, zigrarr: ape, zopf: lpe, Zopf: cpe, Zscr: upe, zscr: dpe, zwj: hpe, zwnj: ppe };
var Dm, A0;
function iw() {
  return A0 || (A0 = 1, Dm = fpe), Dm;
}
var Fm, D0;
function Bv() {
  return D0 || (D0 = 1, Fm = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/), Fm;
}
var Vc = {}, Lm, F0;
function mpe() {
  if (F0) return Lm;
  F0 = 1;
  var a = {};
  function i(d) {
    var h, g, p = a[d];
    if (p) return p;
    for (p = a[d] = [], h = 0; h < 128; h++) g = String.fromCharCode(h), /^[0-9a-z]$/i.test(g) ? p.push(g) : p.push("%" + ("0" + h.toString(16).toUpperCase()).slice(-2));
    for (h = 0; h < d.length; h++) p[d.charCodeAt(h)] = d[h];
    return p;
  }
  function l(d, h, g) {
    var p, o, w, S, k, I = "";
    for (typeof h != "string" && (g = h, h = l.defaultChars), typeof g > "u" && (g = true), k = i(h), p = 0, o = d.length; p < o; p++) {
      if (w = d.charCodeAt(p), g && w === 37 && p + 2 < o && /^[0-9a-f]{2}$/i.test(d.slice(p + 1, p + 3))) {
        I += d.slice(p, p + 3), p += 2;
        continue;
      }
      if (w < 128) {
        I += k[w];
        continue;
      }
      if (w >= 55296 && w <= 57343) {
        if (w >= 55296 && w <= 56319 && p + 1 < o && (S = d.charCodeAt(p + 1), S >= 56320 && S <= 57343)) {
          I += encodeURIComponent(d[p] + d[p + 1]), p++;
          continue;
        }
        I += "%EF%BF%BD";
        continue;
      }
      I += encodeURIComponent(d[p]);
    }
    return I;
  }
  return l.defaultChars = ";/?:@&=+$,-_.!~*'()#", l.componentChars = "-_.!~*'()", Lm = l, Lm;
}
var Bm, L0;
function gpe() {
  if (L0) return Bm;
  L0 = 1;
  var a = {};
  function i(d) {
    var h, g, p = a[d];
    if (p) return p;
    for (p = a[d] = [], h = 0; h < 128; h++) g = String.fromCharCode(h), p.push(g);
    for (h = 0; h < d.length; h++) g = d.charCodeAt(h), p[g] = "%" + ("0" + g.toString(16).toUpperCase()).slice(-2);
    return p;
  }
  function l(d, h) {
    var g;
    return typeof h != "string" && (h = l.defaultChars), g = i(h), d.replace(/(%[a-f0-9]{2})+/gi, function(p) {
      var o, w, S, k, I, z, R, O = "";
      for (o = 0, w = p.length; o < w; o += 3) {
        if (S = parseInt(p.slice(o + 1, o + 3), 16), S < 128) {
          O += g[S];
          continue;
        }
        if ((S & 224) === 192 && o + 3 < w && (k = parseInt(p.slice(o + 4, o + 6), 16), (k & 192) === 128)) {
          R = S << 6 & 1984 | k & 63, R < 128 ? O += "\uFFFD\uFFFD" : O += String.fromCharCode(R), o += 3;
          continue;
        }
        if ((S & 240) === 224 && o + 6 < w && (k = parseInt(p.slice(o + 4, o + 6), 16), I = parseInt(p.slice(o + 7, o + 9), 16), (k & 192) === 128 && (I & 192) === 128)) {
          R = S << 12 & 61440 | k << 6 & 4032 | I & 63, R < 2048 || R >= 55296 && R <= 57343 ? O += "\uFFFD\uFFFD\uFFFD" : O += String.fromCharCode(R), o += 6;
          continue;
        }
        if ((S & 248) === 240 && o + 9 < w && (k = parseInt(p.slice(o + 4, o + 6), 16), I = parseInt(p.slice(o + 7, o + 9), 16), z = parseInt(p.slice(o + 10, o + 12), 16), (k & 192) === 128 && (I & 192) === 128 && (z & 192) === 128)) {
          R = S << 18 & 1835008 | k << 12 & 258048 | I << 6 & 4032 | z & 63, R < 65536 || R > 1114111 ? O += "\uFFFD\uFFFD\uFFFD\uFFFD" : (R -= 65536, O += String.fromCharCode(55296 + (R >> 10), 56320 + (R & 1023))), o += 9;
          continue;
        }
        O += "\uFFFD";
      }
      return O;
    });
  }
  return l.defaultChars = ";/?:@&=+$,#", l.componentChars = "", Bm = l, Bm;
}
var Om, B0;
function vpe() {
  return B0 || (B0 = 1, Om = function(i) {
    var l = "";
    return l += i.protocol || "", l += i.slashes ? "//" : "", l += i.auth ? i.auth + "@" : "", i.hostname && i.hostname.indexOf(":") !== -1 ? l += "[" + i.hostname + "]" : l += i.hostname || "", l += i.port ? ":" + i.port : "", l += i.pathname || "", l += i.search || "", l += i.hash || "", l;
  }), Om;
}
var $m, O0;
function ype() {
  if (O0) return $m;
  O0 = 1;
  function a() {
    this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
  }
  var i = /^([a-z0-9.+-]+:)/i, l = /:[0-9]*$/, d = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h = ["<", ">", '"', "`", " ", "\r", `
`, "	"], g = ["{", "}", "|", "\\", "^", "`"].concat(h), p = ["'"].concat(g), o = ["%", "/", "?", ";", "#"].concat(p), w = ["/", "?", "#"], S = 255, k = /^[+a-z0-9A-Z_-]{0,63}$/, I = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, z = { javascript: true, "javascript:": true }, R = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  function O(V, W) {
    if (V && V instanceof a) return V;
    var N = new a();
    return N.parse(V, W), N;
  }
  return a.prototype.parse = function(V, W) {
    var N, K, Z, X, te, q = V;
    if (q = q.trim(), !W && V.split("#").length === 1) {
      var he = d.exec(q);
      if (he) return this.pathname = he[1], he[2] && (this.search = he[2]), this;
    }
    var se = i.exec(q);
    if (se && (se = se[0], Z = se.toLowerCase(), this.protocol = se, q = q.substr(se.length)), (W || se || q.match(/^\/\/[^@\/]+@[^@\/]+/)) && (te = q.substr(0, 2) === "//", te && !(se && z[se]) && (q = q.substr(2), this.slashes = true)), !z[se] && (te || se && !R[se])) {
      var Q = -1;
      for (N = 0; N < w.length; N++) X = q.indexOf(w[N]), X !== -1 && (Q === -1 || X < Q) && (Q = X);
      var oe, ve;
      for (Q === -1 ? ve = q.lastIndexOf("@") : ve = q.lastIndexOf("@", Q), ve !== -1 && (oe = q.slice(0, ve), q = q.slice(ve + 1), this.auth = oe), Q = -1, N = 0; N < o.length; N++) X = q.indexOf(o[N]), X !== -1 && (Q === -1 || X < Q) && (Q = X);
      Q === -1 && (Q = q.length), q[Q - 1] === ":" && Q--;
      var Be = q.slice(0, Q);
      q = q.slice(Q), this.parseHost(Be), this.hostname = this.hostname || "";
      var Ne = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!Ne) {
        var Pe = this.hostname.split(/\./);
        for (N = 0, K = Pe.length; N < K; N++) {
          var tt = Pe[N];
          if (tt && !tt.match(k)) {
            for (var at = "", xt = 0, ht = tt.length; xt < ht; xt++) tt.charCodeAt(xt) > 127 ? at += "x" : at += tt[xt];
            if (!at.match(k)) {
              var Ye = Pe.slice(0, N), Ke = Pe.slice(N + 1), Lt = tt.match(I);
              Lt && (Ye.push(Lt[1]), Ke.unshift(Lt[2])), Ke.length && (q = Ke.join(".") + q), this.hostname = Ye.join(".");
              break;
            }
          }
        }
      }
      this.hostname.length > S && (this.hostname = ""), Ne && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
    }
    var ct = q.indexOf("#");
    ct !== -1 && (this.hash = q.substr(ct), q = q.slice(0, ct));
    var bt = q.indexOf("?");
    return bt !== -1 && (this.search = q.substr(bt), q = q.slice(0, bt)), q && (this.pathname = q), R[Z] && this.hostname && !this.pathname && (this.pathname = ""), this;
  }, a.prototype.parseHost = function(V) {
    var W = l.exec(V);
    W && (W = W[0], W !== ":" && (this.port = W.substr(1)), V = V.substr(0, V.length - W.length)), V && (this.hostname = V);
  }, $m = O, $m;
}
var $0;
function ow() {
  return $0 || ($0 = 1, Vc.encode = mpe(), Vc.decode = gpe(), Vc.format = vpe(), Vc.parse = ype()), Vc;
}
var yl = {}, jm, j0;
function sw() {
  return j0 || (j0 = 1, jm = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), jm;
}
var Nm, N0;
function aw() {
  return N0 || (N0 = 1, Nm = /[\0-\x1F\x7F-\x9F]/), Nm;
}
var Vm, V0;
function _pe() {
  return V0 || (V0 = 1, Vm = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Vm;
}
var Um, U0;
function lw() {
  return U0 || (U0 = 1, Um = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Um;
}
var q0;
function bpe() {
  return q0 || (q0 = 1, yl.Any = sw(), yl.Cc = aw(), yl.Cf = _pe(), yl.P = Bv(), yl.Z = lw()), yl;
}
var G0;
function nn() {
  return G0 || (G0 = 1, (function(a) {
    function i(Pe) {
      return Object.prototype.toString.call(Pe);
    }
    function l(Pe) {
      return i(Pe) === "[object String]";
    }
    var d = Object.prototype.hasOwnProperty;
    function h(Pe, tt) {
      return d.call(Pe, tt);
    }
    function g(Pe) {
      var tt = Array.prototype.slice.call(arguments, 1);
      return tt.forEach(function(at) {
        if (at) {
          if (typeof at != "object") throw new TypeError(at + "must be object");
          Object.keys(at).forEach(function(xt) {
            Pe[xt] = at[xt];
          });
        }
      }), Pe;
    }
    function p(Pe, tt, at) {
      return [].concat(Pe.slice(0, tt), at, Pe.slice(tt + 1));
    }
    function o(Pe) {
      return !(Pe >= 55296 && Pe <= 57343 || Pe >= 64976 && Pe <= 65007 || (Pe & 65535) === 65535 || (Pe & 65535) === 65534 || Pe >= 0 && Pe <= 8 || Pe === 11 || Pe >= 14 && Pe <= 31 || Pe >= 127 && Pe <= 159 || Pe > 1114111);
    }
    function w(Pe) {
      if (Pe > 65535) {
        Pe -= 65536;
        var tt = 55296 + (Pe >> 10), at = 56320 + (Pe & 1023);
        return String.fromCharCode(tt, at);
      }
      return String.fromCharCode(Pe);
    }
    var S = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, k = /&([a-z#][a-z0-9]{1,31});/gi, I = new RegExp(S.source + "|" + k.source, "gi"), z = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, R = iw();
    function O(Pe, tt) {
      var at;
      return h(R, tt) ? R[tt] : tt.charCodeAt(0) === 35 && z.test(tt) && (at = tt[1].toLowerCase() === "x" ? parseInt(tt.slice(2), 16) : parseInt(tt.slice(1), 10), o(at)) ? w(at) : Pe;
    }
    function V(Pe) {
      return Pe.indexOf("\\") < 0 ? Pe : Pe.replace(S, "$1");
    }
    function W(Pe) {
      return Pe.indexOf("\\") < 0 && Pe.indexOf("&") < 0 ? Pe : Pe.replace(I, function(tt, at, xt) {
        return at || O(tt, xt);
      });
    }
    var N = /[&<>"]/, K = /[&<>"]/g, Z = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
    function X(Pe) {
      return Z[Pe];
    }
    function te(Pe) {
      return N.test(Pe) ? Pe.replace(K, X) : Pe;
    }
    var q = /[.?*+^$[\]\\(){}|-]/g;
    function he(Pe) {
      return Pe.replace(q, "\\$&");
    }
    function se(Pe) {
      switch (Pe) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function Q(Pe) {
      if (Pe >= 8192 && Pe <= 8202) return true;
      switch (Pe) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var oe = Bv();
    function ve(Pe) {
      return oe.test(Pe);
    }
    function Be(Pe) {
      switch (Pe) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function Ne(Pe) {
      return Pe = Pe.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (Pe = Pe.replace(//g, "\xDF")), Pe.toLowerCase().toUpperCase();
    }
    a.lib = {}, a.lib.mdurl = ow(), a.lib.ucmicro = bpe(), a.assign = g, a.isString = l, a.has = h, a.unescapeMd = V, a.unescapeAll = W, a.isValidEntityCode = o, a.fromCodePoint = w, a.escapeHtml = te, a.arrayReplaceAt = p, a.isSpace = se, a.isWhiteSpace = Q, a.isMdAsciiPunct = Be, a.isPunctChar = ve, a.escapeRE = he, a.normalizeReference = Ne;
  })(Am)), Am;
}
var yd = {}, qm, W0;
function xpe() {
  return W0 || (W0 = 1, qm = function(i, l, d) {
    var h, g, p, o, w = -1, S = i.posMax, k = i.pos;
    for (i.pos = l + 1, h = 1; i.pos < S; ) {
      if (p = i.src.charCodeAt(i.pos), p === 93 && (h--, h === 0)) {
        g = true;
        break;
      }
      if (o = i.pos, i.md.inline.skipToken(i), p === 91) {
        if (o === i.pos - 1) h++;
        else if (d) return i.pos = k, -1;
      }
    }
    return g && (w = i.pos), i.pos = k, w;
  }), qm;
}
var Gm, Z0;
function wpe() {
  if (Z0) return Gm;
  Z0 = 1;
  var a = nn().unescapeAll;
  return Gm = function(l, d, h) {
    var g, p, o = d, w = { ok: false, pos: 0, lines: 0, str: "" };
    if (l.charCodeAt(o) === 60) {
      for (o++; o < h; ) {
        if (g = l.charCodeAt(o), g === 10 || g === 60) return w;
        if (g === 62) return w.pos = o + 1, w.str = a(l.slice(d + 1, o)), w.ok = true, w;
        if (g === 92 && o + 1 < h) {
          o += 2;
          continue;
        }
        o++;
      }
      return w;
    }
    for (p = 0; o < h && (g = l.charCodeAt(o), !(g === 32 || g < 32 || g === 127)); ) {
      if (g === 92 && o + 1 < h) {
        if (l.charCodeAt(o + 1) === 32) break;
        o += 2;
        continue;
      }
      if (g === 40 && (p++, p > 32)) return w;
      if (g === 41) {
        if (p === 0) break;
        p--;
      }
      o++;
    }
    return d === o || p !== 0 || (w.str = a(l.slice(d, o)), w.pos = o, w.ok = true), w;
  }, Gm;
}
var Wm, H0;
function Cpe() {
  if (H0) return Wm;
  H0 = 1;
  var a = nn().unescapeAll;
  return Wm = function(l, d, h) {
    var g, p, o = 0, w = d, S = { ok: false, pos: 0, lines: 0, str: "" };
    if (w >= h || (p = l.charCodeAt(w), p !== 34 && p !== 39 && p !== 40)) return S;
    for (w++, p === 40 && (p = 41); w < h; ) {
      if (g = l.charCodeAt(w), g === p) return S.pos = w + 1, S.lines = o, S.str = a(l.slice(d + 1, w)), S.ok = true, S;
      if (g === 40 && p === 41) return S;
      g === 10 ? o++ : g === 92 && w + 1 < h && (w++, l.charCodeAt(w) === 10 && o++), w++;
    }
    return S;
  }, Wm;
}
var X0;
function Spe() {
  return X0 || (X0 = 1, yd.parseLinkLabel = xpe(), yd.parseLinkDestination = wpe(), yd.parseLinkTitle = Cpe()), yd;
}
var Zm, Y0;
function kpe() {
  if (Y0) return Zm;
  Y0 = 1;
  var a = nn().assign, i = nn().unescapeAll, l = nn().escapeHtml, d = {};
  d.code_inline = function(g, p, o, w, S) {
    var k = g[p];
    return "<code" + S.renderAttrs(k) + ">" + l(k.content) + "</code>";
  }, d.code_block = function(g, p, o, w, S) {
    var k = g[p];
    return "<pre" + S.renderAttrs(k) + "><code>" + l(g[p].content) + `</code></pre>
`;
  }, d.fence = function(g, p, o, w, S) {
    var k = g[p], I = k.info ? i(k.info).trim() : "", z = "", R = "", O, V, W, N, K;
    return I && (W = I.split(/(\s+)/g), z = W[0], R = W.slice(2).join("")), o.highlight ? O = o.highlight(k.content, z, R) || l(k.content) : O = l(k.content), O.indexOf("<pre") === 0 ? O + `
` : I ? (V = k.attrIndex("class"), N = k.attrs ? k.attrs.slice() : [], V < 0 ? N.push(["class", o.langPrefix + z]) : (N[V] = N[V].slice(), N[V][1] += " " + o.langPrefix + z), K = { attrs: N }, "<pre><code" + S.renderAttrs(K) + ">" + O + `</code></pre>
`) : "<pre><code" + S.renderAttrs(k) + ">" + O + `</code></pre>
`;
  }, d.image = function(g, p, o, w, S) {
    var k = g[p];
    return k.attrs[k.attrIndex("alt")][1] = S.renderInlineAsText(k.children, o, w), S.renderToken(g, p, o);
  }, d.hardbreak = function(g, p, o) {
    return o.xhtmlOut ? `<br />
` : `<br>
`;
  }, d.softbreak = function(g, p, o) {
    return o.breaks ? o.xhtmlOut ? `<br />
` : `<br>
` : `
`;
  }, d.text = function(g, p) {
    return l(g[p].content);
  }, d.html_block = function(g, p) {
    return g[p].content;
  }, d.html_inline = function(g, p) {
    return g[p].content;
  };
  function h() {
    this.rules = a({}, d);
  }
  return h.prototype.renderAttrs = function(p) {
    var o, w, S;
    if (!p.attrs) return "";
    for (S = "", o = 0, w = p.attrs.length; o < w; o++) S += " " + l(p.attrs[o][0]) + '="' + l(p.attrs[o][1]) + '"';
    return S;
  }, h.prototype.renderToken = function(p, o, w) {
    var S, k = "", I = false, z = p[o];
    return z.hidden ? "" : (z.block && z.nesting !== -1 && o && p[o - 1].hidden && (k += `
`), k += (z.nesting === -1 ? "</" : "<") + z.tag, k += this.renderAttrs(z), z.nesting === 0 && w.xhtmlOut && (k += " /"), z.block && (I = true, z.nesting === 1 && o + 1 < p.length && (S = p[o + 1], (S.type === "inline" || S.hidden || S.nesting === -1 && S.tag === z.tag) && (I = false))), k += I ? `>
` : ">", k);
  }, h.prototype.renderInline = function(g, p, o) {
    for (var w, S = "", k = this.rules, I = 0, z = g.length; I < z; I++) w = g[I].type, typeof k[w] < "u" ? S += k[w](g, I, p, o, this) : S += this.renderToken(g, I, p);
    return S;
  }, h.prototype.renderInlineAsText = function(g, p, o) {
    for (var w = "", S = 0, k = g.length; S < k; S++) g[S].type === "text" ? w += g[S].content : g[S].type === "image" ? w += this.renderInlineAsText(g[S].children, p, o) : g[S].type === "softbreak" && (w += `
`);
    return w;
  }, h.prototype.render = function(g, p, o) {
    var w, S, k, I = "", z = this.rules;
    for (w = 0, S = g.length; w < S; w++) k = g[w].type, k === "inline" ? I += this.renderInline(g[w].children, p, o) : typeof z[k] < "u" ? I += z[k](g, w, p, o, this) : I += this.renderToken(g, w, p, o);
    return I;
  }, Zm = h, Zm;
}
var Hm, K0;
function Ov() {
  if (K0) return Hm;
  K0 = 1;
  function a() {
    this.__rules__ = [], this.__cache__ = null;
  }
  return a.prototype.__find__ = function(i) {
    for (var l = 0; l < this.__rules__.length; l++) if (this.__rules__[l].name === i) return l;
    return -1;
  }, a.prototype.__compile__ = function() {
    var i = this, l = [""];
    i.__rules__.forEach(function(d) {
      d.enabled && d.alt.forEach(function(h) {
        l.indexOf(h) < 0 && l.push(h);
      });
    }), i.__cache__ = {}, l.forEach(function(d) {
      i.__cache__[d] = [], i.__rules__.forEach(function(h) {
        h.enabled && (d && h.alt.indexOf(d) < 0 || i.__cache__[d].push(h.fn));
      });
    });
  }, a.prototype.at = function(i, l, d) {
    var h = this.__find__(i), g = d || {};
    if (h === -1) throw new Error("Parser rule not found: " + i);
    this.__rules__[h].fn = l, this.__rules__[h].alt = g.alt || [], this.__cache__ = null;
  }, a.prototype.before = function(i, l, d, h) {
    var g = this.__find__(i), p = h || {};
    if (g === -1) throw new Error("Parser rule not found: " + i);
    this.__rules__.splice(g, 0, { name: l, enabled: true, fn: d, alt: p.alt || [] }), this.__cache__ = null;
  }, a.prototype.after = function(i, l, d, h) {
    var g = this.__find__(i), p = h || {};
    if (g === -1) throw new Error("Parser rule not found: " + i);
    this.__rules__.splice(g + 1, 0, { name: l, enabled: true, fn: d, alt: p.alt || [] }), this.__cache__ = null;
  }, a.prototype.push = function(i, l, d) {
    var h = d || {};
    this.__rules__.push({ name: i, enabled: true, fn: l, alt: h.alt || [] }), this.__cache__ = null;
  }, a.prototype.enable = function(i, l) {
    Array.isArray(i) || (i = [i]);
    var d = [];
    return i.forEach(function(h) {
      var g = this.__find__(h);
      if (g < 0) {
        if (l) return;
        throw new Error("Rules manager: invalid rule name " + h);
      }
      this.__rules__[g].enabled = true, d.push(h);
    }, this), this.__cache__ = null, d;
  }, a.prototype.enableOnly = function(i, l) {
    Array.isArray(i) || (i = [i]), this.__rules__.forEach(function(d) {
      d.enabled = false;
    }), this.enable(i, l);
  }, a.prototype.disable = function(i, l) {
    Array.isArray(i) || (i = [i]);
    var d = [];
    return i.forEach(function(h) {
      var g = this.__find__(h);
      if (g < 0) {
        if (l) return;
        throw new Error("Rules manager: invalid rule name " + h);
      }
      this.__rules__[g].enabled = false, d.push(h);
    }, this), this.__cache__ = null, d;
  }, a.prototype.getRules = function(i) {
    return this.__cache__ === null && this.__compile__(), this.__cache__[i] || [];
  }, Hm = a, Hm;
}
var Xm, J0;
function Ppe() {
  if (J0) return Xm;
  J0 = 1;
  var a = /\r\n?|\n/g, i = /\0/g;
  return Xm = function(d) {
    var h;
    h = d.src.replace(a, `
`), h = h.replace(i, "\uFFFD"), d.src = h;
  }, Xm;
}
var Ym, Q0;
function Tpe() {
  return Q0 || (Q0 = 1, Ym = function(i) {
    var l;
    i.inlineMode ? (l = new i.Token("inline", "", 0), l.content = i.src, l.map = [0, 1], l.children = [], i.tokens.push(l)) : i.md.block.parse(i.src, i.md, i.env, i.tokens);
  }), Ym;
}
var Km, eb;
function Mpe() {
  return eb || (eb = 1, Km = function(i) {
    var l = i.tokens, d, h, g;
    for (h = 0, g = l.length; h < g; h++) d = l[h], d.type === "inline" && i.md.inline.parse(d.content, i.md, i.env, d.children);
  }), Km;
}
var Jm, tb;
function Ipe() {
  if (tb) return Jm;
  tb = 1;
  var a = nn().arrayReplaceAt;
  function i(d) {
    return /^<a[>\s]/i.test(d);
  }
  function l(d) {
    return /^<\/a\s*>/i.test(d);
  }
  return Jm = function(h) {
    var g, p, o, w, S, k, I, z, R, O, V, W, N, K, Z, X, te = h.tokens, q;
    if (h.md.options.linkify) {
      for (p = 0, o = te.length; p < o; p++) if (!(te[p].type !== "inline" || !h.md.linkify.pretest(te[p].content))) for (w = te[p].children, N = 0, g = w.length - 1; g >= 0; g--) {
        if (k = w[g], k.type === "link_close") {
          for (g--; w[g].level !== k.level && w[g].type !== "link_open"; ) g--;
          continue;
        }
        if (k.type === "html_inline" && (i(k.content) && N > 0 && N--, l(k.content) && N++), !(N > 0) && k.type === "text" && h.md.linkify.test(k.content)) {
          for (R = k.content, q = h.md.linkify.match(R), I = [], W = k.level, V = 0, q.length > 0 && q[0].index === 0 && g > 0 && w[g - 1].type === "text_special" && (q = q.slice(1)), z = 0; z < q.length; z++) K = q[z].url, Z = h.md.normalizeLink(K), h.md.validateLink(Z) && (X = q[z].text, q[z].schema ? q[z].schema === "mailto:" && !/^mailto:/i.test(X) ? X = h.md.normalizeLinkText("mailto:" + X).replace(/^mailto:/, "") : X = h.md.normalizeLinkText(X) : X = h.md.normalizeLinkText("http://" + X).replace(/^http:\/\//, ""), O = q[z].index, O > V && (S = new h.Token("text", "", 0), S.content = R.slice(V, O), S.level = W, I.push(S)), S = new h.Token("link_open", "a", 1), S.attrs = [["href", Z]], S.level = W++, S.markup = "linkify", S.info = "auto", I.push(S), S = new h.Token("text", "", 0), S.content = X, S.level = W, I.push(S), S = new h.Token("link_close", "a", -1), S.level = --W, S.markup = "linkify", S.info = "auto", I.push(S), V = q[z].lastIndex);
          V < R.length && (S = new h.Token("text", "", 0), S.content = R.slice(V), S.level = W, I.push(S)), te[p].children = w = a(w, g, I);
        }
      }
    }
  }, Jm;
}
var Qm, rb;
function Epe() {
  if (rb) return Qm;
  rb = 1;
  var a = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, i = /\((c|tm|r)\)/i, l = /\((c|tm|r)\)/ig, d = { c: "\xA9", r: "\xAE", tm: "\u2122" };
  function h(o, w) {
    return d[w.toLowerCase()];
  }
  function g(o) {
    var w, S, k = 0;
    for (w = o.length - 1; w >= 0; w--) S = o[w], S.type === "text" && !k && (S.content = S.content.replace(l, h)), S.type === "link_open" && S.info === "auto" && k--, S.type === "link_close" && S.info === "auto" && k++;
  }
  function p(o) {
    var w, S, k = 0;
    for (w = o.length - 1; w >= 0; w--) S = o[w], S.type === "text" && !k && a.test(S.content) && (S.content = S.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), S.type === "link_open" && S.info === "auto" && k--, S.type === "link_close" && S.info === "auto" && k++;
  }
  return Qm = function(w) {
    var S;
    if (w.md.options.typographer) for (S = w.tokens.length - 1; S >= 0; S--) w.tokens[S].type === "inline" && (i.test(w.tokens[S].content) && g(w.tokens[S].children), a.test(w.tokens[S].content) && p(w.tokens[S].children));
  }, Qm;
}
var eg, nb;
function Rpe() {
  if (nb) return eg;
  nb = 1;
  var a = nn().isWhiteSpace, i = nn().isPunctChar, l = nn().isMdAsciiPunct, d = /['"]/, h = /['"]/g, g = "\u2019";
  function p(w, S, k) {
    return w.slice(0, S) + k + w.slice(S + 1);
  }
  function o(w, S) {
    var k, I, z, R, O, V, W, N, K, Z, X, te, q, he, se, Q, oe, ve, Be, Ne, Pe;
    for (Be = [], k = 0; k < w.length; k++) {
      for (I = w[k], W = w[k].level, oe = Be.length - 1; oe >= 0 && !(Be[oe].level <= W); oe--) ;
      if (Be.length = oe + 1, I.type === "text") {
        z = I.content, O = 0, V = z.length;
        e: for (; O < V && (h.lastIndex = O, R = h.exec(z), !!R); ) {
          if (se = Q = true, O = R.index + 1, ve = R[0] === "'", K = 32, R.index - 1 >= 0) K = z.charCodeAt(R.index - 1);
          else for (oe = k - 1; oe >= 0 && !(w[oe].type === "softbreak" || w[oe].type === "hardbreak"); oe--) if (w[oe].content) {
            K = w[oe].content.charCodeAt(w[oe].content.length - 1);
            break;
          }
          if (Z = 32, O < V) Z = z.charCodeAt(O);
          else for (oe = k + 1; oe < w.length && !(w[oe].type === "softbreak" || w[oe].type === "hardbreak"); oe++) if (w[oe].content) {
            Z = w[oe].content.charCodeAt(0);
            break;
          }
          if (X = l(K) || i(String.fromCharCode(K)), te = l(Z) || i(String.fromCharCode(Z)), q = a(K), he = a(Z), he ? se = false : te && (q || X || (se = false)), q ? Q = false : X && (he || te || (Q = false)), Z === 34 && R[0] === '"' && K >= 48 && K <= 57 && (Q = se = false), se && Q && (se = X, Q = te), !se && !Q) {
            ve && (I.content = p(I.content, R.index, g));
            continue;
          }
          if (Q) {
            for (oe = Be.length - 1; oe >= 0 && (N = Be[oe], !(Be[oe].level < W)); oe--) if (N.single === ve && Be[oe].level === W) {
              N = Be[oe], ve ? (Ne = S.md.options.quotes[2], Pe = S.md.options.quotes[3]) : (Ne = S.md.options.quotes[0], Pe = S.md.options.quotes[1]), I.content = p(I.content, R.index, Pe), w[N.token].content = p(w[N.token].content, N.pos, Ne), O += Pe.length - 1, N.token === k && (O += Ne.length - 1), z = I.content, V = z.length, Be.length = oe;
              continue e;
            }
          }
          se ? Be.push({ token: k, pos: R.index, single: ve, level: W }) : Q && ve && (I.content = p(I.content, R.index, g));
        }
      }
    }
  }
  return eg = function(S) {
    var k;
    if (S.md.options.typographer) for (k = S.tokens.length - 1; k >= 0; k--) S.tokens[k].type !== "inline" || !d.test(S.tokens[k].content) || o(S.tokens[k].children, S);
  }, eg;
}
var tg, ib;
function zpe() {
  return ib || (ib = 1, tg = function(i) {
    var l, d, h, g, p, o, w = i.tokens;
    for (l = 0, d = w.length; l < d; l++) if (w[l].type === "inline") {
      for (h = w[l].children, p = h.length, g = 0; g < p; g++) h[g].type === "text_special" && (h[g].type = "text");
      for (g = o = 0; g < p; g++) h[g].type === "text" && g + 1 < p && h[g + 1].type === "text" ? h[g + 1].content = h[g].content + h[g + 1].content : (g !== o && (h[o] = h[g]), o++);
      g !== o && (h.length = o);
    }
  }), tg;
}
var rg, ob;
function $v() {
  if (ob) return rg;
  ob = 1;
  function a(i, l, d) {
    this.type = i, this.tag = l, this.attrs = null, this.map = null, this.nesting = d, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
  }
  return a.prototype.attrIndex = function(l) {
    var d, h, g;
    if (!this.attrs) return -1;
    for (d = this.attrs, h = 0, g = d.length; h < g; h++) if (d[h][0] === l) return h;
    return -1;
  }, a.prototype.attrPush = function(l) {
    this.attrs ? this.attrs.push(l) : this.attrs = [l];
  }, a.prototype.attrSet = function(l, d) {
    var h = this.attrIndex(l), g = [l, d];
    h < 0 ? this.attrPush(g) : this.attrs[h] = g;
  }, a.prototype.attrGet = function(l) {
    var d = this.attrIndex(l), h = null;
    return d >= 0 && (h = this.attrs[d][1]), h;
  }, a.prototype.attrJoin = function(l, d) {
    var h = this.attrIndex(l);
    h < 0 ? this.attrPush([l, d]) : this.attrs[h][1] = this.attrs[h][1] + " " + d;
  }, rg = a, rg;
}
var ng, sb;
function Ape() {
  if (sb) return ng;
  sb = 1;
  var a = $v();
  function i(l, d, h) {
    this.src = l, this.env = h, this.tokens = [], this.inlineMode = false, this.md = d;
  }
  return i.prototype.Token = a, ng = i, ng;
}
var ig, ab;
function Dpe() {
  if (ab) return ig;
  ab = 1;
  var a = Ov(), i = [["normalize", Ppe()], ["block", Tpe()], ["inline", Mpe()], ["linkify", Ipe()], ["replacements", Epe()], ["smartquotes", Rpe()], ["text_join", zpe()]];
  function l() {
    this.ruler = new a();
    for (var d = 0; d < i.length; d++) this.ruler.push(i[d][0], i[d][1]);
  }
  return l.prototype.process = function(d) {
    var h, g, p;
    for (p = this.ruler.getRules(""), h = 0, g = p.length; h < g; h++) p[h](d);
  }, l.prototype.State = Ape(), ig = l, ig;
}
var og, lb;
function Fpe() {
  if (lb) return og;
  lb = 1;
  var a = nn().isSpace;
  function i(d, h) {
    var g = d.bMarks[h] + d.tShift[h], p = d.eMarks[h];
    return d.src.slice(g, p);
  }
  function l(d) {
    var h = [], g = 0, p = d.length, o, w = false, S = 0, k = "";
    for (o = d.charCodeAt(g); g < p; ) o === 124 && (w ? (k += d.substring(S, g - 1), S = g) : (h.push(k + d.substring(S, g)), k = "", S = g + 1)), w = o === 92, g++, o = d.charCodeAt(g);
    return h.push(k + d.substring(S)), h;
  }
  return og = function(h, g, p, o) {
    var w, S, k, I, z, R, O, V, W, N, K, Z, X, te, q, he, se, Q;
    if (g + 2 > p || (R = g + 1, h.sCount[R] < h.blkIndent) || h.sCount[R] - h.blkIndent >= 4 || (k = h.bMarks[R] + h.tShift[R], k >= h.eMarks[R]) || (se = h.src.charCodeAt(k++), se !== 124 && se !== 45 && se !== 58) || k >= h.eMarks[R] || (Q = h.src.charCodeAt(k++), Q !== 124 && Q !== 45 && Q !== 58 && !a(Q)) || se === 45 && a(Q)) return false;
    for (; k < h.eMarks[R]; ) {
      if (w = h.src.charCodeAt(k), w !== 124 && w !== 45 && w !== 58 && !a(w)) return false;
      k++;
    }
    for (S = i(h, g + 1), O = S.split("|"), N = [], I = 0; I < O.length; I++) {
      if (K = O[I].trim(), !K) {
        if (I === 0 || I === O.length - 1) continue;
        return false;
      }
      if (!/^:?-+:?$/.test(K)) return false;
      K.charCodeAt(K.length - 1) === 58 ? N.push(K.charCodeAt(0) === 58 ? "center" : "right") : K.charCodeAt(0) === 58 ? N.push("left") : N.push("");
    }
    if (S = i(h, g).trim(), S.indexOf("|") === -1 || h.sCount[g] - h.blkIndent >= 4 || (O = l(S), O.length && O[0] === "" && O.shift(), O.length && O[O.length - 1] === "" && O.pop(), V = O.length, V === 0 || V !== N.length)) return false;
    if (o) return true;
    for (te = h.parentType, h.parentType = "table", he = h.md.block.ruler.getRules("blockquote"), W = h.push("table_open", "table", 1), W.map = Z = [g, 0], W = h.push("thead_open", "thead", 1), W.map = [g, g + 1], W = h.push("tr_open", "tr", 1), W.map = [g, g + 1], I = 0; I < O.length; I++) W = h.push("th_open", "th", 1), N[I] && (W.attrs = [["style", "text-align:" + N[I]]]), W = h.push("inline", "", 0), W.content = O[I].trim(), W.children = [], W = h.push("th_close", "th", -1);
    for (W = h.push("tr_close", "tr", -1), W = h.push("thead_close", "thead", -1), R = g + 2; R < p && !(h.sCount[R] < h.blkIndent); R++) {
      for (q = false, I = 0, z = he.length; I < z; I++) if (he[I](h, R, p, true)) {
        q = true;
        break;
      }
      if (q || (S = i(h, R).trim(), !S) || h.sCount[R] - h.blkIndent >= 4) break;
      for (O = l(S), O.length && O[0] === "" && O.shift(), O.length && O[O.length - 1] === "" && O.pop(), R === g + 2 && (W = h.push("tbody_open", "tbody", 1), W.map = X = [g + 2, 0]), W = h.push("tr_open", "tr", 1), W.map = [R, R + 1], I = 0; I < V; I++) W = h.push("td_open", "td", 1), N[I] && (W.attrs = [["style", "text-align:" + N[I]]]), W = h.push("inline", "", 0), W.content = O[I] ? O[I].trim() : "", W.children = [], W = h.push("td_close", "td", -1);
      W = h.push("tr_close", "tr", -1);
    }
    return X && (W = h.push("tbody_close", "tbody", -1), X[1] = R), W = h.push("table_close", "table", -1), Z[1] = R, h.parentType = te, h.line = R, true;
  }, og;
}
var sg, cb;
function Lpe() {
  return cb || (cb = 1, sg = function(i, l, d) {
    var h, g, p;
    if (i.sCount[l] - i.blkIndent < 4) return false;
    for (g = h = l + 1; h < d; ) {
      if (i.isEmpty(h)) {
        h++;
        continue;
      }
      if (i.sCount[h] - i.blkIndent >= 4) {
        h++, g = h;
        continue;
      }
      break;
    }
    return i.line = g, p = i.push("code_block", "code", 0), p.content = i.getLines(l, g, 4 + i.blkIndent, false) + `
`, p.map = [l, i.line], true;
  }), sg;
}
var ag, ub;
function Bpe() {
  return ub || (ub = 1, ag = function(i, l, d, h) {
    var g, p, o, w, S, k, I, z = false, R = i.bMarks[l] + i.tShift[l], O = i.eMarks[l];
    if (i.sCount[l] - i.blkIndent >= 4 || R + 3 > O || (g = i.src.charCodeAt(R), g !== 126 && g !== 96) || (S = R, R = i.skipChars(R, g), p = R - S, p < 3) || (I = i.src.slice(S, R), o = i.src.slice(R, O), g === 96 && o.indexOf(String.fromCharCode(g)) >= 0)) return false;
    if (h) return true;
    for (w = l; w++, !(w >= d || (R = S = i.bMarks[w] + i.tShift[w], O = i.eMarks[w], R < O && i.sCount[w] < i.blkIndent)); ) if (i.src.charCodeAt(R) === g && !(i.sCount[w] - i.blkIndent >= 4) && (R = i.skipChars(R, g), !(R - S < p) && (R = i.skipSpaces(R), !(R < O)))) {
      z = true;
      break;
    }
    return p = i.sCount[l], i.line = w + (z ? 1 : 0), k = i.push("fence", "code", 0), k.info = o, k.content = i.getLines(l + 1, w, p, true), k.markup = I, k.map = [l, i.line], true;
  }), ag;
}
var lg, db;
function Ope() {
  if (db) return lg;
  db = 1;
  var a = nn().isSpace;
  return lg = function(l, d, h, g) {
    var p, o, w, S, k, I, z, R, O, V, W, N, K, Z, X, te, q, he, se, Q, oe = l.lineMax, ve = l.bMarks[d] + l.tShift[d], Be = l.eMarks[d];
    if (l.sCount[d] - l.blkIndent >= 4 || l.src.charCodeAt(ve) !== 62) return false;
    if (g) return true;
    for (V = [], W = [], Z = [], X = [], he = l.md.block.ruler.getRules("blockquote"), K = l.parentType, l.parentType = "blockquote", R = d; R < h && (Q = l.sCount[R] < l.blkIndent, ve = l.bMarks[R] + l.tShift[R], Be = l.eMarks[R], !(ve >= Be)); R++) {
      if (l.src.charCodeAt(ve++) === 62 && !Q) {
        for (S = l.sCount[R] + 1, l.src.charCodeAt(ve) === 32 ? (ve++, S++, p = false, te = true) : l.src.charCodeAt(ve) === 9 ? (te = true, (l.bsCount[R] + S) % 4 === 3 ? (ve++, S++, p = false) : p = true) : te = false, O = S, V.push(l.bMarks[R]), l.bMarks[R] = ve; ve < Be && (o = l.src.charCodeAt(ve), a(o)); ) {
          o === 9 ? O += 4 - (O + l.bsCount[R] + (p ? 1 : 0)) % 4 : O++;
          ve++;
        }
        I = ve >= Be, W.push(l.bsCount[R]), l.bsCount[R] = l.sCount[R] + 1 + (te ? 1 : 0), Z.push(l.sCount[R]), l.sCount[R] = O - S, X.push(l.tShift[R]), l.tShift[R] = ve - l.bMarks[R];
        continue;
      }
      if (I) break;
      for (q = false, w = 0, k = he.length; w < k; w++) if (he[w](l, R, h, true)) {
        q = true;
        break;
      }
      if (q) {
        l.lineMax = R, l.blkIndent !== 0 && (V.push(l.bMarks[R]), W.push(l.bsCount[R]), X.push(l.tShift[R]), Z.push(l.sCount[R]), l.sCount[R] -= l.blkIndent);
        break;
      }
      V.push(l.bMarks[R]), W.push(l.bsCount[R]), X.push(l.tShift[R]), Z.push(l.sCount[R]), l.sCount[R] = -1;
    }
    for (N = l.blkIndent, l.blkIndent = 0, se = l.push("blockquote_open", "blockquote", 1), se.markup = ">", se.map = z = [d, 0], l.md.block.tokenize(l, d, R), se = l.push("blockquote_close", "blockquote", -1), se.markup = ">", l.lineMax = oe, l.parentType = K, z[1] = l.line, w = 0; w < X.length; w++) l.bMarks[w + d] = V[w], l.tShift[w + d] = X[w], l.sCount[w + d] = Z[w], l.bsCount[w + d] = W[w];
    return l.blkIndent = N, true;
  }, lg;
}
var cg, hb;
function $pe() {
  if (hb) return cg;
  hb = 1;
  var a = nn().isSpace;
  return cg = function(l, d, h, g) {
    var p, o, w, S, k = l.bMarks[d] + l.tShift[d], I = l.eMarks[d];
    if (l.sCount[d] - l.blkIndent >= 4 || (p = l.src.charCodeAt(k++), p !== 42 && p !== 45 && p !== 95)) return false;
    for (o = 1; k < I; ) {
      if (w = l.src.charCodeAt(k++), w !== p && !a(w)) return false;
      w === p && o++;
    }
    return o < 3 ? false : (g || (l.line = d + 1, S = l.push("hr", "hr", 0), S.map = [d, l.line], S.markup = Array(o + 1).join(String.fromCharCode(p))), true);
  }, cg;
}
var ug, pb;
function jpe() {
  if (pb) return ug;
  pb = 1;
  var a = nn().isSpace;
  function i(h, g) {
    var p, o, w, S;
    return o = h.bMarks[g] + h.tShift[g], w = h.eMarks[g], p = h.src.charCodeAt(o++), p !== 42 && p !== 45 && p !== 43 || o < w && (S = h.src.charCodeAt(o), !a(S)) ? -1 : o;
  }
  function l(h, g) {
    var p, o = h.bMarks[g] + h.tShift[g], w = o, S = h.eMarks[g];
    if (w + 1 >= S || (p = h.src.charCodeAt(w++), p < 48 || p > 57)) return -1;
    for (; ; ) {
      if (w >= S) return -1;
      if (p = h.src.charCodeAt(w++), p >= 48 && p <= 57) {
        if (w - o >= 10) return -1;
        continue;
      }
      if (p === 41 || p === 46) break;
      return -1;
    }
    return w < S && (p = h.src.charCodeAt(w), !a(p)) ? -1 : w;
  }
  function d(h, g) {
    var p, o, w = h.level + 2;
    for (p = g + 2, o = h.tokens.length - 2; p < o; p++) h.tokens[p].level === w && h.tokens[p].type === "paragraph_open" && (h.tokens[p + 2].hidden = true, h.tokens[p].hidden = true, p += 2);
  }
  return ug = function(g, p, o, w) {
    var S, k, I, z, R, O, V, W, N, K, Z, X, te, q, he, se, Q, oe, ve, Be, Ne, Pe, tt, at, xt, ht, Ye, Ke = p, Lt = false, ct = true;
    if (g.sCount[Ke] - g.blkIndent >= 4 || g.listIndent >= 0 && g.sCount[Ke] - g.listIndent >= 4 && g.sCount[Ke] < g.blkIndent) return false;
    if (w && g.parentType === "paragraph" && g.sCount[Ke] >= g.blkIndent && (Lt = true), (Pe = l(g, Ke)) >= 0) {
      if (V = true, at = g.bMarks[Ke] + g.tShift[Ke], te = Number(g.src.slice(at, Pe - 1)), Lt && te !== 1) return false;
    } else if ((Pe = i(g, Ke)) >= 0) V = false;
    else return false;
    if (Lt && g.skipSpaces(Pe) >= g.eMarks[Ke]) return false;
    if (w) return true;
    for (X = g.src.charCodeAt(Pe - 1), Z = g.tokens.length, V ? (Ye = g.push("ordered_list_open", "ol", 1), te !== 1 && (Ye.attrs = [["start", te]])) : Ye = g.push("bullet_list_open", "ul", 1), Ye.map = K = [Ke, 0], Ye.markup = String.fromCharCode(X), tt = false, ht = g.md.block.ruler.getRules("list"), Q = g.parentType, g.parentType = "list"; Ke < o; ) {
      for (Ne = Pe, q = g.eMarks[Ke], O = he = g.sCount[Ke] + Pe - (g.bMarks[Ke] + g.tShift[Ke]); Ne < q; ) {
        if (S = g.src.charCodeAt(Ne), S === 9) he += 4 - (he + g.bsCount[Ke]) % 4;
        else if (S === 32) he++;
        else break;
        Ne++;
      }
      if (k = Ne, k >= q ? R = 1 : R = he - O, R > 4 && (R = 1), z = O + R, Ye = g.push("list_item_open", "li", 1), Ye.markup = String.fromCharCode(X), Ye.map = W = [Ke, 0], V && (Ye.info = g.src.slice(at, Pe - 1)), Be = g.tight, ve = g.tShift[Ke], oe = g.sCount[Ke], se = g.listIndent, g.listIndent = g.blkIndent, g.blkIndent = z, g.tight = true, g.tShift[Ke] = k - g.bMarks[Ke], g.sCount[Ke] = he, k >= q && g.isEmpty(Ke + 1) ? g.line = Math.min(g.line + 2, o) : g.md.block.tokenize(g, Ke, o, true), (!g.tight || tt) && (ct = false), tt = g.line - Ke > 1 && g.isEmpty(g.line - 1), g.blkIndent = g.listIndent, g.listIndent = se, g.tShift[Ke] = ve, g.sCount[Ke] = oe, g.tight = Be, Ye = g.push("list_item_close", "li", -1), Ye.markup = String.fromCharCode(X), Ke = g.line, W[1] = Ke, Ke >= o || g.sCount[Ke] < g.blkIndent || g.sCount[Ke] - g.blkIndent >= 4) break;
      for (xt = false, I = 0, N = ht.length; I < N; I++) if (ht[I](g, Ke, o, true)) {
        xt = true;
        break;
      }
      if (xt) break;
      if (V) {
        if (Pe = l(g, Ke), Pe < 0) break;
        at = g.bMarks[Ke] + g.tShift[Ke];
      } else if (Pe = i(g, Ke), Pe < 0) break;
      if (X !== g.src.charCodeAt(Pe - 1)) break;
    }
    return V ? Ye = g.push("ordered_list_close", "ol", -1) : Ye = g.push("bullet_list_close", "ul", -1), Ye.markup = String.fromCharCode(X), K[1] = Ke, g.line = Ke, g.parentType = Q, ct && d(g, Z), true;
  }, ug;
}
var dg, fb;
function Npe() {
  if (fb) return dg;
  fb = 1;
  var a = nn().normalizeReference, i = nn().isSpace;
  return dg = function(d, h, g, p) {
    var o, w, S, k, I, z, R, O, V, W, N, K, Z, X, te, q, he = 0, se = d.bMarks[h] + d.tShift[h], Q = d.eMarks[h], oe = h + 1;
    if (d.sCount[h] - d.blkIndent >= 4 || d.src.charCodeAt(se) !== 91) return false;
    for (; ++se < Q; ) if (d.src.charCodeAt(se) === 93 && d.src.charCodeAt(se - 1) !== 92) {
      if (se + 1 === Q || d.src.charCodeAt(se + 1) !== 58) return false;
      break;
    }
    for (k = d.lineMax, te = d.md.block.ruler.getRules("reference"), W = d.parentType, d.parentType = "reference"; oe < k && !d.isEmpty(oe); oe++) if (!(d.sCount[oe] - d.blkIndent > 3) && !(d.sCount[oe] < 0)) {
      for (X = false, z = 0, R = te.length; z < R; z++) if (te[z](d, oe, k, true)) {
        X = true;
        break;
      }
      if (X) break;
    }
    for (Z = d.getLines(h, oe, d.blkIndent, false).trim(), Q = Z.length, se = 1; se < Q; se++) {
      if (o = Z.charCodeAt(se), o === 91) return false;
      if (o === 93) {
        V = se;
        break;
      } else o === 10 ? he++ : o === 92 && (se++, se < Q && Z.charCodeAt(se) === 10 && he++);
    }
    if (V < 0 || Z.charCodeAt(V + 1) !== 58) return false;
    for (se = V + 2; se < Q; se++) if (o = Z.charCodeAt(se), o === 10) he++;
    else if (!i(o)) break;
    if (N = d.md.helpers.parseLinkDestination(Z, se, Q), !N.ok || (I = d.md.normalizeLink(N.str), !d.md.validateLink(I))) return false;
    for (se = N.pos, he += N.lines, w = se, S = he, K = se; se < Q; se++) if (o = Z.charCodeAt(se), o === 10) he++;
    else if (!i(o)) break;
    for (N = d.md.helpers.parseLinkTitle(Z, se, Q), se < Q && K !== se && N.ok ? (q = N.str, se = N.pos, he += N.lines) : (q = "", se = w, he = S); se < Q && (o = Z.charCodeAt(se), !!i(o)); ) se++;
    if (se < Q && Z.charCodeAt(se) !== 10 && q) for (q = "", se = w, he = S; se < Q && (o = Z.charCodeAt(se), !!i(o)); ) se++;
    return se < Q && Z.charCodeAt(se) !== 10 || (O = a(Z.slice(1, V)), !O) ? false : (p || (typeof d.env.references > "u" && (d.env.references = {}), typeof d.env.references[O] > "u" && (d.env.references[O] = { title: q, href: I }), d.parentType = W, d.line = h + he + 1), true);
  }, dg;
}
var hg, mb;
function Vpe() {
  return mb || (mb = 1, hg = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]), hg;
}
var hp = {}, gb;
function cw() {
  if (gb) return hp;
  gb = 1;
  var a = "[a-zA-Z_:][a-zA-Z0-9:._-]*", i = "[^\"'=<>`\\x00-\\x20]+", l = "'[^']*'", d = '"[^"]*"', h = "(?:" + i + "|" + l + "|" + d + ")", g = "(?:\\s+" + a + "(?:\\s*=\\s*" + h + ")?)", p = "<[A-Za-z][A-Za-z0-9\\-]*" + g + "*\\s*\\/?>", o = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", w = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", S = "<[?][\\s\\S]*?[?]>", k = "<![A-Z]+\\s+[^>]*>", I = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", z = new RegExp("^(?:" + p + "|" + o + "|" + w + "|" + S + "|" + k + "|" + I + ")"), R = new RegExp("^(?:" + p + "|" + o + ")");
  return hp.HTML_TAG_RE = z, hp.HTML_OPEN_CLOSE_TAG_RE = R, hp;
}
var pg, vb;
function Upe() {
  if (vb) return pg;
  vb = 1;
  var a = Vpe(), i = cw().HTML_OPEN_CLOSE_TAG_RE, l = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + a.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(i.source + "\\s*$"), /^$/, false]];
  return pg = function(h, g, p, o) {
    var w, S, k, I, z = h.bMarks[g] + h.tShift[g], R = h.eMarks[g];
    if (h.sCount[g] - h.blkIndent >= 4 || !h.md.options.html || h.src.charCodeAt(z) !== 60) return false;
    for (I = h.src.slice(z, R), w = 0; w < l.length && !l[w][0].test(I); w++) ;
    if (w === l.length) return false;
    if (o) return l[w][2];
    if (S = g + 1, !l[w][1].test(I)) {
      for (; S < p && !(h.sCount[S] < h.blkIndent); S++) if (z = h.bMarks[S] + h.tShift[S], R = h.eMarks[S], I = h.src.slice(z, R), l[w][1].test(I)) {
        I.length !== 0 && S++;
        break;
      }
    }
    return h.line = S, k = h.push("html_block", "", 0), k.map = [g, S], k.content = h.getLines(g, S, h.blkIndent, true), true;
  }, pg;
}
var fg, yb;
function qpe() {
  if (yb) return fg;
  yb = 1;
  var a = nn().isSpace;
  return fg = function(l, d, h, g) {
    var p, o, w, S, k = l.bMarks[d] + l.tShift[d], I = l.eMarks[d];
    if (l.sCount[d] - l.blkIndent >= 4 || (p = l.src.charCodeAt(k), p !== 35 || k >= I)) return false;
    for (o = 1, p = l.src.charCodeAt(++k); p === 35 && k < I && o <= 6; ) o++, p = l.src.charCodeAt(++k);
    return o > 6 || k < I && !a(p) ? false : (g || (I = l.skipSpacesBack(I, k), w = l.skipCharsBack(I, 35, k), w > k && a(l.src.charCodeAt(w - 1)) && (I = w), l.line = d + 1, S = l.push("heading_open", "h" + String(o), 1), S.markup = "########".slice(0, o), S.map = [d, l.line], S = l.push("inline", "", 0), S.content = l.src.slice(k, I).trim(), S.map = [d, l.line], S.children = [], S = l.push("heading_close", "h" + String(o), -1), S.markup = "########".slice(0, o)), true);
  }, fg;
}
var mg, _b;
function Gpe() {
  return _b || (_b = 1, mg = function(i, l, d) {
    var h, g, p, o, w, S, k, I, z, R = l + 1, O, V = i.md.block.ruler.getRules("paragraph");
    if (i.sCount[l] - i.blkIndent >= 4) return false;
    for (O = i.parentType, i.parentType = "paragraph"; R < d && !i.isEmpty(R); R++) if (!(i.sCount[R] - i.blkIndent > 3)) {
      if (i.sCount[R] >= i.blkIndent && (S = i.bMarks[R] + i.tShift[R], k = i.eMarks[R], S < k && (z = i.src.charCodeAt(S), (z === 45 || z === 61) && (S = i.skipChars(S, z), S = i.skipSpaces(S), S >= k)))) {
        I = z === 61 ? 1 : 2;
        break;
      }
      if (!(i.sCount[R] < 0)) {
        for (g = false, p = 0, o = V.length; p < o; p++) if (V[p](i, R, d, true)) {
          g = true;
          break;
        }
        if (g) break;
      }
    }
    return I ? (h = i.getLines(l, R, i.blkIndent, false).trim(), i.line = R + 1, w = i.push("heading_open", "h" + String(I), 1), w.markup = String.fromCharCode(z), w.map = [l, i.line], w = i.push("inline", "", 0), w.content = h, w.map = [l, i.line - 1], w.children = [], w = i.push("heading_close", "h" + String(I), -1), w.markup = String.fromCharCode(z), i.parentType = O, true) : false;
  }), mg;
}
var gg, bb;
function Wpe() {
  return bb || (bb = 1, gg = function(i, l, d) {
    var h, g, p, o, w, S, k = l + 1, I = i.md.block.ruler.getRules("paragraph");
    for (S = i.parentType, i.parentType = "paragraph"; k < d && !i.isEmpty(k); k++) if (!(i.sCount[k] - i.blkIndent > 3) && !(i.sCount[k] < 0)) {
      for (g = false, p = 0, o = I.length; p < o; p++) if (I[p](i, k, d, true)) {
        g = true;
        break;
      }
      if (g) break;
    }
    return h = i.getLines(l, k, i.blkIndent, false).trim(), i.line = k, w = i.push("paragraph_open", "p", 1), w.map = [l, i.line], w = i.push("inline", "", 0), w.content = h, w.map = [l, i.line], w.children = [], w = i.push("paragraph_close", "p", -1), i.parentType = S, true;
  }), gg;
}
var vg, xb;
function Zpe() {
  if (xb) return vg;
  xb = 1;
  var a = $v(), i = nn().isSpace;
  function l(d, h, g, p) {
    var o, w, S, k, I, z, R, O;
    for (this.src = d, this.md = h, this.env = g, this.tokens = p, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", w = this.src, O = false, S = k = z = R = 0, I = w.length; k < I; k++) {
      if (o = w.charCodeAt(k), !O) if (i(o)) {
        z++, o === 9 ? R += 4 - R % 4 : R++;
        continue;
      } else O = true;
      (o === 10 || k === I - 1) && (o !== 10 && k++, this.bMarks.push(S), this.eMarks.push(k), this.tShift.push(z), this.sCount.push(R), this.bsCount.push(0), O = false, z = 0, R = 0, S = k + 1);
    }
    this.bMarks.push(w.length), this.eMarks.push(w.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
  }
  return l.prototype.push = function(d, h, g) {
    var p = new a(d, h, g);
    return p.block = true, g < 0 && this.level--, p.level = this.level, g > 0 && this.level++, this.tokens.push(p), p;
  }, l.prototype.isEmpty = function(h) {
    return this.bMarks[h] + this.tShift[h] >= this.eMarks[h];
  }, l.prototype.skipEmptyLines = function(h) {
    for (var g = this.lineMax; h < g && !(this.bMarks[h] + this.tShift[h] < this.eMarks[h]); h++) ;
    return h;
  }, l.prototype.skipSpaces = function(h) {
    for (var g, p = this.src.length; h < p && (g = this.src.charCodeAt(h), !!i(g)); h++) ;
    return h;
  }, l.prototype.skipSpacesBack = function(h, g) {
    if (h <= g) return h;
    for (; h > g; ) if (!i(this.src.charCodeAt(--h))) return h + 1;
    return h;
  }, l.prototype.skipChars = function(h, g) {
    for (var p = this.src.length; h < p && this.src.charCodeAt(h) === g; h++) ;
    return h;
  }, l.prototype.skipCharsBack = function(h, g, p) {
    if (h <= p) return h;
    for (; h > p; ) if (g !== this.src.charCodeAt(--h)) return h + 1;
    return h;
  }, l.prototype.getLines = function(h, g, p, o) {
    var w, S, k, I, z, R, O, V = h;
    if (h >= g) return "";
    for (R = new Array(g - h), w = 0; V < g; V++, w++) {
      for (S = 0, O = I = this.bMarks[V], V + 1 < g || o ? z = this.eMarks[V] + 1 : z = this.eMarks[V]; I < z && S < p; ) {
        if (k = this.src.charCodeAt(I), i(k)) k === 9 ? S += 4 - (S + this.bsCount[V]) % 4 : S++;
        else if (I - O < this.tShift[V]) S++;
        else break;
        I++;
      }
      S > p ? R[w] = new Array(S - p + 1).join(" ") + this.src.slice(I, z) : R[w] = this.src.slice(I, z);
    }
    return R.join("");
  }, l.prototype.Token = a, vg = l, vg;
}
var yg, wb;
function Hpe() {
  if (wb) return yg;
  wb = 1;
  var a = Ov(), i = [["table", Fpe(), ["paragraph", "reference"]], ["code", Lpe()], ["fence", Bpe(), ["paragraph", "reference", "blockquote", "list"]], ["blockquote", Ope(), ["paragraph", "reference", "blockquote", "list"]], ["hr", $pe(), ["paragraph", "reference", "blockquote", "list"]], ["list", jpe(), ["paragraph", "reference", "blockquote"]], ["reference", Npe()], ["html_block", Upe(), ["paragraph", "reference", "blockquote"]], ["heading", qpe(), ["paragraph", "reference", "blockquote"]], ["lheading", Gpe()], ["paragraph", Wpe()]];
  function l() {
    this.ruler = new a();
    for (var d = 0; d < i.length; d++) this.ruler.push(i[d][0], i[d][1], { alt: (i[d][2] || []).slice() });
  }
  return l.prototype.tokenize = function(d, h, g) {
    for (var p, o, w, S = this.ruler.getRules(""), k = S.length, I = h, z = false, R = d.md.options.maxNesting; I < g && (d.line = I = d.skipEmptyLines(I), !(I >= g || d.sCount[I] < d.blkIndent)); ) {
      if (d.level >= R) {
        d.line = g;
        break;
      }
      for (w = d.line, o = 0; o < k; o++) if (p = S[o](d, I, g, false), p) {
        if (w >= d.line) throw new Error("block rule didn't increment state.line");
        break;
      }
      if (!p) throw new Error("none of the block rules matched");
      d.tight = !z, d.isEmpty(d.line - 1) && (z = true), I = d.line, I < g && d.isEmpty(I) && (z = true, I++, d.line = I);
    }
  }, l.prototype.parse = function(d, h, g, p) {
    var o;
    d && (o = new this.State(d, h, g, p), this.tokenize(o, o.line, o.lineMax));
  }, l.prototype.State = Zpe(), yg = l, yg;
}
var _g, Cb;
function Xpe() {
  if (Cb) return _g;
  Cb = 1;
  function a(i) {
    switch (i) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  return _g = function(l, d) {
    for (var h = l.pos; h < l.posMax && !a(l.src.charCodeAt(h)); ) h++;
    return h === l.pos ? false : (d || (l.pending += l.src.slice(l.pos, h)), l.pos = h, true);
  }, _g;
}
var bg, Sb;
function Ype() {
  if (Sb) return bg;
  Sb = 1;
  var a = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  return bg = function(l, d) {
    var h, g, p, o, w, S, k, I;
    return !l.md.options.linkify || l.linkLevel > 0 || (h = l.pos, g = l.posMax, h + 3 > g) || l.src.charCodeAt(h) !== 58 || l.src.charCodeAt(h + 1) !== 47 || l.src.charCodeAt(h + 2) !== 47 || (p = l.pending.match(a), !p) || (o = p[1], w = l.md.linkify.matchAtStart(l.src.slice(h - o.length)), !w) || (S = w.url, S.length <= o.length) || (S = S.replace(/\*+$/, ""), k = l.md.normalizeLink(S), !l.md.validateLink(k)) ? false : (d || (l.pending = l.pending.slice(0, -o.length), I = l.push("link_open", "a", 1), I.attrs = [["href", k]], I.markup = "linkify", I.info = "auto", I = l.push("text", "", 0), I.content = l.md.normalizeLinkText(S), I = l.push("link_close", "a", -1), I.markup = "linkify", I.info = "auto"), l.pos += S.length - o.length, true);
  }, bg;
}
var xg, kb;
function Kpe() {
  if (kb) return xg;
  kb = 1;
  var a = nn().isSpace;
  return xg = function(l, d) {
    var h, g, p, o = l.pos;
    if (l.src.charCodeAt(o) !== 10) return false;
    if (h = l.pending.length - 1, g = l.posMax, !d) if (h >= 0 && l.pending.charCodeAt(h) === 32) if (h >= 1 && l.pending.charCodeAt(h - 1) === 32) {
      for (p = h - 1; p >= 1 && l.pending.charCodeAt(p - 1) === 32; ) p--;
      l.pending = l.pending.slice(0, p), l.push("hardbreak", "br", 0);
    } else l.pending = l.pending.slice(0, -1), l.push("softbreak", "br", 0);
    else l.push("softbreak", "br", 0);
    for (o++; o < g && a(l.src.charCodeAt(o)); ) o++;
    return l.pos = o, true;
  }, xg;
}
var wg, Pb;
function Jpe() {
  if (Pb) return wg;
  Pb = 1;
  for (var a = nn().isSpace, i = [], l = 0; l < 256; l++) i.push(0);
  return "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(d) {
    i[d.charCodeAt(0)] = 1;
  }), wg = function(h, g) {
    var p, o, w, S, k, I = h.pos, z = h.posMax;
    if (h.src.charCodeAt(I) !== 92 || (I++, I >= z)) return false;
    if (p = h.src.charCodeAt(I), p === 10) {
      for (g || h.push("hardbreak", "br", 0), I++; I < z && (p = h.src.charCodeAt(I), !!a(p)); ) I++;
      return h.pos = I, true;
    }
    return S = h.src[I], p >= 55296 && p <= 56319 && I + 1 < z && (o = h.src.charCodeAt(I + 1), o >= 56320 && o <= 57343 && (S += h.src[I + 1], I++)), w = "\\" + S, g || (k = h.push("text_special", "", 0), p < 256 && i[p] !== 0 ? k.content = S : k.content = w, k.markup = w, k.info = "escape"), h.pos = I + 1, true;
  }, wg;
}
var Cg, Tb;
function Qpe() {
  return Tb || (Tb = 1, Cg = function(i, l) {
    var d, h, g, p, o, w, S, k, I = i.pos, z = i.src.charCodeAt(I);
    if (z !== 96) return false;
    for (d = I, I++, h = i.posMax; I < h && i.src.charCodeAt(I) === 96; ) I++;
    if (g = i.src.slice(d, I), S = g.length, i.backticksScanned && (i.backticks[S] || 0) <= d) return l || (i.pending += g), i.pos += S, true;
    for (w = I; (o = i.src.indexOf("`", w)) !== -1; ) {
      for (w = o + 1; w < h && i.src.charCodeAt(w) === 96; ) w++;
      if (k = w - o, k === S) return l || (p = i.push("code_inline", "code", 0), p.markup = g, p.content = i.src.slice(I, o).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), i.pos = w, true;
      i.backticks[k] = o;
    }
    return i.backticksScanned = true, l || (i.pending += g), i.pos += S, true;
  }), Cg;
}
var pp = {}, Mb;
function Ib() {
  if (Mb) return pp;
  Mb = 1, pp.tokenize = function(l, d) {
    var h, g, p, o, w, S = l.pos, k = l.src.charCodeAt(S);
    if (d || k !== 126 || (g = l.scanDelims(l.pos, true), o = g.length, w = String.fromCharCode(k), o < 2)) return false;
    for (o % 2 && (p = l.push("text", "", 0), p.content = w, o--), h = 0; h < o; h += 2) p = l.push("text", "", 0), p.content = w + w, l.delimiters.push({ marker: k, length: 0, token: l.tokens.length - 1, end: -1, open: g.can_open, close: g.can_close });
    return l.pos += g.length, true;
  };
  function a(i, l) {
    var d, h, g, p, o, w = [], S = l.length;
    for (d = 0; d < S; d++) g = l[d], g.marker === 126 && g.end !== -1 && (p = l[g.end], o = i.tokens[g.token], o.type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", o = i.tokens[p.token], o.type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", i.tokens[p.token - 1].type === "text" && i.tokens[p.token - 1].content === "~" && w.push(p.token - 1));
    for (; w.length; ) {
      for (d = w.pop(), h = d + 1; h < i.tokens.length && i.tokens[h].type === "s_close"; ) h++;
      h--, d !== h && (o = i.tokens[h], i.tokens[h] = i.tokens[d], i.tokens[d] = o);
    }
  }
  return pp.postProcess = function(l) {
    var d, h = l.tokens_meta, g = l.tokens_meta.length;
    for (a(l, l.delimiters), d = 0; d < g; d++) h[d] && h[d].delimiters && a(l, h[d].delimiters);
  }, pp;
}
var fp = {}, Eb;
function Rb() {
  if (Eb) return fp;
  Eb = 1, fp.tokenize = function(l, d) {
    var h, g, p, o = l.pos, w = l.src.charCodeAt(o);
    if (d || w !== 95 && w !== 42) return false;
    for (g = l.scanDelims(l.pos, w === 42), h = 0; h < g.length; h++) p = l.push("text", "", 0), p.content = String.fromCharCode(w), l.delimiters.push({ marker: w, length: g.length, token: l.tokens.length - 1, end: -1, open: g.can_open, close: g.can_close });
    return l.pos += g.length, true;
  };
  function a(i, l) {
    var d, h, g, p, o, w, S = l.length;
    for (d = S - 1; d >= 0; d--) h = l[d], !(h.marker !== 95 && h.marker !== 42) && h.end !== -1 && (g = l[h.end], w = d > 0 && l[d - 1].end === h.end + 1 && l[d - 1].marker === h.marker && l[d - 1].token === h.token - 1 && l[h.end + 1].token === g.token + 1, o = String.fromCharCode(h.marker), p = i.tokens[h.token], p.type = w ? "strong_open" : "em_open", p.tag = w ? "strong" : "em", p.nesting = 1, p.markup = w ? o + o : o, p.content = "", p = i.tokens[g.token], p.type = w ? "strong_close" : "em_close", p.tag = w ? "strong" : "em", p.nesting = -1, p.markup = w ? o + o : o, p.content = "", w && (i.tokens[l[d - 1].token].content = "", i.tokens[l[h.end + 1].token].content = "", d--));
  }
  return fp.postProcess = function(l) {
    var d, h = l.tokens_meta, g = l.tokens_meta.length;
    for (a(l, l.delimiters), d = 0; d < g; d++) h[d] && h[d].delimiters && a(l, h[d].delimiters);
  }, fp;
}
var Sg, zb;
function efe() {
  if (zb) return Sg;
  zb = 1;
  var a = nn().normalizeReference, i = nn().isSpace;
  return Sg = function(d, h) {
    var g, p, o, w, S, k, I, z, R, O = "", V = "", W = d.pos, N = d.posMax, K = d.pos, Z = true;
    if (d.src.charCodeAt(d.pos) !== 91 || (S = d.pos + 1, w = d.md.helpers.parseLinkLabel(d, d.pos, true), w < 0)) return false;
    if (k = w + 1, k < N && d.src.charCodeAt(k) === 40) {
      for (Z = false, k++; k < N && (p = d.src.charCodeAt(k), !(!i(p) && p !== 10)); k++) ;
      if (k >= N) return false;
      if (K = k, I = d.md.helpers.parseLinkDestination(d.src, k, d.posMax), I.ok) {
        for (O = d.md.normalizeLink(I.str), d.md.validateLink(O) ? k = I.pos : O = "", K = k; k < N && (p = d.src.charCodeAt(k), !(!i(p) && p !== 10)); k++) ;
        if (I = d.md.helpers.parseLinkTitle(d.src, k, d.posMax), k < N && K !== k && I.ok) for (V = I.str, k = I.pos; k < N && (p = d.src.charCodeAt(k), !(!i(p) && p !== 10)); k++) ;
      }
      (k >= N || d.src.charCodeAt(k) !== 41) && (Z = true), k++;
    }
    if (Z) {
      if (typeof d.env.references > "u") return false;
      if (k < N && d.src.charCodeAt(k) === 91 ? (K = k + 1, k = d.md.helpers.parseLinkLabel(d, k), k >= 0 ? o = d.src.slice(K, k++) : k = w + 1) : k = w + 1, o || (o = d.src.slice(S, w)), z = d.env.references[a(o)], !z) return d.pos = W, false;
      O = z.href, V = z.title;
    }
    return h || (d.pos = S, d.posMax = w, R = d.push("link_open", "a", 1), R.attrs = g = [["href", O]], V && g.push(["title", V]), d.linkLevel++, d.md.inline.tokenize(d), d.linkLevel--, R = d.push("link_close", "a", -1)), d.pos = k, d.posMax = N, true;
  }, Sg;
}
var kg, Ab;
function tfe() {
  if (Ab) return kg;
  Ab = 1;
  var a = nn().normalizeReference, i = nn().isSpace;
  return kg = function(d, h) {
    var g, p, o, w, S, k, I, z, R, O, V, W, N, K = "", Z = d.pos, X = d.posMax;
    if (d.src.charCodeAt(d.pos) !== 33 || d.src.charCodeAt(d.pos + 1) !== 91 || (k = d.pos + 2, S = d.md.helpers.parseLinkLabel(d, d.pos + 1, false), S < 0)) return false;
    if (I = S + 1, I < X && d.src.charCodeAt(I) === 40) {
      for (I++; I < X && (p = d.src.charCodeAt(I), !(!i(p) && p !== 10)); I++) ;
      if (I >= X) return false;
      for (N = I, R = d.md.helpers.parseLinkDestination(d.src, I, d.posMax), R.ok && (K = d.md.normalizeLink(R.str), d.md.validateLink(K) ? I = R.pos : K = ""), N = I; I < X && (p = d.src.charCodeAt(I), !(!i(p) && p !== 10)); I++) ;
      if (R = d.md.helpers.parseLinkTitle(d.src, I, d.posMax), I < X && N !== I && R.ok) for (O = R.str, I = R.pos; I < X && (p = d.src.charCodeAt(I), !(!i(p) && p !== 10)); I++) ;
      else O = "";
      if (I >= X || d.src.charCodeAt(I) !== 41) return d.pos = Z, false;
      I++;
    } else {
      if (typeof d.env.references > "u") return false;
      if (I < X && d.src.charCodeAt(I) === 91 ? (N = I + 1, I = d.md.helpers.parseLinkLabel(d, I), I >= 0 ? w = d.src.slice(N, I++) : I = S + 1) : I = S + 1, w || (w = d.src.slice(k, S)), z = d.env.references[a(w)], !z) return d.pos = Z, false;
      K = z.href, O = z.title;
    }
    return h || (o = d.src.slice(k, S), d.md.inline.parse(o, d.md, d.env, W = []), V = d.push("image", "img", 0), V.attrs = g = [["src", K], ["alt", ""]], V.children = W, V.content = o, O && g.push(["title", O])), d.pos = I, d.posMax = X, true;
  }, kg;
}
var Pg, Db;
function rfe() {
  if (Db) return Pg;
  Db = 1;
  var a = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, i = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  return Pg = function(d, h) {
    var g, p, o, w, S, k, I = d.pos;
    if (d.src.charCodeAt(I) !== 60) return false;
    for (S = d.pos, k = d.posMax; ; ) {
      if (++I >= k || (w = d.src.charCodeAt(I), w === 60)) return false;
      if (w === 62) break;
    }
    return g = d.src.slice(S + 1, I), i.test(g) ? (p = d.md.normalizeLink(g), d.md.validateLink(p) ? (h || (o = d.push("link_open", "a", 1), o.attrs = [["href", p]], o.markup = "autolink", o.info = "auto", o = d.push("text", "", 0), o.content = d.md.normalizeLinkText(g), o = d.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), d.pos += g.length + 2, true) : false) : a.test(g) ? (p = d.md.normalizeLink("mailto:" + g), d.md.validateLink(p) ? (h || (o = d.push("link_open", "a", 1), o.attrs = [["href", p]], o.markup = "autolink", o.info = "auto", o = d.push("text", "", 0), o.content = d.md.normalizeLinkText(g), o = d.push("link_close", "a", -1), o.markup = "autolink", o.info = "auto"), d.pos += g.length + 2, true) : false) : false;
  }, Pg;
}
var Tg, Fb;
function nfe() {
  if (Fb) return Tg;
  Fb = 1;
  var a = cw().HTML_TAG_RE;
  function i(h) {
    return /^<a[>\s]/i.test(h);
  }
  function l(h) {
    return /^<\/a\s*>/i.test(h);
  }
  function d(h) {
    var g = h | 32;
    return g >= 97 && g <= 122;
  }
  return Tg = function(g, p) {
    var o, w, S, k, I = g.pos;
    return !g.md.options.html || (S = g.posMax, g.src.charCodeAt(I) !== 60 || I + 2 >= S) || (o = g.src.charCodeAt(I + 1), o !== 33 && o !== 63 && o !== 47 && !d(o)) || (w = g.src.slice(I).match(a), !w) ? false : (p || (k = g.push("html_inline", "", 0), k.content = w[0], i(k.content) && g.linkLevel++, l(k.content) && g.linkLevel--), g.pos += w[0].length, true);
  }, Tg;
}
var Mg, Lb;
function ife() {
  if (Lb) return Mg;
  Lb = 1;
  var a = iw(), i = nn().has, l = nn().isValidEntityCode, d = nn().fromCodePoint, h = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, g = /^&([a-z][a-z0-9]{1,31});/i;
  return Mg = function(o, w) {
    var S, k, I, z, R = o.pos, O = o.posMax;
    if (o.src.charCodeAt(R) !== 38 || R + 1 >= O) return false;
    if (S = o.src.charCodeAt(R + 1), S === 35) {
      if (I = o.src.slice(R).match(h), I) return w || (k = I[1][0].toLowerCase() === "x" ? parseInt(I[1].slice(1), 16) : parseInt(I[1], 10), z = o.push("text_special", "", 0), z.content = l(k) ? d(k) : d(65533), z.markup = I[0], z.info = "entity"), o.pos += I[0].length, true;
    } else if (I = o.src.slice(R).match(g), I && i(a, I[1])) return w || (z = o.push("text_special", "", 0), z.content = a[I[1]], z.markup = I[0], z.info = "entity"), o.pos += I[0].length, true;
    return false;
  }, Mg;
}
var Ig, Bb;
function ofe() {
  if (Bb) return Ig;
  Bb = 1;
  function a(i) {
    var l, d, h, g, p, o, w, S, k = {}, I = i.length;
    if (I) {
      var z = 0, R = -2, O = [];
      for (l = 0; l < I; l++) if (h = i[l], O.push(0), (i[z].marker !== h.marker || R !== h.token - 1) && (z = l), R = h.token, h.length = h.length || 0, !!h.close) {
        for (k.hasOwnProperty(h.marker) || (k[h.marker] = [-1, -1, -1, -1, -1, -1]), p = k[h.marker][(h.open ? 3 : 0) + h.length % 3], d = z - O[z] - 1, o = d; d > p; d -= O[d] + 1) if (g = i[d], g.marker === h.marker && g.open && g.end < 0 && (w = false, (g.close || h.open) && (g.length + h.length) % 3 === 0 && (g.length % 3 !== 0 || h.length % 3 !== 0) && (w = true), !w)) {
          S = d > 0 && !i[d - 1].open ? O[d - 1] + 1 : 0, O[l] = l - d + S, O[d] = S, h.open = false, g.end = l, g.close = false, o = -1, R = -2;
          break;
        }
        o !== -1 && (k[h.marker][(h.open ? 3 : 0) + (h.length || 0) % 3] = o);
      }
    }
  }
  return Ig = function(l) {
    var d, h = l.tokens_meta, g = l.tokens_meta.length;
    for (a(l.delimiters), d = 0; d < g; d++) h[d] && h[d].delimiters && a(h[d].delimiters);
  }, Ig;
}
var Eg, Ob;
function sfe() {
  return Ob || (Ob = 1, Eg = function(i) {
    var l, d, h = 0, g = i.tokens, p = i.tokens.length;
    for (l = d = 0; l < p; l++) g[l].nesting < 0 && h--, g[l].level = h, g[l].nesting > 0 && h++, g[l].type === "text" && l + 1 < p && g[l + 1].type === "text" ? g[l + 1].content = g[l].content + g[l + 1].content : (l !== d && (g[d] = g[l]), d++);
    l !== d && (g.length = d);
  }), Eg;
}
var Rg, $b;
function afe() {
  if ($b) return Rg;
  $b = 1;
  var a = $v(), i = nn().isWhiteSpace, l = nn().isPunctChar, d = nn().isMdAsciiPunct;
  function h(g, p, o, w) {
    this.src = g, this.env = o, this.md = p, this.tokens = w, this.tokens_meta = Array(w.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
  }
  return h.prototype.pushPending = function() {
    var g = new a("text", "", 0);
    return g.content = this.pending, g.level = this.pendingLevel, this.tokens.push(g), this.pending = "", g;
  }, h.prototype.push = function(g, p, o) {
    this.pending && this.pushPending();
    var w = new a(g, p, o), S = null;
    return o < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), w.level = this.level, o > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], S = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(w), this.tokens_meta.push(S), w;
  }, h.prototype.scanDelims = function(g, p) {
    var o = g, w, S, k, I, z, R, O, V, W, N = true, K = true, Z = this.posMax, X = this.src.charCodeAt(g);
    for (w = g > 0 ? this.src.charCodeAt(g - 1) : 32; o < Z && this.src.charCodeAt(o) === X; ) o++;
    return k = o - g, S = o < Z ? this.src.charCodeAt(o) : 32, O = d(w) || l(String.fromCharCode(w)), W = d(S) || l(String.fromCharCode(S)), R = i(w), V = i(S), V ? N = false : W && (R || O || (N = false)), R ? K = false : O && (V || W || (K = false)), p ? (I = N, z = K) : (I = N && (!K || O), z = K && (!N || W)), { can_open: I, can_close: z, length: k };
  }, h.prototype.Token = a, Rg = h, Rg;
}
var zg, jb;
function lfe() {
  if (jb) return zg;
  jb = 1;
  var a = Ov(), i = [["text", Xpe()], ["linkify", Ype()], ["newline", Kpe()], ["escape", Jpe()], ["backticks", Qpe()], ["strikethrough", Ib().tokenize], ["emphasis", Rb().tokenize], ["link", efe()], ["image", tfe()], ["autolink", rfe()], ["html_inline", nfe()], ["entity", ife()]], l = [["balance_pairs", ofe()], ["strikethrough", Ib().postProcess], ["emphasis", Rb().postProcess], ["fragments_join", sfe()]];
  function d() {
    var h;
    for (this.ruler = new a(), h = 0; h < i.length; h++) this.ruler.push(i[h][0], i[h][1]);
    for (this.ruler2 = new a(), h = 0; h < l.length; h++) this.ruler2.push(l[h][0], l[h][1]);
  }
  return d.prototype.skipToken = function(h) {
    var g, p, o = h.pos, w = this.ruler.getRules(""), S = w.length, k = h.md.options.maxNesting, I = h.cache;
    if (typeof I[o] < "u") {
      h.pos = I[o];
      return;
    }
    if (h.level < k) {
      for (p = 0; p < S; p++) if (h.level++, g = w[p](h, true), h.level--, g) {
        if (o >= h.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    } else h.pos = h.posMax;
    g || h.pos++, I[o] = h.pos;
  }, d.prototype.tokenize = function(h) {
    for (var g, p, o, w = this.ruler.getRules(""), S = w.length, k = h.posMax, I = h.md.options.maxNesting; h.pos < k; ) {
      if (o = h.pos, h.level < I) {
        for (p = 0; p < S; p++) if (g = w[p](h, false), g) {
          if (o >= h.pos) throw new Error("inline rule didn't increment state.pos");
          break;
        }
      }
      if (g) {
        if (h.pos >= k) break;
        continue;
      }
      h.pending += h.src[h.pos++];
    }
    h.pending && h.pushPending();
  }, d.prototype.parse = function(h, g, p, o) {
    var w, S, k, I = new this.State(h, g, p, o);
    for (this.tokenize(I), S = this.ruler2.getRules(""), k = S.length, w = 0; w < k; w++) S[w](I);
  }, d.prototype.State = afe(), zg = d, zg;
}
var Ag, Nb;
function cfe() {
  return Nb || (Nb = 1, Ag = function(a) {
    var i = {};
    a = a || {}, i.src_Any = sw().source, i.src_Cc = aw().source, i.src_Z = lw().source, i.src_P = Bv().source, i.src_ZPCc = [i.src_Z, i.src_P, i.src_Cc].join("|"), i.src_ZCc = [i.src_Z, i.src_Cc].join("|");
    var l = "[><\uFF5C]";
    return i.src_pseudo_letter = "(?:(?!" + l + "|" + i.src_ZPCc + ")" + i.src_Any + ")", i.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", i.src_auth = "(?:(?:(?!" + i.src_ZCc + "|[@/\\[\\]()]).)+@)?", i.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", i.src_host_terminator = "(?=$|" + l + "|" + i.src_ZPCc + ")(?!" + (a["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + i.src_ZPCc + "))", i.src_path = "(?:[/?#](?:(?!" + i.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + i.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + i.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + i.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + i.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + i.src_ZCc + "|[']).)+\\'|\\'(?=" + i.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + i.src_ZCc + "|[.]|$)|" + (a["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + i.src_ZCc + "|$)|;(?!" + i.src_ZCc + "|$)|\\!+(?!" + i.src_ZCc + "|[!]|$)|\\?(?!" + i.src_ZCc + "|[?]|$))+|\\/)?", i.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', i.src_xn = "xn--[a-z0-9\\-]{1,59}", i.src_domain_root = "(?:" + i.src_xn + "|" + i.src_pseudo_letter + "{1,63})", i.src_domain = "(?:" + i.src_xn + "|(?:" + i.src_pseudo_letter + ")|(?:" + i.src_pseudo_letter + "(?:-|" + i.src_pseudo_letter + "){0,61}" + i.src_pseudo_letter + "))", i.src_host = "(?:(?:(?:(?:" + i.src_domain + ")\\.)*" + i.src_domain + "))", i.tpl_host_fuzzy = "(?:" + i.src_ip4 + "|(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%)))", i.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%))", i.src_host_strict = i.src_host + i.src_host_terminator, i.tpl_host_fuzzy_strict = i.tpl_host_fuzzy + i.src_host_terminator, i.src_host_port_strict = i.src_host + i.src_port + i.src_host_terminator, i.tpl_host_port_fuzzy_strict = i.tpl_host_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_port_no_ip_fuzzy_strict = i.tpl_host_no_ip_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + i.src_ZPCc + "|>|$))", i.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + i.src_ZCc + ")(" + i.src_email_name + "@" + i.tpl_host_fuzzy_strict + ")", i.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_fuzzy_strict + i.src_path + ")", i.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_no_ip_fuzzy_strict + i.src_path + ")", i;
  }), Ag;
}
var Dg, Vb;
function ufe() {
  if (Vb) return Dg;
  Vb = 1;
  function a(Z) {
    var X = Array.prototype.slice.call(arguments, 1);
    return X.forEach(function(te) {
      te && Object.keys(te).forEach(function(q) {
        Z[q] = te[q];
      });
    }), Z;
  }
  function i(Z) {
    return Object.prototype.toString.call(Z);
  }
  function l(Z) {
    return i(Z) === "[object String]";
  }
  function d(Z) {
    return i(Z) === "[object Object]";
  }
  function h(Z) {
    return i(Z) === "[object RegExp]";
  }
  function g(Z) {
    return i(Z) === "[object Function]";
  }
  function p(Z) {
    return Z.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var o = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
  function w(Z) {
    return Object.keys(Z || {}).reduce(function(X, te) {
      return X || o.hasOwnProperty(te);
    }, false);
  }
  var S = { "http:": { validate: function(Z, X, te) {
    var q = Z.slice(X);
    return te.re.http || (te.re.http = new RegExp("^\\/\\/" + te.re.src_auth + te.re.src_host_port_strict + te.re.src_path, "i")), te.re.http.test(q) ? q.match(te.re.http)[0].length : 0;
  } }, "https:": "http:", "ftp:": "http:", "//": { validate: function(Z, X, te) {
    var q = Z.slice(X);
    return te.re.no_http || (te.re.no_http = new RegExp("^" + te.re.src_auth + "(?:localhost|(?:(?:" + te.re.src_domain + ")\\.)+" + te.re.src_domain_root + ")" + te.re.src_port + te.re.src_host_terminator + te.re.src_path, "i")), te.re.no_http.test(q) ? X >= 3 && Z[X - 3] === ":" || X >= 3 && Z[X - 3] === "/" ? 0 : q.match(te.re.no_http)[0].length : 0;
  } }, "mailto:": { validate: function(Z, X, te) {
    var q = Z.slice(X);
    return te.re.mailto || (te.re.mailto = new RegExp("^" + te.re.src_email_name + "@" + te.re.src_host_strict, "i")), te.re.mailto.test(q) ? q.match(te.re.mailto)[0].length : 0;
  } } }, k = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", I = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
  function z(Z) {
    Z.__index__ = -1, Z.__text_cache__ = "";
  }
  function R(Z) {
    return function(X, te) {
      var q = X.slice(te);
      return Z.test(q) ? q.match(Z)[0].length : 0;
    };
  }
  function O() {
    return function(Z, X) {
      X.normalize(Z);
    };
  }
  function V(Z) {
    var X = Z.re = cfe()(Z.__opts__), te = Z.__tlds__.slice();
    Z.onCompile(), Z.__tlds_replaced__ || te.push(k), te.push(X.src_xn), X.src_tlds = te.join("|");
    function q(oe) {
      return oe.replace("%TLDS%", X.src_tlds);
    }
    X.email_fuzzy = RegExp(q(X.tpl_email_fuzzy), "i"), X.link_fuzzy = RegExp(q(X.tpl_link_fuzzy), "i"), X.link_no_ip_fuzzy = RegExp(q(X.tpl_link_no_ip_fuzzy), "i"), X.host_fuzzy_test = RegExp(q(X.tpl_host_fuzzy_test), "i");
    var he = [];
    Z.__compiled__ = {};
    function se(oe, ve) {
      throw new Error('(LinkifyIt) Invalid schema "' + oe + '": ' + ve);
    }
    Object.keys(Z.__schemas__).forEach(function(oe) {
      var ve = Z.__schemas__[oe];
      if (ve !== null) {
        var Be = { validate: null, link: null };
        if (Z.__compiled__[oe] = Be, d(ve)) {
          h(ve.validate) ? Be.validate = R(ve.validate) : g(ve.validate) ? Be.validate = ve.validate : se(oe, ve), g(ve.normalize) ? Be.normalize = ve.normalize : ve.normalize ? se(oe, ve) : Be.normalize = O();
          return;
        }
        if (l(ve)) {
          he.push(oe);
          return;
        }
        se(oe, ve);
      }
    }), he.forEach(function(oe) {
      Z.__compiled__[Z.__schemas__[oe]] && (Z.__compiled__[oe].validate = Z.__compiled__[Z.__schemas__[oe]].validate, Z.__compiled__[oe].normalize = Z.__compiled__[Z.__schemas__[oe]].normalize);
    }), Z.__compiled__[""] = { validate: null, normalize: O() };
    var Q = Object.keys(Z.__compiled__).filter(function(oe) {
      return oe.length > 0 && Z.__compiled__[oe];
    }).map(p).join("|");
    Z.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + X.src_ZPCc + "))(" + Q + ")", "i"), Z.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + X.src_ZPCc + "))(" + Q + ")", "ig"), Z.re.schema_at_start = RegExp("^" + Z.re.schema_search.source, "i"), Z.re.pretest = RegExp("(" + Z.re.schema_test.source + ")|(" + Z.re.host_fuzzy_test.source + ")|@", "i"), z(Z);
  }
  function W(Z, X) {
    var te = Z.__index__, q = Z.__last_index__, he = Z.__text_cache__.slice(te, q);
    this.schema = Z.__schema__.toLowerCase(), this.index = te + X, this.lastIndex = q + X, this.raw = he, this.text = he, this.url = he;
  }
  function N(Z, X) {
    var te = new W(Z, X);
    return Z.__compiled__[te.schema].normalize(te, Z), te;
  }
  function K(Z, X) {
    if (!(this instanceof K)) return new K(Z, X);
    X || w(Z) && (X = Z, Z = {}), this.__opts__ = a({}, o, X), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = a({}, S, Z), this.__compiled__ = {}, this.__tlds__ = I, this.__tlds_replaced__ = false, this.re = {}, V(this);
  }
  return K.prototype.add = function(X, te) {
    return this.__schemas__[X] = te, V(this), this;
  }, K.prototype.set = function(X) {
    return this.__opts__ = a(this.__opts__, X), this;
  }, K.prototype.test = function(X) {
    if (this.__text_cache__ = X, this.__index__ = -1, !X.length) return false;
    var te, q, he, se, Q, oe, ve, Be, Ne;
    if (this.re.schema_test.test(X)) {
      for (ve = this.re.schema_search, ve.lastIndex = 0; (te = ve.exec(X)) !== null; ) if (se = this.testSchemaAt(X, te[2], ve.lastIndex), se) {
        this.__schema__ = te[2], this.__index__ = te.index + te[1].length, this.__last_index__ = te.index + te[0].length + se;
        break;
      }
    }
    return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (Be = X.search(this.re.host_fuzzy_test), Be >= 0 && (this.__index__ < 0 || Be < this.__index__) && (q = X.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (Q = q.index + q[1].length, (this.__index__ < 0 || Q < this.__index__) && (this.__schema__ = "", this.__index__ = Q, this.__last_index__ = q.index + q[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (Ne = X.indexOf("@"), Ne >= 0 && (he = X.match(this.re.email_fuzzy)) !== null && (Q = he.index + he[1].length, oe = he.index + he[0].length, (this.__index__ < 0 || Q < this.__index__ || Q === this.__index__ && oe > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = Q, this.__last_index__ = oe))), this.__index__ >= 0;
  }, K.prototype.pretest = function(X) {
    return this.re.pretest.test(X);
  }, K.prototype.testSchemaAt = function(X, te, q) {
    return this.__compiled__[te.toLowerCase()] ? this.__compiled__[te.toLowerCase()].validate(X, q, this) : 0;
  }, K.prototype.match = function(X) {
    var te = 0, q = [];
    this.__index__ >= 0 && this.__text_cache__ === X && (q.push(N(this, te)), te = this.__last_index__);
    for (var he = te ? X.slice(te) : X; this.test(he); ) q.push(N(this, te)), he = he.slice(this.__last_index__), te += this.__last_index__;
    return q.length ? q : null;
  }, K.prototype.matchAtStart = function(X) {
    if (this.__text_cache__ = X, this.__index__ = -1, !X.length) return null;
    var te = this.re.schema_at_start.exec(X);
    if (!te) return null;
    var q = this.testSchemaAt(X, te[2], te[0].length);
    return q ? (this.__schema__ = te[2], this.__index__ = te.index + te[1].length, this.__last_index__ = te.index + te[0].length + q, N(this, 0)) : null;
  }, K.prototype.tlds = function(X, te) {
    return X = Array.isArray(X) ? X : [X], te ? (this.__tlds__ = this.__tlds__.concat(X).sort().filter(function(q, he, se) {
      return q !== se[he - 1];
    }).reverse(), V(this), this) : (this.__tlds__ = X.slice(), this.__tlds_replaced__ = true, V(this), this);
  }, K.prototype.normalize = function(X) {
    X.schema || (X.url = "http://" + X.url), X.schema === "mailto:" && !/^mailto:/i.test(X.url) && (X.url = "mailto:" + X.url);
  }, K.prototype.onCompile = function() {
  }, Dg = K, Dg;
}
const Wc = 2147483647, hs = 36, jv = 1, $d = 26, dfe = 38, hfe = 700, uw = 72, dw = 128, hw = "-", pfe = /^xn--/, ffe = /[^\0-\x7F]/, mfe = /[\x2E\u3002\uFF0E\uFF61]/g, gfe = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, Fg = hs - jv, ps = Math.floor, Lg = String.fromCharCode;
function ya(a) {
  throw new RangeError(gfe[a]);
}
function vfe(a, i) {
  const l = [];
  let d = a.length;
  for (; d--; ) l[d] = i(a[d]);
  return l;
}
function pw(a, i) {
  const l = a.split("@");
  let d = "";
  l.length > 1 && (d = l[0] + "@", a = l[1]), a = a.replace(mfe, ".");
  const h = a.split("."), g = vfe(h, i).join(".");
  return d + g;
}
function Nv(a) {
  const i = [];
  let l = 0;
  const d = a.length;
  for (; l < d; ) {
    const h = a.charCodeAt(l++);
    if (h >= 55296 && h <= 56319 && l < d) {
      const g = a.charCodeAt(l++);
      (g & 64512) == 56320 ? i.push(((h & 1023) << 10) + (g & 1023) + 65536) : (i.push(h), l--);
    } else i.push(h);
  }
  return i;
}
const fw = (a) => String.fromCodePoint(...a), yfe = function(a) {
  return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : hs;
}, Ub = function(a, i) {
  return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
}, mw = function(a, i, l) {
  let d = 0;
  for (a = l ? ps(a / hfe) : a >> 1, a += ps(a / i); a > Fg * $d >> 1; d += hs) a = ps(a / Fg);
  return ps(d + (Fg + 1) * a / (a + dfe));
}, Vv = function(a) {
  const i = [], l = a.length;
  let d = 0, h = dw, g = uw, p = a.lastIndexOf(hw);
  p < 0 && (p = 0);
  for (let o = 0; o < p; ++o) a.charCodeAt(o) >= 128 && ya("not-basic"), i.push(a.charCodeAt(o));
  for (let o = p > 0 ? p + 1 : 0; o < l; ) {
    const w = d;
    for (let k = 1, I = hs; ; I += hs) {
      o >= l && ya("invalid-input");
      const z = yfe(a.charCodeAt(o++));
      z >= hs && ya("invalid-input"), z > ps((Wc - d) / k) && ya("overflow"), d += z * k;
      const R = I <= g ? jv : I >= g + $d ? $d : I - g;
      if (z < R) break;
      const O = hs - R;
      k > ps(Wc / O) && ya("overflow"), k *= O;
    }
    const S = i.length + 1;
    g = mw(d - w, S, w == 0), ps(d / S) > Wc - h && ya("overflow"), h += ps(d / S), d %= S, i.splice(d++, 0, h);
  }
  return String.fromCodePoint(...i);
}, Uv = function(a) {
  const i = [];
  a = Nv(a);
  const l = a.length;
  let d = dw, h = 0, g = uw;
  for (const w of a) w < 128 && i.push(Lg(w));
  const p = i.length;
  let o = p;
  for (p && i.push(hw); o < l; ) {
    let w = Wc;
    for (const k of a) k >= d && k < w && (w = k);
    const S = o + 1;
    w - d > ps((Wc - h) / S) && ya("overflow"), h += (w - d) * S, d = w;
    for (const k of a) if (k < d && ++h > Wc && ya("overflow"), k === d) {
      let I = h;
      for (let z = hs; ; z += hs) {
        const R = z <= g ? jv : z >= g + $d ? $d : z - g;
        if (I < R) break;
        const O = I - R, V = hs - R;
        i.push(Lg(Ub(R + O % V, 0))), I = ps(O / V);
      }
      i.push(Lg(Ub(I, 0))), g = mw(h, S, o === p), h = 0, ++o;
    }
    ++h, ++d;
  }
  return i.join("");
}, gw = function(a) {
  return pw(a, function(i) {
    return pfe.test(i) ? Vv(i.slice(4).toLowerCase()) : i;
  });
}, vw = function(a) {
  return pw(a, function(i) {
    return ffe.test(i) ? "xn--" + Uv(i) : i;
  });
}, _fe = { version: "2.3.1", ucs2: { decode: Nv, encode: fw }, decode: Vv, encode: Uv, toASCII: vw, toUnicode: gw }, bfe = Object.freeze(Object.defineProperty({ __proto__: null, decode: Vv, default: _fe, encode: Uv, toASCII: vw, toUnicode: gw, ucs2decode: Nv, ucs2encode: fw }, Symbol.toStringTag, { value: "Module" })), xfe = MC(bfe);
var Bg, qb;
function wfe() {
  return qb || (qb = 1, Bg = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }), Bg;
}
var Og, Gb;
function Cfe() {
  return Gb || (Gb = 1, Og = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }), Og;
}
var $g, Wb;
function Sfe() {
  return Wb || (Wb = 1, $g = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }), $g;
}
var jg, Zb;
function kfe() {
  if (Zb) return jg;
  Zb = 1;
  var a = nn(), i = Spe(), l = kpe(), d = Dpe(), h = Hpe(), g = lfe(), p = ufe(), o = ow(), w = xfe, S = { default: wfe(), zero: Cfe(), commonmark: Sfe() }, k = /^(vbscript|javascript|file|data):/, I = /^data:image\/(gif|png|jpeg|webp);/;
  function z(N) {
    var K = N.trim().toLowerCase();
    return k.test(K) ? !!I.test(K) : true;
  }
  var R = ["http:", "https:", "mailto:"];
  function O(N) {
    var K = o.parse(N, true);
    if (K.hostname && (!K.protocol || R.indexOf(K.protocol) >= 0)) try {
      K.hostname = w.toASCII(K.hostname);
    } catch {
    }
    return o.encode(o.format(K));
  }
  function V(N) {
    var K = o.parse(N, true);
    if (K.hostname && (!K.protocol || R.indexOf(K.protocol) >= 0)) try {
      K.hostname = w.toUnicode(K.hostname);
    } catch {
    }
    return o.decode(o.format(K), o.decode.defaultChars + "%");
  }
  function W(N, K) {
    if (!(this instanceof W)) return new W(N, K);
    K || a.isString(N) || (K = N || {}, N = "default"), this.inline = new g(), this.block = new h(), this.core = new d(), this.renderer = new l(), this.linkify = new p(), this.validateLink = z, this.normalizeLink = O, this.normalizeLinkText = V, this.utils = a, this.helpers = a.assign({}, i), this.options = {}, this.configure(N), K && this.set(K);
  }
  return W.prototype.set = function(N) {
    return a.assign(this.options, N), this;
  }, W.prototype.configure = function(N) {
    var K = this, Z;
    if (a.isString(N) && (Z = N, N = S[Z], !N)) throw new Error('Wrong `markdown-it` preset "' + Z + '", check name');
    if (!N) throw new Error("Wrong `markdown-it` preset, can't be empty");
    return N.options && K.set(N.options), N.components && Object.keys(N.components).forEach(function(X) {
      N.components[X].rules && K[X].ruler.enableOnly(N.components[X].rules), N.components[X].rules2 && K[X].ruler2.enableOnly(N.components[X].rules2);
    }), this;
  }, W.prototype.enable = function(N, K) {
    var Z = [];
    Array.isArray(N) || (N = [N]), ["core", "block", "inline"].forEach(function(te) {
      Z = Z.concat(this[te].ruler.enable(N, true));
    }, this), Z = Z.concat(this.inline.ruler2.enable(N, true));
    var X = N.filter(function(te) {
      return Z.indexOf(te) < 0;
    });
    if (X.length && !K) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + X);
    return this;
  }, W.prototype.disable = function(N, K) {
    var Z = [];
    Array.isArray(N) || (N = [N]), ["core", "block", "inline"].forEach(function(te) {
      Z = Z.concat(this[te].ruler.disable(N, true));
    }, this), Z = Z.concat(this.inline.ruler2.disable(N, true));
    var X = N.filter(function(te) {
      return Z.indexOf(te) < 0;
    });
    if (X.length && !K) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + X);
    return this;
  }, W.prototype.use = function(N) {
    var K = [this].concat(Array.prototype.slice.call(arguments, 1));
    return N.apply(N, K), this;
  }, W.prototype.parse = function(N, K) {
    if (typeof N != "string") throw new Error("Input data should be a String");
    var Z = new this.core.State(N, this, K);
    return this.core.process(Z), Z.tokens;
  }, W.prototype.render = function(N, K) {
    return K = K || {}, this.renderer.render(this.parse(N, K), this.options, K);
  }, W.prototype.parseInline = function(N, K) {
    var Z = new this.core.State(N, this, K);
    return Z.inlineMode = true, this.core.process(Z), Z.tokens;
  }, W.prototype.renderInline = function(N, K) {
    return K = K || {}, this.renderer.render(this.parseInline(N, K), this.options, K);
  }, jg = W, jg;
}
var Ng, Hb;
function Pfe() {
  return Hb || (Hb = 1, Ng = kfe()), Ng;
}
var Tfe = Pfe();
const Mfe = IC(Tfe), Xb = ot({ name: "VueMarkdown", props: { source: { type: String, required: true }, options: { type: Object, required: false }, plugins: { type: Array, required: false } }, setup(a) {
  const i = Me(new Mfe(a.options ?? {}));
  for (const d of a.plugins ?? []) i.value.use(d);
  const l = De(() => i.value.render(a.source));
  return () => L("div", { innerHTML: l.value });
} }), Ife = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, Efe = { class: "about-view" }, Rfe = { id: "project", class: "section project-section" }, zfe = { class: "project-header" }, Afe = { class: "project-description" }, Dfe = { id: "data-sources", class: "section data-sources" }, Ffe = ["href"], Lfe = { id: "credits", class: "section credits-section" }, Bfe = { class: "credit-content" }, Ofe = { key: 1 }, $fe = { class: "license-text" }, jfe = { class: "credit-links" }, Nfe = ["href"], Vfe = ["href"], Ufe = { __name: "AboutView", setup(a) {
  Pa((w) => ({ "1e81317d": `${o.value}px` }));
  const i = Sa(), { t: l } = Ri(), d = Me(false), h = () => {
    d.value = window.innerWidth >= 700;
  };
  Tn(() => {
    h(), window.addEventListener("resize", h);
  }), Qb(() => {
    window.removeEventListener("resize", h);
  });
  const g = Me(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), p = (w) => w.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((S) => S.split(`
`).map((k) => k.trim()).join(" ")).join(`

`).trim(), o = Me(20);
  return (w, S) => (lt(), $t("div", Efe, [d.value ? (lt(), gr(Y(Jx), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: $e(() => [Re(Y(_p), { title: Y(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), Re(Y(_p), { title: Y(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), Re(Y(_p), { title: Y(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : Pr("", true), mt("section", Rfe, [Re(Y(vo), null, { default: $e(() => [mt("div", zfe, [Re(Y(b1), { width: "100", src: g.value, "preview-disabled": "" }, null, 8, ["src"]), Re(Y(pR), null, { default: $e(() => [...S[0] || (S[0] = [Cr("Trackmaker", -1)])]), _: 1 })]), mt("p", Afe, Qt(Y(l)("aboutView.description")), 1), Re(Y(V_), { class: "license-collapse" }, { default: $e(() => [Re(Y(U_), { title: "License", name: "license" }, { header: $e(() => [Re(Y(ba), null, { default: $e(() => [Re(Y(op), null, { default: $e(() => [...S[1] || (S[1] = [Cr("License", -1)])]), _: 1 }), Re(Y(bo), { type: "info", round: "", size: "small" }, { default: $e(() => [...S[2] || (S[2] = [Cr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: $e(() => [Re(Y(Xb), { source: Y(Ife), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), mt("section", Dfe, [Re(Y(vo), null, { header: $e(() => [Cr(Qt(Y(l)("aboutView.sections.dataSource")), 1)]), footer: $e(() => [Re(Y(Xb), { source: Y(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: $e(() => [Re(Y(Ud), null, { default: $e(() => [(lt(true), $t(qr, null, ti(Y(EC), (k) => (lt(), gr(Y(qd), { key: k.id }, { default: $e(() => [Re(Y(ba), null, { default: $e(() => [Re(Y(op), null, { default: $e(() => [Cr(Qt(k.name), 1)]), _: 2 }, 1024), k.license ? (lt(), gr(Y(bo), { key: 0, type: "info", round: "", size: "small" }, { default: $e(() => [Cr(Qt(k.license), 1)]), _: 2 }, 1024)) : Pr("", true)]), _: 2 }, 1024)]), suffix: $e(() => [mt("a", { href: k.url, class: "external-link" }, [Re(Y(xn), { size: o.value, color: Y(i).textColor1 }, { default: $e(() => [Re(Y(F_))]), _: 1 }, 8, ["size", "color"])], 8, Ffe)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), mt("section", Lfe, [Re(Y(vo), { hoverable: "" }, { header: $e(() => [Cr(Qt(Y(l)("aboutView.sections.credits")), 1)]), default: $e(() => [Re(Y(op), null, { default: $e(() => [Cr(Qt(Y(l)("aboutView.creditIntro")), 1)]), _: 1 }), Re(Y(V_), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: $e(() => [(lt(true), $t(qr, null, ti(Y(RC).sort((k, I) => k.name.localeCompare(I.name)), (k) => (lt(), gr(Y(U_), { key: k.id, title: k.name, name: k.id }, { header: $e(() => [Re(Y(ba), null, { default: $e(() => [Cr(Qt(k.name) + " ", 1), k.licenseType.trim() ? (lt(), gr(Y(ba), { key: 0 }, { default: $e(() => [(lt(true), $t(qr, null, ti(k.licenseType.trim().split(",").map((I) => I.trim()), (I) => (lt(), gr(Y(bo), { key: I, round: "", type: "info", size: "small" }, { default: $e(() => [Cr(Qt(I), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : Pr("", true)]), _: 2 }, 1024)]), "header-extra": $e(() => [mt("div", jfe, [k.homepage ? (lt(), $t("a", { key: 0, href: k.homepage }, [Re(Y(xn), { size: o.value, color: Y(i).textColor1 }, { default: $e(() => [Re(Y(F_))]), _: 1 }, 8, ["size", "color"])], 8, Nfe)) : Pr("", true), k.url ? (lt(), $t("a", { key: 1, href: k.url }, [Re(Y(xn), { size: o.value, color: Y(i).textColor1 }, { default: $e(() => [k.url.includes("github") ? (lt(), gr(Y(qk), { key: 0 })) : (lt(), gr(Y(Ox), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, Vfe)) : Pr("", true)])]), default: $e(() => [mt("div", Bfe, [mt("p", null, Qt(k.description), 1), k.license.trim() ? (lt(), gr(Y(c1), { key: 0 })) : Pr("", true), k.license ? (lt(), $t("div", Ofe, [Re(Y(op), null, { default: $e(() => [...S[3] || (S[3] = [mt("strong", null, "License:", -1)])]), _: 1 }), mt("div", $fe, [mt("pre", null, Qt(p(k.license)), 1)])])) : Pr("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, yw = jn(Ufe, [["__scopeId", "data-v-e19031a0"]]), qfe = Object.freeze(Object.defineProperty({ __proto__: null, default: yw }, Symbol.toStringTag, { value: "Module" })), Gfe = { class: "settings-view" }, Wfe = { class: "settings-layout" }, Zfe = { class: "settings-content" }, Hfe = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, Xfe = { key: 0 }, Yfe = { key: 1 }, Kfe = { key: 2 }, Jfe = { key: 3 }, Qfe = { key: 0, class: "settings-nav" }, eme = ot({ __name: "SettingsView", setup(a) {
  const i = new ru(), l = DS(), d = De(() => i.isMobile), { width: h } = Sx(), g = De(() => h.value < 800), p = De(() => h.value < 680), { t: o, availableLocales: w } = Ri(), S = hr("settings"), k = De(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: o("settings.appearance.theme.options.light") }, { value: "dark", label: o("settings.appearance.theme.options.dark") }, { value: "system", label: o("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: w.map((R) => ({ value: R, label: o(`settings.language.interfaceLanguage.options.${R}`) })) }, { title: "mapLanguage", type: "select", items: w.map((R) => ({ value: R, label: o(`settings.language.mapLanguage.options.${R}`) })).concat([{ value: "interface", label: o("settings.language.mapLanguage.options.interface") }]) }] }, { title: "tools", items: [{ title: "apiDetection", type: "button" }, { title: "imuOrientationTesting", type: "button" }] }]), I = () => {
    l.push("/api-detection");
  }, z = () => {
    l.push("/sensor-demo");
  };
  return Tn(() => {
    S.init();
  }), (R, O) => (lt(), $t("div", Gfe, [mt("div", Wfe, [mt("div", Zfe, [(lt(true), $t(qr, null, ti(k.value, (V) => (lt(), gr(Y(vo), { id: "appearance", key: V.title, title: R.$t(`settings.${V.title}.title`) }, { default: $e(() => [Re(Y(Ud), null, { default: $e(() => [(lt(true), $t(qr, null, ti(V.items, (W) => (lt(), gr(Y(qd), { key: W.title }, { default: $e(() => [mt("div", Hfe, [Re(Y(a1), { style: { "white-space": "nowrap" }, tooltip: { trigger: d.value ? "click" : "hover" } }, { tooltip: $e(() => [Cr(Qt(W.items || W.type === "button" ? R.$t(`settings.${V.title}.${W.title}.title`) : R.$t(`settings.${V.title}.${W.title}`)), 1)]), default: $e(() => [Cr(Qt(W.items || W.type === "button" ? R.$t(`settings.${V.title}.${W.title}.title`) : R.$t(`settings.${V.title}.${W.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), W.type === "radio" ? (lt(), $t("div", Xfe, [g.value ? (lt(), gr(Y(ev), { key: 1, value: Y(S).settings[W.title], "onUpdate:value": (N) => Y(S).settings[W.title] = N, options: W.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (lt(), gr(Y(aI), { key: 0, value: Y(S).settings[W.title], "onUpdate:value": (N) => Y(S).settings[W.title] = N }, { default: $e(() => [(lt(true), $t(qr, null, ti(W.items, (N) => (lt(), gr(Y(nI), { key: N.value, value: N.value, label: N.label, checked: Y(S).settings[W.title] === N.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : W.type === "select" ? (lt(), $t("div", Yfe, [Re(Y(ev), { value: Y(S).settings[W.title], "onUpdate:value": (N) => Y(S).settings[W.title] = N, options: W.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : W.type === "checkbox" ? (lt(), $t("div", Kfe, [Re(Y(S1), { value: Y(S).settings[W.title], "onUpdate:value": (N) => Y(S).settings[W.title] = N }, null, 8, ["value", "onUpdate:value"])])) : W.type === "button" ? (lt(), $t("div", Jfe, [Re(Y(jr), { type: "primary", onClick: (N) => W.title === "apiDetection" ? I() : z() }, { default: $e(() => [Cr(Qt(R.$t(`settings.${V.title}.${W.title}.button`)), 1)]), _: 2 }, 1032, ["onClick"])])) : Pr("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), p.value ? Pr("", true) : (lt(), $t("div", Qfe, [Re(Y(Jx), { "show-rail": true, style: { width: "128px" } }, { default: $e(() => [(lt(true), $t(qr, null, ti(k.value, (V) => (lt(), gr(Y(_p), { key: V.title, title: R.$t(`settings.${V.title}.title`), href: `#${V.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), _w = jn(eme, [["__scopeId", "data-v-8793c34f"]]), tme = Object.freeze(Object.defineProperty({ __proto__: null, default: _w }, Symbol.toStringTag, { value: "Module" })), rme = { class: "api-detection-view" }, nme = { class: "api-detection-content" }, ime = { class: "api-status-item" }, ome = { class: "api-name" }, sme = { key: 0, class: "api-details" }, ame = { key: 1, class: "api-error" }, lme = ot({ __name: "ApiDetectionView", setup(a) {
  const { t: i } = Ri(), l = Me([{ name: "fetch", available: false }, { name: "geolocation", available: false }, { name: "performance", available: false }, { name: "permission", available: false }, { name: "deviceorientation", available: false }, { name: "devicemotion", available: false }]), d = () => {
    try {
      l.value[0].available = typeof fetch < "u", l.value[0].details = l.value[0].available ? i("apiDetection.descriptions.fetch.available") : i("apiDetection.descriptions.fetch.unavailable");
    } catch (h) {
      l.value[0].available = false, l.value[0].error = h instanceof Error ? h.message : "Unknown error";
    }
    try {
      l.value[1].available = "geolocation" in navigator, l.value[1].details = l.value[1].available ? i("apiDetection.descriptions.geolocation.available") : i("apiDetection.descriptions.geolocation.unavailable");
    } catch (h) {
      l.value[1].available = false, l.value[1].error = h instanceof Error ? h.message : "Unknown error";
    }
    try {
      l.value[2].available = "performance" in window, l.value[2].details = l.value[2].available ? i("apiDetection.descriptions.performance.available") : i("apiDetection.descriptions.performance.unavailable");
    } catch (h) {
      l.value[2].available = false, l.value[2].error = h instanceof Error ? h.message : "Unknown error";
    }
    try {
      l.value[3].available = "permissions" in navigator, l.value[3].details = l.value[3].available ? i("apiDetection.descriptions.permission.available") : i("apiDetection.descriptions.permission.unavailable");
    } catch (h) {
      l.value[3].available = false, l.value[3].error = h instanceof Error ? h.message : "Unknown error";
    }
    try {
      l.value[4].available = "DeviceOrientationEvent" in window, l.value[4].details = l.value[4].available ? i("apiDetection.descriptions.deviceorientation.available") : i("apiDetection.descriptions.deviceorientation.unavailable");
    } catch (h) {
      l.value[4].available = false, l.value[4].error = h instanceof Error ? h.message : "Unknown error";
    }
    try {
      l.value[5].available = "DeviceMotionEvent" in window, l.value[5].details = l.value[5].available ? i("apiDetection.descriptions.devicemotion.available") : i("apiDetection.descriptions.devicemotion.unavailable");
    } catch (h) {
      l.value[5].available = false, l.value[5].error = h instanceof Error ? h.message : "Unknown error";
    }
  };
  return Tn(() => {
    d();
  }), (h, g) => (lt(), $t("div", rme, [mt("div", nme, [Re(Y(ba), { vertical: "", size: "large" }, { default: $e(() => [Re(Y(vo), { title: h.$t("apiDetection.title") }, { default: $e(() => [Re(Y(vp), { type: "info", "show-icon": false }, { default: $e(() => [Cr(Qt(h.$t("apiDetection.description")), 1)]), _: 1 }), Re(Y(c1), { horizontal: "" }), Re(Y(Ud), null, { default: $e(() => [(lt(true), $t(qr, null, ti(l.value, (p) => (lt(), gr(Y(qd), { key: p.name }, { default: $e(() => [mt("div", ime, [mt("div", ome, Qt(h.$t(`apiDetection.apis.${p.name}`)), 1), Re(Y(bo), { type: p.available ? "success" : "error", bordered: false }, { default: $e(() => [Cr(Qt(p.available ? h.$t("apiDetection.available") : h.$t("apiDetection.unavailable")), 1)]), _: 2 }, 1032, ["type"])]), p.details ? (lt(), $t("div", sme, [Re(Y(a1), null, { default: $e(() => [Cr(Qt(p.details), 1)]), _: 2 }, 1024)])) : Pr("", true), p.error ? (lt(), $t("div", ame, Qt(h.$t("apiDetection.error")) + ": " + Qt(p.error), 1)) : Pr("", true)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 }, 8, ["title"])]), _: 1 })])]));
} }), bw = jn(lme, [["__scopeId", "data-v-485d4d3d"]]), cme = Object.freeze(Object.defineProperty({ __proto__: null, default: bw }, Symbol.toStringTag, { value: "Module" })), ume = { class: "sensor-demo-view" }, dme = { class: "demo-container" }, hme = { key: 1, class: "data-section" }, pme = { class: "orientation-stats" }, fme = { class: "orientation-row" }, mme = { class: "orientation-row" }, gme = { key: 1, class: "data-section" }, vme = { key: 0, class: "sensor-subsection" }, yme = { class: "xyz-row" }, _me = { class: "other-stats-row" }, bme = { key: 1, class: "sensor-subsection" }, xme = { class: "xyz-row" }, wme = { class: "other-stats-row" }, Cme = { key: 1, class: "data-section" }, Sme = { class: "gps-stats" }, kme = { class: "gps-row" }, Pme = { class: "gps-row" }, Tme = { key: 2, class: "data-section" }, Mme = ot({ __name: "SensorTestView", setup(a) {
  const { t: i } = Ri(), l = Me(null), d = Me(null), h = Me(null), g = Me(null), p = Me(null), o = Me(null), w = new zC(), S = Me(null), k = Me(null), I = Me(null), z = Me(null), R = Me(null), O = Me(null), V = Me(null), W = De(() => l.value ? l.value.webkitCompassHeading || 360 - l.value.alpha : 0), N = De(() => l.value ? Math.sqrt(l.value.beta ** 2 + l.value.gamma ** 2) : 0), K = De(() => h.value ? Math.sqrt(h.value.x ** 2 + h.value.y ** 2 + h.value.z ** 2) : 0), Z = De(() => g.value ? Math.sqrt(g.value.x ** 2 + g.value.y ** 2 + g.value.z ** 2) : 0);
  Tn(async () => {
    await X(), await he();
  }), Qb(() => {
    Q();
  });
  async function X() {
    try {
      const oe = await cs.initialize();
      if (oe.isErr()) {
        console.error("Failed to initialize IMU manager:", oe.error), O.value = "IMU manager initialization failed", V.value = "IMU manager initialization failed";
        return;
      }
      await te(), await q();
      const ve = cs.getLastKnownOrientation();
      ve && (l.value = ve);
      const Be = cs.getLastKnownMotion();
      Be && (h.value = Be.acceleration, g.value = Be.gyroscope);
    } catch (oe) {
      console.error("Error initializing IMU manager:", oe), O.value = "Initialization error", V.value = "Initialization error";
    }
  }
  async function te() {
    try {
      const oe = await cs.startOrientationUpdates((ve) => {
        l.value = ve, O.value = null;
      });
      oe.isOk() ? (d.value = oe.value, O.value = null) : O.value = `Start failed: ${oe.error.message}`;
    } catch (oe) {
      O.value = `Error: ${oe instanceof Error ? oe.message : "Unknown error"}`;
    }
  }
  async function q() {
    try {
      const oe = await cs.startAccelerationUpdates({ normalizeToENU: true }, (Be) => {
        h.value = Be, V.value = null;
      });
      if (oe.isErr()) {
        V.value = `Acceleration start failed: ${oe.error.message}`;
        return;
      }
      const ve = await cs.startGyroscopeUpdates({ normalizeToENU: false }, (Be) => {
        g.value = Be, V.value = null;
      });
      if (ve.isErr()) {
        oe.isOk() && cs.stopAccelerationUpdates(oe.value), V.value = `Gyroscope start failed: ${ve.error.message}`;
        return;
      }
      p.value = oe.value, o.value = ve.value, V.value = null;
    } catch (oe) {
      V.value = `Error: ${oe instanceof Error ? oe.message : "Unknown error"}`;
    }
  }
  async function he() {
    try {
      const oe = await w.initialize();
      if (oe.isErr()) {
        console.error("Failed to initialize GPS manager:", oe.error), I.value = "GPS manager initialization failed";
        return;
      }
      const ve = w.getLastKnownLocation();
      ve && ve.latitude !== 0 && ve.longitude !== 0 && (S.value = ve, R.value = /* @__PURE__ */ new Date()), z.value = w.getCurrentBackend(), await se();
    } catch (oe) {
      console.error("Error initializing GPS manager:", oe), I.value = "GPS initialization error";
    }
  }
  async function se() {
    try {
      const oe = await w.startLocationUpdates((ve) => {
        S.value = ve, R.value = /* @__PURE__ */ new Date(), z.value = w.getCurrentBackend(), I.value = null;
      });
      oe.isOk() ? (k.value = oe.value, I.value = null) : I.value = `GPS start failed: ${oe.error.message}`;
    } catch (oe) {
      I.value = `Error: ${oe instanceof Error ? oe.message : "Unknown error"}`;
    }
  }
  function Q() {
    d.value !== null && cs.stopOrientationUpdates(d.value), p.value !== null && cs.stopAccelerationUpdates(p.value), o.value !== null && cs.stopGyroscopeUpdates(o.value), k.value !== null && w.stopLocationUpdates(k.value);
  }
  return (oe, ve) => (lt(), $t("div", ume, [mt("div", dme, [Re(Y(vo), { title: Y(i)("sensorTest.deviceOrientation.title"), class: "sensor-card" }, { default: $e(() => [O.value ? (lt(), gr(Y(vp), { key: 0, type: "error", title: O.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : Pr("", true), l.value ? (lt(), $t("div", hme, [mt("div", pme, [mt("div", fme, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceOrientation.compassHeading"), value: W.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceOrientation.alpha"), value: l.value.alpha.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceOrientation.beta"), value: l.value.beta.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])]), mt("div", mme, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceOrientation.gamma"), value: l.value.gamma.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceOrientation.tiltAngle"), value: N.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), l.value.webkitCompassHeading ? (lt(), gr(Y(Qn), { key: 0, label: Y(i)("sensorTest.deviceOrientation.iosHeading"), value: l.value.webkitCompassHeading.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])) : Pr("", true)])])])) : Pr("", true)]), _: 1 }, 8, ["title"]), Re(Y(vo), { title: Y(i)("sensorTest.deviceMotion.title"), class: "sensor-card" }, { default: $e(() => [V.value ? (lt(), gr(Y(vp), { key: 0, type: "error", title: V.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : Pr("", true), h.value || g.value ? (lt(), $t("div", gme, [h.value ? (lt(), $t("div", vme, [mt("h4", null, Qt(Y(i)("sensorTest.deviceMotion.acceleration.title")), 1), mt("div", yme, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.acceleration.x"), value: h.value.x.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.acceleration.y"), value: h.value.y.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.acceleration.z"), value: h.value.z.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])]), mt("div", _me, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.acceleration.magnitude"), value: K.value.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])])])) : Pr("", true), g.value ? (lt(), $t("div", bme, [mt("h4", null, Qt(Y(i)("sensorTest.deviceMotion.gyroscope.title")), 1), mt("div", xme, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.gyroscope.x"), value: g.value.x.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.gyroscope.y"), value: g.value.y.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.gyroscope.z"), value: g.value.z.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])]), mt("div", wme, [Re(Y(Qn), { label: Y(i)("sensorTest.deviceMotion.gyroscope.rotationSpeed"), value: Z.value.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])])])) : Pr("", true)])) : Pr("", true)]), _: 1 }, 8, ["title"]), Re(Y(vo), { title: Y(i)("sensorTest.gps.title"), class: "sensor-card" }, { default: $e(() => [I.value ? (lt(), gr(Y(vp), { key: 0, type: "error", title: I.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : Pr("", true), S.value ? (lt(), $t("div", Cme, [mt("div", Sme, [mt("div", kme, [Re(Y(Qn), { label: Y(i)("sensorTest.gps.latitude"), value: S.value.latitude.toFixed(6), suffix: "\xB0" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.gps.longitude"), value: S.value.longitude.toFixed(6), suffix: "\xB0" }, null, 8, ["label", "value"]), Re(Y(Qn), { label: Y(i)("sensorTest.gps.accuracy"), value: S.value.accuracy.toFixed(1), suffix: "m" }, null, 8, ["label", "value"])]), mt("div", Pme, [Re(Y(Qn), { label: Y(i)("sensorTest.gps.backend"), value: z.value === "platform" ? Y(i)("sensorTest.gps.backendGPS") : Y(i)("sensorTest.gps.backendIP") }, null, 8, ["label", "value"]), R.value ? (lt(), gr(Y(Qn), { key: 0, label: Y(i)("sensorTest.gps.timestamp"), value: R.value.toLocaleTimeString() }, null, 8, ["label", "value"])) : Pr("", true)])])])) : I.value ? Pr("", true) : (lt(), $t("div", Tme, [mt("p", null, Qt(Y(i)("sensorTest.gps.noData")), 1)]))]), _: 1 }, 8, ["title"])])]));
} }), xw = jn(Mme, [["__scopeId", "data-v-de8efb79"]]), Ime = Object.freeze(Object.defineProperty({ __proto__: null, default: xw }, Symbol.toStringTag, { value: "Module" })), Lme = FS({ history: LS("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: Dc() ? rw : () => Ac(() => Promise.resolve().then(() => n3), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: Dc() ? nw : () => Ac(() => Promise.resolve().then(() => Y3), void 0, import.meta.url) }, { path: "/about", name: "about", component: Dc() ? yw : () => Ac(() => Promise.resolve().then(() => qfe), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: Dc() ? _w : () => Ac(() => Promise.resolve().then(() => tme), void 0, import.meta.url) }, { path: "/api-detection", name: "apiDetection", component: Dc() ? bw : () => Ac(() => Promise.resolve().then(() => cme), void 0, import.meta.url) }, { path: "/sensor-demo", name: "sensorDemo", component: Dc() ? xw : () => Ac(() => Promise.resolve().then(() => Ime), void 0, import.meta.url) }] });
export {
  Lme as default
};
