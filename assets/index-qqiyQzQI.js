var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a2;
import { E as Lf, G as Lw, d as st, c as Xt, o as St, a as It, H as Hd, j as ze, b as Ae, f as Cn, i as fr, I as Xd, q as ar, k as Qi, p as Jr, h as F, m as Ya, J as Bw, L as vy, t as Dt, M as Ka, B as Ao, N as Nn, F as qr, w as vo, O as va, P as Ow, Q as ig, R as $w, S as ws, U as jw, T as _y, V as Nv, W as Al, x as Kr, X as Nw, g as Vw, Y as Ga, Z as Uw, $ as Gw, a0 as Oi, a1 as zr, a2 as yy, a3 as km, a4 as Dl, a5 as Dd, C as Sr, y as Ge, s as Ne, v as ee, z as Pr, D as Yu, A as ir, _ as yo, u as nc, a6 as qw, n as kl, a7 as zg, a8 as dn, a9 as zd, aa as Ww, ab as by, l as Zw, ac as Hw, ad as Xw, ae as hf, af as ff } from "./index-B3cU0dyc.js";
import { u as zo } from "./vue-i18n-CZoz-ox8.js";
import { bq as Yw, br as xy, bs as Kw, b0 as pi, b3 as Pl, bt as wy, bu as Id, bv as Cy, bw as Ji, bx as jn, by as Xf, bz as Pm, aT as Sy, a4 as ue, a7 as Ue, ac as Tr, bA as oc, b1 as Fd, bB as _a, a3 as qe, a6 as Re, a8 as Ld, a9 as Yf, bC as Vn, aj as Nr, af as Yt, B as Jw, ag as jt, ah as ci, aa as wl, bD as Fg, a_ as ui, bE as Kf, bF as xi, ai as Jf, bG as Yd, ae as Rn, bH as Qw, bI as e2, bJ as Ro, bK as Tl, bL as t2, ab as Qf, bM as r2, bN as Vv, b9 as Ot, R as An, bO as i2, b7 as Uv, bi as Lg, bP as n2, a5 as Bf, ap as ep, bQ as o2, al as Bg, am as tp, ao as Og, an as $g, bR as ky, T as ng, bS as a2, bT as og, bU as s2, bV as l2, b5 as Zi, bW as ya, bX as En, bY as Hn, bZ as rp, b_ as u2, b$ as Py, c0 as Ty, c1 as c2, $ as zl, c2 as d2, c3 as h2, c4 as f2, c5 as p2, c6 as Yo, r as Zo, c7 as Za, c8 as Il, c9 as Ef, ca as Ha, cb as Ss, cc as Ts, cd as Hu, ce as Ml, cf as Iy, cg as ag, ch as sg, ci as lg, cj as Md, ck as ug, cl as cg, cm as dg, cn as Of, co as My, cp as Ey, cq as Ry, cr as Ku, cs as $f, ct as m2, cu as ip, cv as Ay, bg as Vr, cw as g2, b6 as jf, b4 as v2, cx as _2, cy as El, cz as y2, a$ as Dy, cA as zy, cB as b2, a0 as x2, aq as w2, cC as C2, cD as S2, cE as jg, cF as k2, cG as P2, cH as T2, cI as I2, c as Kd, cJ as Nf, cK as Fy, cL as Ly, cM as M2, cN as Ho, cO as E2, cP as R2, cQ as A2, cR as By, cS as D2, cT as z2, cU as Oy, cV as $y, cW as F2, cX as L2, cY as B2, cZ as Gv, c_ as O2, X as jy, c$ as $2, d0 as j2, d1 as N2, d2 as V2, d3 as U2, d4 as G2, d5 as Tm, d6 as q2, d7 as W2, d8 as Ny, d9 as qv, da as Z2, aV as Wv, db as H2, dc as Mo, dd as Eo, bh as ki, U as Bd, b2 as Vy, bd as Ng, bo as vd, bc as X2, bm as Uy, bf as Ua, bp as Zv, bn as Y2, de as qa, bk as K2, be as Gy, df as J2, dg as Q2 } from "./platform-DlAx1eiT.js";
var eC = /\s/;
function tC(r) {
  for (var i = r.length; i-- && eC.test(r.charAt(i)); ) ;
  return i;
}
var rC = /^\s+/;
function iC(r) {
  return r && r.slice(0, tC(r) + 1).replace(rC, "");
}
var Hv = NaN, nC = /^[-+]0x[0-9a-f]+$/i, oC = /^0b[01]+$/i, aC = /^0o[0-7]+$/i, sC = parseInt;
function Ed(r) {
  if (typeof r == "number") return r;
  if (Yw(r)) return Hv;
  if (Lf(r)) {
    var i = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Lf(i) ? i + "" : i;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = iC(r);
  var l = oC.test(r);
  return l || aC.test(r) ? sC(r.slice(2), l ? 2 : 8) : nC.test(r) ? Hv : +r;
}
function lC(r, i, l, d) {
  for (var f = -1, g = r == null ? 0 : r.length; ++f < g; ) l = i(l, r[f], f, r);
  return l;
}
function uC(r) {
  return function(i) {
    return r == null ? void 0 : r[i];
  };
}
var cC = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, dC = uC(cC), hC = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, fC = "\\u0300-\\u036f", pC = "\\ufe20-\\ufe2f", mC = "\\u20d0-\\u20ff", gC = fC + pC + mC, vC = "[" + gC + "]", _C = RegExp(vC, "g");
function yC(r) {
  return r = xy(r), r && r.replace(hC, dC).replace(_C, "");
}
var bC = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function xC(r) {
  return r.match(bC) || [];
}
var wC = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function CC(r) {
  return wC.test(r);
}
var qy = "\\ud800-\\udfff", SC = "\\u0300-\\u036f", kC = "\\ufe20-\\ufe2f", PC = "\\u20d0-\\u20ff", TC = SC + kC + PC, Wy = "\\u2700-\\u27bf", Zy = "a-z\\xdf-\\xf6\\xf8-\\xff", IC = "\\xac\\xb1\\xd7\\xf7", MC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", EC = "\\u2000-\\u206f", RC = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Hy = "A-Z\\xc0-\\xd6\\xd8-\\xde", AC = "\\ufe0e\\ufe0f", Xy = IC + MC + EC + RC, Yy = "['\u2019]", Xv = "[" + Xy + "]", DC = "[" + TC + "]", Ky = "\\d+", zC = "[" + Wy + "]", Jy = "[" + Zy + "]", Qy = "[^" + qy + Xy + Ky + Wy + Zy + Hy + "]", FC = "\\ud83c[\\udffb-\\udfff]", LC = "(?:" + DC + "|" + FC + ")", BC = "[^" + qy + "]", eb = "(?:\\ud83c[\\udde6-\\uddff]){2}", tb = "[\\ud800-\\udbff][\\udc00-\\udfff]", Wu = "[" + Hy + "]", OC = "\\u200d", Yv = "(?:" + Jy + "|" + Qy + ")", $C = "(?:" + Wu + "|" + Qy + ")", Kv = "(?:" + Yy + "(?:d|ll|m|re|s|t|ve))?", Jv = "(?:" + Yy + "(?:D|LL|M|RE|S|T|VE))?", rb = LC + "?", ib = "[" + AC + "]?", jC = "(?:" + OC + "(?:" + [BC, eb, tb].join("|") + ")" + ib + rb + ")*", NC = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", VC = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", UC = ib + rb + jC, GC = "(?:" + [zC, eb, tb].join("|") + ")" + UC, qC = RegExp([Wu + "?" + Jy + "+" + Kv + "(?=" + [Xv, Wu, "$"].join("|") + ")", $C + "+" + Jv + "(?=" + [Xv, Wu + Yv, "$"].join("|") + ")", Wu + "?" + Yv + "+" + Kv, Wu + "+" + Jv, VC, NC, Ky, GC].join("|"), "g");
function WC(r) {
  return r.match(qC) || [];
}
function ZC(r, i, l) {
  return r = xy(r), i = i, i === void 0 ? CC(r) ? WC(r) : xC(r) : r.match(i) || [];
}
var HC = "['\u2019]", XC = RegExp(HC, "g");
function YC(r) {
  return function(i) {
    return lC(ZC(yC(i).replace(XC, "")), r, "");
  };
}
function KC(r, i, l) {
  return r === r && (l !== void 0 && (r = r <= l ? r : l), i !== void 0 && (r = r >= i ? r : i)), r;
}
function hg(r, i, l) {
  return l === void 0 && (l = i, i = void 0), l !== void 0 && (l = Ed(l), l = l === l ? l : 0), i !== void 0 && (i = Ed(i), i = i === i ? i : 0), KC(Ed(r), i, l);
}
var Im = function() {
  return Lw.Date.now();
}, JC = "Expected a function", QC = Math.max, e3 = Math.min;
function t3(r, i, l) {
  var d, f, g, m, s, C, T = 0, M = false, z = false, L = true;
  if (typeof r != "function") throw new TypeError(JC);
  i = Ed(i) || 0, Lf(l) && (M = !!l.leading, z = "maxWait" in l, g = z ? QC(Ed(l.maxWait) || 0, i) : g, L = "trailing" in l ? !!l.trailing : L);
  function A(J) {
    var Se = d, fe = f;
    return d = f = void 0, T = J, m = r.apply(fe, Se), m;
  }
  function O(J) {
    return T = J, s = setTimeout(H, i), M ? A(J) : m;
  }
  function U(J) {
    var Se = J - C, fe = J - T, oe = i - Se;
    return z ? e3(oe, g - fe) : oe;
  }
  function X(J) {
    var Se = J - C, fe = J - T;
    return C === void 0 || Se >= i || Se < 0 || z && fe >= g;
  }
  function H() {
    var J = Im();
    if (X(J)) return Q(J);
    s = setTimeout(H, U(J));
  }
  function Q(J) {
    return s = void 0, L && d ? A(J) : (d = f = void 0, m);
  }
  function ie() {
    s !== void 0 && clearTimeout(s), T = 0, d = C = f = s = void 0;
  }
  function te() {
    return s === void 0 ? m : Q(Im());
  }
  function re() {
    var J = Im(), Se = X(J);
    if (d = arguments, f = this, C = J, Se) {
      if (s === void 0) return O(C);
      if (z) return clearTimeout(s), s = setTimeout(H, i), A(C);
    }
    return s === void 0 && (s = setTimeout(H, i)), m;
  }
  return re.cancel = ie, re.flush = te, re;
}
var r3 = YC(function(r, i, l) {
  return r + (l ? "-" : "") + i.toLowerCase();
}), i3 = "Expected a function";
function n3(r, i, l) {
  var d = true, f = true;
  if (typeof r != "function") throw new TypeError(i3);
  return Lf(l) && (d = "leading" in l ? !!l.leading : d, f = "trailing" in l ? !!l.trailing : f), t3(r, i, { leading: d, maxWait: i, trailing: f });
}
const o3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, a3 = st({ name: "BrandGithub", render: function(i, l) {
  return St(), Xt("svg", o3, l[0] || (l[0] = [It("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), s3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, l3 = st({ name: "Calendar", render: function(i, l) {
  return St(), Xt("svg", s3, l[0] || (l[0] = [Hd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), u3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, c3 = st({ name: "DeviceFloppy", render: function(i, l) {
  return St(), Xt("svg", u3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), It("circle", { cx: "12", cy: "14", r: "2" }), It("path", { d: "M14 4v4H8V4" })], -1)]));
} }), d3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, h3 = st({ name: "Edit", render: function(i, l) {
  return St(), Xt("svg", d3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), It("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), It("path", { d: "M16 5l3 3" })], -1)]));
} }), f3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, nb = st({ name: "FileText", render: function(i, l) {
  return St(), Xt("svg", f3, l[0] || (l[0] = [Hd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), p3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, m3 = st({ name: "Folder", render: function(i, l) {
  return St(), Xt("svg", p3, l[0] || (l[0] = [It("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), g3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, v3 = st({ name: "HandFinger", render: function(i, l) {
  return St(), Xt("svg", g3, l[0] || (l[0] = [Hd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), _3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, y3 = st({ name: "Line", render: function(i, l) {
  return St(), Xt("svg", _3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("circle", { cx: "6", cy: "18", r: "2" }), It("circle", { cx: "18", cy: "6", r: "2" }), It("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), b3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Qv = st({ name: "Link", render: function(i, l) {
  return St(), Xt("svg", b3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), It("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), x3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, w3 = st({ name: "Minus", render: function(i, l) {
  return St(), Xt("svg", x3, l[0] || (l[0] = [It("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), C3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, S3 = st({ name: "PlayerRecord", render: function(i, l) {
  return St(), Xt("svg", C3, l[0] || (l[0] = [It("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), k3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Od = st({ name: "Plus", render: function(i, l) {
  return St(), Xt("svg", k3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("path", { d: "M12 5v14" }), It("path", { d: "M5 12h14" })], -1)]));
} }), P3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Vg = st({ name: "Route", render: function(i, l) {
  return St(), Xt("svg", P3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("circle", { cx: "6", cy: "19", r: "2" }), It("circle", { cx: "18", cy: "5", r: "2" }), It("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), T3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, ob = st({ name: "Shape", render: function(i, l) {
  return St(), Xt("svg", T3, l[0] || (l[0] = [Hd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), I3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, M3 = st({ name: "Square", render: function(i, l) {
  return St(), Xt("svg", I3, l[0] || (l[0] = [It("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), E3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, np = st({ name: "Trash", render: function(i, l) {
  return St(), Xt("svg", E3, l[0] || (l[0] = [Hd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), R3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, ab = st({ name: "Upload", render: function(i, l) {
  return St(), Xt("svg", R3, l[0] || (l[0] = [It("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [It("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), It("path", { d: "M7 9l5-5l5 5" }), It("path", { d: "M12 4v12" })], -1)]));
} });
function sb(r) {
  return typeof r == "string" ? document.querySelector(r) : typeof r == "function" ? r() : r;
}
function A3(r) {
  if (typeof r == "number") return { "": r.toString() };
  const i = {};
  return r.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [d, f] = l.split(":");
    f === void 0 ? i[""] = d : i[d] = f;
  }), i;
}
function Ou(r, i) {
  var l;
  if (r == null) return;
  const d = A3(r);
  if (i === void 0) return d[""];
  if (typeof i == "string") return (l = d[i]) !== null && l !== void 0 ? l : d[""];
  if (Array.isArray(i)) {
    for (let f = i.length - 1; f >= 0; --f) {
      const g = i[f];
      if (g in d) return d[g];
    }
    return d[""];
  } else {
    let f, g = -1;
    return Object.keys(d).forEach((m) => {
      const s = Number(m);
      !Number.isNaN(s) && i >= s && s >= g && (g = s, f = d[m]);
    }), f;
  }
}
const D3 = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function z3(r) {
  return `(min-width: ${r}px)`;
}
const _d = {};
function F3(r = D3) {
  if (!Kw) return ze(() => []);
  if (typeof window.matchMedia != "function") return ze(() => []);
  const i = Ae({}), l = Object.keys(r), d = (f, g) => {
    f.matches ? i.value[g] = true : i.value[g] = false;
  };
  return l.forEach((f) => {
    const g = r[f];
    let m, s;
    _d[g] === void 0 ? (m = window.matchMedia(z3(g)), m.addEventListener ? m.addEventListener("change", (C) => {
      s.forEach((T) => {
        T(C, f);
      });
    }) : m.addListener && m.addListener((C) => {
      s.forEach((T) => {
        T(C, f);
      });
    }), s = /* @__PURE__ */ new Set(), _d[g] = { mql: m, cbs: s }) : (m = _d[g].mql, s = _d[g].cbs), s.add(d), m.matches && s.forEach((C) => {
      C(m, f);
    });
  }), Cn(() => {
    l.forEach((f) => {
      const { cbs: g } = _d[r[f]];
      g.has(d) && g.delete(d);
    });
  }), ze(() => {
    const { value: f } = i;
    return l.filter((g) => f[g]);
  });
}
function L3(r, i, l) {
  var d;
  const f = fr(r, null);
  if (f === null) return;
  const g = (d = Xd()) === null || d === void 0 ? void 0 : d.proxy;
  ar(l, m), m(l.value), Cn(() => {
    m(void 0, l.value);
  });
  function m(T, M) {
    if (!f) return;
    const z = f[i];
    M !== void 0 && s(z, M), T !== void 0 && C(z, T);
  }
  function s(T, M) {
    T[M] || (T[M] = []), T[M].splice(T[M].findIndex((z) => z === g), 1);
  }
  function C(T, M) {
    T[M] || (T[M] = []), ~T[M].findIndex((z) => z === g) || T[M].push(g);
  }
}
function B3(r, i, l) {
  const d = fr(r, null);
  d !== null && (i in d || (d[i] = []), d[i].push(l.value), ar(l, (f, g) => {
    const m = d[i], s = m.findIndex((C) => C === g);
    ~s && m.splice(s, 1), m.push(f);
  }), Cn(() => {
    const f = d[i], g = f.findIndex((m) => m === l.value);
    ~g && f.splice(g, 1);
  }));
}
function O3(r, i, l) {
  const d = fr(r, null);
  d !== null && (i in d || (d[i] = []), Qi(() => {
    const f = l();
    f && d[i].push(f);
  }), Cn(() => {
    const f = d[i], g = l(), m = f.findIndex((s) => s === g);
    ~m && f.splice(m, 1);
  }));
}
function e_(r) {
  return r & -r;
}
class lb {
  constructor(i, l) {
    this.l = i, this.min = l;
    const d = new Array(i + 1);
    for (let f = 0; f < i + 1; ++f) d[f] = 0;
    this.ft = d;
  }
  add(i, l) {
    if (l === 0) return;
    const { l: d, ft: f } = this;
    for (i += 1; i <= d; ) f[i] += l, i += e_(i);
  }
  get(i) {
    return this.sum(i + 1) - this.sum(i);
  }
  sum(i) {
    if (i === void 0 && (i = this.l), i <= 0) return 0;
    const { ft: l, min: d, l: f } = this;
    if (i > f) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let g = i * d;
    for (; i > 0; ) g += l[i], i -= e_(i);
    return g;
  }
  getBound(i) {
    let l = 0, d = this.l;
    for (; d > l; ) {
      const f = Math.floor((l + d) / 2), g = this.sum(f);
      if (g > i) {
        d = f;
        continue;
      } else if (g < i) {
        if (l === f) return this.sum(l + 1) <= i ? l + 1 : f;
        l = f;
      } else return f;
    }
    return l;
  }
}
let pf;
function $3() {
  return typeof document > "u" ? false : (pf === void 0 && ("matchMedia" in window ? pf = window.matchMedia("(pointer:coarse)").matches : pf = false), pf);
}
let Mm;
function t_() {
  return typeof document > "u" ? 1 : (Mm === void 0 && (Mm = "chrome" in window ? window.devicePixelRatio : 1), Mm);
}
const ub = "VVirtualListXScroll";
function j3({ columnsRef: r, renderColRef: i, renderItemWithColsRef: l }) {
  const d = Ae(0), f = Ae(0), g = ze(() => {
    const T = r.value;
    if (T.length === 0) return null;
    const M = new lb(T.length, 0);
    return T.forEach((z, L) => {
      M.add(L, z.width);
    }), M;
  }), m = pi(() => {
    const T = g.value;
    return T !== null ? Math.max(T.getBound(f.value) - 1, 0) : 0;
  }), s = (T) => {
    const M = g.value;
    return M !== null ? M.sum(T) : 0;
  }, C = pi(() => {
    const T = g.value;
    return T !== null ? Math.min(T.getBound(f.value + d.value) + 1, r.value.length - 1) : 0;
  });
  return Jr(ub, { startIndexRef: m, endIndexRef: C, columnsRef: r, renderColRef: i, renderItemWithColsRef: l, getLeft: s }), { listWidthRef: d, scrollLeftRef: f };
}
const r_ = st({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: r, endIndexRef: i, columnsRef: l, getLeft: d, renderColRef: f, renderItemWithColsRef: g } = fr(ub);
  return { startIndex: r, endIndex: i, columns: l, renderCol: f, renderItemWithCols: g, getLeft: d };
}, render() {
  const { startIndex: r, endIndex: i, columns: l, renderCol: d, renderItemWithCols: f, getLeft: g, item: m } = this;
  if (f != null) return f({ itemIndex: this.index, startColIndex: r, endColIndex: i, allColumns: l, item: m, getLeft: g });
  if (d != null) {
    const s = [];
    for (let C = r; C <= i; ++C) {
      const T = l[C];
      s.push(d({ column: T, left: g(C), item: m }));
    }
    return s;
  }
  return null;
} }), N3 = Id(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [Id("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [Id("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), V3 = st({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(r) {
  const i = wy();
  N3.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: Cy, ssr: i }), Qi(() => {
    const { defaultScrollIndex: Ve, defaultScrollKey: Ke } = r;
    Ve != null ? X({ index: Ve }) : Ke != null && X({ key: Ke });
  });
  let l = false, d = false;
  Bw(() => {
    if (l = false, !d) {
      d = true;
      return;
    }
    X({ top: A.value, left: m.value });
  }), vy(() => {
    l = true, d || (d = true);
  });
  const f = pi(() => {
    if (r.renderCol == null && r.renderItemWithCols == null || r.columns.length === 0) return;
    let Ve = 0;
    return r.columns.forEach((Ke) => {
      Ve += Ke.width;
    }), Ve;
  }), g = ze(() => {
    const Ve = /* @__PURE__ */ new Map(), { keyField: Ke } = r;
    return r.items.forEach((lt, vt) => {
      Ve.set(lt[Ke], vt);
    }), Ve;
  }), { scrollLeftRef: m, listWidthRef: s } = j3({ columnsRef: Dt(r, "columns"), renderColRef: Dt(r, "renderCol"), renderItemWithColsRef: Dt(r, "renderItemWithCols") }), C = Ae(null), T = Ae(void 0), M = /* @__PURE__ */ new Map(), z = ze(() => {
    const { items: Ve, itemSize: Ke, keyField: lt } = r, vt = new lb(Ve.length, Ke);
    return Ve.forEach((xt, at) => {
      const et = xt[lt], ht = M.get(et);
      ht !== void 0 && vt.add(at, ht);
    }), vt;
  }), L = Ae(0), A = Ae(0), O = pi(() => Math.max(z.value.getBound(A.value - Ji(r.paddingTop)) - 1, 0)), U = ze(() => {
    const { value: Ve } = T;
    if (Ve === void 0) return [];
    const { items: Ke, itemSize: lt } = r, vt = O.value, xt = Math.min(vt + Math.ceil(Ve / lt + 1), Ke.length - 1), at = [];
    for (let et = vt; et <= xt; ++et) at.push(Ke[et]);
    return at;
  }), X = (Ve, Ke) => {
    if (typeof Ve == "number") {
      te(Ve, Ke, "auto");
      return;
    }
    const { left: lt, top: vt, index: xt, key: at, position: et, behavior: ht, debounce: yt = true } = Ve;
    if (lt !== void 0 || vt !== void 0) te(lt, vt, ht);
    else if (xt !== void 0) ie(xt, ht, yt);
    else if (at !== void 0) {
      const nt = g.value.get(at);
      nt !== void 0 && ie(nt, ht, yt);
    } else et === "bottom" ? te(0, Number.MAX_SAFE_INTEGER, ht) : et === "top" && te(0, 0, ht);
  };
  let H, Q = null;
  function ie(Ve, Ke, lt) {
    const { value: vt } = z, xt = vt.sum(Ve) + Ji(r.paddingTop);
    if (!lt) C.value.scrollTo({ left: 0, top: xt, behavior: Ke });
    else {
      H = Ve, Q !== null && window.clearTimeout(Q), Q = window.setTimeout(() => {
        H = void 0, Q = null;
      }, 16);
      const { scrollTop: at, offsetHeight: et } = C.value;
      if (xt > at) {
        const ht = vt.get(Ve);
        xt + ht <= at + et || C.value.scrollTo({ left: 0, top: xt + ht - et, behavior: Ke });
      } else C.value.scrollTo({ left: 0, top: xt, behavior: Ke });
    }
  }
  function te(Ve, Ke, lt) {
    C.value.scrollTo({ left: Ve, top: Ke, behavior: lt });
  }
  function re(Ve, Ke) {
    var lt, vt, xt;
    if (l || r.ignoreItemResize || $e(Ke.target)) return;
    const { value: at } = z, et = g.value.get(Ve), ht = at.get(et), yt = (xt = (vt = (lt = Ke.borderBoxSize) === null || lt === void 0 ? void 0 : lt[0]) === null || vt === void 0 ? void 0 : vt.blockSize) !== null && xt !== void 0 ? xt : Ke.contentRect.height;
    if (yt === ht) return;
    yt - r.itemSize === 0 ? M.delete(Ve) : M.set(Ve, yt - r.itemSize);
    const ut = yt - ht;
    if (ut === 0) return;
    at.add(et, ut);
    const Lt = C.value;
    if (Lt != null) {
      if (H === void 0) {
        const Ht = at.sum(et);
        Lt.scrollTop > Ht && Lt.scrollBy(0, ut);
      } else if (et < H) Lt.scrollBy(0, ut);
      else if (et === H) {
        const Ht = at.sum(et);
        yt + Ht > Lt.scrollTop + Lt.offsetHeight && Lt.scrollBy(0, ut);
      }
      xe();
    }
    L.value++;
  }
  const J = !$3();
  let Se = false;
  function fe(Ve) {
    var Ke;
    (Ke = r.onScroll) === null || Ke === void 0 || Ke.call(r, Ve), (!J || !Se) && xe();
  }
  function oe(Ve) {
    var Ke;
    if ((Ke = r.onWheel) === null || Ke === void 0 || Ke.call(r, Ve), J) {
      const lt = C.value;
      if (lt != null) {
        if (Ve.deltaX === 0 && (lt.scrollTop === 0 && Ve.deltaY <= 0 || lt.scrollTop + lt.offsetHeight >= lt.scrollHeight && Ve.deltaY >= 0)) return;
        Ve.preventDefault(), lt.scrollTop += Ve.deltaY / t_(), lt.scrollLeft += Ve.deltaX / t_(), xe(), Se = true, Xf(() => {
          Se = false;
        });
      }
    }
  }
  function de(Ve) {
    if (l || $e(Ve.target)) return;
    if (r.renderCol == null && r.renderItemWithCols == null) {
      if (Ve.contentRect.height === T.value) return;
    } else if (Ve.contentRect.height === T.value && Ve.contentRect.width === s.value) return;
    T.value = Ve.contentRect.height, s.value = Ve.contentRect.width;
    const { onResize: Ke } = r;
    Ke !== void 0 && Ke(Ve);
  }
  function xe() {
    const { value: Ve } = C;
    Ve != null && (A.value = Ve.scrollTop, m.value = Ve.scrollLeft);
  }
  function $e(Ve) {
    let Ke = Ve;
    for (; Ke !== null; ) {
      if (Ke.style.display === "none") return true;
      Ke = Ke.parentElement;
    }
    return false;
  }
  return { listHeight: T, listStyle: { overflow: "auto" }, keyToIndex: g, itemsStyle: ze(() => {
    const { itemResizable: Ve } = r, Ke = jn(z.value.sum());
    return L.value, [r.itemsStyle, { boxSizing: "content-box", width: jn(f.value), height: Ve ? "" : Ke, minHeight: Ve ? Ke : "", paddingTop: jn(r.paddingTop), paddingBottom: jn(r.paddingBottom) }];
  }), visibleItemsStyle: ze(() => (L.value, { transform: `translateY(${jn(z.value.sum(O.value))})` })), viewportItems: U, listElRef: C, itemsElRef: Ae(null), scrollTo: X, handleListResize: de, handleListScroll: fe, handleListWheel: oe, handleItemResize: re };
}, render() {
  const { itemResizable: r, keyField: i, keyToIndex: l, visibleItemsTag: d } = this;
  return F(Pl, { onResize: this.handleListResize }, { default: () => {
    var f, g;
    return F("div", Ya(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? F("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [F(d, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: m, renderItemWithCols: s } = this;
      return this.viewportItems.map((C) => {
        const T = C[i], M = l.get(T), z = m != null ? F(r_, { index: M, item: C }) : void 0, L = s != null ? F(r_, { index: M, item: C }) : void 0, A = this.$slots.default({ item: C, renderedCols: z, renderedItemWithCols: L, index: M })[0];
        return r ? F(Pl, { key: T, onResize: (O) => this.handleItemResize(T, O) }, { default: () => A }) : (A.key = T, A);
      });
    } })]) : (g = (f = this.$slots).empty) === null || g === void 0 ? void 0 : g.call(f)]);
  } });
} }), U3 = Id(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [Id("&::-webkit-scrollbar", { width: 0, height: 0 })]), G3 = st({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const r = Ae(null);
  function i(f) {
    !(f.currentTarget.offsetWidth < f.currentTarget.scrollWidth) || f.deltaY === 0 || (f.currentTarget.scrollLeft += f.deltaY + f.deltaX, f.preventDefault());
  }
  const l = wy();
  return U3.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: Cy, ssr: l }), Object.assign({ selfRef: r, handleWheel: i }, { scrollTo(...f) {
    var g;
    (g = r.value) === null || g === void 0 || g.scrollTo(...f);
  } });
}, render() {
  return F("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function cb(r, i) {
  i && (Qi(() => {
    const { value: l } = r;
    l && Pm.registerHandler(l, i);
  }), ar(r, (l, d) => {
    d && Pm.unregisterHandler(d);
  }, { deep: false }), Cn(() => {
    const { value: l } = r;
    l && Pm.unregisterHandler(l);
  }));
}
function db(r, i) {
  if (!r) return;
  const l = document.createElement("a");
  l.href = r, i !== void 0 && (l.download = i), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function fg(r) {
  switch (typeof r) {
    case "string":
      return r || void 0;
    case "number":
      return String(r);
    default:
      return;
  }
}
const q3 = { tiny: "mini", small: "tiny", medium: "small", large: "medium", huge: "large" };
function W3(r) {
  const i = q3[r];
  if (i === void 0) throw new Error(`${r} has no smaller size.`);
  return i;
}
function op(r, i = "default", l = []) {
  const f = r.$slots[i];
  return f === void 0 ? l : f();
}
function Z3(r) {
  var i;
  const l = (i = r.dirs) === null || i === void 0 ? void 0 : i.find(({ dir: d }) => d === Ka);
  return !!(l && l.value === false);
}
function Em(r) {
  const i = r.filter((l) => l !== void 0);
  if (i.length !== 0) return i.length === 1 ? i[0] : (l) => {
    r.forEach((d) => {
      d && d(l);
    });
  };
}
const H3 = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (r) => `Please load all ${r}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (r) => `Total ${r} items`, selected: (r) => `${r} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" }, Heatmap: { less: "less", more: "more", monthFormat: "MMM", weekdayFormat: "eee" } };
function Rm(r) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : r.defaultWidth;
    return r.formats[l] || r.formats[r.defaultWidth];
  };
}
function yd(r) {
  return (i, l) => {
    const d = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let f;
    if (d === "formatting" && r.formattingValues) {
      const m = r.defaultFormattingWidth || r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : m;
      f = r.formattingValues[s] || r.formattingValues[m];
    } else {
      const m = r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : r.defaultWidth;
      f = r.values[s] || r.values[m];
    }
    const g = r.argumentCallback ? r.argumentCallback(i) : i;
    return f[g];
  };
}
function bd(r) {
  return (i, l = {}) => {
    const d = l.width, f = d && r.matchPatterns[d] || r.matchPatterns[r.defaultMatchWidth], g = i.match(f);
    if (!g) return null;
    const m = g[0], s = d && r.parsePatterns[d] || r.parsePatterns[r.defaultParseWidth], C = Array.isArray(s) ? Y3(s, (z) => z.test(m)) : X3(s, (z) => z.test(m));
    let T;
    T = r.valueCallback ? r.valueCallback(C) : C, T = l.valueCallback ? l.valueCallback(T) : T;
    const M = i.slice(m.length);
    return { value: T, rest: M };
  };
}
function X3(r, i) {
  for (const l in r) if (Object.prototype.hasOwnProperty.call(r, l) && i(r[l])) return l;
}
function Y3(r, i) {
  for (let l = 0; l < r.length; l++) if (i(r[l])) return l;
}
function K3(r) {
  return (i, l = {}) => {
    const d = i.match(r.matchPattern);
    if (!d) return null;
    const f = d[0], g = i.match(r.parsePattern);
    if (!g) return null;
    let m = r.valueCallback ? r.valueCallback(g[0]) : g[0];
    m = l.valueCallback ? l.valueCallback(m) : m;
    const s = i.slice(f.length);
    return { value: m, rest: s };
  };
}
const J3 = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, Q3 = (r, i, l) => {
  let d;
  const f = J3[r];
  return typeof f == "string" ? d = f : i === 1 ? d = f.one : d = f.other.replace("{{count}}", i.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + d : d + " ago" : d;
}, eS = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, tS = (r, i, l, d) => eS[r], rS = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, iS = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, nS = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, oS = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, aS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, sS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, lS = (r, i) => {
  const l = Number(r), d = l % 100;
  if (d > 20 || d < 10) switch (d % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, uS = { ordinalNumber: lS, era: yd({ values: rS, defaultWidth: "wide" }), quarter: yd({ values: iS, defaultWidth: "wide", argumentCallback: (r) => r - 1 }), month: yd({ values: nS, defaultWidth: "wide" }), day: yd({ values: oS, defaultWidth: "wide" }), dayPeriod: yd({ values: aS, defaultWidth: "wide", formattingValues: sS, defaultFormattingWidth: "wide" }) }, cS = /^(\d+)(th|st|nd|rd)?/i, dS = /\d+/i, hS = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, fS = { any: [/^b/i, /^(a|c)/i] }, pS = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, mS = { any: [/1/i, /2/i, /3/i, /4/i] }, gS = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, vS = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, _S = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, yS = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, bS = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, xS = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, wS = { ordinalNumber: K3({ matchPattern: cS, parsePattern: dS, valueCallback: (r) => parseInt(r, 10) }), era: bd({ matchPatterns: hS, defaultMatchWidth: "wide", parsePatterns: fS, defaultParseWidth: "any" }), quarter: bd({ matchPatterns: pS, defaultMatchWidth: "wide", parsePatterns: mS, defaultParseWidth: "any", valueCallback: (r) => r + 1 }), month: bd({ matchPatterns: gS, defaultMatchWidth: "wide", parsePatterns: vS, defaultParseWidth: "any" }), day: bd({ matchPatterns: _S, defaultMatchWidth: "wide", parsePatterns: yS, defaultParseWidth: "any" }), dayPeriod: bd({ matchPatterns: bS, defaultMatchWidth: "any", parsePatterns: xS, defaultParseWidth: "any" }) }, CS = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, SS = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, kS = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, PS = { date: Rm({ formats: CS, defaultWidth: "full" }), time: Rm({ formats: SS, defaultWidth: "full" }), dateTime: Rm({ formats: kS, defaultWidth: "full" }) }, TS = { code: "en-US", formatDistance: Q3, formatLong: PS, formatRelative: tS, localize: uS, match: wS, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, IS = { name: "en-US", locale: TS };
function Ja(r) {
  const { mergedLocaleRef: i, mergedDateLocaleRef: l } = fr(Sy, null) || {}, d = ze(() => {
    var g, m;
    return (m = (g = i == null ? void 0 : i.value) === null || g === void 0 ? void 0 : g[r]) !== null && m !== void 0 ? m : H3[r];
  });
  return { dateLocaleRef: ze(() => {
    var g;
    return (g = l == null ? void 0 : l.value) !== null && g !== void 0 ? g : IS;
  }), localeRef: d };
}
const MS = ue("affix", [Ue("affixed", { position: "fixed" }, [Ue("absolute-positioned", { position: "absolute" })])]);
function ES(r) {
  return r instanceof HTMLElement ? r.scrollTop : window.scrollY;
}
function RS(r) {
  return r instanceof HTMLElement ? r.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const Ug = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, AS = Fd(Ug), DS = st({ name: "Affix", props: Ug, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  oc("-affix", MS, i);
  let l = null;
  const d = Ae(false), f = Ae(false), g = Ae(null), m = Ae(null), s = ze(() => f.value || d.value), C = ze(() => {
    var X, H;
    return (H = (X = r.triggerTop) !== null && X !== void 0 ? X : r.offsetTop) !== null && H !== void 0 ? H : r.top;
  }), T = ze(() => {
    var X, H;
    return (H = (X = r.top) !== null && X !== void 0 ? X : r.triggerTop) !== null && H !== void 0 ? H : r.offsetTop;
  }), M = ze(() => {
    var X, H;
    return (H = (X = r.bottom) !== null && X !== void 0 ? X : r.triggerBottom) !== null && H !== void 0 ? H : r.offsetBottom;
  }), z = ze(() => {
    var X, H;
    return (H = (X = r.triggerBottom) !== null && X !== void 0 ? X : r.offsetBottom) !== null && H !== void 0 ? H : r.bottom;
  }), L = Ae(null), A = () => {
    const { target: X, listenTo: H } = r;
    X ? l = X() : H ? l = sb(H) : l = document, l && (l.addEventListener("scroll", O), O());
  };
  function O() {
    Xf(U);
  }
  function U() {
    const { value: X } = L;
    if (!l || !X) return;
    const H = ES(l);
    if (s.value) {
      m.value !== null && H < m.value && (d.value = false, m.value = null), g.value !== null && H > g.value && (f.value = false, g.value = null);
      return;
    }
    const Q = RS(l), ie = X.getBoundingClientRect(), te = ie.top - Q.top, re = Q.bottom - ie.bottom, J = C.value, Se = z.value;
    J !== void 0 && te <= J ? (d.value = true, m.value = H - (J - te)) : (d.value = false, m.value = null), Se !== void 0 && re <= Se ? (f.value = true, g.value = H + Se - re) : (f.value = false, g.value = null);
  }
  return Qi(() => {
    A();
  }), Cn(() => {
    l && l.removeEventListener("scroll", O);
  }), { selfRef: L, affixed: s, mergedClsPrefix: i, mergedstyle: ze(() => {
    const X = {};
    return d.value && C.value !== void 0 && T.value !== void 0 && (X.top = `${T.value}px`), f.value && z.value !== void 0 && M.value !== void 0 && (X.bottom = `${M.value}px`), X;
  }) };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { ref: "selfRef", class: [`${r}-affix`, { [`${r}-affix--affixed`]: this.affixed, [`${r}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), ap = st({ name: "Add", render() {
  return F("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), zS = _a("attach", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), FS = _a("cancel", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), LS = st({ name: "Checkmark", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, F("g", { fill: "none" }, F("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), BS = st({ name: "ChevronDown", render() {
  return F("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), OS = st({ name: "ChevronLeft", render() {
  return F("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), $S = _a("clear", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), hb = _a("download", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), jS = st({ name: "Empty", render() {
  return F("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), F("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), fb = st({ name: "Eye", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), F("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), NS = st({ name: "EyeOff", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), F("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), F("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), F("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), F("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), VS = st({ name: "Remove", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), US = st({ name: "ResizeSmall", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, F("g", { fill: "none" }, F("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), GS = _a("retry", () => F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), F("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), qS = _a("rotateClockwise", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), F("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), WS = _a("rotateClockwise", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), F("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), ZS = _a("trash", () => F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), HS = _a("zoomIn", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), F("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), XS = _a("zoomOut", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), F("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), YS = ue("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [qe(">", [Re("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [qe("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), qe("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Re("placeholder", `
 display: flex;
 `), Re("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Ld({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), pg = st({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(r) {
  return oc("-base-clear", YS, Dt(r, "clsPrefix")), { handleMouseDown(i) {
    i.preventDefault();
  } };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-base-clear` }, F(Yf, null, { default: () => {
    var i, l;
    return this.show ? F("div", { key: "dismiss", class: `${r}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, Vn(this.$slots.icon, () => [F(Nr, { clsPrefix: r }, { default: () => F($S, null) })])) : F("div", { key: "icon", class: `${r}-base-clear__placeholder` }, (l = (i = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(i));
  } }));
} }), KS = st({ props: { onFocus: Function, onBlur: Function }, setup(r) {
  return () => F("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: r.onFocus, onBlur: r.onBlur });
} }), JS = ue("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Re("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [qe("+", [Re("description", `
 margin-top: 8px;
 `)])]), Re("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Re("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), QS = Object.assign(Object.assign({}, Yt.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), $d = st({ name: "Empty", props: QS, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedComponentPropsRef: d } = Tr(r), f = Yt("Empty", "-empty", JS, Jw, r, i), { localeRef: g } = Ja("Empty"), m = ze(() => {
    var M, z, L;
    return (M = r.description) !== null && M !== void 0 ? M : (L = (z = d == null ? void 0 : d.value) === null || z === void 0 ? void 0 : z.Empty) === null || L === void 0 ? void 0 : L.description;
  }), s = ze(() => {
    var M, z;
    return ((z = (M = d == null ? void 0 : d.value) === null || M === void 0 ? void 0 : M.Empty) === null || z === void 0 ? void 0 : z.renderIcon) || (() => F(jS, null));
  }), C = ze(() => {
    const { size: M } = r, { common: { cubicBezierEaseInOut: z }, self: { [jt("iconSize", M)]: L, [jt("fontSize", M)]: A, textColor: O, iconColor: U, extraTextColor: X } } = f.value;
    return { "--n-icon-size": L, "--n-font-size": A, "--n-bezier": z, "--n-text-color": O, "--n-icon-color": U, "--n-extra-text-color": X };
  }), T = l ? ci("empty", ze(() => {
    let M = "";
    const { size: z } = r;
    return M += z[0], M;
  }), C, r) : void 0;
  return { mergedClsPrefix: i, mergedRenderIcon: s, localizedDescription: ze(() => m.value || g.value.description), cssVars: l ? void 0 : C, themeClass: T == null ? void 0 : T.themeClass, onRender: T == null ? void 0 : T.onRender };
}, render() {
  const { $slots: r, mergedClsPrefix: i, onRender: l } = this;
  return l == null ? void 0 : l(), F("div", { class: [`${i}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? F("div", { class: `${i}-empty__icon` }, r.icon ? r.icon() : F(Nr, { clsPrefix: i }, { default: this.mergedRenderIcon })) : null, this.showDescription ? F("div", { class: `${i}-empty__description` }, r.default ? r.default() : this.localizedDescription) : null, r.extra ? F("div", { class: `${i}-empty__extra` }, r.extra()) : null);
} }), i_ = st({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: r, renderOptionRef: i, labelFieldRef: l, nodePropsRef: d } = fr(Fg);
  return { labelField: l, nodeProps: d, renderLabel: r, renderOption: i };
}, render() {
  const { clsPrefix: r, renderLabel: i, renderOption: l, nodeProps: d, tmNode: { rawNode: f } } = this, g = d == null ? void 0 : d(f), m = i ? i(f, false) : wl(f[this.labelField], f, false), s = F("div", Object.assign({}, g, { class: [`${r}-base-select-group-header`, g == null ? void 0 : g.class] }), m);
  return f.render ? f.render({ node: s, option: f }) : l ? l({ node: s, option: f, selected: false }) : s;
} });
function ek(r, i) {
  return F(Ao, { name: "fade-in-scale-up-transition" }, { default: () => r ? F(Nr, { clsPrefix: i, class: `${i}-base-select-option__check` }, { default: () => F(LS) }) : null });
}
const n_ = st({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(r) {
  const { valueRef: i, pendingTmNodeRef: l, multipleRef: d, valueSetRef: f, renderLabelRef: g, renderOptionRef: m, labelFieldRef: s, valueFieldRef: C, showCheckmarkRef: T, nodePropsRef: M, handleOptionClick: z, handleOptionMouseEnter: L } = fr(Fg), A = pi(() => {
    const { value: H } = l;
    return H ? r.tmNode.key === H.key : false;
  });
  function O(H) {
    const { tmNode: Q } = r;
    Q.disabled || z(H, Q);
  }
  function U(H) {
    const { tmNode: Q } = r;
    Q.disabled || L(H, Q);
  }
  function X(H) {
    const { tmNode: Q } = r, { value: ie } = A;
    Q.disabled || ie || L(H, Q);
  }
  return { multiple: d, isGrouped: pi(() => {
    const { tmNode: H } = r, { parent: Q } = H;
    return Q && Q.rawNode.type === "group";
  }), showCheckmark: T, nodeProps: M, isPending: A, isSelected: pi(() => {
    const { value: H } = i, { value: Q } = d;
    if (H === null) return false;
    const ie = r.tmNode.rawNode[C.value];
    if (Q) {
      const { value: te } = f;
      return te.has(ie);
    } else return H === ie;
  }), labelField: s, renderLabel: g, renderOption: m, handleMouseMove: X, handleMouseEnter: U, handleClick: O };
}, render() {
  const { clsPrefix: r, tmNode: { rawNode: i }, isSelected: l, isPending: d, isGrouped: f, showCheckmark: g, nodeProps: m, renderOption: s, renderLabel: C, handleClick: T, handleMouseEnter: M, handleMouseMove: z } = this, L = ek(l, r), A = C ? [C(i, l), g && L] : [wl(i[this.labelField], i, l), g && L], O = m == null ? void 0 : m(i), U = F("div", Object.assign({}, O, { class: [`${r}-base-select-option`, i.class, O == null ? void 0 : O.class, { [`${r}-base-select-option--disabled`]: i.disabled, [`${r}-base-select-option--selected`]: l, [`${r}-base-select-option--grouped`]: f, [`${r}-base-select-option--pending`]: d, [`${r}-base-select-option--show-checkmark`]: g }], style: [(O == null ? void 0 : O.style) || "", i.style || ""], onClick: Em([T, O == null ? void 0 : O.onClick]), onMouseenter: Em([M, O == null ? void 0 : O.onMouseenter]), onMousemove: Em([z, O == null ? void 0 : O.onMousemove]) }), F("div", { class: `${r}-base-select-option__content` }, A));
  return i.render ? i.render({ node: U, option: i, selected: l }) : s ? s({ node: U, option: i, selected: l }) : U;
} }), tk = ue("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [ue("scrollbar", `
 max-height: var(--n-height);
 `), ue("virtual-list", `
 max-height: var(--n-height);
 `), ue("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Re("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), ue("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), ue("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Re("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Re("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Re("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Re("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), ue("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), ue("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ue("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), qe("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), qe("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ue("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ue("pending", [qe("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ue("selected", `
 color: var(--n-option-text-color-active);
 `, [qe("&::before", `
 background-color: var(--n-option-color-active);
 `), Ue("pending", [qe("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 `, [ui("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ue("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Re("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [Kf({ enterScale: "0.5" })])])]), rk = st({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, Yt.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Rn("InternalSelectMenu", l, i), f = Yt("InternalSelectMenu", "-internal-select-menu", tk, Qw, r, Dt(r, "clsPrefix")), g = Ae(null), m = Ae(null), s = Ae(null), C = ze(() => r.treeMate.getFlattenedNodes()), T = ze(() => e2(C.value)), M = Ae(null);
  function z() {
    const { treeMate: nt } = r;
    let ut = null;
    const { value: Lt } = r;
    Lt === null ? ut = nt.getFirstAvailableNode() : (r.multiple ? ut = nt.getNode((Lt || [])[(Lt || []).length - 1]) : ut = nt.getNode(Lt), (!ut || ut.disabled) && (ut = nt.getFirstAvailableNode())), Ke(ut || null);
  }
  function L() {
    const { value: nt } = M;
    nt && !r.treeMate.getNode(nt.key) && (M.value = null);
  }
  let A;
  ar(() => r.show, (nt) => {
    nt ? A = ar(() => r.treeMate, () => {
      r.resetMenuOnOptionsChange ? (r.autoPending ? z() : L(), Nn(lt)) : L();
    }, { immediate: true }) : A == null ? void 0 : A();
  }, { immediate: true }), Cn(() => {
    A == null ? void 0 : A();
  });
  const O = ze(() => Ji(f.value.self[jt("optionHeight", r.size)])), U = ze(() => Ro(f.value.self[jt("padding", r.size)])), X = ze(() => r.multiple && Array.isArray(r.value) ? new Set(r.value) : /* @__PURE__ */ new Set()), H = ze(() => {
    const nt = C.value;
    return nt && nt.length === 0;
  });
  function Q(nt) {
    const { onToggle: ut } = r;
    ut && ut(nt);
  }
  function ie(nt) {
    const { onScroll: ut } = r;
    ut && ut(nt);
  }
  function te(nt) {
    var ut;
    (ut = s.value) === null || ut === void 0 || ut.sync(), ie(nt);
  }
  function re() {
    var nt;
    (nt = s.value) === null || nt === void 0 || nt.sync();
  }
  function J() {
    const { value: nt } = M;
    return nt || null;
  }
  function Se(nt, ut) {
    ut.disabled || Ke(ut, false);
  }
  function fe(nt, ut) {
    ut.disabled || Q(ut);
  }
  function oe(nt) {
    var ut;
    Tl(nt, "action") || (ut = r.onKeyup) === null || ut === void 0 || ut.call(r, nt);
  }
  function de(nt) {
    var ut;
    Tl(nt, "action") || (ut = r.onKeydown) === null || ut === void 0 || ut.call(r, nt);
  }
  function xe(nt) {
    var ut;
    (ut = r.onMousedown) === null || ut === void 0 || ut.call(r, nt), !r.focusable && nt.preventDefault();
  }
  function $e() {
    const { value: nt } = M;
    nt && Ke(nt.getNext({ loop: true }), true);
  }
  function Ve() {
    const { value: nt } = M;
    nt && Ke(nt.getPrev({ loop: true }), true);
  }
  function Ke(nt, ut = false) {
    M.value = nt, ut && lt();
  }
  function lt() {
    var nt, ut;
    const Lt = M.value;
    if (!Lt) return;
    const Ht = T.value(Lt.key);
    Ht !== null && (r.virtualScroll ? (nt = m.value) === null || nt === void 0 || nt.scrollTo({ index: Ht }) : (ut = s.value) === null || ut === void 0 || ut.scrollTo({ index: Ht, elSize: O.value }));
  }
  function vt(nt) {
    var ut, Lt;
    !((ut = g.value) === null || ut === void 0) && ut.contains(nt.target) && ((Lt = r.onFocus) === null || Lt === void 0 || Lt.call(r, nt));
  }
  function xt(nt) {
    var ut, Lt;
    !((ut = g.value) === null || ut === void 0) && ut.contains(nt.relatedTarget) || (Lt = r.onBlur) === null || Lt === void 0 || Lt.call(r, nt);
  }
  Jr(Fg, { handleOptionMouseEnter: Se, handleOptionClick: fe, valueSetRef: X, pendingTmNodeRef: M, nodePropsRef: Dt(r, "nodeProps"), showCheckmarkRef: Dt(r, "showCheckmark"), multipleRef: Dt(r, "multiple"), valueRef: Dt(r, "value"), renderLabelRef: Dt(r, "renderLabel"), renderOptionRef: Dt(r, "renderOption"), labelFieldRef: Dt(r, "labelField"), valueFieldRef: Dt(r, "valueField") }), Jr(t2, g), Qi(() => {
    const { value: nt } = s;
    nt && nt.sync();
  });
  const at = ze(() => {
    const { size: nt } = r, { common: { cubicBezierEaseInOut: ut }, self: { height: Lt, borderRadius: Ht, color: zt, groupHeaderTextColor: pr, actionDividerColor: Jt, optionTextColorPressed: tr, optionTextColor: wr, optionTextColorDisabled: Er, optionTextColorActive: rr, optionOpacityDisabled: sr, optionCheckColor: qt, actionTextColor: Dr, optionColorPending: Cr, optionColorActive: Ct, loadingColor: Ee, loadingSize: ot, optionColorActivePending: Le, [jt("optionFontSize", nt)]: Ye, [jt("optionHeight", nt)]: ft, [jt("optionPadding", nt)]: bt } } = f.value;
    return { "--n-height": Lt, "--n-action-divider-color": Jt, "--n-action-text-color": Dr, "--n-bezier": ut, "--n-border-radius": Ht, "--n-color": zt, "--n-option-font-size": Ye, "--n-group-header-text-color": pr, "--n-option-check-color": qt, "--n-option-color-pending": Cr, "--n-option-color-active": Ct, "--n-option-color-active-pending": Le, "--n-option-height": ft, "--n-option-opacity-disabled": sr, "--n-option-text-color": wr, "--n-option-text-color-active": rr, "--n-option-text-color-disabled": Er, "--n-option-text-color-pressed": tr, "--n-option-padding": bt, "--n-option-padding-left": Ro(bt, "left"), "--n-option-padding-right": Ro(bt, "right"), "--n-loading-color": Ee, "--n-loading-size": ot };
  }), { inlineThemeDisabled: et } = r, ht = et ? ci("internal-select-menu", ze(() => r.size[0]), at, r) : void 0, yt = { selfRef: g, next: $e, prev: Ve, getPendingTmNode: J };
  return cb(g, r.onResize), Object.assign({ mergedTheme: f, mergedClsPrefix: i, rtlEnabled: d, virtualListRef: m, scrollbarRef: s, itemSize: O, padding: U, flattenedNodes: C, empty: H, virtualListContainer() {
    const { value: nt } = m;
    return nt == null ? void 0 : nt.listElRef;
  }, virtualListContent() {
    const { value: nt } = m;
    return nt == null ? void 0 : nt.itemsElRef;
  }, doScroll: ie, handleFocusin: vt, handleFocusout: xt, handleKeyUp: oe, handleKeyDown: de, handleMouseDown: xe, handleVirtualListResize: re, handleVirtualListScroll: te, cssVars: et ? void 0 : at, themeClass: ht == null ? void 0 : ht.themeClass, onRender: ht == null ? void 0 : ht.onRender }, yt);
}, render() {
  const { $slots: r, virtualScroll: i, clsPrefix: l, mergedTheme: d, themeClass: f, onRender: g } = this;
  return g == null ? void 0 : g(), F("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, f, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, xi(r.header, (m) => m && F("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, m)), this.loading ? F("div", { class: `${l}-base-select-menu__loading` }, F(Jf, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? F("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, Vn(r.empty, () => [F($d, { theme: d.peers.Empty, themeOverrides: d.peerOverrides.Empty, size: this.size })])) : F(Yd, { ref: "scrollbarRef", theme: d.peers.Scrollbar, themeOverrides: d.peerOverrides.Scrollbar, scrollable: this.scrollable, container: i ? this.virtualListContainer : void 0, content: i ? this.virtualListContent : void 0, onScroll: i ? void 0 : this.doScroll }, { default: () => i ? F(V3, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: m }) => m.isGroup ? F(i_, { key: m.key, clsPrefix: l, tmNode: m }) : m.ignored ? null : F(n_, { clsPrefix: l, key: m.key, tmNode: m }) }) : F("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((m) => m.isGroup ? F(i_, { key: m.key, clsPrefix: l, tmNode: m }) : F(n_, { clsPrefix: l, key: m.key, tmNode: m }))) }), xi(r.action, (m) => m && [F("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, m), F(KS, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), pb = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, ik = ue("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ue("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Re("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Re("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Re("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Re("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ue("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Re("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Re("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ue("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ue("icon, avatar", [Ue("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ue("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ue("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [ui("disabled", [qe("&:hover", "background-color: var(--n-color-hover-checkable);", [ui("checked", "color: var(--n-text-color-hover-checkable);")]), qe("&:active", "background-color: var(--n-color-pressed-checkable);", [ui("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ue("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [ui("disabled", [qe("&:hover", "background-color: var(--n-color-checked-hover);"), qe("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), nk = Object.assign(Object.assign(Object.assign({}, Yt.props), pb), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), ok = An("n-tag"), Do = st({ name: "Tag", props: nk, slots: Object, setup(r) {
  const i = Ae(null), { mergedBorderedRef: l, mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Tr(r), m = Yt("Tag", "-tag", ik, r2, r, d);
  Jr(ok, { roundRef: Dt(r, "round") });
  function s() {
    if (!r.disabled && r.checkable) {
      const { checked: A, onCheckedChange: O, onUpdateChecked: U, "onUpdate:checked": X } = r;
      U && U(!A), X && X(!A), O && O(!A);
    }
  }
  function C(A) {
    if (r.triggerClickOnClose || A.stopPropagation(), !r.disabled) {
      const { onClose: O } = r;
      O && Ot(O, A);
    }
  }
  const T = { setTextContent(A) {
    const { value: O } = i;
    O && (O.textContent = A);
  } }, M = Rn("Tag", g, d), z = ze(() => {
    const { type: A, size: O, color: { color: U, textColor: X } = {} } = r, { common: { cubicBezierEaseInOut: H }, self: { padding: Q, closeMargin: ie, borderRadius: te, opacityDisabled: re, textColorCheckable: J, textColorHoverCheckable: Se, textColorPressedCheckable: fe, textColorChecked: oe, colorCheckable: de, colorHoverCheckable: xe, colorPressedCheckable: $e, colorChecked: Ve, colorCheckedHover: Ke, colorCheckedPressed: lt, closeBorderRadius: vt, fontWeightStrong: xt, [jt("colorBordered", A)]: at, [jt("closeSize", O)]: et, [jt("closeIconSize", O)]: ht, [jt("fontSize", O)]: yt, [jt("height", O)]: nt, [jt("color", A)]: ut, [jt("textColor", A)]: Lt, [jt("border", A)]: Ht, [jt("closeIconColor", A)]: zt, [jt("closeIconColorHover", A)]: pr, [jt("closeIconColorPressed", A)]: Jt, [jt("closeColorHover", A)]: tr, [jt("closeColorPressed", A)]: wr } } = m.value, Er = Ro(ie);
    return { "--n-font-weight-strong": xt, "--n-avatar-size-override": `calc(${nt} - 8px)`, "--n-bezier": H, "--n-border-radius": te, "--n-border": Ht, "--n-close-icon-size": ht, "--n-close-color-pressed": wr, "--n-close-color-hover": tr, "--n-close-border-radius": vt, "--n-close-icon-color": zt, "--n-close-icon-color-hover": pr, "--n-close-icon-color-pressed": Jt, "--n-close-icon-color-disabled": zt, "--n-close-margin-top": Er.top, "--n-close-margin-right": Er.right, "--n-close-margin-bottom": Er.bottom, "--n-close-margin-left": Er.left, "--n-close-size": et, "--n-color": U || (l.value ? at : ut), "--n-color-checkable": de, "--n-color-checked": Ve, "--n-color-checked-hover": Ke, "--n-color-checked-pressed": lt, "--n-color-hover-checkable": xe, "--n-color-pressed-checkable": $e, "--n-font-size": yt, "--n-height": nt, "--n-opacity-disabled": re, "--n-padding": Q, "--n-text-color": X || Lt, "--n-text-color-checkable": J, "--n-text-color-checked": oe, "--n-text-color-hover-checkable": Se, "--n-text-color-pressed-checkable": fe };
  }), L = f ? ci("tag", ze(() => {
    let A = "";
    const { type: O, size: U, color: { color: X, textColor: H } = {} } = r;
    return A += O[0], A += U[0], X && (A += `a${Vv(X)}`), H && (A += `b${Vv(H)}`), l.value && (A += "c"), A;
  }), z, r) : void 0;
  return Object.assign(Object.assign({}, T), { rtlEnabled: M, mergedClsPrefix: d, contentRef: i, mergedBordered: l, handleClick: s, handleCloseClick: C, cssVars: f ? void 0 : z, themeClass: L == null ? void 0 : L.themeClass, onRender: L == null ? void 0 : L.onRender });
}, render() {
  var r, i;
  const { mergedClsPrefix: l, rtlEnabled: d, closable: f, color: { borderColor: g } = {}, round: m, onRender: s, $slots: C } = this;
  s == null ? void 0 : s();
  const T = xi(C.avatar, (z) => z && F("div", { class: `${l}-tag__avatar` }, z)), M = xi(C.icon, (z) => z && F("div", { class: `${l}-tag__icon` }, z));
  return F("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: d, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: m, [`${l}-tag--avatar`]: T, [`${l}-tag--icon`]: M, [`${l}-tag--closable`]: f }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, M || T, F("span", { class: `${l}-tag__content`, ref: "contentRef" }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r)), !this.checkable && f ? F(Qf, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: m, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? F("div", { class: `${l}-tag__border`, style: { borderColor: g } }) : null);
} }), mb = st({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(r, { slots: i }) {
  return () => {
    const { clsPrefix: l } = r;
    return F(Jf, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: r.loading }, { default: () => r.showArrow ? F(pg, { clsPrefix: l, show: r.showClear, onClear: r.onClear }, { placeholder: () => F(Nr, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => Vn(i.default, () => [F(BS, null)]) }) }) : null });
  };
} }), ak = qe([ue("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [ue("base-loading", `
 color: var(--n-loading-color);
 `), ue("base-selection-tags", "min-height: var(--n-height);"), Re("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Re("state-border", `
 z-index: 1;
 border-color: #0000;
 `), ue("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Re("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), ue("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Re("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), ue("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Re("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), ue("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [ue("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Re("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Re("render-label", `
 color: var(--n-text-color);
 `)]), ui("disabled", [qe("&:hover", [Re("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ue("focus", [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ue("active", [Re("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), ue("base-selection-label", "background-color: var(--n-color-active);"), ue("base-selection-tags", "background-color: var(--n-color-active);")])]), Ue("disabled", "cursor: not-allowed;", [Re("arrow", `
 color: var(--n-arrow-color-disabled);
 `), ue("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [ue("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Re("render-label", `
 color: var(--n-text-color-disabled);
 `)]), ue("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), ue("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), ue("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Re("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Re("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((r) => Ue(`${r}-status`, [Re("state-border", `border: var(--n-border-${r});`), ui("disabled", [qe("&:hover", [Re("state-border", `
 box-shadow: var(--n-box-shadow-hover-${r});
 border: var(--n-border-hover-${r});
 `)]), Ue("active", [Re("state-border", `
 box-shadow: var(--n-box-shadow-active-${r});
 border: var(--n-border-active-${r});
 `), ue("base-selection-label", `background-color: var(--n-color-active-${r});`), ue("base-selection-tags", `background-color: var(--n-color-active-${r});`)]), Ue("focus", [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), ue("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), ue("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [qe("&:last-child", "padding-right: 0;"), ue("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Re("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), sk = st({ name: "InternalSelection", props: Object.assign(Object.assign({}, Yt.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Rn("InternalSelection", l, i), f = Ae(null), g = Ae(null), m = Ae(null), s = Ae(null), C = Ae(null), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(null), O = Ae(false), U = Ae(false), X = Ae(false), H = Yt("InternalSelection", "-internal-selection", ak, n2, r, Dt(r, "clsPrefix")), Q = ze(() => r.clearable && !r.disabled && (X.value || r.active)), ie = ze(() => r.selectedOption ? r.renderTag ? r.renderTag({ option: r.selectedOption, handleClose: () => {
  } }) : r.renderLabel ? r.renderLabel(r.selectedOption, true) : wl(r.selectedOption[r.labelField], r.selectedOption, true) : r.placeholder), te = ze(() => {
    const tt = r.selectedOption;
    if (tt) return tt[r.labelField];
  }), re = ze(() => r.multiple ? !!(Array.isArray(r.selectedOptions) && r.selectedOptions.length) : r.selectedOption !== null);
  function J() {
    var tt;
    const { value: mt } = f;
    if (mt) {
      const { value: Zt } = g;
      Zt && (Zt.style.width = `${mt.offsetWidth}px`, r.maxTagCount !== "responsive" && ((tt = L.value) === null || tt === void 0 || tt.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function Se() {
    const { value: tt } = A;
    tt && (tt.style.display = "none");
  }
  function fe() {
    const { value: tt } = A;
    tt && (tt.style.display = "inline-block");
  }
  ar(Dt(r, "active"), (tt) => {
    tt || Se();
  }), ar(Dt(r, "pattern"), () => {
    r.multiple && Nn(J);
  });
  function oe(tt) {
    const { onFocus: mt } = r;
    mt && mt(tt);
  }
  function de(tt) {
    const { onBlur: mt } = r;
    mt && mt(tt);
  }
  function xe(tt) {
    const { onDeleteOption: mt } = r;
    mt && mt(tt);
  }
  function $e(tt) {
    const { onClear: mt } = r;
    mt && mt(tt);
  }
  function Ve(tt) {
    const { onPatternInput: mt } = r;
    mt && mt(tt);
  }
  function Ke(tt) {
    var mt;
    (!tt.relatedTarget || !(!((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget))) && oe(tt);
  }
  function lt(tt) {
    var mt;
    !((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget) || de(tt);
  }
  function vt(tt) {
    $e(tt);
  }
  function xt() {
    X.value = true;
  }
  function at() {
    X.value = false;
  }
  function et(tt) {
    !r.active || !r.filterable || tt.target !== g.value && tt.preventDefault();
  }
  function ht(tt) {
    xe(tt);
  }
  const yt = Ae(false);
  function nt(tt) {
    if (tt.key === "Backspace" && !yt.value && !r.pattern.length) {
      const { selectedOptions: mt } = r;
      (mt == null ? void 0 : mt.length) && ht(mt[mt.length - 1]);
    }
  }
  let ut = null;
  function Lt(tt) {
    const { value: mt } = f;
    if (mt) {
      const Zt = tt.target.value;
      mt.textContent = Zt, J();
    }
    r.ignoreComposition && yt.value ? ut = tt : Ve(tt);
  }
  function Ht() {
    yt.value = true;
  }
  function zt() {
    yt.value = false, r.ignoreComposition && Ve(ut), ut = null;
  }
  function pr(tt) {
    var mt;
    U.value = true, (mt = r.onPatternFocus) === null || mt === void 0 || mt.call(r, tt);
  }
  function Jt(tt) {
    var mt;
    U.value = false, (mt = r.onPatternBlur) === null || mt === void 0 || mt.call(r, tt);
  }
  function tr() {
    var tt, mt;
    if (r.filterable) U.value = false, (tt = T.value) === null || tt === void 0 || tt.blur(), (mt = g.value) === null || mt === void 0 || mt.blur();
    else if (r.multiple) {
      const { value: Zt } = s;
      Zt == null ? void 0 : Zt.blur();
    } else {
      const { value: Zt } = C;
      Zt == null ? void 0 : Zt.blur();
    }
  }
  function wr() {
    var tt, mt, Zt;
    r.filterable ? (U.value = false, (tt = T.value) === null || tt === void 0 || tt.focus()) : r.multiple ? (mt = s.value) === null || mt === void 0 || mt.focus() : (Zt = C.value) === null || Zt === void 0 || Zt.focus();
  }
  function Er() {
    const { value: tt } = g;
    tt && (fe(), tt.focus());
  }
  function rr() {
    const { value: tt } = g;
    tt && tt.blur();
  }
  function sr(tt) {
    const { value: mt } = M;
    mt && mt.setTextContent(`+${tt}`);
  }
  function qt() {
    const { value: tt } = z;
    return tt;
  }
  function Dr() {
    return g.value;
  }
  let Cr = null;
  function Ct() {
    Cr !== null && window.clearTimeout(Cr);
  }
  function Ee() {
    r.active || (Ct(), Cr = window.setTimeout(() => {
      re.value && (O.value = true);
    }, 100));
  }
  function ot() {
    Ct();
  }
  function Le(tt) {
    tt || (Ct(), O.value = false);
  }
  ar(re, (tt) => {
    tt || (O.value = false);
  }), Qi(() => {
    vo(() => {
      const tt = T.value;
      tt && (r.disabled ? tt.removeAttribute("tabindex") : tt.tabIndex = U.value ? -1 : 0);
    });
  }), cb(m, r.onResize);
  const { inlineThemeDisabled: Ye } = r, ft = ze(() => {
    const { size: tt } = r, { common: { cubicBezierEaseInOut: mt }, self: { fontWeight: Zt, borderRadius: ii, color: wi, placeholderColor: Fe, textColor: Z, paddingSingle: Y, paddingMultiple: ne, caretColor: _e, colorDisabled: Te, textColorDisabled: De, placeholderColorDisabled: he, colorActive: ve, boxShadowFocus: je, boxShadowActive: it, boxShadowHover: Xe, border: wt, borderFocus: Pe, borderHover: $t, borderActive: Qt, arrowColor: Nt, arrowColorDisabled: ur, loadingColor: Br, colorActiveWarning: Qr, boxShadowFocusWarning: ei, boxShadowActiveWarning: ni, boxShadowHoverWarning: gr, borderWarning: yr, borderFocusWarning: Wr, borderHoverWarning: ge, borderActiveWarning: dt, colorActiveError: Bt, boxShadowFocusError: Rr, boxShadowActiveError: $r, boxShadowHoverError: gt, borderError: cr, borderFocusError: lr, borderHoverError: oi, borderActiveError: hn, clearColor: tn, clearColorHover: dr, clearColorPressed: Qo, clearSize: Un, arrowSize: ea, [jt("height", tt)]: Sn, [jt("fontSize", tt)]: bo } } = H.value, Zr = Ro(Y), Jn = Ro(ne);
    return { "--n-bezier": mt, "--n-border": wt, "--n-border-active": Qt, "--n-border-focus": Pe, "--n-border-hover": $t, "--n-border-radius": ii, "--n-box-shadow-active": it, "--n-box-shadow-focus": je, "--n-box-shadow-hover": Xe, "--n-caret-color": _e, "--n-color": wi, "--n-color-active": ve, "--n-color-disabled": Te, "--n-font-size": bo, "--n-height": Sn, "--n-padding-single-top": Zr.top, "--n-padding-multiple-top": Jn.top, "--n-padding-single-right": Zr.right, "--n-padding-multiple-right": Jn.right, "--n-padding-single-left": Zr.left, "--n-padding-multiple-left": Jn.left, "--n-padding-single-bottom": Zr.bottom, "--n-padding-multiple-bottom": Jn.bottom, "--n-placeholder-color": Fe, "--n-placeholder-color-disabled": he, "--n-text-color": Z, "--n-text-color-disabled": De, "--n-arrow-color": Nt, "--n-arrow-color-disabled": ur, "--n-loading-color": Br, "--n-color-active-warning": Qr, "--n-box-shadow-focus-warning": ei, "--n-box-shadow-active-warning": ni, "--n-box-shadow-hover-warning": gr, "--n-border-warning": yr, "--n-border-focus-warning": Wr, "--n-border-hover-warning": ge, "--n-border-active-warning": dt, "--n-color-active-error": Bt, "--n-box-shadow-focus-error": Rr, "--n-box-shadow-active-error": $r, "--n-box-shadow-hover-error": gt, "--n-border-error": cr, "--n-border-focus-error": lr, "--n-border-hover-error": oi, "--n-border-active-error": hn, "--n-clear-size": Un, "--n-clear-color": tn, "--n-clear-color-hover": dr, "--n-clear-color-pressed": Qo, "--n-arrow-size": ea, "--n-font-weight": Zt };
  }), bt = Ye ? ci("internal-selection", ze(() => r.size[0]), ft, r) : void 0;
  return { mergedTheme: H, mergedClearable: Q, mergedClsPrefix: i, rtlEnabled: d, patternInputFocused: U, filterablePlaceholder: ie, label: te, selected: re, showTagsPanel: O, isComposing: yt, counterRef: M, counterWrapperRef: z, patternInputMirrorRef: f, patternInputRef: g, selfRef: m, multipleElRef: s, singleElRef: C, patternInputWrapperRef: T, overflowRef: L, inputTagElRef: A, handleMouseDown: et, handleFocusin: Ke, handleClear: vt, handleMouseEnter: xt, handleMouseLeave: at, handleDeleteOption: ht, handlePatternKeyDown: nt, handlePatternInputInput: Lt, handlePatternInputBlur: Jt, handlePatternInputFocus: pr, handleMouseEnterCounter: Ee, handleMouseLeaveCounter: ot, handleFocusout: lt, handleCompositionEnd: zt, handleCompositionStart: Ht, onPopoverUpdateShow: Le, focus: wr, focusInput: Er, blur: tr, blurInput: rr, updateCounter: sr, getCounter: qt, getTail: Dr, renderLabel: r.renderLabel, cssVars: Ye ? void 0 : ft, themeClass: bt == null ? void 0 : bt.themeClass, onRender: bt == null ? void 0 : bt.onRender };
}, render() {
  const { status: r, multiple: i, size: l, disabled: d, filterable: f, maxTagCount: g, bordered: m, clsPrefix: s, ellipsisTagPopoverProps: C, onRender: T, renderTag: M, renderLabel: z } = this;
  T == null ? void 0 : T();
  const L = g === "responsive", A = typeof g == "number", O = L || A, U = F(i2, null, { default: () => F(mb, { clsPrefix: s, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var H, Q;
    return (Q = (H = this.$slots).arrow) === null || Q === void 0 ? void 0 : Q.call(H);
  } }) });
  let X;
  if (i) {
    const { labelField: H } = this, Q = (Ve) => F("div", { class: `${s}-base-selection-tag-wrapper`, key: Ve.value }, M ? M({ option: Ve, handleClose: () => {
      this.handleDeleteOption(Ve);
    } }) : F(Do, { size: l, closable: !Ve.disabled, disabled: d, onClose: () => {
      this.handleDeleteOption(Ve);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => z ? z(Ve, true) : wl(Ve[H], Ve, true) })), ie = () => (A ? this.selectedOptions.slice(0, g) : this.selectedOptions).map(Q), te = f ? F("div", { class: `${s}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, F("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: d, value: this.pattern, autofocus: this.autofocus, class: `${s}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), F("span", { ref: "patternInputMirrorRef", class: `${s}-base-selection-input-tag__mirror` }, this.pattern)) : null, re = L ? () => F("div", { class: `${s}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, F(Do, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: d })) : void 0;
    let J;
    if (A) {
      const Ve = this.selectedOptions.length - g;
      Ve > 0 && (J = F("div", { class: `${s}-base-selection-tag-wrapper`, key: "__counter__" }, F(Do, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: d }, { default: () => `+${Ve}` })));
    }
    const Se = L ? f ? F(Uv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re, tail: () => te }) : F(Uv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re }) : A && J ? ie().concat(J) : ie(), fe = O ? () => F("div", { class: `${s}-base-selection-popover` }, L ? ie() : this.selectedOptions.map(Q)) : void 0, oe = O ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, C) : null, xe = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay` }, F("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)) : null, $e = f ? F("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-tags` }, Se, L ? null : te, U) : F("div", { ref: "multipleElRef", class: `${s}-base-selection-tags`, tabindex: d ? void 0 : 0 }, Se, U);
    X = F(qr, null, O ? F(Lg, Object.assign({}, oe, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => $e, default: fe }) : $e, xe);
  } else if (f) {
    const H = this.pattern || this.isComposing, Q = this.active ? !H : !this.selected, ie = this.active ? false : this.selected;
    X = F("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-label`, title: this.patternInputFocused ? void 0 : fg(this.label) }, F("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${s}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: d, disabled: d, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), ie ? F("div", { class: `${s}-base-selection-label__render-label ${s}-base-selection-overlay`, key: "input" }, F("div", { class: `${s}-base-selection-overlay__wrapper` }, M ? M({ option: this.selectedOption, handleClose: () => {
    } }) : z ? z(this.selectedOption, true) : wl(this.label, this.selectedOption, true))) : null, Q ? F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, F("div", { class: `${s}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, U);
  } else X = F("div", { ref: "singleElRef", class: `${s}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? F("div", { class: `${s}-base-selection-input`, title: fg(this.label), key: "input" }, F("div", { class: `${s}-base-selection-input__content` }, M ? M({ option: this.selectedOption, handleClose: () => {
  } }) : z ? z(this.selectedOption, true) : wl(this.label, this.selectedOption, true))) : F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, F("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)), U);
  return F("div", { ref: "selfRef", class: [`${s}-base-selection`, this.rtlEnabled && `${s}-base-selection--rtl`, this.themeClass, r && `${s}-base-selection--${r}-status`, { [`${s}-base-selection--active`]: this.active, [`${s}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${s}-base-selection--disabled`]: this.disabled, [`${s}-base-selection--multiple`]: this.multiple, [`${s}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, X, m ? F("div", { class: `${s}-base-selection__border` }) : null, m ? F("div", { class: `${s}-base-selection__state-border` }) : null);
} }), lk = ue("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [Re("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), Ue("closable", [ue("alert-body", [Re("title", `
 padding-right: 24px;
 `)])]), Re("icon", { color: "var(--n-icon-color)" }), ue("alert-body", { padding: "var(--n-padding)" }, [Re("title", { color: "var(--n-title-text-color)" }), Re("content", { color: "var(--n-content-text-color)" })]), Bf({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), Re("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), Re("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), Ue("show-icon", [ue("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), Ue("right-adjust", [ue("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), ue("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [Re("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [qe("& +", [Re("content", { marginTop: "9px" })])]), Re("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), Re("icon", { transition: "color .3s var(--n-bezier)" })]), uk = Object.assign(Object.assign({}, Yt.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), ck = st({ name: "Alert", inheritAttrs: false, props: uk, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Yt("Alert", "-alert", lk, o2, r, i), m = Rn("Alert", f, i), s = ze(() => {
    const { common: { cubicBezierEaseInOut: A }, self: O } = g.value, { fontSize: U, borderRadius: X, titleFontWeight: H, lineHeight: Q, iconSize: ie, iconMargin: te, iconMarginRtl: re, closeIconSize: J, closeBorderRadius: Se, closeSize: fe, closeMargin: oe, closeMarginRtl: de, padding: xe } = O, { type: $e } = r, { left: Ve, right: Ke } = Ro(te);
    return { "--n-bezier": A, "--n-color": O[jt("color", $e)], "--n-close-icon-size": J, "--n-close-border-radius": Se, "--n-close-color-hover": O[jt("closeColorHover", $e)], "--n-close-color-pressed": O[jt("closeColorPressed", $e)], "--n-close-icon-color": O[jt("closeIconColor", $e)], "--n-close-icon-color-hover": O[jt("closeIconColorHover", $e)], "--n-close-icon-color-pressed": O[jt("closeIconColorPressed", $e)], "--n-icon-color": O[jt("iconColor", $e)], "--n-border": O[jt("border", $e)], "--n-title-text-color": O[jt("titleTextColor", $e)], "--n-content-text-color": O[jt("contentTextColor", $e)], "--n-line-height": Q, "--n-border-radius": X, "--n-font-size": U, "--n-title-font-weight": H, "--n-icon-size": ie, "--n-icon-margin": te, "--n-icon-margin-rtl": re, "--n-close-size": fe, "--n-close-margin": oe, "--n-close-margin-rtl": de, "--n-padding": xe, "--n-icon-margin-left": Ve, "--n-icon-margin-right": Ke };
  }), C = d ? ci("alert", ze(() => r.type[0]), s, r) : void 0, T = Ae(true), M = () => {
    const { onAfterLeave: A, onAfterHide: O } = r;
    A && A(), O && O();
  };
  return { rtlEnabled: m, mergedClsPrefix: i, mergedBordered: l, visible: T, handleCloseClick: () => {
    var A;
    Promise.resolve((A = r.onClose) === null || A === void 0 ? void 0 : A.call(r)).then((O) => {
      O !== false && (T.value = false);
    });
  }, handleAfterLeave: () => {
    M();
  }, mergedTheme: g, cssVars: d ? void 0 : s, themeClass: C == null ? void 0 : C.themeClass, onRender: C == null ? void 0 : C.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F(ep, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: i, $slots: l } = this, d = { class: [`${i}-alert`, this.themeClass, this.closable && `${i}-alert--closable`, this.showIcon && `${i}-alert--show-icon`, !this.title && this.closable && `${i}-alert--right-adjust`, this.rtlEnabled && `${i}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? F("div", Object.assign({}, Ya(this.$attrs, d)), this.closable && F(Qf, { clsPrefix: i, class: `${i}-alert__close`, onClick: this.handleCloseClick }), this.bordered && F("div", { class: `${i}-alert__border` }), this.showIcon && F("div", { class: `${i}-alert__icon`, "aria-hidden": "true" }, Vn(l.icon, () => [F(Nr, { clsPrefix: i }, { default: () => {
      switch (this.type) {
        case "success":
          return F($g, null);
        case "info":
          return F(Og, null);
        case "warning":
          return F(tp, null);
        case "error":
          return F(Bg, null);
        default:
          return null;
      }
    } })])), F("div", { class: [`${i}-alert-body`, this.mergedBordered && `${i}-alert-body--bordered`] }, xi(l.header, (f) => {
      const g = f || this.title;
      return g ? F("div", { class: `${i}-alert-body__title` }, g) : null;
    }), l.default && F("div", { class: `${i}-alert-body__content` }, l))) : null;
  } });
} }), Rf = An("n-anchor"), dk = { title: String, href: String }, Af = st({ name: "AnchorLink", props: dk, slots: Object, setup(r, { slots: i }) {
  const l = Ae(null), d = fr(Rf), f = Dt(r, "href"), g = pi(() => f.value && f.value === d.activeHref.value);
  B3(Rf, "collectedLinkHrefs", f), O3(Rf, "titleEls", () => l.value), ar(g, (s) => {
    s && l.value && d.updateBarPosition(l.value);
  });
  function m() {
    r.href !== void 0 && d.setActiveHref(r.href);
  }
  return () => {
    var s;
    const { value: C } = d.mergedClsPrefix;
    return F("div", { class: [`${C}-anchor-link`, g.value && `${C}-anchor-link--active`] }, F("a", { ref: l, class: [`${C}-anchor-link__title`], href: r.href, title: fg(r.title), onClick: m }, { default: () => Vn(i.title, () => [r.title]) }), (s = i.default) === null || s === void 0 ? void 0 : s.call(i));
  };
} });
function hk(r, i) {
  const { top: l, height: d } = r.getBoundingClientRect(), f = i instanceof HTMLElement ? i.getBoundingClientRect().top : 0;
  return { top: l - f, height: d };
}
const Gg = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, fk = Fd(Gg), pk = st({ name: "BaseAnchor", props: Object.assign(Object.assign({}, Gg), { mergedClsPrefix: { type: String, required: true } }), setup(r) {
  const i = [], l = [], d = Ae(null), f = Ae(null), g = Ae(null), m = Ae(null);
  let s = false;
  const C = ze(() => r.type === "block"), T = ze(() => !C.value && r.showRail);
  function M() {
    const { value: Q } = g, { value: ie } = f;
    Q && (Q.style.transition = "none"), ie && (ie.style.transition = "none"), l && l.forEach((te) => {
      te.style.transition = "none";
    }), Nn(() => {
      const { value: te } = g, { value: re } = f;
      te && (te.offsetWidth, te.style.transition = ""), re && (re.offsetWidth, re.style.transition = ""), l && l.forEach((J) => {
        J.offsetWidth, J.style.transition = "";
      });
    });
  }
  function z(Q, ie = true) {
    const { value: te } = g, { value: re } = f, { value: J } = m;
    if (!J || !te) return;
    ie || (te.style.transition = "none", re && (re.style.transition = "none"));
    const { offsetHeight: Se, offsetWidth: fe } = Q, { top: oe, left: de } = Q.getBoundingClientRect(), { top: xe, left: $e } = J.getBoundingClientRect(), Ve = oe - xe, Ke = de - $e;
    te.style.top = `${Ve}px`, te.style.height = `${Se}px`, re && (re.style.top = `${Ve}px`, re.style.height = `${Se}px`, re.style.maxWidth = `${fe + Ke}px`), te.offsetHeight, re && re.offsetHeight, ie || (te.style.transition = "", re && (re.style.transition = ""));
  }
  let L, A = false, O = false;
  const U = () => {
    if (O) A = true;
    else {
      if (s) return;
      H(true), O = true, clearTimeout(L), L = setTimeout(() => {
        O = false, A && (A = false, U());
      }, 128);
    }
  };
  function X(Q, ie = true) {
    const te = /^#([^#]+)$/.exec(Q);
    if (!te) return;
    const re = document.getElementById(te[1]);
    re && (s = true, d.value = Q, re.scrollIntoView(), ie || M(), A = false, setTimeout(() => {
      s = false;
    }, 0));
  }
  function H(Q = true) {
    var ie;
    const te = [], re = sb((ie = r.offsetTarget) !== null && ie !== void 0 ? ie : document);
    i.forEach((de) => {
      const xe = /#([^#]+)$/.exec(de);
      if (!xe) return;
      const $e = document.getElementById(xe[1]);
      if ($e && re) {
        const { top: Ve, height: Ke } = hk($e, re);
        te.push({ top: Ve, height: Ke, href: de });
      }
    }), te.sort((de, xe) => de.top > xe.top ? 1 : (de.top === xe.top && de.height < xe.height, -1));
    const J = d.value, { bound: Se, ignoreGap: fe } = r, oe = te.reduce((de, xe) => xe.top + xe.height < 0 ? fe ? xe : de : xe.top <= Se ? de === null ? xe : xe.top === de.top ? xe.href === J ? xe : de : xe.top > de.top ? xe : de : de, null);
    Q || M(), oe ? d.value = oe.href : d.value = null;
  }
  return Jr(Rf, { activeHref: d, mergedClsPrefix: Dt(r, "mergedClsPrefix"), updateBarPosition: z, setActiveHref: X, collectedLinkHrefs: i, titleEls: l }), Qi(() => {
    document.addEventListener("scroll", U, true), X(window.location.hash), H(false);
  }), ky(() => {
    X(window.location.hash), H(false);
  }), Cn(() => {
    clearTimeout(L), document.removeEventListener("scroll", U, true);
  }), ar(d, (Q) => {
    if (Q === null) {
      const { value: ie } = f;
      ie && !C.value && (ie.style.maxWidth = "0");
    }
  }), { selfRef: m, barRef: g, slotRef: f, setActiveHref: X, activeHref: d, isBlockType: C, mergedShowRail: T };
}, render() {
  var r;
  const { mergedClsPrefix: i, mergedShowRail: l, isBlockType: d, $slots: f } = this, g = F("div", { class: [`${i}-anchor`, d && `${i}-anchor--block`, l && `${i}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? F("div", { ref: "slotRef", class: `${i}-anchor-link-background` }) : null, l ? F("div", { class: `${i}-anchor-rail` }, F("div", { ref: "barRef", class: [`${i}-anchor-rail__bar`, this.activeHref !== null && `${i}-anchor-rail__bar--active`] })) : null, (r = f.default) === null || r === void 0 ? void 0 : r.call(f));
  return this.internalScrollable ? F(Yd, null, { default: () => g }) : g;
} }), mk = ue("anchor", `
 position: relative;
`, [ui("block", `
 padding-left: var(--n-rail-width);
 `, [ue("anchor-link", [qe("+, >", [ue("anchor-link", `
 margin-top: .5em;
 `)])]), ue("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), ui("show-rail", [qe(">", [ue("anchor-link", "padding-left: 0;")])])]), Ue("block", [ue("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ue("active", `
 background-color: var(--n-link-color);
 `)])]), ue("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Re("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ue("active", { backgroundColor: "var(--n-rail-color-active)" })])]), ue("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ue("active", [qe(">", [Re("title", `
 color: var(--n-link-text-color-active);
 `)])]), Re("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [qe("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), qe("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), gk = Object.assign(Object.assign(Object.assign(Object.assign({}, Yt.props), { affix: Boolean }), Ug), Gg), gb = st({ name: "Anchor", props: gk, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(r), f = Yt("Anchor", "-anchor", mk, a2, r, l), g = Ae(null), m = ze(() => {
    const { self: { railColor: C, linkColor: T, railColorActive: M, linkTextColor: z, linkTextColorHover: L, linkTextColorPressed: A, linkTextColorActive: O, linkFontSize: U, railWidth: X, linkPadding: H, borderRadius: Q }, common: { cubicBezierEaseInOut: ie } } = f.value;
    return { "--n-link-border-radius": Q, "--n-link-color": T, "--n-link-font-size": U, "--n-link-text-color": z, "--n-link-text-color-hover": L, "--n-link-text-color-active": O, "--n-link-text-color-pressed": A, "--n-link-padding": H, "--n-bezier": ie, "--n-rail-color": C, "--n-rail-color-active": M, "--n-rail-width": X };
  }), s = d ? ci("anchor", void 0, m, r) : void 0;
  return { scrollTo(C) {
    var T;
    (T = g.value) === null || T === void 0 || T.setActiveHref(C);
  }, renderAnchor: () => (s == null ? void 0 : s.onRender(), F(pk, Object.assign({ ref: g, style: d ? void 0 : m.value, class: s == null ? void 0 : s.themeClass.value }, ng(r, fk), { mergedClsPrefix: l.value }), i)) };
}, render() {
  return this.affix ? F(DS, Object.assign({}, ng(this, AS)), { default: this.renderAnchor }) : this.renderAnchor();
} }), vb = An("n-input"), vk = ue("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Re("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Re("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Re("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [qe("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), qe("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), qe("&:-webkit-autofill ~", [Re("placeholder", "display: none;")])]), Ue("round", [ui("textarea", "border-radius: calc(var(--n-height) / 2);")]), Re("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [qe("span", `
 width: 100%;
 display: inline-block;
 `)]), Ue("textarea", [Re("placeholder", "overflow: visible;")]), ui("autosize", "width: 100%;"), Ue("autosize", [Re("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), ue("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Re("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Re("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [qe("&[type=password]::-ms-reveal", "display: none;"), qe("+", [Re("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), ui("textarea", [Re("placeholder", "white-space: nowrap;")]), Re("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ue("textarea", "width: 100%;", [ue("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ue("resizable", [ue("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Re("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Re("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ue("pair", [Re("input-el, placeholder", "text-align: center;"), Re("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [ue("icon", `
 color: var(--n-icon-color);
 `), ue("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Re("border", "border: var(--n-border-disabled);"), Re("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Re("placeholder", "color: var(--n-placeholder-color-disabled);"), Re("separator", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), ue("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Re("suffix, prefix", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), ui("disabled", [Re("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [qe("&:hover", `
 color: var(--n-icon-color-hover);
 `), qe("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), qe("&:hover", [Re("state-border", "border: var(--n-border-hover);")]), Ue("focus", "background-color: var(--n-color-focus);", [Re("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Re("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Re("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Re("prefix", "margin-right: 4px;"), Re("suffix", `
 margin-left: 4px;
 `), Re("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [ue("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), ue("base-clear", `
 font-size: var(--n-icon-size);
 `, [Re("placeholder", [ue("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), qe(">", [ue("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), ue("base-icon", `
 font-size: var(--n-icon-size);
 `)]), ue("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((r) => Ue(`${r}-status`, [ui("disabled", [ue("base-loading", `
 color: var(--n-loading-color-${r})
 `), Re("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${r});
 `), Re("state-border", `
 border: var(--n-border-${r});
 `), qe("&:hover", [Re("state-border", `
 border: var(--n-border-hover-${r});
 `)]), qe("&:focus", `
 background-color: var(--n-color-focus-${r});
 `, [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)]), Ue("focus", `
 background-color: var(--n-color-focus-${r});
 `, [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), _k = ue("input", [Ue("disabled", [Re("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function yk(r) {
  let i = 0;
  for (const l of r) i++;
  return i;
}
function mf(r) {
  return r === "" || r == null;
}
function bk(r) {
  const i = Ae(null);
  function l() {
    const { value: g } = r;
    if (!(g == null ? void 0 : g.focus)) {
      f();
      return;
    }
    const { selectionStart: m, selectionEnd: s, value: C } = g;
    if (m == null || s == null) {
      f();
      return;
    }
    i.value = { start: m, end: s, beforeText: C.slice(0, m), afterText: C.slice(s) };
  }
  function d() {
    var g;
    const { value: m } = i, { value: s } = r;
    if (!m || !s) return;
    const { value: C } = s, { start: T, beforeText: M, afterText: z } = m;
    let L = C.length;
    if (C.endsWith(z)) L = C.length - z.length;
    else if (C.startsWith(M)) L = M.length;
    else {
      const A = M[T - 1], O = C.indexOf(A, T - 1);
      O !== -1 && (L = O + 1);
    }
    (g = s.setSelectionRange) === null || g === void 0 || g.call(s, L, L);
  }
  function f() {
    i.value = null;
  }
  return ar(r, f), { recordCursor: l, restoreCursor: d };
}
const o_ = st({ name: "InputWordCount", setup(r, { slots: i }) {
  const { mergedValueRef: l, maxlengthRef: d, mergedClsPrefixRef: f, countGraphemesRef: g } = fr(vb), m = ze(() => {
    const { value: s } = l;
    return s === null || Array.isArray(s) ? 0 : (g.value || yk)(s);
  });
  return () => {
    const { value: s } = d, { value: C } = l;
    return F("span", { class: `${f.value}-input-word-count` }, og(i.default, { value: C === null || Array.isArray(C) ? "" : C }, () => [s === void 0 ? m.value : `${m.value} / ${s}`]));
  };
} }), xk = Object.assign(Object.assign({}, Yt.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), mo = st({ name: "Input", props: xk, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Yt("Input", "-input", vk, s2, r, i);
  l2 && oc("-input-safari", _k, i);
  const m = Ae(null), s = Ae(null), C = Ae(null), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = bk(L), O = Ae(null), { localeRef: U } = Ja("Input"), X = Ae(r.defaultValue), H = Dt(r, "value"), Q = Zi(H, X), ie = ya(r), { mergedSizeRef: te, mergedDisabledRef: re, mergedStatusRef: J } = ie, Se = Ae(false), fe = Ae(false), oe = Ae(false), de = Ae(false);
  let xe = null;
  const $e = ze(() => {
    const { placeholder: ge, pair: dt } = r;
    return dt ? Array.isArray(ge) ? ge : ge === void 0 ? ["", ""] : [ge, ge] : ge === void 0 ? [U.value.placeholder] : [ge];
  }), Ve = ze(() => {
    const { value: ge } = oe, { value: dt } = Q, { value: Bt } = $e;
    return !ge && (mf(dt) || Array.isArray(dt) && mf(dt[0])) && Bt[0];
  }), Ke = ze(() => {
    const { value: ge } = oe, { value: dt } = Q, { value: Bt } = $e;
    return !ge && Bt[1] && (mf(dt) || Array.isArray(dt) && mf(dt[1]));
  }), lt = pi(() => r.internalForceFocus || Se.value), vt = pi(() => {
    if (re.value || r.readonly || !r.clearable || !lt.value && !fe.value) return false;
    const { value: ge } = Q, { value: dt } = lt;
    return r.pair ? !!(Array.isArray(ge) && (ge[0] || ge[1])) && (fe.value || dt) : !!ge && (fe.value || dt);
  }), xt = ze(() => {
    const { showPasswordOn: ge } = r;
    if (ge) return ge;
    if (r.showPasswordToggle) return "click";
  }), at = Ae(false), et = ze(() => {
    const { textDecoration: ge } = r;
    return ge ? Array.isArray(ge) ? ge.map((dt) => ({ textDecoration: dt })) : [{ textDecoration: ge }] : ["", ""];
  }), ht = Ae(void 0), yt = () => {
    var ge, dt;
    if (r.type === "textarea") {
      const { autosize: Bt } = r;
      if (Bt && (ht.value = (dt = (ge = O.value) === null || ge === void 0 ? void 0 : ge.$el) === null || dt === void 0 ? void 0 : dt.offsetWidth), !s.value || typeof Bt == "boolean") return;
      const { paddingTop: Rr, paddingBottom: $r, lineHeight: gt } = window.getComputedStyle(s.value), cr = Number(Rr.slice(0, -2)), lr = Number($r.slice(0, -2)), oi = Number(gt.slice(0, -2)), { value: hn } = C;
      if (!hn) return;
      if (Bt.minRows) {
        const tn = Math.max(Bt.minRows, 1), dr = `${cr + lr + oi * tn}px`;
        hn.style.minHeight = dr;
      }
      if (Bt.maxRows) {
        const tn = `${cr + lr + oi * Bt.maxRows}px`;
        hn.style.maxHeight = tn;
      }
    }
  }, nt = ze(() => {
    const { maxlength: ge } = r;
    return ge === void 0 ? void 0 : Number(ge);
  });
  Qi(() => {
    const { value: ge } = Q;
    Array.isArray(ge) || Qt(ge);
  });
  const ut = Xd().proxy;
  function Lt(ge, dt) {
    const { onUpdateValue: Bt, "onUpdate:value": Rr, onInput: $r } = r, { nTriggerFormInput: gt } = ie;
    Bt && Ot(Bt, ge, dt), Rr && Ot(Rr, ge, dt), $r && Ot($r, ge, dt), X.value = ge, gt();
  }
  function Ht(ge, dt) {
    const { onChange: Bt } = r, { nTriggerFormChange: Rr } = ie;
    Bt && Ot(Bt, ge, dt), X.value = ge, Rr();
  }
  function zt(ge) {
    const { onBlur: dt } = r, { nTriggerFormBlur: Bt } = ie;
    dt && Ot(dt, ge), Bt();
  }
  function pr(ge) {
    const { onFocus: dt } = r, { nTriggerFormFocus: Bt } = ie;
    dt && Ot(dt, ge), Bt();
  }
  function Jt(ge) {
    const { onClear: dt } = r;
    dt && Ot(dt, ge);
  }
  function tr(ge) {
    const { onInputBlur: dt } = r;
    dt && Ot(dt, ge);
  }
  function wr(ge) {
    const { onInputFocus: dt } = r;
    dt && Ot(dt, ge);
  }
  function Er() {
    const { onDeactivate: ge } = r;
    ge && Ot(ge);
  }
  function rr() {
    const { onActivate: ge } = r;
    ge && Ot(ge);
  }
  function sr(ge) {
    const { onClick: dt } = r;
    dt && Ot(dt, ge);
  }
  function qt(ge) {
    const { onWrapperFocus: dt } = r;
    dt && Ot(dt, ge);
  }
  function Dr(ge) {
    const { onWrapperBlur: dt } = r;
    dt && Ot(dt, ge);
  }
  function Cr() {
    oe.value = true;
  }
  function Ct(ge) {
    oe.value = false, ge.target === z.value ? Ee(ge, 1) : Ee(ge, 0);
  }
  function Ee(ge, dt = 0, Bt = "input") {
    const Rr = ge.target.value;
    if (Qt(Rr), ge instanceof InputEvent && !ge.isComposing && (oe.value = false), r.type === "textarea") {
      const { value: gt } = O;
      gt && gt.syncUnifiedContainer();
    }
    if (xe = Rr, oe.value) return;
    A.recordCursor();
    const $r = ot(Rr);
    if ($r) if (!r.pair) Bt === "input" ? Lt(Rr, { source: dt }) : Ht(Rr, { source: dt });
    else {
      let { value: gt } = Q;
      Array.isArray(gt) ? gt = [gt[0], gt[1]] : gt = ["", ""], gt[dt] = Rr, Bt === "input" ? Lt(gt, { source: dt }) : Ht(gt, { source: dt });
    }
    ut.$forceUpdate(), $r || Nn(A.restoreCursor);
  }
  function ot(ge) {
    const { countGraphemes: dt, maxlength: Bt, minlength: Rr } = r;
    if (dt) {
      let gt;
      if (Bt !== void 0 && (gt === void 0 && (gt = dt(ge)), gt > Number(Bt)) || Rr !== void 0 && (gt === void 0 && (gt = dt(ge)), gt < Number(Bt))) return false;
    }
    const { allowInput: $r } = r;
    return typeof $r == "function" ? $r(ge) : true;
  }
  function Le(ge) {
    tr(ge), ge.relatedTarget === m.value && Er(), ge.relatedTarget !== null && (ge.relatedTarget === M.value || ge.relatedTarget === z.value || ge.relatedTarget === s.value) || (de.value = false), tt(ge, "blur"), L.value = null;
  }
  function Ye(ge, dt) {
    wr(ge), Se.value = true, de.value = true, rr(), tt(ge, "focus"), dt === 0 ? L.value = M.value : dt === 1 ? L.value = z.value : dt === 2 && (L.value = s.value);
  }
  function ft(ge) {
    r.passivelyActivated && (Dr(ge), tt(ge, "blur"));
  }
  function bt(ge) {
    r.passivelyActivated && (Se.value = true, qt(ge), tt(ge, "focus"));
  }
  function tt(ge, dt) {
    ge.relatedTarget !== null && (ge.relatedTarget === M.value || ge.relatedTarget === z.value || ge.relatedTarget === s.value || ge.relatedTarget === m.value) || (dt === "focus" ? (pr(ge), Se.value = true) : dt === "blur" && (zt(ge), Se.value = false));
  }
  function mt(ge, dt) {
    Ee(ge, dt, "change");
  }
  function Zt(ge) {
    sr(ge);
  }
  function ii(ge) {
    Jt(ge), wi();
  }
  function wi() {
    r.pair ? (Lt(["", ""], { source: "clear" }), Ht(["", ""], { source: "clear" })) : (Lt("", { source: "clear" }), Ht("", { source: "clear" }));
  }
  function Fe(ge) {
    const { onMousedown: dt } = r;
    dt && dt(ge);
    const { tagName: Bt } = ge.target;
    if (Bt !== "INPUT" && Bt !== "TEXTAREA") {
      if (r.resizable) {
        const { value: Rr } = m;
        if (Rr) {
          const { left: $r, top: gt, width: cr, height: lr } = Rr.getBoundingClientRect(), oi = 14;
          if ($r + cr - oi < ge.clientX && ge.clientX < $r + cr && gt + lr - oi < ge.clientY && ge.clientY < gt + lr) return;
        }
      }
      ge.preventDefault(), Se.value || je();
    }
  }
  function Z() {
    var ge;
    fe.value = true, r.type === "textarea" && ((ge = O.value) === null || ge === void 0 || ge.handleMouseEnterWrapper());
  }
  function Y() {
    var ge;
    fe.value = false, r.type === "textarea" && ((ge = O.value) === null || ge === void 0 || ge.handleMouseLeaveWrapper());
  }
  function ne() {
    re.value || xt.value === "click" && (at.value = !at.value);
  }
  function _e(ge) {
    if (re.value) return;
    ge.preventDefault();
    const dt = (Rr) => {
      Rr.preventDefault(), Hn("mouseup", document, dt);
    };
    if (En("mouseup", document, dt), xt.value !== "mousedown") return;
    at.value = true;
    const Bt = () => {
      at.value = false, Hn("mouseup", document, Bt);
    };
    En("mouseup", document, Bt);
  }
  function Te(ge) {
    r.onKeyup && Ot(r.onKeyup, ge);
  }
  function De(ge) {
    switch (r.onKeydown && Ot(r.onKeydown, ge), ge.key) {
      case "Escape":
        ve();
        break;
      case "Enter":
        he(ge);
        break;
    }
  }
  function he(ge) {
    var dt, Bt;
    if (r.passivelyActivated) {
      const { value: Rr } = de;
      if (Rr) {
        r.internalDeactivateOnEnter && ve();
        return;
      }
      ge.preventDefault(), r.type === "textarea" ? (dt = s.value) === null || dt === void 0 || dt.focus() : (Bt = M.value) === null || Bt === void 0 || Bt.focus();
    }
  }
  function ve() {
    r.passivelyActivated && (de.value = false, Nn(() => {
      var ge;
      (ge = m.value) === null || ge === void 0 || ge.focus();
    }));
  }
  function je() {
    var ge, dt, Bt;
    re.value || (r.passivelyActivated ? (ge = m.value) === null || ge === void 0 || ge.focus() : ((dt = s.value) === null || dt === void 0 || dt.focus(), (Bt = M.value) === null || Bt === void 0 || Bt.focus()));
  }
  function it() {
    var ge;
    !((ge = m.value) === null || ge === void 0) && ge.contains(document.activeElement) && document.activeElement.blur();
  }
  function Xe() {
    var ge, dt;
    (ge = s.value) === null || ge === void 0 || ge.select(), (dt = M.value) === null || dt === void 0 || dt.select();
  }
  function wt() {
    re.value || (s.value ? s.value.focus() : M.value && M.value.focus());
  }
  function Pe() {
    const { value: ge } = m;
    (ge == null ? void 0 : ge.contains(document.activeElement)) && ge !== document.activeElement && ve();
  }
  function $t(ge) {
    if (r.type === "textarea") {
      const { value: dt } = s;
      dt == null ? void 0 : dt.scrollTo(ge);
    } else {
      const { value: dt } = M;
      dt == null ? void 0 : dt.scrollTo(ge);
    }
  }
  function Qt(ge) {
    const { type: dt, pair: Bt, autosize: Rr } = r;
    if (!Bt && Rr) if (dt === "textarea") {
      const { value: $r } = C;
      $r && ($r.textContent = `${ge ?? ""}\r
`);
    } else {
      const { value: $r } = T;
      $r && (ge ? $r.textContent = ge : $r.innerHTML = "&nbsp;");
    }
  }
  function Nt() {
    yt();
  }
  const ur = Ae({ top: "0" });
  function Br(ge) {
    var dt;
    const { scrollTop: Bt } = ge.target;
    ur.value.top = `${-Bt}px`, (dt = O.value) === null || dt === void 0 || dt.syncUnifiedContainer();
  }
  let Qr = null;
  vo(() => {
    const { autosize: ge, type: dt } = r;
    ge && dt === "textarea" ? Qr = ar(Q, (Bt) => {
      !Array.isArray(Bt) && Bt !== xe && Qt(Bt);
    }) : Qr == null ? void 0 : Qr();
  });
  let ei = null;
  vo(() => {
    r.type === "textarea" ? ei = ar(Q, (ge) => {
      var dt;
      !Array.isArray(ge) && ge !== xe && ((dt = O.value) === null || dt === void 0 || dt.syncUnifiedContainer());
    }) : ei == null ? void 0 : ei();
  }), Jr(vb, { mergedValueRef: Q, maxlengthRef: nt, mergedClsPrefixRef: i, countGraphemesRef: Dt(r, "countGraphemes") });
  const ni = { wrapperElRef: m, inputElRef: M, textareaElRef: s, isCompositing: oe, clear: wi, focus: je, blur: it, select: Xe, deactivate: Pe, activate: wt, scrollTo: $t }, gr = Rn("Input", f, i), yr = ze(() => {
    const { value: ge } = te, { common: { cubicBezierEaseInOut: dt }, self: { color: Bt, borderRadius: Rr, textColor: $r, caretColor: gt, caretColorError: cr, caretColorWarning: lr, textDecorationColor: oi, border: hn, borderDisabled: tn, borderHover: dr, borderFocus: Qo, placeholderColor: Un, placeholderColorDisabled: ea, lineHeightTextarea: Sn, colorDisabled: bo, colorFocus: Zr, textColorDisabled: Jn, boxShadowFocus: rn, iconSize: Ur, colorFocusWarning: Ll, boxShadowFocusWarning: wa, borderWarning: Ds, borderFocusWarning: xo, borderHoverWarning: wo, colorFocusError: zs, boxShadowFocusError: Bl, borderError: Ol, borderFocusError: ta, borderHoverError: $l, clearSize: cc, clearColor: dc, clearColorHover: hc, clearColorPressed: Fs, iconColor: ra, iconColorDisabled: Ls, suffixTextColor: Bs, countTextColor: ia, countTextColorDisabled: Os, iconColorHover: $s, iconColorPressed: fc, loadingColor: na, loadingColorError: Ca, loadingColorWarning: Dn, fontWeight: br, [jt("padding", ge)]: Lo, [jt("fontSize", ge)]: Co, [jt("height", ge)]: Qn } } = g.value, { left: Bo, right: xr } = Ro(Lo);
    return { "--n-bezier": dt, "--n-count-text-color": ia, "--n-count-text-color-disabled": Os, "--n-color": Bt, "--n-font-size": Co, "--n-font-weight": br, "--n-border-radius": Rr, "--n-height": Qn, "--n-padding-left": Bo, "--n-padding-right": xr, "--n-text-color": $r, "--n-caret-color": gt, "--n-text-decoration-color": oi, "--n-border": hn, "--n-border-disabled": tn, "--n-border-hover": dr, "--n-border-focus": Qo, "--n-placeholder-color": Un, "--n-placeholder-color-disabled": ea, "--n-icon-size": Ur, "--n-line-height-textarea": Sn, "--n-color-disabled": bo, "--n-color-focus": Zr, "--n-text-color-disabled": Jn, "--n-box-shadow-focus": rn, "--n-loading-color": na, "--n-caret-color-warning": lr, "--n-color-focus-warning": Ll, "--n-box-shadow-focus-warning": wa, "--n-border-warning": Ds, "--n-border-focus-warning": xo, "--n-border-hover-warning": wo, "--n-loading-color-warning": Dn, "--n-caret-color-error": cr, "--n-color-focus-error": zs, "--n-box-shadow-focus-error": Bl, "--n-border-error": Ol, "--n-border-focus-error": ta, "--n-border-hover-error": $l, "--n-loading-color-error": Ca, "--n-clear-color": dc, "--n-clear-size": cc, "--n-clear-color-hover": hc, "--n-clear-color-pressed": Fs, "--n-icon-color": ra, "--n-icon-color-hover": $s, "--n-icon-color-pressed": fc, "--n-icon-color-disabled": Ls, "--n-suffix-text-color": Bs };
  }), Wr = d ? ci("input", ze(() => {
    const { value: ge } = te;
    return ge[0];
  }), yr, r) : void 0;
  return Object.assign(Object.assign({}, ni), { wrapperElRef: m, inputElRef: M, inputMirrorElRef: T, inputEl2Ref: z, textareaElRef: s, textareaMirrorElRef: C, textareaScrollbarInstRef: O, rtlEnabled: gr, uncontrolledValue: X, mergedValue: Q, passwordVisible: at, mergedPlaceholder: $e, showPlaceholder1: Ve, showPlaceholder2: Ke, mergedFocus: lt, isComposing: oe, activated: de, showClearButton: vt, mergedSize: te, mergedDisabled: re, textDecorationStyle: et, mergedClsPrefix: i, mergedBordered: l, mergedShowPasswordOn: xt, placeholderStyle: ur, mergedStatus: J, textAreaScrollContainerWidth: ht, handleTextAreaScroll: Br, handleCompositionStart: Cr, handleCompositionEnd: Ct, handleInput: Ee, handleInputBlur: Le, handleInputFocus: Ye, handleWrapperBlur: ft, handleWrapperFocus: bt, handleMouseEnter: Z, handleMouseLeave: Y, handleMouseDown: Fe, handleChange: mt, handleClick: Zt, handleClear: ii, handlePasswordToggleClick: ne, handlePasswordToggleMousedown: _e, handleWrapperKeydown: De, handleWrapperKeyup: Te, handleTextAreaMirrorResize: Nt, getTextareaScrollContainer: () => s.value, mergedTheme: g, cssVars: d ? void 0 : yr, themeClass: Wr == null ? void 0 : Wr.themeClass, onRender: Wr == null ? void 0 : Wr.onRender });
}, render() {
  var r, i, l, d, f, g, m;
  const { mergedClsPrefix: s, mergedStatus: C, themeClass: T, type: M, countGraphemes: z, onRender: L } = this, A = this.$slots;
  return L == null ? void 0 : L(), F("div", { ref: "wrapperElRef", class: [`${s}-input`, T, C && `${s}-input--${C}-status`, { [`${s}-input--rtl`]: this.rtlEnabled, [`${s}-input--disabled`]: this.mergedDisabled, [`${s}-input--textarea`]: M === "textarea", [`${s}-input--resizable`]: this.resizable && !this.autosize, [`${s}-input--autosize`]: this.autosize, [`${s}-input--round`]: this.round && M !== "textarea", [`${s}-input--pair`]: this.pair, [`${s}-input--focus`]: this.mergedFocus, [`${s}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, F("div", { class: `${s}-input-wrapper` }, xi(A.prefix, (O) => O && F("div", { class: `${s}-input__prefix` }, O)), M === "textarea" ? F(Yd, { ref: "textareaScrollbarInstRef", class: `${s}-input__textarea`, container: this.getTextareaScrollContainer, theme: (i = (r = this.theme) === null || r === void 0 ? void 0 : r.peers) === null || i === void 0 ? void 0 : i.Scrollbar, themeOverrides: (d = (l = this.themeOverrides) === null || l === void 0 ? void 0 : l.peers) === null || d === void 0 ? void 0 : d.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var O, U;
    const { textAreaScrollContainerWidth: X } = this, H = { width: this.autosize && X && `${X}px` };
    return F(qr, null, F("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${s}-input__textarea-el`, (O = this.inputProps) === null || O === void 0 ? void 0 : O.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (U = this.inputProps) === null || U === void 0 ? void 0 : U.style, H], onBlur: this.handleInputBlur, onFocus: (Q) => {
      this.handleInputFocus(Q, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? F("div", { class: `${s}-input__placeholder`, style: [this.placeholderStyle, H], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? F(Pl, { onResize: this.handleTextAreaMirrorResize }, { default: () => F("div", { ref: "textareaMirrorElRef", class: `${s}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : F("div", { class: `${s}-input__input` }, F("input", Object.assign({ type: M === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : M }, this.inputProps, { ref: "inputElRef", class: [`${s}-input__input-el`, (f = this.inputProps) === null || f === void 0 ? void 0 : f.class], style: [this.textDecorationStyle[0], (g = this.inputProps) === null || g === void 0 ? void 0 : g.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (m = this.inputProps) === null || m === void 0 ? void 0 : m.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 0);
  }, onInput: (O) => {
    this.handleInput(O, 0);
  }, onChange: (O) => {
    this.handleChange(O, 0);
  } })), this.showPlaceholder1 ? F("div", { class: `${s}-input__placeholder` }, F("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? F("div", { class: `${s}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && xi(A.suffix, (O) => O || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? F("div", { class: `${s}-input__suffix` }, [xi(A["clear-icon-placeholder"], (U) => (this.clearable || U) && F(pg, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => U, icon: () => {
    var X, H;
    return (H = (X = this.$slots)["clear-icon"]) === null || H === void 0 ? void 0 : H.call(X);
  } })), this.internalLoadingBeforeSuffix ? null : O, this.loading !== void 0 ? F(mb, { clsPrefix: s, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? O : null, this.showCount && this.type !== "textarea" ? F(o_, null, { default: (U) => {
    var X;
    const { renderCount: H } = this;
    return H ? H(U) : (X = A.count) === null || X === void 0 ? void 0 : X.call(A, U);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? F("div", { class: `${s}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Vn(A["password-visible-icon"], () => [F(Nr, { clsPrefix: s }, { default: () => F(fb, null) })]) : Vn(A["password-invisible-icon"], () => [F(Nr, { clsPrefix: s }, { default: () => F(NS, null) })])) : null]) : null)), this.pair ? F("span", { class: `${s}-input__separator` }, Vn(A.separator, () => [this.separator])) : null, this.pair ? F("div", { class: `${s}-input-wrapper` }, F("div", { class: `${s}-input__input` }, F("input", { ref: "inputEl2Ref", type: this.type, class: `${s}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 1);
  }, onInput: (O) => {
    this.handleInput(O, 1);
  }, onChange: (O) => {
    this.handleChange(O, 1);
  } }), this.showPlaceholder2 ? F("div", { class: `${s}-input__placeholder` }, F("span", null, this.mergedPlaceholder[1])) : null), xi(A.suffix, (O) => (this.clearable || O) && F("div", { class: `${s}-input__suffix` }, [this.clearable && F(pg, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var U;
    return (U = A["clear-icon"]) === null || U === void 0 ? void 0 : U.call(A);
  }, placeholder: () => {
    var U;
    return (U = A["clear-icon-placeholder"]) === null || U === void 0 ? void 0 : U.call(A);
  } }), O]))) : null, this.mergedBordered ? F("div", { class: `${s}-input__border` }) : null, this.mergedBordered ? F("div", { class: `${s}-input__state-border` }) : null, this.showCount && M === "textarea" ? F(o_, null, { default: (O) => {
    var U;
    const { renderCount: X } = this;
    return X ? X(O) : (U = A.count) === null || U === void 0 ? void 0 : U.call(A, O);
  } }) : null);
} }), wk = ue("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [qe(">", [ue("input", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), qe("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), ue("button", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Re("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), qe("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Re("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), qe("*", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [qe(">", [ue("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Re("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), qe("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [qe(">", [ue("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Re("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), Ck = {}, Sk = st({ name: "InputGroup", props: Ck, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  return oc("-input-group", wk, i), { mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { class: `${r}-input-group` }, this.$slots);
} });
function Vf(r) {
  return r.type === "group";
}
function _b(r) {
  return r.type === "ignored";
}
function Am(r, i) {
  try {
    return !!(1 + i.toString().toLowerCase().indexOf(r.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function kk(r, i) {
  return { getIsGroup: Vf, getIgnored: _b, getKey(d) {
    return Vf(d) ? d.name || d.key || "key-required" : d[r];
  }, getChildren(d) {
    return d[i];
  } };
}
function Pk(r, i, l, d) {
  if (!i) return r;
  function f(g) {
    if (!Array.isArray(g)) return [];
    const m = [];
    for (const s of g) if (Vf(s)) {
      const C = f(s[d]);
      C.length && m.push(Object.assign({}, s, { [d]: C }));
    } else {
      if (_b(s)) continue;
      i(l, s) && m.push(s);
    }
    return m;
  }
  return f(r);
}
function Tk(r, i, l) {
  const d = /* @__PURE__ */ new Map();
  return r.forEach((f) => {
    Vf(f) ? f[l].forEach((g) => {
      d.set(g[i], g);
    }) : d.set(f[i], f);
  }), d;
}
const Ik = rp && "loading" in document.createElement("img");
function Mk(r = {}) {
  var i;
  const { root: l = null } = r;
  return { hash: `${r.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(r.threshold) ? r.threshold.join(",") : (i = r.threshold) !== null && i !== void 0 ? i : "0"}`, options: Object.assign(Object.assign({}, r), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const Dm = /* @__PURE__ */ new WeakMap(), zm = /* @__PURE__ */ new WeakMap(), Fm = /* @__PURE__ */ new WeakMap(), Ek = (r, i, l) => {
  if (!r) return () => {
  };
  const d = Mk(i), { root: f } = d.options;
  let g;
  const m = Dm.get(f);
  m ? g = m : (g = /* @__PURE__ */ new Map(), Dm.set(f, g));
  let s, C;
  g.has(d.hash) ? (C = g.get(d.hash), C[1].has(r) || (s = C[0], C[1].add(r), s.observe(r))) : (s = new IntersectionObserver((z) => {
    z.forEach((L) => {
      if (L.isIntersecting) {
        const A = zm.get(L.target), O = Fm.get(L.target);
        A && A(), O && (O.value = true);
      }
    });
  }, d.options), s.observe(r), C = [s, /* @__PURE__ */ new Set([r])], g.set(d.hash, C));
  let T = false;
  const M = () => {
    T || (zm.delete(r), Fm.delete(r), T = true, C[1].has(r) && (C[0].unobserve(r), C[1].delete(r)), C[1].size <= 0 && g.delete(d.hash), g.size || Dm.delete(f));
  };
  return zm.set(r, M), Fm.set(r, l), M;
}, Si = "0!important", yb = "-1px!important";
function $u(r) {
  return Ue(`${r}-type`, [qe("& +", [ue("button", {}, [Ue(`${r}-type`, [Re("border", { borderLeftWidth: Si }), Re("state-border", { left: yb })])])])]);
}
function ju(r) {
  return Ue(`${r}-type`, [qe("& +", [ue("button", [Ue(`${r}-type`, [Re("border", { borderTopWidth: Si }), Re("state-border", { top: yb })])])])]);
}
const Rk = ue("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [ui("vertical", { flexDirection: "row" }, [ui("rtl", [ue("button", [qe("&:first-child:not(:last-child)", `
 margin-right: ${Si};
 border-top-right-radius: ${Si};
 border-bottom-right-radius: ${Si};
 `), qe("&:last-child:not(:first-child)", `
 margin-left: ${Si};
 border-top-left-radius: ${Si};
 border-bottom-left-radius: ${Si};
 `), qe("&:not(:first-child):not(:last-child)", `
 margin-left: ${Si};
 margin-right: ${Si};
 border-radius: ${Si};
 `), $u("default"), Ue("ghost", [$u("primary"), $u("info"), $u("success"), $u("warning"), $u("error")])])])]), Ue("vertical", { flexDirection: "column" }, [ue("button", [qe("&:first-child:not(:last-child)", `
 margin-bottom: ${Si};
 margin-left: ${Si};
 margin-right: ${Si};
 border-bottom-left-radius: ${Si};
 border-bottom-right-radius: ${Si};
 `), qe("&:last-child:not(:first-child)", `
 margin-top: ${Si};
 margin-left: ${Si};
 margin-right: ${Si};
 border-top-left-radius: ${Si};
 border-top-right-radius: ${Si};
 `), qe("&:not(:first-child):not(:last-child)", `
 margin: ${Si};
 border-radius: ${Si};
 `), ju("default"), Ue("ghost", [ju("primary"), ju("info"), ju("success"), ju("warning"), ju("error")])])])]), Ak = { size: { type: String, default: void 0 }, vertical: Boolean }, Dk = st({ name: "ButtonGroup", props: Ak, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r);
  return oc("-button-group", Rk, i), Jr(u2, r), { rtlEnabled: Rn("ButtonGroup", l, i), mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { class: [`${r}-button-group`, this.rtlEnabled && `${r}-button-group--rtl`, this.vertical && `${r}-button-group--vertical`], role: "group" }, this.$slots);
} }), zk = An("n-checkbox-group"), Fk = () => F("svg", { viewBox: "0 0 64 64", class: "check-icon" }, F("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), Lk = () => F("svg", { viewBox: "0 0 100 100", class: "line-icon" }, F("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), Bk = qe([ue("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ue("show-label", "line-height: var(--n-label-line-height);"), qe("&:hover", [ue("checkbox-box", [Re("border", "border: var(--n-border-checked);")])]), qe("&:focus:not(:active)", [ue("checkbox-box", [Re("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ue("inside-table", [ue("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ue("checked", [ue("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [ue("checkbox-icon", [qe(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("indeterminate", [ue("checkbox-box", [ue("checkbox-icon", [qe(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), qe(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("checked, indeterminate", [qe("&:focus:not(:active)", [ue("checkbox-box", [Re("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), ue("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Re("border", { border: "var(--n-border-checked)" })])]), Ue("disabled", { cursor: "not-allowed" }, [Ue("checked", [ue("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Re("border", { border: "var(--n-border-disabled-checked)" }), ue("checkbox-icon", [qe(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), ue("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Re("border", `
 border: var(--n-border-disabled);
 `), ue("checkbox-icon", [qe(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Re("label", `
 color: var(--n-text-color-disabled);
 `)]), ue("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), ue("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Re("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), ue("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [qe(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Ld({ left: "1px", top: "1px" })])]), Re("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [qe("&:empty", { display: "none" })])]), Py(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), Ty(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), Ok = Object.assign(Object.assign({}, Yt.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), $k = st({ name: "Checkbox", props: Ok, setup(r) {
  const i = fr(zk, null), l = Ae(null), { mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Tr(r), m = Ae(r.defaultChecked), s = Dt(r, "checked"), C = Zi(s, m), T = pi(() => {
    if (i) {
      const J = i.valueSetRef.value;
      return J && r.value !== void 0 ? J.has(r.value) : false;
    } else return C.value === r.checkedValue;
  }), M = ya(r, { mergedSize(J) {
    const { size: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      const { value: fe } = i.mergedSizeRef;
      if (fe !== void 0) return fe;
    }
    if (J) {
      const { mergedSize: fe } = J;
      if (fe !== void 0) return fe.value;
    }
    return "medium";
  }, mergedDisabled(J) {
    const { disabled: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      if (i.disabledRef.value) return true;
      const { maxRef: { value: fe }, checkedCountRef: oe } = i;
      if (fe !== void 0 && oe.value >= fe && !T.value) return true;
      const { minRef: { value: de } } = i;
      if (de !== void 0 && oe.value <= de && T.value) return true;
    }
    return J ? J.disabled.value : false;
  } }), { mergedDisabledRef: z, mergedSizeRef: L } = M, A = Yt("Checkbox", "-checkbox", Bk, c2, r, d);
  function O(J) {
    if (i && r.value !== void 0) i.toggleCheckbox(!T.value, r.value);
    else {
      const { onChange: Se, "onUpdate:checked": fe, onUpdateChecked: oe } = r, { nTriggerFormInput: de, nTriggerFormChange: xe } = M, $e = T.value ? r.uncheckedValue : r.checkedValue;
      fe && Ot(fe, $e, J), oe && Ot(oe, $e, J), Se && Ot(Se, $e, J), de(), xe(), m.value = $e;
    }
  }
  function U(J) {
    z.value || O(J);
  }
  function X(J) {
    if (!z.value) switch (J.key) {
      case " ":
      case "Enter":
        O(J);
    }
  }
  function H(J) {
    switch (J.key) {
      case " ":
        J.preventDefault();
    }
  }
  const Q = { focus: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.focus();
  }, blur: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.blur();
  } }, ie = Rn("Checkbox", g, d), te = ze(() => {
    const { value: J } = L, { common: { cubicBezierEaseInOut: Se }, self: { borderRadius: fe, color: oe, colorChecked: de, colorDisabled: xe, colorTableHeader: $e, colorTableHeaderModal: Ve, colorTableHeaderPopover: Ke, checkMarkColor: lt, checkMarkColorDisabled: vt, border: xt, borderFocus: at, borderDisabled: et, borderChecked: ht, boxShadowFocus: yt, textColor: nt, textColorDisabled: ut, checkMarkColorDisabledChecked: Lt, colorDisabledChecked: Ht, borderDisabledChecked: zt, labelPadding: pr, labelLineHeight: Jt, labelFontWeight: tr, [jt("fontSize", J)]: wr, [jt("size", J)]: Er } } = A.value;
    return { "--n-label-line-height": Jt, "--n-label-font-weight": tr, "--n-size": Er, "--n-bezier": Se, "--n-border-radius": fe, "--n-border": xt, "--n-border-checked": ht, "--n-border-focus": at, "--n-border-disabled": et, "--n-border-disabled-checked": zt, "--n-box-shadow-focus": yt, "--n-color": oe, "--n-color-checked": de, "--n-color-table": $e, "--n-color-table-modal": Ve, "--n-color-table-popover": Ke, "--n-color-disabled": xe, "--n-color-disabled-checked": Ht, "--n-text-color": nt, "--n-text-color-disabled": ut, "--n-check-mark-color": lt, "--n-check-mark-color-disabled": vt, "--n-check-mark-color-disabled-checked": Lt, "--n-font-size": wr, "--n-label-padding": pr };
  }), re = f ? ci("checkbox", ze(() => L.value[0]), te, r) : void 0;
  return Object.assign(M, Q, { rtlEnabled: ie, selfRef: l, mergedClsPrefix: d, mergedDisabled: z, renderedChecked: T, mergedTheme: A, labelId: zl(), handleClick: U, handleKeyUp: X, handleKeyDown: H, cssVars: f ? void 0 : te, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender });
}, render() {
  var r;
  const { $slots: i, renderedChecked: l, mergedDisabled: d, indeterminate: f, privateInsideTable: g, cssVars: m, labelId: s, label: C, mergedClsPrefix: T, focusable: M, handleKeyUp: z, handleKeyDown: L, handleClick: A } = this;
  (r = this.onRender) === null || r === void 0 || r.call(this);
  const O = xi(i.default, (U) => C || U ? F("span", { class: `${T}-checkbox__label`, id: s }, C || U) : null);
  return F("div", { ref: "selfRef", class: [`${T}-checkbox`, this.themeClass, this.rtlEnabled && `${T}-checkbox--rtl`, l && `${T}-checkbox--checked`, d && `${T}-checkbox--disabled`, f && `${T}-checkbox--indeterminate`, g && `${T}-checkbox--inside-table`, O && `${T}-checkbox--show-label`], tabindex: d || !M ? void 0 : 0, role: "checkbox", "aria-checked": f ? "mixed" : l, "aria-labelledby": s, style: m, onKeyup: z, onKeydown: L, onClick: A, onMousedown: () => {
    En("selectstart", window, (U) => {
      U.preventDefault();
    }, { once: true });
  } }, F("div", { class: `${T}-checkbox-box-wrapper` }, "\xA0", F("div", { class: `${T}-checkbox-box` }, F(Yf, null, { default: () => this.indeterminate ? F("div", { key: "indeterminate", class: `${T}-checkbox-icon` }, Lk()) : F("div", { key: "check", class: `${T}-checkbox-icon` }, Fk()) }), F("div", { class: `${T}-checkbox-box__border` }))), O);
} }), jk = ue("collapse", "width: 100%;", [ue("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ue("disabled", [Re("header", "cursor: not-allowed;", [Re("header-main", `
 color: var(--n-title-text-color-disabled);
 `), ue("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), ue("collapse-item", "margin-left: 32px;"), qe("&:first-child", "margin-top: 0;"), qe("&:first-child >", [Re("header", "padding-top: 0;")]), Ue("left-arrow-placement", [Re("header", [ue("collapse-item-arrow", "margin-right: 4px;")])]), Ue("right-arrow-placement", [Re("header", [ue("collapse-item-arrow", "margin-left: 4px;")])]), Re("content-wrapper", [Re("content-inner", "padding-top: 16px;"), Bf({ duration: "0.15s" })]), Ue("active", [Re("header", [Ue("active", [ue("collapse-item-arrow", "transform: rotate(90deg);")])])]), qe("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), ui("disabled", [Ue("trigger-area-main", [Re("header", [Re("header-main", "cursor: pointer;"), ue("collapse-item-arrow", "cursor: default;")])]), Ue("trigger-area-arrow", [Re("header", [ue("collapse-item-arrow", "cursor: pointer;")])]), Ue("trigger-area-extra", [Re("header", [Re("header-extra", "cursor: pointer;")])])]), Re("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Re("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Re("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), ue("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), Nk = Object.assign(Object.assign({}, Yt.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), bb = An("n-collapse"), a_ = st({ name: "Collapse", props: Nk, slots: Object, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Ae(r.defaultExpandedNames), m = ze(() => r.expandedNames), s = Zi(m, g), C = Yt("Collapse", "-collapse", jk, d2, r, l);
  function T(U) {
    const { "onUpdate:expandedNames": X, onUpdateExpandedNames: H, onExpandedNamesChange: Q } = r;
    H && Ot(H, U), X && Ot(X, U), Q && Ot(Q, U), g.value = U;
  }
  function M(U) {
    const { onItemHeaderClick: X } = r;
    X && Ot(X, U);
  }
  function z(U, X, H) {
    const { accordion: Q } = r, { value: ie } = s;
    if (Q) U ? (T([X]), M({ name: X, expanded: true, event: H })) : (T([]), M({ name: X, expanded: false, event: H }));
    else if (!Array.isArray(ie)) T([X]), M({ name: X, expanded: true, event: H });
    else {
      const te = ie.slice(), re = te.findIndex((J) => X === J);
      ~re ? (te.splice(re, 1), T(te), M({ name: X, expanded: false, event: H })) : (te.push(X), T(te), M({ name: X, expanded: true, event: H }));
    }
  }
  Jr(bb, { props: r, mergedClsPrefixRef: l, expandedNamesRef: s, slots: i, toggleItem: z });
  const L = Rn("Collapse", f, l), A = ze(() => {
    const { common: { cubicBezierEaseInOut: U }, self: { titleFontWeight: X, dividerColor: H, titlePadding: Q, titleTextColor: ie, titleTextColorDisabled: te, textColor: re, arrowColor: J, fontSize: Se, titleFontSize: fe, arrowColorDisabled: oe, itemMargin: de } } = C.value;
    return { "--n-font-size": Se, "--n-bezier": U, "--n-text-color": re, "--n-divider-color": H, "--n-title-padding": Q, "--n-title-font-size": fe, "--n-title-text-color": ie, "--n-title-text-color-disabled": te, "--n-title-font-weight": X, "--n-arrow-color": J, "--n-arrow-color-disabled": oe, "--n-item-margin": de };
  }), O = d ? ci("collapse", void 0, A, r) : void 0;
  return { rtlEnabled: L, mergedTheme: C, mergedClsPrefix: l, cssVars: d ? void 0 : A, themeClass: O == null ? void 0 : O.themeClass, onRender: O == null ? void 0 : O.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), Vk = st({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(r) {
  return { onceTrue: h2(Dt(r, "show")) };
}, render() {
  return F(ep, null, { default: () => {
    const { show: r, displayDirective: i, onceTrue: l, clsPrefix: d } = this, f = i === "show" && l, g = F("div", { class: `${d}-collapse-item__content-wrapper` }, F("div", { class: `${d}-collapse-item__content-inner` }, this.$slots));
    return f ? va(g, [[Ka, r]]) : r ? g : null;
  } });
} }), Uk = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, s_ = st({ name: "CollapseItem", props: Uk, setup(r) {
  const { mergedRtlRef: i } = Tr(r), l = zl(), d = pi(() => {
    var z;
    return (z = r.name) !== null && z !== void 0 ? z : l;
  }), f = fr(bb);
  f || Yo("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: g, props: m, mergedClsPrefixRef: s, slots: C } = f, T = ze(() => {
    const { value: z } = g;
    if (Array.isArray(z)) {
      const { value: L } = d;
      return !~z.findIndex((A) => A === L);
    } else if (z) {
      const { value: L } = d;
      return L !== z;
    }
    return true;
  });
  return { rtlEnabled: Rn("Collapse", i, s), collapseSlots: C, randomName: l, mergedClsPrefix: s, collapsed: T, triggerAreas: Dt(m, "triggerAreas"), mergedDisplayDirective: ze(() => {
    const { displayDirective: z } = r;
    return z || m.displayDirective;
  }), arrowPlacement: ze(() => m.arrowPlacement), handleClick(z) {
    let L = "main";
    Tl(z, "arrow") && (L = "arrow"), Tl(z, "extra") && (L = "extra"), m.triggerAreas.includes(L) && f && !r.disabled && f.toggleItem(T.value, d.value, z);
  } };
}, render() {
  const { collapseSlots: r, $slots: i, arrowPlacement: l, collapsed: d, mergedDisplayDirective: f, mergedClsPrefix: g, disabled: m, triggerAreas: s } = this, C = og(i.header, { collapsed: d }, () => [this.title]), T = i["header-extra"] || r["header-extra"], M = i.arrow || r.arrow;
  return F("div", { class: [`${g}-collapse-item`, `${g}-collapse-item--${l}-arrow-placement`, m && `${g}-collapse-item--disabled`, !d && `${g}-collapse-item--active`, s.map((z) => `${g}-collapse-item--trigger-area-${z}`)] }, F("div", { class: [`${g}-collapse-item__header`, !d && `${g}-collapse-item__header--active`] }, F("div", { class: `${g}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && C, F("div", { class: `${g}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, og(M, { collapsed: d }, () => [F(Nr, { clsPrefix: g }, { default: () => this.rtlEnabled ? F(OS, null) : F(f2, null) })])), l === "left" && C), p2(T, { collapsed: d }, (z) => F("div", { class: `${g}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, z))), F(Vk, { clsPrefix: g, displayDirective: f, show: !d }, i));
} });
function Gk(r, i) {
  switch (r[0]) {
    case "hex":
      return i ? "#000000FF" : "#000000";
    case "rgb":
      return i ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return i ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return i ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function jd(r) {
  return r === null ? null : /^ *#/.test(r) ? "hex" : r.includes("rgb") ? "rgb" : r.includes("hsl") ? "hsl" : r.includes("hsv") ? "hsv" : null;
}
function qk(r, i = [255, 255, 255], l = "AA") {
  const [d, f, g, m] = Zo(Za(r));
  if (m === 1) {
    const A = gf([d, f, g]), O = gf(i);
    return (Math.max(A, O) + 0.05) / (Math.min(A, O) + 0.05) >= (l === "AA" ? 4.5 : 7);
  }
  const s = Math.round(d * m + i[0] * (1 - m)), C = Math.round(f * m + i[1] * (1 - m)), T = Math.round(g * m + i[2] * (1 - m)), M = gf([s, C, T]), z = gf(i);
  return (Math.max(M, z) + 0.05) / (Math.min(M, z) + 0.05) >= (l === "AA" ? 4.5 : 7);
}
function gf(r) {
  const [i, l, d] = r.map((f) => (f /= 255, f <= 0.03928 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4)));
  return 0.2126 * i + 0.7152 * l + 0.0722 * d;
}
function Wk(r) {
  return r = Math.round(r), r >= 360 ? 359 : r < 0 ? 0 : r;
}
function Zk(r) {
  return r = Math.round(r * 100) / 100, r > 1 ? 1 : r < 0 ? 0 : r;
}
const Hk = { rgb: { hex(r) {
  return Ts(Zo(r));
}, hsl(r) {
  const [i, l, d, f] = Zo(r);
  return Za([...lg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Zo(r);
  return Ml([...sg(i, l, d), f]);
} }, hex: { rgb(r) {
  return Ha(Zo(r));
}, hsl(r) {
  const [i, l, d, f] = Zo(r);
  return Za([...lg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Zo(r);
  return Ml([...sg(i, l, d), f]);
} }, hsl: { hex(r) {
  const [i, l, d, f] = Hu(r);
  return Ts([...ag(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Hu(r);
  return Ha([...ag(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Hu(r);
  return Ml([...Iy(i, l, d), f]);
} }, hsv: { hex(r) {
  const [i, l, d, f] = Il(r);
  return Ts([...Ss(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Il(r);
  return Ha([...Ss(i, l, d), f]);
}, hsl(r) {
  const [i, l, d, f] = Il(r);
  return Za([...Ef(i, l, d), f]);
} } };
function xb(r, i, l) {
  return l = l || jd(r), l ? l === i ? r : Hk[l][i](r) : null;
}
const xd = "12px", Xk = 12, _l = "6px", Yk = st({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    !i.value || !r.rgba || (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), T = (g.clientX - C) / (s - Xk);
    r.onUpdateAlpha(Zk(T));
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, railBackgroundImage: ze(() => {
    const { rgba: g } = r;
    return g ? `linear-gradient(to right, rgba(${g[0]}, ${g[1]}, ${g[2]}, 0) 0%, rgba(${g[0]}, ${g[1]}, ${g[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-slider`, ref: "railRef", style: { height: xd, borderRadius: _l }, onMousedown: this.handleMouseDown }, F("div", { style: { borderRadius: _l, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, F("div", { class: `${r}-color-picker-checkboard` }), F("div", { class: `${r}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && F("div", { style: { position: "absolute", left: _l, right: _l, top: 0, bottom: 0 } }, F("div", { class: `${r}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${_l})`, borderRadius: _l, width: xd, height: xd } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: Ha(this.rgba), borderRadius: _l, width: xd, height: xd } }))));
} }), qg = An("n-color-picker");
function Kk(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 255)) : false;
}
function Jk(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 360)) : false;
}
function Qk(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 100)) : false;
}
function eP(r) {
  const i = r.trim();
  return /^#[0-9a-fA-F]+$/.test(i) ? [4, 5, 7, 9].includes(i.length) : false;
}
function tP(r) {
  return /^\d{1,3}\.?\d*%$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r) / 100, 100)) : false;
}
const rP = { paddingSmall: "0 4px" }, l_ = st({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(r) {
  const i = Ae(""), { themeRef: l } = fr(qg, null);
  vo(() => {
    i.value = d();
  });
  function d() {
    const { value: m } = r;
    if (m === null) return "";
    const { label: s } = r;
    return s === "HEX" ? m : s === "A" ? `${Math.floor(m * 100)}%` : String(Math.floor(m));
  }
  function f(m) {
    i.value = m;
  }
  function g(m) {
    let s, C;
    switch (r.label) {
      case "HEX":
        C = eP(m), C && r.onUpdateValue(m), i.value = d();
        break;
      case "H":
        s = Jk(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "S":
      case "L":
      case "V":
        s = Qk(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "A":
        s = tP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "R":
      case "G":
      case "B":
        s = Kk(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
    }
  }
  return { mergedTheme: l, inputValue: i, handleInputChange: g, handleInputUpdateValue: f };
}, render() {
  const { mergedTheme: r } = this;
  return F(mo, { size: "small", placeholder: this.label, theme: r.peers.Input, themeOverrides: r.peerOverrides.Input, builtinThemeOverrides: rP, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), iP = st({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(r) {
  return { handleUnitUpdateValue(i, l) {
    const { showAlpha: d } = r;
    if (r.mode === "hex") {
      r.onUpdateValue((d ? Ts : Md)(l));
      return;
    }
    let f;
    switch (r.valueArr === null ? f = [0, 0, 0, 0] : f = Array.from(r.valueArr), r.mode) {
      case "hsv":
        f[i] = l, r.onUpdateValue((d ? Ml : dg)(f));
        break;
      case "rgb":
        f[i] = l, r.onUpdateValue((d ? Ha : cg)(f));
        break;
      case "hsl":
        f[i] = l, r.onUpdateValue((d ? Za : ug)(f));
        break;
    }
  } };
}, render() {
  const { clsPrefix: r, modes: i } = this;
  return F("div", { class: `${r}-color-picker-input` }, F("div", { class: `${r}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: i.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), F(Sk, null, { default: () => {
    const { mode: l, valueArr: d, showAlpha: f } = this;
    if (l === "hex") {
      let g = null;
      try {
        g = d === null ? null : (f ? Ts : Md)(d);
      } catch {
      }
      return F(l_, { label: "HEX", showAlpha: f, value: g, onUpdateValue: (m) => {
        this.handleUnitUpdateValue(0, m);
      } });
    }
    return (l + (f ? "a" : "")).split("").map((g, m) => F(l_, { label: g.toUpperCase(), value: d === null ? null : d[m], onUpdateValue: (s) => {
      this.handleUnitUpdateValue(m, s);
    } }));
  } }));
} });
function nP(r, i) {
  if (i === "hsv") {
    const [l, d, f, g] = Il(r);
    return Ha([...Ss(l, d, f), g]);
  }
  return r;
}
function oP(r) {
  const i = document.createElement("canvas").getContext("2d");
  return i ? (i.fillStyle = r, i.fillStyle) : "#000000";
}
const aP = st({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  const i = ze(() => r.swatches.map((g) => {
    const m = jd(g);
    return { value: g, mode: m, legalValue: nP(g, m) };
  }));
  function l(g) {
    const { mode: m } = r;
    let { value: s, mode: C } = g;
    return C || (C = "hex", /^[a-zA-Z]+$/.test(s) ? s = oP(s) : (Of("color-picker", `color ${s} in swatches is invalid.`), s = "#000000")), C === m ? s : xb(s, m, C);
  }
  function d(g) {
    r.onUpdateColor(l(g));
  }
  function f(g, m) {
    g.key === "Enter" && d(m);
  }
  return { parsedSwatchesRef: i, handleSwatchSelect: d, handleSwatchKeyDown: f };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-swatches` }, this.parsedSwatchesRef.map((i) => F("div", { class: `${r}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(i);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, i);
  } }, F("div", { class: `${r}-color-picker-swatch__fill`, style: { background: i.legalValue } }))));
} }), sP = st({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(r) {
  const { colorPickerSlots: i, renderLabelRef: l } = fr(qg, null);
  return () => {
    const { hsla: d, value: f, clsPrefix: g, onClick: m, disabled: s } = r, C = i.label || l.value;
    return F("div", { class: [`${g}-color-picker-trigger`, s && `${g}-color-picker-trigger--disabled`], onClick: s ? void 0 : m }, F("div", { class: `${g}-color-picker-trigger__fill` }, F("div", { class: `${g}-color-picker-checkboard` }), F("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: d ? Za(d) : "" } }), f && d ? F("div", { class: `${g}-color-picker-trigger__value`, style: { color: qk(d) ? "white" : "black" } }, C ? C(f) : f) : null));
  };
} }), lP = st({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (r) => {
  const i = jd(r);
  return !!(!r || i && i !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  function i(l) {
    var d;
    const f = l.target.value;
    (d = r.onUpdateColor) === null || d === void 0 || d.call(r, xb(f.toUpperCase(), r.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: i };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-preview__preview` }, F("span", { class: `${r}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), F("input", { class: `${r}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), Nu = "12px", uP = 12, yl = "6px", cP = 6, dP = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", hP = st({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), T = Wk((g.clientX - C - cP) / (s - uP) * 360);
    r.onUpdateHue(T);
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-slider`, style: { height: Nu, borderRadius: yl } }, F("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: dP, height: Nu, borderRadius: yl, position: "relative" }, onMousedown: this.handleMouseDown }, F("div", { style: { position: "absolute", left: yl, right: yl, top: 0, bottom: 0 } }, F("div", { class: `${r}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${yl})`, borderRadius: yl, width: Nu, height: Nu } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: yl, width: Nu, height: Nu } })))));
} }), vf = "12px", _f = "6px", fP = st({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, height: C, left: T, bottom: M } = m.getBoundingClientRect(), z = (M - g.clientY) / C, L = (g.clientX - T) / s, A = 100 * (L > 1 ? 1 : L < 0 ? 0 : L), O = 100 * (z > 1 ? 1 : z < 0 ? 0 : z);
    r.onUpdateSV(A, O);
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { palleteRef: i, handleColor: ze(() => {
    const { rgba: g } = r;
    return g ? `rgb(${g[0]}, ${g[1]}, ${g[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, F("div", { class: `${r}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), F("div", { class: `${r}-color-picker-pallete__layer ${r}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && F("div", { class: `${r}-color-picker-handle`, style: { width: vf, height: vf, borderRadius: _f, left: `calc(${this.displayedSv[0]}% - ${_f})`, bottom: `calc(${this.displayedSv[1]}% - ${_f})` } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: _f, width: vf, height: vf } })));
} }), pP = qe([ue("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), ue("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [Kf(), ue("input", `
 text-align: center;
 `)]), ue("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [qe("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), ue("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Re("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), qe("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), ue("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Re("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), ue("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Re("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), ue("color-picker-preview", `
 display: flex;
 `, [Re("sliders", `
 flex: 1 0 auto;
 `), Re("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Re("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Re("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), ue("color-picker-input", `
 display: flex;
 align-items: center;
 `, [ue("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Re("mode", `
 width: 72px;
 text-align: center;
 `)]), ue("color-picker-control", `
 padding: 12px;
 `), ue("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [ue("button", "margin-left: 8px;")]), ue("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Re("value", `
 white-space: nowrap;
 position: relative;
 `), Re("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ue("disabled", "cursor: not-allowed"), ue("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [qe("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), ue("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [ue("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Re("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), qe("&:focus", `
 outline: none;
 `, [Re("fill", [qe("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), mP = Object.assign(Object.assign({}, Yt.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: Ku.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), Lm = st({ name: "ColorPicker", props: mP, slots: Object, setup(r, { slots: i }) {
  const l = Ae(null);
  let d = null;
  const f = ya(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, { localeRef: s } = Ja("global"), { mergedClsPrefixRef: C, namespaceRef: T, inlineThemeDisabled: M } = Tr(r), z = Yt("ColorPicker", "-color-picker", pP, m2, r, C);
  Jr(qg, { themeRef: z, renderLabelRef: Dt(r, "renderLabel"), colorPickerSlots: i });
  const L = Ae(r.defaultShow), A = Zi(Dt(r, "show"), L);
  function O(Ee) {
    const { onUpdateShow: ot, "onUpdate:show": Le } = r;
    ot && Ot(ot, Ee), Le && Ot(Le, Ee), L.value = Ee;
  }
  const { defaultValue: U } = r, X = Ae(U === void 0 ? Gk(r.modes, r.showAlpha) : U), H = Zi(Dt(r, "value"), X), Q = Ae([H.value]), ie = Ae(0), te = ze(() => jd(H.value)), { modes: re } = r, J = Ae(jd(H.value) || re[0] || "rgb");
  function Se() {
    const { modes: Ee } = r, { value: ot } = J, Le = Ee.findIndex((Ye) => Ye === ot);
    ~Le ? J.value = Ee[(Le + 1) % Ee.length] : J.value = "rgb";
  }
  let fe, oe, de, xe, $e, Ve, Ke, lt;
  const vt = ze(() => {
    const { value: Ee } = H;
    if (!Ee) return null;
    switch (te.value) {
      case "hsv":
        return Il(Ee);
      case "hsl":
        return [fe, oe, de, lt] = Hu(Ee), [...Iy(fe, oe, de), lt];
      case "rgb":
      case "hex":
        return [$e, Ve, Ke, lt] = Zo(Ee), [...sg($e, Ve, Ke), lt];
    }
  }), xt = ze(() => {
    const { value: Ee } = H;
    if (!Ee) return null;
    switch (te.value) {
      case "rgb":
      case "hex":
        return Zo(Ee);
      case "hsv":
        return [fe, oe, xe, lt] = Il(Ee), [...Ss(fe, oe, xe), lt];
      case "hsl":
        return [fe, oe, de, lt] = Hu(Ee), [...ag(fe, oe, de), lt];
    }
  }), at = ze(() => {
    const { value: Ee } = H;
    if (!Ee) return null;
    switch (te.value) {
      case "hsl":
        return Hu(Ee);
      case "hsv":
        return [fe, oe, xe, lt] = Il(Ee), [...Ef(fe, oe, xe), lt];
      case "rgb":
      case "hex":
        return [$e, Ve, Ke, lt] = Zo(Ee), [...lg($e, Ve, Ke), lt];
    }
  }), et = ze(() => {
    switch (J.value) {
      case "rgb":
      case "hex":
        return xt.value;
      case "hsv":
        return vt.value;
      case "hsl":
        return at.value;
    }
  }), ht = Ae(0), yt = Ae(1), nt = Ae([0, 0]);
  function ut(Ee, ot) {
    const { value: Le } = vt, Ye = ht.value, ft = Le ? Le[3] : 1;
    nt.value = [Ee, ot];
    const { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        zt((bt ? Ml : dg)([Ye, Ee, ot, ft]), "cursor");
        break;
      case "hsl":
        zt((bt ? Za : ug)([...Ef(Ye, Ee, ot), ft]), "cursor");
        break;
      case "rgb":
        zt((bt ? Ha : cg)([...Ss(Ye, Ee, ot), ft]), "cursor");
        break;
      case "hex":
        zt((bt ? Ts : Md)([...Ss(Ye, Ee, ot), ft]), "cursor");
        break;
    }
  }
  function Lt(Ee) {
    ht.value = Ee;
    const { value: ot } = vt;
    if (!ot) return;
    const [, Le, Ye, ft] = ot, { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        zt((bt ? Ml : dg)([Ee, Le, Ye, ft]), "cursor");
        break;
      case "rgb":
        zt((bt ? Ha : cg)([...Ss(Ee, Le, Ye), ft]), "cursor");
        break;
      case "hex":
        zt((bt ? Ts : Md)([...Ss(Ee, Le, Ye), ft]), "cursor");
        break;
      case "hsl":
        zt((bt ? Za : ug)([...Ef(Ee, Le, Ye), ft]), "cursor");
        break;
    }
  }
  function Ht(Ee) {
    switch (J.value) {
      case "hsv":
        [fe, oe, xe] = vt.value, zt(Ml([fe, oe, xe, Ee]), "cursor");
        break;
      case "rgb":
        [$e, Ve, Ke] = xt.value, zt(Ha([$e, Ve, Ke, Ee]), "cursor");
        break;
      case "hex":
        [$e, Ve, Ke] = xt.value, zt(Ts([$e, Ve, Ke, Ee]), "cursor");
        break;
      case "hsl":
        [fe, oe, de] = at.value, zt(Za([fe, oe, de, Ee]), "cursor");
        break;
    }
    yt.value = Ee;
  }
  function zt(Ee, ot) {
    ot === "cursor" ? d = Ee : d = null;
    const { nTriggerFormChange: Le, nTriggerFormInput: Ye } = f, { onUpdateValue: ft, "onUpdate:value": bt } = r;
    ft && Ot(ft, Ee), bt && Ot(bt, Ee), Le(), Ye(), X.value = Ee;
  }
  function pr(Ee) {
    zt(Ee, "input"), Nn(Jt);
  }
  function Jt(Ee = true) {
    const { value: ot } = H;
    if (ot) {
      const { nTriggerFormChange: Le, nTriggerFormInput: Ye } = f, { onComplete: ft } = r;
      ft && ft(ot);
      const { value: bt } = Q, { value: tt } = ie;
      Ee && (bt.splice(tt + 1, bt.length, ot), ie.value = tt + 1), Le(), Ye();
    }
  }
  function tr() {
    const { value: Ee } = ie;
    Ee - 1 < 0 || (zt(Q.value[Ee - 1], "input"), Jt(false), ie.value = Ee - 1);
  }
  function wr() {
    const { value: Ee } = ie;
    Ee < 0 || Ee + 1 >= Q.value.length || (zt(Q.value[Ee + 1], "input"), Jt(false), ie.value = Ee + 1);
  }
  function Er() {
    zt(null, "input");
    const { onClear: Ee } = r;
    Ee && Ee(), O(false);
  }
  function rr() {
    const { value: Ee } = H, { onConfirm: ot } = r;
    ot && ot(Ee), O(false);
  }
  const sr = ze(() => ie.value >= 1), qt = ze(() => {
    const { value: Ee } = Q;
    return Ee.length > 1 && ie.value < Ee.length - 1;
  });
  ar(A, (Ee) => {
    Ee || (Q.value = [H.value], ie.value = 0);
  }), vo(() => {
    if (!(d && d === H.value)) {
      const { value: Ee } = vt;
      Ee && (ht.value = Ee[0], yt.value = Ee[3], nt.value = [Ee[1], Ee[2]]);
    }
    d = null;
  });
  const Dr = ze(() => {
    const { value: Ee } = g, { common: { cubicBezierEaseInOut: ot }, self: { textColor: Le, color: Ye, panelFontSize: ft, boxShadow: bt, border: tt, borderRadius: mt, dividerColor: Zt, [jt("height", Ee)]: ii, [jt("fontSize", Ee)]: wi } } = z.value;
    return { "--n-bezier": ot, "--n-text-color": Le, "--n-color": Ye, "--n-panel-font-size": ft, "--n-font-size": wi, "--n-box-shadow": bt, "--n-border": tt, "--n-border-radius": mt, "--n-height": ii, "--n-divider-color": Zt };
  }), Cr = M ? ci("color-picker", ze(() => g.value[0]), Dr, r) : void 0;
  function Ct() {
    var Ee;
    const { value: ot } = xt, { value: Le } = ht, { internalActions: Ye, modes: ft, actions: bt } = r, { value: tt } = z, { value: mt } = C;
    return F("div", { class: [`${mt}-color-picker-panel`, Cr == null ? void 0 : Cr.themeClass.value], onDragstart: (Zt) => {
      Zt.preventDefault();
    }, style: M ? void 0 : Dr.value }, F("div", { class: `${mt}-color-picker-control` }, F(fP, { clsPrefix: mt, rgba: ot, displayedHue: Le, displayedSv: nt.value, onUpdateSV: ut, onComplete: Jt }), F("div", { class: `${mt}-color-picker-preview` }, F("div", { class: `${mt}-color-picker-preview__sliders` }, F(hP, { clsPrefix: mt, hue: Le, onUpdateHue: Lt, onComplete: Jt }), r.showAlpha ? F(Yk, { clsPrefix: mt, rgba: ot, alpha: yt.value, onUpdateAlpha: Ht, onComplete: Jt }) : null), r.showPreview ? F(lP, { clsPrefix: mt, mode: J.value, color: xt.value && Md(xt.value), onUpdateColor: (Zt) => {
      zt(Zt, "input");
    } }) : null), F(iP, { clsPrefix: mt, showAlpha: r.showAlpha, mode: J.value, modes: ft, onUpdateMode: Se, value: H.value, valueArr: et.value, onUpdateValue: pr }), ((Ee = r.swatches) === null || Ee === void 0 ? void 0 : Ee.length) && F(aP, { clsPrefix: mt, mode: J.value, swatches: r.swatches, onUpdateColor: (Zt) => {
      zt(Zt, "input");
    } })), (bt == null ? void 0 : bt.length) ? F("div", { class: `${mt}-color-picker-action` }, bt.includes("confirm") && F(Vr, { size: "small", onClick: rr, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.confirm }), bt.includes("clear") && F(Vr, { size: "small", onClick: Er, disabled: !H.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.clear })) : null, i.action ? F("div", { class: `${mt}-color-picker-action` }, { default: i.action }) : Ye ? F("div", { class: `${mt}-color-picker-action` }, Ye.includes("undo") && F(Vr, { size: "small", onClick: tr, disabled: !sr.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.undo }), Ye.includes("redo") && F(Vr, { size: "small", onClick: wr, disabled: !qt.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.redo })) : null);
  }
  return { mergedClsPrefix: C, namespace: T, selfRef: l, hsla: at, rgba: xt, mergedShow: A, mergedDisabled: m, isMounted: ip(), adjustedTo: Ku(r), mergedValue: H, handleTriggerClick() {
    O(true);
  }, handleClickOutside(Ee) {
    var ot;
    !((ot = l.value) === null || ot === void 0) && ot.contains(Ay(Ee)) || O(false);
  }, renderPanel: Ct, cssVars: M ? void 0 : Dr, themeClass: Cr == null ? void 0 : Cr.themeClass, onRender: Cr == null ? void 0 : Cr.onRender };
}, render() {
  const { mergedClsPrefix: r, onRender: i } = this;
  return i == null ? void 0 : i(), F("div", { class: [this.themeClass, `${r}-color-picker`], ref: "selfRef", style: this.cssVars }, F(My, null, { default: () => [F(Ey, null, { default: () => F(sP, { clsPrefix: r, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), F(Ry, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === Ku.tdkey, to: this.adjustedTo }, { default: () => F(Ao, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? va(this.renderPanel(), [[$f, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), gP = qe([ue("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), ue("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [Kf({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), vP = Object.assign(Object.assign({}, Yt.props), { to: Ku.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), mg = st({ name: "Select", props: vP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, namespaceRef: d, inlineThemeDisabled: f } = Tr(r), g = Yt("Select", "-select", gP, g2, r, i), m = Ae(r.defaultValue), s = Dt(r, "value"), C = Zi(s, m), T = Ae(false), M = Ae(""), z = jf(r, ["items", "options"]), L = Ae([]), A = Ae([]), O = ze(() => A.value.concat(L.value).concat(z.value)), U = ze(() => {
    const { filter: he } = r;
    if (he) return he;
    const { labelField: ve, valueField: je } = r;
    return (it, Xe) => {
      if (!Xe) return false;
      const wt = Xe[ve];
      if (typeof wt == "string") return Am(it, wt);
      const Pe = Xe[je];
      return typeof Pe == "string" ? Am(it, Pe) : typeof Pe == "number" ? Am(it, String(Pe)) : false;
    };
  }), X = ze(() => {
    if (r.remote) return z.value;
    {
      const { value: he } = O, { value: ve } = M;
      return !ve.length || !r.filterable ? he : Pk(he, U.value, ve, r.childrenField);
    }
  }), H = ze(() => {
    const { valueField: he, childrenField: ve } = r, je = kk(he, ve);
    return v2(X.value, je);
  }), Q = ze(() => Tk(O.value, r.valueField, r.childrenField)), ie = Ae(false), te = Zi(Dt(r, "show"), ie), re = Ae(null), J = Ae(null), Se = Ae(null), { localeRef: fe } = Ja("Select"), oe = ze(() => {
    var he;
    return (he = r.placeholder) !== null && he !== void 0 ? he : fe.value.placeholder;
  }), de = [], xe = Ae(/* @__PURE__ */ new Map()), $e = ze(() => {
    const { fallbackOption: he } = r;
    if (he === void 0) {
      const { labelField: ve, valueField: je } = r;
      return (it) => ({ [ve]: String(it), [je]: it });
    }
    return he === false ? false : (ve) => Object.assign(he(ve), { value: ve });
  });
  function Ve(he) {
    const ve = r.remote, { value: je } = xe, { value: it } = Q, { value: Xe } = $e, wt = [];
    return he.forEach((Pe) => {
      if (it.has(Pe)) wt.push(it.get(Pe));
      else if (ve && je.has(Pe)) wt.push(je.get(Pe));
      else if (Xe) {
        const $t = Xe(Pe);
        $t && wt.push($t);
      }
    }), wt;
  }
  const Ke = ze(() => {
    if (r.multiple) {
      const { value: he } = C;
      return Array.isArray(he) ? Ve(he) : [];
    }
    return null;
  }), lt = ze(() => {
    const { value: he } = C;
    return !r.multiple && !Array.isArray(he) ? he === null ? null : Ve([he])[0] || null : null;
  }), vt = ya(r), { mergedSizeRef: xt, mergedDisabledRef: at, mergedStatusRef: et } = vt;
  function ht(he, ve) {
    const { onChange: je, "onUpdate:value": it, onUpdateValue: Xe } = r, { nTriggerFormChange: wt, nTriggerFormInput: Pe } = vt;
    je && Ot(je, he, ve), Xe && Ot(Xe, he, ve), it && Ot(it, he, ve), m.value = he, wt(), Pe();
  }
  function yt(he) {
    const { onBlur: ve } = r, { nTriggerFormBlur: je } = vt;
    ve && Ot(ve, he), je();
  }
  function nt() {
    const { onClear: he } = r;
    he && Ot(he);
  }
  function ut(he) {
    const { onFocus: ve, showOnFocus: je } = r, { nTriggerFormFocus: it } = vt;
    ve && Ot(ve, he), it(), je && Jt();
  }
  function Lt(he) {
    const { onSearch: ve } = r;
    ve && Ot(ve, he);
  }
  function Ht(he) {
    const { onScroll: ve } = r;
    ve && Ot(ve, he);
  }
  function zt() {
    var he;
    const { remote: ve, multiple: je } = r;
    if (ve) {
      const { value: it } = xe;
      if (je) {
        const { valueField: Xe } = r;
        (he = Ke.value) === null || he === void 0 || he.forEach((wt) => {
          it.set(wt[Xe], wt);
        });
      } else {
        const Xe = lt.value;
        Xe && it.set(Xe[r.valueField], Xe);
      }
    }
  }
  function pr(he) {
    const { onUpdateShow: ve, "onUpdate:show": je } = r;
    ve && Ot(ve, he), je && Ot(je, he), ie.value = he;
  }
  function Jt() {
    at.value || (pr(true), ie.value = true, r.filterable && Y());
  }
  function tr() {
    pr(false);
  }
  function wr() {
    M.value = "", A.value = de;
  }
  const Er = Ae(false);
  function rr() {
    r.filterable && (Er.value = true);
  }
  function sr() {
    r.filterable && (Er.value = false, te.value || wr());
  }
  function qt() {
    at.value || (te.value ? r.filterable ? Y() : tr() : Jt());
  }
  function Dr(he) {
    var ve, je;
    !((je = (ve = Se.value) === null || ve === void 0 ? void 0 : ve.selfRef) === null || je === void 0) && je.contains(he.relatedTarget) || (T.value = false, yt(he), tr());
  }
  function Cr(he) {
    ut(he), T.value = true;
  }
  function Ct() {
    T.value = true;
  }
  function Ee(he) {
    var ve;
    !((ve = re.value) === null || ve === void 0) && ve.$el.contains(he.relatedTarget) || (T.value = false, yt(he), tr());
  }
  function ot() {
    var he;
    (he = re.value) === null || he === void 0 || he.focus(), tr();
  }
  function Le(he) {
    var ve;
    te.value && (!((ve = re.value) === null || ve === void 0) && ve.$el.contains(Ay(he)) || tr());
  }
  function Ye(he) {
    if (!Array.isArray(he)) return [];
    if ($e.value) return Array.from(he);
    {
      const { remote: ve } = r, { value: je } = Q;
      if (ve) {
        const { value: it } = xe;
        return he.filter((Xe) => je.has(Xe) || it.has(Xe));
      } else return he.filter((it) => je.has(it));
    }
  }
  function ft(he) {
    bt(he.rawNode);
  }
  function bt(he) {
    if (at.value) return;
    const { tag: ve, remote: je, clearFilterAfterSelect: it, valueField: Xe } = r;
    if (ve && !je) {
      const { value: wt } = A, Pe = wt[0] || null;
      if (Pe) {
        const $t = L.value;
        $t.length ? $t.push(Pe) : L.value = [Pe], A.value = de;
      }
    }
    if (je && xe.value.set(he[Xe], he), r.multiple) {
      const wt = Ye(C.value), Pe = wt.findIndex(($t) => $t === he[Xe]);
      if (~Pe) {
        if (wt.splice(Pe, 1), ve && !je) {
          const $t = tt(he[Xe]);
          ~$t && (L.value.splice($t, 1), it && (M.value = ""));
        }
      } else wt.push(he[Xe]), it && (M.value = "");
      ht(wt, Ve(wt));
    } else {
      if (ve && !je) {
        const wt = tt(he[Xe]);
        ~wt ? L.value = [L.value[wt]] : L.value = de;
      }
      Z(), tr(), ht(he[Xe], he);
    }
  }
  function tt(he) {
    return L.value.findIndex((je) => je[r.valueField] === he);
  }
  function mt(he) {
    te.value || Jt();
    const { value: ve } = he.target;
    M.value = ve;
    const { tag: je, remote: it } = r;
    if (Lt(ve), je && !it) {
      if (!ve) {
        A.value = de;
        return;
      }
      const { onCreate: Xe } = r, wt = Xe ? Xe(ve) : { [r.labelField]: ve, [r.valueField]: ve }, { valueField: Pe, labelField: $t } = r;
      z.value.some((Qt) => Qt[Pe] === wt[Pe] || Qt[$t] === wt[$t]) || L.value.some((Qt) => Qt[Pe] === wt[Pe] || Qt[$t] === wt[$t]) ? A.value = de : A.value = [wt];
    }
  }
  function Zt(he) {
    he.stopPropagation();
    const { multiple: ve } = r;
    !ve && r.filterable && tr(), nt(), ve ? ht([], []) : ht(null, null);
  }
  function ii(he) {
    !Tl(he, "action") && !Tl(he, "empty") && !Tl(he, "header") && he.preventDefault();
  }
  function wi(he) {
    Ht(he);
  }
  function Fe(he) {
    var ve, je, it, Xe, wt;
    if (!r.keyboard) {
      he.preventDefault();
      return;
    }
    switch (he.key) {
      case " ":
        if (r.filterable) break;
        he.preventDefault();
      case "Enter":
        if (!(!((ve = re.value) === null || ve === void 0) && ve.isComposing)) {
          if (te.value) {
            const Pe = (je = Se.value) === null || je === void 0 ? void 0 : je.getPendingTmNode();
            Pe ? ft(Pe) : r.filterable || (tr(), Z());
          } else if (Jt(), r.tag && Er.value) {
            const Pe = A.value[0];
            if (Pe) {
              const $t = Pe[r.valueField], { value: Qt } = C;
              r.multiple && Array.isArray(Qt) && Qt.includes($t) || bt(Pe);
            }
          }
        }
        he.preventDefault();
        break;
      case "ArrowUp":
        if (he.preventDefault(), r.loading) return;
        te.value && ((it = Se.value) === null || it === void 0 || it.prev());
        break;
      case "ArrowDown":
        if (he.preventDefault(), r.loading) return;
        te.value ? (Xe = Se.value) === null || Xe === void 0 || Xe.next() : Jt();
        break;
      case "Escape":
        te.value && (_2(he), tr()), (wt = re.value) === null || wt === void 0 || wt.focus();
        break;
    }
  }
  function Z() {
    var he;
    (he = re.value) === null || he === void 0 || he.focus();
  }
  function Y() {
    var he;
    (he = re.value) === null || he === void 0 || he.focusInput();
  }
  function ne() {
    var he;
    te.value && ((he = J.value) === null || he === void 0 || he.syncPosition());
  }
  zt(), ar(Dt(r, "options"), zt);
  const _e = { focus: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.focus();
  }, focusInput: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.focusInput();
  }, blur: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.blur();
  }, blurInput: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.blurInput();
  } }, Te = ze(() => {
    const { self: { menuBoxShadow: he } } = g.value;
    return { "--n-menu-box-shadow": he };
  }), De = f ? ci("select", void 0, Te, r) : void 0;
  return Object.assign(Object.assign({}, _e), { mergedStatus: et, mergedClsPrefix: i, mergedBordered: l, namespace: d, treeMate: H, isMounted: ip(), triggerRef: re, menuRef: Se, pattern: M, uncontrolledShow: ie, mergedShow: te, adjustedTo: Ku(r), uncontrolledValue: m, mergedValue: C, followerRef: J, localizedPlaceholder: oe, selectedOption: lt, selectedOptions: Ke, mergedSize: xt, mergedDisabled: at, focused: T, activeWithoutMenuOpen: Er, inlineThemeDisabled: f, onTriggerInputFocus: rr, onTriggerInputBlur: sr, handleTriggerOrMenuResize: ne, handleMenuFocus: Ct, handleMenuBlur: Ee, handleMenuTabOut: ot, handleTriggerClick: qt, handleToggle: ft, handleDeleteOption: bt, handlePatternInput: mt, handleClear: Zt, handleTriggerBlur: Dr, handleTriggerFocus: Cr, handleKeydown: Fe, handleMenuAfterLeave: wr, handleMenuClickOutside: Le, handleMenuScroll: wi, handleMenuKeydown: Fe, handleMenuMousedown: ii, mergedTheme: g, cssVars: f ? void 0 : Te, themeClass: De == null ? void 0 : De.themeClass, onRender: De == null ? void 0 : De.onRender });
}, render() {
  return F("div", { class: `${this.mergedClsPrefix}-select` }, F(My, null, { default: () => [F(Ey, null, { default: () => F(sk, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var r, i;
    return [(i = (r = this.$slots).arrow) === null || i === void 0 ? void 0 : i.call(r)];
  } }) }), F(Ry, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === Ku.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => F(Ao, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var r, i, l;
    return this.mergedShow || this.displayDirective === "show" ? ((r = this.onRender) === null || r === void 0 || r.call(this), va(F(rk, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (i = this.menuProps) === null || i === void 0 ? void 0 : i.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var d, f;
      return [(f = (d = this.$slots).empty) === null || f === void 0 ? void 0 : f.call(d)];
    }, header: () => {
      var d, f;
      return [(f = (d = this.$slots).header) === null || f === void 0 ? void 0 : f.call(d)];
    }, action: () => {
      var d, f;
      return [(f = (d = this.$slots).action) === null || f === void 0 ? void 0 : f.call(d)];
    } }), this.displayDirective === "show" ? [[Ka, this.mergedShow], [$f, this.handleMenuClickOutside, void 0, { capture: true }]] : [[$f, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), _P = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, wb = An("n-radio-group");
function yP(r) {
  const i = fr(wb, null), l = ya(r, { mergedSize(Q) {
    const { size: ie } = r;
    if (ie !== void 0) return ie;
    if (i) {
      const { mergedSizeRef: { value: te } } = i;
      if (te !== void 0) return te;
    }
    return Q ? Q.mergedSize.value : "medium";
  }, mergedDisabled(Q) {
    return !!(r.disabled || (i == null ? void 0 : i.disabledRef.value) || (Q == null ? void 0 : Q.disabled.value));
  } }), { mergedSizeRef: d, mergedDisabledRef: f } = l, g = Ae(null), m = Ae(null), s = Ae(r.defaultChecked), C = Dt(r, "checked"), T = Zi(C, s), M = pi(() => i ? i.valueRef.value === r.value : T.value), z = pi(() => {
    const { name: Q } = r;
    if (Q !== void 0) return Q;
    if (i) return i.nameRef.value;
  }), L = Ae(false);
  function A() {
    if (i) {
      const { doUpdateValue: Q } = i, { value: ie } = r;
      Ot(Q, ie);
    } else {
      const { onUpdateChecked: Q, "onUpdate:checked": ie } = r, { nTriggerFormInput: te, nTriggerFormChange: re } = l;
      Q && Ot(Q, true), ie && Ot(ie, true), te(), re(), s.value = true;
    }
  }
  function O() {
    f.value || M.value || A();
  }
  function U() {
    O(), g.value && (g.value.checked = M.value);
  }
  function X() {
    L.value = false;
  }
  function H() {
    L.value = true;
  }
  return { mergedClsPrefix: i ? i.mergedClsPrefixRef : Tr(r).mergedClsPrefixRef, inputRef: g, labelRef: m, mergedName: z, mergedDisabled: f, renderSafeChecked: M, focus: L, mergedSize: d, handleRadioInputChange: U, handleRadioInputBlur: X, handleRadioInputFocus: H };
}
const bP = st({ name: "RadioButton", props: _P, setup: yP, render() {
  const { mergedClsPrefix: r } = this;
  return F("label", { class: [`${r}-radio-button`, this.mergedDisabled && `${r}-radio-button--disabled`, this.renderSafeChecked && `${r}-radio-button--checked`, this.focus && [`${r}-radio-button--focus`]] }, F("input", { ref: "inputRef", type: "radio", class: `${r}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), F("div", { class: `${r}-radio-button__state-border` }), xi(this.$slots.default, (i) => !i && !this.label ? null : F("div", { ref: "labelRef", class: `${r}-radio__label` }, i || this.label)));
} }), xP = ue("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Re("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ue("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ue("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ue("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [ue("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Re("splitor", { height: "var(--n-height)" })]), ue("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [ue("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Re("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), qe("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Re("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), qe("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Re("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), ui("disabled", `
 cursor: pointer;
 `, [qe("&:hover", [Re("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), ui("checked", { color: "var(--n-button-text-color-hover)" })]), Ue("focus", [qe("&:not(:active)", [Re("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ue("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ue("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function wP(r, i, l) {
  var d;
  const f = [];
  let g = false;
  for (let m = 0; m < r.length; ++m) {
    const s = r[m], C = (d = s.type) === null || d === void 0 ? void 0 : d.name;
    C === "RadioButton" && (g = true);
    const T = s.props;
    if (C !== "RadioButton") {
      f.push(s);
      continue;
    }
    if (m === 0) f.push(s);
    else {
      const M = f[f.length - 1].props, z = i === M.value, L = M.disabled, A = i === T.value, O = T.disabled, U = (z ? 2 : 0) + (L ? 0 : 1), X = (A ? 2 : 0) + (O ? 0 : 1), H = { [`${l}-radio-group__splitor--disabled`]: L, [`${l}-radio-group__splitor--checked`]: z }, Q = { [`${l}-radio-group__splitor--disabled`]: O, [`${l}-radio-group__splitor--checked`]: A }, ie = U < X ? Q : H;
      f.push(F("div", { class: [`${l}-radio-group__splitor`, ie] }), s);
    }
  }
  return { children: f, isButtonGroup: g };
}
const CP = Object.assign(Object.assign({}, Yt.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), SP = st({ name: "RadioGroup", props: CP, setup(r) {
  const i = Ae(null), { mergedSizeRef: l, mergedDisabledRef: d, nTriggerFormChange: f, nTriggerFormInput: g, nTriggerFormBlur: m, nTriggerFormFocus: s } = ya(r), { mergedClsPrefixRef: C, inlineThemeDisabled: T, mergedRtlRef: M } = Tr(r), z = Yt("Radio", "-radio-group", xP, y2, r, C), L = Ae(r.defaultValue), A = Dt(r, "value"), O = Zi(A, L);
  function U(re) {
    const { onUpdateValue: J, "onUpdate:value": Se } = r;
    J && Ot(J, re), Se && Ot(Se, re), L.value = re, f(), g();
  }
  function X(re) {
    const { value: J } = i;
    J && (J.contains(re.relatedTarget) || s());
  }
  function H(re) {
    const { value: J } = i;
    J && (J.contains(re.relatedTarget) || m());
  }
  Jr(wb, { mergedClsPrefixRef: C, nameRef: Dt(r, "name"), valueRef: O, disabledRef: d, mergedSizeRef: l, doUpdateValue: U });
  const Q = Rn("Radio", M, C), ie = ze(() => {
    const { value: re } = l, { common: { cubicBezierEaseInOut: J }, self: { buttonBorderColor: Se, buttonBorderColorActive: fe, buttonBorderRadius: oe, buttonBoxShadow: de, buttonBoxShadowFocus: xe, buttonBoxShadowHover: $e, buttonColor: Ve, buttonColorActive: Ke, buttonTextColor: lt, buttonTextColorActive: vt, buttonTextColorHover: xt, opacityDisabled: at, [jt("buttonHeight", re)]: et, [jt("fontSize", re)]: ht } } = z.value;
    return { "--n-font-size": ht, "--n-bezier": J, "--n-button-border-color": Se, "--n-button-border-color-active": fe, "--n-button-border-radius": oe, "--n-button-box-shadow": de, "--n-button-box-shadow-focus": xe, "--n-button-box-shadow-hover": $e, "--n-button-color": Ve, "--n-button-color-active": Ke, "--n-button-text-color": lt, "--n-button-text-color-hover": xt, "--n-button-text-color-active": vt, "--n-height": et, "--n-opacity-disabled": at };
  }), te = T ? ci("radio-group", ze(() => l.value[0]), ie, r) : void 0;
  return { selfElRef: i, rtlEnabled: Q, mergedClsPrefix: C, mergedValue: O, handleFocusout: H, handleFocusin: X, cssVars: T ? void 0 : ie, themeClass: te == null ? void 0 : te.themeClass, onRender: te == null ? void 0 : te.onRender };
}, render() {
  var r;
  const { mergedValue: i, mergedClsPrefix: l, handleFocusin: d, handleFocusout: f } = this, { children: g, isButtonGroup: m } = wP(El(op(this)), i, l);
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { onFocusin: d, onFocusout: f, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, m && `${l}-radio-group--button-group`], style: this.cssVars }, g);
} }), Cb = ue("ellipsis", { overflow: "hidden" }, [ui("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ue("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ue("cursor-pointer", `
 cursor: pointer;
 `)]);
function gg(r) {
  return `${r}-ellipsis--line-clamp`;
}
function vg(r, i) {
  return `${r}-ellipsis--cursor-${i}`;
}
const Sb = Object.assign(Object.assign({}, Yt.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), kP = st({ name: "Ellipsis", inheritAttrs: false, props: Sb, slots: Object, setup(r, { slots: i, attrs: l }) {
  const d = zy(), f = Yt("Ellipsis", "-ellipsis", Cb, b2, r, d), g = Ae(null), m = Ae(null), s = Ae(null), C = Ae(false), T = ze(() => {
    const { lineClamp: X } = r, { value: H } = C;
    return X !== void 0 ? { textOverflow: "", "-webkit-line-clamp": H ? "" : X } : { textOverflow: H ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function M() {
    let X = false;
    const { value: H } = C;
    if (H) return true;
    const { value: Q } = g;
    if (Q) {
      const { lineClamp: ie } = r;
      if (A(Q), ie !== void 0) X = Q.scrollHeight <= Q.offsetHeight;
      else {
        const { value: te } = m;
        te && (X = te.getBoundingClientRect().width <= Q.getBoundingClientRect().width);
      }
      O(Q, X);
    }
    return X;
  }
  const z = ze(() => r.expandTrigger === "click" ? () => {
    var X;
    const { value: H } = C;
    H && ((X = s.value) === null || X === void 0 || X.setShow(false)), C.value = !H;
  } : void 0);
  vy(() => {
    var X;
    r.tooltip && ((X = s.value) === null || X === void 0 || X.setShow(false));
  });
  const L = () => F("span", Object.assign({}, Ya(l, { class: [`${d.value}-ellipsis`, r.lineClamp !== void 0 ? gg(d.value) : void 0, r.expandTrigger === "click" ? vg(d.value, "pointer") : void 0], style: T.value }), { ref: "triggerRef", onClick: z.value, onMouseenter: r.expandTrigger === "click" ? M : void 0 }), r.lineClamp ? i : F("span", { ref: "triggerInnerRef" }, i));
  function A(X) {
    if (!X) return;
    const H = T.value, Q = gg(d.value);
    r.lineClamp !== void 0 ? U(X, Q, "add") : U(X, Q, "remove");
    for (const ie in H) X.style[ie] !== H[ie] && (X.style[ie] = H[ie]);
  }
  function O(X, H) {
    const Q = vg(d.value, "pointer");
    r.expandTrigger === "click" && !H ? U(X, Q, "add") : U(X, Q, "remove");
  }
  function U(X, H, Q) {
    Q === "add" ? X.classList.contains(H) || X.classList.add(H) : X.classList.contains(H) && X.classList.remove(H);
  }
  return { mergedTheme: f, triggerRef: g, triggerInnerRef: m, tooltipRef: s, handleClick: z, renderTrigger: L, getTooltipDisabled: M };
}, render() {
  var r;
  const { tooltip: i, renderTrigger: l, $slots: d } = this;
  if (i) {
    const { mergedTheme: f } = this;
    return F(Dy, Object.assign({ ref: "tooltipRef", placement: "top" }, i, { getDisabled: this.getTooltipDisabled, theme: f.peers.Tooltip, themeOverrides: f.peerOverrides.Tooltip }), { trigger: l, default: (r = d.tooltip) !== null && r !== void 0 ? r : d.default });
  } else return l();
} }), PP = st({ name: "PerformantEllipsis", props: Sb, inheritAttrs: false, setup(r, { attrs: i, slots: l }) {
  const d = Ae(false), f = zy();
  return oc("-ellipsis", Cb, f), { mouseEntered: d, renderTrigger: () => {
    const { lineClamp: m } = r, s = f.value;
    return F("span", Object.assign({}, Ya(i, { class: [`${s}-ellipsis`, m !== void 0 ? gg(s) : void 0, r.expandTrigger === "click" ? vg(s, "pointer") : void 0], style: m === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": m } }), { onMouseenter: () => {
      d.value = true;
    } }), m ? l : F("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? F(kP, Ya({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function kb() {
  const r = fr(x2, null);
  return r === null && Yo("use-dialog", "No outer <n-dialog-provider /> founded."), r;
}
function sp() {
  const r = fr(w2, null);
  return r === null && Yo("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), r;
}
const TP = ue("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [ui("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [ui("no-title", `
 display: flex;
 align-items: center;
 `)]), Re("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ue("title-position-left", [Re("line", [Ue("left", { width: "28px" })])]), Ue("title-position-right", [Re("line", [Ue("right", { width: "28px" })])]), Ue("dashed", [Re("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ue("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Re("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), ui("dashed", [Re("line", { backgroundColor: "var(--n-color)" })]), Ue("dashed", [Re("line", { borderColor: "var(--n-color)" })]), Ue("vertical", { backgroundColor: "var(--n-color)" })]), IP = Object.assign(Object.assign({}, Yt.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), MP = st({ name: "Divider", props: IP, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Yt("Divider", "-divider", TP, C2, r, i), f = ze(() => {
    const { common: { cubicBezierEaseInOut: m }, self: { color: s, textColor: C, fontWeight: T } } = d.value;
    return { "--n-bezier": m, "--n-color": s, "--n-text-color": C, "--n-font-weight": T };
  }), g = l ? ci("divider", void 0, f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  const { $slots: i, titlePlacement: l, vertical: d, dashed: f, cssVars: g, mergedClsPrefix: m } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { role: "separator", class: [`${m}-divider`, this.themeClass, { [`${m}-divider--vertical`]: d, [`${m}-divider--no-title`]: !i.default, [`${m}-divider--dashed`]: f, [`${m}-divider--title-position-${l}`]: i.default && l }], style: g }, d ? null : F("div", { class: `${m}-divider__line ${m}-divider__line--left` }), !d && i.default ? F(qr, null, F("div", { class: `${m}-divider__title` }, this.$slots), F("div", { class: `${m}-divider__line ${m}-divider__line--right` })) : null);
} }), EP = st({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(r) {
  const i = Ae(!!r.show), l = Ae(null), d = fr(jg);
  let f = 0, g = "", m = null;
  const s = Ae(false), C = Ae(false), T = ze(() => r.placement === "top" || r.placement === "bottom"), { mergedClsPrefixRef: M, mergedRtlRef: z } = Tr(r), L = Rn("Drawer", z, M), A = J, O = (oe) => {
    C.value = true, f = T.value ? oe.clientY : oe.clientX, g = document.body.style.cursor, document.body.style.cursor = T.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", re), document.body.addEventListener("mouseleave", A), document.body.addEventListener("mouseup", J);
  }, U = () => {
    m !== null && (window.clearTimeout(m), m = null), C.value ? s.value = true : m = window.setTimeout(() => {
      s.value = true;
    }, 300);
  }, X = () => {
    m !== null && (window.clearTimeout(m), m = null), s.value = false;
  }, { doUpdateHeight: H, doUpdateWidth: Q } = d, ie = (oe) => {
    const { maxWidth: de } = r;
    if (de && oe > de) return de;
    const { minWidth: xe } = r;
    return xe && oe < xe ? xe : oe;
  }, te = (oe) => {
    const { maxHeight: de } = r;
    if (de && oe > de) return de;
    const { minHeight: xe } = r;
    return xe && oe < xe ? xe : oe;
  };
  function re(oe) {
    var de, xe;
    if (C.value) if (T.value) {
      let $e = ((de = l.value) === null || de === void 0 ? void 0 : de.offsetHeight) || 0;
      const Ve = f - oe.clientY;
      $e += r.placement === "bottom" ? Ve : -Ve, $e = te($e), H($e), f = oe.clientY;
    } else {
      let $e = ((xe = l.value) === null || xe === void 0 ? void 0 : xe.offsetWidth) || 0;
      const Ve = f - oe.clientX;
      $e += r.placement === "right" ? Ve : -Ve, $e = ie($e), Q($e), f = oe.clientX;
    }
  }
  function J() {
    C.value && (f = 0, C.value = false, document.body.style.cursor = g, document.body.removeEventListener("mousemove", re), document.body.removeEventListener("mouseup", J), document.body.removeEventListener("mouseleave", A));
  }
  vo(() => {
    r.show && (i.value = true);
  }), ar(() => r.show, (oe) => {
    oe || J();
  }), Cn(() => {
    J();
  });
  const Se = ze(() => {
    const { show: oe } = r, de = [[Ka, oe]];
    return r.showMask || de.push([$f, r.onClickoutside, void 0, { capture: true }]), de;
  });
  function fe() {
    var oe;
    i.value = false, (oe = r.onAfterLeave) === null || oe === void 0 || oe.call(r);
  }
  return k2(ze(() => r.blockScroll && i.value)), Jr(P2, l), Jr(T2, null), Jr(I2, null), { bodyRef: l, rtlEnabled: L, mergedClsPrefix: d.mergedClsPrefixRef, isMounted: d.isMountedRef, mergedTheme: d.mergedThemeRef, displayed: i, transitionName: ze(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[r.placement]), handleAfterLeave: fe, bodyDirectives: Se, handleMousedownResizeTrigger: O, handleMouseenterResizeTrigger: U, handleMouseleaveResizeTrigger: X, isDragging: C, isHoverOnResizeTrigger: s };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? va(F("div", { role: "none" }, F(S2, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => F(Ao, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => va(F("div", Ya(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${i}-drawer`, this.rtlEnabled && `${i}-drawer--rtl`, `${i}-drawer--${this.placement}-placement`, this.isDragging && `${i}-drawer--unselectable`, this.nativeScrollbar && `${i}-drawer--native-scrollbar`] }), [this.resizable ? F("div", { class: [`${i}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${i}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? F("div", { class: [`${i}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, r) : F(Yd, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${i}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), r)]), this.bodyDirectives) }) })), [[Ka, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: RP, cubicBezierEaseOut: AP } = Kd;
function DP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${RP}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${AP}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: zP, cubicBezierEaseOut: FP } = Kd;
function LP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${zP}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${FP}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: BP, cubicBezierEaseOut: OP } = Kd;
function $P({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${BP}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${OP}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: jP, cubicBezierEaseOut: NP } = Kd;
function VP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${jP}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${NP}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const UP = qe([ue("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [$P(), LP(), VP(), DP(), Ue("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ue("native-scrollbar", [ue("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Re("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), ue("drawer-content-wrapper", `
 box-sizing: border-box;
 `), ue("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ue("native-scrollbar", [ue("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), ue("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), ue("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), ue("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Re("main", `
 flex: 1;
 `), Re("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), ue("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ue("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ue("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ue("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ue("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), qe("body", [qe(">", [ue("drawer-container", `
 position: fixed;
 `)])]), ue("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [qe("> *", `
 pointer-events: all;
 `)]), ue("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), Nf({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), GP = Object.assign(Object.assign({}, Yt.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), Pb = st({ name: "Drawer", inheritAttrs: false, props: GP, setup(r) {
  const { mergedClsPrefixRef: i, namespaceRef: l, inlineThemeDisabled: d } = Tr(r), f = ip(), g = Yt("Drawer", "-drawer", UP, M2, r, i), m = Ae(r.defaultWidth), s = Ae(r.defaultHeight), C = Zi(Dt(r, "width"), m), T = Zi(Dt(r, "height"), s), M = ze(() => {
    const { placement: J } = r;
    return J === "top" || J === "bottom" ? "" : Ho(C.value);
  }), z = ze(() => {
    const { placement: J } = r;
    return J === "left" || J === "right" ? "" : Ho(T.value);
  }), L = (J) => {
    const { onUpdateWidth: Se, "onUpdate:width": fe } = r;
    Se && Ot(Se, J), fe && Ot(fe, J), m.value = J;
  }, A = (J) => {
    const { onUpdateHeight: Se, "onUpdate:width": fe } = r;
    Se && Ot(Se, J), fe && Ot(fe, J), s.value = J;
  }, O = ze(() => [{ width: M.value, height: z.value }, r.drawerStyle || ""]);
  function U(J) {
    const { onMaskClick: Se, maskClosable: fe } = r;
    fe && ie(false), Se && Se(J);
  }
  function X(J) {
    U(J);
  }
  const H = E2();
  function Q(J) {
    var Se;
    (Se = r.onEsc) === null || Se === void 0 || Se.call(r), r.show && r.closeOnEsc && R2(J) && (H.value || ie(false));
  }
  function ie(J) {
    const { onHide: Se, onUpdateShow: fe, "onUpdate:show": oe } = r;
    fe && Ot(fe, J), oe && Ot(oe, J), Se && !J && Ot(Se, J);
  }
  Jr(jg, { isMountedRef: f, mergedThemeRef: g, mergedClsPrefixRef: i, doUpdateShow: ie, doUpdateHeight: A, doUpdateWidth: L });
  const te = ze(() => {
    const { common: { cubicBezierEaseInOut: J, cubicBezierEaseIn: Se, cubicBezierEaseOut: fe }, self: { color: oe, textColor: de, boxShadow: xe, lineHeight: $e, headerPadding: Ve, footerPadding: Ke, borderRadius: lt, bodyPadding: vt, titleFontSize: xt, titleTextColor: at, titleFontWeight: et, headerBorderBottom: ht, footerBorderTop: yt, closeIconColor: nt, closeIconColorHover: ut, closeIconColorPressed: Lt, closeColorHover: Ht, closeColorPressed: zt, closeIconSize: pr, closeSize: Jt, closeBorderRadius: tr, resizableTriggerColorHover: wr } } = g.value;
    return { "--n-line-height": $e, "--n-color": oe, "--n-border-radius": lt, "--n-text-color": de, "--n-box-shadow": xe, "--n-bezier": J, "--n-bezier-out": fe, "--n-bezier-in": Se, "--n-header-padding": Ve, "--n-body-padding": vt, "--n-footer-padding": Ke, "--n-title-text-color": at, "--n-title-font-size": xt, "--n-title-font-weight": et, "--n-header-border-bottom": ht, "--n-footer-border-top": yt, "--n-close-icon-color": nt, "--n-close-icon-color-hover": ut, "--n-close-icon-color-pressed": Lt, "--n-close-size": Jt, "--n-close-color-hover": Ht, "--n-close-color-pressed": zt, "--n-close-icon-size": pr, "--n-close-border-radius": tr, "--n-resize-trigger-color-hover": wr };
  }), re = d ? ci("drawer", void 0, te, r) : void 0;
  return { mergedClsPrefix: i, namespace: l, mergedBodyStyle: O, handleOutsideClick: X, handleMaskClick: U, handleEsc: Q, mergedTheme: g, cssVars: d ? void 0 : te, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender, isMounted: f };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F(Ly, { to: this.to, show: this.show }, { default: () => {
    var i;
    return (i = this.onRender) === null || i === void 0 || i.call(this), va(F("div", { class: [`${r}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? F(Ao, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? F("div", { "aria-hidden": true, class: [`${r}-drawer-mask`, this.showMask === "transparent" && `${r}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, F(EP, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[Fy, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), qP = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, Tb = st({ name: "DrawerContent", props: qP, slots: Object, setup() {
  const r = fr(jg, null);
  r || Yo("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: i } = r;
  function l() {
    i(false);
  }
  return { handleCloseClick: l, mergedTheme: r.mergedThemeRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { title: r, mergedClsPrefix: i, nativeScrollbar: l, mergedTheme: d, bodyClass: f, bodyStyle: g, bodyContentClass: m, bodyContentStyle: s, headerClass: C, headerStyle: T, footerClass: M, footerStyle: z, scrollbarProps: L, closable: A, $slots: O } = this;
  return F("div", { role: "none", class: [`${i}-drawer-content`, l && `${i}-drawer-content--native-scrollbar`] }, O.header || r || A ? F("div", { class: [`${i}-drawer-header`, C], style: T, role: "none" }, F("div", { class: `${i}-drawer-header__main`, role: "heading", "aria-level": "1" }, O.header !== void 0 ? O.header() : r), A && F(Qf, { onClick: this.handleCloseClick, clsPrefix: i, class: `${i}-drawer-header__close`, absolute: true })) : null, l ? F("div", { class: [`${i}-drawer-body`, f], style: g, role: "none" }, F("div", { class: [`${i}-drawer-body-content-wrapper`, m], style: s, role: "none" }, O)) : F(Yd, Object.assign({ themeOverrides: d.peerOverrides.Scrollbar, theme: d.peers.Scrollbar }, L, { class: `${i}-drawer-body`, contentClass: [`${i}-drawer-body-content-wrapper`, m], contentStyle: s }), O), O.footer ? F("div", { class: [`${i}-drawer-footer`, M], style: z, role: "none" }, O.footer()) : null);
} });
let Bm;
function WP() {
  if (!rp) return true;
  if (Bm === void 0) {
    const r = document.createElement("div");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.rowGap = "1px", r.appendChild(document.createElement("div")), r.appendChild(document.createElement("div")), document.body.appendChild(r);
    const i = r.scrollHeight === 1;
    return document.body.removeChild(r), Bm = i;
  }
  return Bm;
}
const ZP = Object.assign(Object.assign({}, Yt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), Cl = st({ name: "Space", props: ZP, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Yt("Space", "-space", void 0, A2, r, i), f = Rn("Space", l, i);
  return { useGap: WP(), rtlEnabled: f, mergedClsPrefix: i, margin: ze(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [jt("gap", g)]: m } } = d.value, { row: s, col: C } = By(m);
    return { horizontal: Ji(C), vertical: Ji(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, itemClass: g, itemStyle: m, margin: s, wrap: C, mergedClsPrefix: T, rtlEnabled: M, useGap: z, wrapItem: L, internalUseGap: A } = this, O = El(op(this), false);
  if (!O.length) return null;
  const U = `${s.horizontal}px`, X = `${s.horizontal / 2}px`, H = `${s.vertical}px`, Q = `${s.vertical / 2}px`, ie = O.length - 1, te = f.startsWith("space-");
  return F("div", { role: "none", class: [`${T}-space`, M && `${T}-space--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(f) ? `flex-${f}` : f, flexWrap: !C || r ? "nowrap" : "wrap", marginTop: z || r ? "" : `-${Q}`, marginBottom: z || r ? "" : `-${Q}`, alignItems: l, gap: z ? `${s.vertical}px ${s.horizontal}px` : "" } }, !L && (z || A) ? O : O.map((re, J) => re.type === Ow ? re : F("div", { role: "none", class: g, style: [m, { maxWidth: "100%" }, z ? "" : r ? { marginBottom: J !== ie ? H : "" } : M ? { marginLeft: te ? f === "space-between" && J === ie ? "" : X : J !== ie ? U : "", marginRight: te ? f === "space-between" && J === 0 ? "" : X : "", paddingTop: Q, paddingBottom: Q } : { marginRight: te ? f === "space-between" && J === ie ? "" : X : J !== ie ? U : "", marginLeft: te ? f === "space-between" && J === 0 ? "" : X : "", paddingTop: Q, paddingBottom: Q }] }, re)));
} }), HP = ue("dynamic-tags", [ue("input", { minWidth: "var(--n-input-width)" })]), XP = Object.assign(Object.assign(Object.assign({}, Yt.props), pb), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (r) => r }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), YP = st({ name: "DynamicTags", props: XP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), { localeRef: d } = Ja("DynamicTags"), f = ya(r), { mergedDisabledRef: g } = f, m = Ae(""), s = Ae(false), C = Ae(true), T = Ae(null), M = Yt("DynamicTags", "-dynamic-tags", HP, D2, r, i), z = Ae(r.defaultValue), L = Dt(r, "value"), A = Zi(L, z), O = ze(() => d.value.add), U = ze(() => W3(r.size)), X = ze(() => g.value || !!r.max && A.value.length >= r.max);
  function H(oe) {
    const { onChange: de, "onUpdate:value": xe, onUpdateValue: $e } = r, { nTriggerFormInput: Ve, nTriggerFormChange: Ke } = f;
    de && Ot(de, oe), $e && Ot($e, oe), xe && Ot(xe, oe), z.value = oe, Ve(), Ke();
  }
  function Q(oe) {
    const de = A.value.slice(0);
    de.splice(oe, 1), H(de);
  }
  function ie(oe) {
    switch (oe.key) {
      case "Enter":
        te();
    }
  }
  function te(oe) {
    const de = oe ?? m.value;
    if (de) {
      const xe = A.value.slice(0);
      xe.push(r.onCreate(de)), H(xe);
    }
    s.value = false, C.value = true, m.value = "";
  }
  function re() {
    te();
  }
  function J() {
    s.value = true, Nn(() => {
      var oe;
      (oe = T.value) === null || oe === void 0 || oe.focus(), C.value = false;
    });
  }
  const Se = ze(() => {
    const { self: { inputWidth: oe } } = M.value;
    return { "--n-input-width": oe };
  }), fe = l ? ci("dynamic-tags", void 0, Se, r) : void 0;
  return { mergedClsPrefix: i, inputInstRef: T, localizedAdd: O, inputSize: U, inputValue: m, showInput: s, inputForceFocused: C, mergedValue: A, mergedDisabled: g, triggerDisabled: X, handleInputKeyDown: ie, handleAddClick: J, handleInputBlur: re, handleCloseClick: Q, handleInputConfirm: te, mergedTheme: M, cssVars: l ? void 0 : Se, themeClass: fe == null ? void 0 : fe.themeClass, onRender: fe == null ? void 0 : fe.onRender };
}, render() {
  const { mergedTheme: r, cssVars: i, mergedClsPrefix: l, onRender: d, renderTag: f } = this;
  return d == null ? void 0 : d(), F(Cl, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: i, theme: r.peers.Space, themeOverrides: r.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: g, tagClass: m, tagStyle: s, type: C, round: T, size: M, color: z, closable: L, mergedDisabled: A, showInput: O, inputValue: U, inputClass: X, inputStyle: H, inputSize: Q, inputForceFocused: ie, triggerDisabled: te, handleInputKeyDown: re, handleInputBlur: J, handleAddClick: Se, handleCloseClick: fe, handleInputConfirm: oe, $slots: de } = this;
    return this.mergedValue.map((xe, $e) => f ? f(xe, $e) : F(Do, { key: $e, theme: g.peers.Tag, themeOverrides: g.peerOverrides.Tag, class: m, style: s, type: C, round: T, size: M, color: z, closable: L, disabled: A, onClose: () => {
      fe($e);
    } }, { default: () => typeof xe == "string" ? xe : xe.label })).concat(O ? de.input ? de.input({ submit: oe, deactivate: J }) : F(mo, Object.assign({ placeholder: "", size: Q, style: H, class: X, autosize: true }, this.inputProps, { ref: "inputInstRef", value: U, onUpdateValue: (xe) => {
      this.inputValue = xe;
    }, theme: g.peers.Input, themeOverrides: g.peerOverrides.Input, onKeydown: re, onBlur: J, internalForceFocus: ie })) : de.trigger ? de.trigger({ activate: Se, disabled: te }) : F(Vr, { dashed: true, disabled: te, theme: g.peers.Button, themeOverrides: g.peerOverrides.Button, size: Q, onClick: Se }, { icon: () => F(Nr, { clsPrefix: l }, { default: () => F(ap, null) }) }));
  } });
} }), KP = Object.assign(Object.assign({}, Yt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), u_ = st({ name: "Flex", props: KP, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Yt("Flex", "-flex", void 0, z2, r, i);
  return { rtlEnabled: Rn("Flex", l, i), mergedClsPrefix: i, margin: ze(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [jt("gap", g)]: m } } = d.value, { row: s, col: C } = By(m);
    return { horizontal: Ji(C), vertical: Ji(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, margin: g, wrap: m, mergedClsPrefix: s, rtlEnabled: C } = this, T = El(op(this), false);
  return T.length ? F("div", { role: "none", class: [`${s}-flex`, C && `${s}-flex--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: f, flexWrap: !m || r ? "nowrap" : "wrap", alignItems: l, gap: `${g.vertical}px ${g.horizontal}px` } }, T) : null;
} }), Jd = An("n-form"), Ib = An("n-form-item-insts"), JP = ue("form", [Ue("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [ue("form-item", { width: "auto", marginRight: "18px" }, [qe("&:last-child", { marginRight: 0 })])])]);
var QP = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const eT = Object.assign(Object.assign({}, Yt.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (r) => {
  r.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), Nd = st({ name: "Form", props: eT, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  Yt("Form", "-form", JP, Oy, r, i);
  const l = {}, d = Ae(void 0), f = (C) => {
    const T = d.value;
    (T === void 0 || C >= T) && (d.value = C);
  };
  function g(C) {
    return QP(this, arguments, void 0, function* (T, M = () => true) {
      return yield new Promise((z, L) => {
        const A = [];
        for (const O of Fd(l)) {
          const U = l[O];
          for (const X of U) X.path && A.push(X.internalValidate(null, M));
        }
        Promise.all(A).then((O) => {
          const U = O.some((Q) => !Q.valid), X = [], H = [];
          O.forEach((Q) => {
            var ie, te;
            !((ie = Q.errors) === null || ie === void 0) && ie.length && X.push(Q.errors), !((te = Q.warnings) === null || te === void 0) && te.length && H.push(Q.warnings);
          }), T && T(X.length ? X : void 0, { warnings: H.length ? H : void 0 }), U ? L(X.length ? X : void 0) : z({ warnings: H.length ? H : void 0 });
        });
      });
    });
  }
  function m() {
    for (const C of Fd(l)) {
      const T = l[C];
      for (const M of T) M.restoreValidation();
    }
  }
  return Jr(Jd, { props: r, maxChildLabelWidthRef: d, deriveMaxChildLabelWidth: f }), Jr(Ib, { formItems: l }), Object.assign({ validate: g, restoreValidation: m }, { mergedClsPrefix: i });
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("form", { class: [`${r}-form`, this.inline && `${r}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function Sl() {
  return Sl = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) Object.prototype.hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, Sl.apply(this, arguments);
}
function tT(r, i) {
  r.prototype = Object.create(i.prototype), r.prototype.constructor = r, Vd(r, i);
}
function _g(r) {
  return _g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, _g(r);
}
function Vd(r, i) {
  return Vd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, f) {
    return d.__proto__ = f, d;
  }, Vd(r, i);
}
function rT() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function Df(r, i, l) {
  return rT() ? Df = Reflect.construct.bind() : Df = function(f, g, m) {
    var s = [null];
    s.push.apply(s, g);
    var C = Function.bind.apply(f, s), T = new C();
    return m && Vd(T, m.prototype), T;
  }, Df.apply(null, arguments);
}
function iT(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function yg(r) {
  var i = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return yg = function(d) {
    if (d === null || !iT(d)) return d;
    if (typeof d != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof i < "u") {
      if (i.has(d)) return i.get(d);
      i.set(d, f);
    }
    function f() {
      return Df(d, arguments, _g(this).constructor);
    }
    return f.prototype = Object.create(d.prototype, { constructor: { value: f, enumerable: false, writable: true, configurable: true } }), Vd(f, d);
  }, yg(r);
}
var nT = /%[sdj%]/g, oT = function() {
};
function bg(r) {
  if (!r || !r.length) return null;
  var i = {};
  return r.forEach(function(l) {
    var d = l.field;
    i[d] = i[d] || [], i[d].push(l);
  }), i;
}
function go(r) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), d = 1; d < i; d++) l[d - 1] = arguments[d];
  var f = 0, g = l.length;
  if (typeof r == "function") return r.apply(null, l);
  if (typeof r == "string") {
    var m = r.replace(nT, function(s) {
      if (s === "%%") return "%";
      if (f >= g) return s;
      switch (s) {
        case "%s":
          return String(l[f++]);
        case "%d":
          return Number(l[f++]);
        case "%j":
          try {
            return JSON.stringify(l[f++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return m;
  }
  return r;
}
function aT(r) {
  return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern";
}
function en(r, i) {
  return !!(r == null || i === "array" && Array.isArray(r) && !r.length || aT(i) && typeof r == "string" && !r);
}
function sT(r, i, l) {
  var d = [], f = 0, g = r.length;
  function m(s) {
    d.push.apply(d, s || []), f++, f === g && l(d);
  }
  r.forEach(function(s) {
    i(s, m);
  });
}
function c_(r, i, l) {
  var d = 0, f = r.length;
  function g(m) {
    if (m && m.length) {
      l(m);
      return;
    }
    var s = d;
    d = d + 1, s < f ? i(r[s], g) : l([]);
  }
  g([]);
}
function lT(r) {
  var i = [];
  return Object.keys(r).forEach(function(l) {
    i.push.apply(i, r[l] || []);
  }), i;
}
var d_ = (function(r) {
  tT(i, r);
  function i(l, d) {
    var f;
    return f = r.call(this, "Async Validation Error") || this, f.errors = l, f.fields = d, f;
  }
  return i;
})(yg(Error));
function uT(r, i, l, d, f) {
  if (i.first) {
    var g = new Promise(function(L, A) {
      var O = function(H) {
        return d(H), H.length ? A(new d_(H, bg(H))) : L(f);
      }, U = lT(r);
      c_(U, l, O);
    });
    return g.catch(function(L) {
      return L;
    }), g;
  }
  var m = i.firstFields === true ? Object.keys(r) : i.firstFields || [], s = Object.keys(r), C = s.length, T = 0, M = [], z = new Promise(function(L, A) {
    var O = function(X) {
      if (M.push.apply(M, X), T++, T === C) return d(M), M.length ? A(new d_(M, bg(M))) : L(f);
    };
    s.length || (d(M), L(f)), s.forEach(function(U) {
      var X = r[U];
      m.indexOf(U) !== -1 ? c_(X, l, O) : sT(X, l, O);
    });
  });
  return z.catch(function(L) {
    return L;
  }), z;
}
function cT(r) {
  return !!(r && r.message !== void 0);
}
function dT(r, i) {
  for (var l = r, d = 0; d < i.length; d++) {
    if (l == null) return l;
    l = l[i[d]];
  }
  return l;
}
function h_(r, i) {
  return function(l) {
    var d;
    return r.fullFields ? d = dT(i, r.fullFields) : d = i[l.field || r.fullField], cT(l) ? (l.field = l.field || r.fullField, l.fieldValue = d, l) : { message: typeof l == "function" ? l() : l, fieldValue: d, field: l.field || r.fullField };
  };
}
function f_(r, i) {
  if (i) {
    for (var l in i) if (i.hasOwnProperty(l)) {
      var d = i[l];
      typeof d == "object" && typeof r[l] == "object" ? r[l] = Sl({}, r[l], d) : r[l] = d;
    }
  }
  return r;
}
var Mb = function(i, l, d, f, g, m) {
  i.required && (!d.hasOwnProperty(i.field) || en(l, m || i.type)) && f.push(go(g.messages.required, i.fullField));
}, hT = function(i, l, d, f, g) {
  (/^\s+$/.test(l) || l === "") && f.push(go(g.messages.whitespace, i.fullField));
}, yf, fT = (function() {
  if (yf) return yf;
  var r = "[a-fA-F\\d:]", i = function(te) {
    return te && te.includeBoundaries ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", d = "[a-fA-F\\d]{1,4}", f = (`
(?:
(?:` + d + ":){7}(?:" + d + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + d + ":){6}(?:" + l + "|:" + d + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + d + ":){5}(?::" + l + "|(?::" + d + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + d + ":){4}(?:(?::" + d + "){0,1}:" + l + "|(?::" + d + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + d + ":){3}(?:(?::" + d + "){0,2}:" + l + "|(?::" + d + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + d + ":){2}(?:(?::" + d + "){0,3}:" + l + "|(?::" + d + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + d + ":){1}(?:(?::" + d + "){0,4}:" + l + "|(?::" + d + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + d + "){0,5}:" + l + "|(?::" + d + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), g = new RegExp("(?:^" + l + "$)|(?:^" + f + "$)"), m = new RegExp("^" + l + "$"), s = new RegExp("^" + f + "$"), C = function(te) {
    return te && te.exact ? g : new RegExp("(?:" + i(te) + l + i(te) + ")|(?:" + i(te) + f + i(te) + ")", "g");
  };
  C.v4 = function(ie) {
    return ie && ie.exact ? m : new RegExp("" + i(ie) + l + i(ie), "g");
  }, C.v6 = function(ie) {
    return ie && ie.exact ? s : new RegExp("" + i(ie) + f + i(ie), "g");
  };
  var T = "(?:(?:[a-z]+:)?//)", M = "(?:\\S+(?::\\S*)?@)?", z = C.v4().source, L = C.v6().source, A = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", O = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", U = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", X = "(?::\\d{2,5})?", H = '(?:[/?#][^\\s"]*)?', Q = "(?:" + T + "|www\\.)" + M + "(?:localhost|" + z + "|" + L + "|" + A + O + U + ")" + X + H;
  return yf = new RegExp("(?:^" + Q + "$)", "i"), yf;
}), p_ = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, kd = { integer: function(i) {
  return kd.number(i) && parseInt(i, 10) === i;
}, float: function(i) {
  return kd.number(i) && !kd.integer(i);
}, array: function(i) {
  return Array.isArray(i);
}, regexp: function(i) {
  if (i instanceof RegExp) return true;
  try {
    return !!new RegExp(i);
  } catch {
    return false;
  }
}, date: function(i) {
  return typeof i.getTime == "function" && typeof i.getMonth == "function" && typeof i.getYear == "function" && !isNaN(i.getTime());
}, number: function(i) {
  return isNaN(i) ? false : typeof i == "number";
}, object: function(i) {
  return typeof i == "object" && !kd.array(i);
}, method: function(i) {
  return typeof i == "function";
}, email: function(i) {
  return typeof i == "string" && i.length <= 320 && !!i.match(p_.email);
}, url: function(i) {
  return typeof i == "string" && i.length <= 2048 && !!i.match(fT());
}, hex: function(i) {
  return typeof i == "string" && !!i.match(p_.hex);
} }, pT = function(i, l, d, f, g) {
  if (i.required && l === void 0) {
    Mb(i, l, d, f, g);
    return;
  }
  var m = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = i.type;
  m.indexOf(s) > -1 ? kd[s](l) || f.push(go(g.messages.types[s], i.fullField, i.type)) : s && typeof l !== i.type && f.push(go(g.messages.types[s], i.fullField, i.type));
}, mT = function(i, l, d, f, g) {
  var m = typeof i.len == "number", s = typeof i.min == "number", C = typeof i.max == "number", T = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, M = l, z = null, L = typeof l == "number", A = typeof l == "string", O = Array.isArray(l);
  if (L ? z = "number" : A ? z = "string" : O && (z = "array"), !z) return false;
  O && (M = l.length), A && (M = l.replace(T, "_").length), m ? M !== i.len && f.push(go(g.messages[z].len, i.fullField, i.len)) : s && !C && M < i.min ? f.push(go(g.messages[z].min, i.fullField, i.min)) : C && !s && M > i.max ? f.push(go(g.messages[z].max, i.fullField, i.max)) : s && C && (M < i.min || M > i.max) && f.push(go(g.messages[z].range, i.fullField, i.min, i.max));
}, Vu = "enum", gT = function(i, l, d, f, g) {
  i[Vu] = Array.isArray(i[Vu]) ? i[Vu] : [], i[Vu].indexOf(l) === -1 && f.push(go(g.messages[Vu], i.fullField, i[Vu].join(", ")));
}, vT = function(i, l, d, f, g) {
  if (i.pattern) {
    if (i.pattern instanceof RegExp) i.pattern.lastIndex = 0, i.pattern.test(l) || f.push(go(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    else if (typeof i.pattern == "string") {
      var m = new RegExp(i.pattern);
      m.test(l) || f.push(go(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    }
  }
}, Lr = { required: Mb, whitespace: hT, type: pT, range: mT, enum: gT, pattern: vT }, _T = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "string") && !i.required) return d();
    Lr.required(i, l, f, m, g, "string"), en(l, "string") || (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g), Lr.pattern(i, l, f, m, g), i.whitespace === true && Lr.whitespace(i, l, f, m, g));
  }
  d(m);
}, yT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, bT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l === "" && (l = void 0), en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, xT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, wT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), en(l) || Lr.type(i, l, f, m, g);
  }
  d(m);
}, CT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, ST = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, kT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l == null && !i.required) return d();
    Lr.required(i, l, f, m, g, "array"), l != null && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, PT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, TT = "enum", IT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr[TT](i, l, f, m, g);
  }
  d(m);
}, MT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "string") && !i.required) return d();
    Lr.required(i, l, f, m, g), en(l, "string") || Lr.pattern(i, l, f, m, g);
  }
  d(m);
}, ET = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "date") && !i.required) return d();
    if (Lr.required(i, l, f, m, g), !en(l, "date")) {
      var C;
      l instanceof Date ? C = l : C = new Date(l), Lr.type(i, C, f, m, g), C && Lr.range(i, C.getTime(), f, m, g);
    }
  }
  d(m);
}, RT = function(i, l, d, f, g) {
  var m = [], s = Array.isArray(l) ? "array" : typeof l;
  Lr.required(i, l, f, m, g, s), d(m);
}, Om = function(i, l, d, f, g) {
  var m = i.type, s = [], C = i.required || !i.required && f.hasOwnProperty(i.field);
  if (C) {
    if (en(l, m) && !i.required) return d();
    Lr.required(i, l, f, s, g, m), en(l, m) || Lr.type(i, l, f, s, g);
  }
  d(s);
}, AT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g);
  }
  d(m);
}, Rd = { string: _T, method: yT, number: bT, boolean: xT, regexp: wT, integer: CT, float: ST, array: kT, object: PT, enum: IT, pattern: MT, date: ET, url: Om, hex: Om, email: Om, required: RT, any: AT };
function xg() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var i = JSON.parse(JSON.stringify(this));
    return i.clone = this.clone, i;
  } };
}
var wg = xg(), Ju = (function() {
  function r(l) {
    this.rules = null, this._messages = wg, this.define(l);
  }
  var i = r.prototype;
  return i.define = function(d) {
    var f = this;
    if (!d) throw new Error("Cannot configure a schema with no rules");
    if (typeof d != "object" || Array.isArray(d)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(d).forEach(function(g) {
      var m = d[g];
      f.rules[g] = Array.isArray(m) ? m : [m];
    });
  }, i.messages = function(d) {
    return d && (this._messages = f_(xg(), d)), this._messages;
  }, i.validate = function(d, f, g) {
    var m = this;
    f === void 0 && (f = {}), g === void 0 && (g = function() {
    });
    var s = d, C = f, T = g;
    if (typeof C == "function" && (T = C, C = {}), !this.rules || Object.keys(this.rules).length === 0) return T && T(null, s), Promise.resolve(s);
    function M(U) {
      var X = [], H = {};
      function Q(te) {
        if (Array.isArray(te)) {
          var re;
          X = (re = X).concat.apply(re, te);
        } else X.push(te);
      }
      for (var ie = 0; ie < U.length; ie++) Q(U[ie]);
      X.length ? (H = bg(X), T(X, H)) : T(null, s);
    }
    if (C.messages) {
      var z = this.messages();
      z === wg && (z = xg()), f_(z, C.messages), C.messages = z;
    } else C.messages = this.messages();
    var L = {}, A = C.keys || Object.keys(this.rules);
    A.forEach(function(U) {
      var X = m.rules[U], H = s[U];
      X.forEach(function(Q) {
        var ie = Q;
        typeof ie.transform == "function" && (s === d && (s = Sl({}, s)), H = s[U] = ie.transform(H)), typeof ie == "function" ? ie = { validator: ie } : ie = Sl({}, ie), ie.validator = m.getValidationMethod(ie), ie.validator && (ie.field = U, ie.fullField = ie.fullField || U, ie.type = m.getType(ie), L[U] = L[U] || [], L[U].push({ rule: ie, value: H, source: s, field: U }));
      });
    });
    var O = {};
    return uT(L, C, function(U, X) {
      var _a3;
      var H = U.rule, Q = (H.type === "object" || H.type === "array") && (typeof H.fields == "object" || typeof H.defaultField == "object");
      Q = Q && (H.required || !H.required && U.value), H.field = U.field;
      function ie(J, Se) {
        return Sl({}, Se, { fullField: H.fullField + "." + J, fullFields: H.fullFields ? [].concat(H.fullFields, [J]) : [J] });
      }
      function te(J) {
        J === void 0 && (J = []);
        var Se = Array.isArray(J) ? J : [J];
        !C.suppressWarning && Se.length && r.warning("async-validator:", Se), Se.length && H.message !== void 0 && (Se = [].concat(H.message));
        var fe = Se.map(h_(H, s));
        if (C.first && fe.length) return O[H.field] = 1, X(fe);
        if (!Q) X(fe);
        else {
          if (H.required && !U.value) return H.message !== void 0 ? fe = [].concat(H.message).map(h_(H, s)) : C.error && (fe = [C.error(H, go(C.messages.required, H.field))]), X(fe);
          var oe = {};
          H.defaultField && Object.keys(U.value).map(function($e) {
            oe[$e] = H.defaultField;
          }), oe = Sl({}, oe, U.rule.fields);
          var de = {};
          Object.keys(oe).forEach(function($e) {
            var Ve = oe[$e], Ke = Array.isArray(Ve) ? Ve : [Ve];
            de[$e] = Ke.map(ie.bind(null, $e));
          });
          var xe = new r(de);
          xe.messages(C.messages), U.rule.options && (U.rule.options.messages = C.messages, U.rule.options.error = C.error), xe.validate(U.value, U.rule.options || C, function($e) {
            var Ve = [];
            fe && fe.length && Ve.push.apply(Ve, fe), $e && $e.length && Ve.push.apply(Ve, $e), X(Ve.length ? Ve : null);
          });
        }
      }
      var re;
      if (H.asyncValidator) re = H.asyncValidator(H, U.value, te, U.source, C);
      else if (H.validator) {
        try {
          re = H.validator(H, U.value, te, U.source, C);
        } catch (J) {
          (_a3 = console.error) == null ? void 0 : _a3.call(console, J), C.suppressValidatorError || setTimeout(function() {
            throw J;
          }, 0), te(J.message);
        }
        re === true ? te() : re === false ? te(typeof H.message == "function" ? H.message(H.fullField || H.field) : H.message || (H.fullField || H.field) + " fails") : re instanceof Array ? te(re) : re instanceof Error && te(re.message);
      }
      re && re.then && re.then(function() {
        return te();
      }, function(J) {
        return te(J);
      });
    }, function(U) {
      M(U);
    }, s);
  }, i.getType = function(d) {
    if (d.type === void 0 && d.pattern instanceof RegExp && (d.type = "pattern"), typeof d.validator != "function" && d.type && !Rd.hasOwnProperty(d.type)) throw new Error(go("Unknown rule type %s", d.type));
    return d.type || "string";
  }, i.getValidationMethod = function(d) {
    if (typeof d.validator == "function") return d.validator;
    var f = Object.keys(d), g = f.indexOf("message");
    return g !== -1 && f.splice(g, 1), f.length === 1 && f[0] === "required" ? Rd.required : Rd[this.getType(d)] || void 0;
  }, r;
})();
Ju.register = function(i, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  Rd[i] = l;
};
Ju.warning = oT;
Ju.messages = wg;
Ju.validators = Rd;
const { cubicBezierEaseInOut: m_ } = Kd;
function DT({ name: r = "fade-down", fromOffset: i = "-4px", enterDuration: l = ".3s", leaveDuration: d = ".3s", enterCubicBezier: f = m_, leaveCubicBezier: g = m_ } = {}) {
  return [qe(`&.${r}-transition-enter-from, &.${r}-transition-leave-to`, { opacity: 0, transform: `translateY(${i})` }), qe(`&.${r}-transition-enter-to, &.${r}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), qe(`&.${r}-transition-leave-active`, { transition: `opacity ${d} ${g}, transform ${d} ${g}` }), qe(`&.${r}-transition-enter-active`, { transition: `opacity ${l} ${f}, transform ${l} ${f}` })];
}
const zT = ue("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [ue("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Re("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Re("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), ue("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ue("auto-label-width", [ue("form-item-label", "white-space: nowrap;")]), Ue("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [ue("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ue("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ue("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ue("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ue("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Re("text", `
 grid-area: text; 
 `), Re("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ue("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ue("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), ue("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), ue("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), ue("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [qe("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), ue("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ue("warning", { color: "var(--n-feedback-text-color-warning)" }), Ue("error", { color: "var(--n-feedback-text-color-error)" }), DT({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function FT(r) {
  const i = fr(Jd, null);
  return { mergedSize: ze(() => r.size !== void 0 ? r.size : (i == null ? void 0 : i.props.size) !== void 0 ? i.props.size : "medium") };
}
function LT(r) {
  const i = fr(Jd, null), l = ze(() => {
    const { labelPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.labelPlacement) ? i.props.labelPlacement : "top";
  }), d = ze(() => l.value === "left" && (r.labelWidth === "auto" || (i == null ? void 0 : i.props.labelWidth) === "auto")), f = ze(() => {
    if (l.value === "top") return;
    const { labelWidth: O } = r;
    if (O !== void 0 && O !== "auto") return Ho(O);
    if (d.value) {
      const U = i == null ? void 0 : i.maxChildLabelWidthRef.value;
      return U !== void 0 ? Ho(U) : void 0;
    }
    if ((i == null ? void 0 : i.props.labelWidth) !== void 0) return Ho(i.props.labelWidth);
  }), g = ze(() => {
    const { labelAlign: O } = r;
    if (O) return O;
    if (i == null ? void 0 : i.props.labelAlign) return i.props.labelAlign;
  }), m = ze(() => {
    var O;
    return [(O = r.labelProps) === null || O === void 0 ? void 0 : O.style, r.labelStyle, { width: f.value }];
  }), s = ze(() => {
    const { showRequireMark: O } = r;
    return O !== void 0 ? O : i == null ? void 0 : i.props.showRequireMark;
  }), C = ze(() => {
    const { requireMarkPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.requireMarkPlacement) || "right";
  }), T = Ae(false), M = Ae(false), z = ze(() => {
    const { validationStatus: O } = r;
    if (O !== void 0) return O;
    if (T.value) return "error";
    if (M.value) return "warning";
  }), L = ze(() => {
    const { showFeedback: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showFeedback) !== void 0 ? i.props.showFeedback : true;
  }), A = ze(() => {
    const { showLabel: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showLabel) !== void 0 ? i.props.showLabel : true;
  });
  return { validationErrored: T, validationWarned: M, mergedLabelStyle: m, mergedLabelPlacement: l, mergedLabelAlign: g, mergedShowRequireMark: s, mergedRequireMarkPlacement: C, mergedValidationStatus: z, mergedShowFeedback: L, mergedShowLabel: A, isAutoLabelWidth: d };
}
function BT(r) {
  const i = fr(Jd, null), l = ze(() => {
    const { rulePath: m } = r;
    if (m !== void 0) return m;
    const { path: s } = r;
    if (s !== void 0) return s;
  }), d = ze(() => {
    const m = [], { rule: s } = r;
    if (s !== void 0 && (Array.isArray(s) ? m.push(...s) : m.push(s)), i) {
      const { rules: C } = i.props, { value: T } = l;
      if (C !== void 0 && T !== void 0) {
        const M = $y(C, T);
        M !== void 0 && (Array.isArray(M) ? m.push(...M) : m.push(M));
      }
    }
    return m;
  }), f = ze(() => d.value.some((m) => m.required)), g = ze(() => f.value || r.required);
  return { mergedRules: d, mergedRequired: g };
}
var g_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const OT = Object.assign(Object.assign({}, Yt.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object, contentClass: String, contentStyle: [String, Object] });
function v_(r, i) {
  return (...l) => {
    try {
      const d = r(...l);
      return !i && (typeof d == "boolean" || d instanceof Error || Array.isArray(d)) || (d == null ? void 0 : d.then) ? d : (d === void 0 || Of("form-item/validate", `You return a ${typeof d} typed value in the validator method, which is not recommended. Please use ${i ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (d) {
      Of("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(d);
      return;
    }
  };
}
const xn = st({ name: "FormItem", props: OT, setup(r) {
  L3(Ib, "formItems", Dt(r, "path"));
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = fr(Jd, null), f = FT(r), g = LT(r), { validationErrored: m, validationWarned: s } = g, { mergedRequired: C, mergedRules: T } = BT(r), { mergedSize: M } = f, { mergedLabelPlacement: z, mergedLabelAlign: L, mergedRequireMarkPlacement: A } = g, O = Ae([]), U = Ae(zl()), X = d ? Dt(d.props, "disabled") : Ae(false), H = Yt("Form", "-form-item", zT, Oy, r, i);
  ar(Dt(r, "path"), () => {
    r.ignorePathChange || Q();
  });
  function Q() {
    O.value = [], m.value = false, s.value = false, r.feedback && (U.value = zl());
  }
  const ie = (...Ke) => g_(this, [...Ke], void 0, function* (lt = null, vt = () => true, xt = { suppressWarning: true }) {
    const { path: at } = r;
    xt ? xt.first || (xt.first = r.first) : xt = {};
    const { value: et } = T, ht = d ? $y(d.props.model, at || "") : void 0, yt = {}, nt = {}, ut = (lt ? et.filter((rr) => Array.isArray(rr.trigger) ? rr.trigger.includes(lt) : rr.trigger === lt) : et).filter(vt).map((rr, sr) => {
      const qt = Object.assign({}, rr);
      if (qt.validator && (qt.validator = v_(qt.validator, false)), qt.asyncValidator && (qt.asyncValidator = v_(qt.asyncValidator, true)), qt.renderMessage) {
        const Dr = `__renderMessage__${sr}`;
        nt[Dr] = qt.message, qt.message = Dr, yt[Dr] = qt.renderMessage;
      }
      return qt;
    }), Lt = ut.filter((rr) => rr.level !== "warning"), Ht = ut.filter((rr) => rr.level === "warning"), zt = { valid: true, errors: void 0, warnings: void 0 };
    if (!ut.length) return zt;
    const pr = at ?? "__n_no_path__", Jt = new Ju({ [pr]: Lt }), tr = new Ju({ [pr]: Ht }), { validateMessages: wr } = (d == null ? void 0 : d.props) || {};
    wr && (Jt.messages(wr), tr.messages(wr));
    const Er = (rr) => {
      O.value = rr.map((sr) => {
        const qt = (sr == null ? void 0 : sr.message) || "";
        return { key: qt, render: () => qt.startsWith("__renderMessage__") ? yt[qt]() : qt };
      }), rr.forEach((sr) => {
        var qt;
        !((qt = sr.message) === null || qt === void 0) && qt.startsWith("__renderMessage__") && (sr.message = nt[sr.message]);
      });
    };
    if (Lt.length) {
      const rr = yield new Promise((sr) => {
        Jt.validate({ [pr]: ht }, xt, sr);
      });
      (rr == null ? void 0 : rr.length) && (zt.valid = false, zt.errors = rr, Er(rr));
    }
    if (Ht.length && !zt.errors) {
      const rr = yield new Promise((sr) => {
        tr.validate({ [pr]: ht }, xt, sr);
      });
      (rr == null ? void 0 : rr.length) && (Er(rr), zt.warnings = rr);
    }
    return !zt.errors && !zt.warnings ? Q() : (m.value = !!zt.errors, s.value = !!zt.warnings), zt;
  });
  function te() {
    ie("blur");
  }
  function re() {
    ie("change");
  }
  function J() {
    ie("focus");
  }
  function Se() {
    ie("input");
  }
  function fe(Ke, lt) {
    return g_(this, void 0, void 0, function* () {
      let vt, xt, at, et;
      return typeof Ke == "string" ? (vt = Ke, xt = lt) : Ke !== null && typeof Ke == "object" && (vt = Ke.trigger, xt = Ke.callback, at = Ke.shouldRuleBeApplied, et = Ke.options), yield new Promise((ht, yt) => {
        ie(vt, at, et).then(({ valid: nt, errors: ut, warnings: Lt }) => {
          nt ? (xt && xt(void 0, { warnings: Lt }), ht({ warnings: Lt })) : (xt && xt(ut, { warnings: Lt }), yt(ut));
        });
      });
    });
  }
  Jr(F2, { path: Dt(r, "path"), disabled: X, mergedSize: f.mergedSize, mergedValidationStatus: g.mergedValidationStatus, restoreValidation: Q, handleContentBlur: te, handleContentChange: re, handleContentFocus: J, handleContentInput: Se });
  const oe = { validate: fe, restoreValidation: Q, internalValidate: ie }, de = Ae(null);
  Qi(() => {
    if (!g.isAutoLabelWidth.value) return;
    const Ke = de.value;
    if (Ke !== null) {
      const lt = Ke.style.whiteSpace;
      Ke.style.whiteSpace = "nowrap", Ke.style.width = "", d == null ? void 0 : d.deriveMaxChildLabelWidth(Number(getComputedStyle(Ke).width.slice(0, -2))), Ke.style.whiteSpace = lt;
    }
  });
  const xe = ze(() => {
    var Ke;
    const { value: lt } = M, { value: vt } = z, xt = vt === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: at }, self: { labelTextColor: et, asteriskColor: ht, lineHeight: yt, feedbackTextColor: nt, feedbackTextColorWarning: ut, feedbackTextColorError: Lt, feedbackPadding: Ht, labelFontWeight: zt, [jt("labelHeight", lt)]: pr, [jt("blankHeight", lt)]: Jt, [jt("feedbackFontSize", lt)]: tr, [jt("feedbackHeight", lt)]: wr, [jt("labelPadding", xt)]: Er, [jt("labelTextAlign", xt)]: rr, [jt(jt("labelFontSize", vt), lt)]: sr } } = H.value;
    let qt = (Ke = L.value) !== null && Ke !== void 0 ? Ke : rr;
    return vt === "top" && (qt = qt === "right" ? "flex-end" : "flex-start"), { "--n-bezier": at, "--n-line-height": yt, "--n-blank-height": Jt, "--n-label-font-size": sr, "--n-label-text-align": qt, "--n-label-height": pr, "--n-label-padding": Er, "--n-label-font-weight": zt, "--n-asterisk-color": ht, "--n-label-text-color": et, "--n-feedback-padding": Ht, "--n-feedback-font-size": tr, "--n-feedback-height": wr, "--n-feedback-text-color": nt, "--n-feedback-text-color-warning": ut, "--n-feedback-text-color-error": Lt };
  }), $e = l ? ci("form-item", ze(() => {
    var Ke;
    return `${M.value[0]}${z.value[0]}${((Ke = L.value) === null || Ke === void 0 ? void 0 : Ke[0]) || ""}`;
  }), xe, r) : void 0, Ve = ze(() => z.value === "left" && A.value === "left" && L.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: de, mergedClsPrefix: i, mergedRequired: C, feedbackId: U, renderExplains: O, reverseColSpace: Ve }, g), f), oe), { cssVars: l ? void 0 : xe, themeClass: $e == null ? void 0 : $e.themeClass, onRender: $e == null ? void 0 : $e.onRender });
}, render() {
  const { $slots: r, mergedClsPrefix: i, mergedShowLabel: l, mergedShowRequireMark: d, mergedRequireMarkPlacement: f, onRender: g } = this, m = d !== void 0 ? d : this.mergedRequired;
  g == null ? void 0 : g();
  const s = () => {
    const C = this.$slots.label ? this.$slots.label() : this.label;
    if (!C) return null;
    const T = F("span", { class: `${i}-form-item-label__text` }, C), M = m ? F("span", { class: `${i}-form-item-label__asterisk` }, f !== "left" ? "\xA0*" : "*\xA0") : f === "right-hanging" && F("span", { class: `${i}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: z } = this;
    return F("label", Object.assign({}, z, { class: [z == null ? void 0 : z.class, `${i}-form-item-label`, `${i}-form-item-label--${f}-mark`, this.reverseColSpace && `${i}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), f === "left" ? [M, T] : [T, M]);
  };
  return F("div", { class: [`${i}-form-item`, this.themeClass, `${i}-form-item--${this.mergedSize}-size`, `${i}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${i}-form-item--auto-label-width`, !l && `${i}-form-item--no-label`], style: this.cssVars }, l && s(), F("div", { class: [`${i}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${i}-form-item-blank--${this.mergedValidationStatus}`], style: this.contentStyle }, r), this.mergedShowFeedback ? F("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${i}-form-item-feedback-wrapper`, this.feedbackClass] }, F(Ao, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: C } = this;
    return xi(r.feedback, (T) => {
      var M;
      const { feedback: z } = this, L = T || z ? F("div", { key: "__feedback__", class: `${i}-form-item-feedback__line` }, T || z) : this.renderExplains.length ? (M = this.renderExplains) === null || M === void 0 ? void 0 : M.map(({ key: A, render: O }) => F("div", { key: A, class: `${i}-form-item-feedback__line` }, O())) : null;
      return L ? C === "warning" ? F("div", { key: "controlled-warning", class: `${i}-form-item-feedback ${i}-form-item-feedback--warning` }, L) : C === "error" ? F("div", { key: "controlled-error", class: `${i}-form-item-feedback ${i}-form-item-feedback--error` }, L) : C === "success" ? F("div", { key: "controlled-success", class: `${i}-form-item-feedback ${i}-form-item-feedback--success` }, L) : F("div", { key: "controlled-default", class: `${i}-form-item-feedback` }, L) : null;
    });
  } })) : null);
} }), __ = 1, Eb = An("n-grid"), Rb = 1, $T = { span: { type: [Number, String], default: Rb }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, jT = st({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: $T, setup() {
  const { isSsrRef: r, xGapRef: i, itemStyleRef: l, overflowRef: d, layoutShiftDisabledRef: f } = fr(Eb), g = Xd();
  return { overflow: d, itemStyle: l, layoutShiftDisabled: f, mergedXGap: ze(() => jn(i.value || 0)), deriveStyle: () => {
    r.value;
    const { privateSpan: m = Rb, privateShow: s = true, privateColStart: C = void 0, privateOffset: T = 0 } = g.vnode.props, { value: M } = i, z = jn(M || 0);
    return { display: s ? "" : "none", gridColumn: `${C ?? `span ${m}`} / span ${m}`, marginLeft: T ? `calc((100% - (${m} - 1) * ${z}) / ${m} * ${T} + ${z} * ${T})` : "" };
  } };
}, render() {
  var r, i;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: d, mergedXGap: f } = this;
    return F("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: d ? `calc((100% - (${l} - 1) * ${f}) / ${l} * ${d} + ${f} * ${d})` : "" } }, this.$slots);
  }
  return F("div", { style: [this.itemStyle, this.deriveStyle()] }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r, { overflow: this.overflow }));
} }), NT = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, Ab = 24, $m = "__ssr__", VT = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: Ab }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, UT = st({ name: "Grid", inheritAttrs: false, props: VT, setup(r) {
  const { mergedClsPrefixRef: i, mergedBreakpointsRef: l } = Tr(r), d = /^\d+$/, f = Ae(void 0), g = F3((l == null ? void 0 : l.value) || NT), m = pi(() => !!(r.itemResponsive || !d.test(r.cols.toString()) || !d.test(r.xGap.toString()) || !d.test(r.yGap.toString()))), s = ze(() => {
    if (m.value) return r.responsive === "self" ? f.value : g.value;
  }), C = pi(() => {
    var H;
    return (H = Number(Ou(r.cols.toString(), s.value))) !== null && H !== void 0 ? H : Ab;
  }), T = pi(() => Ou(r.xGap.toString(), s.value)), M = pi(() => Ou(r.yGap.toString(), s.value)), z = (H) => {
    f.value = H.contentRect.width;
  }, L = (H) => {
    Xf(z, H);
  }, A = Ae(false), O = ze(() => {
    if (r.responsive === "self") return L;
  }), U = Ae(false), X = Ae();
  return Qi(() => {
    const { value: H } = X;
    H && H.hasAttribute($m) && (H.removeAttribute($m), U.value = true);
  }), Jr(Eb, { layoutShiftDisabledRef: Dt(r, "layoutShiftDisabled"), isSsrRef: U, itemStyleRef: Dt(r, "itemStyle"), xGapRef: T, overflowRef: A }), { isSsr: !rp, contentEl: X, mergedClsPrefix: i, style: ze(() => r.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${r.cols}, minmax(0, 1fr))`, columnGap: jn(r.xGap), rowGap: jn(r.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${C.value}, minmax(0, 1fr))`, columnGap: jn(T.value), rowGap: jn(M.value) }), isResponsive: m, responsiveQuery: s, responsiveCols: C, handleResize: O, overflow: A };
}, render() {
  if (this.layoutShiftDisabled) return F("div", Ya({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const r = () => {
    var i, l, d, f, g, m, s;
    this.overflow = false;
    const C = El(op(this)), T = [], { collapsed: M, collapsedRows: z, responsiveCols: L, responsiveQuery: A } = this;
    C.forEach((Q) => {
      var ie, te, re, J, Se;
      if (((ie = Q == null ? void 0 : Q.type) === null || ie === void 0 ? void 0 : ie.__GRID_ITEM__) !== true) return;
      if (Z3(Q)) {
        const de = ig(Q);
        de.props ? de.props.privateShow = false : de.props = { privateShow: false }, T.push({ child: de, rawChildSpan: 0 });
        return;
      }
      Q.dirs = ((te = Q.dirs) === null || te === void 0 ? void 0 : te.filter(({ dir: de }) => de !== Ka)) || null, ((re = Q.dirs) === null || re === void 0 ? void 0 : re.length) === 0 && (Q.dirs = null);
      const fe = ig(Q), oe = Number((Se = Ou((J = fe.props) === null || J === void 0 ? void 0 : J.span, A)) !== null && Se !== void 0 ? Se : __);
      oe !== 0 && T.push({ child: fe, rawChildSpan: oe });
    });
    let O = 0;
    const U = (i = T[T.length - 1]) === null || i === void 0 ? void 0 : i.child;
    if (U == null ? void 0 : U.props) {
      const Q = (l = U.props) === null || l === void 0 ? void 0 : l.suffix;
      Q !== void 0 && Q !== false && (O = Number((f = Ou((d = U.props) === null || d === void 0 ? void 0 : d.span, A)) !== null && f !== void 0 ? f : __), U.props.privateSpan = O, U.props.privateColStart = L + 1 - O, U.props.privateShow = (g = U.props.privateShow) !== null && g !== void 0 ? g : true);
    }
    let X = 0, H = false;
    for (const { child: Q, rawChildSpan: ie } of T) {
      if (H && (this.overflow = true), !H) {
        const te = Number((s = Ou((m = Q.props) === null || m === void 0 ? void 0 : m.offset, A)) !== null && s !== void 0 ? s : 0), re = Math.min(ie + te, L);
        if (Q.props ? (Q.props.privateSpan = re, Q.props.privateOffset = te) : Q.props = { privateSpan: re, privateOffset: te }, M) {
          const J = X % L;
          re + J > L && (X += L - J), re + X + O > z * L ? H = true : X += re;
        }
      }
      H && (Q.props ? Q.props.privateShow !== true && (Q.props.privateShow = false) : Q.props = { privateShow: false });
    }
    return F("div", Ya({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [$m]: this.isSsr || void 0 }, this.$attrs), T.map(({ child: Q }) => Q));
  };
  return this.isResponsive && this.responsive === "self" ? F(Pl, { onResize: this.handleResize }, { default: r }) : r();
} });
function GT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function qT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function WT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const Wg = Object.assign(Object.assign({}, Yt.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), Db = An("n-image"), ZT = qe([qe("body >", [ue("image-container", "position: fixed;")]), ue("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), ue("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [Nf()]), ue("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), Nf()]), ue("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [Kf()]), ue("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), ue("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [ui("preview-disabled", `
 cursor: pointer;
 `), qe("img", `
 border-radius: inherit;
 `)])]), bf = 32, HT = Object.assign(Object.assign({}, Wg), { src: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onNext: Function, onPrev: Function, onClose: [Function, Array] }), zb = st({ name: "ImagePreview", props: HT, setup(r) {
  const { src: i } = $w(r), { mergedClsPrefixRef: l } = Tr(r), d = Yt("Image", "-image", ZT, L2, r, l);
  let f = null;
  const g = Ae(null), m = Ae(null), s = Ae(false), { localeRef: C } = Ja("Image"), T = Ae(r.defaultShow), M = Dt(r, "show"), z = Zi(M, T);
  function L() {
    const { value: Ee } = m;
    if (!f || !Ee) return;
    const { style: ot } = Ee, Le = f.getBoundingClientRect(), Ye = Le.left + Le.width / 2, ft = Le.top + Le.height / 2;
    ot.transformOrigin = `${Ye}px ${ft}px`;
  }
  function A(Ee) {
    var ot, Le;
    switch (Ee.key) {
      case " ":
        Ee.preventDefault();
        break;
      case "ArrowLeft":
        (ot = r.onPrev) === null || ot === void 0 || ot.call(r);
        break;
      case "ArrowRight":
        (Le = r.onNext) === null || Le === void 0 || Le.call(r);
        break;
      case "ArrowUp":
        Ee.preventDefault(), zt();
        break;
      case "ArrowDown":
        Ee.preventDefault(), pr();
        break;
      case "Escape":
        wr();
        break;
    }
  }
  function O(Ee) {
    const { onUpdateShow: ot, "onUpdate:show": Le } = r;
    ot && Ot(ot, Ee), Le && Ot(Le, Ee), T.value = Ee, s.value = true;
  }
  ar(z, (Ee) => {
    Ee ? En("keydown", document, A) : Hn("keydown", document, A);
  }), Cn(() => {
    Hn("keydown", document, A);
  });
  let U = 0, X = 0, H = 0, Q = 0, ie = 0, te = 0, re = 0, J = 0, Se = false;
  function fe(Ee) {
    const { clientX: ot, clientY: Le } = Ee;
    H = ot - U, Q = Le - X, Xf(tr);
  }
  function oe(Ee) {
    const { mouseUpClientX: ot, mouseUpClientY: Le, mouseDownClientX: Ye, mouseDownClientY: ft } = Ee, bt = Ye - ot, tt = ft - Le, mt = `vertical${tt > 0 ? "Top" : "Bottom"}`, Zt = `horizontal${bt > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: mt, moveHorizontalDirection: Zt, deltaHorizontal: bt, deltaVertical: tt };
  }
  function de(Ee) {
    const { value: ot } = g;
    if (!ot) return { offsetX: 0, offsetY: 0 };
    const Le = ot.getBoundingClientRect(), { moveVerticalDirection: Ye, moveHorizontalDirection: ft, deltaHorizontal: bt, deltaVertical: tt } = Ee || {};
    let mt = 0, Zt = 0;
    return Le.width <= window.innerWidth ? mt = 0 : Le.left > 0 ? mt = (Le.width - window.innerWidth) / 2 : Le.right < window.innerWidth ? mt = -(Le.width - window.innerWidth) / 2 : ft === "horizontalRight" ? mt = Math.min((Le.width - window.innerWidth) / 2, ie - (bt ?? 0)) : mt = Math.max(-((Le.width - window.innerWidth) / 2), ie - (bt ?? 0)), Le.height <= window.innerHeight ? Zt = 0 : Le.top > 0 ? Zt = (Le.height - window.innerHeight) / 2 : Le.bottom < window.innerHeight ? Zt = -(Le.height - window.innerHeight) / 2 : Ye === "verticalBottom" ? Zt = Math.min((Le.height - window.innerHeight) / 2, te - (tt ?? 0)) : Zt = Math.max(-((Le.height - window.innerHeight) / 2), te - (tt ?? 0)), { offsetX: mt, offsetY: Zt };
  }
  function xe(Ee) {
    Hn("mousemove", document, fe), Hn("mouseup", document, xe);
    const { clientX: ot, clientY: Le } = Ee;
    Se = false;
    const Ye = oe({ mouseUpClientX: ot, mouseUpClientY: Le, mouseDownClientX: re, mouseDownClientY: J }), ft = de(Ye);
    H = ft.offsetX, Q = ft.offsetY, tr();
  }
  const $e = fr(Db, null);
  function Ve(Ee) {
    var ot, Le;
    if ((Le = (ot = $e == null ? void 0 : $e.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onMousedown) === null || Le === void 0 || Le.call(ot, Ee), Ee.button !== 0) return;
    const { clientX: Ye, clientY: ft } = Ee;
    Se = true, U = Ye - H, X = ft - Q, ie = H, te = Q, re = Ye, J = ft, tr(), En("mousemove", document, fe), En("mouseup", document, xe);
  }
  const Ke = 1.5;
  let lt = 0, vt = 1, xt = 0;
  function at(Ee) {
    var ot, Le;
    (Le = (ot = $e == null ? void 0 : $e.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDblclick) === null || Le === void 0 || Le.call(ot, Ee);
    const Ye = Ht();
    vt = vt === Ye ? 1 : Ye, tr();
  }
  function et() {
    vt = 1, lt = 0;
  }
  function ht() {
    var Ee;
    et(), xt = 0, (Ee = r.onPrev) === null || Ee === void 0 || Ee.call(r);
  }
  function yt() {
    var Ee;
    et(), xt = 0, (Ee = r.onNext) === null || Ee === void 0 || Ee.call(r);
  }
  function nt() {
    xt -= 90, tr();
  }
  function ut() {
    xt += 90, tr();
  }
  function Lt() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: ot, innerHeight: Le } = window, Ye = Math.max(1, Ee.naturalHeight / (Le - bf)), ft = Math.max(1, Ee.naturalWidth / (ot - bf));
    return Math.max(3, Ye * 2, ft * 2);
  }
  function Ht() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: ot, innerHeight: Le } = window, Ye = Ee.naturalHeight / (Le - bf), ft = Ee.naturalWidth / (ot - bf);
    return Ye < 1 && ft < 1 ? 1 : Math.max(Ye, ft);
  }
  function zt() {
    const Ee = Lt();
    vt < Ee && (lt += 1, vt = Math.min(Ee, Math.pow(Ke, lt)), tr());
  }
  function pr() {
    if (vt > 0.5) {
      const Ee = vt;
      lt -= 1, vt = Math.max(0.5, Math.pow(Ke, lt));
      const ot = Ee - vt;
      tr(false);
      const Le = de();
      vt += ot, tr(false), vt -= ot, H = Le.offsetX, Q = Le.offsetY, tr();
    }
  }
  function Jt() {
    const Ee = i.value;
    Ee && db(Ee, void 0);
  }
  function tr(Ee = true) {
    var ot;
    const { value: Le } = g;
    if (!Le) return;
    const { style: Ye } = Le, ft = ws((ot = $e == null ? void 0 : $e.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.style);
    let bt = "";
    if (typeof ft == "string") bt = `${ft};`;
    else for (const mt in ft) bt += `${r3(mt)}: ${ft[mt]};`;
    const tt = `transform-origin: center; transform: translateX(${H}px) translateY(${Q}px) rotate(${xt}deg) scale(${vt});`;
    Se ? Ye.cssText = `${bt}cursor: grabbing; transition: none;${tt}` : Ye.cssText = `${bt}cursor: grab;${tt}${Ee ? "" : "transition: none;"}`, Ee || Le.offsetHeight;
  }
  function wr() {
    if (z.value) {
      const { onClose: Ee } = r;
      Ee && Ot(Ee), O(false), T.value = false;
    }
  }
  function Er() {
    vt = Ht(), lt = Math.ceil(Math.log(vt) / Math.log(Ke)), H = 0, Q = 0, tr();
  }
  const rr = { setThumbnailEl: (Ee) => {
    f = Ee;
  } };
  function sr(Ee, ot) {
    if (r.showToolbarTooltip) {
      const { value: Le } = d;
      return F(Dy, { to: false, theme: Le.peers.Tooltip, themeOverrides: Le.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => C.value[ot], trigger: () => Ee });
    } else return Ee;
  }
  const qt = ze(() => {
    const { common: { cubicBezierEaseInOut: Ee }, self: { toolbarIconColor: ot, toolbarBorderRadius: Le, toolbarBoxShadow: Ye, toolbarColor: ft } } = d.value;
    return { "--n-bezier": Ee, "--n-toolbar-icon-color": ot, "--n-toolbar-color": ft, "--n-toolbar-border-radius": Le, "--n-toolbar-box-shadow": Ye };
  }), { inlineThemeDisabled: Dr } = Tr(), Cr = Dr ? ci("image-preview", void 0, qt, r) : void 0;
  function Ct(Ee) {
    Ee.preventDefault();
  }
  return Object.assign({ clsPrefix: l, previewRef: g, previewWrapperRef: m, previewSrc: i, mergedShow: z, appear: ip(), displayed: s, previewedImgProps: $e == null ? void 0 : $e.previewedImgPropsRef, handleWheel: Ct, handlePreviewMousedown: Ve, handlePreviewDblclick: at, syncTransformOrigin: L, handleAfterLeave: () => {
    et(), xt = 0, s.value = false;
  }, handleDragStart: (Ee) => {
    var ot, Le;
    (Le = (ot = $e == null ? void 0 : $e.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDragstart) === null || Le === void 0 || Le.call(ot, Ee), Ee.preventDefault();
  }, zoomIn: zt, zoomOut: pr, handleDownloadClick: Jt, rotateCounterclockwise: nt, rotateClockwise: ut, handleSwitchPrev: ht, handleSwitchNext: yt, withTooltip: sr, resizeToOrignalImageSize: Er, cssVars: Dr ? void 0 : qt, themeClass: Cr == null ? void 0 : Cr.themeClass, onRender: Cr == null ? void 0 : Cr.onRender, doUpdateShow: O, close: wr }, rr);
}, render() {
  var r, i;
  const { clsPrefix: l, renderToolbar: d, withTooltip: f } = this, g = f(F(Nr, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: GT }), "tipPrevious"), m = f(F(Nr, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: qT }), "tipNext"), s = f(F(Nr, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => F(WS, null) }), "tipCounterclockwise"), C = f(F(Nr, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => F(qS, null) }), "tipClockwise"), T = f(F(Nr, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => F(US, null) }), "tipOriginalSize"), M = f(F(Nr, { clsPrefix: l, onClick: this.zoomOut }, { default: () => F(XS, null) }), "tipZoomOut"), z = f(F(Nr, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => F(hb, null) }), "tipDownload"), L = f(F(Nr, { clsPrefix: l, onClick: () => this.close() }, { default: WT }), "tipClose"), A = f(F(Nr, { clsPrefix: l, onClick: this.zoomIn }, { default: () => F(HS, null) }), "tipZoomIn");
  return F(qr, null, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r), F(Ly, { show: this.mergedShow }, { default: () => {
    var O;
    return this.mergedShow || this.displayed ? ((O = this.onRender) === null || O === void 0 || O.call(this), va(F("div", { ref: "containerRef", class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, F(Ao, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? F("div", { class: `${l}-image-preview-overlay`, onClick: () => this.close() }) : null }), this.showToolbar ? F(Ao, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? F("div", { class: `${l}-image-preview-toolbar` }, d ? d({ nodes: { prev: g, next: m, rotateCounterclockwise: s, rotateClockwise: C, resizeToOriginalSize: T, zoomOut: M, zoomIn: A, download: z, close: L } }) : F(qr, null, this.onPrev ? F(qr, null, g, m) : null, s, C, T, M, A, z, L)) : null }) : null, F(Ao, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: U = {} } = this;
      return va(F("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, F("img", Object.assign({}, U, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, U.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[Ka, this.mergedShow]]);
    } })), [[Fy, { enabled: this.mergedShow }]])) : null;
  } }));
} }), Fb = An("n-image-group"), XT = Object.assign(Object.assign({}, Wg), { srcList: Array, current: Number, defaultCurrent: { type: Number, default: 0 }, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], onUpdateCurrent: [Function, Array], "onUpdate:current": [Function, Array] }), YT = st({ name: "ImageGroup", props: XT, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r), l = `c${zl()}`, d = Ae(null), f = Ae(r.defaultShow), g = Dt(r, "show"), m = Zi(g, f), s = Ae(/* @__PURE__ */ new Map()), C = ze(() => {
    if (r.srcList) {
      const fe = /* @__PURE__ */ new Map();
      return r.srcList.forEach((oe, de) => {
        fe.set(`p${de}`, oe);
      }), fe;
    }
    return s.value;
  }), T = ze(() => Array.from(C.value.keys())), M = () => T.value.length;
  function z(fe, oe) {
    r.srcList && Yo("image-group", "`n-image` can't be placed inside `n-image-group` when image group's `src-list` prop is set.");
    const de = `r${fe}`;
    return s.value.has(`r${de}`) || s.value.set(de, oe), function() {
      s.value.has(de) || s.value.delete(de);
    };
  }
  const L = Ae(r.defaultCurrent), A = Dt(r, "current"), O = Zi(A, L), U = (fe) => {
    if (fe !== O.value) {
      const { onUpdateCurrent: oe, "onUpdate:current": de } = r;
      oe && Ot(oe, fe), de && Ot(de, fe), L.value = fe;
    }
  }, X = ze(() => T.value[O.value]), H = (fe) => {
    const oe = T.value.indexOf(fe);
    oe !== O.value && U(oe);
  }, Q = ze(() => C.value.get(X.value));
  function ie(fe) {
    const { onUpdateShow: oe, "onUpdate:show": de } = r;
    oe && Ot(oe, fe), de && Ot(de, fe), f.value = fe;
  }
  function te() {
    ie(false);
  }
  const re = ze(() => {
    const fe = (de, xe) => {
      for (let $e = de; $e <= xe; $e++) {
        const Ve = T.value[$e];
        if (C.value.get(Ve)) return $e;
      }
    }, oe = fe(O.value + 1, M() - 1);
    return oe === void 0 ? fe(0, O.value - 1) : oe;
  }), J = ze(() => {
    const fe = (de, xe) => {
      for (let $e = de; $e >= xe; $e--) {
        const Ve = T.value[$e];
        if (C.value.get(Ve)) return $e;
      }
    }, oe = fe(O.value - 1, 0);
    return oe === void 0 ? fe(M() - 1, O.value + 1) : oe;
  });
  function Se(fe) {
    var oe, de;
    fe === 1 ? (J.value !== void 0 && U(re.value), (oe = r.onPreviewNext) === null || oe === void 0 || oe.call(r)) : (re.value !== void 0 && U(J.value), (de = r.onPreviewPrev) === null || de === void 0 || de.call(r));
  }
  return Jr(Fb, { mergedClsPrefixRef: i, registerImageUrl: z, setThumbnailEl: (fe) => {
    var oe;
    (oe = d.value) === null || oe === void 0 || oe.setThumbnailEl(fe);
  }, toggleShow: (fe) => {
    ie(true), H(fe);
  }, groupId: l, renderToolbarRef: Dt(r, "renderToolbar") }), { mergedClsPrefix: i, previewInstRef: d, mergedShow: m, src: Q, onClose: te, next: () => {
    Se(1);
  }, prev: () => {
    Se(-1);
  } };
}, render() {
  return F(zb, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, src: this.src, show: this.mergedShow, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, onClose: this.onClose }, this.$slots);
} }), KT = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, Wg);
let JT = 0;
const Lb = st({ name: "Image", props: KT, slots: Object, inheritAttrs: false, setup(r) {
  const i = Ae(null), l = Ae(false), d = Ae(null), f = fr(Fb, null), { mergedClsPrefixRef: g } = f || Tr(r), m = ze(() => r.previewSrc || r.src), s = Ae(false), C = JT++, T = () => {
    if (r.previewDisabled || l.value) return;
    if (f) {
      f.setThumbnailEl(i.value), f.toggleShow(`r${C}`);
      return;
    }
    const { value: U } = d;
    U && (U.setThumbnailEl(i.value), s.value = true);
  }, M = { click: () => {
    T();
  }, showPreview: T }, z = Ae(!r.lazy);
  Qi(() => {
    var U;
    (U = i.value) === null || U === void 0 || U.setAttribute("data-group-id", (f == null ? void 0 : f.groupId) || "");
  }), Qi(() => {
    if (r.lazy && r.intersectionObserverOptions) {
      let U;
      const X = vo(() => {
        U == null ? void 0 : U(), U = void 0, U = Ek(i.value, r.intersectionObserverOptions, z);
      });
      Cn(() => {
        X(), U == null ? void 0 : U();
      });
    }
  }), vo(() => {
    var U;
    r.src || ((U = r.imgProps) === null || U === void 0 || U.src), l.value = false;
  }), vo((U) => {
    var X;
    const H = (X = f == null ? void 0 : f.registerImageUrl) === null || X === void 0 ? void 0 : X.call(f, C, m.value || "");
    U(() => {
      H == null ? void 0 : H();
    });
  });
  function L(U) {
    var X, H;
    M.showPreview(), (H = (X = r.imgProps) === null || X === void 0 ? void 0 : X.onClick) === null || H === void 0 || H.call(X, U);
  }
  function A() {
    s.value = false;
  }
  const O = Ae(false);
  return Jr(Db, { previewedImgPropsRef: Dt(r, "previewedImgProps") }), Object.assign({ mergedClsPrefix: g, groupId: f == null ? void 0 : f.groupId, previewInstRef: d, imageRef: i, mergedPreviewSrc: m, showError: l, shouldStartLoading: z, loaded: O, mergedOnClick: (U) => {
    L(U);
  }, onPreviewClose: A, mergedOnError: (U) => {
    if (!z.value) return;
    l.value = true;
    const { onError: X, imgProps: { onError: H } = {} } = r;
    X == null ? void 0 : X(U), H == null ? void 0 : H(U);
  }, mergedOnLoad: (U) => {
    const { onLoad: X, imgProps: { onLoad: H } = {} } = r;
    X == null ? void 0 : X(U), H == null ? void 0 : H(U), O.value = true;
  }, previewShow: s }, M);
}, render() {
  var r, i;
  const { mergedClsPrefix: l, imgProps: d = {}, loaded: f, $attrs: g, lazy: m } = this, s = Vn(this.$slots.error, () => []), C = (i = (r = this.$slots).placeholder) === null || i === void 0 ? void 0 : i.call(r), T = this.src || d.src, M = this.showError && s.length ? s : F("img", Object.assign(Object.assign({}, d), { ref: "imageRef", width: this.width || d.width, height: this.height || d.height, src: this.showError ? this.fallbackSrc : m && this.intersectionObserverOptions ? this.shouldStartLoading ? T : void 0 : T, alt: this.alt || d.alt, "aria-label": this.alt || d.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: Ik && m && !this.intersectionObserverOptions ? "lazy" : "eager", style: [d.style || "", C && !f ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return F("div", Object.assign({}, g, { role: "none", class: [g.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? M : F(zb, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, src: this.mergedPreviewSrc, show: !this.previewDisabled && this.previewShow, onClose: this.onPreviewClose }, { default: () => M }), !f && C);
} }), QT = qe([ue("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), ue("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function e5(r) {
  return r == null || typeof r == "string" && r.trim() === "" ? null : Number(r);
}
function t5(r) {
  return r.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(r) || /^-?\d*$/.test(r)) || r === "-" || r === "-0";
}
function jm(r) {
  return r == null ? true : !Number.isNaN(r);
}
function y_(r, i) {
  return typeof r != "number" ? "" : i === void 0 ? String(r) : r.toFixed(i);
}
function Nm(r) {
  if (r === null) return null;
  if (typeof r == "number") return r;
  {
    const i = Number(r);
    return Number.isNaN(i) ? null : i;
  }
}
const b_ = 800, x_ = 100, r5 = Object.assign(Object.assign({}, Yt.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), w_ = st({ name: "InputNumber", props: r5, slots: Object, setup(r) {
  const { mergedBorderedRef: i, mergedClsPrefixRef: l, mergedRtlRef: d } = Tr(r), f = Yt("InputNumber", "-input-number", QT, B2, r, l), { localeRef: g } = Ja("InputNumber"), m = ya(r), { mergedSizeRef: s, mergedDisabledRef: C, mergedStatusRef: T } = m, M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(r.defaultValue), O = Dt(r, "value"), U = Zi(O, A), X = Ae(""), H = (Ct) => {
    const Ee = String(Ct).split(".")[1];
    return Ee ? Ee.length : 0;
  }, Q = (Ct) => {
    const Ee = [r.min, r.max, r.step, Ct].map((ot) => ot === void 0 ? 0 : H(ot));
    return Math.max(...Ee);
  }, ie = pi(() => {
    const { placeholder: Ct } = r;
    return Ct !== void 0 ? Ct : g.value.placeholder;
  }), te = pi(() => {
    const Ct = Nm(r.step);
    return Ct !== null ? Ct === 0 ? 1 : Math.abs(Ct) : 1;
  }), re = pi(() => {
    const Ct = Nm(r.min);
    return Ct !== null ? Ct : null;
  }), J = pi(() => {
    const Ct = Nm(r.max);
    return Ct !== null ? Ct : null;
  }), Se = () => {
    const { value: Ct } = U;
    if (jm(Ct)) {
      const { format: Ee, precision: ot } = r;
      Ee ? X.value = Ee(Ct) : Ct === null || ot === void 0 || H(Ct) > ot ? X.value = y_(Ct, void 0) : X.value = y_(Ct, ot);
    } else X.value = String(Ct);
  };
  Se();
  const fe = (Ct) => {
    const { value: Ee } = U;
    if (Ct === Ee) {
      Se();
      return;
    }
    const { "onUpdate:value": ot, onUpdateValue: Le, onChange: Ye } = r, { nTriggerFormInput: ft, nTriggerFormChange: bt } = m;
    Ye && Ot(Ye, Ct), Le && Ot(Le, Ct), ot && Ot(ot, Ct), A.value = Ct, ft(), bt();
  }, oe = ({ offset: Ct, doUpdateIfValid: Ee, fixPrecision: ot, isInputing: Le }) => {
    const { value: Ye } = X;
    if (Le && t5(Ye)) return false;
    const ft = (r.parse || e5)(Ye);
    if (ft === null) return Ee && fe(null), null;
    if (jm(ft)) {
      const bt = H(ft), { precision: tt } = r;
      if (tt !== void 0 && tt < bt && !ot) return false;
      let mt = Number.parseFloat((ft + Ct).toFixed(tt ?? Q(ft)));
      if (jm(mt)) {
        const { value: Zt } = J, { value: ii } = re;
        if (Zt !== null && mt > Zt) {
          if (!Ee || Le) return false;
          mt = Zt;
        }
        if (ii !== null && mt < ii) {
          if (!Ee || Le) return false;
          mt = ii;
        }
        return r.validator && !r.validator(mt) ? false : (Ee && fe(mt), mt);
      }
    }
    return false;
  }, de = pi(() => oe({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), xe = pi(() => {
    const { value: Ct } = U;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = te;
    return oe({ offset: -Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), $e = pi(() => {
    const { value: Ct } = U;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = te;
    return oe({ offset: +Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function Ve(Ct) {
    const { onFocus: Ee } = r, { nTriggerFormFocus: ot } = m;
    Ee && Ot(Ee, Ct), ot();
  }
  function Ke(Ct) {
    var Ee, ot;
    if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
    const Le = oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if (Le !== false) {
      const bt = (ot = M.value) === null || ot === void 0 ? void 0 : ot.inputElRef;
      bt && (bt.value = String(Le || "")), U.value === Le && Se();
    } else Se();
    const { onBlur: Ye } = r, { nTriggerFormBlur: ft } = m;
    Ye && Ot(Ye, Ct), ft(), Nn(() => {
      Se();
    });
  }
  function lt(Ct) {
    const { onClear: Ee } = r;
    Ee && Ot(Ee, Ct);
  }
  function vt() {
    const { value: Ct } = $e;
    if (!Ct) {
      Jt();
      return;
    }
    const { value: Ee } = U;
    if (Ee === null) r.validator || fe(ht());
    else {
      const { value: ot } = te;
      oe({ offset: ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function xt() {
    const { value: Ct } = xe;
    if (!Ct) {
      zt();
      return;
    }
    const { value: Ee } = U;
    if (Ee === null) r.validator || fe(ht());
    else {
      const { value: ot } = te;
      oe({ offset: -ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const at = Ve, et = Ke;
  function ht() {
    if (r.validator) return null;
    const { value: Ct } = re, { value: Ee } = J;
    return Ct !== null ? Math.max(0, Ct) : Ee !== null ? Math.min(0, Ee) : 0;
  }
  function yt(Ct) {
    lt(Ct), fe(null);
  }
  function nt(Ct) {
    var Ee, ot, Le;
    !((Ee = L.value) === null || Ee === void 0) && Ee.$el.contains(Ct.target) && Ct.preventDefault(), !((ot = z.value) === null || ot === void 0) && ot.$el.contains(Ct.target) && Ct.preventDefault(), (Le = M.value) === null || Le === void 0 || Le.activate();
  }
  let ut = null, Lt = null, Ht = null;
  function zt() {
    Ht && (window.clearTimeout(Ht), Ht = null), ut && (window.clearInterval(ut), ut = null);
  }
  let pr = null;
  function Jt() {
    pr && (window.clearTimeout(pr), pr = null), Lt && (window.clearInterval(Lt), Lt = null);
  }
  function tr() {
    zt(), Ht = window.setTimeout(() => {
      ut = window.setInterval(() => {
        xt();
      }, x_);
    }, b_), En("mouseup", document, zt, { once: true });
  }
  function wr() {
    Jt(), pr = window.setTimeout(() => {
      Lt = window.setInterval(() => {
        vt();
      }, x_);
    }, b_), En("mouseup", document, Jt, { once: true });
  }
  const Er = () => {
    Lt || vt();
  }, rr = () => {
    ut || xt();
  };
  function sr(Ct) {
    var Ee, ot;
    if (Ct.key === "Enter") {
      if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
      oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((ot = M.value) === null || ot === void 0 || ot.deactivate());
    } else if (Ct.key === "ArrowUp") {
      if (!$e.value || r.keyboard.ArrowUp === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && vt();
    } else if (Ct.key === "ArrowDown") {
      if (!xe.value || r.keyboard.ArrowDown === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && xt();
    }
  }
  function qt(Ct) {
    X.value = Ct, r.updateValueOnInput && !r.format && !r.parse && r.precision === void 0 && oe({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  ar(U, () => {
    Se();
  });
  const Dr = { focus: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.focus();
  }, blur: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.blur();
  }, select: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.select();
  } }, Cr = Rn("InputNumber", d, l);
  return Object.assign(Object.assign({}, Dr), { rtlEnabled: Cr, inputInstRef: M, minusButtonInstRef: z, addButtonInstRef: L, mergedClsPrefix: l, mergedBordered: i, uncontrolledValue: A, mergedValue: U, mergedPlaceholder: ie, displayedValueInvalid: de, mergedSize: s, mergedDisabled: C, displayedValue: X, addable: $e, minusable: xe, mergedStatus: T, handleFocus: at, handleBlur: et, handleClear: yt, handleMouseDown: nt, handleAddClick: Er, handleMinusClick: rr, handleAddMousedown: wr, handleMinusMousedown: tr, handleKeyDown: sr, handleUpdateDisplayedValue: qt, mergedTheme: f, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: ze(() => {
    const { self: { iconColorDisabled: Ct } } = f.value, [Ee, ot, Le, Ye] = Zo(Ct);
    return { textColorTextDisabled: `rgb(${Ee}, ${ot}, ${Le})`, opacityDisabled: `${Ye}` };
  }) });
}, render() {
  const { mergedClsPrefix: r, $slots: i } = this, l = () => F(Gv, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => Vn(i["minus-icon"], () => [F(Nr, { clsPrefix: r }, { default: () => F(VS, null) })]) }), d = () => F(Gv, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => Vn(i["add-icon"], () => [F(Nr, { clsPrefix: r }, { default: () => F(ap, null) })]) });
  return F("div", { class: [`${r}-input-number`, this.rtlEnabled && `${r}-input-number--rtl`] }, F(mo, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var f;
    return this.showButton && this.buttonPlacement === "both" ? [l(), xi(i.prefix, (g) => g ? F("span", { class: `${r}-input-number-prefix` }, g) : null)] : (f = i.prefix) === null || f === void 0 ? void 0 : f.call(i);
  }, suffix: () => {
    var f;
    return this.showButton ? [xi(i.suffix, (g) => g ? F("span", { class: `${r}-input-number-suffix` }, g) : null), this.buttonPlacement === "right" ? l() : null, d()] : (f = i.suffix) === null || f === void 0 ? void 0 : f.call(i);
  } }));
} }), i5 = qe([ue("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ue("show-divider", [ue("list-item", [qe("&:not(:last-child)", [Re("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ue("clickable", [ue("list-item", `
 cursor: pointer;
 `)]), Ue("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ue("hoverable", [ue("list-item", `
 border-radius: var(--n-border-radius);
 `, [qe("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Re("divider", `
 background-color: transparent;
 `)])])]), Ue("bordered, hoverable", [ue("list-item", `
 padding: 12px 20px;
 `), Re("header, footer", `
 padding: 12px 20px;
 `)]), Re("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [qe("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), ue("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Re("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Re("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Re("main", `
 flex: 1;
 `), Re("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), Py(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), Ty(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), n5 = Object.assign(Object.assign({}, Yt.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), Bb = An("n-list"), lp = st({ name: "List", props: n5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Tr(r), f = Rn("List", d, i), g = Yt("List", "-list", i5, O2, r, i);
  Jr(Bb, { showDividerRef: Dt(r, "showDivider"), mergedClsPrefixRef: i });
  const m = ze(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: T, textColor: M, color: z, colorModal: L, colorPopover: A, borderColor: O, borderColorModal: U, borderColorPopover: X, borderRadius: H, colorHover: Q, colorHoverModal: ie, colorHoverPopover: te } } = g.value;
    return { "--n-font-size": T, "--n-bezier": C, "--n-text-color": M, "--n-color": z, "--n-border-radius": H, "--n-border-color": O, "--n-border-color-modal": U, "--n-border-color-popover": X, "--n-color-modal": L, "--n-color-popover": A, "--n-color-hover": Q, "--n-color-hover-modal": ie, "--n-color-hover-popover": te };
  }), s = l ? ci("list", void 0, m, r) : void 0;
  return { mergedClsPrefix: i, rtlEnabled: f, cssVars: l ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { $slots: i, mergedClsPrefix: l, onRender: d } = this;
  return d == null ? void 0 : d(), F("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, i.header ? F("div", { class: `${l}-list__header` }, i.header()) : null, (r = i.default) === null || r === void 0 ? void 0 : r.call(i), i.footer ? F("div", { class: `${l}-list__footer` }, i.footer()) : null);
} }), up = st({ name: "ListItem", slots: Object, setup() {
  const r = fr(Bb, null);
  return r || Yo("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: r.showDividerRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return F("li", { class: `${i}-list-item` }, r.prefix ? F("div", { class: `${i}-list-item__prefix` }, r.prefix()) : null, r.default ? F("div", { class: `${i}-list-item__main` }, r) : null, r.suffix ? F("div", { class: `${i}-list-item__suffix` }, r.suffix()) : null, this.showDivider && F("div", { class: `${i}-list-item__divider` }));
} }), Ob = An("n-popconfirm"), $b = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, C_ = Fd($b), o5 = st({ name: "NPopconfirmPanel", props: $b, setup(r) {
  const { localeRef: i } = Ja("Popconfirm"), { inlineThemeDisabled: l } = Tr(), { mergedClsPrefixRef: d, mergedThemeRef: f, props: g } = fr(Ob), m = ze(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: T, iconSize: M, iconColor: z } } = f.value;
    return { "--n-bezier": C, "--n-font-size": T, "--n-icon-size": M, "--n-icon-color": z };
  }), s = l ? ci("popconfirm-panel", void 0, m, g) : void 0;
  return Object.assign(Object.assign({}, Ja("Popconfirm")), { mergedClsPrefix: d, cssVars: l ? void 0 : m, localizedPositiveText: ze(() => r.positiveText || i.value.positiveText), localizedNegativeText: ze(() => r.negativeText || i.value.negativeText), positiveButtonProps: Dt(g, "positiveButtonProps"), negativeButtonProps: Dt(g, "negativeButtonProps"), handlePositiveClick(C) {
    r.onPositiveClick(C);
  }, handleNegativeClick(C) {
    r.onNegativeClick(C);
  }, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender });
}, render() {
  var r;
  const { mergedClsPrefix: i, showIcon: l, $slots: d } = this, f = Vn(d.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && F(Vr, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && F(Vr, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${i}-popconfirm__panel`, this.themeClass], style: this.cssVars }, xi(d.default, (g) => l || g ? F("div", { class: `${i}-popconfirm__body` }, l ? F("div", { class: `${i}-popconfirm__icon` }, Vn(d.icon, () => [F(Nr, { clsPrefix: i }, { default: () => F(tp, null) })])) : null, g) : null), f ? F("div", { class: [`${i}-popconfirm__action`] }, f) : null);
} }), a5 = ue("popconfirm", [Re("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Re("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Re("action", `
 display: flex;
 justify-content: flex-end;
 `, [qe("&:not(:first-child)", "margin-top: 8px"), ue("button", [qe("&:not(:last-child)", "margin-right: 8px;")])])]), s5 = Object.assign(Object.assign(Object.assign({}, Yt.props), j2), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), l5 = st({ name: "Popconfirm", props: s5, slots: Object, __popover__: true, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(), l = Yt("Popconfirm", "-popconfirm", a5, $2, r, i), d = Ae(null);
  function f(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onPositiveClick: T, "onUpdate:show": M } = r;
    Promise.resolve(T ? T(s) : true).then((z) => {
      var L;
      z !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  function g(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onNegativeClick: T, "onUpdate:show": M } = r;
    Promise.resolve(T ? T(s) : true).then((z) => {
      var L;
      z !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  return Jr(Ob, { mergedThemeRef: l, mergedClsPrefixRef: i, props: r }), { setShow(s) {
    var C;
    (C = d.value) === null || C === void 0 || C.setShow(s);
  }, syncPosition() {
    var s;
    (s = d.value) === null || s === void 0 || s.syncPosition();
  }, mergedTheme: l, popoverInstRef: d, handlePositiveClick: f, handleNegativeClick: g };
}, render() {
  const { $slots: r, $props: i, mergedTheme: l } = this;
  return F(Lg, Object.assign({}, jy(i, C_), { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: r.trigger, default: () => {
    const d = ng(i, C_);
    return F(o5, Object.assign({}, d, { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), r);
  } });
} }), u5 = { success: F($g, null), error: F(Bg, null), warning: F(tp, null), info: F(Og, null) }, c5 = st({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(r, { slots: i }) {
  const l = ze(() => {
    const g = "gradient", { fillColor: m } = r;
    return typeof m == "object" ? `${g}-${N2(JSON.stringify(m))}` : g;
  });
  function d(g, m, s, C) {
    const { gapDegree: T, viewBoxWidth: M, strokeWidth: z } = r, L = 50, A = 0, O = L, U = 0, X = 2 * L, H = 50 + z / 2, Q = `M ${H},${H} m ${A},${O}
      a ${L},${L} 0 1 1 ${U},${-X}
      a ${L},${L} 0 1 1 ${-U},${X}`, ie = Math.PI * 2 * L, te = { stroke: C === "rail" ? s : typeof r.fillColor == "object" ? `url(#${l.value})` : s, strokeDasharray: `${g / 100 * (ie - T)}px ${M * 8}px`, strokeDashoffset: `-${T / 2}px`, transformOrigin: m ? "center" : void 0, transform: m ? `rotate(${m}deg)` : void 0 };
    return { pathString: Q, pathStyle: te };
  }
  const f = () => {
    const g = typeof r.fillColor == "object", m = g ? r.fillColor.stops[0] : "", s = g ? r.fillColor.stops[1] : "";
    return g && F("defs", null, F("linearGradient", { id: l.value, x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, F("stop", { offset: "0%", "stop-color": m }), F("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: g, railColor: m, strokeWidth: s, offsetDegree: C, status: T, percentage: M, showIndicator: z, indicatorTextColor: L, unit: A, gapOffsetDegree: O, clsPrefix: U } = r, { pathString: X, pathStyle: H } = d(100, 0, m, "rail"), { pathString: Q, pathStyle: ie } = d(M, C, g, "fill"), te = 100 + s;
    return F("div", { class: `${U}-progress-content`, role: "none" }, F("div", { class: `${U}-progress-graph`, "aria-hidden": true }, F("div", { class: `${U}-progress-graph-circle`, style: { transform: O ? `rotate(${O}deg)` : void 0 } }, F("svg", { viewBox: `0 0 ${te} ${te}` }, f(), F("g", null, F("path", { class: `${U}-progress-graph-circle-rail`, d: X, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: H })), F("g", null, F("path", { class: [`${U}-progress-graph-circle-fill`, M === 0 && `${U}-progress-graph-circle-fill--empty`], d: Q, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: ie }))))), z ? F("div", null, i.default ? F("div", { class: `${U}-progress-custom-content`, role: "none" }, i.default()) : T !== "default" ? F("div", { class: `${U}-progress-icon`, "aria-hidden": true }, F(Nr, { clsPrefix: U }, { default: () => u5[T] })) : F("div", { class: `${U}-progress-text`, style: { color: L }, role: "none" }, F("span", { class: `${U}-progress-text__percentage` }, M), F("span", { class: `${U}-progress-text__unit` }, A))) : null);
  };
} }), d5 = { success: F($g, null), error: F(Bg, null), warning: F(tp, null), info: F(Og, null) }, h5 = st({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(r, { slots: i }) {
  const l = ze(() => Ho(r.height)), d = ze(() => {
    var m, s;
    return typeof r.fillColor == "object" ? `linear-gradient(to right, ${(m = r.fillColor) === null || m === void 0 ? void 0 : m.stops[0]} , ${(s = r.fillColor) === null || s === void 0 ? void 0 : s.stops[1]})` : r.fillColor;
  }), f = ze(() => r.railBorderRadius !== void 0 ? Ho(r.railBorderRadius) : r.height !== void 0 ? Ho(r.height, { c: 0.5 }) : ""), g = ze(() => r.fillBorderRadius !== void 0 ? Ho(r.fillBorderRadius) : r.railBorderRadius !== void 0 ? Ho(r.railBorderRadius) : r.height !== void 0 ? Ho(r.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: m, railColor: s, railStyle: C, percentage: T, unit: M, indicatorTextColor: z, status: L, showIndicator: A, processing: O, clsPrefix: U } = r;
    return F("div", { class: `${U}-progress-content`, role: "none" }, F("div", { class: `${U}-progress-graph`, "aria-hidden": true }, F("div", { class: [`${U}-progress-graph-line`, { [`${U}-progress-graph-line--indicator-${m}`]: true }] }, F("div", { class: `${U}-progress-graph-line-rail`, style: [{ backgroundColor: s, height: l.value, borderRadius: f.value }, C] }, F("div", { class: [`${U}-progress-graph-line-fill`, O && `${U}-progress-graph-line-fill--processing`], style: { maxWidth: `${r.percentage}%`, background: d.value, height: l.value, lineHeight: l.value, borderRadius: g.value } }, m === "inside" ? F("div", { class: `${U}-progress-graph-line-indicator`, style: { color: z } }, i.default ? i.default() : `${T}${M}`) : null)))), A && m === "outside" ? F("div", null, i.default ? F("div", { class: `${U}-progress-custom-content`, style: { color: z }, role: "none" }, i.default()) : L === "default" ? F("div", { role: "none", class: `${U}-progress-icon ${U}-progress-icon--as-text`, style: { color: z } }, T, M) : F("div", { class: `${U}-progress-icon`, "aria-hidden": true }, F(Nr, { clsPrefix: U }, { default: () => d5[L] }))) : null);
  };
} });
function S_(r, i, l = 100) {
  return `m ${l / 2} ${l / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
}
const f5 = st({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(r, { slots: i }) {
  const l = ze(() => r.percentage.map((g, m) => `${Math.PI * g / 100 * (r.viewBoxWidth / 2 - r.strokeWidth / 2 * (1 + 2 * m) - r.circleGap * m) * 2}, ${r.viewBoxWidth * 8}`)), d = (f, g) => {
    const m = r.fillColor[g], s = typeof m == "object" ? m.stops[0] : "", C = typeof m == "object" ? m.stops[1] : "";
    return typeof r.fillColor[g] == "object" && F("linearGradient", { id: `gradient-${g}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, F("stop", { offset: "0%", "stop-color": s }), F("stop", { offset: "100%", "stop-color": C }));
  };
  return () => {
    const { viewBoxWidth: f, strokeWidth: g, circleGap: m, showIndicator: s, fillColor: C, railColor: T, railStyle: M, percentage: z, clsPrefix: L } = r;
    return F("div", { class: `${L}-progress-content`, role: "none" }, F("div", { class: `${L}-progress-graph`, "aria-hidden": true }, F("div", { class: `${L}-progress-graph-circle` }, F("svg", { viewBox: `0 0 ${f} ${f}` }, F("defs", null, z.map((A, O) => d(A, O))), z.map((A, O) => F("g", { key: O }, F("path", { class: `${L}-progress-graph-circle-rail`, d: S_(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: T[O] }, M[O]] }), F("path", { class: [`${L}-progress-graph-circle-fill`, A === 0 && `${L}-progress-graph-circle-fill--empty`], d: S_(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[O], strokeDashoffset: 0, stroke: typeof C[O] == "object" ? `url(#gradient-${O})` : C[O] } })))))), s && i.default ? F("div", null, F("div", { class: `${L}-progress-text` }, i.default())) : null);
  };
} }), p5 = qe([ue("progress", { display: "inline-block" }, [ue("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ue("line", `
 width: 100%;
 display: block;
 `, [ue("progress-content", `
 display: flex;
 align-items: center;
 `, [ue("progress-graph", { flex: 1 })]), ue("progress-custom-content", { marginLeft: "14px" }), ue("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ue("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ue("circle, dashboard", { width: "120px" }, [ue("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), ue("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), ue("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ue("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [ue("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), ue("progress-content", { position: "relative" }), ue("progress-graph", { position: "relative" }, [ue("progress-graph-circle", [qe("svg", { verticalAlign: "bottom" }), ue("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ue("empty", { opacity: 0 })]), ue("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), ue("progress-graph-line", [Ue("indicator-inside", [ue("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [ue("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), ue("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ue("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [ue("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), ue("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ue("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [ue("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ue("processing", [qe("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), qe("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), m5 = Object.assign(Object.assign({}, Yt.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), g5 = st({ name: "Progress", props: m5, setup(r) {
  const i = ze(() => r.indicatorPlacement || r.indicatorPosition), l = ze(() => {
    if (r.gapDegree || r.gapDegree === 0) return r.gapDegree;
    if (r.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: d, inlineThemeDisabled: f } = Tr(r), g = Yt("Progress", "-progress", p5, V2, r, d), m = ze(() => {
    const { status: C } = r, { common: { cubicBezierEaseInOut: T }, self: { fontSize: M, fontSizeCircle: z, railColor: L, railHeight: A, iconSizeCircle: O, iconSizeLine: U, textColorCircle: X, textColorLineInner: H, textColorLineOuter: Q, lineBgProcessing: ie, fontWeightCircle: te, [jt("iconColor", C)]: re, [jt("fillColor", C)]: J } } = g.value;
    return { "--n-bezier": T, "--n-fill-color": J, "--n-font-size": M, "--n-font-size-circle": z, "--n-font-weight-circle": te, "--n-icon-color": re, "--n-icon-size-circle": O, "--n-icon-size-line": U, "--n-line-bg-processing": ie, "--n-rail-color": L, "--n-rail-height": A, "--n-text-color-circle": X, "--n-text-color-line-inner": H, "--n-text-color-line-outer": Q };
  }), s = f ? ci("progress", ze(() => r.status[0]), m, r) : void 0;
  return { mergedClsPrefix: d, mergedIndicatorPlacement: i, gapDeg: l, cssVars: f ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  const { type: r, cssVars: i, indicatorTextColor: l, showIndicator: d, status: f, railColor: g, railStyle: m, color: s, percentage: C, viewBoxWidth: T, strokeWidth: M, mergedIndicatorPlacement: z, unit: L, borderRadius: A, fillBorderRadius: O, height: U, processing: X, circleGap: H, mergedClsPrefix: Q, gapDeg: ie, gapOffsetDegree: te, themeClass: re, $slots: J, onRender: Se } = this;
  return Se == null ? void 0 : Se(), F("div", { class: [re, `${Q}-progress`, `${Q}-progress--${r}`, `${Q}-progress--${f}`], style: i, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": C, role: r === "circle" || r === "line" || r === "dashboard" ? "progressbar" : "none" }, r === "circle" || r === "dashboard" ? F(c5, { clsPrefix: Q, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, offsetDegree: this.offsetDegree, percentage: C, viewBoxWidth: T, strokeWidth: M, gapDegree: ie === void 0 ? r === "dashboard" ? 75 : 0 : ie, gapOffsetDegree: te, unit: L }, J) : r === "line" ? F(h5, { clsPrefix: Q, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, percentage: C, processing: X, indicatorPlacement: z, unit: L, fillBorderRadius: O, railBorderRadius: A, height: U }, J) : r === "multiple-circle" ? F(f5, { clsPrefix: Q, strokeWidth: M, railColor: g, fillColor: s, railStyle: m, viewBoxWidth: T, percentage: C, showIndicator: d, circleGap: H }, J) : null);
} }), v5 = qe([qe("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), ue("spin-container", `
 position: relative;
 `, [ue("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Nf()])]), ue("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), ue("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ue("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), ue("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), ue("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ue("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), _5 = { small: 20, medium: 18, large: 16 }, y5 = Object.assign(Object.assign({}, Yt.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), b5 = st({ name: "Spin", props: y5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Yt("Spin", "-spin", v5, U2, r, i), f = ze(() => {
    const { size: C } = r, { common: { cubicBezierEaseInOut: T }, self: M } = d.value, { opacitySpinning: z, color: L, textColor: A } = M, O = typeof C == "number" ? jn(C) : M[jt("size", C)];
    return { "--n-bezier": T, "--n-opacity-spinning": z, "--n-size": O, "--n-color": L, "--n-text-color": A };
  }), g = l ? ci("spin", ze(() => {
    const { size: C } = r;
    return typeof C == "number" ? String(C) : C[0];
  }), f, r) : void 0, m = jf(r, ["spinning", "show"]), s = Ae(false);
  return vo((C) => {
    let T;
    if (m.value) {
      const { delay: M } = r;
      if (M) {
        T = window.setTimeout(() => {
          s.value = true;
        }, M), C(() => {
          clearTimeout(T);
        });
        return;
      }
    }
    s.value = m.value;
  }), { mergedClsPrefix: i, active: s, mergedStrokeWidth: ze(() => {
    const { strokeWidth: C } = r;
    if (C !== void 0) return C;
    const { size: T } = r;
    return _5[typeof T == "number" ? "medium" : T];
  }), cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r, i;
  const { $slots: l, mergedClsPrefix: d, description: f } = this, g = l.icon && this.rotate, m = (f || l.description) && F("div", { class: `${d}-spin-description` }, f || ((r = l.description) === null || r === void 0 ? void 0 : r.call(l))), s = l.icon ? F("div", { class: [`${d}-spin-body`, this.themeClass] }, F("div", { class: [`${d}-spin`, g && `${d}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), m) : F("div", { class: [`${d}-spin-body`, this.themeClass] }, F(Jf, { clsPrefix: d, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${d}-spin` }), m);
  return (i = this.onRender) === null || i === void 0 || i.call(this), l.default ? F("div", { class: [`${d}-spin-container`, this.themeClass], style: this.cssVars }, F("div", { class: [`${d}-spin-content`, this.active && `${d}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), F(Ao, { name: "fade-in-transition" }, { default: () => this.active ? s : null })) : s;
} }), x5 = ue("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ue("horizontal", `
 flex-direction: row;
 `), Ue("vertical", `
 flex-direction: column;
 `), ue("split-pane-1", `
 overflow: hidden;
 `), ue("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Re("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), qe("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), w5 = Object.assign(Object.assign({}, Yt.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), k_ = st({ name: "Split", props: w5, slots: Object, setup(r) {
  var i;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(r), f = Yt("Split", "-split", x5, G2, r, l), g = ze(() => {
    const { common: { cubicBezierEaseInOut: ie }, self: { resizableTriggerColor: te, resizableTriggerColorHover: re } } = f.value;
    return { "--n-bezier": ie, "--n-resize-trigger-color": te, "--n-resize-trigger-color-hover": re };
  }), m = Ae(null), s = Ae(false), C = Dt(r, "size"), T = Ae(r.defaultSize);
  !((i = r.watchProps) === null || i === void 0) && i.includes("defaultSize") && vo(() => T.value = r.defaultSize);
  const M = (ie) => {
    const te = r["onUpdate:size"];
    r.onUpdateSize && Ot(r.onUpdateSize, ie), te && Ot(te, ie), T.value = ie;
  }, z = Zi(C, T), L = ze(() => {
    const ie = z.value;
    if (typeof ie == "string") return { flex: `0 0 ${ie}` };
    if (typeof ie == "number") {
      const te = ie * 100;
      return { flex: `0 0 calc(${te}% - ${r.resizeTriggerSize * te / 100}px)` };
    }
  }), A = ze(() => r.direction === "horizontal" ? { width: `${r.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${r.resizeTriggerSize}px` }), O = ze(() => {
    const ie = r.direction === "horizontal";
    return { width: ie ? `${r.resizeTriggerSize}px` : "", height: ie ? "" : `${r.resizeTriggerSize}px`, cursor: r.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let U = 0;
  const X = (ie) => {
    ie.preventDefault(), s.value = true, r.onDragStart && r.onDragStart(ie);
    const te = "mousemove", re = "mouseup", J = (oe) => {
      H(oe), r.onDragMove && r.onDragMove(oe);
    }, Se = () => {
      Hn(te, document, J), Hn(re, document, Se), s.value = false, r.onDragEnd && r.onDragEnd(ie), document.body.style.cursor = "";
    };
    document.body.style.cursor = O.value.cursor, En(te, document, J), En(re, document, Se);
    const fe = m.value;
    if (fe) {
      const oe = fe.getBoundingClientRect();
      r.direction === "horizontal" ? U = ie.clientX - oe.left : U = oe.top - ie.clientY;
    }
    H(ie);
  };
  function H(ie) {
    var te, re;
    const J = (re = (te = m.value) === null || te === void 0 ? void 0 : te.parentElement) === null || re === void 0 ? void 0 : re.getBoundingClientRect();
    if (!J) return;
    const { direction: Se } = r, fe = J.width - r.resizeTriggerSize, oe = J.height - r.resizeTriggerSize, de = Se === "horizontal" ? fe : oe, xe = Se === "horizontal" ? ie.clientX - J.left - U : ie.clientY - J.top + U, { min: $e, max: Ve } = r, Ke = typeof $e == "string" ? Ji($e) : $e * de, lt = typeof Ve == "string" ? Ji(Ve) : Ve * de;
    let vt = xe;
    vt = Math.max(vt, Ke), vt = Math.min(vt, lt, de), typeof z.value == "string" ? M(`${vt}px`) : M(vt / de);
  }
  const Q = d ? ci("split", void 0, g, r) : void 0;
  return { themeClass: Q == null ? void 0 : Q.themeClass, onRender: Q == null ? void 0 : Q.onRender, cssVars: d ? void 0 : g, resizeTriggerElRef: m, isDragging: s, mergedClsPrefix: l, resizeTriggerWrapperStyle: O, resizeTriggerStyle: A, handleMouseDown: X, firstPaneStyle: L };
}, render() {
  var r, i, l, d, f;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, F("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (i = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(i)), !this.disabled && F("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, Vn(this.$slots["resize-trigger"], () => [F("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), F("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (f = (d = this.$slots)[2]) === null || f === void 0 ? void 0 : f.call(d)));
} }), C5 = ue("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Re("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Re("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Re("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), ue("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Ld({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Re("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Re("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Re("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), qe("&:focus", [Re("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ue("round", [Re("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Re("button", "border-radius: calc(var(--n-button-height) / 2);")])]), ui("disabled", [ui("icon", [Ue("rubber-band", [Ue("pressed", [Re("rail", [Re("button", "max-width: var(--n-button-width-pressed);")])]), Re("rail", [qe("&:active", [Re("button", "max-width: var(--n-button-width-pressed);")])]), Ue("active", [Ue("pressed", [Re("rail", [Re("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Re("rail", [qe("&:active", [Re("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ue("active", [Re("rail", [Re("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Re("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Re("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Ld()]), Re("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ue("active", [Re("rail", "background-color: var(--n-rail-color-active);")]), Ue("loading", [Re("rail", `
 cursor: wait;
 `)]), Ue("disabled", [Re("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), S5 = Object.assign(Object.assign({}, Yt.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let wd;
const jb = st({ name: "Switch", props: S5, slots: Object, setup(r) {
  wd === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? wd = CSS.supports("width", "max(1px)") : wd = false : wd = true);
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Yt("Switch", "-switch", C5, q2, r, i), f = ya(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, s = Ae(r.defaultValue), C = Dt(r, "value"), T = Zi(C, s), M = ze(() => T.value === r.checkedValue), z = Ae(false), L = Ae(false), A = ze(() => {
    const { railStyle: fe } = r;
    if (fe) return fe({ focused: L.value, checked: M.value });
  });
  function O(fe) {
    const { "onUpdate:value": oe, onChange: de, onUpdateValue: xe } = r, { nTriggerFormInput: $e, nTriggerFormChange: Ve } = f;
    oe && Ot(oe, fe), xe && Ot(xe, fe), de && Ot(de, fe), s.value = fe, $e(), Ve();
  }
  function U() {
    const { nTriggerFormFocus: fe } = f;
    fe();
  }
  function X() {
    const { nTriggerFormBlur: fe } = f;
    fe();
  }
  function H() {
    r.loading || m.value || (T.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue));
  }
  function Q() {
    L.value = true, U();
  }
  function ie() {
    L.value = false, X(), z.value = false;
  }
  function te(fe) {
    r.loading || m.value || fe.key === " " && (T.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue), z.value = false);
  }
  function re(fe) {
    r.loading || m.value || fe.key === " " && (fe.preventDefault(), z.value = true);
  }
  const J = ze(() => {
    const { value: fe } = g, { self: { opacityDisabled: oe, railColor: de, railColorActive: xe, buttonBoxShadow: $e, buttonColor: Ve, boxShadowFocus: Ke, loadingColor: lt, textColor: vt, iconColor: xt, [jt("buttonHeight", fe)]: at, [jt("buttonWidth", fe)]: et, [jt("buttonWidthPressed", fe)]: ht, [jt("railHeight", fe)]: yt, [jt("railWidth", fe)]: nt, [jt("railBorderRadius", fe)]: ut, [jt("buttonBorderRadius", fe)]: Lt }, common: { cubicBezierEaseInOut: Ht } } = d.value;
    let zt, pr, Jt;
    return wd ? (zt = `calc((${yt} - ${at}) / 2)`, pr = `max(${yt}, ${at})`, Jt = `max(${nt}, calc(${nt} + ${at} - ${yt}))`) : (zt = jn((Ji(yt) - Ji(at)) / 2), pr = jn(Math.max(Ji(yt), Ji(at))), Jt = Ji(yt) > Ji(at) ? nt : jn(Ji(nt) + Ji(at) - Ji(yt))), { "--n-bezier": Ht, "--n-button-border-radius": Lt, "--n-button-box-shadow": $e, "--n-button-color": Ve, "--n-button-width": et, "--n-button-width-pressed": ht, "--n-button-height": at, "--n-height": pr, "--n-offset": zt, "--n-opacity-disabled": oe, "--n-rail-border-radius": ut, "--n-rail-color": de, "--n-rail-color-active": xe, "--n-rail-height": yt, "--n-rail-width": nt, "--n-width": Jt, "--n-box-shadow-focus": Ke, "--n-loading-color": lt, "--n-text-color": vt, "--n-icon-color": xt };
  }), Se = l ? ci("switch", ze(() => g.value[0]), J, r) : void 0;
  return { handleClick: H, handleBlur: ie, handleFocus: Q, handleKeyup: te, handleKeydown: re, mergedRailStyle: A, pressed: z, mergedClsPrefix: i, mergedValue: T, checked: M, mergedDisabled: m, cssVars: l ? void 0 : J, themeClass: Se == null ? void 0 : Se.themeClass, onRender: Se == null ? void 0 : Se.onRender };
}, render() {
  const { mergedClsPrefix: r, mergedDisabled: i, checked: l, mergedRailStyle: d, onRender: f, $slots: g } = this;
  f == null ? void 0 : f();
  const { checked: m, unchecked: s, icon: C, "checked-icon": T, "unchecked-icon": M } = g, z = !(Tm(C) && Tm(T) && Tm(M));
  return F("div", { role: "switch", "aria-checked": l, class: [`${r}-switch`, this.themeClass, z && `${r}-switch--icon`, l && `${r}-switch--active`, i && `${r}-switch--disabled`, this.round && `${r}-switch--round`, this.loading && `${r}-switch--loading`, this.pressed && `${r}-switch--pressed`, this.rubberBand && `${r}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, F("div", { class: `${r}-switch__rail`, "aria-hidden": "true", style: d }, xi(m, (L) => xi(s, (A) => L || A ? F("div", { "aria-hidden": true, class: `${r}-switch__children-placeholder` }, F("div", { class: `${r}-switch__rail-placeholder` }, F("div", { class: `${r}-switch__button-placeholder` }), L), F("div", { class: `${r}-switch__rail-placeholder` }, F("div", { class: `${r}-switch__button-placeholder` }), A)) : null)), F("div", { class: `${r}-switch__button` }, xi(C, (L) => xi(T, (A) => xi(M, (O) => F(Yf, null, { default: () => this.loading ? F(Jf, { key: "loading", clsPrefix: r, strokeWidth: 20 }) : this.checked && (A || L) ? F("div", { class: `${r}-switch__button-icon`, key: A ? "checked-icon" : "icon" }, A || L) : !this.checked && (O || L) ? F("div", { class: `${r}-switch__button-icon`, key: O ? "unchecked-icon" : "icon" }, O || L) : null })))), xi(m, (L) => L && F("div", { key: "checked", class: `${r}-switch__checked` }, L)), xi(s, (L) => L && F("div", { key: "unchecked", class: `${r}-switch__unchecked` }, L)))));
} }), Zg = An("n-tabs"), Nb = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, P_ = st({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: Nb, slots: Object, setup(r) {
  const i = fr(Zg, null);
  return i || Yo("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: i.paneStyleRef, class: i.paneClassRef, mergedClsPrefix: i.mergedClsPrefixRef };
}, render() {
  return F("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), k5 = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, jy(Nb, ["displayDirective"])), Cg = st({ __TAB__: true, inheritAttrs: false, name: "Tab", props: k5, setup(r) {
  const { mergedClsPrefixRef: i, valueRef: l, typeRef: d, closableRef: f, tabStyleRef: g, addTabStyleRef: m, tabClassRef: s, addTabClassRef: C, tabChangeIdRef: T, onBeforeLeaveRef: M, triggerRef: z, handleAdd: L, activateTab: A, handleClose: O } = fr(Zg);
  return { trigger: z, mergedClosable: ze(() => {
    if (r.internalAddable) return false;
    const { closable: U } = r;
    return U === void 0 ? f.value : U;
  }), style: g, addStyle: m, tabClass: s, addTabClass: C, clsPrefix: i, value: l, type: d, handleClose(U) {
    U.stopPropagation(), !r.disabled && O(r.name);
  }, activateTab() {
    if (r.disabled) return;
    if (r.internalAddable) {
      L();
      return;
    }
    const { name: U } = r, X = ++T.id;
    if (U !== l.value) {
      const { value: H } = M;
      H ? Promise.resolve(H(r.name, l.value)).then((Q) => {
        Q && T.id === X && A(U);
      }) : A(U);
    }
  } };
}, render() {
  const { internalAddable: r, clsPrefix: i, name: l, disabled: d, label: f, tab: g, value: m, mergedClosable: s, trigger: C, $slots: { default: T } } = this, M = f ?? g;
  return F("div", { class: `${i}-tabs-tab-wrapper` }, this.internalLeftPadded ? F("div", { class: `${i}-tabs-tab-pad` }) : null, F("div", Object.assign({ key: l, "data-name": l, "data-disabled": d ? true : void 0 }, Ya({ class: [`${i}-tabs-tab`, m === l && `${i}-tabs-tab--active`, d && `${i}-tabs-tab--disabled`, s && `${i}-tabs-tab--closable`, r && `${i}-tabs-tab--addable`, r ? this.addTabClass : this.tabClass], onClick: C === "click" ? this.activateTab : void 0, onMouseenter: C === "hover" ? this.activateTab : void 0, style: r ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), F("span", { class: `${i}-tabs-tab__label` }, r ? F(qr, null, F("div", { class: `${i}-tabs-tab__height-placeholder` }, "\xA0"), F(Nr, { clsPrefix: i }, { default: () => F(ap, null) })) : T ? T() : typeof M == "object" ? M : wl(M ?? l)), s && this.type === "card" ? F(Qf, { clsPrefix: i, class: `${i}-tabs-tab__close`, onClick: this.handleClose, disabled: d }) : null));
} }), P5 = ue("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ue("segment-type", [ue("tabs-rail", [qe("&.transition-disabled", [ue("tabs-capsule", `
 transition: none;
 `)])])]), Ue("top", [ue("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ue("left", [ue("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ue("left, right", `
 flex-direction: row;
 `, [ue("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ue("right", `
 flex-direction: row-reverse;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), ue("tabs-bar", `
 left: 0;
 `)]), Ue("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), ue("tabs-bar", `
 top: 0;
 `)]), ue("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), ue("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [ue("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ue("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), qe("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ue("flex", [ue("tabs-nav", `
 width: 100%;
 position: relative;
 `, [ue("tabs-wrapper", `
 width: 100%;
 `, [ue("tabs-tab", `
 margin-right: 0;
 `)])])]), ue("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Re("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Re("prefix", "padding-right: 16px;"), Re("suffix", "padding-left: 16px;")]), Ue("top, bottom", [qe(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [qe("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), qe("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ue("shadow-start", [qe("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [qe("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), Ue("left, right", [ue("tabs-nav-scroll-content", `
 flex-direction: column;
 `), qe(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [qe("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), qe("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ue("shadow-start", [qe("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [qe("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), ue("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [ue("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [qe("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), qe("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), ue("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), ue("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), ue("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), ue("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ue("disabled", { cursor: "not-allowed" }), Re("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Re("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), ue("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [qe("&.transition-disabled", `
 transition: none;
 `), Ue("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), ue("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), ue("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [qe("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), qe("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), qe("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), qe("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), qe("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), ue("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ue("line-type, bar-type", [ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [qe("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ue("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ue("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), ue("tabs-nav", [Ue("line-type", [Ue("top", [Re("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 bottom: -1px;
 `)]), Ue("left", [Re("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 right: -1px;
 `)]), Ue("right", [Re("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 left: -1px;
 `)]), Ue("bottom", [Re("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 top: -1px;
 `)]), Re("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-bar", `
 border-radius: 0;
 `)]), Ue("card-type", [Re("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ue("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Re("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), ui("disabled", [qe("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ue("closable", "padding-right: 8px;"), Ue("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ue("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ue("left, right", `
 flex-direction: column; 
 `, [Re("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), ue("tabs-wrapper", `
 flex-direction: column;
 `), ue("tabs-tab-wrapper", `
 flex-direction: column;
 `, [ue("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ue("top", [Ue("card-type", [ue("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-bottom: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ue("left", [Ue("card-type", [ue("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-right: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ue("right", [Ue("card-type", [ue("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-left: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ue("bottom", [Ue("card-type", [ue("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-top: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), Vm = n3, T5 = Object.assign(Object.assign({}, Yt.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), I5 = st({ name: "Tabs", props: T5, slots: Object, setup(r, { slots: i }) {
  var l, d, f, g;
  const { mergedClsPrefixRef: m, inlineThemeDisabled: s } = Tr(r), C = Yt("Tabs", "-tabs", P5, W2, r, m), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(null), O = Ae(null), U = Ae(true), X = Ae(true), H = jf(r, ["labelSize", "size"]), Q = jf(r, ["activeName", "value"]), ie = Ae((d = (l = Q.value) !== null && l !== void 0 ? l : r.defaultValue) !== null && d !== void 0 ? d : i.default ? (g = (f = El(i.default())[0]) === null || f === void 0 ? void 0 : f.props) === null || g === void 0 ? void 0 : g.name : null), te = Zi(Q, ie), re = { id: 0 }, J = ze(() => {
    if (!(!r.justifyContent || r.type === "card")) return { display: "flex", justifyContent: r.justifyContent };
  });
  ar(te, () => {
    re.id = 0, xe(), $e();
  });
  function Se() {
    var Le;
    const { value: Ye } = te;
    return Ye === null ? null : (Le = T.value) === null || Le === void 0 ? void 0 : Le.querySelector(`[data-name="${Ye}"]`);
  }
  function fe(Le) {
    if (r.type === "card") return;
    const { value: Ye } = M;
    if (!Ye) return;
    const ft = Ye.style.opacity === "0";
    if (Le) {
      const bt = `${m.value}-tabs-bar--disabled`, { barWidth: tt, placement: mt } = r;
      if (Le.dataset.disabled === "true" ? Ye.classList.add(bt) : Ye.classList.remove(bt), ["top", "bottom"].includes(mt)) {
        if (de(["top", "maxHeight", "height"]), typeof tt == "number" && Le.offsetWidth >= tt) {
          const Zt = Math.floor((Le.offsetWidth - tt) / 2) + Le.offsetLeft;
          Ye.style.left = `${Zt}px`, Ye.style.maxWidth = `${tt}px`;
        } else Ye.style.left = `${Le.offsetLeft}px`, Ye.style.maxWidth = `${Le.offsetWidth}px`;
        Ye.style.width = "8192px", ft && (Ye.style.transition = "none"), Ye.offsetWidth, ft && (Ye.style.transition = "", Ye.style.opacity = "1");
      } else {
        if (de(["left", "maxWidth", "width"]), typeof tt == "number" && Le.offsetHeight >= tt) {
          const Zt = Math.floor((Le.offsetHeight - tt) / 2) + Le.offsetTop;
          Ye.style.top = `${Zt}px`, Ye.style.maxHeight = `${tt}px`;
        } else Ye.style.top = `${Le.offsetTop}px`, Ye.style.maxHeight = `${Le.offsetHeight}px`;
        Ye.style.height = "8192px", ft && (Ye.style.transition = "none"), Ye.offsetHeight, ft && (Ye.style.transition = "", Ye.style.opacity = "1");
      }
    }
  }
  function oe() {
    if (r.type === "card") return;
    const { value: Le } = M;
    Le && (Le.style.opacity = "0");
  }
  function de(Le) {
    const { value: Ye } = M;
    if (Ye) for (const ft of Le) Ye.style[ft] = "";
  }
  function xe() {
    if (r.type === "card") return;
    const Le = Se();
    Le ? fe(Le) : oe();
  }
  function $e() {
    var Le;
    const Ye = (Le = A.value) === null || Le === void 0 ? void 0 : Le.$el;
    if (!Ye) return;
    const ft = Se();
    if (!ft) return;
    const { scrollLeft: bt, offsetWidth: tt } = Ye, { offsetLeft: mt, offsetWidth: Zt } = ft;
    bt > mt ? Ye.scrollTo({ top: 0, left: mt, behavior: "smooth" }) : mt + Zt > bt + tt && Ye.scrollTo({ top: 0, left: mt + Zt - tt, behavior: "smooth" });
  }
  const Ve = Ae(null);
  let Ke = 0, lt = null;
  function vt(Le) {
    const Ye = Ve.value;
    if (Ye) {
      Ke = Le.getBoundingClientRect().height;
      const ft = `${Ke}px`, bt = () => {
        Ye.style.height = ft, Ye.style.maxHeight = ft;
      };
      lt ? (bt(), lt(), lt = null) : lt = bt;
    }
  }
  function xt(Le) {
    const Ye = Ve.value;
    if (Ye) {
      const ft = Le.getBoundingClientRect().height, bt = () => {
        document.body.offsetHeight, Ye.style.maxHeight = `${ft}px`, Ye.style.height = `${Math.max(Ke, ft)}px`;
      };
      lt ? (lt(), lt = null, bt()) : lt = bt;
    }
  }
  function at() {
    const Le = Ve.value;
    if (Le) {
      Le.style.maxHeight = "", Le.style.height = "";
      const { paneWrapperStyle: Ye } = r;
      if (typeof Ye == "string") Le.style.cssText = Ye;
      else if (Ye) {
        const { maxHeight: ft, height: bt } = Ye;
        ft !== void 0 && (Le.style.maxHeight = ft), bt !== void 0 && (Le.style.height = bt);
      }
    }
  }
  const et = { value: [] }, ht = Ae("next");
  function yt(Le) {
    const Ye = te.value;
    let ft = "next";
    for (const bt of et.value) {
      if (bt === Ye) break;
      if (bt === Le) {
        ft = "prev";
        break;
      }
    }
    ht.value = ft, nt(Le);
  }
  function nt(Le) {
    const { onActiveNameChange: Ye, onUpdateValue: ft, "onUpdate:value": bt } = r;
    Ye && Ot(Ye, Le), ft && Ot(ft, Le), bt && Ot(bt, Le), ie.value = Le;
  }
  function ut(Le) {
    const { onClose: Ye } = r;
    Ye && Ot(Ye, Le);
  }
  function Lt() {
    const { value: Le } = M;
    if (!Le) return;
    const Ye = "transition-disabled";
    Le.classList.add(Ye), xe(), Le.classList.remove(Ye);
  }
  const Ht = Ae(null);
  function zt({ transitionDisabled: Le }) {
    const Ye = T.value;
    if (!Ye) return;
    Le && Ye.classList.add("transition-disabled");
    const ft = Se();
    ft && Ht.value && (Ht.value.style.width = `${ft.offsetWidth}px`, Ht.value.style.height = `${ft.offsetHeight}px`, Ht.value.style.transform = `translateX(${ft.offsetLeft - Ji(getComputedStyle(Ye).paddingLeft)}px)`, Le && Ht.value.offsetWidth), Le && Ye.classList.remove("transition-disabled");
  }
  ar([te], () => {
    r.type === "segment" && Nn(() => {
      zt({ transitionDisabled: false });
    });
  }), Qi(() => {
    r.type === "segment" && zt({ transitionDisabled: true });
  });
  let pr = 0;
  function Jt(Le) {
    var Ye;
    if (Le.contentRect.width === 0 && Le.contentRect.height === 0 || pr === Le.contentRect.width) return;
    pr = Le.contentRect.width;
    const { type: ft } = r;
    if ((ft === "line" || ft === "bar") && Lt(), ft !== "segment") {
      const { placement: bt } = r;
      qt((bt === "top" || bt === "bottom" ? (Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el : O.value) || null);
    }
  }
  const tr = Vm(Jt, 64);
  ar([() => r.justifyContent, () => r.size], () => {
    Nn(() => {
      const { type: Le } = r;
      (Le === "line" || Le === "bar") && Lt();
    });
  });
  const wr = Ae(false);
  function Er(Le) {
    var Ye;
    const { target: ft, contentRect: { width: bt, height: tt } } = Le, mt = ft.parentElement.parentElement.offsetWidth, Zt = ft.parentElement.parentElement.offsetHeight, { placement: ii } = r;
    if (!wr.value) ii === "top" || ii === "bottom" ? mt < bt && (wr.value = true) : Zt < tt && (wr.value = true);
    else {
      const { value: wi } = L;
      if (!wi) return;
      ii === "top" || ii === "bottom" ? mt - bt > wi.$el.offsetWidth && (wr.value = false) : Zt - tt > wi.$el.offsetHeight && (wr.value = false);
    }
    qt(((Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el) || null);
  }
  const rr = Vm(Er, 64);
  function sr() {
    const { onAdd: Le } = r;
    Le && Le(), Nn(() => {
      const Ye = Se(), { value: ft } = A;
      !Ye || !ft || ft.scrollTo({ left: Ye.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function qt(Le) {
    if (!Le) return;
    const { placement: Ye } = r;
    if (Ye === "top" || Ye === "bottom") {
      const { scrollLeft: ft, scrollWidth: bt, offsetWidth: tt } = Le;
      U.value = ft <= 0, X.value = ft + tt >= bt;
    } else {
      const { scrollTop: ft, scrollHeight: bt, offsetHeight: tt } = Le;
      U.value = ft <= 0, X.value = ft + tt >= bt;
    }
  }
  const Dr = Vm((Le) => {
    qt(Le.target);
  }, 64);
  Jr(Zg, { triggerRef: Dt(r, "trigger"), tabStyleRef: Dt(r, "tabStyle"), tabClassRef: Dt(r, "tabClass"), addTabStyleRef: Dt(r, "addTabStyle"), addTabClassRef: Dt(r, "addTabClass"), paneClassRef: Dt(r, "paneClass"), paneStyleRef: Dt(r, "paneStyle"), mergedClsPrefixRef: m, typeRef: Dt(r, "type"), closableRef: Dt(r, "closable"), valueRef: te, tabChangeIdRef: re, onBeforeLeaveRef: Dt(r, "onBeforeLeave"), activateTab: yt, handleClose: ut, handleAdd: sr }), ky(() => {
    xe(), $e();
  }), vo(() => {
    const { value: Le } = z;
    if (!Le) return;
    const { value: Ye } = m, ft = `${Ye}-tabs-nav-scroll-wrapper--shadow-start`, bt = `${Ye}-tabs-nav-scroll-wrapper--shadow-end`;
    U.value ? Le.classList.remove(ft) : Le.classList.add(ft), X.value ? Le.classList.remove(bt) : Le.classList.add(bt);
  });
  const Cr = { syncBarPosition: () => {
    xe();
  } }, Ct = () => {
    zt({ transitionDisabled: true });
  }, Ee = ze(() => {
    const { value: Le } = H, { type: Ye } = r, ft = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[Ye], bt = `${Le}${ft}`, { self: { barColor: tt, closeIconColor: mt, closeIconColorHover: Zt, closeIconColorPressed: ii, tabColor: wi, tabBorderColor: Fe, paneTextColor: Z, tabFontWeight: Y, tabBorderRadius: ne, tabFontWeightActive: _e, colorSegment: Te, fontWeightStrong: De, tabColorSegment: he, closeSize: ve, closeIconSize: je, closeColorHover: it, closeColorPressed: Xe, closeBorderRadius: wt, [jt("panePadding", Le)]: Pe, [jt("tabPadding", bt)]: $t, [jt("tabPaddingVertical", bt)]: Qt, [jt("tabGap", bt)]: Nt, [jt("tabGap", `${bt}Vertical`)]: ur, [jt("tabTextColor", Ye)]: Br, [jt("tabTextColorActive", Ye)]: Qr, [jt("tabTextColorHover", Ye)]: ei, [jt("tabTextColorDisabled", Ye)]: ni, [jt("tabFontSize", Le)]: gr }, common: { cubicBezierEaseInOut: yr } } = C.value;
    return { "--n-bezier": yr, "--n-color-segment": Te, "--n-bar-color": tt, "--n-tab-font-size": gr, "--n-tab-text-color": Br, "--n-tab-text-color-active": Qr, "--n-tab-text-color-disabled": ni, "--n-tab-text-color-hover": ei, "--n-pane-text-color": Z, "--n-tab-border-color": Fe, "--n-tab-border-radius": ne, "--n-close-size": ve, "--n-close-icon-size": je, "--n-close-color-hover": it, "--n-close-color-pressed": Xe, "--n-close-border-radius": wt, "--n-close-icon-color": mt, "--n-close-icon-color-hover": Zt, "--n-close-icon-color-pressed": ii, "--n-tab-color": wi, "--n-tab-font-weight": Y, "--n-tab-font-weight-active": _e, "--n-tab-padding": $t, "--n-tab-padding-vertical": Qt, "--n-tab-gap": Nt, "--n-tab-gap-vertical": ur, "--n-pane-padding-left": Ro(Pe, "left"), "--n-pane-padding-right": Ro(Pe, "right"), "--n-pane-padding-top": Ro(Pe, "top"), "--n-pane-padding-bottom": Ro(Pe, "bottom"), "--n-font-weight-strong": De, "--n-tab-color-segment": he };
  }), ot = s ? ci("tabs", ze(() => `${H.value[0]}${r.type[0]}`), Ee, r) : void 0;
  return Object.assign({ mergedClsPrefix: m, mergedValue: te, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: Ht, tabsPaneWrapperRef: Ve, tabsElRef: T, barElRef: M, addTabInstRef: L, xScrollInstRef: A, scrollWrapperElRef: z, addTabFixed: wr, tabWrapperStyle: J, handleNavResize: tr, mergedSize: H, handleScroll: Dr, handleTabsResize: rr, cssVars: s ? void 0 : Ee, themeClass: ot == null ? void 0 : ot.themeClass, animationDirection: ht, renderNameListRef: et, yScrollElRef: O, handleSegmentResize: Ct, onAnimationBeforeLeave: vt, onAnimationEnter: xt, onAnimationAfterEnter: at, onRender: ot == null ? void 0 : ot.onRender }, Cr);
}, render() {
  const { mergedClsPrefix: r, type: i, placement: l, addTabFixed: d, addable: f, mergedSize: g, renderNameListRef: m, onRender: s, paneWrapperClass: C, paneWrapperStyle: T, $slots: { default: M, prefix: z, suffix: L } } = this;
  s == null ? void 0 : s();
  const A = M ? El(M()).filter((re) => re.type.__TAB_PANE__ === true) : [], O = M ? El(M()).filter((re) => re.type.__TAB__ === true) : [], U = !O.length, X = i === "card", H = i === "segment", Q = !X && !H && this.justifyContent;
  m.value = [];
  const ie = () => {
    const re = F("div", { style: this.tabWrapperStyle, class: `${r}-tabs-wrapper` }, Q ? null : F("div", { class: `${r}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), U ? A.map((J, Se) => (m.value.push(J.props.name), Um(F(Cg, Object.assign({}, J.props, { internalCreatedByPane: true, internalLeftPadded: Se !== 0 && (!Q || Q === "center" || Q === "start" || Q === "end") }), J.children ? { default: J.children.tab } : void 0)))) : O.map((J, Se) => (m.value.push(J.props.name), Um(Se !== 0 && !Q ? M_(J) : J))), !d && f && X ? I_(f, (U ? A.length : O.length) !== 0) : null, Q ? null : F("div", { class: `${r}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return F("div", { ref: "tabsElRef", class: `${r}-tabs-nav-scroll-content` }, X && f ? F(Pl, { onResize: this.handleTabsResize }, { default: () => re }) : re, X ? F("div", { class: `${r}-tabs-pad` }) : null, X ? null : F("div", { ref: "barElRef", class: `${r}-tabs-bar` }));
  }, te = H ? "top" : l;
  return F("div", { class: [`${r}-tabs`, this.themeClass, `${r}-tabs--${i}-type`, `${r}-tabs--${g}-size`, Q && `${r}-tabs--flex`, `${r}-tabs--${te}`], style: this.cssVars }, F("div", { class: [`${r}-tabs-nav--${i}-type`, `${r}-tabs-nav--${te}`, `${r}-tabs-nav`] }, xi(z, (re) => re && F("div", { class: `${r}-tabs-nav__prefix` }, re)), H ? F(Pl, { onResize: this.handleSegmentResize }, { default: () => F("div", { class: `${r}-tabs-rail`, ref: "tabsElRef" }, F("div", { class: `${r}-tabs-capsule`, ref: "segmentCapsuleElRef" }, F("div", { class: `${r}-tabs-wrapper` }, F("div", { class: `${r}-tabs-tab` }))), U ? A.map((re, J) => (m.value.push(re.props.name), F(Cg, Object.assign({}, re.props, { internalCreatedByPane: true, internalLeftPadded: J !== 0 }), re.children ? { default: re.children.tab } : void 0))) : O.map((re, J) => (m.value.push(re.props.name), J === 0 ? re : M_(re)))) }) : F(Pl, { onResize: this.handleNavResize }, { default: () => F("div", { class: `${r}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(te) ? F(G3, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: ie }) : F("div", { class: `${r}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, ie())) }), d && f && X ? I_(f, true) : null, xi(L, (re) => re && F("div", { class: `${r}-tabs-nav__suffix` }, re))), U && (this.animated && (te === "top" || te === "bottom") ? F("div", { ref: "tabsPaneWrapperRef", style: T, class: [`${r}-tabs-pane-wrapper`, C] }, T_(A, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : T_(A, this.mergedValue, this.renderedNames)));
} });
function T_(r, i, l, d, f, g, m) {
  const s = [];
  return r.forEach((C) => {
    const { name: T, displayDirective: M, "display-directive": z } = C.props, L = (O) => M === O || z === O, A = i === T;
    if (C.key !== void 0 && (C.key = T), A || L("show") || L("show:lazy") && l.has(T)) {
      l.has(T) || l.add(T);
      const O = !L("if");
      s.push(O ? va(C, [[Ka, A]]) : C);
    }
  }), m ? F(jw, { name: `${m}-transition`, onBeforeLeave: d, onEnter: f, onAfterEnter: g }, { default: () => s }) : s;
}
function I_(r, i) {
  return F(Cg, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: i, disabled: typeof r == "object" && r.disabled });
}
function M_(r) {
  const i = ig(r);
  return i.props ? i.props.internalLeftPadded = true : i.props = { internalLeftPadded: true }, i;
}
function Um(r) {
  return Array.isArray(r.dynamicProps) ? r.dynamicProps.includes("internalLeftPadded") || r.dynamicProps.push("internalLeftPadded") : r.dynamicProps = ["internalLeftPadded"], r;
}
const M5 = ue("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [qe("&:first-child", { marginTop: 0 }), Ue("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ue("align-text", { paddingLeft: 0 }, [qe("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), qe("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), qe("&::before", { backgroundColor: "var(--n-bar-color)" })])]), E5 = Object.assign(Object.assign({}, Yt.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), R5 = (r) => st({ name: `H${r}`, props: E5, setup(i) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(i), f = Yt("Typography", "-h", M5, Ny, i, l), g = ze(() => {
    const { type: s } = i, { common: { cubicBezierEaseInOut: C }, self: { headerFontWeight: T, headerTextColor: M, [jt("headerPrefixWidth", r)]: z, [jt("headerFontSize", r)]: L, [jt("headerMargin", r)]: A, [jt("headerBarWidth", r)]: O, [jt("headerBarColor", s)]: U } } = f.value;
    return { "--n-bezier": C, "--n-font-size": L, "--n-margin": A, "--n-bar-color": U, "--n-bar-width": O, "--n-font-weight": T, "--n-text-color": M, "--n-prefix-width": z };
  }), m = d ? ci(`h${r}`, ze(() => i.type[0]), g, i) : void 0;
  return { mergedClsPrefix: l, cssVars: d ? void 0 : g, themeClass: m == null ? void 0 : m.themeClass, onRender: m == null ? void 0 : m.onRender };
}, render() {
  var i;
  const { prefix: l, alignText: d, mergedClsPrefix: f, cssVars: g, $slots: m } = this;
  return (i = this.onRender) === null || i === void 0 || i.call(this), F(`h${r}`, { class: [`${f}-h`, `${f}-h${r}`, this.themeClass, { [`${f}-h--prefix-bar`]: l, [`${f}-h--align-text`]: d }], style: g }, m);
} }), A5 = R5("1"), D5 = ue("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [qe("&:first-child", "margin-top: 0;"), qe("&:last-child", "margin-bottom: 0;")]), z5 = Object.assign(Object.assign({}, Yt.props), { depth: [String, Number] }), xf = st({ name: "P", props: z5, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Yt("Typography", "-p", D5, Ny, r, i), f = ze(() => {
    const { depth: m } = r, s = m || "1", { common: { cubicBezierEaseInOut: C }, self: { pFontSize: T, pLineHeight: M, pMargin: z, pTextColor: L, [`pTextColor${s}Depth`]: A } } = d.value;
    return { "--n-bezier": C, "--n-font-size": T, "--n-line-height": M, "--n-margin": z, "--n-text-color": m === void 0 ? L : A };
  }), g = l ? ci("p", ze(() => `${r.depth || ""}`), f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), ac = An("n-upload"), F5 = qe([ue("upload", "width: 100%;", [Ue("dragger-inside", [ue("upload-trigger", `
 display: block;
 `)]), Ue("drag-over", [ue("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), ue("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [qe("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ue("disabled", `
 cursor: not-allowed;
 `)]), ue("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [qe("+", [ue("upload-file-list", "margin-top: 8px;")]), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ue("image-card", `
 width: 96px;
 height: 96px;
 `, [ue("base-icon", `
 font-size: 24px;
 `), ue("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), ue("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [qe("a, img", "outline: none;"), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [ue("upload-file", "cursor: not-allowed;")]), Ue("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), ue("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Bf(), ue("progress", [Bf({ foldPadding: true })]), qe("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [ue("upload-file-info", [Re("action", `
 opacity: 1;
 `)])]), Ue("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [ue("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [ue("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Re("name", `
 padding: 0 8px;
 `), Re("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [qe("img", `
 width: 100%;
 `)])])]), Ue("text-type", [ue("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ue("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [ue("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), ue("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Re("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [qe("img", `
 width: 100%;
 `)])]), qe("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), qe("&:hover", [qe("&::before", "opacity: 1;"), ue("upload-file-info", [Re("thumbnail", "opacity: .12;")])])]), Ue("error-status", [qe("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), ue("upload-file-info", [Re("name", "color: var(--n-item-text-color-error);"), Re("thumbnail", "color: var(--n-item-text-color-error);")]), Ue("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ue("with-url", `
 cursor: pointer;
 `, [ue("upload-file-info", [Re("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [qe("a", `
 text-decoration: underline;
 `)])])]), ue("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Re("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [ue("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Re("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [ue("button", [qe("&:not(:last-child)", { marginRight: "4px" }), ue("base-icon", [qe("svg", [Ld()])])]), Ue("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ue("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Re("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [qe("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), ue("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), Vb = "__UPLOAD_DRAGGER__", Ub = st({ name: "UploadDragger", [Vb]: true, setup(r, { slots: i }) {
  const l = fr(ac, null);
  return l || Yo("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: d }, mergedDisabledRef: { value: f }, maxReachedRef: { value: g } } = l;
    return F("div", { class: [`${d}-upload-dragger`, (f || g) && `${d}-upload-dragger--disabled`] }, i);
  };
} });
function L5() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, F("g", { fill: "none" }, F("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })));
}
function B5() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, F("g", { fill: "none" }, F("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })));
}
const O5 = st({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: fr(ac).mergedThemeRef };
}, render() {
  return F(ep, null, { default: () => this.show ? F(g5, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var Sg = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
function Gb(r) {
  return r.includes("image/");
}
function E_(r = "") {
  const i = r.split("/"), d = i[i.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(d) || [""])[0];
}
const R_ = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, qb = (r) => {
  if (r.type) return Gb(r.type);
  const i = E_(r.name || "");
  if (R_.test(i)) return true;
  const l = r.thumbnailUrl || r.url || "", d = E_(l);
  return !!(/^data:image\//.test(l) || R_.test(d));
};
function $5(r) {
  return Sg(this, void 0, void 0, function* () {
    return yield new Promise((i) => {
      if (!r.type || !Gb(r.type)) {
        i("");
        return;
      }
      i(window.URL.createObjectURL(r));
    });
  });
}
const j5 = rp && window.FileReader && window.File;
function N5(r) {
  return r.isDirectory;
}
function V5(r) {
  return r.isFile;
}
function U5(r, i) {
  return Sg(this, void 0, void 0, function* () {
    const l = [];
    function d(f) {
      return Sg(this, void 0, void 0, function* () {
        for (const g of f) if (g) {
          if (i && N5(g)) {
            const m = g.createReader();
            let s = [], C;
            try {
              do
                C = yield new Promise((T, M) => {
                  m.readEntries(T, M);
                }), s = s.concat(C);
              while (C.length > 0);
            } catch (T) {
              qv("upload", "error happens when handling directory upload", T);
            }
            yield d(s);
          } else if (V5(g)) try {
            const m = yield new Promise((s, C) => {
              g.file(s, C);
            });
            l.push({ file: m, entry: g, source: "dnd" });
          } catch (m) {
            qv("upload", "error happens when handling file upload", m);
          }
        }
      });
    }
    return yield d(r), l;
  });
}
function Ud(r) {
  const { id: i, name: l, percentage: d, status: f, url: g, file: m, thumbnailUrl: s, type: C, fullPath: T, batchId: M } = r;
  return { id: i, name: l, percentage: d ?? null, status: f, url: g ?? null, file: m ?? null, thumbnailUrl: s ?? null, type: C ?? null, fullPath: T ?? null, batchId: M ?? null };
}
function G5(r, i, l) {
  return r = r.toLowerCase(), i = i.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((f) => f.trim()).filter(Boolean).some((f) => {
    if (f.startsWith(".")) {
      if (r.endsWith(f)) return true;
    } else if (f.includes("/")) {
      const [g, m] = i.split("/"), [s, C] = f.split("/");
      if ((s === "*" || g && s && s === g) && (C === "*" || m && C && C === m)) return true;
    } else return true;
    return false;
  });
}
var A_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const wf = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, q5 = st({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(r) {
  const i = fr(ac), l = Ae(null), d = Ae(""), f = ze(() => {
    const { file: re } = r;
    return re.status === "finished" ? "success" : re.status === "error" ? "error" : "info";
  }), g = ze(() => {
    const { file: re } = r;
    if (re.status === "error") return "error";
  }), m = ze(() => {
    const { file: re } = r;
    return re.status === "uploading";
  }), s = ze(() => {
    if (!i.showCancelButtonRef.value) return false;
    const { file: re } = r;
    return ["uploading", "pending", "error"].includes(re.status);
  }), C = ze(() => {
    if (!i.showRemoveButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), T = ze(() => {
    if (!i.showDownloadButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), M = ze(() => {
    if (!i.showRetryButtonRef.value) return false;
    const { file: re } = r;
    return ["error"].includes(re.status);
  }), z = pi(() => d.value || r.file.thumbnailUrl || r.file.url), L = ze(() => {
    if (!i.showPreviewButtonRef.value) return false;
    const { file: { status: re }, listType: J } = r;
    return ["finished"].includes(re) && z.value && J === "image-card";
  });
  function A() {
    return A_(this, void 0, void 0, function* () {
      const re = i.onRetryRef.value;
      re && (yield re({ file: r.file })) === false || i.submit(r.file.id);
    });
  }
  function O(re) {
    re.preventDefault();
    const { file: J } = r;
    ["finished", "pending", "error"].includes(J.status) ? X(J) : ["uploading"].includes(J.status) ? Q(J) : Of("upload", "The button clicked type is unknown.");
  }
  function U(re) {
    re.preventDefault(), H(r.file);
  }
  function X(re) {
    const { xhrMap: J, doChange: Se, onRemoveRef: { value: fe }, mergedFileListRef: { value: oe } } = i;
    Promise.resolve(fe ? fe({ file: Object.assign({}, re), fileList: oe, index: r.index }) : true).then((de) => {
      if (de === false) return;
      const xe = Object.assign({}, re, { status: "removed" });
      J.delete(re.id), Se(xe, void 0, { remove: true });
    });
  }
  function H(re) {
    const { onDownloadRef: { value: J }, customDownloadRef: { value: Se } } = i;
    Promise.resolve(J ? J(Object.assign({}, re)) : true).then((fe) => {
      fe !== false && (Se ? Se(Object.assign({}, re)) : db(re.url, re.name));
    });
  }
  function Q(re) {
    const { xhrMap: J } = i, Se = J.get(re.id);
    Se == null ? void 0 : Se.abort(), X(Object.assign({}, re));
  }
  function ie(re) {
    const { onPreviewRef: { value: J } } = i;
    if (J) J(r.file, { event: re });
    else if (r.listType === "image-card") {
      const { value: Se } = l;
      if (!Se) return;
      Se.showPreview();
    }
  }
  const te = () => A_(this, void 0, void 0, function* () {
    const { listType: re } = r;
    re !== "image" && re !== "image-card" || i.shouldUseThumbnailUrlRef.value(r.file) && (d.value = yield i.getFileThumbnailUrlResolver(r.file));
  });
  return vo(() => {
    te();
  }), { mergedTheme: i.mergedThemeRef, progressStatus: f, buttonType: g, showProgress: m, disabled: i.mergedDisabledRef, showCancelButton: s, showRemoveButton: C, showDownloadButton: T, showRetryButton: M, showPreviewButton: L, mergedThumbnailUrl: z, shouldUseThumbnailUrl: i.shouldUseThumbnailUrlRef, renderIcon: i.renderIconRef, imageRef: l, handleRemoveOrCancelClick: O, handleDownloadClick: U, handleRetryClick: A, handlePreviewClick: ie };
}, render() {
  const { clsPrefix: r, mergedTheme: i, listType: l, file: d, renderIcon: f } = this;
  let g;
  const m = l === "image";
  m || l === "image-card" ? g = !this.shouldUseThumbnailUrl(d) || !this.mergedThumbnailUrl ? F("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : qb(d) ? F(Nr, { clsPrefix: r }, { default: L5 }) : F(Nr, { clsPrefix: r }, { default: B5 })) : F("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, class: `${r}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? F(Lb, { src: this.mergedThumbnailUrl || void 0, previewSrc: d.url || void 0, alt: d.name, ref: "imageRef" }) : F("img", { src: this.mergedThumbnailUrl || void 0, alt: d.name })) : g = F("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : F(Nr, { clsPrefix: r }, { default: () => F(zS, null) }));
  const C = F(O5, { show: this.showProgress, percentage: d.percentage || 0, status: this.progressStatus }), T = l === "text" || l === "image";
  return F("div", { class: [`${r}-upload-file`, `${r}-upload-file--${this.progressStatus}-status`, d.url && d.status !== "error" && l !== "image-card" && `${r}-upload-file--with-url`, `${r}-upload-file--${l}-type`] }, F("div", { class: `${r}-upload-file-info` }, g, F("div", { class: `${r}-upload-file-info__name` }, T && (d.url && d.status !== "error" ? F("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, onClick: this.handlePreviewClick }, d.name) : F("span", { onClick: this.handlePreviewClick }, d.name)), m && C), F("div", { class: [`${r}-upload-file-info__action`, `${r}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? F(Vr, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: wf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(fb, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && F(Vr, { key: "cancelOrTrash", theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, quaternary: true, builtinThemeOverrides: wf, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => F(Yf, null, { default: () => this.showRemoveButton ? F(Nr, { clsPrefix: r, key: "trash" }, { default: () => F(ZS, null) }) : F(Nr, { clsPrefix: r, key: "cancel" }, { default: () => F(FS, null) }) }) }), this.showRetryButton && !this.disabled && F(Vr, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: wf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(GS, null) }) }), this.showDownloadButton ? F(Vr, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: wf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(hb, null) }) }) : null)), !m && C);
} }), Wb = st({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(r, { slots: i }) {
  const l = fr(ac, null);
  l || Yo("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: d, mergedDisabledRef: f, maxReachedRef: g, listTypeRef: m, dragOverRef: s, openOpenFileDialog: C, draggerInsideRef: T, handleFileAddition: M, mergedDirectoryDndRef: z, triggerClassRef: L, triggerStyleRef: A } = l, O = ze(() => m.value === "image-card");
  function U() {
    f.value || g.value || C();
  }
  function X(te) {
    te.preventDefault(), s.value = true;
  }
  function H(te) {
    te.preventDefault(), s.value = true;
  }
  function Q(te) {
    te.preventDefault(), s.value = false;
  }
  function ie(te) {
    var re;
    if (te.preventDefault(), !T.value || f.value || g.value) {
      s.value = false;
      return;
    }
    const J = (re = te.dataTransfer) === null || re === void 0 ? void 0 : re.items;
    (J == null ? void 0 : J.length) ? U5(Array.from(J).map((Se) => Se.webkitGetAsEntry()), z.value).then((Se) => {
      M(Se);
    }).finally(() => {
      s.value = false;
    }) : s.value = false;
  }
  return () => {
    var te;
    const { value: re } = d;
    return r.abstract ? (te = i.default) === null || te === void 0 ? void 0 : te.call(i, { handleClick: U, handleDrop: ie, handleDragOver: X, handleDragEnter: H, handleDragLeave: Q }) : F("div", { class: [`${re}-upload-trigger`, (f.value || g.value) && `${re}-upload-trigger--disabled`, O.value && `${re}-upload-trigger--image-card`, L.value], style: A.value, onClick: U, onDrop: ie, onDragover: X, onDragenter: H, onDragleave: Q }, O.value ? F(Ub, null, { default: () => Vn(i.default, () => [F(Nr, { clsPrefix: re }, { default: () => F(ap, null) })]) }) : i);
  };
} }), W5 = st({ name: "UploadFileList", setup(r, { slots: i }) {
  const l = fr(ac, null);
  l || Yo("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: d, mergedClsPrefixRef: f, listTypeRef: g, mergedFileListRef: m, fileListClassRef: s, fileListStyleRef: C, cssVarsRef: T, themeClassRef: M, maxReachedRef: z, showTriggerRef: L, imageGroupPropsRef: A } = l, O = ze(() => g.value === "image-card"), U = () => m.value.map((H, Q) => F(q5, { clsPrefix: f.value, key: H.id, file: H, index: Q, listType: g.value })), X = () => O.value ? F(YT, Object.assign({}, A.value), { default: U }) : F(ep, { group: true }, { default: U });
  return () => {
    const { value: H } = f, { value: Q } = d;
    return F("div", { class: [`${H}-upload-file-list`, O.value && `${H}-upload-file-list--grid`, Q ? M == null ? void 0 : M.value : void 0, s.value], style: [Q && T ? T.value : "", C.value] }, X(), L.value && !z.value && O.value && F(Wb, null, i));
  };
} });
var D_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
function Z5(r, i, l) {
  const { doChange: d, xhrMap: f } = r;
  let g = 0;
  function m(C) {
    var T;
    let M = Object.assign({}, i, { status: "error", percentage: g });
    f.delete(i.id), M = Ud(((T = r.onError) === null || T === void 0 ? void 0 : T.call(r, { file: M, event: C })) || M), d(M, C);
  }
  function s(C) {
    var T;
    if (r.isErrorState) {
      if (r.isErrorState(l)) {
        m(C);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      m(C);
      return;
    }
    let M = Object.assign({}, i, { status: "finished", percentage: g });
    f.delete(i.id), M = Ud(((T = r.onFinish) === null || T === void 0 ? void 0 : T.call(r, { file: M, event: C })) || M), d(M, C);
  }
  return { handleXHRLoad: s, handleXHRError: m, handleXHRAbort(C) {
    const T = Object.assign({}, i, { status: "removed", file: null, percentage: g });
    f.delete(i.id), d(T, C);
  }, handleXHRProgress(C) {
    const T = Object.assign({}, i, { status: "uploading" });
    if (C.lengthComputable) {
      const M = Math.ceil(C.loaded / C.total * 100);
      T.percentage = M, g = M;
    }
    d(T, C);
  } };
}
function H5(r) {
  const { inst: i, file: l, data: d, headers: f, withCredentials: g, action: m, customRequest: s } = r, { doChange: C } = r.inst;
  let T = 0;
  s({ file: l, data: d, headers: f, withCredentials: g, action: m, onProgress(M) {
    const z = Object.assign({}, l, { status: "uploading" }), L = M.percent;
    z.percentage = L, T = L, C(z);
  }, onFinish() {
    var M;
    let z = Object.assign({}, l, { status: "finished", percentage: T });
    z = Ud(((M = i.onFinish) === null || M === void 0 ? void 0 : M.call(i, { file: z })) || z), C(z);
  }, onError() {
    var M;
    let z = Object.assign({}, l, { status: "error", percentage: T });
    z = Ud(((M = i.onError) === null || M === void 0 ? void 0 : M.call(i, { file: z })) || z), C(z);
  } });
}
function X5(r, i, l) {
  const d = Z5(r, i, l);
  l.onabort = d.handleXHRAbort, l.onerror = d.handleXHRError, l.onload = d.handleXHRLoad, l.upload && (l.upload.onprogress = d.handleXHRProgress);
}
function Zb(r, i) {
  return typeof r == "function" ? r({ file: i }) : r || {};
}
function Y5(r, i, l) {
  const d = Zb(i, l);
  d && Object.keys(d).forEach((f) => {
    r.setRequestHeader(f, d[f]);
  });
}
function K5(r, i, l) {
  const d = Zb(i, l);
  d && Object.keys(d).forEach((f) => {
    r.append(f, d[f]);
  });
}
function J5(r, i, l, { method: d, action: f, withCredentials: g, responseType: m, headers: s, data: C }) {
  const T = new XMLHttpRequest();
  T.responseType = m, r.xhrMap.set(l.id, T), T.withCredentials = g;
  const M = new FormData();
  if (K5(M, C, l), l.file !== null && M.append(i, l.file), X5(r, l, T), f !== void 0) {
    T.open(d.toUpperCase(), f), Y5(T, s, l), T.send(M);
    const z = Object.assign({}, l, { status: "uploading" });
    r.doChange(z);
  }
}
const Q5 = Object.assign(Object.assign({}, Yt.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (r) => j5 ? qb(r) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), e6 = st({ name: "Upload", props: Q5, setup(r) {
  r.abstract && r.listType === "image-card" && Yo("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Tr(r), f = Yt("Upload", "-upload", F5, Z2, r, i), g = Rn("Upload", d, i), m = ya(r), s = Ae(r.defaultFileList), C = Dt(r, "fileList"), T = Ae(null), M = { value: false }, z = Ae(false), L = /* @__PURE__ */ new Map(), A = Zi(C, s), O = ze(() => A.value.map(Ud)), U = ze(() => {
    const { max: xe } = r;
    return xe !== void 0 ? O.value.length >= xe : false;
  });
  function X() {
    var xe;
    (xe = T.value) === null || xe === void 0 || xe.click();
  }
  function H(xe) {
    const $e = xe.target;
    re($e.files ? Array.from($e.files).map((Ve) => ({ file: Ve, entry: null, source: "input" })) : null, xe), $e.value = "";
  }
  function Q(xe) {
    const { "onUpdate:fileList": $e, onUpdateFileList: Ve } = r;
    $e && Ot($e, xe), Ve && Ot(Ve, xe), s.value = xe;
  }
  const ie = ze(() => r.multiple || r.directory), te = (xe, $e, Ve = { append: false, remove: false }) => {
    const { append: Ke, remove: lt } = Ve, vt = Array.from(O.value), xt = vt.findIndex((at) => at.id === xe.id);
    if (Ke || lt || ~xt) {
      Ke ? vt.push(xe) : lt ? vt.splice(xt, 1) : vt.splice(xt, 1, xe);
      const { onChange: at } = r;
      at && at({ file: xe, fileList: vt, event: $e }), Q(vt);
    }
  };
  function re(xe, $e) {
    if (!xe || xe.length === 0) return;
    const { onBeforeUpload: Ve } = r;
    xe = ie.value ? xe : [xe[0]];
    const { max: Ke, accept: lt } = r;
    xe = xe.filter(({ file: xt, source: at }) => at === "dnd" && (lt == null ? void 0 : lt.trim()) ? G5(xt.name, xt.type, lt) : true), Ke && (xe = xe.slice(0, Ke - O.value.length));
    const vt = zl();
    Promise.all(xe.map((xt) => D_(this, [xt], void 0, function* ({ file: at, entry: et }) {
      var ht;
      const yt = { id: zl(), batchId: vt, name: at.name, status: "pending", percentage: 0, file: at, url: null, type: at.type, thumbnailUrl: null, fullPath: (ht = et == null ? void 0 : et.fullPath) !== null && ht !== void 0 ? ht : `/${at.webkitRelativePath || at.name}` };
      return !Ve || (yield Ve({ file: yt, fileList: O.value })) !== false ? yt : null;
    }))).then((xt) => D_(this, void 0, void 0, function* () {
      let at = Promise.resolve();
      xt.forEach((et) => {
        at = at.then(Nn).then(() => {
          et && te(et, $e, { append: true });
        });
      }), yield at;
    })).then(() => {
      r.defaultUpload && J();
    });
  }
  function J(xe) {
    const { method: $e, action: Ve, withCredentials: Ke, headers: lt, data: vt, name: xt } = r, at = xe !== void 0 ? O.value.filter((ht) => ht.id === xe) : O.value, et = xe !== void 0;
    at.forEach((ht) => {
      const { status: yt } = ht;
      (yt === "pending" || yt === "error" && et) && (r.customRequest ? H5({ inst: { doChange: te, xhrMap: L, onFinish: r.onFinish, onError: r.onError }, file: ht, action: Ve, withCredentials: Ke, headers: lt, data: vt, customRequest: r.customRequest }) : J5({ doChange: te, xhrMap: L, onFinish: r.onFinish, onError: r.onError, isErrorState: r.isErrorState }, xt, ht, { method: $e, action: Ve, withCredentials: Ke, responseType: r.responseType, headers: lt, data: vt }));
    });
  }
  function Se(xe) {
    var $e;
    if (xe.thumbnailUrl) return xe.thumbnailUrl;
    const { createThumbnailUrl: Ve } = r;
    return Ve ? ($e = Ve(xe.file, xe)) !== null && $e !== void 0 ? $e : xe.url || "" : xe.url ? xe.url : xe.file ? $5(xe.file) : "";
  }
  const fe = ze(() => {
    const { common: { cubicBezierEaseInOut: xe }, self: { draggerColor: $e, draggerBorder: Ve, draggerBorderHover: Ke, itemColorHover: lt, itemColorHoverError: vt, itemTextColorError: xt, itemTextColorSuccess: at, itemTextColor: et, itemIconColor: ht, itemDisabledOpacity: yt, lineHeight: nt, borderRadius: ut, fontSize: Lt, itemBorderImageCardError: Ht, itemBorderImageCard: zt } } = f.value;
    return { "--n-bezier": xe, "--n-border-radius": ut, "--n-dragger-border": Ve, "--n-dragger-border-hover": Ke, "--n-dragger-color": $e, "--n-font-size": Lt, "--n-item-color-hover": lt, "--n-item-color-hover-error": vt, "--n-item-disabled-opacity": yt, "--n-item-icon-color": ht, "--n-item-text-color": et, "--n-item-text-color-error": xt, "--n-item-text-color-success": at, "--n-line-height": nt, "--n-item-border-image-card-error": Ht, "--n-item-border-image-card": zt };
  }), oe = l ? ci("upload", void 0, fe, r) : void 0;
  Jr(ac, { mergedClsPrefixRef: i, mergedThemeRef: f, showCancelButtonRef: Dt(r, "showCancelButton"), showDownloadButtonRef: Dt(r, "showDownloadButton"), showRemoveButtonRef: Dt(r, "showRemoveButton"), showRetryButtonRef: Dt(r, "showRetryButton"), onRemoveRef: Dt(r, "onRemove"), onDownloadRef: Dt(r, "onDownload"), customDownloadRef: Dt(r, "customDownload"), mergedFileListRef: O, triggerClassRef: Dt(r, "triggerClass"), triggerStyleRef: Dt(r, "triggerStyle"), shouldUseThumbnailUrlRef: Dt(r, "shouldUseThumbnailUrl"), renderIconRef: Dt(r, "renderIcon"), xhrMap: L, submit: J, doChange: te, showPreviewButtonRef: Dt(r, "showPreviewButton"), onPreviewRef: Dt(r, "onPreview"), getFileThumbnailUrlResolver: Se, listTypeRef: Dt(r, "listType"), dragOverRef: z, openOpenFileDialog: X, draggerInsideRef: M, handleFileAddition: re, mergedDisabledRef: m.mergedDisabledRef, maxReachedRef: U, fileListClassRef: Dt(r, "fileListClass"), fileListStyleRef: Dt(r, "fileListStyle"), abstractRef: Dt(r, "abstract"), acceptRef: Dt(r, "accept"), cssVarsRef: l ? void 0 : fe, themeClassRef: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, showTriggerRef: Dt(r, "showTrigger"), imageGroupPropsRef: Dt(r, "imageGroupProps"), mergedDirectoryDndRef: ze(() => {
    var xe;
    return (xe = r.directoryDnd) !== null && xe !== void 0 ? xe : r.directory;
  }), onRetryRef: Dt(r, "onRetry") });
  const de = { clear: () => {
    s.value = [];
  }, submit: J, openOpenFileDialog: X };
  return Object.assign({ mergedClsPrefix: i, draggerInsideRef: M, rtlEnabled: g, inputElRef: T, mergedTheme: f, dragOver: z, mergedMultiple: ie, cssVars: l ? void 0 : fe, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, handleFileInputChange: H }, de);
}, render() {
  var r, i;
  const { draggerInsideRef: l, mergedClsPrefix: d, $slots: f, directory: g, onRender: m } = this;
  if (f.default && !this.abstract) {
    const C = f.default()[0];
    !((r = C == null ? void 0 : C.type) === null || r === void 0) && r[Vb] && (l.value = true);
  }
  const s = F("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${d}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: g || void 0, directory: g || void 0 }));
  return this.abstract ? F(qr, null, (i = f.default) === null || i === void 0 ? void 0 : i.call(f), F(_y, { to: "body" }, s)) : (m == null ? void 0 : m(), F("div", { class: [`${d}-upload`, this.rtlEnabled && `${d}-upload--rtl`, l.value && `${d}-upload--dragger-inside`, this.dragOver && `${d}-upload--drag-over`, this.themeClass], style: this.cssVars }, s, this.showTrigger && this.listType !== "image-card" && F(Wb, null, f), this.showFileList && F(W5, null, f)));
} });
function Fl() {
  const r = fr(Sy, null);
  return ze(() => {
    if (r === null) return Wv;
    const { mergedThemeRef: { value: i }, mergedThemeOverridesRef: { value: l } } = r, d = (i == null ? void 0 : i.common) || Wv;
    return (l == null ? void 0 : l.common) ? Object.assign({}, d, l.common) : d;
  });
}
var zf = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.7.1/LICENSE.txt
*/
var t6 = zf.exports, z_;
function r6() {
  return z_ || (z_ = 1, (function(r, i) {
    (function(l, d) {
      r.exports = d();
    })(t6, (function() {
      var l = {}, d = {};
      function f(m, s, C) {
        if (d[m] = C, m === "index") {
          var T = "var sharedModule = {}; (" + d.shared + ")(sharedModule); (" + d.worker + ")(sharedModule);", M = {};
          return d.shared(M), d.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([T], { type: "text/javascript" }))), l;
        }
      }
      f("shared", ["exports"], (function(m) {
        function s(o, t, n, u) {
          return new (n || (n = Promise))((function(h, y) {
            function b(I) {
              try {
                S(u.next(I));
              } catch (E) {
                y(E);
              }
            }
            function w(I) {
              try {
                S(u.throw(I));
              } catch (E) {
                y(E);
              }
            }
            function S(I) {
              var E;
              I.done ? h(I.value) : (E = I.value, E instanceof n ? E : new n((function(B) {
                B(E);
              }))).then(b, w);
            }
            S((u = u.apply(o, t || [])).next());
          }));
        }
        function C(o, t) {
          this.x = o, this.y = t;
        }
        function T(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var M, z;
        typeof SuppressedError == "function" && SuppressedError, C.prototype = { clone() {
          return new C(this.x, this.y);
        }, add(o) {
          return this.clone()._add(o);
        }, sub(o) {
          return this.clone()._sub(o);
        }, multByPoint(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint(o) {
          return this.clone()._divByPoint(o);
        }, mult(o) {
          return this.clone()._mult(o);
        }, div(o) {
          return this.clone()._div(o);
        }, rotate(o) {
          return this.clone()._rotate(o);
        }, rotateAround(o, t) {
          return this.clone()._rotateAround(o, t);
        }, matMult(o) {
          return this.clone()._matMult(o);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(o) {
          return this.x === o.x && this.y === o.y;
        }, dist(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr(o) {
          const t = o.x - this.x, n = o.y - this.y;
          return t * t + n * n;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep(o, t) {
          return Math.atan2(this.x * t - this.y * o, this.x * o + this.y * t);
        }, _matMult(o) {
          const t = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = t, this;
        }, _add(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult(o) {
          return this.x *= o, this.y *= o, this;
        }, _div(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate(o) {
          const t = Math.cos(o), n = Math.sin(o), u = n * this.x + t * this.y;
          return this.x = t * this.x - n * this.y, this.y = u, this;
        }, _rotateAround(o, t) {
          const n = Math.cos(o), u = Math.sin(o), h = t.y + u * (this.x - t.x) + n * (this.y - t.y);
          return this.x = t.x + n * (this.x - t.x) - u * (this.y - t.y), this.y = h, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: C }, C.convert = function(o) {
          if (o instanceof C) return o;
          if (Array.isArray(o)) return new C(+o[0], +o[1]);
          if (o.x !== void 0 && o.y !== void 0) return new C(+o.x, +o.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var L = (function() {
          if (z) return M;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return z = 1, M = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var y = this.sampleCurveX(u) - t;
              if (Math.abs(y) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= y / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (y = this.sampleCurveX(u), !(Math.abs(y - t) < n)); h++) t > y ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, M;
        })(), A = T(L);
        let O, U;
        function X() {
          return O == null && (O = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), O;
        }
        function H() {
          if (U == null && (U = false, X())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (t) {
              for (let u = 0; u < 25; u++) {
                const h = 4 * u;
                t.fillStyle = `rgb(${h},${h + 1},${h + 2})`, t.fillRect(u % 5, Math.floor(u / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let u = 0; u < 100; u++) if (u % 4 != 3 && n[u] !== u) {
                U = true;
                break;
              }
            }
          }
          return U || false;
        }
        var Q = 1e-6, ie = typeof Float32Array < "u" ? Float32Array : Array;
        function te() {
          var o = new ie(9);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
        }
        function re(o) {
          return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }
        function J() {
          var o = new ie(3);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o;
        }
        function Se(o) {
          var t = o[0], n = o[1], u = o[2];
          return Math.sqrt(t * t + n * n + u * u);
        }
        function fe(o, t, n) {
          var u = new ie(3);
          return u[0] = o, u[1] = t, u[2] = n, u;
        }
        function oe(o, t, n) {
          return o[0] = t[0] + n[0], o[1] = t[1] + n[1], o[2] = t[2] + n[2], o;
        }
        function de(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o;
        }
        function xe(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = n[0], w = n[1], S = n[2];
          return o[0] = h * S - y * w, o[1] = y * b - u * S, o[2] = u * w - h * b, o;
        }
        var $e, Ve = Se;
        function Ke(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = t[3];
          return o[0] = n[0] * u + n[4] * h + n[8] * y + n[12] * b, o[1] = n[1] * u + n[5] * h + n[9] * y + n[13] * b, o[2] = n[2] * u + n[6] * h + n[10] * y + n[14] * b, o[3] = n[3] * u + n[7] * h + n[11] * y + n[15] * b, o;
        }
        function lt() {
          var o = new ie(4);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o[3] = 1, o;
        }
        function vt(o, t, n, u) {
          var h = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", y = Math.PI / 360;
          t *= y, u *= y, n *= y;
          var b = Math.sin(t), w = Math.cos(t), S = Math.sin(n), I = Math.cos(n), E = Math.sin(u), B = Math.cos(u);
          switch (h) {
            case "xyz":
              o[0] = b * I * B + w * S * E, o[1] = w * S * B - b * I * E, o[2] = w * I * E + b * S * B, o[3] = w * I * B - b * S * E;
              break;
            case "xzy":
              o[0] = b * I * B - w * S * E, o[1] = w * S * B - b * I * E, o[2] = w * I * E + b * S * B, o[3] = w * I * B + b * S * E;
              break;
            case "yxz":
              o[0] = b * I * B + w * S * E, o[1] = w * S * B - b * I * E, o[2] = w * I * E - b * S * B, o[3] = w * I * B + b * S * E;
              break;
            case "yzx":
              o[0] = b * I * B + w * S * E, o[1] = w * S * B + b * I * E, o[2] = w * I * E - b * S * B, o[3] = w * I * B - b * S * E;
              break;
            case "zxy":
              o[0] = b * I * B - w * S * E, o[1] = w * S * B + b * I * E, o[2] = w * I * E + b * S * B, o[3] = w * I * B - b * S * E;
              break;
            case "zyx":
              o[0] = b * I * B - w * S * E, o[1] = w * S * B + b * I * E, o[2] = w * I * E - b * S * B, o[3] = w * I * B + b * S * E;
              break;
            default:
              throw new Error("Unknown angle order " + h);
          }
          return o;
        }
        function xt() {
          var o = new ie(2);
          return ie != Float32Array && (o[0] = 0, o[1] = 0), o;
        }
        function at(o, t) {
          var n = new ie(2);
          return n[0] = o, n[1] = t, n;
        }
        J(), $e = new ie(4), ie != Float32Array && ($e[0] = 0, $e[1] = 0, $e[2] = 0, $e[3] = 0), J(), fe(1, 0, 0), fe(0, 1, 0), lt(), lt(), te(), xt();
        const et = 8192;
        function ht(o, t, n) {
          return t * (et / (o.tileSize * Math.pow(2, n - o.tileID.overscaledZ)));
        }
        function yt(o, t) {
          return (o % t + t) % t;
        }
        function nt(o, t, n) {
          return o * (1 - n) + t * n;
        }
        function ut(o) {
          if (o <= 0) return 0;
          if (o >= 1) return 1;
          const t = o * o, n = t * o;
          return 4 * (o < 0.5 ? n : 3 * (o - t) + n - 0.75);
        }
        function Lt(o, t, n, u) {
          const h = new A(o, t, n, u);
          return (y) => h.solve(y);
        }
        const Ht = Lt(0.25, 0.1, 0.25, 1);
        function zt(o, t, n) {
          return Math.min(n, Math.max(t, o));
        }
        function pr(o, t, n) {
          const u = n - t, h = ((o - t) % u + u) % u + t;
          return h === t ? n : h;
        }
        function Jt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        let tr = 1;
        function wr(o, t, n) {
          const u = {};
          for (const h in o) u[h] = t.call(this, o[h], h, o);
          return u;
        }
        function Er(o, t, n) {
          const u = {};
          for (const h in o) t.call(this, o[h], h, o) && (u[h] = o[h]);
          return u;
        }
        function rr(o) {
          return Array.isArray(o) ? o.map(rr) : typeof o == "object" && o ? wr(o, rr) : o;
        }
        const sr = {};
        function qt(o) {
          sr[o] || (typeof console < "u" && console.warn(o), sr[o] = true);
        }
        function Dr(o, t, n) {
          return (n.y - o.y) * (t.x - o.x) > (t.y - o.y) * (n.x - o.x);
        }
        function Cr(o) {
          return typeof WorkerGlobalScope < "u" && o !== void 0 && o instanceof WorkerGlobalScope;
        }
        let Ct = null;
        function Ee(o) {
          return typeof ImageBitmap < "u" && o instanceof ImageBitmap;
        }
        const ot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Le(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const y = new VideoFrame(o, { timestamp: 0 });
            try {
              const b = y == null ? void 0 : y.format;
              if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
              const w = b.startsWith("BGR"), S = new Uint8ClampedArray(u * h * 4);
              if (yield y.copyTo(S, (function(I, E, B, N, G) {
                const q = 4 * Math.max(-E, 0), K = (Math.max(0, B) - B) * N * 4 + q, ae = 4 * N, pe = Math.max(0, E), Be = Math.max(0, B);
                return { rect: { x: pe, y: Be, width: Math.min(I.width, E + N) - pe, height: Math.min(I.height, B + G) - Be }, layout: [{ offset: K, stride: ae }] };
              })(o, t, n, u, h)), w) for (let I = 0; I < S.length; I += 4) {
                const E = S[I];
                S[I] = S[I + 2], S[I + 2] = E;
              }
              return S;
            } finally {
              y.close();
            }
          }));
        }
        let Ye, ft;
        function bt(o, t, n, u) {
          return o.addEventListener(t, n, u), { unsubscribe: () => {
            o.removeEventListener(t, n, u);
          } };
        }
        function tt(o) {
          return o * Math.PI / 180;
        }
        function mt(o) {
          return o / Math.PI * 180;
        }
        const Zt = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, ii = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, wi = "AbortError";
        function Fe() {
          return new Error(wi);
        }
        const Z = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function Y(o) {
          return Z.REGISTERED_PROTOCOLS[o.substring(0, o.indexOf("://"))];
        }
        const ne = "global-dispatcher";
        class _e extends Error {
          constructor(t, n, u, h) {
            super(`AJAXError: ${n} (${t}): ${u}`), this.status = t, this.statusText = n, this.url = u, this.body = h;
          }
        }
        const Te = () => Cr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, De = function(o, t) {
          if (/:\/\//.test(o.url) && !/^https?:|^file:/.test(o.url)) {
            const u = Y(o.url);
            if (u) return u(o, t);
            if (Cr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, targetMapId: ne }, t);
          }
          if (!(/^file:/.test(n = o.url) || /^file:/.test(Te()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(u, h) {
              return s(this, void 0, void 0, (function* () {
                const y = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: Te(), signal: h.signal });
                let b, w;
                u.type !== "json" || y.headers.has("Accept") || y.headers.set("Accept", "application/json");
                try {
                  b = yield fetch(y);
                } catch (I) {
                  throw new _e(0, I.message, u.url, new Blob());
                }
                if (!b.ok) {
                  const I = yield b.blob();
                  throw new _e(b.status, b.statusText, u.url, I);
                }
                w = u.type === "arrayBuffer" || u.type === "image" ? b.arrayBuffer() : u.type === "json" ? b.json() : b.text();
                const S = yield w;
                if (h.signal.aborted) throw Fe();
                return { data: S, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
              }));
            })(o, t);
            if (Cr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, mustQueue: true, targetMapId: ne }, t);
          }
          var n;
          return (function(u, h) {
            return new Promise(((y, b) => {
              var w;
              const S = new XMLHttpRequest();
              S.open(u.method || "GET", u.url, true), u.type !== "arrayBuffer" && u.type !== "image" || (S.responseType = "arraybuffer");
              for (const I in u.headers) S.setRequestHeader(I, u.headers[I]);
              u.type === "json" && (S.responseType = "text", !((w = u.headers) === null || w === void 0) && w.Accept || S.setRequestHeader("Accept", "application/json")), S.withCredentials = u.credentials === "include", S.onerror = () => {
                b(new Error(S.statusText));
              }, S.onload = () => {
                if (!h.signal.aborted) if ((S.status >= 200 && S.status < 300 || S.status === 0) && S.response !== null) {
                  let I = S.response;
                  if (u.type === "json") try {
                    I = JSON.parse(S.response);
                  } catch (E) {
                    return void b(E);
                  }
                  y({ data: I, cacheControl: S.getResponseHeader("Cache-Control"), expires: S.getResponseHeader("Expires") });
                } else {
                  const I = new Blob([S.response], { type: S.getResponseHeader("Content-Type") });
                  b(new _e(S.status, S.statusText, u.url, I));
                }
              }, h.signal.addEventListener("abort", (() => {
                S.abort(), b(Fe());
              })), S.send(u.body);
            }));
          })(o, t);
        };
        function he(o) {
          if (!o || o.indexOf("://") <= 0 || o.indexOf("data:image/") === 0 || o.indexOf("blob:") === 0) return true;
          const t = new URL(o), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function ve(o, t, n) {
          n[o] && n[o].indexOf(t) !== -1 || (n[o] = n[o] || [], n[o].push(t));
        }
        function je(o, t, n) {
          if (n && n[o]) {
            const u = n[o].indexOf(t);
            u !== -1 && n[o].splice(u, 1);
          }
        }
        class it {
          constructor(t, n = {}) {
            Jt(this, n), this.type = t;
          }
        }
        class Xe extends it {
          constructor(t, n = {}) {
            super("error", Jt({ error: t }, n));
          }
        }
        class wt {
          on(t, n) {
            return this._listeners = this._listeners || {}, ve(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return je(t, n, this._listeners), je(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ve(t, n, this._oneTimeListeners), this) : new Promise(((u) => this.once(t, u)));
          }
          fire(t, n) {
            typeof t == "string" && (t = new it(t, n || {}));
            const u = t.type;
            if (this.listens(u)) {
              t.target = this;
              const h = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
              for (const w of h) w.call(this, t);
              const y = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
              for (const w of y) je(u, w, this._oneTimeListeners), w.call(this, t);
              const b = this._eventedParent;
              b && (Jt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
            } else t instanceof Xe && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var Pe = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const $t = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Qt(o, t) {
          const n = {};
          for (const u in o) u !== "ref" && (n[u] = o[u]);
          return $t.forEach(((u) => {
            u in t && (n[u] = t[u]);
          })), n;
        }
        function Nt(o, t) {
          if (Array.isArray(o)) {
            if (!Array.isArray(t) || o.length !== t.length) return false;
            for (let n = 0; n < o.length; n++) if (!Nt(o[n], t[n])) return false;
            return true;
          }
          if (typeof o == "object" && o !== null && t !== null) {
            if (typeof t != "object" || Object.keys(o).length !== Object.keys(t).length) return false;
            for (const n in o) if (!Nt(o[n], t[n])) return false;
            return true;
          }
          return o === t;
        }
        function ur(o, t) {
          o.push(t);
        }
        function Br(o, t, n) {
          ur(n, { command: "addSource", args: [o, t[o]] });
        }
        function Qr(o, t, n) {
          ur(t, { command: "removeSource", args: [o] }), n[o] = true;
        }
        function ei(o, t, n, u) {
          Qr(o, n, u), Br(o, t, n);
        }
        function ni(o, t, n) {
          let u;
          for (u in o[n]) if (Object.prototype.hasOwnProperty.call(o[n], u) && u !== "data" && !Nt(o[n][u], t[n][u])) return false;
          for (u in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], u) && u !== "data" && !Nt(o[n][u], t[n][u])) return false;
          return true;
        }
        function gr(o, t, n, u, h, y) {
          o = o || {}, t = t || {};
          for (const b in o) Object.prototype.hasOwnProperty.call(o, b) && (Nt(o[b], t[b]) || n.push({ command: y, args: [u, b, t[b], h] }));
          for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(o, b) && (Nt(o[b], t[b]) || n.push({ command: y, args: [u, b, t[b], h] }));
        }
        function yr(o) {
          return o.id;
        }
        function Wr(o, t) {
          return o[t.id] = t, o;
        }
        class ge {
          constructor(t, n, u, h) {
            this.message = (t ? `${t}: ` : "") + u, h && (this.identifier = h), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function dt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        class Bt extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class Rr {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [u, h] of n) this.bindings[u] = h;
          }
          concat(t) {
            return new Rr(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const $r = { kind: "null" }, gt = { kind: "number" }, cr = { kind: "string" }, lr = { kind: "boolean" }, oi = { kind: "color" }, hn = { kind: "projectionDefinition" }, tn = { kind: "object" }, dr = { kind: "value" }, Qo = { kind: "collator" }, Un = { kind: "formatted" }, ea = { kind: "padding" }, Sn = { kind: "colorArray" }, bo = { kind: "numberArray" }, Zr = { kind: "resolvedImage" }, Jn = { kind: "variableAnchorOffsetCollection" };
        function rn(o, t) {
          return { kind: "array", itemType: o, N: t };
        }
        function Ur(o) {
          if (o.kind === "array") {
            const t = Ur(o.itemType);
            return typeof o.N == "number" ? `array<${t}, ${o.N}>` : o.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return o.kind;
        }
        const Ll = [$r, gt, cr, lr, oi, hn, Un, tn, rn(dr), ea, bo, Sn, Zr, Jn];
        function wa(o, t) {
          if (t.kind === "error") return null;
          if (o.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !wa(o.itemType, t.itemType)) && (typeof o.N != "number" || o.N === t.N)) return null;
          } else {
            if (o.kind === t.kind) return null;
            if (o.kind === "value") {
              for (const n of Ll) if (!wa(n, t)) return null;
            }
          }
          return `Expected ${Ur(o)} but found ${Ur(t)} instead.`;
        }
        function Ds(o, t) {
          return t.some(((n) => n.kind === o.kind));
        }
        function xo(o, t) {
          return t.some(((n) => n === "null" ? o === null : n === "array" ? Array.isArray(o) : n === "object" ? o && !Array.isArray(o) && typeof o == "object" : n === typeof o));
        }
        function wo(o, t) {
          return o.kind === "array" && t.kind === "array" ? o.itemType.kind === t.itemType.kind && typeof o.N == "number" : o.kind === t.kind;
        }
        const zs = 0.96422, Bl = 0.82521, Ol = 4 / 29, ta = 6 / 29, $l = 3 * ta * ta, cc = ta * ta * ta, dc = Math.PI / 180, hc = 180 / Math.PI;
        function Fs(o) {
          return (o %= 360) < 0 && (o += 360), o;
        }
        function ra([o, t, n, u]) {
          let h, y;
          const b = Bs((0.2225045 * (o = Ls(o)) + 0.7168786 * (t = Ls(t)) + 0.0606169 * (n = Ls(n))) / 1);
          o === t && t === n ? h = y = b : (h = Bs((0.4360747 * o + 0.3850649 * t + 0.1430804 * n) / zs), y = Bs((0.0139322 * o + 0.0971045 * t + 0.7141733 * n) / Bl));
          const w = 116 * b - 16;
          return [w < 0 ? 0 : w, 500 * (h - b), 200 * (b - y), u];
        }
        function Ls(o) {
          return o <= 0.04045 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
        }
        function Bs(o) {
          return o > cc ? Math.pow(o, 1 / 3) : o / $l + Ol;
        }
        function ia([o, t, n, u]) {
          let h = (o + 16) / 116, y = isNaN(t) ? h : h + t / 500, b = isNaN(n) ? h : h - n / 200;
          return h = 1 * $s(h), y = zs * $s(y), b = Bl * $s(b), [Os(3.1338561 * y - 1.6168667 * h - 0.4906146 * b), Os(-0.9787684 * y + 1.9161415 * h + 0.033454 * b), Os(0.0719453 * y - 0.2289914 * h + 1.4052427 * b), u];
        }
        function Os(o) {
          return (o = o <= 304e-5 ? 12.92 * o : 1.055 * Math.pow(o, 1 / 2.4) - 0.055) < 0 ? 0 : o > 1 ? 1 : o;
        }
        function $s(o) {
          return o > ta ? o * o * o : $l * (o - Ol);
        }
        const fc = Object.hasOwn || function(o, t) {
          return Object.prototype.hasOwnProperty.call(o, t);
        };
        function na(o, t) {
          return fc(o, t) ? o[t] : void 0;
        }
        function Ca(o) {
          return parseInt(o.padEnd(2, o), 16) / 255;
        }
        function Dn(o, t) {
          return br(t ? o / 100 : o, 0, 1);
        }
        function br(o, t, n) {
          return Math.min(Math.max(t, o), n);
        }
        function Lo(o) {
          return !o.some(Number.isNaN);
        }
        const Co = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Qn(o, t, n) {
          return o + n * (t - o);
        }
        function Bo(o, t, n) {
          return o.map(((u, h) => Qn(u, t[h], n)));
        }
        class xr {
          constructor(t, n, u, h = 1, y = true) {
            this.r = t, this.g = n, this.b = u, this.a = h, y || (this.r *= h, this.g *= h, this.b *= h, h || this.overwriteGetter("rgb", [t, n, u, h]));
          }
          static parse(t) {
            if (t instanceof xr) return t;
            if (typeof t != "string") return;
            const n = (function(u) {
              if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const h = na(Co, u);
              if (h) {
                const [b, w, S] = h;
                return [b / 255, w / 255, S / 255, 1];
              }
              if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
                const b = u.length < 6 ? 1 : 2;
                let w = 1;
                return [Ca(u.slice(w, w += b)), Ca(u.slice(w, w += b)), Ca(u.slice(w, w += b)), Ca(u.slice(w, w + b) || "ff")];
              }
              if (u.startsWith("rgb")) {
                const b = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (b) {
                  const [w, S, I, E, B, N, G, q, K, ae, pe, Be] = b, Ce = [E || " ", G || " ", ae].join("");
                  if (Ce === "  " || Ce === "  /" || Ce === ",," || Ce === ",,,") {
                    const Ie = [I, N, K].join(""), He = Ie === "%%%" ? 100 : Ie === "" ? 255 : 0;
                    if (He) {
                      const rt = [br(+S / He, 0, 1), br(+B / He, 0, 1), br(+q / He, 0, 1), pe ? Dn(+pe, Be) : 1];
                      if (Lo(rt)) return rt;
                    }
                  }
                  return;
                }
              }
              const y = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (y) {
                const [b, w, S, I, E, B, N, G, q] = y, K = [S || " ", E || " ", N].join("");
                if (K === "  " || K === "  /" || K === ",," || K === ",,,") {
                  const ae = [+w, br(+I, 0, 100), br(+B, 0, 100), G ? Dn(+G, q) : 1];
                  if (Lo(ae)) return (function([pe, Be, Ce, Ie]) {
                    function He(rt) {
                      const _t = (rt + pe / 30) % 12, At = Be * Math.min(Ce, 1 - Ce);
                      return Ce - At * Math.max(-1, Math.min(_t - 3, 9 - _t, 1));
                    }
                    return pe = Fs(pe), Be /= 100, Ce /= 100, [He(0), He(8), He(4), Ie];
                  })(ae);
                }
              }
            })(t);
            return n ? new xr(...n, false) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: u, a: h } = this, y = h || 1 / 0;
            return this.overwriteGetter("rgb", [t / y, n / y, u / y, h]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, u, h, y] = ra(t), b = Math.sqrt(u * u + h * h);
              return [Math.round(1e4 * b) ? Fs(Math.atan2(h, u) * hc) : NaN, b, n, y];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ra(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, u, h] = this.rgb;
            return `rgba(${[t, n, u].map(((y) => Math.round(255 * y))).join(",")},${h})`;
          }
          static interpolate(t, n, u, h = "rgb") {
            switch (h) {
              case "rgb": {
                const [y, b, w, S] = Bo(t.rgb, n.rgb, u);
                return new xr(y, b, w, S, false);
              }
              case "hcl": {
                const [y, b, w, S] = t.hcl, [I, E, B, N] = n.hcl;
                let G, q;
                if (isNaN(y) || isNaN(I)) isNaN(y) ? isNaN(I) ? G = NaN : (G = I, w !== 1 && w !== 0 || (q = E)) : (G = y, B !== 1 && B !== 0 || (q = b));
                else {
                  let Ce = I - y;
                  I > y && Ce > 180 ? Ce -= 360 : I < y && y - I > 180 && (Ce += 360), G = y + u * Ce;
                }
                const [K, ae, pe, Be] = (function([Ce, Ie, He, rt]) {
                  return Ce = isNaN(Ce) ? 0 : Ce * dc, ia([He, Math.cos(Ce) * Ie, Math.sin(Ce) * Ie, rt]);
                })([G, q ?? Qn(b, E, u), Qn(w, B, u), Qn(S, N, u)]);
                return new xr(K, ae, pe, Be, false);
              }
              case "lab": {
                const [y, b, w, S] = ia(Bo(t.lab, n.lab, u));
                return new xr(y, b, w, S, false);
              }
            }
          }
        }
        xr.black = new xr(0, 0, 0, 1), xr.white = new xr(1, 1, 1, 1), xr.transparent = new xr(0, 0, 0, 0), xr.red = new xr(1, 0, 0, 1);
        class Sa {
          constructor(t, n, u) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const jl = ["bottom", "center", "top"];
        class Nl {
          constructor(t, n, u, h, y, b) {
            this.text = t, this.image = n, this.scale = u, this.fontStack = h, this.textColor = y, this.verticalAlign = b;
          }
        }
        class fn {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new fn([new Nl(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof fn ? t : fn.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class $i {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof $i) return t;
            if (typeof t == "number") return new $i([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new $i(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new $i(Bo(t.values, n.values, u));
          }
        }
        class pn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof pn) return t;
            if (typeof t == "number") return new pn([t]);
            if (Array.isArray(t)) {
              for (const n of t) if (typeof n != "number") return;
              return new pn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new pn(Bo(t.values, n.values, u));
          }
        }
        class Pi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Pi) return t;
            if (typeof t == "string") {
              const u = xr.parse(t);
              return u ? new Pi([u]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const u of t) {
              if (typeof u != "string") return;
              const h = xr.parse(u);
              if (!h) return;
              n.push(h);
            }
            return new Pi(n);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u, h = "rgb") {
            const y = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let b = 0; b < t.values.length; b++) y.push(xr.interpolate(t.values[b], n.values[b], u, h));
            return new Pi(y);
          }
        }
        class ti extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const oh = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class mn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof mn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const u = t[n], h = t[n + 1];
                if (typeof u != "string" || !oh.has(u) || !Array.isArray(h) || h.length !== 2 || typeof h[0] != "number" || typeof h[1] != "number") return;
              }
              return new mn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            const h = t.values, y = n.values;
            if (h.length !== y.length) throw new ti(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const b = [];
            for (let w = 0; w < h.length; w += 2) {
              if (h[w] !== y[w]) throw new ti(`Cannot interpolate values containing mismatched anchors. from[${w}]: ${h[w]}, to[${w}]: ${y[w]}`);
              b.push(h[w]);
              const [S, I] = h[w + 1], [E, B] = y[w + 1];
              b.push([Qn(S, E, u), Qn(I, B, u)]);
            }
            return new mn(b);
          }
        }
        class zn {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new zn({ name: t, available: false }) : null;
          }
        }
        class nn {
          constructor(t, n, u) {
            this.from = t, this.to = n, this.transition = u;
          }
          static interpolate(t, n, u) {
            return new nn(t, n, u);
          }
          static parse(t) {
            return t instanceof nn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new nn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new nn(t.from, t.to, t.transition) : typeof t == "string" ? new nn(t, t, 1) : void 0;
          }
        }
        function si(o, t, n, u) {
          return typeof o == "number" && o >= 0 && o <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[o, t, n, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [o, t, n, u] : [o, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ka(o) {
          if (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number" || o instanceof nn || o instanceof xr || o instanceof Sa || o instanceof fn || o instanceof $i || o instanceof pn || o instanceof Pi || o instanceof mn || o instanceof zn) return true;
          if (Array.isArray(o)) {
            for (const t of o) if (!ka(t)) return false;
            return true;
          }
          if (typeof o == "object") {
            for (const t in o) if (!ka(o[t])) return false;
            return true;
          }
          return false;
        }
        function nr(o) {
          if (o === null) return $r;
          if (typeof o == "string") return cr;
          if (typeof o == "boolean") return lr;
          if (typeof o == "number") return gt;
          if (o instanceof xr) return oi;
          if (o instanceof nn) return hn;
          if (o instanceof Sa) return Qo;
          if (o instanceof fn) return Un;
          if (o instanceof $i) return ea;
          if (o instanceof pn) return bo;
          if (o instanceof Pi) return Sn;
          if (o instanceof mn) return Jn;
          if (o instanceof zn) return Zr;
          if (Array.isArray(o)) {
            const t = o.length;
            let n;
            for (const u of o) {
              const h = nr(u);
              if (n) {
                if (n === h) continue;
                n = dr;
                break;
              }
              n = h;
            }
            return rn(n || dr, t);
          }
          return tn;
        }
        function mr(o) {
          const t = typeof o;
          return o === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(o) : o instanceof xr || o instanceof nn || o instanceof fn || o instanceof $i || o instanceof pn || o instanceof Pi || o instanceof mn || o instanceof zn ? o.toString() : JSON.stringify(o);
        }
        class Oo {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!ka(t[1])) return n.error("invalid value");
            const u = t[1];
            let h = nr(u);
            const y = n.expectedType;
            return h.kind !== "array" || h.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (h = y), new Oo(h, u);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Ar = { string: cr, number: gt, boolean: lr, object: tn };
        class Fn {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u, h = 1;
            const y = t[0];
            if (y === "array") {
              let w, S;
              if (t.length > 2) {
                const I = t[1];
                if (typeof I != "string" || !(I in Ar) || I === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                w = Ar[I], h++;
              } else w = dr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                S = t[2], h++;
              }
              u = rn(w, S);
            } else {
              if (!Ar[y]) throw new Error(`Types doesn't contain name = ${y}`);
              u = Ar[y];
            }
            const b = [];
            for (; h < t.length; h++) {
              const w = n.parse(t[h], h, dr);
              if (!w) return null;
              b.push(w);
            }
            return new Fn(u, b);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const u = this.args[n].evaluate(t);
              if (!wa(this.type, nr(u))) return u;
              if (n === this.args.length - 1) throw new ti(`Expected value to be of type ${Ur(this.type)}, but found ${Ur(nr(u))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const So = { "to-boolean": lr, "to-color": oi, "to-number": gt, "to-string": cr };
        class ko {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[0];
            if (!So[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
            if ((u === "to-boolean" || u === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const h = So[u], y = [];
            for (let b = 1; b < t.length; b++) {
              const w = n.parse(t[b], b, dr);
              if (!w) return null;
              y.push(w);
            }
            return new ko(h, y);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, u;
                for (const h of this.args) {
                  if (n = h.evaluate(t), u = null, n instanceof xr) return n;
                  if (typeof n == "string") {
                    const y = t.parseColor(n);
                    if (y) return y;
                  } else if (Array.isArray(n) && (u = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : si(n[0], n[1], n[2], n[3]), !u)) return new xr(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new ti(u || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = $i.parse(n);
                  if (h) return h;
                }
                throw new ti(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "numberArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = pn.parse(n);
                  if (h) return h;
                }
                throw new ti(`Could not parse numberArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "colorArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Pi.parse(n);
                  if (h) return h;
                }
                throw new ti(`Could not parse colorArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = mn.parse(n);
                  if (h) return h;
                }
                throw new ti(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const u of this.args) {
                  if (n = u.evaluate(t), n === null) return 0;
                  const h = Number(n);
                  if (!isNaN(h)) return h;
                }
                throw new ti(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return fn.fromString(mr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return zn.fromString(mr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return mr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Vl = ["Unknown", "Point", "LineString", "Polygon"];
        class pc {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Vl[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = xr.parse(t), this._parseColorCache.set(t, n)), n;
          }
        }
        class Qa {
          constructor(t, n, u = [], h, y = new Rr(), b = []) {
            this.registry = t, this.path = u, this.key = u.map(((w) => `[${w}]`)).join(""), this.scope = y, this.errors = b, this.expectedType = h, this._isConstant = n;
          }
          parse(t, n, u, h, y = {}) {
            return n ? this.concat(n, u, h)._parse(t, y) : this._parse(t, y);
          }
          _parse(t, n) {
            function u(h, y, b) {
              return b === "assert" ? new Fn(y, [h]) : b === "coerce" ? new ko(y, [h]) : h;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const h = t[0];
              if (typeof h != "string") return this.error(`Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const y = this.registry[h];
              if (y) {
                let b = y.parse(t, this);
                if (!b) return null;
                if (this.expectedType) {
                  const w = this.expectedType, S = b.type;
                  if (w.kind !== "string" && w.kind !== "number" && w.kind !== "boolean" && w.kind !== "object" && w.kind !== "array" || S.kind !== "value") {
                    if (w.kind === "projectionDefinition" && ["string", "array"].includes(S.kind) || ["color", "formatted", "resolvedImage"].includes(w.kind) && ["value", "string"].includes(S.kind) || ["padding", "numberArray"].includes(w.kind) && ["value", "number", "array"].includes(S.kind) || w.kind === "colorArray" && ["value", "string", "array"].includes(S.kind) || w.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(S.kind)) b = u(b, w, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(w, S)) return null;
                  } else b = u(b, w, n.typeAnnotation || "assert");
                }
                if (!(b instanceof Oo) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                  const w = new pc();
                  try {
                    b = new Oo(b.type, b.evaluate(w));
                  } catch (S) {
                    return this.error(S.message), null;
                  }
                }
                return b;
              }
              return this.error(`Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, u) {
            const h = typeof t == "number" ? this.path.concat(t) : this.path, y = u ? this.scope.concat(u) : this.scope;
            return new Qa(this.registry, this._isConstant, h, n || null, y, this.errors);
          }
          error(t, ...n) {
            const u = `${this.key}${n.map(((h) => `[${h}]`)).join("")}`;
            this.errors.push(new Bt(u, t));
          }
          checkSubtype(t, n) {
            const u = wa(t, n);
            return u && this.error(u), u;
          }
        }
        class js {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const u = [];
            for (let y = 1; y < t.length - 1; y += 2) {
              const b = t[y];
              if (typeof b != "string") return n.error(`Expected string, but found ${typeof b} instead.`, y);
              if (/[^a-zA-Z0-9_]/.test(b)) return n.error("Variable names must contain only alphanumeric characters or '_'.", y);
              const w = n.parse(t[y + 1], y + 1);
              if (!w) return null;
              u.push([b, w]);
            }
            const h = n.parse(t[t.length - 1], t.length - 1, n.expectedType, u);
            return h ? new js(u, h) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ul {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const u = t[1];
            return n.scope.has(u) ? new Ul(u, n.scope.get(u)) : n.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Gl {
          constructor(t, n, u) {
            this.type = t, this.index = n, this.input = u;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, gt), h = n.parse(t[2], 2, rn(n.expectedType || dr));
            return u && h ? new Gl(h.type.itemType, u, h) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), u = this.input.evaluate(t);
            if (n < 0) throw new ti(`Array index out of bounds: ${n} < 0.`);
            if (n >= u.length) throw new ti(`Array index out of bounds: ${n} > ${u.length - 1}.`);
            if (n !== Math.floor(n)) throw new ti(`Array index must be an integer, but found ${n} instead.`);
            return u[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class ql {
          constructor(t, n) {
            this.type = lr, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, dr);
            return u && h ? Ds(u.type, [lr, cr, gt, $r, dr]) ? new ql(u, h) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(u.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!u) return false;
            if (!xo(n, ["boolean", "string", "number", "null"])) throw new ti(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(nr(n))} instead.`);
            if (!xo(u, ["string", "array"])) throw new ti(`Expected second argument to be of type array or string, but found ${Ur(nr(u))} instead.`);
            return u.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class eo {
          constructor(t, n, u) {
            this.type = gt, this.needle = t, this.haystack = n, this.fromIndex = u;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, dr);
            if (!u || !h) return null;
            if (!Ds(u.type, [lr, cr, gt, $r, dr])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(u.type)} instead`);
            if (t.length === 4) {
              const y = n.parse(t[3], 3, gt);
              return y ? new eo(u, h, y) : null;
            }
            return new eo(u, h);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!xo(n, ["boolean", "string", "number", "null"])) throw new ti(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(nr(n))} instead.`);
            let h;
            if (this.fromIndex && (h = this.fromIndex.evaluate(t)), xo(u, ["string"])) {
              const y = u.indexOf(n, h);
              return y === -1 ? -1 : [...u.slice(0, y)].length;
            }
            if (xo(u, ["array"])) return u.indexOf(n, h);
            throw new ti(`Expected second argument to be of type array or string, but found ${Ur(nr(u))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class ji {
          constructor(t, n, u, h, y, b) {
            this.inputType = t, this.type = n, this.input = u, this.cases = h, this.outputs = y, this.otherwise = b;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let u, h;
            n.expectedType && n.expectedType.kind !== "value" && (h = n.expectedType);
            const y = {}, b = [];
            for (let I = 2; I < t.length - 1; I += 2) {
              let E = t[I];
              const B = t[I + 1];
              Array.isArray(E) || (E = [E]);
              const N = n.concat(I);
              if (E.length === 0) return N.error("Expected at least one branch label.");
              for (const q of E) {
                if (typeof q != "number" && typeof q != "string") return N.error("Branch labels must be numbers or strings.");
                if (typeof q == "number" && Math.abs(q) > Number.MAX_SAFE_INTEGER) return N.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof q == "number" && Math.floor(q) !== q) return N.error("Numeric branch labels must be integer values.");
                if (u) {
                  if (N.checkSubtype(u, nr(q))) return null;
                } else u = nr(q);
                if (y[String(q)] !== void 0) return N.error("Branch labels must be unique.");
                y[String(q)] = b.length;
              }
              const G = n.parse(B, I, h);
              if (!G) return null;
              h = h || G.type, b.push(G);
            }
            const w = n.parse(t[1], 1, dr);
            if (!w) return null;
            const S = n.parse(t[t.length - 1], t.length - 1, h);
            return S ? w.type.kind !== "value" && n.concat(1).checkSubtype(u, w.type) ? null : new ji(u, h, w, y, b, S) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (nr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class es {
          constructor(t, n, u) {
            this.type = t, this.branches = n, this.otherwise = u;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const h = [];
            for (let b = 1; b < t.length - 1; b += 2) {
              const w = n.parse(t[b], b, lr);
              if (!w) return null;
              const S = n.parse(t[b + 1], b + 1, u);
              if (!S) return null;
              h.push([w, S]), u = u || S.type;
            }
            const y = n.parse(t[t.length - 1], t.length - 1, u);
            if (!y) return null;
            if (!u) throw new Error("Can't infer output type");
            return new es(u, h, y);
          }
          evaluate(t) {
            for (const [n, u] of this.branches) if (n.evaluate(t)) return u.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, u] of this.branches) t(n), t(u);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Ns {
          constructor(t, n, u, h) {
            this.type = t, this.input = n, this.beginIndex = u, this.endIndex = h;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, gt);
            if (!u || !h) return null;
            if (!Ds(u.type, [rn(dr), cr, dr])) return n.error(`Expected first argument to be of type array or string, but found ${Ur(u.type)} instead`);
            if (t.length === 4) {
              const y = n.parse(t[3], 3, gt);
              return y ? new Ns(u.type, u, h, y) : null;
            }
            return new Ns(u.type, u, h);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = this.beginIndex.evaluate(t);
            let h;
            if (this.endIndex && (h = this.endIndex.evaluate(t)), xo(n, ["string"])) return [...n].slice(u, h).join("");
            if (xo(n, ["array"])) return n.slice(u, h);
            throw new ti(`Expected first argument to be of type array or string, but found ${Ur(nr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function Pa(o, t) {
          const n = o.length - 1;
          let u, h, y = 0, b = n, w = 0;
          for (; y <= b; ) if (w = Math.floor((y + b) / 2), u = o[w], h = o[w + 1], u <= t) {
            if (w === n || t < h) return w;
            y = w + 1;
          } else {
            if (!(u > t)) throw new ti("Input is not a number.");
            b = w - 1;
          }
          return 0;
        }
        class yi {
          constructor(t, n, u) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [h, y] of u) this.labels.push(h), this.outputs.push(y);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const u = n.parse(t[1], 1, gt);
            if (!u) return null;
            const h = [];
            let y = null;
            n.expectedType && n.expectedType.kind !== "value" && (y = n.expectedType);
            for (let b = 1; b < t.length; b += 2) {
              const w = b === 1 ? -1 / 0 : t[b], S = t[b + 1], I = b, E = b + 1;
              if (typeof w != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (h.length && h[h.length - 1][0] >= w) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', I);
              const B = n.parse(S, E, y);
              if (!B) return null;
              y = y || B.type, h.push([w, B]);
            }
            return new yi(y, u, h);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const y = n.length;
            return h >= n[y - 1] ? u[y - 1].evaluate(t) : u[Pa(n, h)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function ah(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var Vs, mc, mp = (function() {
          if (mc) return Vs;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return mc = 1, Vs = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var y = this.sampleCurveX(u) - t;
              if (Math.abs(y) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= y / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (y = this.sampleCurveX(u), !(Math.abs(y - t) < n)); h++) t > y ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, Vs;
        })(), ts = ah(mp);
        class Hi {
          constructor(t, n, u, h, y) {
            this.type = t, this.operator = n, this.interpolation = u, this.input = h, this.labels = [], this.outputs = [];
            for (const [b, w] of y) this.labels.push(b), this.outputs.push(w);
          }
          static interpolationFactor(t, n, u, h) {
            let y = 0;
            if (t.name === "exponential") y = Us(n, t.base, u, h);
            else if (t.name === "linear") y = Us(n, 1, u, h);
            else if (t.name === "cubic-bezier") {
              const b = t.controlPoints;
              y = new ts(b[0], b[1], b[2], b[3]).solve(Us(n, 1, u, h));
            }
            return y;
          }
          static parse(t, n) {
            let [u, h, y, ...b] = t;
            if (!Array.isArray(h) || h.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (h[0] === "linear") h = { name: "linear" };
            else if (h[0] === "exponential") {
              const I = h[1];
              if (typeof I != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              h = { name: "exponential", base: I };
            } else {
              if (h[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
              {
                const I = h.slice(1);
                if (I.length !== 4 || I.some(((E) => typeof E != "number" || E < 0 || E > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                h = { name: "cubic-bezier", controlPoints: I };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (y = n.parse(y, 2, gt), !y) return null;
            const w = [];
            let S = null;
            u !== "interpolate-hcl" && u !== "interpolate-lab" || n.expectedType == Sn ? n.expectedType && n.expectedType.kind !== "value" && (S = n.expectedType) : S = oi;
            for (let I = 0; I < b.length; I += 2) {
              const E = b[I], B = b[I + 1], N = I + 3, G = I + 4;
              if (typeof E != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (w.length && w[w.length - 1][0] >= E) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', N);
              const q = n.parse(B, G, S);
              if (!q) return null;
              S = S || q.type, w.push([E, q]);
            }
            return wo(S, gt) || wo(S, hn) || wo(S, oi) || wo(S, ea) || wo(S, bo) || wo(S, Sn) || wo(S, Jn) || wo(S, rn(gt)) ? new Hi(S, u, h, y, w) : n.error(`Type ${Ur(S)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const y = n.length;
            if (h >= n[y - 1]) return u[y - 1].evaluate(t);
            const b = Pa(n, h), w = Hi.interpolationFactor(this.interpolation, h, n[b], n[b + 1]), S = u[b].evaluate(t), I = u[b + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Qn(S, I, w);
                  case "color":
                    return xr.interpolate(S, I, w);
                  case "padding":
                    return $i.interpolate(S, I, w);
                  case "colorArray":
                    return Pi.interpolate(S, I, w);
                  case "numberArray":
                    return pn.interpolate(S, I, w);
                  case "variableAnchorOffsetCollection":
                    return mn.interpolate(S, I, w);
                  case "array":
                    return Bo(S, I, w);
                  case "projectionDefinition":
                    return nn.interpolate(S, I, w);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return xr.interpolate(S, I, w, "hcl");
                  case "colorArray":
                    return Pi.interpolate(S, I, w, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return xr.interpolate(S, I, w, "lab");
                  case "colorArray":
                    return Pi.interpolate(S, I, w, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Us(o, t, n, u) {
          const h = u - n, y = o - n;
          return h === 0 ? 0 : t === 1 ? y / h : (Math.pow(t, y) - 1) / (Math.pow(t, h) - 1);
        }
        const Po = { color: xr.interpolate, number: Qn, padding: $i.interpolate, numberArray: pn.interpolate, colorArray: Pi.interpolate, variableAnchorOffsetCollection: mn.interpolate, array: Bo };
        class Gs {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u = null;
            const h = n.expectedType;
            h && h.kind !== "value" && (u = h);
            const y = [];
            for (const w of t.slice(1)) {
              const S = n.parse(w, 1 + y.length, u, void 0, { typeAnnotation: "omit" });
              if (!S) return null;
              u = u || S.type, y.push(S);
            }
            if (!u) throw new Error("No output type");
            const b = h && y.some(((w) => wa(h, w.type)));
            return new Gs(b ? dr : u, y);
          }
          evaluate(t) {
            let n, u = null, h = 0;
            for (const y of this.args) if (h++, u = y.evaluate(t), u && u instanceof zn && !u.available && (n || (n = u.name), u = null, h === this.args.length && (u = n)), u !== null) break;
            return u;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function qs(o, t) {
          return o === "==" || o === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function Ws(o, t, n, u) {
          return u.compare(t, n) === 0;
        }
        function on(o, t, n) {
          const u = o !== "==" && o !== "!=";
          return class Hb {
            constructor(y, b, w) {
              this.type = lr, this.lhs = y, this.rhs = b, this.collator = w, this.hasUntypedArgument = y.type.kind === "value" || b.type.kind === "value";
            }
            static parse(y, b) {
              if (y.length !== 3 && y.length !== 4) return b.error("Expected two or three arguments.");
              const w = y[0];
              let S = b.parse(y[1], 1, dr);
              if (!S) return null;
              if (!qs(w, S.type)) return b.concat(1).error(`"${w}" comparisons are not supported for type '${Ur(S.type)}'.`);
              let I = b.parse(y[2], 2, dr);
              if (!I) return null;
              if (!qs(w, I.type)) return b.concat(2).error(`"${w}" comparisons are not supported for type '${Ur(I.type)}'.`);
              if (S.type.kind !== I.type.kind && S.type.kind !== "value" && I.type.kind !== "value") return b.error(`Cannot compare types '${Ur(S.type)}' and '${Ur(I.type)}'.`);
              u && (S.type.kind === "value" && I.type.kind !== "value" ? S = new Fn(I.type, [S]) : S.type.kind !== "value" && I.type.kind === "value" && (I = new Fn(S.type, [I])));
              let E = null;
              if (y.length === 4) {
                if (S.type.kind !== "string" && I.type.kind !== "string" && S.type.kind !== "value" && I.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
                if (E = b.parse(y[3], 3, Qo), !E) return null;
              }
              return new Hb(S, I, E);
            }
            evaluate(y) {
              const b = this.lhs.evaluate(y), w = this.rhs.evaluate(y);
              if (u && this.hasUntypedArgument) {
                const S = nr(b), I = nr(w);
                if (S.kind !== I.kind || S.kind !== "string" && S.kind !== "number") throw new ti(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${S.kind}, ${I.kind}) instead.`);
              }
              if (this.collator && !u && this.hasUntypedArgument) {
                const S = nr(b), I = nr(w);
                if (S.kind !== "string" || I.kind !== "string") return t(y, b, w);
              }
              return this.collator ? n(y, b, w, this.collator.evaluate(y)) : t(y, b, w);
            }
            eachChild(y) {
              y(this.lhs), y(this.rhs), this.collator && y(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const sh = on("==", (function(o, t, n) {
          return t === n;
        }), Ws), Wl = on("!=", (function(o, t, n) {
          return t !== n;
        }), (function(o, t, n, u) {
          return !Ws(0, t, n, u);
        })), gp = on("<", (function(o, t, n) {
          return t < n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) < 0;
        })), gc = on(">", (function(o, t, n) {
          return t > n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) > 0;
        })), vp = on("<=", (function(o, t, n) {
          return t <= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) <= 0;
        })), _p = on(">=", (function(o, t, n) {
          return t >= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) >= 0;
        }));
        class Zl {
          constructor(t, n, u) {
            this.type = Qo, this.locale = u, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const u = t[1];
            if (typeof u != "object" || Array.isArray(u)) return n.error("Collator options argument must be an object.");
            const h = n.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, lr);
            if (!h) return null;
            const y = n.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, lr);
            if (!y) return null;
            let b = null;
            return u.locale && (b = n.parse(u.locale, 1, cr), !b) ? null : new Zl(h, y, b);
          }
          evaluate(t) {
            return new Sa(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class vc {
          constructor(t, n, u, h, y) {
            this.type = cr, this.number = t, this.locale = n, this.currency = u, this.minFractionDigits = h, this.maxFractionDigits = y;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, gt);
            if (!u) return null;
            const h = t[2];
            if (typeof h != "object" || Array.isArray(h)) return n.error("NumberFormat options argument must be an object.");
            let y = null;
            if (h.locale && (y = n.parse(h.locale, 1, cr), !y)) return null;
            let b = null;
            if (h.currency && (b = n.parse(h.currency, 1, cr), !b)) return null;
            let w = null;
            if (h["min-fraction-digits"] && (w = n.parse(h["min-fraction-digits"], 1, gt), !w)) return null;
            let S = null;
            return h["max-fraction-digits"] && (S = n.parse(h["max-fraction-digits"], 1, gt), !S) ? null : new vc(u, y, b, w, S);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Ta {
          constructor(t) {
            this.type = Un, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[1];
            if (!Array.isArray(u) && typeof u == "object") return n.error("First argument must be an image or text section.");
            const h = [];
            let y = false;
            for (let b = 1; b <= t.length - 1; ++b) {
              const w = t[b];
              if (y && typeof w == "object" && !Array.isArray(w)) {
                y = false;
                let S = null;
                if (w["font-scale"] && (S = n.parse(w["font-scale"], 1, gt), !S)) return null;
                let I = null;
                if (w["text-font"] && (I = n.parse(w["text-font"], 1, rn(cr)), !I)) return null;
                let E = null;
                if (w["text-color"] && (E = n.parse(w["text-color"], 1, oi), !E)) return null;
                let B = null;
                if (w["vertical-align"]) {
                  if (typeof w["vertical-align"] == "string" && !jl.includes(w["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${w["vertical-align"]}' instead.`);
                  if (B = n.parse(w["vertical-align"], 1, cr), !B) return null;
                }
                const N = h[h.length - 1];
                N.scale = S, N.font = I, N.textColor = E, N.verticalAlign = B;
              } else {
                const S = n.parse(t[b], 1, dr);
                if (!S) return null;
                const I = S.type.kind;
                if (I !== "string" && I !== "value" && I !== "null" && I !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                y = true, h.push({ content: S, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Ta(h);
          }
          evaluate(t) {
            return new fn(this.sections.map(((n) => {
              const u = n.content.evaluate(t);
              return nr(u) === Zr ? new Nl("", u, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Nl(mr(u), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class _c {
          constructor(t) {
            this.type = Zr, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, cr);
            return u ? new _c(u) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = zn.fromString(n);
            return u && t.availableImages && (u.available = t.availableImages.indexOf(n) > -1), u;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Hl {
          constructor(t) {
            this.type = gt, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1);
            return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Ur(u.type)} instead.`) : new Hl(u) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new ti(`Expected value to be of type string or array, but found ${Ur(nr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const to = 8192;
        function yp(o, t) {
          const n = (180 + o[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o[1] * Math.PI / 360))) / 360, h = Math.pow(2, t.z);
          return [Math.round(n * h * to), Math.round(u * h * to)];
        }
        function Xl(o, t) {
          const n = Math.pow(2, t.z);
          return [(h = (o[0] / to + t.x) / n, 360 * h - 180), (u = (o[1] / to + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
          var u, h;
        }
        function Zs(o, t) {
          o[0] = Math.min(o[0], t[0]), o[1] = Math.min(o[1], t[1]), o[2] = Math.max(o[2], t[0]), o[3] = Math.max(o[3], t[1]);
        }
        function Hs(o, t) {
          return !(o[0] <= t[0] || o[2] >= t[2] || o[1] <= t[1] || o[3] >= t[3]);
        }
        function bp(o, t, n) {
          const u = o[0] - t[0], h = o[1] - t[1], y = o[0] - n[0], b = o[1] - n[1];
          return u * b - y * h == 0 && u * y <= 0 && h * b <= 0;
        }
        function Yl(o, t, n, u) {
          return (h = [u[0] - n[0], u[1] - n[1]])[0] * (y = [t[0] - o[0], t[1] - o[1]])[1] - h[1] * y[0] != 0 && !(!uh(o, t, n, u) || !uh(n, u, o, t));
          var h, y;
        }
        function xp(o, t, n) {
          for (const u of n) for (let h = 0; h < u.length - 1; ++h) if (Yl(o, t, u[h], u[h + 1])) return true;
          return false;
        }
        function Ia(o, t, n = false) {
          let u = false;
          for (const w of t) for (let S = 0; S < w.length - 1; S++) {
            if (bp(o, w[S], w[S + 1])) return n;
            (y = w[S])[1] > (h = o)[1] != (b = w[S + 1])[1] > h[1] && h[0] < (b[0] - y[0]) * (h[1] - y[1]) / (b[1] - y[1]) + y[0] && (u = !u);
          }
          var h, y, b;
          return u;
        }
        function lh(o, t) {
          for (const n of t) if (Ia(o, n)) return true;
          return false;
        }
        function yc(o, t) {
          for (const n of o) if (!Ia(n, t)) return false;
          for (let n = 0; n < o.length - 1; ++n) if (xp(o[n], o[n + 1], t)) return false;
          return true;
        }
        function wp(o, t) {
          for (const n of t) if (yc(o, n)) return true;
          return false;
        }
        function uh(o, t, n, u) {
          const h = u[0] - n[0], y = u[1] - n[1], b = (o[0] - n[0]) * y - h * (o[1] - n[1]), w = (t[0] - n[0]) * y - h * (t[1] - n[1]);
          return b > 0 && w < 0 || b < 0 && w > 0;
        }
        function bc(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const y = [];
            for (let b = 0; b < o[h].length; b++) {
              const w = yp(o[h][b], n);
              Zs(t, w), y.push(w);
            }
            u.push(y);
          }
          return u;
        }
        function ch(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const y = bc(o[h], t, n);
            u.push(y);
          }
          return u;
        }
        function Kl(o, t, n, u) {
          if (o[0] < n[0] || o[0] > n[2]) {
            const h = 0.5 * u;
            let y = o[0] - n[0] > h ? -u : n[0] - o[0] > h ? u : 0;
            y === 0 && (y = o[0] - n[2] > h ? -u : n[2] - o[0] > h ? u : 0), o[0] += y;
          }
          Zs(t, o);
        }
        function dh(o, t, n, u) {
          const h = Math.pow(2, u.z) * to, y = [u.x * to, u.y * to], b = [];
          for (const w of o) for (const S of w) {
            const I = [S.x + y[0], S.y + y[1]];
            Kl(I, t, n, h), b.push(I);
          }
          return b;
        }
        function hh(o, t, n, u) {
          const h = Math.pow(2, u.z) * to, y = [u.x * to, u.y * to], b = [];
          for (const S of o) {
            const I = [];
            for (const E of S) {
              const B = [E.x + y[0], E.y + y[1]];
              Zs(t, B), I.push(B);
            }
            b.push(I);
          }
          if (t[2] - t[0] <= h / 2) {
            (w = t)[0] = w[1] = 1 / 0, w[2] = w[3] = -1 / 0;
            for (const S of b) for (const I of S) Kl(I, t, n, h);
          }
          var w;
          return b;
        }
        class Ma {
          constructor(t, n) {
            this.type = lr, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (ka(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") {
                const h = [];
                for (const y of u.features) {
                  const { type: b, coordinates: w } = y.geometry;
                  b === "Polygon" && h.push(w), b === "MultiPolygon" && h.push(...w);
                }
                if (h.length) return new Ma(u, { type: "MultiPolygon", coordinates: h });
              } else if (u.type === "Feature") {
                const h = u.geometry.type;
                if (h === "Polygon" || h === "MultiPolygon") return new Ma(u, u.geometry);
              } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new Ma(u, u);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = bc(u.coordinates, y, b), S = dh(n.geometry(), h, y, b);
                  if (!Hs(h, y)) return false;
                  for (const I of S) if (!Ia(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = ch(u.coordinates, y, b), S = dh(n.geometry(), h, y, b);
                  if (!Hs(h, y)) return false;
                  for (const I of S) if (!lh(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = bc(u.coordinates, y, b), S = hh(n.geometry(), h, y, b);
                  if (!Hs(h, y)) return false;
                  for (const I of S) if (!yc(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = ch(u.coordinates, y, b), S = hh(n.geometry(), h, y, b);
                  if (!Hs(h, y)) return false;
                  for (const I of S) if (!wp(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let xc = class {
          constructor(o = [], t = (n, u) => n < u ? -1 : n > u ? 1 : 0) {
            if (this.data = o, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(o) {
            this.data.push(o), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const o = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), o;
          }
          peek() {
            return this.data[0];
          }
          _up(o) {
            const { data: t, compare: n } = this, u = t[o];
            for (; o > 0; ) {
              const h = o - 1 >> 1, y = t[h];
              if (n(u, y) >= 0) break;
              t[o] = y, o = h;
            }
            t[o] = u;
          }
          _down(o) {
            const { data: t, compare: n } = this, u = this.length >> 1, h = t[o];
            for (; o < u; ) {
              let y = 1 + (o << 1);
              const b = y + 1;
              if (b < this.length && n(t[b], t[y]) < 0 && (y = b), n(t[y], h) >= 0) break;
              t[o] = t[y], o = y;
            }
            t[o] = h;
          }
        };
        function wc(o, t, n = 0, u = o.length - 1, h = Cp) {
          for (; u > n; ) {
            if (u - n > 600) {
              const S = u - n + 1, I = t - n + 1, E = Math.log(S), B = 0.5 * Math.exp(2 * E / 3), N = 0.5 * Math.sqrt(E * B * (S - B) / S) * (I - S / 2 < 0 ? -1 : 1);
              wc(o, t, Math.max(n, Math.floor(t - I * B / S + N)), Math.min(u, Math.floor(t + (S - I) * B / S + N)), h);
            }
            const y = o[t];
            let b = n, w = u;
            for (Xs(o, n, t), h(o[u], y) > 0 && Xs(o, n, u); b < w; ) {
              for (Xs(o, b, w), b++, w--; h(o[b], y) < 0; ) b++;
              for (; h(o[w], y) > 0; ) w--;
            }
            h(o[n], y) === 0 ? Xs(o, n, w) : (w++, Xs(o, w, u)), w <= t && (n = w + 1), t <= w && (u = w - 1);
          }
        }
        function Xs(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Cp(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function Ys(o, t) {
          if (o.length <= 1) return [o];
          const n = [];
          let u, h;
          for (const y of o) {
            const b = Sp(y);
            b !== 0 && (y.area = Math.abs(b), h === void 0 && (h = b < 0), h === b < 0 ? (u && n.push(u), u = [y]) : u.push(y));
          }
          if (u && n.push(u), t > 1) for (let y = 0; y < n.length; y++) n[y].length <= t || (wc(n[y], t, 1, n[y].length - 1, fh), n[y] = n[y].slice(0, t));
          return n;
        }
        function fh(o, t) {
          return t.area - o.area;
        }
        function Sp(o) {
          let t = 0;
          for (let n, u, h = 0, y = o.length, b = y - 1; h < y; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        const ph = 1 / 298.257223563, mh = ph * (2 - ph), Cc = Math.PI / 180;
        class Sc {
          constructor(t) {
            const n = 6378.137 * Cc * 1e3, u = Math.cos(t * Cc), h = 1 / (1 - mh * (1 - u * u)), y = Math.sqrt(h);
            this.kx = n * y * u, this.ky = n * y * h * (1 - mh);
          }
          distance(t, n) {
            const u = this.wrap(t[0] - n[0]) * this.kx, h = (t[1] - n[1]) * this.ky;
            return Math.sqrt(u * u + h * h);
          }
          pointOnLine(t, n) {
            let u, h, y, b, w = 1 / 0;
            for (let S = 0; S < t.length - 1; S++) {
              let I = t[S][0], E = t[S][1], B = this.wrap(t[S + 1][0] - I) * this.kx, N = (t[S + 1][1] - E) * this.ky, G = 0;
              B === 0 && N === 0 || (G = (this.wrap(n[0] - I) * this.kx * B + (n[1] - E) * this.ky * N) / (B * B + N * N), G > 1 ? (I = t[S + 1][0], E = t[S + 1][1]) : G > 0 && (I += B / this.kx * G, E += N / this.ky * G)), B = this.wrap(n[0] - I) * this.kx, N = (n[1] - E) * this.ky;
              const q = B * B + N * N;
              q < w && (w = q, u = I, h = E, y = S, b = G);
            }
            return { point: [u, h], index: y, t: Math.max(0, Math.min(1, b)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function gh(o, t) {
          return t[0] - o[0];
        }
        function Jl(o) {
          return o[1] - o[0] + 1;
        }
        function $o(o, t) {
          return o[1] >= o[0] && o[1] < t;
        }
        function Fr(o, t) {
          if (o[0] > o[1]) return [null, null];
          const n = Jl(o);
          if (t) {
            if (n === 2) return [o, null];
            const h = Math.floor(n / 2);
            return [[o[0], o[0] + h], [o[0] + h, o[1]]];
          }
          if (n === 1) return [o, null];
          const u = Math.floor(n / 2) - 1;
          return [[o[0], o[0] + u], [o[0] + u + 1, o[1]]];
        }
        function kc(o, t) {
          if (!$o(t, o.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let u = t[0]; u <= t[1]; ++u) Zs(n, o[u]);
          return n;
        }
        function Pc(o) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of o) for (const u of n) Zs(t, u);
          return t;
        }
        function vh(o) {
          return o[0] !== -1 / 0 && o[1] !== -1 / 0 && o[2] !== 1 / 0 && o[3] !== 1 / 0;
        }
        function Tc(o, t, n) {
          if (!vh(o) || !vh(t)) return NaN;
          let u = 0, h = 0;
          return o[2] < t[0] && (u = t[0] - o[2]), o[0] > t[2] && (u = o[0] - t[2]), o[1] > t[3] && (h = o[1] - t[3]), o[3] < t[1] && (h = t[1] - o[3]), n.distance([0, 0], [u, h]);
        }
        function Ea(o, t, n) {
          const u = n.pointOnLine(t, o);
          return n.distance(o, u.point);
        }
        function Ic(o, t, n, u, h) {
          const y = Math.min(Ea(o, [n, u], h), Ea(t, [n, u], h)), b = Math.min(Ea(n, [o, t], h), Ea(u, [o, t], h));
          return Math.min(y, b);
        }
        function kp(o, t, n, u, h) {
          if (!$o(t, o.length) || !$o(u, n.length)) return 1 / 0;
          let y = 1 / 0;
          for (let b = t[0]; b < t[1]; ++b) {
            const w = o[b], S = o[b + 1];
            for (let I = u[0]; I < u[1]; ++I) {
              const E = n[I], B = n[I + 1];
              if (Yl(w, S, E, B)) return 0;
              y = Math.min(y, Ic(w, S, E, B, h));
            }
          }
          return y;
        }
        function Pp(o, t, n, u, h) {
          if (!$o(t, o.length) || !$o(u, n.length)) return NaN;
          let y = 1 / 0;
          for (let b = t[0]; b <= t[1]; ++b) for (let w = u[0]; w <= u[1]; ++w) if (y = Math.min(y, h.distance(o[b], n[w])), y === 0) return y;
          return y;
        }
        function Tp(o, t, n) {
          if (Ia(o, t, true)) return 0;
          let u = 1 / 0;
          for (const h of t) {
            const y = h[0], b = h[h.length - 1];
            if (y !== b && (u = Math.min(u, Ea(o, [b, y], n)), u === 0)) return u;
            const w = n.pointOnLine(h, o);
            if (u = Math.min(u, n.distance(o, w.point)), u === 0) return u;
          }
          return u;
        }
        function Ip(o, t, n, u) {
          if (!$o(t, o.length)) return NaN;
          for (let y = t[0]; y <= t[1]; ++y) if (Ia(o[y], n, true)) return 0;
          let h = 1 / 0;
          for (let y = t[0]; y < t[1]; ++y) {
            const b = o[y], w = o[y + 1];
            for (const S of n) for (let I = 0, E = S.length, B = E - 1; I < E; B = I++) {
              const N = S[B], G = S[I];
              if (Yl(b, w, N, G)) return 0;
              h = Math.min(h, Ic(b, w, N, G, u));
            }
          }
          return h;
        }
        function _h(o, t) {
          for (const n of o) for (const u of n) if (Ia(u, t, true)) return true;
          return false;
        }
        function Mp(o, t, n, u = 1 / 0) {
          const h = Pc(o), y = Pc(t);
          if (u !== 1 / 0 && Tc(h, y, n) >= u) return u;
          if (Hs(h, y)) {
            if (_h(o, t)) return 0;
          } else if (_h(t, o)) return 0;
          let b = 1 / 0;
          for (const w of o) for (let S = 0, I = w.length, E = I - 1; S < I; E = S++) {
            const B = w[E], N = w[S];
            for (const G of t) for (let q = 0, K = G.length, ae = K - 1; q < K; ae = q++) {
              const pe = G[ae], Be = G[q];
              if (Yl(B, N, pe, Be)) return 0;
              b = Math.min(b, Ic(B, N, pe, Be, n));
            }
          }
          return b;
        }
        function yh(o, t, n, u, h, y) {
          if (!y) return;
          const b = Tc(kc(u, y), h, n);
          b < t && o.push([b, y, [0, 0]]);
        }
        function Ql(o, t, n, u, h, y, b) {
          if (!y || !b) return;
          const w = Tc(kc(u, y), kc(h, b), n);
          w < t && o.push([w, y, b]);
        }
        function eu(o, t, n, u, h = 1 / 0) {
          let y = Math.min(u.distance(o[0], n[0][0]), h);
          if (y === 0) return y;
          const b = new xc([[0, [0, o.length - 1], [0, 0]]], gh), w = Pc(n);
          for (; b.length > 0; ) {
            const S = b.pop();
            if (S[0] >= y) continue;
            const I = S[1], E = t ? 50 : 100;
            if (Jl(I) <= E) {
              if (!$o(I, o.length)) return NaN;
              if (t) {
                const B = Ip(o, I, n, u);
                if (isNaN(B) || B === 0) return B;
                y = Math.min(y, B);
              } else for (let B = I[0]; B <= I[1]; ++B) {
                const N = Tp(o[B], n, u);
                if (y = Math.min(y, N), y === 0) return 0;
              }
            } else {
              const B = Fr(I, t);
              yh(b, y, u, o, w, B[0]), yh(b, y, u, o, w, B[1]);
            }
          }
          return y;
        }
        function tu(o, t, n, u, h, y = 1 / 0) {
          let b = Math.min(y, h.distance(o[0], n[0]));
          if (b === 0) return b;
          const w = new xc([[0, [0, o.length - 1], [0, n.length - 1]]], gh);
          for (; w.length > 0; ) {
            const S = w.pop();
            if (S[0] >= b) continue;
            const I = S[1], E = S[2], B = t ? 50 : 100, N = u ? 50 : 100;
            if (Jl(I) <= B && Jl(E) <= N) {
              if (!$o(I, o.length) && $o(E, n.length)) return NaN;
              let G;
              if (t && u) G = kp(o, I, n, E, h), b = Math.min(b, G);
              else if (t && !u) {
                const q = o.slice(I[0], I[1] + 1);
                for (let K = E[0]; K <= E[1]; ++K) if (G = Ea(n[K], q, h), b = Math.min(b, G), b === 0) return b;
              } else if (!t && u) {
                const q = n.slice(E[0], E[1] + 1);
                for (let K = I[0]; K <= I[1]; ++K) if (G = Ea(o[K], q, h), b = Math.min(b, G), b === 0) return b;
              } else G = Pp(o, I, n, E, h), b = Math.min(b, G);
            } else {
              const G = Fr(I, t), q = Fr(E, u);
              Ql(w, b, h, o, n, G[0], q[0]), Ql(w, b, h, o, n, G[0], q[1]), Ql(w, b, h, o, n, G[1], q[0]), Ql(w, b, h, o, n, G[1], q[1]);
            }
          }
          return b;
        }
        function Mc(o) {
          return o.type === "MultiPolygon" ? o.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : o.type === "MultiLineString" ? o.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : o.type === "MultiPoint" ? o.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [o];
        }
        class Ra {
          constructor(t, n) {
            this.type = gt, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (ka(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") return new Ra(u, u.features.map(((h) => Mc(h.geometry))).flat());
              if (u.type === "Feature") return new Ra(u, Mc(u.geometry));
              if ("type" in u && "coordinates" in u) return new Ra(u, Mc(u));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = n.geometry(), y = h.flat().map(((S) => Xl([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new Sc(y[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, tu(y, false, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, tu(y, false, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, eu(y, false, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = n.geometry(), y = h.flat().map(((S) => Xl([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new Sc(y[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, tu(y, true, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, tu(y, true, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, eu(y, true, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, u) {
                const h = n.geometry();
                if (h.length === 0 || h[0].length === 0) return NaN;
                const y = Ys(h, 0).map(((S) => S.map(((I) => I.map(((E) => Xl([E.x, E.y], n.canonical))))))), b = new Sc(y[0][0][0][1]);
                let w = 1 / 0;
                for (const S of u) for (const I of y) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, eu([S.coordinates], false, I, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, eu(S.coordinates, true, I, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, Mp(I, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Ks {
          constructor(t) {
            this.type = dr, this.key = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = t[1];
            return u == null ? n.error("Global state property must be defined.") : typeof u != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Ks(u);
          }
          evaluate(t) {
            var n;
            const u = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return u && Object.keys(u).length !== 0 ? na(u, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const rs = { "==": sh, "!=": Wl, ">": gc, "<": gp, ">=": _p, "<=": vp, array: Fn, at: Gl, boolean: Fn, case: es, coalesce: Gs, collator: Zl, format: Ta, image: _c, in: ql, "index-of": eo, interpolate: Hi, "interpolate-hcl": Hi, "interpolate-lab": Hi, length: Hl, let: js, literal: Oo, match: ji, number: Fn, "number-format": vc, object: Fn, slice: Ns, step: yi, string: Fn, "to-boolean": ko, "to-color": ko, "to-number": ko, "to-string": ko, var: Ul, within: Ma, distance: Ra, "global-state": Ks };
        class Gn {
          constructor(t, n, u, h) {
            this.name = t, this.type = n, this._evaluate = u, this.args = h;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return false;
          }
          static parse(t, n) {
            const u = t[0], h = Gn.definitions[u];
            if (!h) return n.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const y = Array.isArray(h) ? h[0] : h.type, b = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, w = b.filter((([I]) => !Array.isArray(I) || I.length === t.length - 1));
            let S = null;
            for (const [I, E] of w) {
              S = new Qa(n.registry, ru, n.path, null, n.scope);
              const B = [];
              let N = false;
              for (let G = 1; G < t.length; G++) {
                const q = t[G], K = Array.isArray(I) ? I[G - 1] : I.type, ae = S.parse(q, 1 + B.length, K);
                if (!ae) {
                  N = true;
                  break;
                }
                B.push(ae);
              }
              if (!N) if (Array.isArray(I) && I.length !== B.length) S.error(`Expected ${I.length} arguments, but found ${B.length} instead.`);
              else {
                for (let G = 0; G < B.length; G++) {
                  const q = Array.isArray(I) ? I[G] : I.type, K = B[G];
                  S.concat(G + 1).checkSubtype(q, K.type);
                }
                if (S.errors.length === 0) return new Gn(u, y, E, B);
              }
            }
            if (w.length === 1) n.errors.push(...S.errors);
            else {
              const I = (w.length ? w : b).map((([B]) => {
                return N = B, Array.isArray(N) ? `(${N.map(Ur).join(", ")})` : `(${Ur(N.type)}...)`;
                var N;
              })).join(" | "), E = [];
              for (let B = 1; B < t.length; B++) {
                const N = n.parse(t[B], 1 + E.length);
                if (!N) return null;
                E.push(Ur(N.type));
              }
              n.error(`Expected arguments of type ${I}, but found (${E.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Gn.definitions = n;
            for (const u in n) t[u] = Gn;
          }
        }
        function bh(o, [t, n, u, h]) {
          t = t.evaluate(o), n = n.evaluate(o), u = u.evaluate(o);
          const y = h ? h.evaluate(o) : 1, b = si(t, n, u, y);
          if (b) throw new ti(b);
          return new xr(t / 255, n / 255, u / 255, y, false);
        }
        function xh(o, t) {
          return o in t;
        }
        function Ec(o, t) {
          const n = t[o];
          return n === void 0 ? null : n;
        }
        function Aa(o) {
          return { type: o };
        }
        function ru(o) {
          if (o instanceof Ul) return ru(o.boundExpression);
          if (o instanceof Gn && o.name === "error" || o instanceof Zl || o instanceof Ma || o instanceof Ra || o instanceof Ks) return false;
          const t = o instanceof ko || o instanceof Fn;
          let n = true;
          return o.eachChild(((u) => {
            n = t ? n && ru(u) : n && u instanceof Oo;
          })), !!n && iu(o) && nu(o, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function iu(o) {
          if (o instanceof Gn && (o.name === "get" && o.args.length === 1 || o.name === "feature-state" || o.name === "has" && o.args.length === 1 || o.name === "properties" || o.name === "geometry-type" || o.name === "id" || /^filter-/.test(o.name)) || o instanceof Ma || o instanceof Ra) return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !iu(n) && (t = false);
          })), t;
        }
        function Js(o) {
          if (o instanceof Gn && o.name === "feature-state") return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !Js(n) && (t = false);
          })), t;
        }
        function nu(o, t) {
          if (o instanceof Gn && t.indexOf(o.name) >= 0) return false;
          let n = true;
          return o.eachChild(((u) => {
            n && !nu(u, t) && (n = false);
          })), n;
        }
        function wh(o) {
          return { result: "success", value: o };
        }
        function is(o) {
          return { result: "error", value: o };
        }
        function oa(o) {
          return o["property-type"] === "data-driven" || o["property-type"] === "cross-faded-data-driven";
        }
        function Ch(o) {
          return !!o.expression && o.expression.parameters.indexOf("zoom") > -1;
        }
        function Rc(o) {
          return !!o.expression && o.expression.interpolated;
        }
        function kr(o) {
          return o instanceof Number ? "number" : o instanceof String ? "string" : o instanceof Boolean ? "boolean" : Array.isArray(o) ? "array" : o === null ? "null" : typeof o;
        }
        function Qs(o) {
          return typeof o == "object" && o !== null && !Array.isArray(o) && nr(o) === tn;
        }
        function Ep(o) {
          return o;
        }
        function Sh(o, t) {
          const n = o.stops && typeof o.stops[0][0] == "object", u = n || !(n || o.property !== void 0), h = o.type || (Rc(t) ? "exponential" : "interval"), y = (function(E) {
            switch (E.type) {
              case "color":
                return xr.parse;
              case "padding":
                return $i.parse;
              case "numberArray":
                return pn.parse;
              case "colorArray":
                return Pi.parse;
              default:
                return null;
            }
          })(t);
          if (y && ((o = dt({}, o)).stops && (o.stops = o.stops.map(((E) => [E[0], y(E[1])]))), o.default = y(o.default ? o.default : t.default)), o.colorSpace && (b = o.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${o.colorSpace}"`);
          var b;
          const w = (function(E) {
            switch (E) {
              case "exponential":
                return Ph;
              case "interval":
                return Rp;
              case "categorical":
                return kh;
              case "identity":
                return Ap;
              default:
                throw new Error(`Unknown function type "${E}"`);
            }
          })(h);
          let S, I;
          if (h === "categorical") {
            S = /* @__PURE__ */ Object.create(null);
            for (const E of o.stops) S[E[0]] = E[1];
            I = typeof o.stops[0][0];
          }
          if (n) {
            const E = {}, B = [];
            for (let q = 0; q < o.stops.length; q++) {
              const K = o.stops[q], ae = K[0].zoom;
              E[ae] === void 0 && (E[ae] = { zoom: ae, type: o.type, property: o.property, default: o.default, stops: [] }, B.push(ae)), E[ae].stops.push([K[0].value, K[1]]);
            }
            const N = [];
            for (const q of B) N.push([E[q].zoom, Sh(E[q], t)]);
            const G = { name: "linear" };
            return { kind: "composite", interpolationType: G, interpolationFactor: Hi.interpolationFactor.bind(void 0, G), zoomStops: N.map(((q) => q[0])), evaluate: ({ zoom: q }, K) => Ph({ stops: N, base: o.base }, t, q).evaluate(q, K) };
          }
          if (u) {
            const E = h === "exponential" ? { name: "exponential", base: o.base !== void 0 ? o.base : 1 } : null;
            return { kind: "camera", interpolationType: E, interpolationFactor: Hi.interpolationFactor.bind(void 0, E), zoomStops: o.stops.map(((B) => B[0])), evaluate: ({ zoom: B }) => w(o, t, B, S, I) };
          }
          return { kind: "source", evaluate(E, B) {
            const N = B && B.properties ? B.properties[o.property] : void 0;
            return N === void 0 ? aa(o.default, t.default) : w(o, t, N, S, I);
          } };
        }
        function aa(o, t, n) {
          return o !== void 0 ? o : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function kh(o, t, n, u, h) {
          return aa(typeof n === h ? u[n] : void 0, o.default, t.default);
        }
        function Rp(o, t, n) {
          if (kr(n) !== "number") return aa(o.default, t.default);
          const u = o.stops.length;
          if (u === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[u - 1][0]) return o.stops[u - 1][1];
          const h = Pa(o.stops.map(((y) => y[0])), n);
          return o.stops[h][1];
        }
        function Ph(o, t, n) {
          const u = o.base !== void 0 ? o.base : 1;
          if (kr(n) !== "number") return aa(o.default, t.default);
          const h = o.stops.length;
          if (h === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[h - 1][0]) return o.stops[h - 1][1];
          const y = Pa(o.stops.map(((E) => E[0])), n), b = (function(E, B, N, G) {
            const q = G - N, K = E - N;
            return q === 0 ? 0 : B === 1 ? K / q : (Math.pow(B, K) - 1) / (Math.pow(B, q) - 1);
          })(n, u, o.stops[y][0], o.stops[y + 1][0]), w = o.stops[y][1], S = o.stops[y + 1][1], I = Po[t.type] || Ep;
          return typeof w.evaluate == "function" ? { evaluate(...E) {
            const B = w.evaluate.apply(void 0, E), N = S.evaluate.apply(void 0, E);
            if (B !== void 0 && N !== void 0) return I(B, N, b, o.colorSpace);
          } } : I(w, S, b, o.colorSpace);
        }
        function Ap(o, t, n) {
          switch (t.type) {
            case "color":
              n = xr.parse(n);
              break;
            case "formatted":
              n = fn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = zn.fromString(n.toString());
              break;
            case "padding":
              n = $i.parse(n);
              break;
            case "colorArray":
              n = Pi.parse(n);
              break;
            case "numberArray":
              n = pn.parse(n);
              break;
            default:
              kr(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return aa(n, o.default, t.default);
        }
        Gn.register(rs, { error: [{ kind: "error" }, [cr], (o, [t]) => {
          throw new ti(t.evaluate(o));
        }], typeof: [cr, [dr], (o, [t]) => Ur(nr(t.evaluate(o)))], "to-rgba": [rn(gt, 4), [oi], (o, [t]) => {
          const [n, u, h, y] = t.evaluate(o).rgb;
          return [255 * n, 255 * u, 255 * h, y];
        }], rgb: [oi, [gt, gt, gt], bh], rgba: [oi, [gt, gt, gt, gt], bh], has: { type: lr, overloads: [[[cr], (o, [t]) => xh(t.evaluate(o), o.properties())], [[cr, tn], (o, [t, n]) => xh(t.evaluate(o), n.evaluate(o))]] }, get: { type: dr, overloads: [[[cr], (o, [t]) => Ec(t.evaluate(o), o.properties())], [[cr, tn], (o, [t, n]) => Ec(t.evaluate(o), n.evaluate(o))]] }, "feature-state": [dr, [cr], (o, [t]) => Ec(t.evaluate(o), o.featureState || {})], properties: [tn, [], (o) => o.properties()], "geometry-type": [cr, [], (o) => o.geometryType()], id: [dr, [], (o) => o.id()], zoom: [gt, [], (o) => o.globals.zoom], "heatmap-density": [gt, [], (o) => o.globals.heatmapDensity || 0], elevation: [gt, [], (o) => o.globals.elevation || 0], "line-progress": [gt, [], (o) => o.globals.lineProgress || 0], accumulated: [dr, [], (o) => o.globals.accumulated === void 0 ? null : o.globals.accumulated], "+": [gt, Aa(gt), (o, t) => {
          let n = 0;
          for (const u of t) n += u.evaluate(o);
          return n;
        }], "*": [gt, Aa(gt), (o, t) => {
          let n = 1;
          for (const u of t) n *= u.evaluate(o);
          return n;
        }], "-": { type: gt, overloads: [[[gt, gt], (o, [t, n]) => t.evaluate(o) - n.evaluate(o)], [[gt], (o, [t]) => -t.evaluate(o)]] }, "/": [gt, [gt, gt], (o, [t, n]) => t.evaluate(o) / n.evaluate(o)], "%": [gt, [gt, gt], (o, [t, n]) => t.evaluate(o) % n.evaluate(o)], ln2: [gt, [], () => Math.LN2], pi: [gt, [], () => Math.PI], e: [gt, [], () => Math.E], "^": [gt, [gt, gt], (o, [t, n]) => Math.pow(t.evaluate(o), n.evaluate(o))], sqrt: [gt, [gt], (o, [t]) => Math.sqrt(t.evaluate(o))], log10: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN10], ln: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o))], log2: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN2], sin: [gt, [gt], (o, [t]) => Math.sin(t.evaluate(o))], cos: [gt, [gt], (o, [t]) => Math.cos(t.evaluate(o))], tan: [gt, [gt], (o, [t]) => Math.tan(t.evaluate(o))], asin: [gt, [gt], (o, [t]) => Math.asin(t.evaluate(o))], acos: [gt, [gt], (o, [t]) => Math.acos(t.evaluate(o))], atan: [gt, [gt], (o, [t]) => Math.atan(t.evaluate(o))], min: [gt, Aa(gt), (o, t) => Math.min(...t.map(((n) => n.evaluate(o))))], max: [gt, Aa(gt), (o, t) => Math.max(...t.map(((n) => n.evaluate(o))))], abs: [gt, [gt], (o, [t]) => Math.abs(t.evaluate(o))], round: [gt, [gt], (o, [t]) => {
          const n = t.evaluate(o);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [gt, [gt], (o, [t]) => Math.floor(t.evaluate(o))], ceil: [gt, [gt], (o, [t]) => Math.ceil(t.evaluate(o))], "filter-==": [lr, [cr, dr], (o, [t, n]) => o.properties()[t.value] === n.value], "filter-id-==": [lr, [dr], (o, [t]) => o.id() === t.value], "filter-type-==": [lr, [cr], (o, [t]) => o.geometryType() === t.value], "filter-<": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u < h;
        }], "filter-id-<": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n < u;
        }], "filter->": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u > h;
        }], "filter-id->": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n > u;
        }], "filter-<=": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u <= h;
        }], "filter-id-<=": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n <= u;
        }], "filter->=": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u >= h;
        }], "filter-id->=": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n >= u;
        }], "filter-has": [lr, [dr], (o, [t]) => t.value in o.properties()], "filter-has-id": [lr, [], (o) => o.id() !== null && o.id() !== void 0], "filter-type-in": [lr, [rn(cr)], (o, [t]) => t.value.indexOf(o.geometryType()) >= 0], "filter-id-in": [lr, [rn(dr)], (o, [t]) => t.value.indexOf(o.id()) >= 0], "filter-in-small": [lr, [cr, rn(dr)], (o, [t, n]) => n.value.indexOf(o.properties()[t.value]) >= 0], "filter-in-large": [lr, [cr, rn(dr)], (o, [t, n]) => (function(u, h, y, b) {
          for (; y <= b; ) {
            const w = y + b >> 1;
            if (h[w] === u) return true;
            h[w] > u ? b = w - 1 : y = w + 1;
          }
          return false;
        })(o.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) && n.evaluate(o)], [Aa(lr), (o, t) => {
          for (const n of t) if (!n.evaluate(o)) return false;
          return true;
        }]] }, any: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) || n.evaluate(o)], [Aa(lr), (o, t) => {
          for (const n of t) if (n.evaluate(o)) return true;
          return false;
        }]] }, "!": [lr, [lr], (o, [t]) => !t.evaluate(o)], "is-supported-script": [lr, [cr], (o, [t]) => {
          const n = o.globals && o.globals.isSupportedScript;
          return !n || n(t.evaluate(o));
        }], upcase: [cr, [cr], (o, [t]) => t.evaluate(o).toUpperCase()], downcase: [cr, [cr], (o, [t]) => t.evaluate(o).toLowerCase()], concat: [cr, Aa(dr), (o, t) => t.map(((n) => mr(n.evaluate(o)))).join("")], "resolved-locale": [cr, [Qo], (o, [t]) => t.evaluate(o).resolvedLocale()] });
        class Ac {
          constructor(t, n) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new pc(), this._defaultValue = n ? (function(u) {
              if (u.type === "color" && Qs(u.default)) return new xr(0, 0, 0, 0);
              switch (u.type) {
                case "color":
                  return xr.parse(u.default) || null;
                case "padding":
                  return $i.parse(u.default) || null;
                case "numberArray":
                  return pn.parse(u.default) || null;
                case "colorArray":
                  return Pi.parse(u.default) || null;
                case "variableAnchorOffsetCollection":
                  return mn.parse(u.default) || null;
                case "projectionDefinition":
                  return nn.parse(u.default) || null;
                default:
                  return u.default === void 0 ? null : u.default;
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null;
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = u, this._evaluator.canonical = h, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, u, h, y, b) {
            this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = u || null, this._evaluator.canonical = h, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = b || null;
            try {
              const w = this.expression.evaluate(this._evaluator);
              if (w == null || typeof w == "number" && w != w) return this._defaultValue;
              if (this._enumValues && !(w in this._enumValues)) throw new ti(`Expected value to be one of ${Object.keys(this._enumValues).map(((S) => JSON.stringify(S))).join(", ")}, but found ${JSON.stringify(w)} instead.`);
              return w;
            } catch (w) {
              return this._warningHistory[w.message] || (this._warningHistory[w.message] = true, typeof console < "u" && console.warn(w.message)), this._defaultValue;
            }
          }
        }
        function ou(o) {
          return Array.isArray(o) && o.length > 0 && typeof o[0] == "string" && o[0] in rs;
        }
        function el(o, t) {
          const n = new Qa(rs, ru, [], t ? (function(h) {
            const y = { color: oi, string: cr, number: gt, enum: cr, boolean: lr, formatted: Un, padding: ea, numberArray: bo, colorArray: Sn, projectionDefinition: hn, resolvedImage: Zr, variableAnchorOffsetCollection: Jn };
            return h.type === "array" ? rn(y[h.value] || dr, h.length) : y[h.type];
          })(t) : void 0), u = n.parse(o, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return u ? wh(new Ac(u, t)) : is(n.errors);
        }
        class tl {
          constructor(t, n) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !Js(n.expression), this.globalStateRefs = nl(n.expression);
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, y, b);
          }
          evaluate(t, n, u, h, y, b) {
            return this._styleExpression.evaluate(t, n, u, h, y, b);
          }
        }
        class Dc {
          constructor(t, n, u, h) {
            this.kind = t, this.zoomStops = u, this._styleExpression = n, this.isStateDependent = t !== "camera" && !Js(n.expression), this.globalStateRefs = nl(n.expression), this.interpolationType = h;
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, y, b);
          }
          evaluate(t, n, u, h, y, b) {
            return this._styleExpression.evaluate(t, n, u, h, y, b);
          }
          interpolationFactor(t, n, u) {
            return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, t, n, u) : 0;
          }
        }
        function Th(o, t) {
          const n = el(o, t);
          if (n.result === "error") return n;
          const u = n.value.expression, h = iu(u);
          if (!h && !oa(t)) return is([new Bt("", "data expressions not supported")]);
          const y = nu(u, ["zoom"]);
          if (!y && !Ch(t)) return is([new Bt("", "zoom expressions not supported")]);
          const b = il(u);
          return b || y ? b instanceof Bt ? is([b]) : b instanceof Hi && !Rc(t) ? is([new Bt("", '"interpolate" expressions cannot be used with this property')]) : wh(b ? new Dc(h ? "camera" : "composite", n.value, b.labels, b instanceof Hi ? b.interpolation : void 0) : new tl(h ? "constant" : "source", n.value)) : is([new Bt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class rl {
          constructor(t, n) {
            this._parameters = t, this._specification = n, dt(this, Sh(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new rl(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function il(o) {
          let t = null;
          if (o instanceof js) t = il(o.result);
          else if (o instanceof Gs) {
            for (const n of o.args) if (t = il(n), t) break;
          } else (o instanceof yi || o instanceof Hi) && o.input instanceof Gn && o.input.name === "zoom" && (t = o);
          return t instanceof Bt || o.eachChild(((n) => {
            const u = il(n);
            u instanceof Bt ? t = u : !t && u ? t = new Bt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && u && t !== u && (t = new Bt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function nl(o, t = /* @__PURE__ */ new Set()) {
          return o instanceof Ks && t.add(o.key), o.eachChild(((n) => {
            nl(n, t);
          })), t;
        }
        function au(o) {
          if (o === true || o === false) return true;
          if (!Array.isArray(o) || o.length === 0) return false;
          switch (o[0]) {
            case "has":
              return o.length >= 2 && o[1] !== "$id" && o[1] !== "$type";
            case "in":
              return o.length >= 3 && (typeof o[1] != "string" || Array.isArray(o[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return o.length !== 3 || Array.isArray(o[1]) || Array.isArray(o[2]);
            case "any":
            case "all":
              for (const t of o.slice(1)) if (!au(t) && typeof t != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const zc = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Da(o) {
          if (o == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          au(o) || (o = za(o));
          const t = el(o, zc);
          if (t.result === "error") throw new Error(t.value.map(((n) => `${n.key}: ${n.message}`)).join(", "));
          return { filter: (n, u, h) => t.value.evaluate(n, u, {}, h), needGeometry: su(o), getGlobalStateRefs: () => nl(t.value.expression) };
        }
        function Fc(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function su(o) {
          if (!Array.isArray(o)) return false;
          if (o[0] === "within" || o[0] === "distance") return true;
          for (let t = 1; t < o.length; t++) if (su(o[t])) return true;
          return false;
        }
        function za(o) {
          if (!o) return true;
          const t = o[0];
          return o.length <= 1 ? t !== "any" : t === "==" ? Lc(o[1], o[2], "==") : t === "!=" ? lu(Lc(o[1], o[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Lc(o[1], o[2], t) : t === "any" ? (n = o.slice(1), ["any"].concat(n.map(za))) : t === "all" ? ["all"].concat(o.slice(1).map(za)) : t === "none" ? ["all"].concat(o.slice(1).map(za).map(lu)) : t === "in" ? Ih(o[1], o.slice(2)) : t === "!in" ? lu(Ih(o[1], o.slice(2))) : t === "has" ? Mh(o[1]) : t !== "!has" || lu(Mh(o[1]));
          var n;
        }
        function Lc(o, t, n) {
          switch (o) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, o, t];
          }
        }
        function Ih(o, t) {
          if (t.length === 0) return false;
          switch (o) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((n) => typeof n != typeof t[0])) ? ["filter-in-large", o, ["literal", t.sort(Fc)]] : ["filter-in-small", o, ["literal", t]];
          }
        }
        function Mh(o) {
          switch (o) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", o];
          }
        }
        function lu(o) {
          return ["!", o];
        }
        function Bc(o) {
          const t = typeof o;
          if (t === "number" || t === "boolean" || t === "string" || o == null) return JSON.stringify(o);
          if (Array.isArray(o)) {
            let h = "[";
            for (const y of o) h += `${Bc(y)},`;
            return `${h}]`;
          }
          const n = Object.keys(o).sort();
          let u = "{";
          for (let h = 0; h < n.length; h++) u += `${JSON.stringify(n[h])}:${Bc(o[n[h]])},`;
          return `${u}}`;
        }
        function Dp(o) {
          let t = "";
          for (const n of $t) t += `/${Bc(o[n])}`;
          return t;
        }
        function Oc(o) {
          const t = o.value;
          return t ? [new ge(o.key, t, "constants have been deprecated as of v8")] : [];
        }
        function gi(o) {
          return o instanceof Number || o instanceof String || o instanceof Boolean ? o.valueOf() : o;
        }
        function To(o) {
          if (Array.isArray(o)) return o.map(To);
          if (o instanceof Object && !(o instanceof Number || o instanceof String || o instanceof Boolean)) {
            const t = {};
            for (const n in o) t[n] = To(o[n]);
            return t;
          }
          return gi(o);
        }
        function qn(o) {
          const t = o.key, n = o.value, u = o.valueSpec || {}, h = o.objectElementValidators || {}, y = o.style, b = o.styleSpec, w = o.validateSpec;
          let S = [];
          const I = kr(n);
          if (I !== "object") return [new ge(t, n, `object expected, ${I} found`)];
          for (const E in n) {
            const B = E.split(".")[0], N = na(u, B) || u["*"];
            let G;
            if (na(h, B)) G = h[B];
            else if (na(u, B)) G = w;
            else if (h["*"]) G = h["*"];
            else {
              if (!u["*"]) {
                S.push(new ge(t, n[E], `unknown property "${E}"`));
                continue;
              }
              G = w;
            }
            S = S.concat(G({ key: (t && `${t}.`) + E, value: n[E], valueSpec: N, style: y, styleSpec: b, object: n, objectKey: E, validateSpec: w }, n));
          }
          for (const E in u) h[E] || u[E].required && u[E].default === void 0 && n[E] === void 0 && S.push(new ge(t, n, `missing required property "${E}"`));
          return S;
        }
        function uu(o) {
          const t = o.value, n = o.valueSpec, u = o.style, h = o.styleSpec, y = o.key, b = o.arrayElementValidator || o.validateSpec;
          if (kr(t) !== "array") return [new ge(y, t, `array expected, ${kr(t)} found`)];
          if (n.length && t.length !== n.length) return [new ge(y, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new ge(y, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let w = { type: n.value, values: n.values };
          h.$version < 7 && (w.function = n.function), kr(n.value) === "object" && (w = n.value);
          let S = [];
          for (let I = 0; I < t.length; I++) S = S.concat(b({ array: t, arrayIndex: I, value: t[I], valueSpec: w, validateSpec: o.validateSpec, style: u, styleSpec: h, key: `${y}[${I}]` }));
          return S;
        }
        function ol(o) {
          const t = o.key, n = o.value, u = o.valueSpec;
          let h = kr(n);
          return h === "number" && n != n && (h = "NaN"), h !== "number" ? [new ge(t, n, `number expected, ${h} found`)] : "minimum" in u && n < u.minimum ? [new ge(t, n, `${n} is less than the minimum value ${u.minimum}`)] : "maximum" in u && n > u.maximum ? [new ge(t, n, `${n} is greater than the maximum value ${u.maximum}`)] : [];
        }
        function Eh(o) {
          const t = o.valueSpec, n = gi(o.value.type);
          let u, h, y, b = {};
          const w = n !== "categorical" && o.value.property === void 0, S = !w, I = kr(o.value.stops) === "array" && kr(o.value.stops[0]) === "array" && kr(o.value.stops[0][0]) === "object", E = qn({ key: o.key, value: o.value, valueSpec: o.styleSpec.function, validateSpec: o.validateSpec, style: o.style, styleSpec: o.styleSpec, objectElementValidators: { stops: function(G) {
            if (n === "identity") return [new ge(G.key, G.value, 'identity function may not have a "stops" property')];
            let q = [];
            const K = G.value;
            return q = q.concat(uu({ key: G.key, value: K, valueSpec: G.valueSpec, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec, arrayElementValidator: B })), kr(K) === "array" && K.length === 0 && q.push(new ge(G.key, K, "array must have at least one stop")), q;
          }, default: function(G) {
            return G.validateSpec({ key: G.key, value: G.value, valueSpec: t, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec });
          } } });
          return n === "identity" && w && E.push(new ge(o.key, o.value, 'missing required property "property"')), n === "identity" || o.value.stops || E.push(new ge(o.key, o.value, 'missing required property "stops"')), n === "exponential" && o.valueSpec.expression && !Rc(o.valueSpec) && E.push(new ge(o.key, o.value, "exponential functions not supported")), o.styleSpec.$version >= 8 && (S && !oa(o.valueSpec) ? E.push(new ge(o.key, o.value, "property functions not supported")) : w && !Ch(o.valueSpec) && E.push(new ge(o.key, o.value, "zoom functions not supported"))), n !== "categorical" && !I || o.value.property !== void 0 || E.push(new ge(o.key, o.value, '"property" property is required')), E;
          function B(G) {
            let q = [];
            const K = G.value, ae = G.key;
            if (kr(K) !== "array") return [new ge(ae, K, `array expected, ${kr(K)} found`)];
            if (K.length !== 2) return [new ge(ae, K, `array length 2 expected, length ${K.length} found`)];
            if (I) {
              if (kr(K[0]) !== "object") return [new ge(ae, K, `object expected, ${kr(K[0])} found`)];
              if (K[0].zoom === void 0) return [new ge(ae, K, "object stop key must have zoom")];
              if (K[0].value === void 0) return [new ge(ae, K, "object stop key must have value")];
              if (y && y > gi(K[0].zoom)) return [new ge(ae, K[0].zoom, "stop zoom values must appear in ascending order")];
              gi(K[0].zoom) !== y && (y = gi(K[0].zoom), h = void 0, b = {}), q = q.concat(qn({ key: `${ae}[0]`, value: K[0], valueSpec: { zoom: {} }, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec, objectElementValidators: { zoom: ol, value: N } }));
            } else q = q.concat(N({ key: `${ae}[0]`, value: K[0], validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec }, K));
            return ou(To(K[1])) ? q.concat([new ge(`${ae}[1]`, K[1], "expressions are not allowed in function stops.")]) : q.concat(G.validateSpec({ key: `${ae}[1]`, value: K[1], valueSpec: t, validateSpec: G.validateSpec, style: G.style, styleSpec: G.styleSpec }));
          }
          function N(G, q) {
            const K = kr(G.value), ae = gi(G.value), pe = G.value !== null ? G.value : q;
            if (u) {
              if (K !== u) return [new ge(G.key, pe, `${K} stop domain type must match previous stop domain type ${u}`)];
            } else u = K;
            if (K !== "number" && K !== "string" && K !== "boolean") return [new ge(G.key, pe, "stop domain value must be a number, string, or boolean")];
            if (K !== "number" && n !== "categorical") {
              let Be = `number expected, ${K} found`;
              return oa(t) && n === void 0 && (Be += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ge(G.key, pe, Be)];
            }
            return n !== "categorical" || K !== "number" || isFinite(ae) && Math.floor(ae) === ae ? n !== "categorical" && K === "number" && h !== void 0 && ae < h ? [new ge(G.key, pe, "stop domain values must appear in ascending order")] : (h = ae, n === "categorical" && ae in b ? [new ge(G.key, pe, "stop domain values must be unique")] : (b[ae] = true, [])) : [new ge(G.key, pe, `integer expected, found ${ae}`)];
          }
        }
        function Fa(o) {
          const t = (o.expressionContext === "property" ? Th : el)(To(o.value), o.valueSpec);
          if (t.result === "error") return t.value.map(((u) => new ge(`${o.key}${u.key}`, o.value, u.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (o.expressionContext === "property" && o.propertyKey === "text-font" && !n.outputDefined()) return [new ge(o.key, o.value, `Invalid data expression for "${o.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (o.expressionContext === "property" && o.propertyType === "layout" && !Js(n)) return [new ge(o.key, o.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (o.expressionContext === "filter" && !Js(n)) return [new ge(o.key, o.value, '"feature-state" data expressions are not supported with filters.')];
          if (o.expressionContext && o.expressionContext.indexOf("cluster") === 0) {
            if (!nu(n, ["zoom", "feature-state"])) return [new ge(o.key, o.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (o.expressionContext === "cluster-initial" && !iu(n)) return [new ge(o.key, o.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function cu(o) {
          const t = o.key, n = o.value, u = kr(n);
          return u !== "string" ? [new ge(t, n, `color expected, ${u} found`)] : xr.parse(String(n)) ? [] : [new ge(t, n, `color expected, "${n}" found`)];
        }
        function jo(o) {
          const t = o.key, n = o.value, u = o.valueSpec, h = [];
          return Array.isArray(u.values) ? u.values.indexOf(gi(n)) === -1 && h.push(new ge(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(gi(n)) === -1 && h.push(new ge(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), h;
        }
        function $c(o) {
          return au(To(o.value)) ? Fa(dt({}, o, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Rh(o);
        }
        function Rh(o) {
          const t = o.value, n = o.key;
          if (kr(t) !== "array") return [new ge(n, t, `array expected, ${kr(t)} found`)];
          const u = o.styleSpec;
          let h, y = [];
          if (t.length < 1) return [new ge(n, t, "filter array must have at least 1 element")];
          switch (y = y.concat(jo({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: o.style, styleSpec: o.styleSpec })), gi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && gi(t[1]) === "$type" && y.push(new ge(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && y.push(new ge(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (h = kr(t[1]), h !== "string" && y.push(new ge(`${n}[1]`, t[1], `string expected, ${h} found`)));
              for (let b = 2; b < t.length; b++) h = kr(t[b]), gi(t[1]) === "$type" ? y = y.concat(jo({ key: `${n}[${b}]`, value: t[b], valueSpec: u.geometry_type, style: o.style, styleSpec: o.styleSpec })) : h !== "string" && h !== "number" && h !== "boolean" && y.push(new ge(`${n}[${b}]`, t[b], `string, number, or boolean expected, ${h} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let b = 1; b < t.length; b++) y = y.concat(Rh({ key: `${n}[${b}]`, value: t[b], style: o.style, styleSpec: o.styleSpec }));
              break;
            case "has":
            case "!has":
              h = kr(t[1]), t.length !== 2 ? y.push(new ge(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : h !== "string" && y.push(new ge(`${n}[1]`, t[1], `string expected, ${h} found`));
          }
          return y;
        }
        function Ah(o, t) {
          const n = o.key, u = o.validateSpec, h = o.style, y = o.styleSpec, b = o.value, w = o.objectKey, S = y[`${t}_${o.layerType}`];
          if (!S) return [];
          const I = w.match(/^(.*)-transition$/);
          if (t === "paint" && I && S[I[1]] && S[I[1]].transition) return u({ key: n, value: b, valueSpec: y.transition, style: h, styleSpec: y });
          const E = o.valueSpec || S[w];
          if (!E) return [new ge(n, b, `unknown property "${w}"`)];
          let B;
          if (kr(b) === "string" && oa(E) && !E.tokens && (B = /^{([^}]+)}$/.exec(b))) return [new ge(n, b, `"${w}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(B[1])} }\`.`)];
          const N = [];
          return o.layerType === "symbol" && (w === "text-field" && h && !h.glyphs && N.push(new ge(n, b, 'use of "text-field" requires a style "glyphs" property')), w === "text-font" && Qs(To(b)) && gi(b.type) === "identity" && N.push(new ge(n, b, '"text-font" does not support identity functions'))), N.concat(u({ key: o.key, value: b, valueSpec: E, style: h, styleSpec: y, expressionContext: "property", propertyType: t, propertyKey: w }));
        }
        function Dh(o) {
          return Ah(o, "paint");
        }
        function zh(o) {
          return Ah(o, "layout");
        }
        function Fh(o) {
          let t = [];
          const n = o.value, u = o.key, h = o.style, y = o.styleSpec;
          if (kr(n) !== "object") return [new ge(u, n, `object expected, ${kr(n)} found`)];
          n.type || n.ref || t.push(new ge(u, n, 'either "type" or "ref" is required'));
          let b = gi(n.type);
          const w = gi(n.ref);
          if (n.id) {
            const S = gi(n.id);
            for (let I = 0; I < o.arrayIndex; I++) {
              const E = h.layers[I];
              gi(E.id) === S && t.push(new ge(u, n.id, `duplicate layer id "${n.id}", previously used at line ${E.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let S;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((I) => {
              I in n && t.push(new ge(u, n[I], `"${I}" is prohibited for ref layers`));
            })), h.layers.forEach(((I) => {
              gi(I.id) === w && (S = I);
            })), S ? S.ref ? t.push(new ge(u, n.ref, "ref cannot reference another ref layer")) : b = gi(S.type) : t.push(new ge(u, n.ref, `ref layer "${w}" not found`));
          } else if (b !== "background") if (n.source) {
            const S = h.sources && h.sources[n.source], I = S && gi(S.type);
            S ? I === "vector" && b === "raster" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a raster source`)) : I !== "raster-dem" && b === "hillshade" || I !== "raster-dem" && b === "color-relief" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a raster-dem source`)) : I === "raster" && b !== "raster" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a vector source`)) : I !== "vector" || n["source-layer"] ? I === "raster-dem" && b !== "hillshade" && b !== "color-relief" ? t.push(new ge(u, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : b !== "line" || !n.paint || !n.paint["line-gradient"] || I === "geojson" && S.lineMetrics || t.push(new ge(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ge(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new ge(u, n.source, `source "${n.source}" not found`));
          } else t.push(new ge(u, n, 'missing required property "source"'));
          return t = t.concat(qn({ key: u, value: n, valueSpec: y.layer, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, objectElementValidators: { "*": () => [], type: () => o.validateSpec({ key: `${u}.type`, value: n.type, valueSpec: y.layer.type, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, object: n, objectKey: "type" }), filter: $c, layout: (S) => qn({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => zh(dt({ layerType: b }, I)) } }), paint: (S) => qn({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => Dh(dt({ layerType: b }, I)) } }) } })), t;
        }
        function ro(o) {
          const t = o.value, n = o.key, u = kr(t);
          return u !== "string" ? [new ge(n, t, `string expected, ${u} found`)] : [];
        }
        const ns = { promoteId: function({ key: o, value: t }) {
          if (kr(t) === "string") return ro({ key: o, value: t });
          {
            const n = [];
            for (const u in t) n.push(...ro({ key: `${o}.${u}`, value: t[u] }));
            return n;
          }
        } };
        function kn(o) {
          const t = o.value, n = o.key, u = o.styleSpec, h = o.style, y = o.validateSpec;
          if (!t.type) return [new ge(n, t, '"type" is required')];
          const b = gi(t.type);
          let w;
          switch (b) {
            case "vector":
            case "raster":
              return w = qn({ key: n, value: t, valueSpec: u[`source_${b.replace("-", "_")}`], style: o.style, styleSpec: u, objectElementValidators: ns, validateSpec: y }), w;
            case "raster-dem":
              return w = (function(S) {
                var I;
                const E = (I = S.sourceName) !== null && I !== void 0 ? I : "", B = S.value, N = S.styleSpec, G = N.source_raster_dem, q = S.style;
                let K = [];
                const ae = kr(B);
                if (B === void 0) return K;
                if (ae !== "object") return K.push(new ge("source_raster_dem", B, `object expected, ${ae} found`)), K;
                const pe = gi(B.encoding) === "custom", Be = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Ce = S.value.encoding ? `"${S.value.encoding}"` : "Default";
                for (const Ie in B) !pe && Be.includes(Ie) ? K.push(new ge(Ie, B[Ie], `In "${E}": "${Ie}" is only valid when "encoding" is set to "custom". ${Ce} encoding found`)) : G[Ie] ? K = K.concat(S.validateSpec({ key: Ie, value: B[Ie], valueSpec: G[Ie], validateSpec: S.validateSpec, style: q, styleSpec: N })) : K.push(new ge(Ie, B[Ie], `unknown property "${Ie}"`));
                return K;
              })({ sourceName: n, value: t, style: o.style, styleSpec: u, validateSpec: y }), w;
            case "geojson":
              if (w = qn({ key: n, value: t, valueSpec: u.source_geojson, style: h, styleSpec: u, validateSpec: y, objectElementValidators: ns }), t.cluster) for (const S in t.clusterProperties) {
                const [I, E] = t.clusterProperties[S], B = typeof I == "string" ? [I, ["accumulated"], ["get", S]] : I;
                w.push(...Fa({ key: `${n}.${S}.map`, value: E, expressionContext: "cluster-map" })), w.push(...Fa({ key: `${n}.${S}.reduce`, value: B, expressionContext: "cluster-reduce" }));
              }
              return w;
            case "video":
              return qn({ key: n, value: t, valueSpec: u.source_video, style: h, validateSpec: y, styleSpec: u });
            case "image":
              return qn({ key: n, value: t, valueSpec: u.source_image, style: h, validateSpec: y, styleSpec: u });
            case "canvas":
              return [new ge(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return jo({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function os(o) {
          const t = o.value, n = o.styleSpec, u = n.light, h = o.style;
          let y = [];
          const b = kr(t);
          if (t === void 0) return y;
          if (b !== "object") return y = y.concat([new ge("light", t, `object expected, ${b} found`)]), y;
          for (const w in t) {
            const S = w.match(/^(.*)-transition$/);
            y = y.concat(S && u[S[1]] && u[S[1]].transition ? o.validateSpec({ key: w, value: t[w], valueSpec: n.transition, validateSpec: o.validateSpec, style: h, styleSpec: n }) : u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          }
          return y;
        }
        function jc(o) {
          const t = o.value, n = o.styleSpec, u = n.sky, h = o.style, y = kr(t);
          if (t === void 0) return [];
          if (y !== "object") return [new ge("sky", t, `object expected, ${y} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return b;
        }
        function Lh(o) {
          const t = o.value, n = o.styleSpec, u = n.terrain, h = o.style;
          let y = [];
          const b = kr(t);
          if (t === void 0) return y;
          if (b !== "object") return y = y.concat([new ge("terrain", t, `object expected, ${b} found`)]), y;
          for (const w in t) y = y.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return y;
        }
        function Bh(o) {
          let t = [];
          const n = o.value, u = o.key;
          if (Array.isArray(n)) {
            const h = [], y = [];
            for (const b in n) n[b].id && h.includes(n[b].id) && t.push(new ge(u, n, `all the sprites' ids must be unique, but ${n[b].id} is duplicated`)), h.push(n[b].id), n[b].url && y.includes(n[b].url) && t.push(new ge(u, n, `all the sprites' URLs must be unique, but ${n[b].url} is duplicated`)), y.push(n[b].url), t = t.concat(qn({ key: `${u}[${b}]`, value: n[b], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: o.validateSpec }));
            return t;
          }
          return ro({ key: u, value: n });
        }
        function as(o) {
          return t = o.value, t && t.constructor === Object ? [] : [new ge(o.key, o.value, `object expected, ${kr(o.value)} found`)];
          var t;
        }
        const Nc = { "*": () => [], array: uu, boolean: function(o) {
          const t = o.value, n = o.key, u = kr(t);
          return u !== "boolean" ? [new ge(n, t, `boolean expected, ${u} found`)] : [];
        }, number: ol, color: cu, constants: Oc, enum: jo, filter: $c, function: Eh, layer: Fh, object: qn, source: kn, light: os, sky: jc, terrain: Lh, projection: function(o) {
          const t = o.value, n = o.styleSpec, u = n.projection, h = o.style, y = kr(t);
          if (t === void 0) return [];
          if (y !== "object") return [new ge("projection", t, `object expected, ${y} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return b;
        }, projectionDefinition: function(o) {
          const t = o.key;
          let n = o.value;
          n = n instanceof String ? n.valueOf() : n;
          const u = kr(n);
          return u !== "array" || (function(h) {
            return Array.isArray(h) && h.length === 3 && typeof h[0] == "string" && typeof h[1] == "string" && typeof h[2] == "number";
          })(n) || (function(h) {
            return !!["interpolate", "step", "literal"].includes(h[0]);
          })(n) ? ["array", "string"].includes(u) ? [] : [new ge(t, n, `projection expected, invalid type "${u}" found`)] : [new ge(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: ro, formatted: function(o) {
          return ro(o).length === 0 ? [] : Fa(o);
        }, resolvedImage: function(o) {
          return ro(o).length === 0 ? [] : Fa(o);
        }, padding: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new ge(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const u = { type: "number" };
            let h = [];
            for (let y = 0; y < n.length; y++) h = h.concat(o.validateSpec({ key: `${t}[${y}]`, value: n[y], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return ol({ key: t, value: n, valueSpec: {} });
        }, numberArray: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            const u = { type: "number" };
            if (n.length < 1) return [new ge(t, n, "array length at least 1 expected, length 0 found")];
            let h = [];
            for (let y = 0; y < n.length; y++) h = h.concat(o.validateSpec({ key: `${t}[${y}]`, value: n[y], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return ol({ key: t, value: n, valueSpec: {} });
        }, colorArray: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            if (n.length < 1) return [new ge(t, n, "array length at least 1 expected, length 0 found")];
            let u = [];
            for (let h = 0; h < n.length; h++) u = u.concat(cu({ key: `${t}[${h}]`, value: n[h] }));
            return u;
          }
          return cu({ key: t, value: n });
        }, variableAnchorOffsetCollection: function(o) {
          const t = o.key, n = o.value, u = kr(n), h = o.styleSpec;
          if (u !== "array" || n.length < 1 || n.length % 2 != 0) return [new ge(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let y = [];
          for (let b = 0; b < n.length; b += 2) y = y.concat(jo({ key: `${t}[${b}]`, value: n[b], valueSpec: h.layout_symbol["text-anchor"] })), y = y.concat(uu({ key: `${t}[${b + 1}]`, value: n[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: o.validateSpec, style: o.style, styleSpec: h }));
          return y;
        }, sprite: Bh, state: as };
        function ss(o) {
          const t = o.value, n = o.valueSpec, u = o.styleSpec;
          return o.validateSpec = ss, n.expression && Qs(gi(t)) ? Eh(o) : n.expression && ou(To(t)) ? Fa(o) : n.type && Nc[n.type] ? Nc[n.type](o) : qn(dt({}, o, { valueSpec: n.type ? u[n.type] : n }));
        }
        function Oh(o) {
          const t = o.value, n = o.key, u = ro(o);
          return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new ge(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new ge(n, t, '"glyphs" url must include a "{range}" token'))), u;
        }
        function Pn(o, t = Pe) {
          let n = [];
          return n = n.concat(ss({ key: "", value: o, valueSpec: t.$root, styleSpec: t, style: o, validateSpec: ss, objectElementValidators: { glyphs: Oh, "*": () => [] } })), o.constants && (n = n.concat(Oc({ key: "constants", value: o.constants }))), ls(n);
        }
        function io(o) {
          return function(t) {
            return o({ ...t, validateSpec: ss });
          };
        }
        function ls(o) {
          return [].concat(o).sort(((t, n) => t.line - n.line));
        }
        function no(o) {
          return function(...t) {
            return ls(o.apply(this, t));
          };
        }
        Pn.source = no(io(kn)), Pn.sprite = no(io(Bh)), Pn.glyphs = no(io(Oh)), Pn.light = no(io(os)), Pn.sky = no(io(jc)), Pn.terrain = no(io(Lh)), Pn.state = no(io(as)), Pn.layer = no(io(Fh)), Pn.filter = no(io($c)), Pn.paintProperty = no(io(Dh)), Pn.layoutProperty = no(io(zh));
        const us = Pn, zp = us.light, al = us.sky, Fp = us.paintProperty, Lp = us.layoutProperty;
        function sl(o, t) {
          let n = false;
          if (t && t.length) for (const u of t) o.fire(new Xe(new Error(u.message))), n = true;
          return n;
        }
        class ll {
          constructor(t, n, u) {
            const h = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const b = new Int32Array(this.arrayBuffer);
              t = b[0], this.d = (n = b[1]) + 2 * (u = b[2]);
              for (let S = 0; S < this.d * this.d; S++) {
                const I = b[3 + S], E = b[3 + S + 1];
                h.push(I === E ? null : b.subarray(I, E));
              }
              const w = b[3 + h.length + 1];
              this.keys = b.subarray(b[3 + h.length], w), this.bboxes = b.subarray(w), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * u;
              for (let b = 0; b < this.d * this.d; b++) h.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = u, this.scale = n / t, this.uid = 0;
            const y = u / n * t;
            this.min = -y, this.max = t + y;
          }
          insert(t, n, u, h, y) {
            this._forEachCell(n, u, h, y, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(h), this.bboxes.push(y);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, u, h, y, b) {
            this.cells[y].push(b);
          }
          query(t, n, u, h, y) {
            const b = this.min, w = this.max;
            if (t <= b && n <= b && w <= u && w <= h && !y) return Array.prototype.slice.call(this.keys);
            {
              const S = [];
              return this._forEachCell(t, n, u, h, this._queryCell, S, {}, y), S;
            }
          }
          _queryCell(t, n, u, h, y, b, w, S) {
            const I = this.cells[y];
            if (I !== null) {
              const E = this.keys, B = this.bboxes;
              for (let N = 0; N < I.length; N++) {
                const G = I[N];
                if (w[G] === void 0) {
                  const q = 4 * G;
                  (S ? S(B[q + 0], B[q + 1], B[q + 2], B[q + 3]) : t <= B[q + 2] && n <= B[q + 3] && u >= B[q + 0] && h >= B[q + 1]) ? (w[G] = true, b.push(E[G])) : w[G] = false;
                }
              }
            }
          }
          _forEachCell(t, n, u, h, y, b, w, S) {
            const I = this._convertToCellCoord(t), E = this._convertToCellCoord(n), B = this._convertToCellCoord(u), N = this._convertToCellCoord(h);
            for (let G = I; G <= B; G++) for (let q = E; q <= N; q++) {
              const K = this.d * q + G;
              if ((!S || S(this._convertFromCellCoord(G), this._convertFromCellCoord(q), this._convertFromCellCoord(G + 1), this._convertFromCellCoord(q + 1))) && y.call(this, t, n, u, h, K, b, w, S)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let u = 0;
            for (let b = 0; b < this.cells.length; b++) u += this.cells[b].length;
            const h = new Int32Array(n + u + this.keys.length + this.bboxes.length);
            h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
            let y = n;
            for (let b = 0; b < t.length; b++) {
              const w = t[b];
              h[3 + b] = y, h.set(w, y), y += w.length;
            }
            return h[3 + t.length] = y, h.set(this.keys, y), y += this.keys.length, h[3 + t.length + 1] = y, h.set(this.bboxes, y), y += this.bboxes.length, h.buffer;
          }
          static serialize(t, n) {
            const u = t.toArrayBuffer();
            return n && n.push(u), { buffer: u };
          }
          static deserialize(t) {
            return new ll(t.buffer);
          }
        }
        const oo = {};
        function Ft(o, t, n = {}) {
          if (oo[o]) throw new Error(`${o} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: o, writeable: false }), oo[o] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        Ft("Object", Object), Ft("Set", Set), Ft("TransferableGridIndex", ll), Ft("Color", xr), Ft("Error", Error), Ft("AJAXError", _e), Ft("ResolvedImage", zn), Ft("StylePropertyFunction", rl), Ft("StyleExpression", Ac, { omit: ["_evaluator"] }), Ft("ZoomDependentExpression", Dc), Ft("ZoomConstantExpression", tl), Ft("CompoundExpression", Gn, { omit: ["_evaluate"] });
        for (const o in rs) rs[o]._classRegistryKey || Ft(`Expression_${o}`, rs[o]);
        function Vc(o) {
          return o && typeof ArrayBuffer < "u" && (o instanceof ArrayBuffer || o.constructor && o.constructor.name === "ArrayBuffer");
        }
        function du(o) {
          return o.$name || o.constructor._classRegistryKey;
        }
        function Uc(o) {
          return !(function(t) {
            if (t === null || typeof t != "object") return false;
            const n = du(t);
            return !(!n || n === "Object");
          })(o) && (o == null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || o instanceof Boolean || o instanceof Number || o instanceof String || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof Error || Vc(o) || Ee(o) || ArrayBuffer.isView(o) || o instanceof ImageData);
        }
        function cs(o, t) {
          if (Uc(o)) return (Vc(o) || Ee(o)) && t && t.push(o), ArrayBuffer.isView(o) && t && t.push(o.buffer), o instanceof ImageData && t && t.push(o.data.buffer), o;
          if (Array.isArray(o)) {
            const y = [];
            for (const b of o) y.push(cs(b, t));
            return y;
          }
          if (typeof o != "object") throw new Error("can't serialize object of type " + typeof o);
          const n = du(o);
          if (!n) throw new Error(`can't serialize object of unregistered class ${o.constructor.name}`);
          if (!oo[n]) throw new Error(`${n} is not registered.`);
          const { klass: u } = oo[n], h = u.serialize ? u.serialize(o, t) : {};
          if (u.serialize) {
            if (t && h === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const y in o) {
              if (!o.hasOwnProperty(y) || oo[n].omit.indexOf(y) >= 0) continue;
              const b = o[y];
              h[y] = oo[n].shallow.indexOf(y) >= 0 ? b : cs(b, t);
            }
            o instanceof Error && (h.message = o.message);
          }
          if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (h.$name = n), h;
        }
        function La(o) {
          if (Uc(o)) return o;
          if (Array.isArray(o)) return o.map(La);
          if (typeof o != "object") throw new Error("can't deserialize object of type " + typeof o);
          const t = du(o) || "Object";
          if (!oo[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = oo[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(o);
          const u = Object.create(n.prototype);
          for (const h of Object.keys(o)) {
            if (h === "$name") continue;
            const y = o[h];
            u[h] = oo[t].shallow.indexOf(h) >= 0 ? y : La(y);
          }
          return u;
        }
        class hu {
          constructor() {
            this.first = true;
          }
          update(t, n) {
            const u = Math.floor(t);
            return this.first ? (this.first = false, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = u, true) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = u, true));
          }
        }
        const Ir = { "Latin-1 Supplement": (o) => o >= 128 && o <= 255, "Hangul Jamo": (o) => o >= 4352 && o <= 4607, Khmer: (o) => o >= 6016 && o <= 6143, "General Punctuation": (o) => o >= 8192 && o <= 8303, "Letterlike Symbols": (o) => o >= 8448 && o <= 8527, "Number Forms": (o) => o >= 8528 && o <= 8591, "Miscellaneous Technical": (o) => o >= 8960 && o <= 9215, "Control Pictures": (o) => o >= 9216 && o <= 9279, "Optical Character Recognition": (o) => o >= 9280 && o <= 9311, "Enclosed Alphanumerics": (o) => o >= 9312 && o <= 9471, "Geometric Shapes": (o) => o >= 9632 && o <= 9727, "Miscellaneous Symbols": (o) => o >= 9728 && o <= 9983, "Miscellaneous Symbols and Arrows": (o) => o >= 11008 && o <= 11263, "Ideographic Description Characters": (o) => o >= 12272 && o <= 12287, "CJK Symbols and Punctuation": (o) => o >= 12288 && o <= 12351, Hiragana: (o) => o >= 12352 && o <= 12447, Katakana: (o) => o >= 12448 && o <= 12543, Kanbun: (o) => o >= 12688 && o <= 12703, "CJK Strokes": (o) => o >= 12736 && o <= 12783, "Enclosed CJK Letters and Months": (o) => o >= 12800 && o <= 13055, "CJK Compatibility": (o) => o >= 13056 && o <= 13311, "Yijing Hexagram Symbols": (o) => o >= 19904 && o <= 19967, "CJK Unified Ideographs": (o) => o >= 19968 && o <= 40959, "Hangul Syllables": (o) => o >= 44032 && o <= 55215, "Private Use Area": (o) => o >= 57344 && o <= 63743, "Vertical Forms": (o) => o >= 65040 && o <= 65055, "CJK Compatibility Forms": (o) => o >= 65072 && o <= 65103, "Small Form Variants": (o) => o >= 65104 && o <= 65135, "Halfwidth and Fullwidth Forms": (o) => o >= 65280 && o <= 65519 };
        function fu(o) {
          for (const t of o) if (qc(t.charCodeAt(0))) return true;
          return false;
        }
        function Bp(o) {
          for (const t of o) if (!$h(t.charCodeAt(0))) return false;
          return true;
        }
        function pu(o) {
          const t = o.map(((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((n) => n));
          return new RegExp(t.join("|"), "u");
        }
        const Op = pu(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function $h(o) {
          return !Op.test(String.fromCodePoint(o));
        }
        const Gc = pu(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function qc(o) {
          return !(o !== 746 && o !== 747 && (o < 4352 || !(Ir["CJK Compatibility Forms"](o) && !(o >= 65097 && o <= 65103) || Ir["CJK Compatibility"](o) || Ir["CJK Strokes"](o) || !(!Ir["CJK Symbols and Punctuation"](o) || o >= 12296 && o <= 12305 || o >= 12308 && o <= 12319 || o === 12336) || Ir["Enclosed CJK Letters and Months"](o) || Ir["Ideographic Description Characters"](o) || Ir.Kanbun(o) || Ir.Katakana(o) && o !== 12540 || !(!Ir["Halfwidth and Fullwidth Forms"](o) || o === 65288 || o === 65289 || o === 65293 || o >= 65306 && o <= 65310 || o === 65339 || o === 65341 || o === 65343 || o >= 65371 && o <= 65503 || o === 65507 || o >= 65512 && o <= 65519) || !(!Ir["Small Form Variants"](o) || o >= 65112 && o <= 65118 || o >= 65123 && o <= 65126) || Ir["Vertical Forms"](o) || Ir["Yijing Hexagram Symbols"](o) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(o)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(o)) || Gc.test(String.fromCodePoint(o)))));
        }
        function jh(o) {
          return !(qc(o) || (function(t) {
            return !!(Ir["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Ir["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Ir["Letterlike Symbols"](t) || Ir["Number Forms"](t) || Ir["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Ir["Control Pictures"](t) && t !== 9251 || Ir["Optical Character Recognition"](t) || Ir["Enclosed Alphanumerics"](t) || Ir["Geometric Shapes"](t) || Ir["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Ir["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Ir["CJK Symbols and Punctuation"](t) || Ir.Katakana(t) || Ir["Private Use Area"](t) || Ir["CJK Compatibility Forms"](t) || Ir["Small Form Variants"](t) || Ir["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(o));
        }
        const Nh = pu(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Wc(o) {
          return Nh.test(String.fromCodePoint(o));
        }
        function Vh(o, t) {
          return !(!t && Wc(o) || o >= 2304 && o <= 3583 || o >= 3840 && o <= 4255 || Ir.Khmer(o));
        }
        function Uh(o) {
          for (const t of o) if (Wc(t.charCodeAt(0))) return true;
          return false;
        }
        const ao = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(o) {
            this.pluginStatus = o.pluginStatus, this.pluginURL = o.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(o) {
            if (ao.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = o.applyArabicShaping, this.processBidirectionalText = o.processBidirectionalText, this.processStyledBidirectionalText = o.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (o.pluginStatus !== "loading") return this.setState(o), o;
              const n = o.pluginURL, u = new Promise(((y) => {
                this.loadScriptResolve = y;
              }));
              t(n);
              const h = new Promise(((y) => setTimeout((() => y()), this.TIMEOUT)));
              if (yield Promise.race([u, h]), this.isParsed()) {
                const y = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(y), y;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            }));
          }
        }();
        class ri {
          constructor(t, n) {
            this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new hu(), this.transition = n.transition || {}, this.globalState = n.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new hu(), this.transition = {}, this.globalState = {});
          }
          isSupportedScript(t) {
            return (function(n, u) {
              for (const h of n) if (!Vh(h.charCodeAt(0), u)) return false;
              return true;
            })(t, ao.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), u = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * n };
          }
        }
        class ds {
          constructor(t, n) {
            this.property = t, this.value = n, this.expression = (function(u, h) {
              if (Qs(u)) return new rl(u, h);
              if (ou(u)) {
                const y = Th(u, h);
                if (y.result === "error") throw new Error(y.value.map(((b) => `${b.key}: ${b.message}`)).join(", "));
                return y.value;
              }
              {
                let y = u;
                return h.type === "color" && typeof u == "string" ? y = xr.parse(u) : h.type !== "padding" || typeof u != "number" && !Array.isArray(u) ? h.type !== "numberArray" || typeof u != "number" && !Array.isArray(u) ? h.type !== "colorArray" || typeof u != "string" && !Array.isArray(u) ? h.type === "variableAnchorOffsetCollection" && Array.isArray(u) ? y = mn.parse(u) : h.type === "projectionDefinition" && typeof u == "string" && (y = nn.parse(u)) : y = Pi.parse(u) : y = pn.parse(u) : y = $i.parse(u), { globalStateRefs: /* @__PURE__ */ new Set(), kind: "constant", evaluate: () => y };
              }
            })(n === void 0 ? t.specification.default : n, t.specification), this._evaluate = this.expression.evaluate;
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, n, u) {
            return this.property.possiblyEvaluate(this, t, n, u);
          }
          setGlobalState(t) {
            this.expression.evaluate = (n, u, h, y, b, w) => (n.globalState = t, this._evaluate.call(this.expression, n, u, h, y, b, w));
          }
        }
        class Zc {
          constructor(t) {
            this.property = t, this.value = new ds(t, void 0);
          }
          transitioned(t, n) {
            return new Hc(this.property, this.value, n, Jt({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new Hc(this.property, this.value, null, {}, 0);
          }
        }
        class Gh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
          }
          getValue(t) {
            return rr(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Zc(this._values[t].property)), this._values[t].value = new ds(this._values[t].property, n === null ? void 0 : rr(n));
          }
          getTransition(t) {
            return rr(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Zc(this._values[t].property)), this._values[t].transition = rr(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
              const h = this.getTransition(n);
              h !== void 0 && (t[`${n}-transition`] = h);
            }
            return t;
          }
          transitioned(t, n) {
            const u = new Xc(this._properties);
            for (const h of Object.keys(this._values)) u._values[h] = this._values[h].transitioned(t, n._values[h]);
            return u;
          }
          untransitioned() {
            const t = new Xc(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class Hc {
          constructor(t, n, u, h, y) {
            this.property = t, this.value = n, this.begin = y + h.delay || 0, this.end = this.begin + h.duration || 0, t.specification.transition && (h.delay || h.duration) && (this.prior = u);
          }
          possiblyEvaluate(t, n, u) {
            const h = t.now || 0, y = this.value.possiblyEvaluate(t, n, u), b = this.prior;
            if (b) {
              if (h > this.end) return this.prior = null, y;
              if (this.value.isDataDriven()) return this.prior = null, y;
              if (h < this.begin) return b.possiblyEvaluate(t, n, u);
              {
                const w = (h - this.begin) / (this.end - this.begin);
                return this.property.interpolate(b.possiblyEvaluate(t, n, u), y, ut(w));
              }
            }
            return y;
          }
        }
        class Xc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, u) {
            const h = new mu(this._properties);
            for (const y of Object.keys(this._values)) h._values[y] = this._values[y].possiblyEvaluate(t, n, u);
            return h;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return true;
            return false;
          }
        }
        class qh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = {};
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return rr(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new ds(this._values[t].property, n === null ? void 0 : rr(n)), this._values[t].setGlobalState(this._globalState);
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
            }
            return t;
          }
          possiblyEvaluate(t, n, u) {
            const h = new mu(this._properties);
            for (const y of Object.keys(this._values)) h._values[y] = this._values[y].possiblyEvaluate(t, n, u);
            return h;
          }
          setGlobalState(t) {
            this._globalState = t;
            for (const n of Object.values(this._values)) n.setGlobalState(t);
          }
        }
        class Io {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.parameters = u;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, u, h) {
            return this.property.evaluate(this.value, this.parameters, t, n, u, h);
          }
        }
        class mu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Gt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, u) {
            const h = Po[this.specification.type];
            return h ? h(t, n, u) : t;
          }
        }
        class er {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, u, h) {
            return new Io(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, u, h) } : t.expression, n);
          }
          interpolate(t, n, u) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Io(this, { kind: "constant", value: void 0 }, t.parameters);
            const h = Po[this.specification.type];
            if (h) {
              const y = h(t.value.value, n.value.value, u);
              return new Io(this, { kind: "constant", value: y }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, u, h, y, b) {
            return t.kind === "constant" ? t.value : t.evaluate(n, u, h, y, b);
          }
        }
        class gu extends er {
          possiblyEvaluate(t, n, u, h) {
            if (t.value === void 0) return new Io(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const y = t.expression.evaluate(n, null, {}, u, h), b = t.property.specification.type === "resolvedImage" && typeof y != "string" ? y.name : y, w = this._calculate(b, b, b, n);
              return new Io(this, { kind: "constant", value: w }, n);
            }
            if (t.expression.kind === "camera") {
              const y = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new Io(this, { kind: "constant", value: y }, n);
            }
            return new Io(this, t.expression, n);
          }
          evaluate(t, n, u, h, y, b) {
            if (t.kind === "source") {
              const w = t.evaluate(n, u, h, y, b);
              return this._calculate(w, w, w, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, u, h), n) : t.value;
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class sa {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const y = t.expression.evaluate(n, null, {}, u, h);
                return this._calculate(y, y, y, n);
              }
              return this._calculate(t.expression.evaluate(new ri(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new ri(Math.floor(n.zoom), n)), t.expression.evaluate(new ri(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class vu {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            return !!t.expression.evaluate(n, null, {}, u, h);
          }
          interpolate() {
            return false;
          }
        }
        class gn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const u = t[n];
              u.specification.overridable && this.overridableProperties.push(n);
              const h = this.defaultPropertyValues[n] = new ds(u, void 0), y = this.defaultTransitionablePropertyValues[n] = new Zc(u);
              this.defaultTransitioningPropertyValues[n] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = h.possiblyEvaluate({});
            }
          }
        }
        Ft("DataDrivenProperty", er), Ft("DataConstantProperty", Gt), Ft("CrossFadedDataDrivenProperty", gu), Ft("CrossFadedProperty", sa), Ft("ColorRampProperty", vu);
        const Wh = "-transition";
        class Wn extends wt {
          constructor(t, n) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, this._globalState = {}, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Da(t.filter)), n.layout && (this._unevaluatedLayout = new qh(n.layout)), n.paint)) {
              this._transitionablePaint = new Gh(n.paint);
              for (const u in t.paint) this.setPaintProperty(u, t.paint[u], { validate: false });
              for (const u in t.layout) this.setLayoutProperty(u, t.layout[u], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mu(n.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Da(t);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const n in this._unevaluatedLayout._values) {
              const u = this._unevaluatedLayout._values[n];
              for (const h of u.getGlobalStateRefs()) t.add(h);
            }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map();
            if (this._transitionablePaint) for (const u in this._transitionablePaint._values) {
              const h = this._transitionablePaint._values[u].value;
              for (const y of h.getGlobalStateRefs()) {
                const b = (t = n.get(y)) !== null && t !== void 0 ? t : [];
                b.push({ name: u, value: h.value }), n.set(y, b);
              }
            }
            return n;
          }
          setLayoutProperty(t, n, u = {}) {
            n != null && this._validate(Lp, `layers.${this.id}.layout.${t}`, t, n, u) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(Wh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, u = {}) {
            if (n != null && this._validate(Fp, `layers.${this.id}.paint.${t}`, t, n, u)) return false;
            if (t.endsWith(Wh)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), false;
            {
              const h = this._transitionablePaint._values[t], y = h.property.specification["property-type"] === "cross-faded-data-driven", b = h.value.isDataDriven(), w = h.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const S = this._transitionablePaint._values[t].value;
              return S.isDataDriven() || b || y || this._handleOverridablePaintPropertyUpdate(t, w, S);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return false;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.globalState = this._globalState, t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          setGlobalState(t) {
            this._globalState = t, this._unevaluatedLayout && this._unevaluatedLayout.setGlobalState(t);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Er(t, ((n, u) => !(n === void 0 || u === "layout" && !Object.keys(n).length || u === "paint" && !Object.keys(n).length)));
          }
          _validate(t, n, u, h, y = {}) {
            return (!y || y.validate !== false) && sl(this, t.call(us, { key: n, layerType: this.type, objectKey: u, value: h, styleSpec: Pe, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Io && oa(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const $p = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class ul {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Hr {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = true, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function bi(o, t = 1) {
          let n = 0, u = 0;
          return { members: o.map(((h) => {
            const y = $p[h.type].BYTES_PER_ELEMENT, b = n = _u(n, Math.max(t, y)), w = h.components || 1;
            return u = Math.max(u, y), n += y * w, { name: h.name, type: h.type, components: w, offset: b };
          })), size: _u(n, Math.max(u, t)), alignment: t };
        }
        function _u(o, t) {
          return Math.ceil(o / t) * t;
        }
        class hs extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.int16[h + 0] = n, this.int16[h + 1] = u, t;
          }
        }
        hs.prototype.bytesPerElement = 4, Ft("StructArrayLayout2i4", hs);
        class fs extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.int16[y + 0] = n, this.int16[y + 1] = u, this.int16[y + 2] = h, t;
          }
        }
        fs.prototype.bytesPerElement = 6, Ft("StructArrayLayout3i6", fs);
        class Yc extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, u, h);
          }
          emplace(t, n, u, h, y) {
            const b = 4 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = u, this.int16[b + 2] = h, this.int16[b + 3] = y, t;
          }
        }
        Yc.prototype.bytesPerElement = 8, Ft("StructArrayLayout4i8", Yc);
        class ps extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = y, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        ps.prototype.bytesPerElement = 12, Ft("StructArrayLayout2i4i12", ps);
        class Ba extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 4 * t, I = 8 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.uint8[I + 4] = h, this.uint8[I + 5] = y, this.uint8[I + 6] = b, this.uint8[I + 7] = w, t;
          }
        }
        Ba.prototype.bytesPerElement = 8, Ft("StructArrayLayout2i4ub8", Ba);
        class cl extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.float32[h + 0] = n, this.float32[h + 1] = u, t;
          }
        }
        cl.prototype.bytesPerElement = 8, Ft("StructArrayLayout2f8", cl);
        class yu extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E) {
            const B = this.length;
            return this.resize(B + 1), this.emplace(B, t, n, u, h, y, b, w, S, I, E);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, B) {
            const N = 10 * t;
            return this.uint16[N + 0] = n, this.uint16[N + 1] = u, this.uint16[N + 2] = h, this.uint16[N + 3] = y, this.uint16[N + 4] = b, this.uint16[N + 5] = w, this.uint16[N + 6] = S, this.uint16[N + 7] = I, this.uint16[N + 8] = E, this.uint16[N + 9] = B, t;
          }
        }
        yu.prototype.bytesPerElement = 20, Ft("StructArrayLayout10ui20", yu);
        class Oa extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, B, N) {
            const G = this.length;
            return this.resize(G + 1), this.emplace(G, t, n, u, h, y, b, w, S, I, E, B, N);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, B, N, G) {
            const q = 12 * t;
            return this.int16[q + 0] = n, this.int16[q + 1] = u, this.int16[q + 2] = h, this.int16[q + 3] = y, this.uint16[q + 4] = b, this.uint16[q + 5] = w, this.uint16[q + 6] = S, this.uint16[q + 7] = I, this.int16[q + 8] = E, this.int16[q + 9] = B, this.int16[q + 10] = N, this.int16[q + 11] = G, t;
          }
        }
        Oa.prototype.bytesPerElement = 24, Ft("StructArrayLayout4i4ui4i24", Oa);
        class Kc extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.float32[y + 0] = n, this.float32[y + 1] = u, this.float32[y + 2] = h, t;
          }
        }
        Kc.prototype.bytesPerElement = 12, Ft("StructArrayLayout3f12", Kc);
        class Jc extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        Jc.prototype.bytesPerElement = 4, Ft("StructArrayLayout1ul4", Jc);
        class bu extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, t, n, u, h, y, b, w, S, I);
          }
          emplace(t, n, u, h, y, b, w, S, I, E) {
            const B = 10 * t, N = 5 * t;
            return this.int16[B + 0] = n, this.int16[B + 1] = u, this.int16[B + 2] = h, this.int16[B + 3] = y, this.int16[B + 4] = b, this.int16[B + 5] = w, this.uint32[N + 3] = S, this.uint16[B + 8] = I, this.uint16[B + 9] = E, t;
          }
        }
        bu.prototype.bytesPerElement = 20, Ft("StructArrayLayout6i1ul2ui20", bu);
        class Qc extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = y, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        Qc.prototype.bytesPerElement = 12, Ft("StructArrayLayout2i2i2i12", Qc);
        class v extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, n, u, h, y);
          }
          emplace(t, n, u, h, y, b) {
            const w = 4 * t, S = 8 * t;
            return this.float32[w + 0] = n, this.float32[w + 1] = u, this.float32[w + 2] = h, this.int16[S + 6] = y, this.int16[S + 7] = b, t;
          }
        }
        v.prototype.bytesPerElement = 16, Ft("StructArrayLayout2f1f2i16", v);
        class e extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 16 * t, I = 4 * t, E = 8 * t;
            return this.uint8[S + 0] = n, this.uint8[S + 1] = u, this.float32[I + 1] = h, this.float32[I + 2] = y, this.int16[E + 6] = b, this.int16[E + 7] = w, t;
          }
        }
        e.prototype.bytesPerElement = 16, Ft("StructArrayLayout2ub2f2i16", e);
        class a extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.uint16[y + 0] = n, this.uint16[y + 1] = u, this.uint16[y + 2] = h, t;
          }
        }
        a.prototype.bytesPerElement = 6, Ft("StructArrayLayout3ui6", a);
        class c extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe) {
            const Be = this.length;
            return this.resize(Be + 1), this.emplace(Be, t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe, Be) {
            const Ce = 24 * t, Ie = 12 * t, He = 48 * t;
            return this.int16[Ce + 0] = n, this.int16[Ce + 1] = u, this.uint16[Ce + 2] = h, this.uint16[Ce + 3] = y, this.uint32[Ie + 2] = b, this.uint32[Ie + 3] = w, this.uint32[Ie + 4] = S, this.uint16[Ce + 10] = I, this.uint16[Ce + 11] = E, this.uint16[Ce + 12] = B, this.float32[Ie + 7] = N, this.float32[Ie + 8] = G, this.uint8[He + 36] = q, this.uint8[He + 37] = K, this.uint8[He + 38] = ae, this.uint32[Ie + 10] = pe, this.int16[Ce + 22] = Be, t;
          }
        }
        c.prototype.bytesPerElement = 48, Ft("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", c);
        class p extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe, Be, Ce, Ie, He, rt, _t, At, Pt, Et, Wt, Mt) {
            const Rt = this.length;
            return this.resize(Rt + 1), this.emplace(Rt, t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe, Be, Ce, Ie, He, rt, _t, At, Pt, Et, Wt, Mt);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe, Be, Ce, Ie, He, rt, _t, At, Pt, Et, Wt, Mt, Rt) {
            const ct = 32 * t, or = 16 * t;
            return this.int16[ct + 0] = n, this.int16[ct + 1] = u, this.int16[ct + 2] = h, this.int16[ct + 3] = y, this.int16[ct + 4] = b, this.int16[ct + 5] = w, this.int16[ct + 6] = S, this.int16[ct + 7] = I, this.uint16[ct + 8] = E, this.uint16[ct + 9] = B, this.uint16[ct + 10] = N, this.uint16[ct + 11] = G, this.uint16[ct + 12] = q, this.uint16[ct + 13] = K, this.uint16[ct + 14] = ae, this.uint16[ct + 15] = pe, this.uint16[ct + 16] = Be, this.uint16[ct + 17] = Ce, this.uint16[ct + 18] = Ie, this.uint16[ct + 19] = He, this.uint16[ct + 20] = rt, this.uint16[ct + 21] = _t, this.uint16[ct + 22] = At, this.uint32[or + 12] = Pt, this.float32[or + 13] = Et, this.float32[or + 14] = Wt, this.uint16[ct + 30] = Mt, this.uint16[ct + 31] = Rt, t;
          }
        }
        p.prototype.bytesPerElement = 64, Ft("StructArrayLayout8i15ui1ul2f2ui64", p);
        class _ extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        _.prototype.bytesPerElement = 4, Ft("StructArrayLayout1f4", _);
        class x extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[y + 1] = u, this.float32[y + 2] = h, t;
          }
        }
        x.prototype.bytesPerElement = 12, Ft("StructArrayLayout1ui2f12", x);
        class k extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[y + 2] = u, this.uint16[y + 3] = h, t;
          }
        }
        k.prototype.bytesPerElement = 8, Ft("StructArrayLayout1ul2ui8", k);
        class P extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.uint16[h + 0] = n, this.uint16[h + 1] = u, t;
          }
        }
        P.prototype.bytesPerElement = 4, Ft("StructArrayLayout2ui4", P);
        class R extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        R.prototype.bytesPerElement = 2, Ft("StructArrayLayout1ui2", R);
        class D extends Hr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, u, h);
          }
          emplace(t, n, u, h, y) {
            const b = 4 * t;
            return this.float32[b + 0] = n, this.float32[b + 1] = u, this.float32[b + 2] = h, this.float32[b + 3] = y, t;
          }
        }
        D.prototype.bytesPerElement = 16, Ft("StructArrayLayout4f16", D);
        class j extends ul {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new C(this.anchorPointX, this.anchorPointY);
          }
        }
        j.prototype.size = 20;
        class $ extends bu {
          get(t) {
            return new j(this, t);
          }
        }
        Ft("CollisionBoxArray", $);
        class V extends ul {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        V.prototype.size = 48;
        class W extends c {
          get(t) {
            return new V(this, t);
          }
        }
        Ft("PlacedSymbolArray", W);
        class le extends ul {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        le.prototype.size = 64;
        class se extends p {
          get(t) {
            return new le(this, t);
          }
        }
        Ft("SymbolInstanceArray", se);
        class ce extends _ {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Ft("GlyphOffsetArray", ce);
        class me extends fs {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Ft("SymbolLineVertexArray", me);
        class we extends ul {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        we.prototype.size = 12;
        class ye extends x {
          get(t) {
            return new we(this, t);
          }
        }
        Ft("TextAnchorOffsetArray", ye);
        class ke extends ul {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ke.prototype.size = 8;
        class Me extends k {
          get(t) {
            return new ke(this, t);
          }
        }
        Ft("FeatureIndexArray", Me);
        class be extends hs {
        }
        class Oe extends hs {
        }
        class Qe extends hs {
        }
        class We extends ps {
        }
        class Ze extends Ba {
        }
        class Je extends cl {
        }
        class kt extends yu {
        }
        class Tt extends Oa {
        }
        class pt extends Kc {
        }
        class Vt extends Jc {
        }
        class _r extends Qc {
        }
        class Or extends e {
        }
        class Xr extends a {
        }
        class Gr extends P {
        }
        const di = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: vi } = di;
        class vr {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t;
          }
          prepareSegment(t, n, u, h) {
            const y = this.segments[this.segments.length - 1];
            return t > vr.MAX_VERTEX_ARRAY_LENGTH && qt(`Max vertices per segment is ${vr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${vr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !y || y.vertexLength + t > vr.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== h ? this.createNewSegment(n, u, h) : y;
          }
          createNewSegment(t, n, u) {
            const h = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return u !== void 0 && (h.sortKey = u), this._forceNewSegmentOnNextPrepare = false, this.segments.push(h), h;
          }
          getOrCreateLatestSegment(t, n, u) {
            return this.prepareSegment(0, t, n, u);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, u, h) {
            return new vr([{ vertexOffset: t, primitiveOffset: n, vertexLength: u, primitiveLength: h, vaos: {}, sortKey: 0 }]);
          }
        }
        function Yr(o, t) {
          return 256 * (o = zt(Math.floor(o), 0, 255)) + zt(Math.floor(t), 0, 255);
        }
        vr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ft("SegmentVector", vr);
        const Ti = bi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var zi, Ni, vn, so = { exports: {} }, la = { exports: {} }, ua = { exports: {} }, ms = (function() {
          if (vn) return so.exports;
          vn = 1;
          var o = (zi || (zi = 1, la.exports = function(n, u) {
            var h, y, b, w, S, I, E, B;
            for (y = n.length - (h = 3 & n.length), b = u, S = 3432918353, I = 461845907, B = 0; B < y; ) E = 255 & n.charCodeAt(B) | (255 & n.charCodeAt(++B)) << 8 | (255 & n.charCodeAt(++B)) << 16 | (255 & n.charCodeAt(++B)) << 24, ++B, b = 27492 + (65535 & (w = 5 * (65535 & (b = (b ^= E = (65535 & (E = (E = (65535 & E) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295) << 13 | b >>> 19)) + ((5 * (b >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (w >>> 16) & 65535) << 16);
            switch (E = 0, h) {
              case 3:
                E ^= (255 & n.charCodeAt(B + 2)) << 16;
              case 2:
                E ^= (255 & n.charCodeAt(B + 1)) << 8;
              case 1:
                b ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & n.charCodeAt(B))) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295;
            }
            return b ^= n.length, b = 2246822507 * (65535 & (b ^= b >>> 16)) + ((2246822507 * (b >>> 16) & 65535) << 16) & 4294967295, b = 3266489909 * (65535 & (b ^= b >>> 13)) + ((3266489909 * (b >>> 16) & 65535) << 16) & 4294967295, (b ^= b >>> 16) >>> 0;
          }), la.exports), t = (Ni || (Ni = 1, ua.exports = function(n, u) {
            for (var h, y = n.length, b = u ^ y, w = 0; y >= 4; ) h = 1540483477 * (65535 & (h = 255 & n.charCodeAt(w) | (255 & n.charCodeAt(++w)) << 8 | (255 & n.charCodeAt(++w)) << 16 | (255 & n.charCodeAt(++w)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), y -= 4, ++w;
            switch (y) {
              case 3:
                b ^= (255 & n.charCodeAt(w + 2)) << 16;
              case 2:
                b ^= (255 & n.charCodeAt(w + 1)) << 8;
              case 1:
                b = 1540483477 * (65535 & (b ^= 255 & n.charCodeAt(w))) + ((1540483477 * (b >>> 16) & 65535) << 16);
            }
            return b = 1540483477 * (65535 & (b ^= b >>> 13)) + ((1540483477 * (b >>> 16) & 65535) << 16), (b ^= b >>> 15) >>> 0;
          }), ua.exports);
          return so.exports = o, so.exports.murmur3 = o, so.exports.murmur2 = t, so.exports;
        })(), gs = T(ms);
        class $a {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t, n, u, h) {
            this.ids.push(ja(t)), this.positions.push(n, u, h);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = ja(t);
            let u = 0, h = this.ids.length - 1;
            for (; u < h; ) {
              const b = u + h >> 1;
              this.ids[b] >= n ? h = b : u = b + 1;
            }
            const y = [];
            for (; this.ids[u] === n; ) y.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
            return y;
          }
          static serialize(t, n) {
            const u = new Float64Array(t.ids), h = new Uint32Array(t.positions);
            return Tn(u, h, 0, u.length - 1), n && n.push(u.buffer, h.buffer), { ids: u, positions: h };
          }
          static deserialize(t) {
            const n = new $a();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = true, n;
          }
        }
        function ja(o) {
          const t = +o;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : gs(String(o));
        }
        function Tn(o, t, n, u) {
          for (; n < u; ) {
            const h = o[n + u >> 1];
            let y = n - 1, b = u + 1;
            for (; ; ) {
              do
                y++;
              while (o[y] < h);
              do
                b--;
              while (o[b] > h);
              if (y >= b) break;
              lo(o, y, b), lo(t, 3 * y, 3 * b), lo(t, 3 * y + 1, 3 * b + 1), lo(t, 3 * y + 2, 3 * b + 2);
            }
            b - n < u - b ? (Tn(o, t, n, b), n = b + 1) : (Tn(o, t, b + 1, u), u = b);
          }
        }
        function lo(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        Ft("FeaturePositionMap", $a);
        class _n {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class ca extends _n {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Ii extends _n {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class Fi extends _n {
          constructor(t, n) {
            super(t, n), this.current = xr.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Zn = new Float32Array(16);
        function Mi(o) {
          return [Yr(255 * o.r, 255 * o.g), Yr(255 * o.b, 255 * o.a)];
        }
        class dl {
          constructor(t, n, u) {
            this.value = t, this.uniformNames = n.map(((h) => `u_${h}`)), this.type = u;
          }
          setUniform(t, n, u) {
            t.set(u.constantOr(this.value));
          }
          getBinding(t, n, u) {
            return this.type === "color" ? new Fi(t, n) : new ca(t, n);
          }
        }
        class vs {
          constructor(t, n) {
            this.uniformNames = n.map(((u) => `u_${u}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, n, u, h) {
            const y = h === "u_pattern_to" ? this.patternTo : h === "u_pattern_from" ? this.patternFrom : h === "u_pixel_ratio_to" ? this.pixelRatioTo : h === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            y && t.set(y);
          }
          getBinding(t, n, u) {
            return u.substr(0, 9) === "u_pattern" ? new Ii(t, n) : new ca(t, n);
          }
        }
        class No {
          constructor(t, n, u, h) {
            this.expression = t, this.type = u, this.maxValue = 0, this.paintVertexAttributes = n.map(((y) => ({ name: `a_${y}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new h();
          }
          populatePaintArray(t, n, u) {
            const h = this.paintVertexArray.length, y = this.expression.evaluate(new ri(0, u), n, {}, u.canonical, [], u.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(h, t, y);
          }
          updatePaintArray(t, n, u, h, y) {
            const b = this.expression.evaluate(new ri(0, y), u, h);
            this._setPaintValue(t, n, b);
          }
          _setPaintValue(t, n, u) {
            if (this.type === "color") {
              const h = Mi(u);
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, h[0], h[1]);
            } else {
              for (let h = t; h < n; h++) this.paintVertexArray.emplace(h, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(u));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class uo {
          constructor(t, n, u, h, y, b) {
            this.expression = t, this.uniformNames = n.map(((w) => `u_${w}_t`)), this.type = u, this.useIntegerZoom = h, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = n.map(((w) => ({ name: `a_${w}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new b();
          }
          populatePaintArray(t, n, u) {
            const h = this.expression.evaluate(new ri(this.zoom, u), n, {}, u.canonical, [], u.formattedSection), y = this.expression.evaluate(new ri(this.zoom + 1, u), n, {}, u.canonical, [], u.formattedSection), b = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(b, t, h, y);
          }
          updatePaintArray(t, n, u, h, y) {
            const b = this.expression.evaluate(new ri(this.zoom, y), u, h), w = this.expression.evaluate(new ri(this.zoom + 1, y), u, h);
            this._setPaintValue(t, n, b, w);
          }
          _setPaintValue(t, n, u, h) {
            if (this.type === "color") {
              const y = Mi(u), b = Mi(h);
              for (let w = t; w < n; w++) this.paintVertexArray.emplace(w, y[0], y[1], b[0], b[1]);
            } else {
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, u, h);
              this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(h));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const u = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, h = zt(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
            t.set(h);
          }
          getBinding(t, n, u) {
            return new ca(t, n);
          }
        }
        class da {
          constructor(t, n, u, h, y, b) {
            this.expression = t, this.type = n, this.useIntegerZoom = u, this.zoom = h, this.layerId = b, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
          }
          populatePaintArray(t, n, u) {
            const h = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(h, t, n.patterns && n.patterns[this.layerId], u.imagePositions);
          }
          updatePaintArray(t, n, u, h, y) {
            this._setPaintValues(t, n, u.patterns && u.patterns[this.layerId], y.imagePositions);
          }
          _setPaintValues(t, n, u, h) {
            if (!h || !u) return;
            const { min: y, mid: b, max: w } = u, S = h[y], I = h[b], E = h[w];
            if (S && I && E) for (let B = t; B < n; B++) this.zoomInPaintVertexArray.emplace(B, I.tl[0], I.tl[1], I.br[0], I.br[1], S.tl[0], S.tl[1], S.br[0], S.br[1], I.pixelRatio, S.pixelRatio), this.zoomOutPaintVertexArray.emplace(B, I.tl[0], I.tl[1], I.br[0], I.br[1], E.tl[0], E.tl[1], E.br[0], E.br[1], I.pixelRatio, E.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Ti.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Ti.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Zh {
          constructor(t, n, u) {
            this.binders = {}, this._buffers = [];
            const h = [];
            for (const y in t.paint._values) {
              if (!u(y)) continue;
              const b = t.paint.get(y);
              if (!(b instanceof Io && oa(b.property.specification))) continue;
              const w = Hh(y, t.type), S = b.value, I = b.property.specification.type, E = b.property.useIntegerZoom, B = b.property.specification["property-type"], N = B === "cross-faded" || B === "cross-faded-data-driven";
              if (S.kind === "constant") this.binders[y] = N ? new vs(S.value, w) : new dl(S.value, w, I), h.push(`/u_${y}`);
              else if (S.kind === "source" || N) {
                const G = ed(y, I, "source");
                this.binders[y] = N ? new da(S, I, E, n, G, t.id) : new No(S, w, I, G), h.push(`/a_${y}`);
              } else {
                const G = ed(y, I, "composite");
                this.binders[y] = new uo(S, w, I, E, n, G), h.push(`/z_${y}`);
              }
            }
            this.cacheKey = h.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof No || n instanceof uo ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, u) {
            for (const h in this.binders) {
              const y = this.binders[h];
              (y instanceof No || y instanceof uo || y instanceof da) && y.populatePaintArray(t, n, u);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof vs && h.setConstantPatternPositions(t, n);
            }
          }
          updatePaintArrays(t, n, u, h, y) {
            let b = false;
            for (const w in t) {
              const S = n.getPositions(w);
              for (const I of S) {
                const E = u.feature(I.index);
                for (const B in this.binders) {
                  const N = this.binders[B];
                  if ((N instanceof No || N instanceof uo || N instanceof da) && N.expression.isStateDependent === true) {
                    const G = h.paint.get(B);
                    N.expression = G.value, N.updatePaintArray(I.start, I.end, E, t[w], y), b = true;
                  }
                }
              }
            }
            return b;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof dl || u instanceof vs) && t.push(...u.uniformNames.map(((h) => `#define HAS_UNIFORM_${h}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof No || u instanceof uo) for (let h = 0; h < u.paintVertexAttributes.length; h++) t.push(u.paintVertexAttributes[h].name);
              else if (u instanceof da) for (let h = 0; h < Ti.members.length; h++) t.push(Ti.members[h].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof dl || u instanceof vs || u instanceof uo) for (const h of u.uniformNames) t.push(h);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const u = [];
            for (const h in this.binders) {
              const y = this.binders[h];
              if (y instanceof dl || y instanceof vs || y instanceof uo) {
                for (const b of y.uniformNames) if (n[b]) {
                  const w = y.getBinding(t, n[b], b);
                  u.push({ name: b, property: h, binding: w });
                }
              }
            }
            return u;
          }
          setUniforms(t, n, u, h) {
            for (const { name: y, property: b, binding: w } of n) this.binders[b].setUniform(w, h, u.get(b), y);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (t && u instanceof da) {
                const h = t.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
                h && this._buffers.push(h);
              } else (u instanceof No || u instanceof uo) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof No || u instanceof uo || u instanceof da) && u.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof No || n instanceof uo || n instanceof da) && n.destroy();
            }
          }
        }
        class Ln {
          constructor(t, n, u = () => true) {
            this.programConfigurations = {};
            for (const h of t) this.programConfigurations[h.id] = new Zh(h, n, u);
            this.needsUpload = false, this._featureMap = new $a(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, u, h) {
            for (const y in this.programConfigurations) this.programConfigurations[y].populatePaintArrays(t, n, h);
            n.id !== void 0 && this._featureMap.add(n.id, u, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = true;
          }
          updatePaintArrays(t, n, u, h) {
            for (const y of u) this.needsUpload = this.programConfigurations[y.id].updatePaintArrays(t, this._featureMap, n, y, h) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Hh(o, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[o] || [o.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function ed(o, t, n) {
          const u = { color: { source: cl, composite: D }, number: { source: _, composite: cl } }, h = (function(y) {
            return { "line-pattern": { source: kt, composite: kt }, "fill-pattern": { source: kt, composite: kt }, "fill-extrusion-pattern": { source: kt, composite: kt } }[y];
          })(o);
          return h && h[n] || u[t][n];
        }
        Ft("ConstantBinder", dl), Ft("CrossFadedConstantBinder", vs), Ft("SourceExpressionBinder", No), Ft("CrossFadedCompositeBinder", da), Ft("CompositeExpressionBinder", uo), Ft("ProgramConfiguration", Zh, { omit: ["_buffers"] }), Ft("ProgramConfigurationSet", Ln);
        const xu = Math.pow(2, 14) - 1, wu = -xu - 1;
        function ha(o) {
          const t = et / o.extent, n = o.loadGeometry();
          for (let u = 0; u < n.length; u++) {
            const h = n[u];
            for (let y = 0; y < h.length; y++) {
              const b = h[y], w = Math.round(b.x * t), S = Math.round(b.y * t);
              b.x = zt(w, wu, xu), b.y = zt(S, wu, xu), (w < b.x || w > b.x + 1 || S < b.y || S > b.y + 1) && qt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function Vo(o, t) {
          return { type: o.type, id: o.id, properties: o.properties, geometry: t ? ha(o) : [] };
        }
        const s0 = -32768;
        function V1(o, t, n, u, h) {
          o.emplaceBack(s0 + 8 * t + u, s0 + 8 * n + h);
        }
        class jp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new Oe(), this.indexArray = new Xr(), this.segments = new vr(), this.programConfigurations = new Ln(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            const h = this.layers[0], y = [];
            let b = null, w = false, S = h.type === "heatmap";
            if (h.type === "circle") {
              const E = h;
              b = E.layout.get("circle-sort-key"), w = !b.isConstant(), S = S || E.paint.get("circle-pitch-alignment") === "map";
            }
            const I = S ? n.subdivisionGranularity.circle : 1;
            for (const { feature: E, id: B, index: N, sourceLayerIndex: G } of t) {
              const q = this.layers[0]._featureFilter.needGeometry, K = Vo(E, q);
              if (!this.layers[0]._featureFilter.filter(new ri(this.zoom, { globalState: this.globalState }), K, u)) continue;
              const ae = w ? b.evaluate(K, {}, u) : void 0, pe = { id: B, properties: E.properties, type: E.type, sourceLayerIndex: G, index: N, geometry: q ? K.geometry : ha(E), patterns: {}, sortKey: ae };
              y.push(pe);
            }
            w && y.sort(((E, B) => E.sortKey - B.sortKey));
            for (const E of y) {
              const { geometry: B, index: N, sourceLayerIndex: G } = E, q = t[N].feature;
              this.addFeature(E, B, N, u, I), n.featureIndex.insert(q, B, N, G, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, vi), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, u, h, y = 1) {
            let b;
            switch (y) {
              case 1:
                b = [0, 7];
                break;
              case 3:
                b = [0, 2, 5, 7];
                break;
              case 5:
                b = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                b = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${y}; valid values are 1, 3, 5, 7.`);
            }
            const w = b.length;
            for (const S of n) for (const I of S) {
              const E = I.x, B = I.y;
              if (E < 0 || E >= et || B < 0 || B >= et) continue;
              const N = this.segments.prepareSegment(w * w, this.layoutVertexArray, this.indexArray, t.sortKey), G = N.vertexLength;
              for (let q = 0; q < w; q++) for (let K = 0; K < w; K++) V1(this.layoutVertexArray, E, B, b[K], b[q]);
              for (let q = 0; q < w - 1; q++) for (let K = 0; K < w - 1; K++) {
                const ae = G + q * w + K, pe = G + (q + 1) * w + K;
                this.indexArray.emplaceBack(ae, pe + 1, ae + 1), this.indexArray.emplaceBack(ae, pe, pe + 1);
              }
              N.vertexLength += w * w, N.primitiveLength += (w - 1) * (w - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: {}, canonical: h, globalState: this.globalState });
          }
        }
        function l0(o, t) {
          for (let n = 0; n < o.length; n++) if (Cu(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (Cu(o, t[n])) return true;
          return !!Np(o, t);
        }
        function U1(o, t, n) {
          return !!Cu(o, t) || !!Vp(t, o, n);
        }
        function u0(o, t) {
          if (o.length === 1) return d0(t, o[0]);
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            for (let h = 0; h < u.length; h++) if (Cu(o, u[h])) return true;
          }
          for (let n = 0; n < o.length; n++) if (d0(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (Np(o, t[n])) return true;
          return false;
        }
        function G1(o, t, n) {
          if (o.length > 1) {
            if (Np(o, t)) return true;
            for (let u = 0; u < t.length; u++) if (Vp(t[u], o, n)) return true;
          }
          for (let u = 0; u < o.length; u++) if (Vp(o[u], t, n)) return true;
          return false;
        }
        function Np(o, t) {
          if (o.length === 0 || t.length === 0) return false;
          for (let n = 0; n < o.length - 1; n++) {
            const u = o[n], h = o[n + 1];
            for (let y = 0; y < t.length - 1; y++) if (q1(u, h, t[y], t[y + 1])) return true;
          }
          return false;
        }
        function q1(o, t, n, u) {
          return Dr(o, n, u) !== Dr(t, n, u) && Dr(o, t, n) !== Dr(o, t, u);
        }
        function Vp(o, t, n) {
          const u = n * n;
          if (t.length === 1) return o.distSqr(t[0]) < u;
          for (let h = 1; h < t.length; h++) if (c0(o, t[h - 1], t[h]) < u) return true;
          return false;
        }
        function c0(o, t, n) {
          const u = t.distSqr(n);
          if (u === 0) return o.distSqr(t);
          const h = ((o.x - t.x) * (n.x - t.x) + (o.y - t.y) * (n.y - t.y)) / u;
          return o.distSqr(h < 0 ? t : h > 1 ? n : n.sub(t)._mult(h)._add(t));
        }
        function d0(o, t) {
          let n, u, h, y = false;
          for (let b = 0; b < o.length; b++) {
            n = o[b];
            for (let w = 0, S = n.length - 1; w < n.length; S = w++) u = n[w], h = n[S], u.y > t.y != h.y > t.y && t.x < (h.x - u.x) * (t.y - u.y) / (h.y - u.y) + u.x && (y = !y);
          }
          return y;
        }
        function Cu(o, t) {
          let n = false;
          for (let u = 0, h = o.length - 1; u < o.length; h = u++) {
            const y = o[u], b = o[h];
            y.y > t.y != b.y > t.y && t.x < (b.x - y.x) * (t.y - y.y) / (b.y - y.y) + y.x && (n = !n);
          }
          return n;
        }
        function W1(o, t, n) {
          const u = n[0], h = n[2];
          if (o.x < u.x && t.x < u.x || o.x > h.x && t.x > h.x || o.y < u.y && t.y < u.y || o.y > h.y && t.y > h.y) return false;
          const y = Dr(o, t, n[0]);
          return y !== Dr(o, t, n[1]) || y !== Dr(o, t, n[2]) || y !== Dr(o, t, n[3]);
        }
        function td(o, t, n) {
          const u = t.paint.get(o).value;
          return u.kind === "constant" ? u.value : n.programConfigurations.get(t.id).getMaxValue(o);
        }
        function Xh(o) {
          return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
        }
        function Yh(o, t, n, u, h) {
          if (!t[0] && !t[1]) return o;
          const y = C.convert(t)._mult(h);
          n === "viewport" && y._rotate(-u);
          const b = [];
          for (let w = 0; w < o.length; w++) b.push(o[w].sub(y));
          return b;
        }
        let h0, f0;
        Ft("CircleBucket", jp, { omit: ["layers"] });
        var Z1 = { get paint() {
          return f0 = f0 || new gn({ "circle-radius": new er(Pe.paint_circle["circle-radius"]), "circle-color": new er(Pe.paint_circle["circle-color"]), "circle-blur": new er(Pe.paint_circle["circle-blur"]), "circle-opacity": new er(Pe.paint_circle["circle-opacity"]), "circle-translate": new Gt(Pe.paint_circle["circle-translate"]), "circle-translate-anchor": new Gt(Pe.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Gt(Pe.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Gt(Pe.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new er(Pe.paint_circle["circle-stroke-width"]), "circle-stroke-color": new er(Pe.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new er(Pe.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return h0 = h0 || new gn({ "circle-sort-key": new er(Pe.layout_circle["circle-sort-key"]) });
        } };
        class H1 extends Wn {
          constructor(t) {
            super(t, Z1);
          }
          createBucket(t) {
            return new jp(t);
          }
          queryRadius(t) {
            const n = t;
            return td("circle-radius", this, n) + td("circle-stroke-width", this, n) + Xh(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            const I = Yh(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -y.bearingInRadians, b), E = this.paint.get("circle-radius").evaluate(n, u) + this.paint.get("circle-stroke-width").evaluate(n, u), B = this.paint.get("circle-pitch-alignment") === "map", N = B ? I : (function(q, K, ae, pe) {
              return q.map(((Be) => p0(Be, K, ae, pe)));
            })(I, y, w, S), G = B ? E * b : E;
            for (const q of h) for (const K of q) {
              const ae = B ? K : p0(K, y, w, S);
              let pe = G;
              const Be = y.projectTileCoordinates(K.x, K.y, w, S).signedDistanceFromCamera;
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? pe *= Be / y.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (pe *= y.cameraToCenterDistance / Be), U1(N, ae, pe)) return true;
            }
            return false;
          }
        }
        function p0(o, t, n, u) {
          const h = t.projectTileCoordinates(o.x, o.y, n, u).point;
          return new C((0.5 * h.x + 0.5) * t.width, (0.5 * -h.y + 0.5) * t.height);
        }
        class m0 extends jp {
        }
        let g0;
        Ft("HeatmapBucket", m0, { omit: ["layers"] });
        var X1 = { get paint() {
          return g0 = g0 || new gn({ "heatmap-radius": new er(Pe.paint_heatmap["heatmap-radius"]), "heatmap-weight": new er(Pe.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Gt(Pe.paint_heatmap["heatmap-intensity"]), "heatmap-color": new vu(Pe.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Gt(Pe.paint_heatmap["heatmap-opacity"]) });
        } };
        function Up(o, { width: t, height: n }, u, h) {
          if (h) {
            if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
            else if (h.length !== t * n * u) throw new RangeError(`mismatched image size. expected: ${h.length} but got: ${t * n * u}`);
          } else h = new Uint8Array(t * n * u);
          return o.width = t, o.height = n, o.data = h, o;
        }
        function v0(o, { width: t, height: n }, u) {
          if (t === o.width && n === o.height) return;
          const h = Up({}, { width: t, height: n }, u);
          Gp(o, h, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(o.width, t), height: Math.min(o.height, n) }, u), o.width = t, o.height = n, o.data = h.data;
        }
        function Gp(o, t, n, u, h, y) {
          if (h.width === 0 || h.height === 0) return t;
          if (h.width > o.width || h.height > o.height || n.x > o.width - h.width || n.y > o.height - h.height) throw new RangeError("out of range source coordinates for image copy");
          if (h.width > t.width || h.height > t.height || u.x > t.width - h.width || u.y > t.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
          const b = o.data, w = t.data;
          if (b === w) throw new Error("srcData equals dstData, so image is already copied");
          for (let S = 0; S < h.height; S++) {
            const I = ((n.y + S) * o.width + n.x) * y, E = ((u.y + S) * t.width + u.x) * y;
            for (let B = 0; B < h.width * y; B++) w[E + B] = b[I + B];
          }
          return t;
        }
        class rd {
          constructor(t, n) {
            Up(this, t, 1, n);
          }
          resize(t) {
            v0(this, t, 1);
          }
          clone() {
            return new rd({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, y) {
            Gp(t, n, u, h, y, 1);
          }
        }
        class Bn {
          constructor(t, n) {
            Up(this, t, 4, n);
          }
          resize(t) {
            v0(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Bn({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, y) {
            Gp(t, n, u, h, y, 4);
          }
          setPixel(t, n, u) {
            const h = 4 * (t * this.width + n);
            this.data[h + 0] = Math.round(255 * u.r / u.a), this.data[h + 1] = Math.round(255 * u.g / u.a), this.data[h + 2] = Math.round(255 * u.b / u.a), this.data[h + 3] = Math.round(255 * u.a);
          }
        }
        function _0(o) {
          const t = {}, n = o.resolution || 256, u = o.clips ? o.clips.length : 1, h = o.image || new Bn({ width: n, height: u });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const y = (b, w, S) => {
            t[o.evaluationKey] = S;
            const I = o.expression.evaluate(t);
            h.setPixel(b / 4 / n, w / 4, I);
          };
          if (o.clips) for (let b = 0, w = 0; b < u; ++b, w += 4 * n) for (let S = 0, I = 0; S < n; S++, I += 4) {
            const E = S / (n - 1), { start: B, end: N } = o.clips[b];
            y(w, I, B * (1 - E) + N * E);
          }
          else for (let b = 0, w = 0; b < n; b++, w += 4) y(0, w, b / (n - 1));
          return h;
        }
        Ft("AlphaImage", rd), Ft("RGBAImage", Bn);
        const qp = "big-fb";
        class Y1 extends Wn {
          createBucket(t) {
            return new m0(t);
          }
          constructor(t) {
            super(t, X1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = _0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(qp) && this.heatmapFbos.delete(qp);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let y0;
        var K1 = { get paint() {
          return y0 = y0 || new gn({ "hillshade-illumination-direction": new Gt(Pe.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Gt(Pe.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Gt(Pe.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Gt(Pe.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Gt(Pe.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Gt(Pe.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Gt(Pe.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Gt(Pe.paint_hillshade["hillshade-method"]) });
        } };
        class J1 extends Wn {
          constructor(t) {
            super(t, K1), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, n = this.paint.get("hillshade-illumination-altitude").values, u = this.paint.get("hillshade-highlight-color").values, h = this.paint.get("hillshade-shadow-color").values;
            const y = Math.max(t.length, n.length, u.length, h.length);
            t = t.concat(Array(y - t.length).fill(t.at(-1))), n = n.concat(Array(y - n.length).fill(n.at(-1))), u = u.concat(Array(y - u.length).fill(u.at(-1))), h = h.concat(Array(y - h.length).fill(h.at(-1)));
            const b = n.map(tt);
            return { directionRadians: t.map(tt), altitudeRadians: b, shadowColor: h, highlightColor: u };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let b0;
        var Q1 = { get paint() {
          return b0 = b0 || new gn({ "color-relief-opacity": new Gt(Pe["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new vu(Pe["paint_color-relief"]["color-relief-color"]) });
        } };
        class Wp {
          constructor(t, n, u, h) {
            this.context = t, this.format = u, this.texture = t.gl.createTexture(), this.update(n, h);
          }
          update(t, n, u) {
            const { width: h, height: y } = t, b = !(this.size && this.size[0] === h && this.size[1] === y || u), { context: w } = this, { gl: S } = w;
            if (this.useMipmap = !!(n && n.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), w.pixelStoreUnpackFlipY.set(false), w.pixelStoreUnpack.set(1), w.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!n || n.premultiply !== false)), b) this.size = [h, y], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, t) : S.texImage2D(S.TEXTURE_2D, 0, this.format, h, y, 0, this.format, S.UNSIGNED_BYTE, t.data);
            else {
              const { x: I, y: E } = u || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texSubImage2D(S.TEXTURE_2D, 0, I, E, S.RGBA, S.UNSIGNED_BYTE, t) : S.texSubImage2D(S.TEXTURE_2D, 0, I, E, h, y, S.RGBA, S.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D), w.pixelStoreUnpackFlipY.setDefault(), w.pixelStoreUnpack.setDefault(), w.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, n, u) {
            const { context: h } = this, { gl: y } = h;
            y.bindTexture(y.TEXTURE_2D, this.texture), u !== y.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = y.LINEAR), t !== this.filter && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, t), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, u || t), this.filter = t), n !== this.wrap && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, n), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, n), this.wrap = n);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class x0 {
          constructor(t, n, u, h = 1, y = 1, b = 1, w = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void qt(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const S = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), u) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = h, this.greenFactor = y, this.blueFactor = b, this.baseShift = w;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let I = 0; I < S; I++) this.data[this._idx(-1, I)] = this.data[this._idx(0, I)], this.data[this._idx(S, I)] = this.data[this._idx(S - 1, I)], this.data[this._idx(I, -1)] = this.data[this._idx(I, 0)], this.data[this._idx(I, S)] = this.data[this._idx(I, S - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(S, -1)] = this.data[this._idx(S - 1, 0)], this.data[this._idx(-1, S)] = this.data[this._idx(0, S - 1)], this.data[this._idx(S, S)] = this.data[this._idx(S - 1, S - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let I = 0; I < S; I++) for (let E = 0; E < S; E++) {
              const B = this.get(I, E);
              B > this.max && (this.max = B), B < this.min && (this.min = B);
            }
          }
          get(t, n) {
            const u = new Uint8Array(this.data.buffer), h = 4 * this._idx(t, n);
            return this.unpack(u[h], u[h + 1], u[h + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, u) {
            return t * this.redFactor + n * this.greenFactor + u * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return w0(t, this.getUnpackVector());
          }
          getPixels() {
            return new Bn({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, u) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let h = n * this.dim, y = n * this.dim + this.dim, b = u * this.dim, w = u * this.dim + this.dim;
            switch (n) {
              case -1:
                h = y - 1;
                break;
              case 1:
                y = h + 1;
            }
            switch (u) {
              case -1:
                b = w - 1;
                break;
              case 1:
                w = b + 1;
            }
            const S = -n * this.dim, I = -u * this.dim;
            for (let E = b; E < w; E++) for (let B = h; B < y; B++) this.data[this._idx(B, E)] = t.data[this._idx(B + S, E + I)];
          }
        }
        function w0(o, t) {
          const n = t[0], u = t[1], h = t[2], y = t[3], b = Math.min(n, u, h), w = Math.round((o + y) / b);
          return { r: Math.floor(w * b / n) % 256, g: Math.floor(w * b / u) % 256, b: Math.floor(w * b / h) % 256 };
        }
        Ft("DEMData", x0);
        class ex extends Wn {
          constructor(t) {
            super(t, Q1);
          }
          _createColorRamp(t) {
            const n = { elevationStops: [], colorStops: [] }, u = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (u instanceof tl && u._styleExpression.expression instanceof Hi) {
              this.colorRampExpression = u;
              const b = u._styleExpression.expression;
              n.elevationStops = b.labels, n.colorStops = [];
              for (const w of n.elevationStops) n.colorStops.push(b.evaluate({ globals: { elevation: w } }));
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [xr.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const h = { elevationStops: [], colorStops: [] }, y = (n.elevationStops.length - 1) / (t - 1);
            for (let b = 0; b < n.elevationStops.length - 0.5; b += y) h.elevationStops.push(n.elevationStops[Math.round(b)]), h.colorStops.push(n.colorStops[Math.round(b)]);
            return qt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), h;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, n, u) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const h = this._createColorRamp(n), y = new Bn({ width: h.colorStops.length, height: 1 }), b = new Bn({ width: h.colorStops.length, height: 1 });
            for (let w = 0; w < h.elevationStops.length; w++) {
              const S = w0(h.elevationStops[w], u);
              b.setPixel(0, w, new xr(S.r / 255, S.g / 255, S.b / 255, 1)), y.setPixel(0, w, h.colorStops[w]);
            }
            return this.colorRampTextures = { elevationTexture: new Wp(t, b, t.gl.RGBA), colorTexture: new Wp(t, y, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const tx = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: rx } = tx;
        function Zp(o, t, n) {
          const u = n.patternDependencies;
          let h = false;
          for (const y of t) {
            const b = y.paint.get(`${o}-pattern`);
            b.isConstant() || (h = true);
            const w = b.constantOr(null);
            w && (h = true, u[w.to] = true, u[w.from] = true);
          }
          return h;
        }
        function Hp(o, t, n, u, h) {
          const { zoom: y, globalState: b } = u, w = h.patternDependencies;
          for (const S of t) {
            const I = S.paint.get(`${o}-pattern`).value;
            if (I.kind !== "constant") {
              let E = I.evaluate({ zoom: y - 1, globalState: b }, n, {}, h.availableImages), B = I.evaluate({ zoom: y, globalState: b }, n, {}, h.availableImages), N = I.evaluate({ zoom: y + 1, globalState: b }, n, {}, h.availableImages);
              E = E && E.name ? E.name : E, B = B && B.name ? B.name : B, N = N && N.name ? N.name : N, w[E] = true, w[B] = true, w[N] = true, n.patterns[S.id] = { min: E, mid: B, max: N };
            }
          }
          return n;
        }
        function C0(o, t, n, u, h) {
          let y;
          if (h === (function(b, w, S, I) {
            let E = 0;
            for (let B = w, N = S - I; B < S; B += I) E += (b[N] - b[B]) * (b[B + 1] + b[N + 1]), N = B;
            return E;
          })(o, t, n, u) > 0) for (let b = t; b < n; b += u) y = T0(b / u | 0, o[b], o[b + 1], y);
          else for (let b = n - u; b >= t; b -= u) y = T0(b / u | 0, o[b], o[b + 1], y);
          return y && Su(y, y.next) && (ad(y), y = y.next), y;
        }
        function hl(o, t) {
          if (!o) return o;
          t || (t = o);
          let n, u = o;
          do
            if (n = false, u.steiner || !Su(u, u.next) && Ci(u.prev, u, u.next) !== 0) u = u.next;
            else {
              if (ad(u), u = t = u.prev, u === u.next) break;
              n = true;
            }
          while (n || u !== t);
          return t;
        }
        function id(o, t, n, u, h, y, b) {
          if (!o) return;
          !b && y && (function(S, I, E, B) {
            let N = S;
            do
              N.z === 0 && (N.z = Xp(N.x, N.y, I, E, B)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next;
            while (N !== S);
            N.prevZ.nextZ = null, N.prevZ = null, (function(G) {
              let q, K = 1;
              do {
                let ae, pe = G;
                G = null;
                let Be = null;
                for (q = 0; pe; ) {
                  q++;
                  let Ce = pe, Ie = 0;
                  for (let rt = 0; rt < K && (Ie++, Ce = Ce.nextZ, Ce); rt++) ;
                  let He = K;
                  for (; Ie > 0 || He > 0 && Ce; ) Ie !== 0 && (He === 0 || !Ce || pe.z <= Ce.z) ? (ae = pe, pe = pe.nextZ, Ie--) : (ae = Ce, Ce = Ce.nextZ, He--), Be ? Be.nextZ = ae : G = ae, ae.prevZ = Be, Be = ae;
                  pe = Ce;
                }
                Be.nextZ = null, K *= 2;
              } while (q > 1);
            })(N);
          })(o, u, h, y);
          let w = o;
          for (; o.prev !== o.next; ) {
            const S = o.prev, I = o.next;
            if (y ? nx(o, u, h, y) : ix(o)) t.push(S.i, o.i, I.i), ad(o), o = I.next, w = I.next;
            else if ((o = I) === w) {
              b ? b === 1 ? id(o = ox(hl(o), t), t, n, u, h, y, 2) : b === 2 && ax(o, t, n, u, h, y) : id(hl(o), t, n, u, h, y, 1);
              break;
            }
          }
        }
        function ix(o) {
          const t = o.prev, n = o, u = o.next;
          if (Ci(t, n, u) >= 0) return false;
          const h = t.x, y = n.x, b = u.x, w = t.y, S = n.y, I = u.y, E = Math.min(h, y, b), B = Math.min(w, S, I), N = Math.max(h, y, b), G = Math.max(w, S, I);
          let q = u.next;
          for (; q !== t; ) {
            if (q.x >= E && q.x <= N && q.y >= B && q.y <= G && nd(h, w, y, S, b, I, q.x, q.y) && Ci(q.prev, q, q.next) >= 0) return false;
            q = q.next;
          }
          return true;
        }
        function nx(o, t, n, u) {
          const h = o.prev, y = o, b = o.next;
          if (Ci(h, y, b) >= 0) return false;
          const w = h.x, S = y.x, I = b.x, E = h.y, B = y.y, N = b.y, G = Math.min(w, S, I), q = Math.min(E, B, N), K = Math.max(w, S, I), ae = Math.max(E, B, N), pe = Xp(G, q, t, n, u), Be = Xp(K, ae, t, n, u);
          let Ce = o.prevZ, Ie = o.nextZ;
          for (; Ce && Ce.z >= pe && Ie && Ie.z <= Be; ) {
            if (Ce.x >= G && Ce.x <= K && Ce.y >= q && Ce.y <= ae && Ce !== h && Ce !== b && nd(w, E, S, B, I, N, Ce.x, Ce.y) && Ci(Ce.prev, Ce, Ce.next) >= 0 || (Ce = Ce.prevZ, Ie.x >= G && Ie.x <= K && Ie.y >= q && Ie.y <= ae && Ie !== h && Ie !== b && nd(w, E, S, B, I, N, Ie.x, Ie.y) && Ci(Ie.prev, Ie, Ie.next) >= 0)) return false;
            Ie = Ie.nextZ;
          }
          for (; Ce && Ce.z >= pe; ) {
            if (Ce.x >= G && Ce.x <= K && Ce.y >= q && Ce.y <= ae && Ce !== h && Ce !== b && nd(w, E, S, B, I, N, Ce.x, Ce.y) && Ci(Ce.prev, Ce, Ce.next) >= 0) return false;
            Ce = Ce.prevZ;
          }
          for (; Ie && Ie.z <= Be; ) {
            if (Ie.x >= G && Ie.x <= K && Ie.y >= q && Ie.y <= ae && Ie !== h && Ie !== b && nd(w, E, S, B, I, N, Ie.x, Ie.y) && Ci(Ie.prev, Ie, Ie.next) >= 0) return false;
            Ie = Ie.nextZ;
          }
          return true;
        }
        function ox(o, t) {
          let n = o;
          do {
            const u = n.prev, h = n.next.next;
            !Su(u, h) && k0(u, n, n.next, h) && od(u, h) && od(h, u) && (t.push(u.i, n.i, h.i), ad(n), ad(n.next), n = o = h), n = n.next;
          } while (n !== o);
          return hl(n);
        }
        function ax(o, t, n, u, h, y) {
          let b = o;
          do {
            let w = b.next.next;
            for (; w !== b.prev; ) {
              if (b.i !== w.i && dx(b, w)) {
                let S = P0(b, w);
                return b = hl(b, b.next), S = hl(S, S.next), id(b, t, n, u, h, y, 0), void id(S, t, n, u, h, y, 0);
              }
              w = w.next;
            }
            b = b.next;
          } while (b !== o);
        }
        function sx(o, t) {
          let n = o.x - t.x;
          return n === 0 && (n = o.y - t.y, n === 0) && (n = (o.next.y - o.y) / (o.next.x - o.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function lx(o, t) {
          const n = (function(h, y) {
            let b = y;
            const w = h.x, S = h.y;
            let I, E = -1 / 0;
            if (Su(h, b)) return b;
            do {
              if (Su(h, b.next)) return b.next;
              if (S <= b.y && S >= b.next.y && b.next.y !== b.y) {
                const K = b.x + (S - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
                if (K <= w && K > E && (E = K, I = b.x < b.next.x ? b : b.next, K === w)) return I;
              }
              b = b.next;
            } while (b !== y);
            if (!I) return null;
            const B = I, N = I.x, G = I.y;
            let q = 1 / 0;
            b = I;
            do {
              if (w >= b.x && b.x >= N && w !== b.x && S0(S < G ? w : E, S, N, G, S < G ? E : w, S, b.x, b.y)) {
                const K = Math.abs(S - b.y) / (w - b.x);
                od(b, h) && (K < q || K === q && (b.x > I.x || b.x === I.x && ux(I, b))) && (I = b, q = K);
              }
              b = b.next;
            } while (b !== B);
            return I;
          })(o, t);
          if (!n) return t;
          const u = P0(n, o);
          return hl(u, u.next), hl(n, n.next);
        }
        function ux(o, t) {
          return Ci(o.prev, o, t.prev) < 0 && Ci(t.next, o, o.next) < 0;
        }
        function Xp(o, t, n, u, h) {
          return (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - n) * h | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - u) * h | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function cx(o) {
          let t = o, n = o;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== o);
          return n;
        }
        function S0(o, t, n, u, h, y, b, w) {
          return (h - b) * (t - w) >= (o - b) * (y - w) && (o - b) * (u - w) >= (n - b) * (t - w) && (n - b) * (y - w) >= (h - b) * (u - w);
        }
        function nd(o, t, n, u, h, y, b, w) {
          return !(o === b && t === w) && S0(o, t, n, u, h, y, b, w);
        }
        function dx(o, t) {
          return o.next.i !== t.i && o.prev.i !== t.i && !(function(n, u) {
            let h = n;
            do {
              if (h.i !== n.i && h.next.i !== n.i && h.i !== u.i && h.next.i !== u.i && k0(h, h.next, n, u)) return true;
              h = h.next;
            } while (h !== n);
            return false;
          })(o, t) && (od(o, t) && od(t, o) && (function(n, u) {
            let h = n, y = false;
            const b = (n.x + u.x) / 2, w = (n.y + u.y) / 2;
            do
              h.y > w != h.next.y > w && h.next.y !== h.y && b < (h.next.x - h.x) * (w - h.y) / (h.next.y - h.y) + h.x && (y = !y), h = h.next;
            while (h !== n);
            return y;
          })(o, t) && (Ci(o.prev, o, t.prev) || Ci(o, t.prev, t)) || Su(o, t) && Ci(o.prev, o, o.next) > 0 && Ci(t.prev, t, t.next) > 0);
        }
        function Ci(o, t, n) {
          return (t.y - o.y) * (n.x - t.x) - (t.x - o.x) * (n.y - t.y);
        }
        function Su(o, t) {
          return o.x === t.x && o.y === t.y;
        }
        function k0(o, t, n, u) {
          const h = Jh(Ci(o, t, n)), y = Jh(Ci(o, t, u)), b = Jh(Ci(n, u, o)), w = Jh(Ci(n, u, t));
          return h !== y && b !== w || !(h !== 0 || !Kh(o, n, t)) || !(y !== 0 || !Kh(o, u, t)) || !(b !== 0 || !Kh(n, o, u)) || !(w !== 0 || !Kh(n, t, u));
        }
        function Kh(o, t, n) {
          return t.x <= Math.max(o.x, n.x) && t.x >= Math.min(o.x, n.x) && t.y <= Math.max(o.y, n.y) && t.y >= Math.min(o.y, n.y);
        }
        function Jh(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        }
        function od(o, t) {
          return Ci(o.prev, o, o.next) < 0 ? Ci(o, t, o.next) >= 0 && Ci(o, o.prev, t) >= 0 : Ci(o, t, o.prev) < 0 || Ci(o, o.next, t) < 0;
        }
        function P0(o, t) {
          const n = Yp(o.i, o.x, o.y), u = Yp(t.i, t.x, t.y), h = o.next, y = t.prev;
          return o.next = t, t.prev = o, n.next = h, h.prev = n, u.next = n, n.prev = u, y.next = u, u.prev = y, u;
        }
        function T0(o, t, n, u) {
          const h = Yp(o, t, n);
          return u ? (h.next = u.next, h.prev = u, u.next.prev = h, u.next = h) : (h.prev = h, h.next = h), h;
        }
        function ad(o) {
          o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
        }
        function Yp(o, t, n) {
          return { i: o, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class ku {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class Qh {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        Qh.noSubdivision = new Qh({ fill: new ku(0, 0), line: new ku(0, 0), tile: new ku(0, 0), stencil: new ku(0, 0), circle: 1 }), Ft("SubdivisionGranularityExpression", ku), Ft("SubdivisionGranularitySetting", Qh);
        const Pu = -32768, sd = 32767;
        class hx {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t, this._granularityCellSize = et / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const u = 0 | Math.round(t), h = 0 | Math.round(n), y = this._getKey(u, h);
            if (this._vertexDictionary.has(y)) return this._vertexDictionary.get(y);
            const b = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(y, b), this._vertexBuffer.push(u, h), b;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(h, y) {
              const b = [];
              for (let w = 0; w < y.length; w += 3) {
                const S = y[w], I = y[w + 1], E = y[w + 2], B = h[2 * S], N = h[2 * S + 1];
                (h[2 * I] - B) * (h[2 * E + 1] - N) - (h[2 * I + 1] - N) * (h[2 * E] - B) > 0 ? (b.push(S), b.push(E), b.push(I)) : (b.push(S), b.push(I), b.push(E));
              }
              return b;
            })(this._vertexBuffer, t);
            const n = [], u = t.length;
            for (let h = 0; h < u; h += 3) {
              const y = [t[h + 0], t[h + 1], t[h + 2]], b = [this._vertexBuffer[2 * t[h + 0] + 0], this._vertexBuffer[2 * t[h + 0] + 1], this._vertexBuffer[2 * t[h + 1] + 0], this._vertexBuffer[2 * t[h + 1] + 1], this._vertexBuffer[2 * t[h + 2] + 0], this._vertexBuffer[2 * t[h + 2] + 1]];
              let w = 1 / 0, S = 1 / 0, I = -1 / 0, E = -1 / 0;
              for (let K = 0; K < 3; K++) {
                const ae = b[2 * K], pe = b[2 * K + 1];
                w = Math.min(w, ae), I = Math.max(I, ae), S = Math.min(S, pe), E = Math.max(E, pe);
              }
              if (w === I || S === E) continue;
              const B = Math.floor(w / this._granularityCellSize), N = Math.ceil(I / this._granularityCellSize), G = Math.floor(S / this._granularityCellSize), q = Math.ceil(E / this._granularityCellSize);
              if (B !== N || G !== q) for (let K = G; K < q; K++) {
                const ae = this._scanlineGenerateVertexRingForCellRow(K, b, y);
                fx(this._vertexBuffer, ae, n);
              }
              else n.push(...y);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, u) {
            const h = t * this._granularityCellSize, y = h + this._granularityCellSize, b = [];
            for (let w = 0; w < 3; w++) {
              const S = n[2 * w], I = n[2 * w + 1], E = n[2 * (w + 1) % 6], B = n[(2 * (w + 1) + 1) % 6], N = n[2 * (w + 2) % 6], G = n[(2 * (w + 2) + 1) % 6], q = E - S, K = B - I, ae = q === 0, pe = K === 0, Be = (h - I) / K, Ce = (y - I) / K, Ie = Math.min(Be, Ce), He = Math.max(Be, Ce);
              if (!pe && (Ie >= 1 || He <= 0) || pe && (I < h || I > y)) {
                B >= h && B <= y && b.push(u[(w + 1) % 3]);
                continue;
              }
              !pe && Ie > 0 && b.push(this._vertexToIndex(S + q * Ie, I + K * Ie));
              const rt = S + q * Math.max(Ie, 0), _t = S + q * Math.min(He, 1);
              ae || this._generateIntraEdgeVertices(b, S, I, E, B, rt, _t), !pe && He < 1 && b.push(this._vertexToIndex(S + q * He, I + K * He)), (pe || B >= h && B <= y) && b.push(u[(w + 1) % 3]), !pe && (B <= h || B >= y) && this._generateInterEdgeVertices(b, S, I, E, B, N, G, _t, h, y);
            }
            return b;
          }
          _generateIntraEdgeVertices(t, n, u, h, y, b, w) {
            const S = h - n, I = y - u, E = I === 0, B = E ? Math.min(n, h) : Math.min(b, w), N = E ? Math.max(n, h) : Math.max(b, w), G = Math.floor(B / this._granularityCellSize) + 1, q = Math.ceil(N / this._granularityCellSize) - 1;
            if (E ? n < h : b < w) for (let K = G; K <= q; K++) {
              const ae = K * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
            else for (let K = q; K >= G; K--) {
              const ae = K * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
          }
          _generateInterEdgeVertices(t, n, u, h, y, b, w, S, I, E) {
            const B = y - u, N = b - h, G = w - y, q = (I - y) / G, K = (E - y) / G, ae = Math.min(q, K), pe = Math.max(q, K), Be = h + N * ae;
            let Ce = Math.floor(Math.min(Be, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(Be, S) / this._granularityCellSize) - 1, He = S < Be;
            const rt = G === 0;
            if (rt && (w === I || w === E)) return;
            if (rt || ae >= 1 || pe <= 0) {
              const At = u - w, Pt = b + (n - b) * Math.min((I - w) / At, (E - w) / At);
              Ce = Math.floor(Math.min(Pt, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(Pt, S) / this._granularityCellSize) - 1, He = S < Pt;
            }
            const _t = B > 0 ? E : I;
            if (He) for (let At = Ce; At <= Ie; At++) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
            else for (let At = Ie; At >= Ce; At--) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
          }
          _generateOutline(t) {
            const n = [];
            for (const u of t) {
              const h = fl(u, this._granularity, true), y = this._pointArrayToIndices(h), b = [];
              for (let w = 1; w < y.length; w++) b.push(y[w - 1]), b.push(y[w]);
              n.push(b);
            }
            return n;
          }
          _handlePoles(t) {
            let n = false, u = false;
            this._canonical && (this._canonical.y === 0 && (n = true), this._canonical.y === (1 << this._canonical.z) - 1 && (u = true)), (n || u) && this._fillPoles(t, n, u);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const u = t[n + 1];
              u === Pu && (t[n + 1] = -32767), u === sd && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, u, h, y, b) {
            h > y != (b === Pu) ? (t.push(n), t.push(u), t.push(this._vertexToIndex(h, b)), t.push(u), t.push(this._vertexToIndex(y, b)), t.push(this._vertexToIndex(h, b))) : (t.push(u), t.push(n), t.push(this._vertexToIndex(h, b)), t.push(this._vertexToIndex(y, b)), t.push(u), t.push(this._vertexToIndex(h, b)));
          }
          _fillPoles(t, n, u) {
            const h = this._vertexBuffer, y = et, b = t.length;
            for (let w = 2; w < b; w += 3) {
              const S = t[w - 2], I = t[w - 1], E = t[w], B = h[2 * S], N = h[2 * S + 1], G = h[2 * I], q = h[2 * I + 1], K = h[2 * E], ae = h[2 * E + 1];
              n && (N === 0 && q === 0 && this._generatePoleQuad(t, S, I, B, G, Pu), q === 0 && ae === 0 && this._generatePoleQuad(t, I, E, G, K, Pu), ae === 0 && N === 0 && this._generatePoleQuad(t, E, S, K, B, Pu)), u && (N === y && q === y && this._generatePoleQuad(t, S, I, B, G, sd), q === y && ae === y && this._generatePoleQuad(t, I, E, G, K, sd), ae === y && N === y && this._generatePoleQuad(t, E, S, K, B, sd));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: u, holeIndices: h } = (function(w) {
              const S = [], I = [];
              for (const E of w) if (E.length !== 0) {
                E !== w[0] && S.push(I.length / 2);
                for (let B = 0; B < E.length; B++) I.push(E[B].x), I.push(E[B].y);
              }
              return { flattened: I, holeIndices: S };
            })(t);
            let y;
            this._initializeVertices(u);
            try {
              const w = (function(I, E, B = 2) {
                const N = E && E.length, G = N ? E[0] * B : I.length;
                let q = C0(I, 0, G, B, true);
                const K = [];
                if (!q || q.next === q.prev) return K;
                let ae, pe, Be;
                if (N && (q = (function(Ce, Ie, He, rt) {
                  const _t = [];
                  for (let At = 0, Pt = Ie.length; At < Pt; At++) {
                    const Et = C0(Ce, Ie[At] * rt, At < Pt - 1 ? Ie[At + 1] * rt : Ce.length, rt, false);
                    Et === Et.next && (Et.steiner = true), _t.push(cx(Et));
                  }
                  _t.sort(sx);
                  for (let At = 0; At < _t.length; At++) He = lx(_t[At], He);
                  return He;
                })(I, E, q, B)), I.length > 80 * B) {
                  ae = I[0], pe = I[1];
                  let Ce = ae, Ie = pe;
                  for (let He = B; He < G; He += B) {
                    const rt = I[He], _t = I[He + 1];
                    rt < ae && (ae = rt), _t < pe && (pe = _t), rt > Ce && (Ce = rt), _t > Ie && (Ie = _t);
                  }
                  Be = Math.max(Ce - ae, Ie - pe), Be = Be !== 0 ? 32767 / Be : 0;
                }
                return id(q, K, B, ae, pe, Be, 0), K;
              })(u, h), S = this._convertIndices(u, w);
              y = this._subdivideTrianglesScanline(S);
            } catch (w) {
              console.error(w);
            }
            let b = [];
            return n && (b = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(y), { verticesFlattened: this._vertexBuffer, indicesTriangles: y, indicesLineList: b };
          }
          _convertIndices(t, n) {
            const u = [];
            for (let h = 0; h < n.length; h++) u.push(this._vertexToIndex(t[2 * n[h]], t[2 * n[h] + 1]));
            return u;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let u = 0; u < t.length; u++) {
              const h = t[u];
              n.push(this._vertexToIndex(h.x, h.y));
            }
            return n;
          }
        }
        function I0(o, t, n, u = true) {
          return new hx(n, t).subdividePolygonInternal(o, u);
        }
        function fl(o, t, n = false) {
          if (!o || o.length < 1) return [];
          if (o.length < 2) return [];
          const u = o[0], h = o[o.length - 1], y = n && (u.x !== h.x || u.y !== h.y);
          if (t < 2) return y ? [...o, o[0]] : [...o];
          const b = Math.floor(et / t), w = [];
          w.push(new C(o[0].x, o[0].y));
          const S = o.length, I = y ? S : S - 1;
          for (let E = 0; E < I; E++) {
            const B = o[E], N = E < S - 1 ? o[E + 1] : o[0], G = B.x, q = B.y, K = N.x, ae = N.y, pe = G !== K, Be = q !== ae;
            if (!pe && !Be) continue;
            const Ce = K - G, Ie = ae - q, He = Math.abs(Ce), rt = Math.abs(Ie);
            let _t = G, At = q;
            for (; ; ) {
              const Et = Ce > 0 ? (Math.floor(_t / b) + 1) * b : (Math.ceil(_t / b) - 1) * b, Wt = Ie > 0 ? (Math.floor(At / b) + 1) * b : (Math.ceil(At / b) - 1) * b, Mt = Math.abs(_t - Et), Rt = Math.abs(At - Wt), ct = Math.abs(_t - K), or = Math.abs(At - ae), hr = pe ? Mt / He : Number.POSITIVE_INFINITY, Kt = Be ? Rt / rt : Number.POSITIVE_INFINITY;
              if ((ct <= Mt || !pe) && (or <= Rt || !Be)) break;
              if (hr < Kt && pe || !Be) {
                _t = Et, At += Ie * hr;
                const Ut = new C(_t, Math.round(At));
                w[w.length - 1].x === Ut.x && w[w.length - 1].y === Ut.y || w.push(Ut);
              } else {
                _t += Ce * Kt, At = Wt;
                const Ut = new C(Math.round(_t), At);
                w[w.length - 1].x === Ut.x && w[w.length - 1].y === Ut.y || w.push(Ut);
              }
            }
            const Pt = new C(K, ae);
            w[w.length - 1].x === Pt.x && w[w.length - 1].y === Pt.y || w.push(Pt);
          }
          return w;
        }
        function fx(o, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let u = 0, h = o[2 * t[0]];
          for (let S = 1; S < t.length; S++) {
            const I = o[2 * t[S]];
            I < h && (h = I, u = S);
          }
          const y = t.length;
          let b = u, w = (b + 1) % y;
          for (; ; ) {
            const S = b - 1 >= 0 ? b - 1 : y - 1, I = (w + 1) % y, E = o[2 * t[S]], B = o[2 * t[I]], N = o[2 * t[b]], G = o[2 * t[b] + 1], q = o[2 * t[w] + 1];
            let K = false;
            if (E < B) K = true;
            else if (E > B) K = false;
            else {
              const ae = q - G, pe = -(o[2 * t[w]] - N), Be = G < q ? 1 : -1;
              ((E - N) * ae + (o[2 * t[S] + 1] - G) * pe) * Be > ((B - N) * ae + (o[2 * t[I] + 1] - G) * pe) * Be && (K = true);
            }
            if (K) {
              const ae = t[S], pe = t[b], Be = t[w];
              ae !== pe && ae !== Be && pe !== Be && n.push(Be, pe, ae), b--, b < 0 && (b = y - 1);
            } else {
              const ae = t[I], pe = t[b], Be = t[w];
              ae !== pe && ae !== Be && pe !== Be && n.push(Be, pe, ae), w++, w >= y && (w = 0);
            }
            if (S === I) break;
          }
        }
        function M0(o, t, n, u, h, y, b, w, S) {
          const I = h.length / 2, E = b && w && S;
          if (I < vr.MAX_VERTEX_ARRAY_LENGTH) {
            const B = t.prepareSegment(I, n, u), N = B.vertexLength;
            for (let K = 0; K < y.length; K += 3) u.emplaceBack(N + y[K], N + y[K + 1], N + y[K + 2]);
            let G, q;
            B.vertexLength += I, B.primitiveLength += y.length / 3, E && (q = b.prepareSegment(I, n, w), G = q.vertexLength, q.vertexLength += I);
            for (let K = 0; K < h.length; K += 2) o(h[K], h[K + 1]);
            if (E) for (let K = 0; K < S.length; K++) {
              const ae = S[K];
              for (let pe = 1; pe < ae.length; pe += 2) w.emplaceBack(G + ae[pe - 1], G + ae[pe]);
              q.primitiveLength += ae.length / 2;
            }
          } else (function(B, N, G, q, K, ae) {
            const pe = [];
            for (let rt = 0; rt < q.length / 2; rt++) pe.push(-1);
            const Be = { count: 0 };
            let Ce = 0, Ie = B.getOrCreateLatestSegment(N, G), He = Ie.vertexLength;
            for (let rt = 2; rt < K.length; rt += 3) {
              const _t = K[rt - 2], At = K[rt - 1], Pt = K[rt];
              let Et = pe[_t] < Ce, Wt = pe[At] < Ce, Mt = pe[Pt] < Ce;
              Ie.vertexLength + ((Et ? 1 : 0) + (Wt ? 1 : 0) + (Mt ? 1 : 0)) > vr.MAX_VERTEX_ARRAY_LENGTH && (Ie = B.createNewSegment(N, G), Ce = Be.count, Et = true, Wt = true, Mt = true, He = 0);
              const Rt = ld(pe, q, ae, Be, _t, Et, Ie), ct = ld(pe, q, ae, Be, At, Wt, Ie), or = ld(pe, q, ae, Be, Pt, Mt, Ie);
              G.emplaceBack(He + Rt - Ce, He + ct - Ce, He + or - Ce), Ie.primitiveLength++;
            }
          })(t, n, u, h, y, o), E && (function(B, N, G, q, K, ae) {
            const pe = [];
            for (let rt = 0; rt < q.length / 2; rt++) pe.push(-1);
            const Be = { count: 0 };
            let Ce = 0, Ie = B.getOrCreateLatestSegment(N, G), He = Ie.vertexLength;
            for (let rt = 0; rt < K.length; rt++) {
              const _t = K[rt];
              for (let At = 1; At < K[rt].length; At += 2) {
                const Pt = _t[At - 1], Et = _t[At];
                let Wt = pe[Pt] < Ce, Mt = pe[Et] < Ce;
                Ie.vertexLength + ((Wt ? 1 : 0) + (Mt ? 1 : 0)) > vr.MAX_VERTEX_ARRAY_LENGTH && (Ie = B.createNewSegment(N, G), Ce = Be.count, Wt = true, Mt = true, He = 0);
                const Rt = ld(pe, q, ae, Be, Pt, Wt, Ie), ct = ld(pe, q, ae, Be, Et, Mt, Ie);
                G.emplaceBack(He + Rt - Ce, He + ct - Ce), Ie.primitiveLength++;
              }
            }
          })(b, n, w, h, S, o), t.forceNewSegmentOnNextPrepare(), b == null ? void 0 : b.forceNewSegmentOnNextPrepare();
        }
        function ld(o, t, n, u, h, y, b) {
          if (y) {
            const w = u.count;
            return n(t[2 * h], t[2 * h + 1]), o[h] = u.count, u.count++, b.vertexLength++, w;
          }
          return o[h];
        }
        class Kp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Qe(), this.indexArray = new Xr(), this.indexArray2 = new Gr(), this.programConfigurations = new Ln(t.layers, t.zoom), this.segments = new vr(), this.segments2 = new vr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasPattern = Zp("fill", this.layers, n);
            const h = this.layers[0].layout.get("fill-sort-key"), y = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, N = Vo(w, B);
              if (!this.layers[0]._featureFilter.filter(new ri(this.zoom, { globalState: this.globalState }), N, u)) continue;
              const G = y ? h.evaluate(N, {}, u, n.availableImages) : void 0, q = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: B ? N.geometry : ha(w), patterns: {}, sortKey: G };
              b.push(q);
            }
            y && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              if (this.hasPattern) {
                const B = Hp("fill", this.layers, w, { zoom: this.zoom, globalState: this.globalState }, n);
                this.patternFeatures.push(B);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, globalState: this.globalState });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, rx), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, u, h, y, b) {
            for (const w of Ys(n, 500)) {
              const S = I0(w, h, b.fill.getGranularityForZoomLevel(h.z)), I = this.layoutVertexArray;
              M0(((E, B) => {
                I.emplaceBack(E, B);
              }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles, this.segments2, this.indexArray2, S.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, canonical: h, globalState: this.globalState });
          }
        }
        let E0, R0;
        Ft("FillBucket", Kp, { omit: ["layers", "patternFeatures"] });
        var px = { get paint() {
          return R0 = R0 || new gn({ "fill-antialias": new Gt(Pe.paint_fill["fill-antialias"]), "fill-opacity": new er(Pe.paint_fill["fill-opacity"]), "fill-color": new er(Pe.paint_fill["fill-color"]), "fill-outline-color": new er(Pe.paint_fill["fill-outline-color"]), "fill-translate": new Gt(Pe.paint_fill["fill-translate"]), "fill-translate-anchor": new Gt(Pe.paint_fill["fill-translate-anchor"]), "fill-pattern": new gu(Pe.paint_fill["fill-pattern"]) });
        }, get layout() {
          return E0 = E0 || new gn({ "fill-sort-key": new er(Pe.layout_fill["fill-sort-key"]) });
        } };
        class mx extends Wn {
          constructor(t) {
            super(t, px);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const u = this.paint._values["fill-outline-color"];
            u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new Kp(t);
          }
          queryRadius() {
            return Xh(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: u, pixelsToTileUnits: h }) {
            return u0(Yh(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -u.bearingInRadians, h), n);
          }
          isTileClipped() {
            return true;
          }
        }
        const gx = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), vx = bi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: _x } = gx;
        class Tu {
          constructor(t, n, u, h, y) {
            this.properties = {}, this.extent = u, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = h, this._values = y, t.readFields(yx, this, n);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos, u = [];
            let h, y = 1, b = 0, w = 0, S = 0;
            for (; t.pos < n; ) {
              if (b <= 0) {
                const I = t.readVarint();
                y = 7 & I, b = I >> 3;
              }
              if (b--, y === 1 || y === 2) w += t.readSVarint(), S += t.readSVarint(), y === 1 && (h && u.push(h), h = []), h && h.push(new C(w, S));
              else {
                if (y !== 7) throw new Error(`unknown command ${y}`);
                h && h.push(h[0].clone());
              }
            }
            return h && u.push(h), u;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let u = 1, h = 0, y = 0, b = 0, w = 1 / 0, S = -1 / 0, I = 1 / 0, E = -1 / 0;
            for (; t.pos < n; ) {
              if (h <= 0) {
                const B = t.readVarint();
                u = 7 & B, h = B >> 3;
              }
              if (h--, u === 1 || u === 2) y += t.readSVarint(), b += t.readSVarint(), y < w && (w = y), y > S && (S = y), b < I && (I = b), b > E && (E = b);
              else if (u !== 7) throw new Error(`unknown command ${u}`);
            }
            return [w, I, S, E];
          }
          toGeoJSON(t, n, u) {
            const h = this.extent * Math.pow(2, u), y = this.extent * t, b = this.extent * n, w = this.loadGeometry();
            function S(N) {
              return [360 * (N.x + y) / h - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (N.y + b) / h) * Math.PI)) - 90];
            }
            function I(N) {
              return N.map(S);
            }
            let E;
            if (this.type === 1) {
              const N = [];
              for (const q of w) N.push(q[0]);
              const G = I(N);
              E = N.length === 1 ? { type: "Point", coordinates: G[0] } : { type: "MultiPoint", coordinates: G };
            } else if (this.type === 2) {
              const N = w.map(I);
              E = N.length === 1 ? { type: "LineString", coordinates: N[0] } : { type: "MultiLineString", coordinates: N };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const N = (function(q) {
                  const K = q.length;
                  if (K <= 1) return [q];
                  const ae = [];
                  let pe, Be;
                  for (let Ce = 0; Ce < K; Ce++) {
                    const Ie = bx(q[Ce]);
                    Ie !== 0 && (Be === void 0 && (Be = Ie < 0), Be === Ie < 0 ? (pe && ae.push(pe), pe = [q[Ce]]) : pe && pe.push(q[Ce]));
                  }
                  return pe && ae.push(pe), ae;
                })(w), G = [];
                for (const q of N) G.push(q.map(I));
                E = G.length === 1 ? { type: "Polygon", coordinates: G[0] } : { type: "MultiPolygon", coordinates: G };
              }
            }
            const B = { type: "Feature", geometry: E, properties: this.properties };
            return this.id != null && (B.id = this.id), B;
          }
        }
        function yx(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? (function(u, h) {
            const y = u.readVarint() + u.pos;
            for (; u.pos < y; ) {
              const b = h._keys[u.readVarint()], w = h._values[u.readVarint()];
              h.properties[b] = w;
            }
          })(n, t) : o === 3 ? t.type = n.readVarint() : o === 4 && (t._geometry = n.pos);
        }
        function bx(o) {
          let t = 0;
          for (let n, u, h = 0, y = o.length, b = y - 1; h < y; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        Tu.types = ["Unknown", "Point", "LineString", "Polygon"];
        class A0 {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(xx, this, n), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new Tu(this._pbf, n, this.extent, this._keys, this._values);
          }
        }
        function xx(o, t, n) {
          o === 15 ? t.version = n.readVarint() : o === 1 ? t.name = n.readString() : o === 5 ? t.extent = n.readVarint() : o === 2 ? t._features.push(n.pos) : o === 3 ? t._keys.push(n.readString()) : o === 4 && t._values.push((function(u) {
            let h = null;
            const y = u.readVarint() + u.pos;
            for (; u.pos < y; ) {
              const b = u.readVarint() >> 3;
              h = b === 1 ? u.readString() : b === 2 ? u.readFloat() : b === 3 ? u.readDouble() : b === 4 ? u.readVarint64() : b === 5 ? u.readVarint() : b === 6 ? u.readSVarint() : b === 7 ? u.readBoolean() : null;
            }
            if (h == null) throw new Error("unknown feature value");
            return h;
          })(n));
        }
        class D0 {
          constructor(t, n) {
            this.layers = t.readFields(wx, {}, n);
          }
        }
        function wx(o, t, n) {
          if (o === 3) {
            const u = new A0(n, n.readVarint() + n.pos);
            u.length && (t[u.name] = u);
          }
        }
        const Jp = Math.pow(2, 13);
        function ud(o, t, n, u, h, y, b, w) {
          o.emplaceBack(t, n, 2 * Math.floor(u * Jp) + b, h * Jp * 2, y * Jp * 2, Math.round(w));
        }
        class Qp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new We(), this.centroidVertexArray = new be(), this.indexArray = new Xr(), this.programConfigurations = new Ln(t.layers, t.zoom), this.segments = new vr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.features = [], this.hasPattern = Zp("fill-extrusion", this.layers, n);
            for (const { feature: h, id: y, index: b, sourceLayerIndex: w } of t) {
              const S = this.layers[0]._featureFilter.needGeometry, I = Vo(h, S);
              if (!this.layers[0]._featureFilter.filter(new ri(this.zoom, { globalState: this.globalState }), I, u)) continue;
              const E = { id: y, sourceLayerIndex: w, index: b, geometry: S ? I.geometry : ha(h), properties: h.properties, type: h.type, patterns: {} };
              this.hasPattern ? this.features.push(Hp("fill-extrusion", this.layers, E, { zoom: this.zoom, globalState: this.globalState }, n)) : this.addFeature(E, E.geometry, b, u, {}, n.subdivisionGranularity), n.featureIndex.insert(h, E.geometry, b, w, this.index, true);
            }
          }
          addFeatures(t, n, u) {
            for (const h of this.features) {
              const { geometry: y } = h;
              this.addFeature(h, y, h.index, n, u, t.subdivisionGranularity);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, globalState: this.globalState });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _x), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, vx.members, true), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, u, h, y, b) {
            for (const w of Ys(n, 500)) {
              const S = { x: 0, y: 0, sampleCount: 0 }, I = this.layoutVertexArray.length;
              this.processPolygon(S, h, t, w, b);
              const E = this.layoutVertexArray.length - I, B = Math.floor(S.x / S.sampleCount), N = Math.floor(S.y / S.sampleCount);
              for (let G = 0; G < E; G++) this.centroidVertexArray.emplaceBack(B, N);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, canonical: h, globalState: this.globalState });
          }
          processPolygon(t, n, u, h, y) {
            if (h.length < 1 || z0(h[0])) return;
            for (const B of h) B.length !== 0 && Cx(t, B);
            const b = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, w = y.fill.getGranularityForZoomLevel(n.z), S = Tu.types[u.type] === "Polygon";
            for (const B of h) {
              if (B.length === 0 || z0(B)) continue;
              const N = fl(B, w, S);
              this._generateSideFaces(N, b);
            }
            if (!S) return;
            const I = I0(h, n, w, false), E = this.layoutVertexArray;
            M0(((B, N) => {
              ud(E, B, N, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, I.verticesFlattened, I.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let u = 0;
            for (let h = 1; h < t.length; h++) {
              const y = t[h], b = t[h - 1];
              if (Sx(y, b)) continue;
              n.segment.vertexLength + 4 > vr.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const w = y.sub(b)._perp()._unit(), S = b.dist(y);
              u + S > 32768 && (u = 0), ud(this.layoutVertexArray, y.x, y.y, w.x, w.y, 0, 0, u), ud(this.layoutVertexArray, y.x, y.y, w.x, w.y, 0, 1, u), u += S, ud(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 0, u), ud(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 1, u);
              const I = n.segment.vertexLength;
              this.indexArray.emplaceBack(I, I + 2, I + 1), this.indexArray.emplaceBack(I + 1, I + 2, I + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function Cx(o, t) {
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            n === t.length - 1 && t[0].x === u.x && t[0].y === u.y || (o.x += u.x, o.y += u.y, o.sampleCount++);
          }
        }
        function Sx(o, t) {
          return o.x === t.x && (o.x < 0 || o.x > et) || o.y === t.y && (o.y < 0 || o.y > et);
        }
        function z0(o) {
          return o.every(((t) => t.x < 0)) || o.every(((t) => t.x > et)) || o.every(((t) => t.y < 0)) || o.every(((t) => t.y > et));
        }
        let F0;
        Ft("FillExtrusionBucket", Qp, { omit: ["layers", "features"] });
        var kx = { get paint() {
          return F0 = F0 || new gn({ "fill-extrusion-opacity": new Gt(Pe["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new er(Pe["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Gt(Pe["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Gt(Pe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gu(Pe["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new er(Pe["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new er(Pe["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Gt(Pe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Px extends Wn {
          constructor(t) {
            super(t, kx);
          }
          createBucket(t) {
            return new Qp(t);
          }
          queryRadius() {
            return Xh(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b, pixelPosMatrix: w }) {
            const S = Yh(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -y.bearingInRadians, b), I = this.paint.get("fill-extrusion-height").evaluate(n, u), E = this.paint.get("fill-extrusion-base").evaluate(n, u), B = (function(G, q) {
              const K = [];
              for (const ae of G) {
                const pe = [ae.x, ae.y, 0, 1];
                Ke(pe, pe, q), K.push(new C(pe[0] / pe[3], pe[1] / pe[3]));
              }
              return K;
            })(S, w), N = (function(G, q, K, ae) {
              const pe = [], Be = [], Ce = ae[8] * q, Ie = ae[9] * q, He = ae[10] * q, rt = ae[11] * q, _t = ae[8] * K, At = ae[9] * K, Pt = ae[10] * K, Et = ae[11] * K;
              for (const Wt of G) {
                const Mt = [], Rt = [];
                for (const ct of Wt) {
                  const or = ct.x, hr = ct.y, Kt = ae[0] * or + ae[4] * hr + ae[12], Ut = ae[1] * or + ae[5] * hr + ae[13], Mr = ae[2] * or + ae[6] * hr + ae[14], _i = ae[3] * or + ae[7] * hr + ae[15], Li = Mr + He, sn = _i + rt, ho = Kt + _t, On = Ut + At, Xi = Mr + Pt, hi = _i + Et, Ui = new C((Kt + Ce) / sn, (Ut + Ie) / sn);
                  Ui.z = Li / sn, Mt.push(Ui);
                  const Yi = new C(ho / hi, On / hi);
                  Yi.z = Xi / hi, Rt.push(Yi);
                }
                pe.push(Mt), Be.push(Rt);
              }
              return [pe, Be];
            })(h, E, I, w);
            return (function(G, q, K) {
              let ae = 1 / 0;
              u0(K, q) && (ae = L0(K, q[0]));
              for (let pe = 0; pe < q.length; pe++) {
                const Be = q[pe], Ce = G[pe];
                for (let Ie = 0; Ie < Be.length - 1; Ie++) {
                  const He = Be[Ie], rt = [He, Be[Ie + 1], Ce[Ie + 1], Ce[Ie], He];
                  l0(K, rt) && (ae = Math.min(ae, L0(K, rt)));
                }
              }
              return ae !== 1 / 0 && ae;
            })(N[0], N[1], B);
          }
        }
        function cd(o, t) {
          return o.x * t.x + o.y * t.y;
        }
        function L0(o, t) {
          if (o.length === 1) {
            let n = 0;
            const u = t[n++];
            let h;
            for (; !h || u.equals(h); ) if (h = t[n++], !h) return 1 / 0;
            for (; n < t.length; n++) {
              const y = t[n], b = o[0], w = h.sub(u), S = y.sub(u), I = b.sub(u), E = cd(w, w), B = cd(w, S), N = cd(S, S), G = cd(I, w), q = cd(I, S), K = E * N - B * B, ae = (N * G - B * q) / K, pe = (E * q - B * G) / K, Be = u.z * (1 - ae - pe) + h.z * ae + y.z * pe;
              if (isFinite(Be)) return Be;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const u of t) n = Math.min(n, u.z);
            return n;
          }
        }
        const Tx = bi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Ix } = Tx, Mx = bi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Ex } = Mx, Rx = Math.cos(Math.PI / 180 * 37.5), B0 = Math.pow(2, 14) / 0.5;
        class em {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((n) => {
              this.gradients[n.id] = {};
            })), this.layoutVertexArray = new Ze(), this.layoutVertexArray2 = new Je(), this.indexArray = new Xr(), this.programConfigurations = new Ln(t.layers, t.zoom), this.segments = new vr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasPattern = Zp("line", this.layers, n);
            const h = this.layers[0].layout.get("line-sort-key"), y = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, N = Vo(w, B);
              if (!this.layers[0]._featureFilter.filter(new ri(this.zoom, { globalState: this.globalState }), N, u)) continue;
              const G = y ? h.evaluate(N, {}, u) : void 0, q = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: B ? N.geometry : ha(w), patterns: {}, sortKey: G };
              b.push(q);
            }
            y && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              if (this.hasPattern) {
                const B = Hp("line", this.layers, w, { zoom: this.zoom, globalState: this.globalState }, n);
                this.patternFeatures.push(B);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, globalState: this.globalState });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ex)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ix), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, u, h, y, b) {
            const w = this.layers[0].layout, S = w.get("line-join").evaluate(t, {}), I = w.get("line-cap"), E = w.get("line-miter-limit"), B = w.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const N of n) this.addLine(N, t, S, I, E, B, h, b);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, canonical: h, globalState: this.globalState });
          }
          addLine(t, n, u, h, y, b, w, S) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = fl(t, w ? S.line.getGranularityForZoomLevel(w.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Ce = 0; Ce < t.length - 1; Ce++) this.totalDistance += t[Ce].dist(t[Ce + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const I = Tu.types[n.type] === "Polygon";
            let E = t.length;
            for (; E >= 2 && t[E - 1].equals(t[E - 2]); ) E--;
            let B = 0;
            for (; B < E - 1 && t[B].equals(t[B + 1]); ) B++;
            if (E < (I ? 3 : 2)) return;
            u === "bevel" && (y = 1.05);
            const N = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, G = this.segments.prepareSegment(10 * E, this.layoutVertexArray, this.indexArray);
            let q, K, ae, pe, Be;
            this.e1 = this.e2 = -1, I && (q = t[E - 2], Be = t[B].sub(q)._unit()._perp());
            for (let Ce = B; Ce < E; Ce++) {
              if (ae = Ce === E - 1 ? I ? t[B + 1] : void 0 : t[Ce + 1], ae && t[Ce].equals(ae)) continue;
              Be && (pe = Be), q && (K = q), q = t[Ce], Be = ae ? ae.sub(q)._unit()._perp() : pe, pe = pe || Be;
              let Ie = pe.add(Be);
              Ie.x === 0 && Ie.y === 0 || Ie._unit();
              const He = pe.x * Be.x + pe.y * Be.y, rt = Ie.x * Be.x + Ie.y * Be.y, _t = rt !== 0 ? 1 / rt : 1 / 0, At = 2 * Math.sqrt(2 - 2 * rt), Pt = rt < Rx && K && ae, Et = pe.x * Be.y - pe.y * Be.x > 0;
              if (Pt && Ce > B) {
                const Rt = q.dist(K);
                if (Rt > 2 * N) {
                  const ct = q.sub(q.sub(K)._mult(N / Rt)._round());
                  this.updateDistance(K, ct), this.addCurrentVertex(ct, pe, 0, 0, G), K = ct;
                }
              }
              const Wt = K && ae;
              let Mt = Wt ? u : I ? "butt" : h;
              if (Wt && Mt === "round" && (_t < b ? Mt = "miter" : _t <= 2 && (Mt = "fakeround")), Mt === "miter" && _t > y && (Mt = "bevel"), Mt === "bevel" && (_t > 2 && (Mt = "flipbevel"), _t < y && (Mt = "miter")), K && this.updateDistance(K, q), Mt === "miter") Ie._mult(_t), this.addCurrentVertex(q, Ie, 0, 0, G);
              else if (Mt === "flipbevel") {
                if (_t > 100) Ie = Be.mult(-1);
                else {
                  const Rt = _t * pe.add(Be).mag() / pe.sub(Be).mag();
                  Ie._perp()._mult(Rt * (Et ? -1 : 1));
                }
                this.addCurrentVertex(q, Ie, 0, 0, G), this.addCurrentVertex(q, Ie.mult(-1), 0, 0, G);
              } else if (Mt === "bevel" || Mt === "fakeround") {
                const Rt = -Math.sqrt(_t * _t - 1), ct = Et ? Rt : 0, or = Et ? 0 : Rt;
                if (K && this.addCurrentVertex(q, pe, ct, or, G), Mt === "fakeround") {
                  const hr = Math.round(180 * At / Math.PI / 20);
                  for (let Kt = 1; Kt < hr; Kt++) {
                    let Ut = Kt / hr;
                    if (Ut !== 0.5) {
                      const _i = Ut - 0.5;
                      Ut += Ut * _i * (Ut - 1) * ((1.0904 + He * (He * (3.55645 - 1.43519 * He) - 3.2452)) * _i * _i + (0.848013 + He * (0.215638 * He - 1.06021)));
                    }
                    const Mr = Be.sub(pe)._mult(Ut)._add(pe)._unit()._mult(Et ? -1 : 1);
                    this.addHalfVertex(q, Mr.x, Mr.y, false, Et, 0, G);
                  }
                }
                ae && this.addCurrentVertex(q, Be, -ct, -or, G);
              } else if (Mt === "butt") this.addCurrentVertex(q, Ie, 0, 0, G);
              else if (Mt === "square") {
                const Rt = K ? 1 : -1;
                this.addCurrentVertex(q, Ie, Rt, Rt, G);
              } else Mt === "round" && (K && (this.addCurrentVertex(q, pe, 0, 0, G), this.addCurrentVertex(q, pe, 1, 1, G, true)), ae && (this.addCurrentVertex(q, Be, -1, -1, G, true), this.addCurrentVertex(q, Be, 0, 0, G)));
              if (Pt && Ce < E - 1) {
                const Rt = q.dist(ae);
                if (Rt > 2 * N) {
                  const ct = q.add(ae.sub(q)._mult(N / Rt)._round());
                  this.updateDistance(q, ct), this.addCurrentVertex(ct, Be, 0, 0, G), q = ct;
                }
              }
            }
          }
          addCurrentVertex(t, n, u, h, y, b = false) {
            const w = n.y * h - n.x, S = -n.y - n.x * h;
            this.addHalfVertex(t, n.x + n.y * u, n.y - n.x * u, b, false, u, y), this.addHalfVertex(t, w, S, b, true, -h, y), this.distance > B0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, u, h, y, b));
          }
          addHalfVertex({ x: t, y: n }, u, h, y, b, w, S) {
            const I = 0.5 * (this.lineClips ? this.scaledDistance * (B0 - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (y ? 1 : 0), (n << 1) + (b ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * h) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1) | (63 & I) << 2, I >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const E = S.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, E, this.e2), S.primitiveLength++), b ? this.e2 = E : this.e1 = E;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
        }
        let O0, $0;
        Ft("LineBucket", em, { omit: ["layers", "patternFeatures"] });
        var j0 = { get paint() {
          return $0 = $0 || new gn({ "line-opacity": new er(Pe.paint_line["line-opacity"]), "line-color": new er(Pe.paint_line["line-color"]), "line-translate": new Gt(Pe.paint_line["line-translate"]), "line-translate-anchor": new Gt(Pe.paint_line["line-translate-anchor"]), "line-width": new er(Pe.paint_line["line-width"]), "line-gap-width": new er(Pe.paint_line["line-gap-width"]), "line-offset": new er(Pe.paint_line["line-offset"]), "line-blur": new er(Pe.paint_line["line-blur"]), "line-dasharray": new sa(Pe.paint_line["line-dasharray"]), "line-pattern": new gu(Pe.paint_line["line-pattern"]), "line-gradient": new vu(Pe.paint_line["line-gradient"]) });
        }, get layout() {
          return O0 = O0 || new gn({ "line-cap": new Gt(Pe.layout_line["line-cap"]), "line-join": new er(Pe.layout_line["line-join"]), "line-miter-limit": new Gt(Pe.layout_line["line-miter-limit"]), "line-round-limit": new Gt(Pe.layout_line["line-round-limit"]), "line-sort-key": new er(Pe.layout_line["line-sort-key"]) });
        } };
        class Ax extends er {
          possiblyEvaluate(t, n) {
            return n = new ri(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, u, h) {
            return n = Jt({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, u, h);
          }
        }
        let ef;
        class Dx extends Wn {
          constructor(t) {
            super(t, j0), this.gradientVersion = 0, ef || (ef = new Ax(j0.paint.properties["line-width"].specification), ef.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(u) {
                return u._styleExpression !== void 0;
              })(n) && n._styleExpression.expression instanceof yi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = ef.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new em(t);
          }
          queryRadius(t) {
            const n = t, u = N0(td("line-width", this, n), td("line-gap-width", this, n)), h = td("line-offset", this, n);
            return u / 2 + Math.abs(h) + Xh(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b }) {
            const w = Yh(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -y.bearingInRadians, b), S = b / 2 * N0(this.paint.get("line-width").evaluate(n, u), this.paint.get("line-gap-width").evaluate(n, u)), I = this.paint.get("line-offset").evaluate(n, u);
            return I && (h = (function(E, B) {
              const N = [];
              for (let G = 0; G < E.length; G++) {
                const q = E[G], K = [];
                for (let ae = 0; ae < q.length; ae++) {
                  const pe = q[ae - 1], Be = q[ae], Ce = q[ae + 1], Ie = ae === 0 ? new C(0, 0) : Be.sub(pe)._unit()._perp(), He = ae === q.length - 1 ? new C(0, 0) : Ce.sub(Be)._unit()._perp(), rt = Ie._add(He)._unit(), _t = rt.x * He.x + rt.y * He.y;
                  _t !== 0 && rt._mult(1 / _t), K.push(rt._mult(B)._add(Be));
                }
                N.push(K);
              }
              return N;
            })(h, I * b)), (function(E, B, N) {
              for (let G = 0; G < B.length; G++) {
                const q = B[G];
                if (E.length >= 3) {
                  for (let K = 0; K < q.length; K++) if (Cu(E, q[K])) return true;
                }
                if (G1(E, q, N)) return true;
              }
              return false;
            })(w, h, S);
          }
          isTileClipped() {
            return true;
          }
        }
        function N0(o, t) {
          return t > 0 ? t + 2 * o : o;
        }
        const zx = bi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Fx = bi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        bi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Lx = bi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        bi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const V0 = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Bx = bi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Ox(o, t, n) {
          return o.sections.forEach(((u) => {
            u.text = (function(h, y, b) {
              const w = y.layout.get("text-transform").evaluate(b, {});
              return w === "uppercase" ? h = h.toLocaleUpperCase() : w === "lowercase" && (h = h.toLocaleLowerCase()), ao.applyArabicShaping && (h = ao.applyArabicShaping(h)), h;
            })(u.text, t, n);
          })), o;
        }
        bi([{ name: "triangle", components: 3, type: "Uint16" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), bi([{ type: "Float32", name: "offsetX" }]), bi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), bi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const dd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Vi = 24;
        const tm = 4294967296, U0 = 1 / tm, G0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class rm {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, n, u = this.length) {
            for (; this.pos < u; ) {
              const h = this.readVarint(), y = h >> 3, b = this.pos;
              this.type = 7 & h, t(y, n, this), this.pos === b && this.skip(h);
            }
            return n;
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * tm;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * tm;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const n = this.buf;
            let u, h;
            return h = n[this.pos++], u = 127 & h, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 7, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 14, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 21, h < 128 ? u : (h = n[this.pos], u |= (15 & h) << 28, (function(y, b, w) {
              const S = w.buf;
              let I, E;
              if (E = S[w.pos++], I = (112 & E) >> 4, E < 128 || (E = S[w.pos++], I |= (127 & E) << 3, E < 128) || (E = S[w.pos++], I |= (127 & E) << 10, E < 128) || (E = S[w.pos++], I |= (127 & E) << 17, E < 128) || (E = S[w.pos++], I |= (127 & E) << 24, E < 128) || (E = S[w.pos++], I |= (1 & E) << 31, E < 128)) return Iu(y, I, b);
              throw new Error("Expected varint not more than 10 bytes");
            })(u, t, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, n = this.pos;
            return this.pos = t, t - n >= 12 && G0 ? G0.decode(this.buf.subarray(n, t)) : (function(u, h, y) {
              let b = "", w = h;
              for (; w < y; ) {
                const S = u[w];
                let I, E, B, N = null, G = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
                if (w + G > y) break;
                G === 1 ? S < 128 && (N = S) : G === 2 ? (I = u[w + 1], (192 & I) == 128 && (N = (31 & S) << 6 | 63 & I, N <= 127 && (N = null))) : G === 3 ? (I = u[w + 1], E = u[w + 2], (192 & I) == 128 && (192 & E) == 128 && (N = (15 & S) << 12 | (63 & I) << 6 | 63 & E, (N <= 2047 || N >= 55296 && N <= 57343) && (N = null))) : G === 4 && (I = u[w + 1], E = u[w + 2], B = u[w + 3], (192 & I) == 128 && (192 & E) == 128 && (192 & B) == 128 && (N = (15 & S) << 18 | (63 & I) << 12 | (63 & E) << 6 | 63 & B, (N <= 65535 || N >= 1114112) && (N = null))), N === null ? (N = 65533, G = 1) : N > 65535 && (N -= 65536, b += String.fromCharCode(N >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), b += String.fromCharCode(N), w += G;
              }
              return b;
            })(this.buf, n, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, t);
            return this.pos = t, n;
          }
          readPackedVarint(t = [], n) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) t.push(this.readVarint(n));
            return t;
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8;
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n);
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t; ) n *= 2;
            if (n !== this.length) {
              const u = new Uint8Array(n);
              u.set(this.buf), this.buf = u, this.dataView = new DataView(u.buffer), this.length = n;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * U0), true), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * U0), true), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, u) {
              let h, y;
              if (n >= 0 ? (h = n % 4294967296 | 0, y = n / 4294967296 | 0) : (h = ~(-n % 4294967296), y = ~(-n / 4294967296), 4294967295 ^ h ? h = h + 1 | 0 : (h = 0, y = y + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              u.realloc(10), (function(b, w, S) {
                S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, S.buf[S.pos] = 127 & (b >>>= 7);
              })(h, 0, u), (function(b, w) {
                const S = (7 & b) << 4;
                w.buf[w.pos++] |= S | ((b >>>= 3) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b)))));
              })(y, u);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(h, y, b) {
              for (let w, S, I = 0; I < y.length; I++) {
                if (w = y.charCodeAt(I), w > 55295 && w < 57344) {
                  if (!S) {
                    w > 56319 || I + 1 === y.length ? (h[b++] = 239, h[b++] = 191, h[b++] = 189) : S = w;
                    continue;
                  }
                  if (w < 56320) {
                    h[b++] = 239, h[b++] = 191, h[b++] = 189, S = w;
                    continue;
                  }
                  w = S - 55296 << 10 | w - 56320 | 65536, S = null;
                } else S && (h[b++] = 239, h[b++] = 191, h[b++] = 189, S = null);
                w < 128 ? h[b++] = w : (w < 2048 ? h[b++] = w >> 6 | 192 : (w < 65536 ? h[b++] = w >> 12 | 224 : (h[b++] = w >> 18 | 240, h[b++] = w >> 12 & 63 | 128), h[b++] = w >> 6 & 63 | 128), h[b++] = 63 & w | 128);
              }
              return b;
            })(this.buf, t, this.pos);
            const u = this.pos - n;
            u >= 128 && q0(n, u, this), this.pos = n - 1, this.writeVarint(u), this.pos += u;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let u = 0; u < n; u++) this.buf[this.pos++] = t[u];
          }
          writeRawMessage(t, n) {
            this.pos++;
            const u = this.pos;
            t(n, this);
            const h = this.pos - u;
            h >= 128 && q0(u, h, this), this.pos = u - 1, this.writeVarint(h), this.pos += h;
          }
          writeMessage(t, n, u) {
            this.writeTag(t, 2), this.writeRawMessage(n, u);
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, $x, n);
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, jx, n);
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, Ux, n);
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, Nx, n);
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, Vx, n);
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, Gx, n);
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, qx, n);
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, Wx, n);
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, Zx, n);
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n);
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n);
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n);
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n);
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n);
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n);
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n);
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n);
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n);
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n);
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n);
          }
        }
        function Iu(o, t, n) {
          return n ? 4294967296 * t + (o >>> 0) : 4294967296 * (t >>> 0) + (o >>> 0);
        }
        function q0(o, t, n) {
          const u = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(u);
          for (let h = n.pos - 1; h >= o; h--) n.buf[h + u] = n.buf[h];
        }
        function $x(o, t) {
          for (let n = 0; n < o.length; n++) t.writeVarint(o[n]);
        }
        function jx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSVarint(o[n]);
        }
        function Nx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFloat(o[n]);
        }
        function Vx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeDouble(o[n]);
        }
        function Ux(o, t) {
          for (let n = 0; n < o.length; n++) t.writeBoolean(o[n]);
        }
        function Gx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed32(o[n]);
        }
        function qx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed32(o[n]);
        }
        function Wx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed64(o[n]);
        }
        function Zx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed64(o[n]);
        }
        function Hx(o, t, n) {
          o === 1 && n.readMessage(Xx, t);
        }
        function Xx(o, t, n) {
          if (o === 3) {
            const { id: u, bitmap: h, width: y, height: b, left: w, top: S, advance: I } = n.readMessage(Yx, {});
            t.push({ id: u, bitmap: new rd({ width: y + 6, height: b + 6 }, h), metrics: { width: y, height: b, left: w, top: S, advance: I } });
          }
        }
        function Yx(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? t.bitmap = n.readBytes() : o === 3 ? t.width = n.readVarint() : o === 4 ? t.height = n.readVarint() : o === 5 ? t.left = n.readSVarint() : o === 6 ? t.top = n.readSVarint() : o === 7 && (t.advance = n.readVarint());
        }
        function W0(o) {
          let t = 0, n = 0;
          for (const b of o) t += b.w * b.h, n = Math.max(n, b.w);
          o.sort(((b, w) => w.h - b.h));
          const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let h = 0, y = 0;
          for (const b of o) for (let w = u.length - 1; w >= 0; w--) {
            const S = u[w];
            if (!(b.w > S.w || b.h > S.h)) {
              if (b.x = S.x, b.y = S.y, y = Math.max(y, b.y + b.h), h = Math.max(h, b.x + b.w), b.w === S.w && b.h === S.h) {
                const I = u.pop();
                I && w < u.length && (u[w] = I);
              } else b.h === S.h ? (S.x += b.w, S.w -= b.w) : b.w === S.w ? (S.y += b.h, S.h -= b.h) : (u.push({ x: S.x + b.w, y: S.y, w: S.w - b.w, h: b.h }), S.y += b.h, S.h -= b.h);
              break;
            }
          }
          return { w: h, h: y, fill: t / (h * y) || 0 };
        }
        class im {
          constructor(t, { pixelRatio: n, version: u, stretchX: h, stretchY: y, content: b, textFitWidth: w, textFitHeight: S }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = h, this.stretchY = y, this.content = b, this.version = u, this.textFitWidth = w, this.textFitHeight = S;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class Z0 {
          constructor(t, n) {
            const u = {}, h = {};
            this.haveRenderCallbacks = [];
            const y = [];
            this.addImages(t, u, y), this.addImages(n, h, y);
            const { w: b, h: w } = W0(y), S = new Bn({ width: b || 1, height: w || 1 });
            for (const I in t) {
              const E = t[I], B = u[I].paddedRect;
              Bn.copy(E.data, S, { x: 0, y: 0 }, { x: B.x + 1, y: B.y + 1 }, E.data);
            }
            for (const I in n) {
              const E = n[I], B = h[I].paddedRect, N = B.x + 1, G = B.y + 1, q = E.data.width, K = E.data.height;
              Bn.copy(E.data, S, { x: 0, y: 0 }, { x: N, y: G }, E.data), Bn.copy(E.data, S, { x: 0, y: K - 1 }, { x: N, y: G - 1 }, { width: q, height: 1 }), Bn.copy(E.data, S, { x: 0, y: 0 }, { x: N, y: G + K }, { width: q, height: 1 }), Bn.copy(E.data, S, { x: q - 1, y: 0 }, { x: N - 1, y: G }, { width: 1, height: K }), Bn.copy(E.data, S, { x: 0, y: 0 }, { x: N + q, y: G }, { width: 1, height: K });
            }
            this.image = S, this.iconPositions = u, this.patternPositions = h;
          }
          addImages(t, n, u) {
            for (const h in t) {
              const y = t[h], b = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
              u.push(b), n[h] = new im(b, y), y.hasRenderCallback && this.haveRenderCallbacks.push(h);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const u in t.updatedImages) this.patchUpdatedImage(this.iconPositions[u], t.getImage(u), n), this.patchUpdatedImage(this.patternPositions[u], t.getImage(u), n);
          }
          patchUpdatedImage(t, n, u) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [h, y] = t.tl;
            u.update(n.data, void 0, { x: h, y });
          }
        }
        var _s;
        Ft("ImagePosition", im), Ft("ImageAtlas", Z0), m.ao = void 0, (_s = m.ao || (m.ao = {}))[_s.none = 0] = "none", _s[_s.horizontal = 1] = "horizontal", _s[_s.vertical = 2] = "vertical", _s[_s.horizontalOnly = 3] = "horizontalOnly";
        class hd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, u) {
            const h = new hd();
            return h.scale = t || 1, h.fontStack = n, h.verticalAlign = u || "bottom", h;
          }
          static forImage(t, n) {
            const u = new hd();
            return u.imageName = t, u.verticalAlign = n || "bottom", u;
          }
        }
        class Mu {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const u = new Mu();
            for (let h = 0; h < t.sections.length; h++) {
              const y = t.sections[h];
              y.image ? u.addImageSection(y) : u.addTextSection(y, n);
            }
            return u;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let u = 0; u < t.length; u++) {
                const h = t.charCodeAt(u + 1) || null, y = t.charCodeAt(u - 1) || null;
                n += h && jh(h) && !dd[t[u + 1]] || y && jh(y) && !dd[t[u - 1]] || !dd[t[u]] ? t[u] : dd[t[u]];
              }
              return n;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let u = 0; u < this.text.length && rf[this.text.charCodeAt(u)]; u++) t++;
            let n = this.text.length;
            for (let u = this.text.length - 1; u >= 0 && u >= t && rf[this.text.charCodeAt(u)]; u--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const u = new Mu();
            return u.text = this.text.substring(t, n), u.sectionIndex = this.sectionIndex.slice(t, n), u.sections = this.sections, u;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0);
          }
          getMaxImageSize(t) {
            let n = 0, u = 0;
            for (let h = 0; h < this.length(); h++) {
              const y = this.getSection(h);
              if (y.imageName) {
                const b = t[y.imageName];
                if (!b) continue;
                const w = b.displaySize;
                n = Math.max(n, w[0]), u = Math.max(u, w[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: u };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(hd.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const u = this.sections.length - 1;
            for (let h = 0; h < t.text.length; ++h) this.sectionIndex.push(u);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void qt("Can't add FormattedSection with an empty image.");
            const u = this.getNextImageSectionCharCode();
            u ? (this.text += String.fromCharCode(u), this.sections.push(hd.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : qt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function tf(o, t, n, u, h, y, b, w, S, I, E, B, N, G, q) {
          const K = Mu.fromFeature(o, h);
          let ae;
          B === m.ao.vertical && K.verticalizePunctuation();
          const { processBidirectionalText: pe, processStyledBidirectionalText: Be } = ao;
          if (pe && K.sections.length === 1) {
            ae = [];
            const He = pe(K.toString(), nm(K, I, y, t, u, G));
            for (const rt of He) {
              const _t = new Mu();
              _t.text = rt, _t.sections = K.sections;
              for (let At = 0; At < rt.length; At++) _t.sectionIndex.push(0);
              ae.push(_t);
            }
          } else if (Be) {
            ae = [];
            const He = Be(K.text, K.sectionIndex, nm(K, I, y, t, u, G));
            for (const rt of He) {
              const _t = new Mu();
              _t.text = rt[0], _t.sectionIndex = rt[1], _t.sections = K.sections, ae.push(_t);
            }
          } else ae = (function(He, rt) {
            const _t = [], At = He.text;
            let Pt = 0;
            for (const Et of rt) _t.push(He.substring(Pt, Et)), Pt = Et;
            return Pt < At.length && _t.push(He.substring(Pt, At.length)), _t;
          })(K, nm(K, I, y, t, u, G));
          const Ce = [], Ie = { positionedLines: Ce, text: K.toString(), top: E[1], bottom: E[1], left: E[0], right: E[0], writingMode: B, iconsInText: false, verticalizable: false };
          return (function(He, rt, _t, At, Pt, Et, Wt, Mt, Rt, ct, or, hr) {
            let Kt = 0, Ut = 0, Mr = 0, _i = 0;
            const Li = Mt === "right" ? 1 : Mt === "left" ? 0 : 0.5, sn = Vi / hr;
            let ho = 0;
            for (const hi of Pt) {
              hi.trim();
              const Ui = hi.getMaxScale(), Yi = { positionedGlyphs: [], lineOffset: 0 };
              He.positionedLines[ho] = Yi;
              const Ki = Yi.positionedGlyphs;
              let In = 0;
              if (!hi.length()) {
                Ut += Et, ++ho;
                continue;
              }
              const fo = ew(At, hi, sn);
              for (let $n = 0; $n < hi.length(); $n++) {
                const Bi = hi.getSection($n), qi = hi.getSectionIndex($n), Wi = hi.getCharCode($n), Ei = tw(Rt, or, Wi);
                let li;
                if (Bi.imageName) {
                  if (He.iconsInText = true, Bi.scale = Bi.scale * sn, li = iw(Bi, Ei, Ui, fo, At), !li) continue;
                  In = Math.max(In, li.imageOffset);
                } else if (li = rw(Bi, Wi, Ei, fo, rt, _t), !li) continue;
                const { rect: Uo, metrics: Du, baselineOffset: Go } = li;
                Ki.push({ glyph: Wi, imageName: Bi.imageName, x: Kt, y: Ut + Go + -17, vertical: Ei, scale: Bi.scale, fontStack: Bi.fontStack, sectionIndex: qi, metrics: Du, rect: Uo }), Ei ? (He.verticalizable = true, Kt += (Bi.imageName ? Du.advance : Vi) * Bi.scale + ct) : Kt += Du.advance * Bi.scale + ct;
              }
              Ki.length !== 0 && (Mr = Math.max(Kt - ct, Mr), nw(Ki, 0, Ki.length - 1, Li)), Kt = 0, Yi.lineOffset = Math.max(In, (Ui - 1) * Vi);
              const Gi = Et * Ui + In;
              Ut += Gi, _i = Math.max(Gi, _i), ++ho;
            }
            const { horizontalAlign: On, verticalAlign: Xi } = om(Wt);
            (function(hi, Ui, Yi, Ki, In, fo, Gi, $n, Bi) {
              const qi = (Ui - Yi) * In;
              let Wi = 0;
              Wi = fo !== Gi ? -$n * Ki - -17 : -Ki * Bi * Gi + 0.5 * Gi;
              for (const Ei of hi) for (const li of Ei.positionedGlyphs) li.x += qi, li.y += Wi;
            })(He.positionedLines, Li, On, Xi, Mr, _i, Et, Ut, Pt.length), He.top += -Xi * Ut, He.bottom = He.top + Ut, He.left += -On * Mr, He.right = He.left + Mr;
          })(Ie, t, n, u, ae, b, w, S, B, I, N, q), !(function(He) {
            for (const rt of He) if (rt.positionedGlyphs.length !== 0) return false;
            return true;
          })(Ce) && Ie;
        }
        const rf = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Kx = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, Jx = { 40: true };
        function H0(o, t, n, u, h, y) {
          if (t.imageName) {
            const b = u[t.imageName];
            return b ? b.displaySize[0] * t.scale * Vi / y + h : 0;
          }
          {
            const b = n[t.fontStack], w = b && b[o];
            return w ? w.metrics.advance * t.scale + h : 0;
          }
        }
        function X0(o, t, n, u) {
          const h = Math.pow(o - t, 2);
          return u ? o < t ? h / 2 : 2 * h : h + Math.abs(n) * n;
        }
        function Qx(o, t, n) {
          let u = 0;
          return o === 10 && (u -= 1e4), n && (u += 150), o !== 40 && o !== 65288 || (u += 50), t !== 41 && t !== 65289 || (u += 50), u;
        }
        function Y0(o, t, n, u, h, y) {
          let b = null, w = X0(t, n, h, y);
          for (const S of u) {
            const I = X0(t - S.x, n, h, y) + S.badness;
            I <= w && (b = S, w = I);
          }
          return { index: o, x: t, priorBreak: b, badness: w };
        }
        function K0(o) {
          return o ? K0(o.priorBreak).concat(o.index) : [];
        }
        function nm(o, t, n, u, h, y) {
          if (!o) return [];
          const b = [], w = (function(B, N, G, q, K, ae) {
            let pe = 0;
            for (let Be = 0; Be < B.length(); Be++) {
              const Ce = B.getSection(Be);
              pe += H0(B.getCharCode(Be), Ce, q, K, N, ae);
            }
            return pe / Math.max(1, Math.ceil(pe / G));
          })(o, t, n, u, h, y), S = o.text.indexOf("\u200B") >= 0;
          let I = 0;
          for (let B = 0; B < o.length(); B++) {
            const N = o.getSection(B), G = o.getCharCode(B);
            if (rf[G] || (I += H0(G, N, u, h, t, y)), B < o.length() - 1) {
              const q = !((E = G) < 11904) && (!!Ir["CJK Compatibility Forms"](E) || !!Ir["CJK Compatibility"](E) || !!Ir["CJK Strokes"](E) || !!Ir["CJK Symbols and Punctuation"](E) || !!Ir["Enclosed CJK Letters and Months"](E) || !!Ir["Halfwidth and Fullwidth Forms"](E) || !!Ir["Ideographic Description Characters"](E) || !!Ir["Vertical Forms"](E) || Gc.test(String.fromCodePoint(E)));
              (Kx[G] || q || N.imageName || B !== o.length() - 2 && Jx[o.getCharCode(B + 1)]) && b.push(Y0(B + 1, I, w, b, Qx(G, o.getCharCode(B + 1), q && S), false));
            }
          }
          var E;
          return K0(Y0(o.length(), I, w, b, 0, true));
        }
        function om(o) {
          let t = 0.5, n = 0.5;
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (o) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function ew(o, t, n) {
          const u = t.getMaxScale() * Vi, { maxImageWidth: h, maxImageHeight: y } = t.getMaxImageSize(o), b = Math.max(u, y * n);
          return { verticalLineContentWidth: Math.max(u, h * n), horizontalLineContentHeight: b };
        }
        function J0(o) {
          switch (o) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function tw(o, t, n) {
          return !(o === m.ao.horizontal || !t && !qc(n) || t && (rf[n] || (u = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(u)))));
          var u;
        }
        function rw(o, t, n, u, h, y) {
          const b = y[o.fontStack], w = (function(I, E, B, N) {
            if (I && I.rect) return I;
            const G = E[B.fontStack], q = G && G[N];
            return q ? { rect: null, metrics: q.metrics } : null;
          })(b && b[t], h, o, t);
          if (w === null) return null;
          let S;
          if (n) S = u.verticalLineContentWidth - o.scale * Vi;
          else {
            const I = J0(o.verticalAlign);
            S = (u.horizontalLineContentHeight - o.scale * Vi) * I;
          }
          return { rect: w.rect, metrics: w.metrics, baselineOffset: S };
        }
        function iw(o, t, n, u, h) {
          const y = h[o.imageName];
          if (!y) return null;
          const b = y.paddedRect, w = y.displaySize, S = { width: w[0], height: w[1], left: 1, top: -3, advance: t ? w[1] : w[0] };
          let I;
          if (t) I = u.verticalLineContentWidth - w[1] * o.scale;
          else {
            const E = J0(o.verticalAlign);
            I = (u.horizontalLineContentHeight - w[1] * o.scale) * E;
          }
          return { rect: b, metrics: S, baselineOffset: I, imageOffset: (t ? w[0] : w[1]) * o.scale - Vi * n };
        }
        function nw(o, t, n, u) {
          if (u === 0) return;
          const h = o[n], y = (o[n].x + h.metrics.advance * h.scale) * u;
          for (let b = t; b <= n; b++) o[b].x -= y;
        }
        function ow(o, t, n) {
          const { horizontalAlign: u, verticalAlign: h } = om(n), y = t[0] - o.displaySize[0] * u, b = t[1] - o.displaySize[1] * h;
          return { image: o, top: b, bottom: b + o.displaySize[1], left: y, right: y + o.displaySize[0] };
        }
        function Q0(o) {
          var t, n;
          let u = o.left, h = o.top, y = o.right - u, b = o.bottom - h;
          const w = (t = o.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", S = (n = o.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", I = (o.image.content[2] - o.image.content[0]) / (o.image.content[3] - o.image.content[1]);
          if (S === "proportional") {
            if (w === "stretchOnly" && y / b < I || w === "proportional") {
              const E = Math.ceil(b * I);
              u *= E / y, y = E;
            }
          } else if (w === "proportional" && S === "stretchOnly" && I !== 0 && y / b > I) {
            const E = Math.ceil(y / I);
            h *= E / b, b = E;
          }
          return { x1: u, y1: h, x2: u + y, y2: h + b };
        }
        function ev(o, t, n, u, h, y) {
          const b = o.image;
          let w;
          if (b.content) {
            const ae = b.content, pe = b.pixelRatio || 1;
            w = [ae[0] / pe, ae[1] / pe, b.displaySize[0] - ae[2] / pe, b.displaySize[1] - ae[3] / pe];
          }
          const S = t.left * y, I = t.right * y;
          let E, B, N, G;
          n === "width" || n === "both" ? (G = h[0] + S - u[3], B = h[0] + I + u[1]) : (G = h[0] + (S + I - b.displaySize[0]) / 2, B = G + b.displaySize[0]);
          const q = t.top * y, K = t.bottom * y;
          return n === "height" || n === "both" ? (E = h[1] + q - u[0], N = h[1] + K + u[2]) : (E = h[1] + (q + K - b.displaySize[1]) / 2, N = E + b.displaySize[1]), { image: b, top: E, right: B, bottom: N, left: G, collisionPadding: w };
        }
        const Na = 128, ys = 32640;
        function tv(o, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new ri(o + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: u, interpolationType: h } = n;
            let y = 0;
            for (; y < u.length && u[y] <= o; ) y++;
            y = Math.max(0, y - 1);
            let b = y;
            for (; b < u.length && u[b] < o + 1; ) b++;
            b = Math.min(u.length - 1, b);
            const w = u[y], S = u[b];
            return n.kind === "composite" ? { kind: "composite", minZoom: w, maxZoom: S, interpolationType: h } : { kind: "camera", minZoom: w, maxZoom: S, minSize: n.evaluate(new ri(w)), maxSize: n.evaluate(new ri(S)), interpolationType: h };
          }
        }
        function am(o, t, n) {
          let u = "never";
          const h = o.get(t);
          return h ? u = h : o.get(n) && (u = "always"), u;
        }
        const aw = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function nf(o, t, n, u, h, y, b, w, S, I, E, B, N) {
          const G = w ? Math.min(ys, Math.round(w[0])) : 0, q = w ? Math.min(ys, Math.round(w[1])) : 0;
          o.emplaceBack(t, n, Math.round(32 * u), Math.round(32 * h), y, b, (G << 1) + (S ? 1 : 0), q, 16 * I, 16 * E, 256 * B, 256 * N);
        }
        function sm(o, t, n) {
          o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n);
        }
        function sw(o) {
          for (const t of o.sections) if (Uh(t.text)) return true;
          return false;
        }
        class lm {
          constructor(t) {
            this.layoutVertexArray = new Tt(), this.indexArray = new Xr(), this.programConfigurations = t, this.segments = new vr(), this.dynamicLayoutVertexArray = new pt(), this.opacityVertexArray = new Vt(), this.hasVisibleVertices = false, this.placedSymbolArray = new W();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, u, h) {
            this.isEmpty() || (u && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, zx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Fx.members, true), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, aw, true), this.opacityVertexBuffer.itemSize = 1), (u || h) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Ft("SymbolBuffers", lm);
        class um {
          constructor(t, n, u) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new u(), this.segments = new vr(), this.collisionVertexArray = new Or();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Lx.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Ft("CollisionBuffers", um);
        class Eu {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((b) => b.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = tv(this.zoom, n["text-size"]), this.iconSizeData = tv(this.zoom, n["icon-size"]);
            const u = this.layers[0].layout, h = u.get("symbol-sort-key"), y = u.get("symbol-z-order");
            this.canOverlap = am(u, "text-overlap", "text-allow-overlap") !== "never" || am(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && !h.isConstant(), this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map(((b) => m.ao[b]))), this.stateDependentLayerIds = this.layers.filter(((b) => b.isStateDependent())).map(((b) => b.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new lm(new Ln(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new lm(new Ln(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new ce(), this.lineVertexArray = new me(), this.symbolInstances = new se(), this.textAnchorOffsets = new ye();
          }
          calculateGlyphDependencies(t, n, u, h, y) {
            for (let b = 0; b < t.length; b++) if (n[t.charCodeAt(b)] = true, (u || h) && y) {
              const w = dd[t.charAt(b)];
              w && (n[w.charCodeAt(0)] = true);
            }
          }
          populate(t, n, u) {
            const h = this.layers[0], y = h.layout, b = y.get("text-font"), w = y.get("text-field"), S = y.get("icon-image"), I = (w.value.kind !== "constant" || w.value.value instanceof fn && !w.value.value.isEmpty() || w.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), E = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, B = y.get("symbol-sort-key");
            if (this.features = [], !I && !E) return;
            const N = n.iconDependencies, G = n.glyphDependencies, q = n.availableImages, K = new ri(this.zoom, { globalState: this.globalState });
            for (const { feature: ae, id: pe, index: Be, sourceLayerIndex: Ce } of t) {
              const Ie = h._featureFilter.needGeometry, He = Vo(ae, Ie);
              if (!h._featureFilter.filter(K, He, u)) continue;
              let rt, _t;
              if (Ie || (He.geometry = ha(ae)), I) {
                const Pt = h.getValueAndResolveTokens("text-field", He, u, q), Et = fn.factory(Pt), Wt = this.hasRTLText = this.hasRTLText || sw(Et);
                (!Wt || ao.getRTLTextPluginStatus() === "unavailable" || Wt && ao.isParsed()) && (rt = Ox(Et, h, He));
              }
              if (E) {
                const Pt = h.getValueAndResolveTokens("icon-image", He, u, q);
                _t = Pt instanceof zn ? Pt : zn.fromString(Pt);
              }
              if (!rt && !_t) continue;
              const At = this.sortFeaturesByKey ? B.evaluate(He, {}, u) : void 0;
              if (this.features.push({ id: pe, text: rt, icon: _t, index: Be, sourceLayerIndex: Ce, geometry: He.geometry, properties: ae.properties, type: Tu.types[ae.type], sortKey: At }), _t && (N[_t.name] = true), rt) {
                const Pt = b.evaluate(He, {}, u).join(","), Et = y.get("text-rotation-alignment") !== "viewport" && y.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(m.ao.vertical) >= 0;
                for (const Wt of rt.sections) if (Wt.image) N[Wt.image.name] = true;
                else {
                  const Mt = fu(rt.toString()), Rt = Wt.fontStack || Pt, ct = G[Rt] = G[Rt] || {};
                  this.calculateGlyphDependencies(Wt.text, ct, Et, this.allowVerticalPlacement, Mt);
                }
              }
            }
            y.get("symbol-placement") === "line" && (this.features = (function(ae) {
              const pe = {}, Be = {}, Ce = [];
              let Ie = 0;
              function He(Pt) {
                Ce.push(ae[Pt]), Ie++;
              }
              function rt(Pt, Et, Wt) {
                const Mt = Be[Pt];
                return delete Be[Pt], Be[Et] = Mt, Ce[Mt].geometry[0].pop(), Ce[Mt].geometry[0] = Ce[Mt].geometry[0].concat(Wt[0]), Mt;
              }
              function _t(Pt, Et, Wt) {
                const Mt = pe[Et];
                return delete pe[Et], pe[Pt] = Mt, Ce[Mt].geometry[0].shift(), Ce[Mt].geometry[0] = Wt[0].concat(Ce[Mt].geometry[0]), Mt;
              }
              function At(Pt, Et, Wt) {
                const Mt = Wt ? Et[0][Et[0].length - 1] : Et[0][0];
                return `${Pt}:${Mt.x}:${Mt.y}`;
              }
              for (let Pt = 0; Pt < ae.length; Pt++) {
                const Et = ae[Pt], Wt = Et.geometry, Mt = Et.text ? Et.text.toString() : null;
                if (!Mt) {
                  He(Pt);
                  continue;
                }
                const Rt = At(Mt, Wt), ct = At(Mt, Wt, true);
                if (Rt in Be && ct in pe && Be[Rt] !== pe[ct]) {
                  const or = _t(Rt, ct, Wt), hr = rt(Rt, ct, Ce[or].geometry);
                  delete pe[Rt], delete Be[ct], Be[At(Mt, Ce[hr].geometry, true)] = hr, Ce[or].geometry = null;
                } else Rt in Be ? rt(Rt, ct, Wt) : ct in pe ? _t(Rt, ct, Wt) : (He(Pt), pe[Rt] = Ie - 1, Be[ct] = Ie - 1);
              }
              return Ce.filter(((Pt) => Pt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ae, pe) => ae.sortKey - pe.sortKey));
          }
          update(t, n, u) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u, globalState: this.globalState }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u, globalState: this.globalState }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const u = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let h = t.dist(n[t.segment + 1]), y = t.dist(n[t.segment]);
              const b = {};
              for (let w = t.segment + 1; w < n.length; w++) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: h }, w < n.length - 1 && (h += n[w + 1].dist(n[w]));
              for (let w = t.segment || 0; w >= 0; w--) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: y }, w > 0 && (y += n[w - 1].dist(n[w]));
              for (let w = 0; w < n.length; w++) {
                const S = b[w];
                this.lineVertexArray.emplaceBack(S.x, S.y, S.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
          }
          addSymbols(t, n, u, h, y, b, w, S, I, E, B, N) {
            const G = t.indexArray, q = t.layoutVertexArray, K = t.segments.prepareSegment(4 * n.length, q, G, this.canOverlap ? b.sortKey : void 0), ae = this.glyphOffsetArray.length, pe = K.vertexLength, Be = this.allowVerticalPlacement && w === m.ao.vertical ? Math.PI / 2 : 0, Ce = b.text && b.text.sections;
            for (let Ie = 0; Ie < n.length; Ie++) {
              const { tl: He, tr: rt, bl: _t, br: At, tex: Pt, pixelOffsetTL: Et, pixelOffsetBR: Wt, minFontScaleX: Mt, minFontScaleY: Rt, glyphOffset: ct, isSDF: or, sectionIndex: hr } = n[Ie], Kt = K.vertexLength, Ut = ct[1];
              nf(q, S.x, S.y, He.x, Ut + He.y, Pt.x, Pt.y, u, or, Et.x, Et.y, Mt, Rt), nf(q, S.x, S.y, rt.x, Ut + rt.y, Pt.x + Pt.w, Pt.y, u, or, Wt.x, Et.y, Mt, Rt), nf(q, S.x, S.y, _t.x, Ut + _t.y, Pt.x, Pt.y + Pt.h, u, or, Et.x, Wt.y, Mt, Rt), nf(q, S.x, S.y, At.x, Ut + At.y, Pt.x + Pt.w, Pt.y + Pt.h, u, or, Wt.x, Wt.y, Mt, Rt), sm(t.dynamicLayoutVertexArray, S, Be), G.emplaceBack(Kt, Kt + 2, Kt + 1), G.emplaceBack(Kt + 1, Kt + 2, Kt + 3), K.vertexLength += 4, K.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ct[0]), Ie !== n.length - 1 && hr === n[Ie + 1].sectionIndex || t.programConfigurations.populatePaintArrays(q.length, b, b.index, { imagePositions: {}, canonical: N, formattedSection: Ce && Ce[hr], globalState: this.globalState });
            }
            t.placedSymbolArray.emplaceBack(S.x, S.y, ae, this.glyphOffsetArray.length - ae, pe, I, E, S.segment, u ? u[0] : 0, u ? u[1] : 0, h[0], h[1], w, 0, false, 0, B);
          }
          _addCollisionDebugVertex(t, n, u, h, y, b) {
            return n.emplaceBack(0, 0), t.emplaceBack(u.x, u.y, h, y, Math.round(b.x), Math.round(b.y));
          }
          addCollisionDebugVertices(t, n, u, h, y, b, w) {
            const S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), I = S.vertexLength, E = y.layoutVertexArray, B = y.collisionVertexArray, N = w.anchorX, G = w.anchorY;
            this._addCollisionDebugVertex(E, B, b, N, G, new C(t, n)), this._addCollisionDebugVertex(E, B, b, N, G, new C(u, n)), this._addCollisionDebugVertex(E, B, b, N, G, new C(u, h)), this._addCollisionDebugVertex(E, B, b, N, G, new C(t, h)), S.vertexLength += 4;
            const q = y.indexArray;
            q.emplaceBack(I, I + 1), q.emplaceBack(I + 1, I + 2), q.emplaceBack(I + 2, I + 3), q.emplaceBack(I + 3, I), S.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, u, h) {
            for (let y = t; y < n; y++) {
              const b = this.collisionBoxArray.get(y);
              this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, h ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, u);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new um(_r, V0.members, Gr), this.iconCollisionBox = new um(_r, V0.members, Gr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, false), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, u, h, y, b, w, S, I) {
            const E = {};
            for (let B = n; B < u; B++) {
              const N = t.get(B);
              E.textBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.textFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = h; B < y; B++) {
              const N = t.get(B);
              E.verticalTextBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.verticalTextFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = b; B < w; B++) {
              const N = t.get(B);
              E.iconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.iconFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = S; B < I; B++) {
              const N = t.get(B);
              E.verticalIconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.verticalIconFeatureIndex = N.featureIndex;
              break;
            }
            return E;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const u = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const u = t.placedSymbolArray.get(n), h = u.vertexStartIndex + 4 * u.numGlyphs;
            for (let y = u.vertexStartIndex; y < h; y += 4) t.indexArray.emplaceBack(y, y + 2, y + 1), t.indexArray.emplaceBack(y + 1, y + 2, y + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), u = Math.cos(t), h = [], y = [], b = [];
            for (let w = 0; w < this.symbolInstances.length; ++w) {
              b.push(w);
              const S = this.symbolInstances.get(w);
              h.push(0 | Math.round(n * S.anchorX + u * S.anchorY)), y.push(S.featureIndex);
            }
            return b.sort(((w, S) => h[w] - h[S] || y[S] - y[w])), b;
          }
          addToSortKeyRanges(t, n) {
            const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            u && u.sortKey === n ? u.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const u = this.symbolInstances.get(n);
                this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach(((h, y, b) => {
                  h >= 0 && b.indexOf(h) === y && this.addIndicesForPlacedSymbol(this.text, h);
                })), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let rv, iv;
        Ft("SymbolBucket", Eu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Eu.MAX_GLYPHS = 65535, Eu.addDynamicAttributes = sm;
        var cm = { get paint() {
          return iv = iv || new gn({ "icon-opacity": new er(Pe.paint_symbol["icon-opacity"]), "icon-color": new er(Pe.paint_symbol["icon-color"]), "icon-halo-color": new er(Pe.paint_symbol["icon-halo-color"]), "icon-halo-width": new er(Pe.paint_symbol["icon-halo-width"]), "icon-halo-blur": new er(Pe.paint_symbol["icon-halo-blur"]), "icon-translate": new Gt(Pe.paint_symbol["icon-translate"]), "icon-translate-anchor": new Gt(Pe.paint_symbol["icon-translate-anchor"]), "text-opacity": new er(Pe.paint_symbol["text-opacity"]), "text-color": new er(Pe.paint_symbol["text-color"], { runtimeType: oi, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }), "text-halo-color": new er(Pe.paint_symbol["text-halo-color"]), "text-halo-width": new er(Pe.paint_symbol["text-halo-width"]), "text-halo-blur": new er(Pe.paint_symbol["text-halo-blur"]), "text-translate": new Gt(Pe.paint_symbol["text-translate"]), "text-translate-anchor": new Gt(Pe.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return rv = rv || new gn({ "symbol-placement": new Gt(Pe.layout_symbol["symbol-placement"]), "symbol-spacing": new Gt(Pe.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Gt(Pe.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new er(Pe.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Gt(Pe.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Gt(Pe.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Gt(Pe.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Gt(Pe.layout_symbol["icon-ignore-placement"]), "icon-optional": new Gt(Pe.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Gt(Pe.layout_symbol["icon-rotation-alignment"]), "icon-size": new er(Pe.layout_symbol["icon-size"]), "icon-text-fit": new Gt(Pe.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Gt(Pe.layout_symbol["icon-text-fit-padding"]), "icon-image": new er(Pe.layout_symbol["icon-image"]), "icon-rotate": new er(Pe.layout_symbol["icon-rotate"]), "icon-padding": new er(Pe.layout_symbol["icon-padding"]), "icon-keep-upright": new Gt(Pe.layout_symbol["icon-keep-upright"]), "icon-offset": new er(Pe.layout_symbol["icon-offset"]), "icon-anchor": new er(Pe.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Gt(Pe.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Gt(Pe.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Gt(Pe.layout_symbol["text-rotation-alignment"]), "text-field": new er(Pe.layout_symbol["text-field"]), "text-font": new er(Pe.layout_symbol["text-font"]), "text-size": new er(Pe.layout_symbol["text-size"]), "text-max-width": new er(Pe.layout_symbol["text-max-width"]), "text-line-height": new Gt(Pe.layout_symbol["text-line-height"]), "text-letter-spacing": new er(Pe.layout_symbol["text-letter-spacing"]), "text-justify": new er(Pe.layout_symbol["text-justify"]), "text-radial-offset": new er(Pe.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Gt(Pe.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new er(Pe.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new er(Pe.layout_symbol["text-anchor"]), "text-max-angle": new Gt(Pe.layout_symbol["text-max-angle"]), "text-writing-mode": new Gt(Pe.layout_symbol["text-writing-mode"]), "text-rotate": new er(Pe.layout_symbol["text-rotate"]), "text-padding": new Gt(Pe.layout_symbol["text-padding"]), "text-keep-upright": new Gt(Pe.layout_symbol["text-keep-upright"]), "text-transform": new er(Pe.layout_symbol["text-transform"]), "text-offset": new er(Pe.layout_symbol["text-offset"]), "text-allow-overlap": new Gt(Pe.layout_symbol["text-allow-overlap"]), "text-overlap": new Gt(Pe.layout_symbol["text-overlap"]), "text-ignore-placement": new Gt(Pe.layout_symbol["text-ignore-placement"]), "text-optional": new Gt(Pe.layout_symbol["text-optional"]) });
        } };
        class nv {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : $r, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Ft("FormatSectionOverride", nv, { omit: ["defaultValue"] });
        class of extends Wn {
          constructor(t) {
            super(t, cm);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const u = this.layout.get("text-writing-mode");
              if (u) {
                const h = [];
                for (const y of u) h.indexOf(y) < 0 && h.push(y);
                this.layout._values["text-writing-mode"] = h;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, u, h) {
            const y = this.layout.get(t).evaluate(n, {}, u, h), b = this._unevaluatedLayout._values[t];
            return b.isDataDriven() || ou(b.value) || !y ? y : (function(w, S) {
              return S.replace(/{([^{}]+)}/g, ((I, E) => w && E in w ? String(w[E]) : ""));
            })(n.properties, y);
          }
          createBucket(t) {
            return new Eu(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of cm.paint.overridableProperties) {
              if (!of.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), u = new nv(n), h = new Ac(u, n.property.specification);
              let y = null;
              y = n.value.kind === "constant" || n.value.kind === "source" ? new tl("source", h) : new Dc("composite", h, n.value.zoomStops), this.paint._values[t] = new Io(n.property, y, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return !(!this.layout || n.isDataDriven() || u.isDataDriven()) && of.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const u = t.get("text-field"), h = cm.paint.properties[n];
            let y = false;
            const b = (w) => {
              for (const S of w) if (h.overrides && h.overrides.hasOverride(S)) return void (y = true);
            };
            if (u.value.kind === "constant" && u.value.value instanceof fn) b(u.value.value.sections);
            else if (u.value.kind === "source" || u.value.kind === "composite") {
              const w = (I) => {
                y || (I instanceof Oo && nr(I.value) === Un ? b(I.value.sections) : I instanceof Ta ? b(I.sections) : I.eachChild(w));
              }, S = u.value;
              S._styleExpression && w(S._styleExpression.expression);
            }
            return y;
          }
        }
        let ov;
        var lw = { get paint() {
          return ov = ov || new gn({ "background-color": new Gt(Pe.paint_background["background-color"]), "background-pattern": new sa(Pe.paint_background["background-pattern"]), "background-opacity": new Gt(Pe.paint_background["background-opacity"]) });
        } };
        class uw extends Wn {
          constructor(t) {
            super(t, lw);
          }
        }
        let av;
        var cw = { get paint() {
          return av = av || new gn({ "raster-opacity": new Gt(Pe.paint_raster["raster-opacity"]), "raster-hue-rotate": new Gt(Pe.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Gt(Pe.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Gt(Pe.paint_raster["raster-brightness-max"]), "raster-saturation": new Gt(Pe.paint_raster["raster-saturation"]), "raster-contrast": new Gt(Pe.paint_raster["raster-contrast"]), "raster-resampling": new Gt(Pe.paint_raster["raster-resampling"]), "raster-fade-duration": new Gt(Pe.paint_raster["raster-fade-duration"]) });
        } };
        class dw extends Wn {
          constructor(t) {
            super(t, cw);
          }
        }
        class hw extends Wn {
          constructor(t) {
            super(t, {}), this.onAdd = (n) => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
            }, this.onRemove = (n) => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class fw {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const pw = { once: true }, dm = 63710088e-1;
        class bs {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new bs(pr(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, u = this.lat * n, h = t.lat * n, y = Math.sin(u) * Math.sin(h) + Math.cos(u) * Math.cos(h) * Math.cos((t.lng - this.lng) * n);
            return dm * Math.acos(Math.min(y, 1));
          }
          static convert(t) {
            if (t instanceof bs) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new bs(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new bs(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const sv = 2 * Math.PI * dm;
        function lv(o) {
          return sv * Math.cos(o * Math.PI / 180);
        }
        function uv(o) {
          return (180 + o) / 360;
        }
        function cv(o) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o * Math.PI / 360))) / 360;
        }
        function dv(o, t) {
          return o / lv(t);
        }
        function hm(o) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90;
        }
        function hv(o, t) {
          return o * lv(hm(t));
        }
        class fd {
          constructor(t, n, u = 0) {
            this.x = +t, this.y = +n, this.z = +u;
          }
          static fromLngLat(t, n = 0) {
            const u = bs.convert(t);
            return new fd(uv(u.lng), cv(u.lat), dv(n, u.lat));
          }
          toLngLat() {
            return new bs(360 * this.x - 180, hm(this.y));
          }
          toAltitude() {
            return hv(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / sv * (t = hm(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function fv(o, t, n) {
          var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [o * u - 2 * Math.PI * 6378137 / 2, t * u - 2 * Math.PI * 6378137 / 2];
        }
        class fm {
          constructor(t, n, u) {
            if (!(function(h, y, b) {
              return !(h < 0 || h > 25 || b < 0 || b >= Math.pow(2, h) || y < 0 || y >= Math.pow(2, h));
            })(t, n, u)) throw new Error(`x=${n}, y=${u}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = u, this.key = Ru(0, t, t, n, u);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, u) {
            const h = (b = this.y, w = this.z, S = fv(256 * (y = this.x), 256 * (b = Math.pow(2, w) - b - 1), w), I = fv(256 * (y + 1), 256 * (b + 1), w), S[0] + "," + S[1] + "," + I[0] + "," + I[1]);
            var y, b, w, S, I;
            const E = (function(B, N, G) {
              let q, K = "";
              for (let ae = B; ae > 0; ae--) q = 1 << ae - 1, K += (N & q ? 1 : 0) + (G & q ? 2 : 0);
              return K;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, E).replace(/{bbox-epsg-3857}/g, h);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new C((t.x * n - this.x) * et, (t.y * n - this.y) * et);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class pv {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Ru(t, n.z, n.z, n.x, n.y);
          }
        }
        class co {
          constructor(t, n, u, h, y) {
            if (this.terrainRttPosMatrix32f = null, t < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${u}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new fm(u, +h, +y), this.key = Ru(n, t, u, h, y);
          }
          clone() {
            return new co(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new co(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new co(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - t;
            return t > this.canonical.z ? Ru(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Ru(this.wrap * +n, t, t, this.canonical.x >> u, this.canonical.y >> u);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return false;
            const n = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new co(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, u = 2 * this.canonical.x, h = 2 * this.canonical.y;
            return [new co(n, this.wrap, n, u, h), new co(n, this.wrap, n, u + 1, h), new co(n, this.wrap, n, u, h + 1), new co(n, this.wrap, n, u + 1, h + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new co(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new co(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new pv(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new fd(t.x - this.wrap, t.y));
          }
        }
        function Ru(o, t, n, u, h) {
          (o *= 2) < 0 && (o = -1 * o - 1);
          const y = 1 << n;
          return (y * y * o + y * h + u).toString(36) + n.toString(36) + t.toString(36);
        }
        function pd(o, t) {
          return t ? o.properties[t] : o.id;
        }
        Ft("CanonicalTileID", fm), Ft("OverscaledTileID", co, { omit: ["terrainRttPosMatrix32f"] });
        class pl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const n = new pl();
            return n.extend(t(new C(this.minX, this.minY))), n.extend(t(new C(this.maxX, this.minY))), n.extend(t(new C(this.minX, this.maxY))), n.extend(t(new C(this.maxX, this.maxY))), n;
          }
          static fromPoints(t) {
            const n = new pl();
            for (const u of t) n.extend(u);
            return n;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class mv {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const u = t[n];
              this._stringToNumber[u] = n, this._numberToString[n] = u;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class gv {
          constructor(t, n, u, h, y) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = u, t._y = h, this.properties = t.properties, this.id = y;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class vv {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ll(et, 16, 0), this.grid3D = new ll(et, 16, 0), this.featureIndexArray = new Me(), this.promoteId = n;
          }
          insert(t, n, u, h, y, b) {
            const w = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(u, h, y);
            const S = b ? this.grid3D : this.grid;
            for (let I = 0; I < n.length; I++) {
              const E = n[I], B = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let N = 0; N < E.length; N++) {
                const G = E[N];
                B[0] = Math.min(B[0], G.x), B[1] = Math.min(B[1], G.y), B[2] = Math.max(B[2], G.x), B[3] = Math.max(B[3], G.y);
              }
              B[0] < et && B[1] < et && B[2] >= 0 && B[3] >= 0 && S.insert(w, B[0], B[1], B[2], B[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new D0(new rm(this.rawTileData)).layers, this.sourceLayerCoder = new mv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, u, h) {
            this.loadVTLayers();
            const y = t.params, b = et / t.tileSize / t.scale, w = Da(y.filter), S = t.queryGeometry, I = t.queryPadding * b, E = pl.fromPoints(S), B = this.grid.query(E.minX - I, E.minY - I, E.maxX + I, E.maxY + I), N = pl.fromPoints(t.cameraQueryGeometry).expandBy(I), G = this.grid3D.query(N.minX, N.minY, N.maxX, N.maxY, ((ae, pe, Be, Ce) => (function(Ie, He, rt, _t, At) {
              for (const Et of Ie) if (He <= Et.x && rt <= Et.y && _t >= Et.x && At >= Et.y) return true;
              const Pt = [new C(He, rt), new C(He, At), new C(_t, At), new C(_t, rt)];
              if (Ie.length > 2) {
                for (const Et of Pt) if (Cu(Ie, Et)) return true;
              }
              for (let Et = 0; Et < Ie.length - 1; Et++) if (W1(Ie[Et], Ie[Et + 1], Pt)) return true;
              return false;
            })(t.cameraQueryGeometry, ae - I, pe - I, Be + I, Ce + I)));
            for (const ae of G) B.push(ae);
            B.sort(mw);
            const q = {};
            let K;
            for (let ae = 0; ae < B.length; ae++) {
              const pe = B[ae];
              if (pe === K) continue;
              K = pe;
              const Be = this.featureIndexArray.get(pe);
              let Ce = null;
              this.loadMatchingFeature(q, Be.bucketIndex, Be.sourceLayerIndex, Be.featureIndex, w, y.layers, y.availableImages, n, u, h, ((Ie, He, rt) => (Ce || (Ce = ha(Ie)), He.queryIntersectsFeature({ queryGeometry: S, feature: Ie, featureState: rt, geometry: Ce, zoom: this.z, transform: t.transform, pixelsToTileUnits: b, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return q;
          }
          loadMatchingFeature(t, n, u, h, y, b, w, S, I, E, B) {
            const N = this.bucketLayerIDs[n];
            if (b && !N.some(((ae) => b.has(ae)))) return;
            const G = this.sourceLayerCoder.decode(u), q = this.vtLayers[G].feature(h);
            if (y.needGeometry) {
              const ae = Vo(q, true);
              if (!y.filter(new ri(this.tileID.overscaledZ), ae, this.tileID.canonical)) return;
            } else if (!y.filter(new ri(this.tileID.overscaledZ), q)) return;
            const K = this.getId(q, G);
            for (let ae = 0; ae < N.length; ae++) {
              const pe = N[ae];
              if (b && !b.has(pe)) continue;
              const Be = S[pe];
              if (!Be) continue;
              let Ce = {};
              K && E && (Ce = E.getState(Be.sourceLayer || "_geojsonTileLayer", K));
              const Ie = Jt({}, I[pe]);
              Ie.paint = _v(Ie.paint, Be.paint, q, Ce, w), Ie.layout = _v(Ie.layout, Be.layout, q, Ce, w);
              const He = !B || B(q, Be, Ce);
              if (!He) continue;
              const rt = new gv(q, this.z, this.x, this.y, K);
              rt.layer = Ie;
              let _t = t[pe];
              _t === void 0 && (_t = t[pe] = []), _t.push({ featureIndex: h, feature: rt, intersectionZ: He });
            }
          }
          lookupSymbolFeatures(t, n, u, h, y, b, w, S) {
            const I = {};
            this.loadVTLayers();
            const E = Da(y);
            for (const B of t) this.loadMatchingFeature(I, u, h, B, E, b, w, S, n);
            return I;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const u of n) if (t === u) return true;
            return false;
          }
          getId(t, n) {
            var u;
            let h = t.id;
            return this.promoteId && (h = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof h == "boolean" && (h = Number(h)), h === void 0 && (!((u = t.properties) === null || u === void 0) && u.cluster) && this.promoteId && (h = Number(t.properties.cluster_id))), h;
          }
        }
        function _v(o, t, n, u, h) {
          return wr(o, ((y, b) => {
            const w = t instanceof mu ? t.get(b) : null;
            return w && w.evaluate ? w.evaluate(n, u, h) : w;
          }));
        }
        function mw(o, t) {
          return t - o;
        }
        function yv(o, t, n, u, h) {
          const y = [];
          for (let b = 0; b < o.length; b++) {
            const w = o[b];
            let S;
            for (let I = 0; I < w.length - 1; I++) {
              let E = w[I], B = w[I + 1];
              E.x < t && B.x < t || (E.x < t ? E = new C(t, E.y + (t - E.x) / (B.x - E.x) * (B.y - E.y))._round() : B.x < t && (B = new C(t, E.y + (t - E.x) / (B.x - E.x) * (B.y - E.y))._round()), E.y < n && B.y < n || (E.y < n ? E = new C(E.x + (n - E.y) / (B.y - E.y) * (B.x - E.x), n)._round() : B.y < n && (B = new C(E.x + (n - E.y) / (B.y - E.y) * (B.x - E.x), n)._round()), E.x >= u && B.x >= u || (E.x >= u ? E = new C(u, E.y + (u - E.x) / (B.x - E.x) * (B.y - E.y))._round() : B.x >= u && (B = new C(u, E.y + (u - E.x) / (B.x - E.x) * (B.y - E.y))._round()), E.y >= h && B.y >= h || (E.y >= h ? E = new C(E.x + (h - E.y) / (B.y - E.y) * (B.x - E.x), h)._round() : B.y >= h && (B = new C(E.x + (h - E.y) / (B.y - E.y) * (B.x - E.x), h)._round()), S && E.equals(S[S.length - 1]) || (S = [E], y.push(S)), S.push(B)))));
            }
          }
          return y;
        }
        Ft("FeatureIndex", vv, { omit: ["rawTileData", "sourceLayerCoder"] });
        class xs extends C {
          constructor(t, n, u, h) {
            super(t, n), this.angle = u, h !== void 0 && (this.segment = h);
          }
          clone() {
            return new xs(this.x, this.y, this.angle, this.segment);
          }
        }
        function bv(o, t, n, u, h) {
          if (t.segment === void 0 || n === 0) return true;
          let y = t, b = t.segment + 1, w = 0;
          for (; w > -n / 2; ) {
            if (b--, b < 0) return false;
            w -= o[b].dist(y), y = o[b];
          }
          w += o[b].dist(o[b + 1]), b++;
          const S = [];
          let I = 0;
          for (; w < n / 2; ) {
            const E = o[b], B = o[b + 1];
            if (!B) return false;
            let N = o[b - 1].angleTo(E) - E.angleTo(B);
            for (N = Math.abs((N + 3 * Math.PI) % (2 * Math.PI) - Math.PI), S.push({ distance: w, angleDelta: N }), I += N; w - S[0].distance > u; ) I -= S.shift().angleDelta;
            if (I > h) return false;
            b++, w += E.dist(B);
          }
          return true;
        }
        function xv(o) {
          let t = 0;
          for (let n = 0; n < o.length - 1; n++) t += o[n].dist(o[n + 1]);
          return t;
        }
        function wv(o, t, n) {
          return o ? 0.6 * t * n : 0;
        }
        function Cv(o, t) {
          return Math.max(o ? o.right - o.left : 0, t ? t.right - t.left : 0);
        }
        function gw(o, t, n, u, h, y) {
          const b = wv(n, h, y), w = Cv(n, u) * y;
          let S = 0;
          const I = xv(o) / 2;
          for (let E = 0; E < o.length - 1; E++) {
            const B = o[E], N = o[E + 1], G = B.dist(N);
            if (S + G > I) {
              const q = (I - S) / G, K = Po.number(B.x, N.x, q), ae = Po.number(B.y, N.y, q), pe = new xs(K, ae, N.angleTo(B), E);
              return pe._round(), !b || bv(o, pe, w, b, t) ? pe : void 0;
            }
            S += G;
          }
        }
        function vw(o, t, n, u, h, y, b, w, S) {
          const I = wv(u, y, b), E = Cv(u, h), B = E * b, N = o[0].x === 0 || o[0].x === S || o[0].y === 0 || o[0].y === S;
          return t - B < t / 4 && (t = B + t / 4), Sv(o, N ? t / 2 * w % t : (E / 2 + 2 * y) * b * w % t, t, I, n, B, N, false, S);
        }
        function Sv(o, t, n, u, h, y, b, w, S) {
          const I = y / 2, E = xv(o);
          let B = 0, N = t - n, G = [];
          for (let q = 0; q < o.length - 1; q++) {
            const K = o[q], ae = o[q + 1], pe = K.dist(ae), Be = ae.angleTo(K);
            for (; N + n < B + pe; ) {
              N += n;
              const Ce = (N - B) / pe, Ie = Po.number(K.x, ae.x, Ce), He = Po.number(K.y, ae.y, Ce);
              if (Ie >= 0 && Ie < S && He >= 0 && He < S && N - I >= 0 && N + I <= E) {
                const rt = new xs(Ie, He, Be, q);
                rt._round(), u && !bv(o, rt, y, u, h) || G.push(rt);
              }
            }
            B += pe;
          }
          return w || G.length || b || (G = Sv(o, B / 2, n, u, h, y, b, true, S)), G;
        }
        function kv(o, t, n, u) {
          const h = [], y = o.image, b = y.pixelRatio, w = y.paddedRect.w - 2, S = y.paddedRect.h - 2;
          let I = { x1: o.left, y1: o.top, x2: o.right, y2: o.bottom };
          const E = y.stretchX || [[0, w]], B = y.stretchY || [[0, S]], N = (ct, or) => ct + or[1] - or[0], G = E.reduce(N, 0), q = B.reduce(N, 0), K = w - G, ae = S - q;
          let pe = 0, Be = G, Ce = 0, Ie = q, He = 0, rt = K, _t = 0, At = ae;
          if (y.content && u) {
            const ct = y.content, or = ct[2] - ct[0], hr = ct[3] - ct[1];
            (y.textFitWidth || y.textFitHeight) && (I = Q0(o)), pe = af(E, 0, ct[0]), Ce = af(B, 0, ct[1]), Be = af(E, ct[0], ct[2]), Ie = af(B, ct[1], ct[3]), He = ct[0] - pe, _t = ct[1] - Ce, rt = or - Be, At = hr - Ie;
          }
          const Pt = I.x1, Et = I.y1, Wt = I.x2 - Pt, Mt = I.y2 - Et, Rt = (ct, or, hr, Kt) => {
            const Ut = sf(ct.stretch - pe, Be, Wt, Pt), Mr = lf(ct.fixed - He, rt, ct.stretch, G), _i = sf(or.stretch - Ce, Ie, Mt, Et), Li = lf(or.fixed - _t, At, or.stretch, q), sn = sf(hr.stretch - pe, Be, Wt, Pt), ho = lf(hr.fixed - He, rt, hr.stretch, G), On = sf(Kt.stretch - Ce, Ie, Mt, Et), Xi = lf(Kt.fixed - _t, At, Kt.stretch, q), hi = new C(Ut, _i), Ui = new C(sn, _i), Yi = new C(sn, On), Ki = new C(Ut, On), In = new C(Mr / b, Li / b), fo = new C(ho / b, Xi / b), Gi = t * Math.PI / 180;
            if (Gi) {
              const qi = Math.sin(Gi), Wi = Math.cos(Gi), Ei = [Wi, -qi, qi, Wi];
              hi._matMult(Ei), Ui._matMult(Ei), Ki._matMult(Ei), Yi._matMult(Ei);
            }
            const $n = ct.stretch + ct.fixed, Bi = or.stretch + or.fixed;
            return { tl: hi, tr: Ui, bl: Ki, br: Yi, tex: { x: y.paddedRect.x + 1 + $n, y: y.paddedRect.y + 1 + Bi, w: hr.stretch + hr.fixed - $n, h: Kt.stretch + Kt.fixed - Bi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: In, pixelOffsetBR: fo, minFontScaleX: rt / b / Wt, minFontScaleY: At / b / Mt, isSDF: n };
          };
          if (u && (y.stretchX || y.stretchY)) {
            const ct = Pv(E, K, G), or = Pv(B, ae, q);
            for (let hr = 0; hr < ct.length - 1; hr++) {
              const Kt = ct[hr], Ut = ct[hr + 1];
              for (let Mr = 0; Mr < or.length - 1; Mr++) h.push(Rt(Kt, or[Mr], Ut, or[Mr + 1]));
            }
          } else h.push(Rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: w + 1 }, { fixed: 0, stretch: S + 1 }));
          return h;
        }
        function af(o, t, n) {
          let u = 0;
          for (const h of o) u += Math.max(t, Math.min(n, h[1])) - Math.max(t, Math.min(n, h[0]));
          return u;
        }
        function Pv(o, t, n) {
          const u = [{ fixed: -1, stretch: 0 }];
          for (const [h, y] of o) {
            const b = u[u.length - 1];
            u.push({ fixed: h - b.stretch, stretch: b.stretch }), u.push({ fixed: h - b.stretch, stretch: b.stretch + (y - h) });
          }
          return u.push({ fixed: t + 1, stretch: n }), u;
        }
        function sf(o, t, n, u) {
          return o / t * n + u;
        }
        function lf(o, t, n, u) {
          return o - t * n / u;
        }
        Ft("Anchor", xs);
        class uf {
          constructor(t, n, u, h, y, b, w, S, I, E) {
            var B;
            if (this.boxStartIndex = t.length, I) {
              let N = b.top, G = b.bottom;
              const q = b.collisionPadding;
              q && (N -= q[1], G += q[3]);
              let K = G - N;
              K > 0 && (K = Math.max(10, K), this.circleDiameter = K);
            } else {
              const N = !((B = b.image) === null || B === void 0) && B.content && (b.image.textFitWidth || b.image.textFitHeight) ? Q0(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
              N.y1 = N.y1 * w - S[0], N.y2 = N.y2 * w + S[2], N.x1 = N.x1 * w - S[3], N.x2 = N.x2 * w + S[1];
              const G = b.collisionPadding;
              if (G && (N.x1 -= G[0] * w, N.y1 -= G[1] * w, N.x2 += G[2] * w, N.y2 += G[3] * w), E) {
                const q = new C(N.x1, N.y1), K = new C(N.x2, N.y1), ae = new C(N.x1, N.y2), pe = new C(N.x2, N.y2), Be = E * Math.PI / 180;
                q._rotate(Be), K._rotate(Be), ae._rotate(Be), pe._rotate(Be), N.x1 = Math.min(q.x, K.x, ae.x, pe.x), N.x2 = Math.max(q.x, K.x, ae.x, pe.x), N.y1 = Math.min(q.y, K.y, ae.y, pe.y), N.y2 = Math.max(q.y, K.y, ae.y, pe.y);
              }
              t.emplaceBack(n.x, n.y, N.x1, N.y1, N.x2, N.y2, u, h, y);
            }
            this.boxEndIndex = t.length;
          }
        }
        class _w {
          constructor(t = [], n = (u, h) => u < h ? -1 : u > h ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: u } = this, h = n[t];
            for (; t > 0; ) {
              const y = t - 1 >> 1, b = n[y];
              if (u(h, b) >= 0) break;
              n[t] = b, t = y;
            }
            n[t] = h;
          }
          _down(t) {
            const { data: n, compare: u } = this, h = this.length >> 1, y = n[t];
            for (; t < h; ) {
              let b = 1 + (t << 1);
              const w = b + 1;
              if (w < this.length && u(n[w], n[b]) < 0 && (b = w), u(n[b], y) >= 0) break;
              n[t] = n[b], t = b;
            }
            n[t] = y;
          }
        }
        function yw(o, t = 1, n = false) {
          const u = pl.fromPoints(o[0]), h = Math.min(u.width(), u.height());
          let y = h / 2;
          const b = new _w([], bw), { minX: w, minY: S, maxX: I, maxY: E } = u;
          if (h === 0) return new C(w, S);
          for (let G = w; G < I; G += h) for (let q = S; q < E; q += h) b.push(new Au(G + y, q + y, y, o));
          let B = (function(G) {
            let q = 0, K = 0, ae = 0;
            const pe = G[0];
            for (let Be = 0, Ce = pe.length, Ie = Ce - 1; Be < Ce; Ie = Be++) {
              const He = pe[Be], rt = pe[Ie], _t = He.x * rt.y - rt.x * He.y;
              K += (He.x + rt.x) * _t, ae += (He.y + rt.y) * _t, q += 3 * _t;
            }
            return new Au(K / q, ae / q, 0, G);
          })(o), N = b.length;
          for (; b.length; ) {
            const G = b.pop();
            (G.d > B.d || !B.d) && (B = G, n && console.log("found best %d after %d probes", Math.round(1e4 * G.d) / 1e4, N)), G.max - B.d <= t || (y = G.h / 2, b.push(new Au(G.p.x - y, G.p.y - y, y, o)), b.push(new Au(G.p.x + y, G.p.y - y, y, o)), b.push(new Au(G.p.x - y, G.p.y + y, y, o)), b.push(new Au(G.p.x + y, G.p.y + y, y, o)), N += 4);
          }
          return n && (console.log(`num probes: ${N}`), console.log(`best distance: ${B.d}`)), B.p;
        }
        function bw(o, t) {
          return t.max - o.max;
        }
        function Au(o, t, n, u) {
          this.p = new C(o, t), this.h = n, this.d = (function(h, y) {
            let b = false, w = 1 / 0;
            for (let S = 0; S < y.length; S++) {
              const I = y[S];
              for (let E = 0, B = I.length, N = B - 1; E < B; N = E++) {
                const G = I[E], q = I[N];
                G.y > h.y != q.y > h.y && h.x < (q.x - G.x) * (h.y - G.y) / (q.y - G.y) + G.x && (b = !b), w = Math.min(w, c0(h, G, q));
              }
            }
            return (b ? 1 : -1) * Math.sqrt(w);
          })(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
        var an;
        m.aE = void 0, (an = m.aE || (m.aE = {}))[an.center = 1] = "center", an[an.left = 2] = "left", an[an.right = 3] = "right", an[an.top = 4] = "top", an[an.bottom = 5] = "bottom", an[an["top-left"] = 6] = "top-left", an[an["top-right"] = 7] = "top-right", an[an["bottom-left"] = 8] = "bottom-left", an[an["bottom-right"] = 9] = "bottom-right";
        const pm = Number.POSITIVE_INFINITY;
        function Tv(o, t) {
          return t[1] !== pm ? (function(n, u, h) {
            let y = 0, b = 0;
            switch (u = Math.abs(u), h = Math.abs(h), n) {
              case "top-right":
              case "top-left":
              case "top":
                b = h - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                b = 7 - h;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                y = -u;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                y = u;
            }
            return [y, b];
          })(o, t[0], t[1]) : (function(n, u) {
            let h = 0, y = 0;
            u < 0 && (u = 0);
            const b = u / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                y = b - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                y = 7 - b;
                break;
              case "bottom":
                y = 7 - u;
                break;
              case "top":
                y = u - 7;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                h = -b;
                break;
              case "top-left":
              case "bottom-left":
                h = b;
                break;
              case "left":
                h = u;
                break;
              case "right":
                h = -u;
            }
            return [h, y];
          })(o, t[0]);
        }
        function Iv(o, t, n) {
          var u;
          const h = o.layout, y = (u = h.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(t, {}, n);
          if (y) {
            const w = y.values, S = [];
            for (let I = 0; I < w.length; I += 2) {
              const E = S[I] = w[I], B = w[I + 1].map(((N) => N * Vi));
              E.startsWith("top") ? B[1] -= 7 : E.startsWith("bottom") && (B[1] += 7), S[I + 1] = B;
            }
            return new mn(S);
          }
          const b = h.get("text-variable-anchor");
          if (b) {
            let w;
            w = o._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [h.get("text-radial-offset").evaluate(t, {}, n) * Vi, pm] : h.get("text-offset").evaluate(t, {}, n).map(((I) => I * Vi));
            const S = [];
            for (const I of b) S.push(I, Tv(I, w));
            return new mn(S);
          }
          return null;
        }
        function mm(o) {
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function xw(o, t, n, u, h, y, b, w, S, I, E, B) {
          let N = y.textMaxSize.evaluate(t, {});
          N === void 0 && (N = b);
          const G = o.layers[0].layout, q = G.get("icon-offset").evaluate(t, {}, E), K = Ev(n.horizontal), ae = b / 24, pe = o.tilePixelRatio * ae, Be = o.tilePixelRatio * N / 24, Ce = o.tilePixelRatio * w, Ie = o.tilePixelRatio * G.get("symbol-spacing"), He = G.get("text-padding") * o.tilePixelRatio, rt = (function(hr, Kt, Ut, Mr = 1) {
            const _i = hr.get("icon-padding").evaluate(Kt, {}, Ut), Li = _i && _i.values;
            return [Li[0] * Mr, Li[1] * Mr, Li[2] * Mr, Li[3] * Mr];
          })(G, t, E, o.tilePixelRatio), _t = G.get("text-max-angle") / 180 * Math.PI, At = G.get("text-rotation-alignment") !== "viewport" && G.get("symbol-placement") !== "point", Pt = G.get("icon-rotation-alignment") === "map" && G.get("symbol-placement") !== "point", Et = G.get("symbol-placement"), Wt = Ie / 2, Mt = G.get("icon-text-fit");
          let Rt;
          u && Mt !== "none" && (o.allowVerticalPlacement && n.vertical && (Rt = ev(u, n.vertical, Mt, G.get("icon-text-fit-padding"), q, ae)), K && (u = ev(u, K, Mt, G.get("icon-text-fit-padding"), q, ae)));
          const ct = E ? B.line.getGranularityForZoomLevel(E.z) : 1, or = (hr, Kt) => {
            Kt.x < 0 || Kt.x >= et || Kt.y < 0 || Kt.y >= et || (function(Ut, Mr, _i, Li, sn, ho, On, Xi, hi, Ui, Yi, Ki, In, fo, Gi, $n, Bi, qi, Wi, Ei, li, Uo, Du, Go, Sw) {
              const zu = Ut.addToLineVertexArray(Mr, _i);
              let ml, Fu, Lu, Bu, zv = 0, Fv = 0, Lv = 0, Bv = 0, Cm = -1, Sm = -1;
              const Va = {};
              let Ov = gs("");
              if (Ut.allowVerticalPlacement && Li.vertical) {
                const yn = Xi.layout.get("text-rotate").evaluate(li, {}, Go) + 90;
                Lu = new uf(hi, Mr, Ui, Yi, Ki, Li.vertical, In, fo, Gi, yn), On && (Bu = new uf(hi, Mr, Ui, Yi, Ki, On, Bi, qi, Gi, yn));
              }
              if (sn) {
                const yn = Xi.layout.get("icon-rotate").evaluate(li, {}), po = Xi.layout.get("icon-text-fit") !== "none", gl = kv(sn, yn, Du, po), Wo = On ? kv(On, yn, Du, po) : void 0;
                Fu = new uf(hi, Mr, Ui, Yi, Ki, sn, Bi, qi, false, yn), zv = 4 * gl.length;
                const vl = Ut.iconSizeData;
                let fa = null;
                vl.kind === "source" ? (fa = [Na * Xi.layout.get("icon-size").evaluate(li, {})], fa[0] > ys && qt(`${Ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : vl.kind === "composite" && (fa = [Na * Uo.compositeIconSizes[0].evaluate(li, {}, Go), Na * Uo.compositeIconSizes[1].evaluate(li, {}, Go)], (fa[0] > ys || fa[1] > ys) && qt(`${Ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Ut.addSymbols(Ut.icon, gl, fa, Ei, Wi, li, m.ao.none, Mr, zu.lineStartIndex, zu.lineLength, -1, Go), Cm = Ut.icon.placedSymbolArray.length - 1, Wo && (Fv = 4 * Wo.length, Ut.addSymbols(Ut.icon, Wo, fa, Ei, Wi, li, m.ao.vertical, Mr, zu.lineStartIndex, zu.lineLength, -1, Go), Sm = Ut.icon.placedSymbolArray.length - 1);
              }
              const $v = Object.keys(Li.horizontal);
              for (const yn of $v) {
                const po = Li.horizontal[yn];
                if (!ml) {
                  Ov = gs(po.text);
                  const Wo = Xi.layout.get("text-rotate").evaluate(li, {}, Go);
                  ml = new uf(hi, Mr, Ui, Yi, Ki, po, In, fo, Gi, Wo);
                }
                const gl = po.positionedLines.length === 1;
                if (Lv += Mv(Ut, Mr, po, ho, Xi, Gi, li, $n, zu, Li.vertical ? m.ao.horizontal : m.ao.horizontalOnly, gl ? $v : [yn], Va, Cm, Uo, Go), gl) break;
              }
              Li.vertical && (Bv += Mv(Ut, Mr, Li.vertical, ho, Xi, Gi, li, $n, zu, m.ao.vertical, ["vertical"], Va, Sm, Uo, Go));
              const kw = ml ? ml.boxStartIndex : Ut.collisionBoxArray.length, Pw = ml ? ml.boxEndIndex : Ut.collisionBoxArray.length, Tw = Lu ? Lu.boxStartIndex : Ut.collisionBoxArray.length, Iw = Lu ? Lu.boxEndIndex : Ut.collisionBoxArray.length, Mw = Fu ? Fu.boxStartIndex : Ut.collisionBoxArray.length, Ew = Fu ? Fu.boxEndIndex : Ut.collisionBoxArray.length, Rw = Bu ? Bu.boxStartIndex : Ut.collisionBoxArray.length, Aw = Bu ? Bu.boxEndIndex : Ut.collisionBoxArray.length;
              let qo = -1;
              const df = (yn, po) => yn && yn.circleDiameter ? Math.max(yn.circleDiameter, po) : po;
              qo = df(ml, qo), qo = df(Lu, qo), qo = df(Fu, qo), qo = df(Bu, qo);
              const jv = qo > -1 ? 1 : 0;
              jv && (qo *= Sw / Vi), Ut.glyphOffsetArray.length >= Eu.MAX_GLYPHS && qt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), li.sortKey !== void 0 && Ut.addToSortKeyRanges(Ut.symbolInstances.length, li.sortKey);
              const Dw = Iv(Xi, li, Go), [zw, Fw] = (function(yn, po) {
                const gl = yn.length, Wo = po == null ? void 0 : po.values;
                if ((Wo == null ? void 0 : Wo.length) > 0) for (let vl = 0; vl < Wo.length; vl += 2) {
                  const fa = Wo[vl + 1];
                  yn.emplaceBack(m.aE[Wo[vl]], fa[0], fa[1]);
                }
                return [gl, yn.length];
              })(Ut.textAnchorOffsets, Dw);
              Ut.symbolInstances.emplaceBack(Mr.x, Mr.y, Va.right >= 0 ? Va.right : -1, Va.center >= 0 ? Va.center : -1, Va.left >= 0 ? Va.left : -1, Va.vertical || -1, Cm, Sm, Ov, kw, Pw, Tw, Iw, Mw, Ew, Rw, Aw, Ui, Lv, Bv, zv, Fv, jv, 0, In, qo, zw, Fw);
            })(o, Kt, hr, n, u, h, Rt, o.layers[0], o.collisionBoxArray, t.index, t.sourceLayerIndex, o.index, pe, [He, He, He, He], At, S, Ce, rt, Pt, q, t, y, I, E, b);
          };
          if (Et === "line") for (const hr of yv(t.geometry, 0, 0, et, et)) {
            const Kt = fl(hr, ct), Ut = vw(Kt, Ie, _t, n.vertical || K, u, 24, Be, o.overscaling, et);
            for (const Mr of Ut) K && ww(o, K.text, Wt, Mr) || or(Kt, Mr);
          }
          else if (Et === "line-center") {
            for (const hr of t.geometry) if (hr.length > 1) {
              const Kt = fl(hr, ct), Ut = gw(Kt, _t, n.vertical || K, u, 24, Be);
              Ut && or(Kt, Ut);
            }
          } else if (t.type === "Polygon") for (const hr of Ys(t.geometry, 0)) {
            const Kt = yw(hr, 16);
            or(fl(hr[0], ct, true), new xs(Kt.x, Kt.y, 0));
          }
          else if (t.type === "LineString") for (const hr of t.geometry) {
            const Kt = fl(hr, ct);
            or(Kt, new xs(Kt[0].x, Kt[0].y, 0));
          }
          else if (t.type === "Point") for (const hr of t.geometry) for (const Kt of hr) or([Kt], new xs(Kt.x, Kt.y, 0));
        }
        function Mv(o, t, n, u, h, y, b, w, S, I, E, B, N, G, q) {
          const K = (function(Be, Ce, Ie, He, rt, _t, At, Pt) {
            const Et = He.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180, Wt = [];
            for (const Mt of Ce.positionedLines) for (const Rt of Mt.positionedGlyphs) {
              if (!Rt.rect) continue;
              const ct = Rt.rect || {};
              let or = 4, hr = true, Kt = 1, Ut = 0;
              const Mr = (rt || Pt) && Rt.vertical, _i = Rt.metrics.advance * Rt.scale / 2;
              if (Pt && Ce.verticalizable && (Ut = Mt.lineOffset / 2 - (Rt.imageName ? -(Vi - Rt.metrics.width * Rt.scale) / 2 : (Rt.scale - 1) * Vi)), Rt.imageName) {
                const qi = At[Rt.imageName];
                hr = qi.sdf, Kt = qi.pixelRatio, or = 1 / Kt;
              }
              const Li = rt ? [Rt.x + _i, Rt.y] : [0, 0];
              let sn = rt ? [0, 0] : [Rt.x + _i + Ie[0], Rt.y + Ie[1] - Ut], ho = [0, 0];
              Mr && (ho = sn, sn = [0, 0]);
              const On = Rt.metrics.isDoubleResolution ? 2 : 1, Xi = (Rt.metrics.left - or) * Rt.scale - _i + sn[0], hi = (-Rt.metrics.top - or) * Rt.scale + sn[1], Ui = Xi + ct.w / On * Rt.scale / Kt, Yi = hi + ct.h / On * Rt.scale / Kt, Ki = new C(Xi, hi), In = new C(Ui, hi), fo = new C(Xi, Yi), Gi = new C(Ui, Yi);
              if (Mr) {
                const qi = new C(-_i, _i - -17), Wi = -Math.PI / 2, Ei = 12 - _i, li = new C(22 - Ei, -(Rt.imageName ? Ei : 0)), Uo = new C(...ho);
                Ki._rotateAround(Wi, qi)._add(li)._add(Uo), In._rotateAround(Wi, qi)._add(li)._add(Uo), fo._rotateAround(Wi, qi)._add(li)._add(Uo), Gi._rotateAround(Wi, qi)._add(li)._add(Uo);
              }
              if (Et) {
                const qi = Math.sin(Et), Wi = Math.cos(Et), Ei = [Wi, -qi, qi, Wi];
                Ki._matMult(Ei), In._matMult(Ei), fo._matMult(Ei), Gi._matMult(Ei);
              }
              const $n = new C(0, 0), Bi = new C(0, 0);
              Wt.push({ tl: Ki, tr: In, bl: fo, br: Gi, tex: ct, writingMode: Ce.writingMode, glyphOffset: Li, sectionIndex: Rt.sectionIndex, isSDF: hr, pixelOffsetTL: $n, pixelOffsetBR: Bi, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Wt;
          })(0, n, w, h, y, b, u, o.allowVerticalPlacement), ae = o.textSizeData;
          let pe = null;
          ae.kind === "source" ? (pe = [Na * h.layout.get("text-size").evaluate(b, {})], pe[0] > ys && qt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ae.kind === "composite" && (pe = [Na * G.compositeTextSizes[0].evaluate(b, {}, q), Na * G.compositeTextSizes[1].evaluate(b, {}, q)], (pe[0] > ys || pe[1] > ys) && qt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), o.addSymbols(o.text, K, pe, w, y, b, I, t, S.lineStartIndex, S.lineLength, N, q);
          for (const Be of E) B[Be] = o.text.placedSymbolArray.length - 1;
          return 4 * K.length;
        }
        function Ev(o) {
          for (const t in o) return o[t];
          return null;
        }
        function ww(o, t, n, u) {
          const h = o.compareText;
          if (t in h) {
            const y = h[t];
            for (let b = y.length - 1; b >= 0; b--) if (u.dist(y[b]) < n) return true;
          } else h[t] = [];
          return h[t].push(u), false;
        }
        const Rv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class gm {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, u] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const h = u >> 4;
            if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
            const y = Rv[15 & u];
            if (!y) throw new Error("Unrecognized array type.");
            const [b] = new Uint16Array(t, 2, 1), [w] = new Uint32Array(t, 4, 1);
            return new gm(w, b, y, t);
          }
          constructor(t, n = 64, u = Float64Array, h) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = u, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const y = Rv.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, w = t * this.IndexArrayType.BYTES_PER_ELEMENT, S = (8 - w % 8) % 8;
            if (y < 0) throw new Error(`Unexpected typed array class: ${u}.`);
            h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 2 * t, this._finished = true) : (this.data = new ArrayBuffer(8 + b + w + S), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + y]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const u = this._pos >> 1;
            return this.ids[u] = u, this.coords[this._pos++] = t, this.coords[this._pos++] = n, u;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return vm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t, n, u, h) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: y, coords: b, nodeSize: w } = this, S = [0, y.length - 1, 0], I = [];
            for (; S.length; ) {
              const E = S.pop() || 0, B = S.pop() || 0, N = S.pop() || 0;
              if (B - N <= w) {
                for (let ae = N; ae <= B; ae++) {
                  const pe = b[2 * ae], Be = b[2 * ae + 1];
                  pe >= t && pe <= u && Be >= n && Be <= h && I.push(y[ae]);
                }
                continue;
              }
              const G = N + B >> 1, q = b[2 * G], K = b[2 * G + 1];
              q >= t && q <= u && K >= n && K <= h && I.push(y[G]), (E === 0 ? t <= q : n <= K) && (S.push(N), S.push(G - 1), S.push(1 - E)), (E === 0 ? u >= q : h >= K) && (S.push(G + 1), S.push(B), S.push(1 - E));
            }
            return I;
          }
          within(t, n, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: h, coords: y, nodeSize: b } = this, w = [0, h.length - 1, 0], S = [], I = u * u;
            for (; w.length; ) {
              const E = w.pop() || 0, B = w.pop() || 0, N = w.pop() || 0;
              if (B - N <= b) {
                for (let ae = N; ae <= B; ae++) Dv(y[2 * ae], y[2 * ae + 1], t, n) <= I && S.push(h[ae]);
                continue;
              }
              const G = N + B >> 1, q = y[2 * G], K = y[2 * G + 1];
              Dv(q, K, t, n) <= I && S.push(h[G]), (E === 0 ? t - u <= q : n - u <= K) && (w.push(N), w.push(G - 1), w.push(1 - E)), (E === 0 ? t + u >= q : n + u >= K) && (w.push(G + 1), w.push(B), w.push(1 - E));
            }
            return S;
          }
        }
        function vm(o, t, n, u, h, y) {
          if (h - u <= n) return;
          const b = u + h >> 1;
          Av(o, t, b, u, h, y), vm(o, t, n, u, b - 1, 1 - y), vm(o, t, n, b + 1, h, 1 - y);
        }
        function Av(o, t, n, u, h, y) {
          for (; h > u; ) {
            if (h - u > 600) {
              const I = h - u + 1, E = n - u + 1, B = Math.log(I), N = 0.5 * Math.exp(2 * B / 3), G = 0.5 * Math.sqrt(B * N * (I - N) / I) * (E - I / 2 < 0 ? -1 : 1);
              Av(o, t, n, Math.max(u, Math.floor(n - E * N / I + G)), Math.min(h, Math.floor(n + (I - E) * N / I + G)), y);
            }
            const b = t[2 * n + y];
            let w = u, S = h;
            for (md(o, t, u, n), t[2 * h + y] > b && md(o, t, u, h); w < S; ) {
              for (md(o, t, w, S), w++, S--; t[2 * w + y] < b; ) w++;
              for (; t[2 * S + y] > b; ) S--;
            }
            t[2 * u + y] === b ? md(o, t, u, S) : (S++, md(o, t, S, h)), S <= n && (u = S + 1), n <= S && (h = S - 1);
          }
        }
        function md(o, t, n, u) {
          _m(o, n, u), _m(t, 2 * n, 2 * u), _m(t, 2 * n + 1, 2 * u + 1);
        }
        function _m(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Dv(o, t, n, u) {
          const h = o - n, y = t - u;
          return h * h + y * y;
        }
        var ym;
        m.cx = void 0, (ym = m.cx || (m.cx = {})).create = "create", ym.load = "load", ym.fullLoad = "fullLoad";
        let cf = null, gd = [];
        const bm = 1e3 / 60, xm = "loadTime", wm = "fullLoadTime", Cw = { mark(o) {
          performance.mark(o);
        }, frame(o) {
          const t = o;
          cf != null && gd.push(t - cf), cf = t;
        }, clearMetrics() {
          cf = null, gd = [], performance.clearMeasures(xm), performance.clearMeasures(wm);
          for (const o in m.cx) performance.clearMarks(m.cx[o]);
        }, getPerformanceMetrics() {
          performance.measure(xm, m.cx.create, m.cx.load), performance.measure(wm, m.cx.create, m.cx.fullLoad);
          const o = performance.getEntriesByName(xm)[0].duration, t = performance.getEntriesByName(wm)[0].duration, n = gd.length, u = 1 / (gd.reduce(((y, b) => y + b), 0) / n / 1e3), h = gd.filter(((y) => y > bm)).reduce(((y, b) => y + (b - bm) / bm), 0);
          return { loadTime: o, fullLoadTime: t, fps: u, percentDroppedFrames: h / (n + h) * 100, totalFrames: n };
        } };
        m.$ = et, m.A = ie, m.B = function([o, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: o * Math.cos(t) * Math.sin(n), y: o * Math.sin(t) * Math.sin(n), z: o * Math.cos(n) };
        }, m.C = Po, m.D = Gt, m.E = wt, m.F = ri, m.G = al, m.H = function(o) {
          if (Ct == null) {
            const t = o.navigator ? o.navigator.userAgent : null;
            Ct = !!o.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Ct;
        }, m.I = im, m.J = class {
          constructor(o, t) {
            this.target = o, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new fw((() => this.process())), this.subscription = bt(this.target, "message", ((n) => this.receive(n)), false), this.globalScope = Cr(self) ? o : window;
          }
          registerMessageHandler(o, t) {
            this.messageHandlers[o] = t;
          }
          sendAsync(o, t) {
            return new Promise(((n, u) => {
              const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), y = t ? bt(t.signal, "abort", (() => {
                y == null ? void 0 : y.unsubscribe(), delete this.resolveRejects[h];
                const S = { id: h, type: "<cancel>", origin: location.origin, targetMapId: o.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(S);
              }), pw) : null;
              this.resolveRejects[h] = { resolve: (S) => {
                y == null ? void 0 : y.unsubscribe(), n(S);
              }, reject: (S) => {
                y == null ? void 0 : y.unsubscribe(), u(S);
              } };
              const b = [], w = Object.assign(Object.assign({}, o), { id: h, sourceMapId: this.mapId, origin: location.origin, data: cs(o.data, b) });
              this.target.postMessage(w, { transfer: b });
            }));
          }
          receive(o) {
            const t = o.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const u = this.abortControllers[n];
                return delete this.abortControllers[n], void (u && u.abort());
              }
              if (Cr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const o = this.taskQueue.shift(), t = this.tasks[o];
            delete this.tasks[o], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(o, t);
          }
          processTask(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const h = this.resolveRejects[o];
                return delete this.resolveRejects[o], h ? void (t.error ? h.reject(La(t.error)) : h.resolve(La(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(o, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = La(t.data), u = new AbortController();
              this.abortControllers[o] = u;
              try {
                const h = yield this.messageHandlers[t.type](t.sourceMapId, n, u);
                this.completeTask(o, null, h);
              } catch (h) {
                this.completeTask(o, h);
              }
            }));
          }
          completeTask(o, t, n) {
            const u = [];
            delete this.abortControllers[o];
            const h = { id: o, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? cs(t) : null, data: cs(n, u) };
            this.target.postMessage(h, { transfer: u });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, m.K = ne, m.L = function() {
          var o = new ie(16);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
        }, m.M = function(o, t, n) {
          var u, h, y, b, w, S, I, E, B, N, G, q, K = n[0], ae = n[1], pe = n[2];
          return t === o ? (o[12] = t[0] * K + t[4] * ae + t[8] * pe + t[12], o[13] = t[1] * K + t[5] * ae + t[9] * pe + t[13], o[14] = t[2] * K + t[6] * ae + t[10] * pe + t[14], o[15] = t[3] * K + t[7] * ae + t[11] * pe + t[15]) : (h = t[1], y = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], B = t[8], N = t[9], G = t[10], q = t[11], o[0] = u = t[0], o[1] = h, o[2] = y, o[3] = b, o[4] = w, o[5] = S, o[6] = I, o[7] = E, o[8] = B, o[9] = N, o[10] = G, o[11] = q, o[12] = u * K + w * ae + B * pe + t[12], o[13] = h * K + S * ae + N * pe + t[13], o[14] = y * K + I * ae + G * pe + t[14], o[15] = b * K + E * ae + q * pe + t[15]), o;
        }, m.N = function(o, t, n) {
          var u = n[0], h = n[1], y = n[2];
          return o[0] = t[0] * u, o[1] = t[1] * u, o[2] = t[2] * u, o[3] = t[3] * u, o[4] = t[4] * h, o[5] = t[5] * h, o[6] = t[6] * h, o[7] = t[7] * h, o[8] = t[8] * y, o[9] = t[9] * y, o[10] = t[10] * y, o[11] = t[11] * y, o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.O = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], B = t[8], N = t[9], G = t[10], q = t[11], K = t[12], ae = t[13], pe = t[14], Be = t[15], Ce = n[0], Ie = n[1], He = n[2], rt = n[3];
          return o[0] = Ce * u + Ie * w + He * B + rt * K, o[1] = Ce * h + Ie * S + He * N + rt * ae, o[2] = Ce * y + Ie * I + He * G + rt * pe, o[3] = Ce * b + Ie * E + He * q + rt * Be, o[4] = (Ce = n[4]) * u + (Ie = n[5]) * w + (He = n[6]) * B + (rt = n[7]) * K, o[5] = Ce * h + Ie * S + He * N + rt * ae, o[6] = Ce * y + Ie * I + He * G + rt * pe, o[7] = Ce * b + Ie * E + He * q + rt * Be, o[8] = (Ce = n[8]) * u + (Ie = n[9]) * w + (He = n[10]) * B + (rt = n[11]) * K, o[9] = Ce * h + Ie * S + He * N + rt * ae, o[10] = Ce * y + Ie * I + He * G + rt * pe, o[11] = Ce * b + Ie * E + He * q + rt * Be, o[12] = (Ce = n[12]) * u + (Ie = n[13]) * w + (He = n[14]) * B + (rt = n[15]) * K, o[13] = Ce * h + Ie * S + He * N + rt * ae, o[14] = Ce * y + Ie * I + He * G + rt * pe, o[15] = Ce * b + Ie * E + He * q + rt * Be, o;
        }, m.P = C, m.Q = function(o, t) {
          const n = {};
          for (let u = 0; u < t.length; u++) {
            const h = t[u];
            h in o && (n[h] = o[h]);
          }
          return n;
        }, m.R = Bn, m.S = bs, m.T = Wp, m.U = cv, m.V = uv, m.W = X, m.X = H, m.Y = Le, m.Z = co, m._ = s, m.a = Z, m.a$ = Ve, m.a0 = function(o, t) {
          var n, u, h, y, b;
          if (!o) return t ?? {};
          if (!t) return o;
          let w = Object.assign({}, o);
          if (t.removeAll && (w = { removeAll: true }), t.remove) {
            const S = new Set(t.remove);
            w.add && (w.add = w.add.filter(((E) => !S.has(E.id)))), w.update && (w.update = w.update.filter(((E) => !S.has(E.id))));
            const I = new Set(((n = o.add) !== null && n !== void 0 ? n : []).map(((E) => E.id)));
            t.remove = t.remove.filter(((E) => !I.has(E)));
          }
          if (t.remove) {
            const S = new Set(w.remove ? w.remove.concat(t.remove) : t.remove);
            w.remove = Array.from(S.values());
          }
          if (t.add) {
            const S = w.add ? w.add.concat(t.add) : t.add, I = new Map(S.map(((E) => [E.id, E])));
            w.add = Array.from(I.values());
          }
          if (t.update) {
            const S = new Map((u = w.update) === null || u === void 0 ? void 0 : u.map(((I) => [I.id, I])));
            for (const I of t.update) {
              const E = (h = S.get(I.id)) !== null && h !== void 0 ? h : { id: I.id };
              I.newGeometry && (E.newGeometry = I.newGeometry), I.addOrUpdateProperties && (E.addOrUpdateProperties = ((y = E.addOrUpdateProperties) !== null && y !== void 0 ? y : []).concat(I.addOrUpdateProperties)), I.removeProperties && (E.removeProperties = ((b = E.removeProperties) !== null && b !== void 0 ? b : []).concat(I.removeProperties)), I.removeAllProperties && (E.removeAllProperties = true), S.set(I.id, E);
            }
            w.update = Array.from(S.values());
          }
          return w.remove && w.add && (w.remove = w.remove.filter(((S) => w.add.findIndex(((I) => I.id === S)) === -1))), w;
        }, m.a1 = fd, m.a2 = pl, m.a3 = 25, m.a4 = fm, m.a5 = (o) => {
          const t = window.document.createElement("video");
          return t.muted = true, new Promise(((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const u of o) {
              const h = window.document.createElement("source");
              he(u) || (t.crossOrigin = "Anonymous"), h.src = u, t.appendChild(h);
            }
          }));
        }, m.a6 = ge, m.a7 = function() {
          return tr++;
        }, m.a8 = $, m.a9 = Eu, m.aA = function(o) {
          let t = 1 / 0, n = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (const y of o) t = Math.min(t, y.x), n = Math.min(n, y.y), u = Math.max(u, y.x), h = Math.max(h, y.y);
          return [t, n, u, h];
        }, m.aB = Vi, m.aC = ht, m.aD = function(o, t, n, u, h = false) {
          if (!n[0] && !n[1]) return [0, 0];
          const y = h ? u === "map" ? -o.bearingInRadians : 0 : u === "viewport" ? o.bearingInRadians : 0;
          if (y) {
            const b = Math.sin(y), w = Math.cos(y);
            n = [n[0] * w - n[1] * b, n[0] * b + n[1] * w];
          }
          return [h ? n[0] : ht(t, n[0], o.zoom), h ? n[1] : ht(t, n[1], o.zoom)];
        }, m.aF = am, m.aG = mm, m.aH = om, m.aI = gm, m.aJ = bi, m.aK = Qh, m.aL = be, m.aM = vr, m.aN = Xr, m.aO = pr, m.aP = mt, m.aQ = hv, m.aR = de, m.aS = oe, m.aT = function(o) {
          var t = new ie(3);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t;
        }, m.aU = function(o, t, n) {
          return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], o;
        }, m.aV = function(o, t) {
          var n = t[0], u = t[1], h = t[2], y = n * n + u * u + h * h;
          return y > 0 && (y = 1 / Math.sqrt(y)), o[0] = t[0] * y, o[1] = t[1] * y, o[2] = t[2] * y, o;
        }, m.aW = xe, m.aX = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2];
        }, m.aY = function(o, t, n) {
          return o[0] = t[0] * n[0], o[1] = t[1] * n[1], o[2] = t[2] * n[2], o[3] = t[3] * n[3], o;
        }, m.aZ = Se, m.a_ = function(o, t, n) {
          const u = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return u === 0 ? null : (-(o[0] * n[0] + o[1] * n[1] + o[2] * n[2]) - n[3]) / u;
        }, m.aa = Da, m.ab = Vo, m.ac = gv, m.ad = function(o) {
          const t = {};
          if (o.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, u, h, y) => {
            const b = h || y;
            return t[u] = !b || b.toLowerCase(), "";
          })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, m.ae = tt, m.af = function(o) {
          return Math.pow(2, o);
        }, m.ag = re, m.ah = zt, m.ai = 85.051129, m.aj = dv, m.ak = function(o) {
          return Math.log(o) / Math.LN2;
        }, m.al = function(o) {
          var t = o[0], n = o[1];
          return t * t + n * n;
        }, m.am = function(o, t) {
          const n = [];
          for (const u in o) u in t || n.push(u);
          return n;
        }, m.an = function(o, t) {
          let n = 0, u = 0;
          if (o.kind === "constant") u = o.layoutSize;
          else if (o.kind !== "source") {
            const { interpolationType: h, minZoom: y, maxZoom: b } = o, w = h ? zt(Hi.interpolationFactor(h, t, y, b), 0, 1) : 0;
            o.kind === "camera" ? u = Po.number(o.minSize, o.maxSize, w) : n = w;
          }
          return { uSizeT: n, uSize: u };
        }, m.ap = function(o, { uSize: t, uSizeT: n }, { lowerSize: u, upperSize: h }) {
          return o.kind === "source" ? u / Na : o.kind === "composite" ? Po.number(u / Na, h / Na, n) : t;
        }, m.aq = function(o, t) {
          var n = t[0], u = t[1], h = t[2], y = t[3], b = t[4], w = t[5], S = t[6], I = t[7], E = t[8], B = t[9], N = t[10], G = t[11], q = t[12], K = t[13], ae = t[14], pe = t[15], Be = n * w - u * b, Ce = n * S - h * b, Ie = n * I - y * b, He = u * S - h * w, rt = u * I - y * w, _t = h * I - y * S, At = E * K - B * q, Pt = E * ae - N * q, Et = E * pe - G * q, Wt = B * ae - N * K, Mt = B * pe - G * K, Rt = N * pe - G * ae, ct = Be * Rt - Ce * Mt + Ie * Wt + He * Et - rt * Pt + _t * At;
          return ct ? (o[0] = (w * Rt - S * Mt + I * Wt) * (ct = 1 / ct), o[1] = (h * Mt - u * Rt - y * Wt) * ct, o[2] = (K * _t - ae * rt + pe * He) * ct, o[3] = (N * rt - B * _t - G * He) * ct, o[4] = (S * Et - b * Rt - I * Pt) * ct, o[5] = (n * Rt - h * Et + y * Pt) * ct, o[6] = (ae * Ie - q * _t - pe * Ce) * ct, o[7] = (E * _t - N * Ie + G * Ce) * ct, o[8] = (b * Mt - w * Et + I * At) * ct, o[9] = (u * Et - n * Mt - y * At) * ct, o[10] = (q * rt - K * Ie + pe * Be) * ct, o[11] = (B * Ie - E * rt - G * Be) * ct, o[12] = (w * Pt - b * Wt - S * At) * ct, o[13] = (n * Wt - u * Pt + h * At) * ct, o[14] = (K * Ce - q * He - ae * Be) * ct, o[15] = (E * He - B * Ce + N * Be) * ct, o) : null;
        }, m.ar = xt, m.as = function(o) {
          var t = o[0], n = o[1];
          return Math.sqrt(t * t + n * n);
        }, m.at = function(o) {
          return o[0] = 0, o[1] = 0, o;
        }, m.au = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o;
        }, m.av = sm, m.aw = Ke, m.ax = function(o, t, n, u) {
          const h = t.y - o.y, y = t.x - o.x, b = u.y - n.y, w = u.x - n.x, S = b * y - w * h;
          if (S === 0) return null;
          const I = (w * (o.y - n.y) - b * (o.x - n.x)) / S;
          return new C(o.x + I * y, o.y + I * h);
        }, m.ay = yv, m.az = l0, m.b = Ee, m.b$ = class extends v {
        }, m.b0 = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o[3] = t[3] * n, o;
        }, m.b1 = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2] + o[3];
        }, m.b2 = pv, m.b3 = Ru, m.b4 = function(o, t, n, u, h) {
          var y = 1 / Math.tan(t / 2);
          if (o[0] = y / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = y, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, h != null && h !== 1 / 0) {
            var b = 1 / (u - h);
            o[10] = (h + u) * b, o[14] = 2 * h * u * b;
          } else o[10] = -1, o[14] = -2 * u;
          return o;
        }, m.b5 = function(o) {
          var t = new ie(16);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t[3] = o[3], t[4] = o[4], t[5] = o[5], t[6] = o[6], t[7] = o[7], t[8] = o[8], t[9] = o[9], t[10] = o[10], t[11] = o[11], t[12] = o[12], t[13] = o[13], t[14] = o[14], t[15] = o[15], t;
        }, m.b6 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[0], b = t[1], w = t[2], S = t[3], I = t[4], E = t[5], B = t[6], N = t[7];
          return t !== o && (o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = y * h + I * u, o[1] = b * h + E * u, o[2] = w * h + B * u, o[3] = S * h + N * u, o[4] = I * h - y * u, o[5] = E * h - b * u, o[6] = B * h - w * u, o[7] = N * h - S * u, o;
        }, m.b7 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[4], b = t[5], w = t[6], S = t[7], I = t[8], E = t[9], B = t[10], N = t[11];
          return t !== o && (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[4] = y * h + I * u, o[5] = b * h + E * u, o[6] = w * h + B * u, o[7] = S * h + N * u, o[8] = I * h - y * u, o[9] = E * h - b * u, o[10] = B * h - w * u, o[11] = N * h - S * u, o;
        }, m.b8 = function() {
          const o = new Float32Array(16);
          return re(o), o;
        }, m.b9 = function() {
          const o = new Float64Array(16);
          return re(o), o;
        }, m.bA = function(o, t) {
          const n = yt(o, 360), u = yt(t, 360), h = u - n, y = u > n ? h - 360 : h + 360;
          return Math.abs(h) < Math.abs(y) ? h : y;
        }, m.bB = function(o) {
          return o[0] = 0, o[1] = 0, o[2] = 0, o;
        }, m.bC = function(o, t, n, u) {
          const h = Math.sqrt(o * o + t * t), y = Math.sqrt(n * n + u * u);
          o /= h, t /= h, n /= y, u /= y;
          const b = Math.acos(o * n + t * u);
          return -t * n + o * u > 0 ? b : -b;
        }, m.bD = function(o, t) {
          const n = yt(o, 2 * Math.PI), u = yt(t, 2 * Math.PI);
          return Math.min(Math.abs(n - u), Math.abs(n - u + 2 * Math.PI), Math.abs(n - u - 2 * Math.PI));
        }, m.bE = function() {
          const o = {}, t = Pe.$version;
          for (const n in Pe.$root) {
            const u = Pe.$root[n];
            if (u.required) {
              let h = null;
              h = n === "version" ? t : u.type === "array" ? [] : {}, h != null && (o[n] = h);
            }
          }
          return o;
        }, m.bF = hu, m.bG = Te, m.bH = function o(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return false;
            for (let u = 0; u < t.length; u++) if (!o(t[u], n[u])) return false;
            return true;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return false;
            for (const u in t) if (!o(t[u], n[u])) return false;
            return true;
          }
          return t === n;
        }, m.bI = function(o) {
          o = o.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < o.length; n++) t[o[n].id] = o[n];
          for (let n = 0; n < o.length; n++) "ref" in o[n] && (o[n] = Qt(o[n], t[o[n].ref]));
          return o;
        }, m.bJ = function(o) {
          if (o.type === "custom") return new hw(o);
          switch (o.type) {
            case "background":
              return new uw(o);
            case "circle":
              return new H1(o);
            case "color-relief":
              return new ex(o);
            case "fill":
              return new mx(o);
            case "fill-extrusion":
              return new Px(o);
            case "heatmap":
              return new Y1(o);
            case "hillshade":
              return new J1(o);
            case "line":
              return new Dx(o);
            case "raster":
              return new dw(o);
            case "symbol":
              return new of(o);
          }
        }, m.bK = rr, m.bL = function(o, t) {
          if (!o) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!Nt(o.version, t.version)) return [{ command: "setStyle", args: [t] }];
            Nt(o.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), Nt(o.state, t.state) || n.push({ command: "setGlobalState", args: [t.state] }), Nt(o.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), Nt(o.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), Nt(o.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), Nt(o.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), Nt(o.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), Nt(o.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), Nt(o.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), Nt(o.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), Nt(o.light, t.light) || n.push({ command: "setLight", args: [t.light] }), Nt(o.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), Nt(o.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), Nt(o.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const u = {}, h = [];
            (function(b, w, S, I) {
              let E;
              for (E in w = w || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, E) && (Object.prototype.hasOwnProperty.call(w, E) || Qr(E, S, I));
              for (E in w) Object.prototype.hasOwnProperty.call(w, E) && (Object.prototype.hasOwnProperty.call(b, E) ? Nt(b[E], w[E]) || (b[E].type === "geojson" && w[E].type === "geojson" && ni(b, w, E) ? ur(S, { command: "setGeoJSONSourceData", args: [E, w[E].data] }) : ei(E, w, S, I)) : Br(E, w, S));
            })(o.sources, t.sources, h, u);
            const y = [];
            o.layers && o.layers.forEach(((b) => {
              "source" in b && u[b.source] ? n.push({ command: "removeLayer", args: [b.id] }) : y.push(b);
            })), n = n.concat(h), (function(b, w, S) {
              w = w || [];
              const I = (b = b || []).map(yr), E = w.map(yr), B = b.reduce(Wr, {}), N = w.reduce(Wr, {}), G = I.slice(), q = /* @__PURE__ */ Object.create(null);
              let K, ae, pe, Be, Ce;
              for (let Ie = 0, He = 0; Ie < I.length; Ie++) K = I[Ie], Object.prototype.hasOwnProperty.call(N, K) ? He++ : (ur(S, { command: "removeLayer", args: [K] }), G.splice(G.indexOf(K, He), 1));
              for (let Ie = 0, He = 0; Ie < E.length; Ie++) K = E[E.length - 1 - Ie], G[G.length - 1 - Ie] !== K && (Object.prototype.hasOwnProperty.call(B, K) ? (ur(S, { command: "removeLayer", args: [K] }), G.splice(G.lastIndexOf(K, G.length - He), 1)) : He++, Be = G[G.length - Ie], ur(S, { command: "addLayer", args: [N[K], Be] }), G.splice(G.length - Ie, 0, K), q[K] = true);
              for (let Ie = 0; Ie < E.length; Ie++) if (K = E[Ie], ae = B[K], pe = N[K], !q[K] && !Nt(ae, pe)) if (Nt(ae.source, pe.source) && Nt(ae["source-layer"], pe["source-layer"]) && Nt(ae.type, pe.type)) {
                for (Ce in gr(ae.layout, pe.layout, S, K, null, "setLayoutProperty"), gr(ae.paint, pe.paint, S, K, null, "setPaintProperty"), Nt(ae.filter, pe.filter) || ur(S, { command: "setFilter", args: [K, pe.filter] }), Nt(ae.minzoom, pe.minzoom) && Nt(ae.maxzoom, pe.maxzoom) || ur(S, { command: "setLayerZoomRange", args: [K, pe.minzoom, pe.maxzoom] }), ae) Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? gr(ae[Ce], pe[Ce], S, K, Ce.slice(6), "setPaintProperty") : Nt(ae[Ce], pe[Ce]) || ur(S, { command: "setLayerProperty", args: [K, Ce, pe[Ce]] }));
                for (Ce in pe) Object.prototype.hasOwnProperty.call(pe, Ce) && !Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? gr(ae[Ce], pe[Ce], S, K, Ce.slice(6), "setPaintProperty") : Nt(ae[Ce], pe[Ce]) || ur(S, { command: "setLayerProperty", args: [K, Ce, pe[Ce]] }));
              } else ur(S, { command: "removeLayer", args: [K] }), Be = G[G.lastIndexOf(K) + 1], ur(S, { command: "addLayer", args: [pe, Be] });
            })(y, t.layers, n);
          } catch (u) {
            console.warn("Unable to compute style diff:", u), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, m.bM = function(o) {
          const t = [], n = o.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), o.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), o.renderingMode && o.renderingMode !== "2d" && o.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, m.bN = wr, m.bO = Er, m.bP = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = 0;
          }
          set(o) {
            this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }, m.bQ = Fi, m.bR = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = Zn;
          }
          set(o) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, false, o);
            for (let t = 1; t < 16; t++) if (o[t] !== this.current[t]) {
              this.current = o, this.gl.uniformMatrix4fv(this.location, false, o);
              break;
            }
          }
        }, m.bS = Ii, m.bT = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = [0, 0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2]));
          }
        }, m.bU = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = [0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1]));
          }
        }, m.bV = te, m.bW = function(o, t) {
          var n = Math.sin(t), u = Math.cos(t);
          return o[0] = u, o[1] = n, o[2] = 0, o[3] = -n, o[4] = u, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
        }, m.bX = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2];
          return o[0] = u * n[0] + h * n[3] + y * n[6], o[1] = u * n[1] + h * n[4] + y * n[7], o[2] = u * n[2] + h * n[5] + y * n[8], o;
        }, m.bY = function(o, t, n, u, h, y, b) {
          var w = 1 / (t - n), S = 1 / (u - h), I = 1 / (y - b);
          return o[0] = -2 * w, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * S, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * I, o[11] = 0, o[12] = (t + n) * w, o[13] = (h + u) * S, o[14] = (b + y) * I, o[15] = 1, o;
        }, m.bZ = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(4 * o.length);
              for (let n = 0; n < o.length; n++) t[4 * n] = o[n].r, t[4 * n + 1] = o[n].g, t[4 * n + 2] = o[n].b, t[4 * n + 3] = o[n].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, m.b_ = class extends _n {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(o);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, m.ba = function() {
          return new Float64Array(16);
        }, m.bb = function(o, t, n) {
          const u = new Float64Array(4);
          return vt(u, o, t - 90, n), u;
        }, m.bc = function(o, t, n, u) {
          var h, y, b, w, S, I = t[0], E = t[1], B = t[2], N = t[3], G = n[0], q = n[1], K = n[2], ae = n[3];
          return (y = I * G + E * q + B * K + N * ae) < 0 && (y = -y, G = -G, q = -q, K = -K, ae = -ae), 1 - y > Q ? (h = Math.acos(y), b = Math.sin(h), w = Math.sin((1 - u) * h) / b, S = Math.sin(u * h) / b) : (w = 1 - u, S = u), o[0] = w * I + S * G, o[1] = w * E + S * q, o[2] = w * B + S * K, o[3] = w * N + S * ae, o;
        }, m.bd = function(o) {
          const t = new Float64Array(9);
          var n, u, h, y, b, w, S, I, E, B, N, G, q, K, ae, pe, Be, Ce;
          B = (h = (u = o)[0]) * (S = h + h), N = (y = u[1]) * S, q = (b = u[2]) * S, K = b * (I = y + y), pe = (w = u[3]) * S, Be = w * I, Ce = w * (E = b + b), (n = t)[0] = 1 - (G = y * I) - (ae = b * E), n[3] = N - Ce, n[6] = q + Be, n[1] = N + Ce, n[4] = 1 - B - ae, n[7] = K - pe, n[2] = q - Be, n[5] = K + pe, n[8] = 1 - B - G;
          const Ie = mt(-Math.asin(zt(t[2], -1, 1)));
          let He, rt;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (He = 0, rt = -mt(Math.atan2(t[3], t[4]))) : (He = mt(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), rt = mt(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: He, pitch: Ie + 90, bearing: rt };
        }, m.be = function(o, t) {
          return o.roll == t.roll && o.pitch == t.pitch && o.bearing == t.bearing;
        }, m.bf = xr, m.bg = ca, m.bh = Pu, m.bi = sd, m.bj = ku, m.bk = nt, m.bl = ut, m.bm = nn, m.bn = function(o, t, n, u, h) {
          return nt(u, h, zt((o - t) / (n - t), 0, 1));
        }, m.bo = yt, m.bp = function() {
          return new Float64Array(3);
        }, m.bq = function(o, t, n, u) {
          return o[0] = t[0] + n[0] * u, o[1] = t[1] + n[1] * u, o[2] = t[2] + n[2] * u, o;
        }, m.br = vt, m.bs = function(o, t, n) {
          var u = n[0], h = n[1], y = n[2], b = n[3], w = t[0], S = t[1], I = t[2], E = h * I - y * S, B = y * w - u * I, N = u * S - h * w;
          return o[0] = w + b * (E += E) + h * (N += N) - y * (B += B), o[1] = S + b * B + y * E - u * N, o[2] = I + b * N + u * B - h * E, o;
        }, m.bt = function(o, t, n) {
          const u = (h = [o[0], o[1], o[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((E = h[8]) * (b = h[4]) - (w = h[5]) * (I = h[7])) + h[1] * (-E * (y = h[3]) + w * (S = h[6])) + h[2] * (I * y - b * S);
          var h, y, b, w, S, I, E;
          if (u === 0) return null;
          const B = xe([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]), N = xe([], [n[0], n[1], n[2]], [o[0], o[1], o[2]]), G = xe([], [o[0], o[1], o[2]], [t[0], t[1], t[2]]), q = de([], B, -o[3]);
          return oe(q, q, de([], N, -t[3])), oe(q, q, de([], G, -n[3])), de(q, q, 1 / u), q;
        }, m.bu = dm, m.bv = function() {
          return new Float64Array(4);
        }, m.bw = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[0] * Math.cos(u) - h[1] * Math.sin(u), y[1] = h[0] * Math.sin(u) + h[1] * Math.cos(u), y[2] = h[2], o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, m.bx = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[0], y[1] = h[1] * Math.cos(u) - h[2] * Math.sin(u), y[2] = h[1] * Math.sin(u) + h[2] * Math.cos(u), o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, m.by = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[2] * Math.sin(u) + h[0] * Math.cos(u), y[1] = h[1], y[2] = h[2] * Math.cos(u) - h[0] * Math.sin(u), o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, m.bz = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[0], b = t[1], w = t[2], S = t[3], I = t[8], E = t[9], B = t[10], N = t[11];
          return t !== o && (o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = y * h - I * u, o[1] = b * h - E * u, o[2] = w * h - B * u, o[3] = S * h - N * u, o[8] = y * u + I * h, o[9] = b * u + E * h, o[10] = w * u + B * h, o[11] = S * u + N * h, o;
        }, m.c = Fe, m.c0 = Bx, m.c1 = class extends a {
        }, m.c2 = qp, m.c3 = function(o) {
          return o <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
        }, m.c4 = _0, m.c5 = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = n[3] * u + n[7] * h + n[11] * y + n[15];
          return o[0] = (n[0] * u + n[4] * h + n[8] * y + n[12]) / (b = b || 1), o[1] = (n[1] * u + n[5] * h + n[9] * y + n[13]) / b, o[2] = (n[2] * u + n[6] * h + n[10] * y + n[14]) / b, o;
        }, m.c6 = class extends Yc {
        }, m.c7 = class extends R {
        }, m.c8 = function(o, t) {
          return o[0] === t[0] && o[1] === t[1] && o[2] === t[2] && o[3] === t[3] && o[4] === t[4] && o[5] === t[5] && o[6] === t[6] && o[7] === t[7] && o[8] === t[8] && o[9] === t[9] && o[10] === t[10] && o[11] === t[11] && o[12] === t[12] && o[13] === t[13] && o[14] === t[14] && o[15] === t[15];
        }, m.c9 = function(o, t) {
          var n = o[0], u = o[1], h = o[2], y = o[3], b = o[4], w = o[5], S = o[6], I = o[7], E = o[8], B = o[9], N = o[10], G = o[11], q = o[12], K = o[13], ae = o[14], pe = o[15], Be = t[0], Ce = t[1], Ie = t[2], He = t[3], rt = t[4], _t = t[5], At = t[6], Pt = t[7], Et = t[8], Wt = t[9], Mt = t[10], Rt = t[11], ct = t[12], or = t[13], hr = t[14], Kt = t[15];
          return Math.abs(n - Be) <= Q * Math.max(1, Math.abs(n), Math.abs(Be)) && Math.abs(u - Ce) <= Q * Math.max(1, Math.abs(u), Math.abs(Ce)) && Math.abs(h - Ie) <= Q * Math.max(1, Math.abs(h), Math.abs(Ie)) && Math.abs(y - He) <= Q * Math.max(1, Math.abs(y), Math.abs(He)) && Math.abs(b - rt) <= Q * Math.max(1, Math.abs(b), Math.abs(rt)) && Math.abs(w - _t) <= Q * Math.max(1, Math.abs(w), Math.abs(_t)) && Math.abs(S - At) <= Q * Math.max(1, Math.abs(S), Math.abs(At)) && Math.abs(I - Pt) <= Q * Math.max(1, Math.abs(I), Math.abs(Pt)) && Math.abs(E - Et) <= Q * Math.max(1, Math.abs(E), Math.abs(Et)) && Math.abs(B - Wt) <= Q * Math.max(1, Math.abs(B), Math.abs(Wt)) && Math.abs(N - Mt) <= Q * Math.max(1, Math.abs(N), Math.abs(Mt)) && Math.abs(G - Rt) <= Q * Math.max(1, Math.abs(G), Math.abs(Rt)) && Math.abs(q - ct) <= Q * Math.max(1, Math.abs(q), Math.abs(ct)) && Math.abs(K - or) <= Q * Math.max(1, Math.abs(K), Math.abs(or)) && Math.abs(ae - hr) <= Q * Math.max(1, Math.abs(ae), Math.abs(hr)) && Math.abs(pe - Kt) <= Q * Math.max(1, Math.abs(pe), Math.abs(Kt));
        }, m.cA = function(o, t) {
          Z.REGISTERED_PROTOCOLS[o] = t;
        }, m.cB = function(o) {
          delete Z.REGISTERED_PROTOCOLS[o];
        }, m.cC = function(o, t) {
          const n = {};
          for (let h = 0; h < o.length; h++) {
            const y = t && t[o[h].id] || Dp(o[h]);
            t && (t[o[h].id] = y);
            let b = n[y];
            b || (b = n[y] = []), b.push(o[h]);
          }
          const u = [];
          for (const h in n) u.push(n[h]);
          return u;
        }, m.cD = Ft, m.cE = mv, m.cF = vv, m.cG = Z0, m.cH = function(o) {
          o.bucket.createArrays(), o.bucket.tilePixelRatio = et / (512 * o.bucket.overscaling), o.bucket.compareText = {}, o.bucket.iconsNeedLinear = false;
          const t = o.bucket.layers[0], n = t.layout, u = t._unevaluatedLayout._values, h = { layoutIconSize: u["icon-size"].possiblyEvaluate(new ri(o.bucket.zoom + 1), o.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new ri(o.bucket.zoom + 1), o.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new ri(18)) };
          if (o.bucket.textSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.textSizeData;
            h.compositeTextSizes = [u["text-size"].possiblyEvaluate(new ri(I), o.canonical), u["text-size"].possiblyEvaluate(new ri(E), o.canonical)];
          }
          if (o.bucket.iconSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.iconSizeData;
            h.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new ri(I), o.canonical), u["icon-size"].possiblyEvaluate(new ri(E), o.canonical)];
          }
          const y = n.get("text-line-height") * Vi, b = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", w = n.get("text-keep-upright"), S = n.get("text-size");
          for (const I of o.bucket.features) {
            const E = n.get("text-font").evaluate(I, {}, o.canonical).join(","), B = S.evaluate(I, {}, o.canonical), N = h.layoutTextSize.evaluate(I, {}, o.canonical), G = h.layoutIconSize.evaluate(I, {}, o.canonical), q = { horizontal: {}, vertical: void 0 }, K = I.text;
            let ae, pe = [0, 0];
            if (K) {
              const Ie = K.toString(), He = n.get("text-letter-spacing").evaluate(I, {}, o.canonical) * Vi, rt = Bp(Ie) ? He : 0, _t = n.get("text-anchor").evaluate(I, {}, o.canonical), At = Iv(t, I, o.canonical);
              if (!At) {
                const Mt = n.get("text-radial-offset").evaluate(I, {}, o.canonical);
                pe = Mt ? Tv(_t, [Mt * Vi, pm]) : n.get("text-offset").evaluate(I, {}, o.canonical).map(((Rt) => Rt * Vi));
              }
              let Pt = b ? "center" : n.get("text-justify").evaluate(I, {}, o.canonical);
              const Et = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(I, {}, o.canonical) * Vi : 1 / 0, Wt = () => {
                o.bucket.allowVerticalPlacement && fu(Ie) && (q.vertical = tf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, "left", rt, pe, m.ao.vertical, true, N, B));
              };
              if (!b && At) {
                const Mt = /* @__PURE__ */ new Set();
                if (Pt === "auto") for (let ct = 0; ct < At.values.length; ct += 2) Mt.add(mm(At.values[ct]));
                else Mt.add(Pt);
                let Rt = false;
                for (const ct of Mt) if (!q.horizontal[ct]) if (Rt) q.horizontal[ct] = q.horizontal[0];
                else {
                  const or = tf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, "center", ct, rt, pe, m.ao.horizontal, false, N, B);
                  or && (q.horizontal[ct] = or, Rt = or.positionedLines.length === 1);
                }
                Wt();
              } else {
                Pt === "auto" && (Pt = mm(_t));
                const Mt = tf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, Pt, rt, pe, m.ao.horizontal, false, N, B);
                Mt && (q.horizontal[Pt] = Mt), Wt(), fu(Ie) && b && w && (q.vertical = tf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, Pt, rt, pe, m.ao.vertical, false, N, B));
              }
            }
            let Be = false;
            if (I.icon && I.icon.name) {
              const Ie = o.imageMap[I.icon.name];
              Ie && (ae = ow(o.imagePositions[I.icon.name], n.get("icon-offset").evaluate(I, {}, o.canonical), n.get("icon-anchor").evaluate(I, {}, o.canonical)), Be = !!Ie.sdf, o.bucket.sdfIcons === void 0 ? o.bucket.sdfIcons = Be : o.bucket.sdfIcons !== Be && qt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ie.pixelRatio !== o.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (o.bucket.iconsNeedLinear = true));
            }
            const Ce = Ev(q.horizontal) || q.vertical;
            o.bucket.iconsInText = !!Ce && Ce.iconsInText, (Ce || ae) && xw(o.bucket, I, q, ae, o.imageMap, h, N, G, pe, Be, o.canonical, o.subdivisionGranularity);
          }
          o.showCollisionBoxes && o.bucket.generateCollisionDebugBuffers();
        }, m.cI = em, m.cJ = Kp, m.cK = Qp, m.cL = D0, m.cM = rm, m.cN = class {
          constructor(o) {
            this._marks = { start: [o.url, "start"].join("#"), end: [o.url, "end"].join("#"), measure: o.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let o = performance.getEntriesByName(this._marks.measure);
            return o.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), o = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), o;
          }
        }, m.cO = function(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (H()) try {
              return yield Le(o, t, n, u, h);
            } catch {
            }
            return (function(y, b, w, S, I) {
              const E = y.width, B = y.height;
              Ye && ft || (Ye = new OffscreenCanvas(E, B), ft = Ye.getContext("2d", { willReadFrequently: true })), Ye.width = E, Ye.height = B, ft.drawImage(y, 0, 0, E, B);
              const N = ft.getImageData(b, w, S, I);
              return ft.clearRect(0, 0, E, B), N.data;
            })(o, t, n, u, h);
          }));
        }, m.cP = x0, m.cQ = T, m.cR = A0, m.cS = Tu, m.cT = el, m.cU = function(o, t) {
          const n = /* @__PURE__ */ new Map();
          if (o != null) if (o.type === "Feature") n.set(pd(o, t), o);
          else for (const u of o.features) n.set(pd(u, t), u);
          return n;
        }, m.cV = function(o, t) {
          if (o == null) return true;
          if (o.type === "Feature") return pd(o, t) != null;
          if (o.type === "FeatureCollection") {
            const n = /* @__PURE__ */ new Set();
            for (const u of o.features) {
              const h = pd(u, t);
              if (h == null || n.has(h)) return false;
              n.add(h);
            }
            return true;
          }
          return false;
        }, m.cW = function(o, t, n) {
          var u, h, y, b;
          if (t.removeAll && o.clear(), t.remove) for (const w of t.remove) o.delete(w);
          if (t.add) for (const w of t.add) {
            const S = pd(w, n);
            S != null && o.set(S, w);
          }
          if (t.update) for (const w of t.update) {
            let S = o.get(w.id);
            if (S == null) continue;
            const I = !w.removeAllProperties && (((u = w.removeProperties) === null || u === void 0 ? void 0 : u.length) > 0 || ((h = w.addOrUpdateProperties) === null || h === void 0 ? void 0 : h.length) > 0);
            if ((w.newGeometry || w.removeAllProperties || I) && (S = Object.assign({}, S), o.set(w.id, S), I && (S.properties = Object.assign({}, S.properties))), w.newGeometry && (S.geometry = w.newGeometry), w.removeAllProperties) S.properties = {};
            else if (((y = w.removeProperties) === null || y === void 0 ? void 0 : y.length) > 0) for (const E of w.removeProperties) Object.prototype.hasOwnProperty.call(S.properties, E) && delete S.properties[E];
            if (((b = w.addOrUpdateProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const { key: E, value: B } of w.addOrUpdateProperties) S.properties[E] = B;
          }
        }, m.cX = ao, m.ca = function(o, t) {
          return o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.cb = (o) => o.type === "symbol", m.cc = (o) => o.type === "circle", m.cd = (o) => o.type === "heatmap", m.ce = (o) => o.type === "line", m.cf = (o) => o.type === "fill", m.cg = (o) => o.type === "fill-extrusion", m.ch = (o) => o.type === "hillshade", m.ci = (o) => o.type === "color-relief", m.cj = (o) => o.type === "raster", m.ck = (o) => o.type === "background", m.cl = (o) => o.type === "custom", m.cm = Lt, m.cn = function(o, t, n) {
          const u = at(t.x - n.x, t.y - n.y), h = at(o.x - n.x, o.y - n.y);
          var y, b;
          return mt(Math.atan2(u[0] * h[1] - u[1] * h[0], (y = u)[0] * (b = h)[0] + y[1] * b[1]));
        }, m.co = Ht, m.cp = function(o, t) {
          return ii[t] && (o instanceof MouseEvent || o instanceof WheelEvent);
        }, m.cq = function(o, t) {
          return Zt[t] && "touches" in o;
        }, m.cr = function(o) {
          return Zt[o] || ii[o];
        }, m.cs = function(o, t, n) {
          var u = t[0], h = t[1];
          return o[0] = n[0] * u + n[4] * h + n[12], o[1] = n[1] * u + n[5] * h + n[13], o;
        }, m.ct = function(o, t) {
          const { x: n, y: u } = fd.fromLngLat(t);
          return !(o < 0 || o > 25 || u < 0 || u >= 1 || n < 0 || n >= 1);
        }, m.cu = function(o, t) {
          return o[0] = t[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = t[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = t[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }, m.cv = class extends fs {
        }, m.cw = Cw, m.cy = function(o) {
          return o.message === wi;
        }, m.cz = _e, m.d = he, m.e = Jt, m.f = (o) => s(void 0, void 0, void 0, (function* () {
          if (o.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(o)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), m.g = Y, m.h = (o) => new Promise(((t, n) => {
          const u = new Image();
          u.onload = () => {
            t(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame((() => {
              u.src = ot;
            }));
          }, u.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const h = new Blob([new Uint8Array(o)], { type: "image/png" });
          u.src = o.byteLength ? URL.createObjectURL(h) : ot;
        })), m.i = Cr, m.j = (o, t) => De(Jt(o, { type: "json" }), t), m.k = Xe, m.l = it, m.m = De, m.n = (o, t) => De(Jt(o, { type: "arrayBuffer" }), t), m.o = function(o) {
          return new rm(o).readFields(Hx, []);
        }, m.p = W0, m.q = rd, m.r = gn, m.s = bt, m.t = Gh, m.u = Ir, m.v = Pe, m.w = qt, m.x = zp, m.y = sl, m.z = us;
      })), f("worker", ["./shared"], (function(m) {
        class s {
          constructor(Z) {
            this.keyCache = {}, Z && this.replace(Z);
          }
          replace(Z) {
            this._layerConfigs = {}, this._layers = {}, this.update(Z, []);
          }
          update(Z, Y) {
            for (const _e of Z) {
              this._layerConfigs[_e.id] = _e;
              const Te = this._layers[_e.id] = m.bJ(_e);
              Te._featureFilter = m.aa(Te.filter), this.keyCache[_e.id] && delete this.keyCache[_e.id];
            }
            for (const _e of Y) delete this.keyCache[_e], delete this._layerConfigs[_e], delete this._layers[_e];
            this.familiesBySource = {};
            const ne = m.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const _e of ne) {
              const Te = _e.map(((Xe) => this._layers[Xe.id])), De = Te[0];
              if (De.visibility === "none") continue;
              const he = De.source || "";
              let ve = this.familiesBySource[he];
              ve || (ve = this.familiesBySource[he] = {});
              const je = De.sourceLayer || "_geojsonTileLayer";
              let it = ve[je];
              it || (it = ve[je] = []), it.push(Te);
            }
          }
        }
        class C {
          constructor(Z) {
            const Y = {}, ne = [];
            for (const he in Z) {
              const ve = Z[he], je = Y[he] = {};
              for (const it in ve) {
                const Xe = ve[+it];
                if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue;
                const wt = { x: 0, y: 0, w: Xe.bitmap.width + 2, h: Xe.bitmap.height + 2 };
                ne.push(wt), je[it] = { rect: wt, metrics: Xe.metrics };
              }
            }
            const { w: _e, h: Te } = m.p(ne), De = new m.q({ width: _e || 1, height: Te || 1 });
            for (const he in Z) {
              const ve = Z[he];
              for (const je in ve) {
                const it = ve[+je];
                if (!it || it.bitmap.width === 0 || it.bitmap.height === 0) continue;
                const Xe = Y[he][je].rect;
                m.q.copy(it.bitmap, De, { x: 0, y: 0 }, { x: Xe.x + 1, y: Xe.y + 1 }, it.bitmap);
              }
            }
            this.image = De, this.positions = Y;
          }
        }
        m.cD("GlyphAtlas", C);
        class T {
          constructor(Z) {
            this.tileID = new m.Z(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.uid = Z.uid, this.zoom = Z.zoom, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Z.showCollisionBoxes, this.collectResourceTiming = !!Z.collectResourceTiming, this.returnDependencies = !!Z.returnDependencies, this.promoteId = Z.promoteId, this.inFlightDependencies = [], this.globalState = Z.globalState;
          }
          parse(Z, Y, ne, _e, Te) {
            return m._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = Z, this.collisionBoxArray = new m.a8();
              const De = new m.cE(Object.keys(Z.layers).sort()), he = new m.cF(this.tileID, this.promoteId);
              he.bucketLayerIDs = [];
              const ve = {}, je = { featureIndex: he, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ne, subdivisionGranularity: Te }, it = Y.familiesBySource[this.source];
              for (const gr in it) {
                const yr = Z.layers[gr];
                if (!yr) continue;
                yr.version === 1 && m.w(`Vector tile source "${this.source}" layer "${gr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Wr = De.encode(gr), ge = [];
                for (let dt = 0; dt < yr.length; dt++) {
                  const Bt = yr.feature(dt), Rr = he.getId(Bt, gr);
                  ge.push({ feature: Bt, id: Rr, index: dt, sourceLayerIndex: Wr });
                }
                for (const dt of it[gr]) {
                  const Bt = dt[0];
                  Bt.source !== this.source && m.w(`layer.source = ${Bt.source} does not equal this.source = ${this.source}`), Bt.minzoom && this.zoom < Math.floor(Bt.minzoom) || Bt.maxzoom && this.zoom >= Bt.maxzoom || Bt.visibility !== "none" && (M(dt, this.zoom, ne, this.globalState), (ve[Bt.id] = Bt.createBucket({ index: he.bucketLayerIDs.length, layers: dt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Wr, sourceID: this.source, globalState: this.globalState })).populate(ge, je, this.tileID.canonical), he.bucketLayerIDs.push(dt.map(((Rr) => Rr.id))));
                }
              }
              const Xe = m.bN(je.glyphDependencies, ((gr) => Object.keys(gr).map(Number)));
              this.inFlightDependencies.forEach(((gr) => gr == null ? void 0 : gr.abort())), this.inFlightDependencies = [];
              let wt = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), wt = _e.sendAsync({ type: "GG", data: { stacks: Xe, source: this.source, tileID: this.tileID, type: "glyphs" } }, gr);
              }
              const Pe = Object.keys(je.iconDependencies);
              let $t = Promise.resolve({});
              if (Pe.length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), $t = _e.sendAsync({ type: "GI", data: { icons: Pe, source: this.source, tileID: this.tileID, type: "icons" } }, gr);
              }
              const Qt = Object.keys(je.patternDependencies);
              let Nt = Promise.resolve({});
              if (Qt.length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), Nt = _e.sendAsync({ type: "GI", data: { icons: Qt, source: this.source, tileID: this.tileID, type: "patterns" } }, gr);
              }
              const [ur, Br, Qr] = yield Promise.all([wt, $t, Nt]), ei = new C(ur), ni = new m.cG(Br, Qr);
              for (const gr in ve) {
                const yr = ve[gr];
                yr instanceof m.a9 ? (M(yr.layers, this.zoom, ne, this.globalState), m.cH({ bucket: yr, glyphMap: ur, glyphPositions: ei.positions, imageMap: Br, imagePositions: ni.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: je.subdivisionGranularity })) : yr.hasPattern && (yr instanceof m.cI || yr instanceof m.cJ || yr instanceof m.cK) && (M(yr.layers, this.zoom, ne, this.globalState), yr.addFeatures(je, this.tileID.canonical, ni.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(ve).filter(((gr) => !gr.isEmpty())), featureIndex: he, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ei.image, imageAtlas: ni, glyphMap: this.returnDependencies ? ur : null, iconMap: this.returnDependencies ? Br : null, glyphPositions: this.returnDependencies ? ei.positions : null };
            }));
          }
        }
        function M(Fe, Z, Y, ne) {
          const _e = new m.F(Z);
          for (const Te of Fe) Te.setGlobalState(ne), Te.recalculate(_e, Y);
        }
        class z {
          constructor(Z, Y, ne) {
            this.actor = Z, this.layerIndex = Y, this.availableImages = ne, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              const ne = yield m.n(Z.request, Y);
              try {
                return { vectorTile: new m.cL(new m.cM(ne.data)), rawData: ne.data, cacheControl: ne.cacheControl, expires: ne.expires };
              } catch (_e) {
                const Te = new Uint8Array(ne.data);
                let De = `Unable to parse the tile at ${Z.request.url}, `;
                throw De += Te[0] === 31 && Te[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${_e.message}`, new Error(De);
              }
            }));
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const Y = Z.uid, ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request), _e = new T(Z);
              this.loading[Y] = _e;
              const Te = new AbortController();
              _e.abort = Te;
              try {
                const De = yield this.loadVectorTile(Z, Te);
                if (delete this.loading[Y], !De) return null;
                const he = De.rawData, ve = {};
                De.expires && (ve.expires = De.expires), De.cacheControl && (ve.cacheControl = De.cacheControl);
                const je = {};
                if (ne) {
                  const Xe = ne.finish();
                  Xe && (je.resourceTiming = JSON.parse(JSON.stringify(Xe)));
                }
                _e.vectorTile = De.vectorTile;
                const it = _e.parse(De.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                this.loaded[Y] = _e, this.fetching[Y] = { rawTileData: he, cacheControl: ve, resourceTiming: je };
                try {
                  const Xe = yield it;
                  return m.e({ rawTileData: he.slice(0) }, Xe, ve, je);
                } finally {
                  delete this.fetching[Y];
                }
              } catch (De) {
                throw delete this.loading[Y], _e.status = "done", this.loaded[Y] = _e, De;
              }
            }));
          }
          reloadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const Y = Z.uid;
              if (!this.loaded || !this.loaded[Y]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ne = this.loaded[Y];
              if (ne.showCollisionBoxes = Z.showCollisionBoxes, ne.globalState = Z.globalState, ne.status === "parsing") {
                const _e = yield ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                let Te;
                if (this.fetching[Y]) {
                  const { rawTileData: De, cacheControl: he, resourceTiming: ve } = this.fetching[Y];
                  delete this.fetching[Y], Te = m.e({ rawTileData: De.slice(0) }, _e, he, ve);
                } else Te = _e;
                return Te;
              }
              if (ne.status === "done" && ne.vectorTile) return ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
            }));
          }
          abortTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const Y = this.loading, ne = Z.uid;
              Y && Y[ne] && Y[ne].abort && (Y[ne].abort.abort(), delete Y[ne]);
            }));
          }
          removeTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[Z.uid] && delete this.loaded[Z.uid];
            }));
          }
        }
        class L {
          constructor() {
            this.loaded = {};
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const { uid: Y, encoding: ne, rawImageData: _e, redFactor: Te, greenFactor: De, blueFactor: he, baseShift: ve } = Z, je = _e.width + 2, it = _e.height + 2, Xe = m.b(_e) ? new m.R({ width: je, height: it }, yield m.cO(_e, -1, -1, je, it)) : _e, wt = new m.cP(Y, Xe, ne, Te, De, he, ve);
              return this.loaded = this.loaded || {}, this.loaded[Y] = wt, wt;
            }));
          }
          removeTile(Z) {
            const Y = this.loaded, ne = Z.uid;
            Y && Y[ne] && delete Y[ne];
          }
        }
        var A, O, U = (function() {
          if (O) return A;
          function Fe(Y, ne) {
            if (Y.length !== 0) {
              Z(Y[0], ne);
              for (var _e = 1; _e < Y.length; _e++) Z(Y[_e], !ne);
            }
          }
          function Z(Y, ne) {
            for (var _e = 0, Te = 0, De = 0, he = Y.length, ve = he - 1; De < he; ve = De++) {
              var je = (Y[De][0] - Y[ve][0]) * (Y[ve][1] + Y[De][1]), it = _e + je;
              Te += Math.abs(_e) >= Math.abs(je) ? _e - it + je : je - it + _e, _e = it;
            }
            _e + Te >= 0 != !!ne && Y.reverse();
          }
          return O = 1, A = function Y(ne, _e) {
            var Te, De = ne && ne.type;
            if (De === "FeatureCollection") for (Te = 0; Te < ne.features.length; Te++) Y(ne.features[Te], _e);
            else if (De === "GeometryCollection") for (Te = 0; Te < ne.geometries.length; Te++) Y(ne.geometries[Te], _e);
            else if (De === "Feature") Y(ne.geometry, _e);
            else if (De === "Polygon") Fe(ne.coordinates, _e);
            else if (De === "MultiPolygon") for (Te = 0; Te < ne.coordinates.length; Te++) Fe(ne.coordinates[Te], _e);
            return ne;
          };
        })(), X = m.cQ(U);
        class H extends m.cS {
          constructor(Z, Y) {
            super(new m.cM(), 0, Y, [], []), this.feature = Z, this.type = Z.type, this.properties = Z.tags ? Z.tags : {}, "id" in Z && (typeof Z.id == "string" ? this.id = parseInt(Z.id, 10) : typeof Z.id != "number" || isNaN(Z.id) || (this.id = Z.id));
          }
          loadGeometry() {
            const Z = [], Y = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const ne of Y) {
              const _e = [];
              for (const Te of ne) _e.push(new m.P(Te[0], Te[1]));
              Z.push(_e);
            }
            return Z;
          }
        }
        class Q extends m.cR {
          constructor(Z, Y) {
            super(new m.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = Y ? Y.version : 1, this.extent = Y ? Y.extent : 4096, this.length = Z.length, this.features = Z;
          }
          feature(Z) {
            return new H(this.features[Z], this.extent);
          }
        }
        function ie(Fe, Z) {
          Z.writeVarintField(15, Fe.version || 1), Z.writeStringField(1, Fe.name || ""), Z.writeVarintField(5, Fe.extent || 4096);
          const Y = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let Te = 0; Te < Fe.length; Te++) Y.feature = Fe.feature(Te), Z.writeMessage(2, te, Y);
          const ne = Y.keys;
          for (const Te of ne) Z.writeStringField(3, Te);
          const _e = Y.values;
          for (const Te of _e) Z.writeMessage(4, oe, Te);
        }
        function te(Fe, Z) {
          if (!Fe.feature) return;
          const Y = Fe.feature;
          Y.id !== void 0 && Z.writeVarintField(1, Y.id), Z.writeMessage(2, re, Fe), Z.writeVarintField(3, Y.type), Z.writeMessage(4, fe, Y);
        }
        function re(Fe, Z) {
          var _a3;
          for (const Y in (_a3 = Fe.feature) == null ? void 0 : _a3.properties) {
            let ne = Fe.feature.properties[Y], _e = Fe.keycache[Y];
            if (ne === null) continue;
            _e === void 0 && (Fe.keys.push(Y), _e = Fe.keys.length - 1, Fe.keycache[Y] = _e), Z.writeVarint(_e), typeof ne != "string" && typeof ne != "boolean" && typeof ne != "number" && (ne = JSON.stringify(ne));
            const Te = typeof ne + ":" + ne;
            let De = Fe.valuecache[Te];
            De === void 0 && (Fe.values.push(ne), De = Fe.values.length - 1, Fe.valuecache[Te] = De), Z.writeVarint(De);
          }
        }
        function J(Fe, Z) {
          return (Z << 3) + (7 & Fe);
        }
        function Se(Fe) {
          return Fe << 1 ^ Fe >> 31;
        }
        function fe(Fe, Z) {
          const Y = Fe.loadGeometry(), ne = Fe.type;
          let _e = 0, Te = 0;
          for (const De of Y) {
            let he = 1;
            ne === 1 && (he = De.length), Z.writeVarint(J(1, he));
            const ve = ne === 3 ? De.length - 1 : De.length;
            for (let je = 0; je < ve; je++) {
              je === 1 && ne !== 1 && Z.writeVarint(J(2, ve - 1));
              const it = De[je].x - _e, Xe = De[je].y - Te;
              Z.writeVarint(Se(it)), Z.writeVarint(Se(Xe)), _e += it, Te += Xe;
            }
            Fe.type === 3 && Z.writeVarint(J(7, 1));
          }
        }
        function oe(Fe, Z) {
          const Y = typeof Fe;
          Y === "string" ? Z.writeStringField(1, Fe) : Y === "boolean" ? Z.writeBooleanField(7, Fe) : Y === "number" && (Fe % 1 != 0 ? Z.writeDoubleField(3, Fe) : Fe < 0 ? Z.writeSVarintField(6, Fe) : Z.writeVarintField(5, Fe));
        }
        const de = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (Fe) => Fe }, xe = Math.fround || ($e = new Float32Array(1), (Fe) => ($e[0] = +Fe, $e[0]));
        var $e;
        class Ve {
          constructor(Z) {
            this.options = Object.assign(Object.create(de), Z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(Z) {
            const { log: Y, minZoom: ne, maxZoom: _e } = this.options;
            Y && console.time("total time");
            const Te = `prepare ${Z.length} points`;
            Y && console.time(Te), this.points = Z;
            const De = [];
            for (let ve = 0; ve < Z.length; ve++) {
              const je = Z[ve];
              if (!je.geometry) continue;
              const [it, Xe] = je.geometry.coordinates, wt = xe(vt(it)), Pe = xe(xt(Xe));
              De.push(wt, Pe, 1 / 0, ve, -1, 1), this.options.reduce && De.push(0);
            }
            let he = this.trees[_e + 1] = this._createTree(De);
            Y && console.timeEnd(Te);
            for (let ve = _e; ve >= ne; ve--) {
              const je = +Date.now();
              he = this.trees[ve] = this._createTree(this._cluster(he, ve)), Y && console.log("z%d: %d clusters in %dms", ve, he.numItems, +Date.now() - je);
            }
            return Y && console.timeEnd("total time"), this;
          }
          getClusters(Z, Y) {
            let ne = ((Z[0] + 180) % 360 + 360) % 360 - 180;
            const _e = Math.max(-90, Math.min(90, Z[1]));
            let Te = Z[2] === 180 ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180;
            const De = Math.max(-90, Math.min(90, Z[3]));
            if (Z[2] - Z[0] >= 360) ne = -180, Te = 180;
            else if (ne > Te) {
              const Xe = this.getClusters([ne, _e, 180, De], Y), wt = this.getClusters([-180, _e, Te, De], Y);
              return Xe.concat(wt);
            }
            const he = this.trees[this._limitZoom(Y)], ve = he.range(vt(ne), xt(De), vt(Te), xt(_e)), je = he.data, it = [];
            for (const Xe of ve) {
              const wt = this.stride * Xe;
              it.push(je[wt + 5] > 1 ? Ke(je, wt, this.clusterProps) : this.points[je[wt + 3]]);
            }
            return it;
          }
          getChildren(Z) {
            const Y = this._getOriginId(Z), ne = this._getOriginZoom(Z), _e = "No cluster with the specified id.", Te = this.trees[ne];
            if (!Te) throw new Error(_e);
            const De = Te.data;
            if (Y * this.stride >= De.length) throw new Error(_e);
            const he = this.options.radius / (this.options.extent * Math.pow(2, ne - 1)), ve = Te.within(De[Y * this.stride], De[Y * this.stride + 1], he), je = [];
            for (const it of ve) {
              const Xe = it * this.stride;
              De[Xe + 4] === Z && je.push(De[Xe + 5] > 1 ? Ke(De, Xe, this.clusterProps) : this.points[De[Xe + 3]]);
            }
            if (je.length === 0) throw new Error(_e);
            return je;
          }
          getLeaves(Z, Y, ne) {
            const _e = [];
            return this._appendLeaves(_e, Z, Y = Y || 10, ne = ne || 0, 0), _e;
          }
          getTile(Z, Y, ne) {
            const _e = this.trees[this._limitZoom(Z)], Te = Math.pow(2, Z), { extent: De, radius: he } = this.options, ve = he / De, je = (ne - ve) / Te, it = (ne + 1 + ve) / Te, Xe = { features: [] };
            return this._addTileFeatures(_e.range((Y - ve) / Te, je, (Y + 1 + ve) / Te, it), _e.data, Y, ne, Te, Xe), Y === 0 && this._addTileFeatures(_e.range(1 - ve / Te, je, 1, it), _e.data, Te, ne, Te, Xe), Y === Te - 1 && this._addTileFeatures(_e.range(0, je, ve / Te, it), _e.data, -1, ne, Te, Xe), Xe.features.length ? Xe : null;
          }
          getClusterExpansionZoom(Z) {
            let Y = this._getOriginZoom(Z) - 1;
            for (; Y <= this.options.maxZoom; ) {
              const ne = this.getChildren(Z);
              if (Y++, ne.length !== 1) break;
              Z = ne[0].properties.cluster_id;
            }
            return Y;
          }
          _appendLeaves(Z, Y, ne, _e, Te) {
            const De = this.getChildren(Y);
            for (const he of De) {
              const ve = he.properties;
              if (ve && ve.cluster ? Te + ve.point_count <= _e ? Te += ve.point_count : Te = this._appendLeaves(Z, ve.cluster_id, ne, _e, Te) : Te < _e ? Te++ : Z.push(he), Z.length === ne) break;
            }
            return Te;
          }
          _createTree(Z) {
            const Y = new m.aI(Z.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ne = 0; ne < Z.length; ne += this.stride) Y.add(Z[ne], Z[ne + 1]);
            return Y.finish(), Y.data = Z, Y;
          }
          _addTileFeatures(Z, Y, ne, _e, Te, De) {
            for (const he of Z) {
              const ve = he * this.stride, je = Y[ve + 5] > 1;
              let it, Xe, wt;
              if (je) it = lt(Y, ve, this.clusterProps), Xe = Y[ve], wt = Y[ve + 1];
              else {
                const Qt = this.points[Y[ve + 3]];
                it = Qt.properties;
                const [Nt, ur] = Qt.geometry.coordinates;
                Xe = vt(Nt), wt = xt(ur);
              }
              const Pe = { type: 1, geometry: [[Math.round(this.options.extent * (Xe * Te - ne)), Math.round(this.options.extent * (wt * Te - _e))]], tags: it };
              let $t;
              $t = je || this.options.generateId ? Y[ve + 3] : this.points[Y[ve + 3]].id, $t !== void 0 && (Pe.id = $t), De.features.push(Pe);
            }
          }
          _limitZoom(Z) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1));
          }
          _cluster(Z, Y) {
            const { radius: ne, extent: _e, reduce: Te, minPoints: De } = this.options, he = ne / (_e * Math.pow(2, Y)), ve = Z.data, je = [], it = this.stride;
            for (let Xe = 0; Xe < ve.length; Xe += it) {
              if (ve[Xe + 2] <= Y) continue;
              ve[Xe + 2] = Y;
              const wt = ve[Xe], Pe = ve[Xe + 1], $t = Z.within(ve[Xe], ve[Xe + 1], he), Qt = ve[Xe + 5];
              let Nt = Qt;
              for (const ur of $t) {
                const Br = ur * it;
                ve[Br + 2] > Y && (Nt += ve[Br + 5]);
              }
              if (Nt > Qt && Nt >= De) {
                let ur, Br = wt * Qt, Qr = Pe * Qt, ei = -1;
                const ni = (Xe / it << 5) + (Y + 1) + this.points.length;
                for (const gr of $t) {
                  const yr = gr * it;
                  if (ve[yr + 2] <= Y) continue;
                  ve[yr + 2] = Y;
                  const Wr = ve[yr + 5];
                  Br += ve[yr] * Wr, Qr += ve[yr + 1] * Wr, ve[yr + 4] = ni, Te && (ur || (ur = this._map(ve, Xe, true), ei = this.clusterProps.length, this.clusterProps.push(ur)), Te(ur, this._map(ve, yr)));
                }
                ve[Xe + 4] = ni, je.push(Br / Nt, Qr / Nt, 1 / 0, ni, -1, Nt), Te && je.push(ei);
              } else {
                for (let ur = 0; ur < it; ur++) je.push(ve[Xe + ur]);
                if (Nt > 1) for (const ur of $t) {
                  const Br = ur * it;
                  if (!(ve[Br + 2] <= Y)) {
                    ve[Br + 2] = Y;
                    for (let Qr = 0; Qr < it; Qr++) je.push(ve[Br + Qr]);
                  }
                }
              }
            }
            return je;
          }
          _getOriginId(Z) {
            return Z - this.points.length >> 5;
          }
          _getOriginZoom(Z) {
            return (Z - this.points.length) % 32;
          }
          _map(Z, Y, ne) {
            if (Z[Y + 5] > 1) {
              const De = this.clusterProps[Z[Y + 6]];
              return ne ? Object.assign({}, De) : De;
            }
            const _e = this.points[Z[Y + 3]].properties, Te = this.options.map(_e);
            return ne && Te === _e ? Object.assign({}, Te) : Te;
          }
        }
        function Ke(Fe, Z, Y) {
          return { type: "Feature", id: Fe[Z + 3], properties: lt(Fe, Z, Y), geometry: { type: "Point", coordinates: [(ne = Fe[Z], 360 * (ne - 0.5)), at(Fe[Z + 1])] } };
          var ne;
        }
        function lt(Fe, Z, Y) {
          const ne = Fe[Z + 5], _e = ne >= 1e4 ? `${Math.round(ne / 1e3)}k` : ne >= 1e3 ? Math.round(ne / 100) / 10 + "k" : ne, Te = Fe[Z + 6], De = Te === -1 ? {} : Object.assign({}, Y[Te]);
          return Object.assign(De, { cluster: true, cluster_id: Fe[Z + 3], point_count: ne, point_count_abbreviated: _e });
        }
        function vt(Fe) {
          return Fe / 360 + 0.5;
        }
        function xt(Fe) {
          const Z = Math.sin(Fe * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function at(Fe) {
          const Z = (180 - 360 * Fe) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90;
        }
        function et(Fe, Z, Y, ne) {
          let _e = ne;
          const Te = Z + (Y - Z >> 1);
          let De, he = Y - Z;
          const ve = Fe[Z], je = Fe[Z + 1], it = Fe[Y], Xe = Fe[Y + 1];
          for (let wt = Z + 3; wt < Y; wt += 3) {
            const Pe = ht(Fe[wt], Fe[wt + 1], ve, je, it, Xe);
            if (Pe > _e) De = wt, _e = Pe;
            else if (Pe === _e) {
              const $t = Math.abs(wt - Te);
              $t < he && (De = wt, he = $t);
            }
          }
          _e > ne && (De - Z > 3 && et(Fe, Z, De, ne), Fe[De + 2] = _e, Y - De > 3 && et(Fe, De, Y, ne));
        }
        function ht(Fe, Z, Y, ne, _e, Te) {
          let De = _e - Y, he = Te - ne;
          if (De !== 0 || he !== 0) {
            const ve = ((Fe - Y) * De + (Z - ne) * he) / (De * De + he * he);
            ve > 1 ? (Y = _e, ne = Te) : ve > 0 && (Y += De * ve, ne += he * ve);
          }
          return De = Fe - Y, he = Z - ne, De * De + he * he;
        }
        function yt(Fe, Z, Y, ne) {
          const _e = { id: Fe ?? null, type: Z, geometry: Y, tags: ne, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (Z === "Point" || Z === "MultiPoint" || Z === "LineString") nt(_e, Y);
          else if (Z === "Polygon") nt(_e, Y[0]);
          else if (Z === "MultiLineString") for (const Te of Y) nt(_e, Te);
          else if (Z === "MultiPolygon") for (const Te of Y) nt(_e, Te[0]);
          return _e;
        }
        function nt(Fe, Z) {
          for (let Y = 0; Y < Z.length; Y += 3) Fe.minX = Math.min(Fe.minX, Z[Y]), Fe.minY = Math.min(Fe.minY, Z[Y + 1]), Fe.maxX = Math.max(Fe.maxX, Z[Y]), Fe.maxY = Math.max(Fe.maxY, Z[Y + 1]);
        }
        function ut(Fe, Z, Y, ne) {
          if (!Z.geometry) return;
          const _e = Z.geometry.coordinates;
          if (_e && _e.length === 0) return;
          const Te = Z.geometry.type, De = Math.pow(Y.tolerance / ((1 << Y.maxZoom) * Y.extent), 2);
          let he = [], ve = Z.id;
          if (Y.promoteId ? ve = Z.properties[Y.promoteId] : Y.generateId && (ve = ne || 0), Te === "Point") Lt(_e, he);
          else if (Te === "MultiPoint") for (const je of _e) Lt(je, he);
          else if (Te === "LineString") Ht(_e, he, De, false);
          else if (Te === "MultiLineString") {
            if (Y.lineMetrics) {
              for (const je of _e) he = [], Ht(je, he, De, false), Fe.push(yt(ve, "LineString", he, Z.properties));
              return;
            }
            zt(_e, he, De, false);
          } else if (Te === "Polygon") zt(_e, he, De, true);
          else {
            if (Te !== "MultiPolygon") {
              if (Te === "GeometryCollection") {
                for (const je of Z.geometry.geometries) ut(Fe, { id: ve, geometry: je, properties: Z.properties }, Y, ne);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const je of _e) {
              const it = [];
              zt(je, it, De, true), he.push(it);
            }
          }
          Fe.push(yt(ve, Te, he, Z.properties));
        }
        function Lt(Fe, Z) {
          Z.push(pr(Fe[0]), Jt(Fe[1]), 0);
        }
        function Ht(Fe, Z, Y, ne) {
          let _e, Te, De = 0;
          for (let ve = 0; ve < Fe.length; ve++) {
            const je = pr(Fe[ve][0]), it = Jt(Fe[ve][1]);
            Z.push(je, it, 0), ve > 0 && (De += ne ? (_e * it - je * Te) / 2 : Math.sqrt(Math.pow(je - _e, 2) + Math.pow(it - Te, 2))), _e = je, Te = it;
          }
          const he = Z.length - 3;
          Z[2] = 1, et(Z, 0, he, Y), Z[he + 2] = 1, Z.size = Math.abs(De), Z.start = 0, Z.end = Z.size;
        }
        function zt(Fe, Z, Y, ne) {
          for (let _e = 0; _e < Fe.length; _e++) {
            const Te = [];
            Ht(Fe[_e], Te, Y, ne), Z.push(Te);
          }
        }
        function pr(Fe) {
          return Fe / 360 + 0.5;
        }
        function Jt(Fe) {
          const Z = Math.sin(Fe * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function tr(Fe, Z, Y, ne, _e, Te, De, he) {
          if (ne /= Z, Te >= (Y /= Z) && De < ne) return Fe;
          if (De < Y || Te >= ne) return null;
          const ve = [];
          for (const je of Fe) {
            const it = je.geometry;
            let Xe = je.type;
            const wt = _e === 0 ? je.minX : je.minY, Pe = _e === 0 ? je.maxX : je.maxY;
            if (wt >= Y && Pe < ne) {
              ve.push(je);
              continue;
            }
            if (Pe < Y || wt >= ne) continue;
            let $t = [];
            if (Xe === "Point" || Xe === "MultiPoint") wr(it, $t, Y, ne, _e);
            else if (Xe === "LineString") Er(it, $t, Y, ne, _e, false, he.lineMetrics);
            else if (Xe === "MultiLineString") sr(it, $t, Y, ne, _e, false);
            else if (Xe === "Polygon") sr(it, $t, Y, ne, _e, true);
            else if (Xe === "MultiPolygon") for (const Qt of it) {
              const Nt = [];
              sr(Qt, Nt, Y, ne, _e, true), Nt.length && $t.push(Nt);
            }
            if ($t.length) {
              if (he.lineMetrics && Xe === "LineString") {
                for (const Qt of $t) ve.push(yt(je.id, Xe, Qt, je.tags));
                continue;
              }
              Xe !== "LineString" && Xe !== "MultiLineString" || ($t.length === 1 ? (Xe = "LineString", $t = $t[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = $t.length === 3 ? "Point" : "MultiPoint"), ve.push(yt(je.id, Xe, $t, je.tags));
            }
          }
          return ve.length ? ve : null;
        }
        function wr(Fe, Z, Y, ne, _e) {
          for (let Te = 0; Te < Fe.length; Te += 3) {
            const De = Fe[Te + _e];
            De >= Y && De <= ne && qt(Z, Fe[Te], Fe[Te + 1], Fe[Te + 2]);
          }
        }
        function Er(Fe, Z, Y, ne, _e, Te, De) {
          let he = rr(Fe);
          const ve = _e === 0 ? Dr : Cr;
          let je, it, Xe = Fe.start;
          for (let Nt = 0; Nt < Fe.length - 3; Nt += 3) {
            const ur = Fe[Nt], Br = Fe[Nt + 1], Qr = Fe[Nt + 2], ei = Fe[Nt + 3], ni = Fe[Nt + 4], gr = _e === 0 ? ur : Br, yr = _e === 0 ? ei : ni;
            let Wr = false;
            De && (je = Math.sqrt(Math.pow(ur - ei, 2) + Math.pow(Br - ni, 2))), gr < Y ? yr > Y && (it = ve(he, ur, Br, ei, ni, Y), De && (he.start = Xe + je * it)) : gr > ne ? yr < ne && (it = ve(he, ur, Br, ei, ni, ne), De && (he.start = Xe + je * it)) : qt(he, ur, Br, Qr), yr < Y && gr >= Y && (it = ve(he, ur, Br, ei, ni, Y), Wr = true), yr > ne && gr <= ne && (it = ve(he, ur, Br, ei, ni, ne), Wr = true), !Te && Wr && (De && (he.end = Xe + je * it), Z.push(he), he = rr(Fe)), De && (Xe += je);
          }
          let wt = Fe.length - 3;
          const Pe = Fe[wt], $t = Fe[wt + 1], Qt = _e === 0 ? Pe : $t;
          Qt >= Y && Qt <= ne && qt(he, Pe, $t, Fe[wt + 2]), wt = he.length - 3, Te && wt >= 3 && (he[wt] !== he[0] || he[wt + 1] !== he[1]) && qt(he, he[0], he[1], he[2]), he.length && Z.push(he);
        }
        function rr(Fe) {
          const Z = [];
          return Z.size = Fe.size, Z.start = Fe.start, Z.end = Fe.end, Z;
        }
        function sr(Fe, Z, Y, ne, _e, Te) {
          for (const De of Fe) Er(De, Z, Y, ne, _e, Te, false);
        }
        function qt(Fe, Z, Y, ne) {
          Fe.push(Z, Y, ne);
        }
        function Dr(Fe, Z, Y, ne, _e, Te) {
          const De = (Te - Z) / (ne - Z);
          return qt(Fe, Te, Y + (_e - Y) * De, 1), De;
        }
        function Cr(Fe, Z, Y, ne, _e, Te) {
          const De = (Te - Y) / (_e - Y);
          return qt(Fe, Z + (ne - Z) * De, Te, 1), De;
        }
        function Ct(Fe, Z) {
          const Y = [];
          for (let ne = 0; ne < Fe.length; ne++) {
            const _e = Fe[ne], Te = _e.type;
            let De;
            if (Te === "Point" || Te === "MultiPoint" || Te === "LineString") De = Ee(_e.geometry, Z);
            else if (Te === "MultiLineString" || Te === "Polygon") {
              De = [];
              for (const he of _e.geometry) De.push(Ee(he, Z));
            } else if (Te === "MultiPolygon") {
              De = [];
              for (const he of _e.geometry) {
                const ve = [];
                for (const je of he) ve.push(Ee(je, Z));
                De.push(ve);
              }
            }
            Y.push(yt(_e.id, Te, De, _e.tags));
          }
          return Y;
        }
        function Ee(Fe, Z) {
          const Y = [];
          Y.size = Fe.size, Fe.start !== void 0 && (Y.start = Fe.start, Y.end = Fe.end);
          for (let ne = 0; ne < Fe.length; ne += 3) Y.push(Fe[ne] + Z, Fe[ne + 1], Fe[ne + 2]);
          return Y;
        }
        function ot(Fe, Z) {
          if (Fe.transformed) return Fe;
          const Y = 1 << Fe.z, ne = Fe.x, _e = Fe.y;
          for (const Te of Fe.features) {
            const De = Te.geometry, he = Te.type;
            if (Te.geometry = [], he === 1) for (let ve = 0; ve < De.length; ve += 2) Te.geometry.push(Le(De[ve], De[ve + 1], Z, Y, ne, _e));
            else for (let ve = 0; ve < De.length; ve++) {
              const je = [];
              for (let it = 0; it < De[ve].length; it += 2) je.push(Le(De[ve][it], De[ve][it + 1], Z, Y, ne, _e));
              Te.geometry.push(je);
            }
          }
          return Fe.transformed = true, Fe;
        }
        function Le(Fe, Z, Y, ne, _e, Te) {
          return [Math.round(Y * (Fe * ne - _e)), Math.round(Y * (Z * ne - Te))];
        }
        function Ye(Fe, Z, Y, ne, _e) {
          const Te = Z === _e.maxZoom ? 0 : _e.tolerance / ((1 << Z) * _e.extent), De = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Fe.length, source: null, x: Y, y: ne, z: Z, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const he of Fe) ft(De, he, Te, _e);
          return De;
        }
        function ft(Fe, Z, Y, ne) {
          const _e = Z.geometry, Te = Z.type, De = [];
          if (Fe.minX = Math.min(Fe.minX, Z.minX), Fe.minY = Math.min(Fe.minY, Z.minY), Fe.maxX = Math.max(Fe.maxX, Z.maxX), Fe.maxY = Math.max(Fe.maxY, Z.maxY), Te === "Point" || Te === "MultiPoint") for (let he = 0; he < _e.length; he += 3) De.push(_e[he], _e[he + 1]), Fe.numPoints++, Fe.numSimplified++;
          else if (Te === "LineString") bt(De, _e, Fe, Y, false, false);
          else if (Te === "MultiLineString" || Te === "Polygon") for (let he = 0; he < _e.length; he++) bt(De, _e[he], Fe, Y, Te === "Polygon", he === 0);
          else if (Te === "MultiPolygon") for (let he = 0; he < _e.length; he++) {
            const ve = _e[he];
            for (let je = 0; je < ve.length; je++) bt(De, ve[je], Fe, Y, true, je === 0);
          }
          if (De.length) {
            let he = Z.tags || null;
            if (Te === "LineString" && ne.lineMetrics) {
              he = {};
              for (const je in Z.tags) he[je] = Z.tags[je];
              he.mapbox_clip_start = _e.start / _e.size, he.mapbox_clip_end = _e.end / _e.size;
            }
            const ve = { geometry: De, type: Te === "Polygon" || Te === "MultiPolygon" ? 3 : Te === "LineString" || Te === "MultiLineString" ? 2 : 1, tags: he };
            Z.id !== null && (ve.id = Z.id), Fe.features.push(ve);
          }
        }
        function bt(Fe, Z, Y, ne, _e, Te) {
          const De = ne * ne;
          if (ne > 0 && Z.size < (_e ? De : ne)) return void (Y.numPoints += Z.length / 3);
          const he = [];
          for (let ve = 0; ve < Z.length; ve += 3) (ne === 0 || Z[ve + 2] > De) && (Y.numSimplified++, he.push(Z[ve], Z[ve + 1])), Y.numPoints++;
          _e && (function(ve, je) {
            let it = 0;
            for (let Xe = 0, wt = ve.length, Pe = wt - 2; Xe < wt; Pe = Xe, Xe += 2) it += (ve[Xe] - ve[Pe]) * (ve[Xe + 1] + ve[Pe + 1]);
            if (it > 0 === je) for (let Xe = 0, wt = ve.length; Xe < wt / 2; Xe += 2) {
              const Pe = ve[Xe], $t = ve[Xe + 1];
              ve[Xe] = ve[wt - 2 - Xe], ve[Xe + 1] = ve[wt - 1 - Xe], ve[wt - 2 - Xe] = Pe, ve[wt - 1 - Xe] = $t;
            }
          })(he, Te), Fe.push(he);
        }
        const tt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class mt {
          constructor(Z, Y) {
            const ne = (Y = this.options = (function(Te, De) {
              for (const he in De) Te[he] = De[he];
              return Te;
            })(Object.create(tt), Y)).debug;
            if (ne && console.time("preprocess data"), Y.maxZoom < 0 || Y.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Y.promoteId && Y.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let _e = (function(Te, De) {
              const he = [];
              if (Te.type === "FeatureCollection") for (let ve = 0; ve < Te.features.length; ve++) ut(he, Te.features[ve], De, ve);
              else ut(he, Te.type === "Feature" ? Te : { geometry: Te }, De);
              return he;
            })(Z, Y);
            this.tiles = {}, this.tileCoords = [], ne && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Y.indexMaxZoom, Y.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), _e = (function(Te, De) {
              const he = De.buffer / De.extent;
              let ve = Te;
              const je = tr(Te, 1, -1 - he, he, 0, -1, 2, De), it = tr(Te, 1, 1 - he, 2 + he, 0, -1, 2, De);
              return (je || it) && (ve = tr(Te, 1, -he, 1 + he, 0, -1, 2, De) || [], je && (ve = Ct(je, 1).concat(ve)), it && (ve = ve.concat(Ct(it, -1)))), ve;
            })(_e, Y), _e.length && this.splitTile(_e, 0, 0, 0), ne && (_e.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(Z, Y, ne, _e, Te, De, he) {
            const ve = [Z, Y, ne, _e], je = this.options, it = je.debug;
            for (; ve.length; ) {
              _e = ve.pop(), ne = ve.pop(), Y = ve.pop(), Z = ve.pop();
              const Xe = 1 << Y, wt = Zt(Y, ne, _e);
              let Pe = this.tiles[wt];
              if (!Pe && (it > 1 && console.time("creation"), Pe = this.tiles[wt] = Ye(Z, Y, ne, _e, je), this.tileCoords.push({ z: Y, x: ne, y: _e }), it)) {
                it > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Y, ne, _e, Pe.numFeatures, Pe.numPoints, Pe.numSimplified), console.timeEnd("creation"));
                const Wr = `z${Y}`;
                this.stats[Wr] = (this.stats[Wr] || 0) + 1, this.total++;
              }
              if (Pe.source = Z, Te == null) {
                if (Y === je.indexMaxZoom || Pe.numPoints <= je.indexMaxPoints) continue;
              } else {
                if (Y === je.maxZoom || Y === Te) continue;
                if (Te != null) {
                  const Wr = Te - Y;
                  if (ne !== De >> Wr || _e !== he >> Wr) continue;
                }
              }
              if (Pe.source = null, Z.length === 0) continue;
              it > 1 && console.time("clipping");
              const $t = 0.5 * je.buffer / je.extent, Qt = 0.5 - $t, Nt = 0.5 + $t, ur = 1 + $t;
              let Br = null, Qr = null, ei = null, ni = null, gr = tr(Z, Xe, ne - $t, ne + Nt, 0, Pe.minX, Pe.maxX, je), yr = tr(Z, Xe, ne + Qt, ne + ur, 0, Pe.minX, Pe.maxX, je);
              Z = null, gr && (Br = tr(gr, Xe, _e - $t, _e + Nt, 1, Pe.minY, Pe.maxY, je), Qr = tr(gr, Xe, _e + Qt, _e + ur, 1, Pe.minY, Pe.maxY, je), gr = null), yr && (ei = tr(yr, Xe, _e - $t, _e + Nt, 1, Pe.minY, Pe.maxY, je), ni = tr(yr, Xe, _e + Qt, _e + ur, 1, Pe.minY, Pe.maxY, je), yr = null), it > 1 && console.timeEnd("clipping"), ve.push(Br || [], Y + 1, 2 * ne, 2 * _e), ve.push(Qr || [], Y + 1, 2 * ne, 2 * _e + 1), ve.push(ei || [], Y + 1, 2 * ne + 1, 2 * _e), ve.push(ni || [], Y + 1, 2 * ne + 1, 2 * _e + 1);
            }
          }
          getTile(Z, Y, ne) {
            Z = +Z, Y = +Y, ne = +ne;
            const _e = this.options, { extent: Te, debug: De } = _e;
            if (Z < 0 || Z > 24) return null;
            const he = 1 << Z, ve = Zt(Z, Y = Y + he & he - 1, ne);
            if (this.tiles[ve]) return ot(this.tiles[ve], Te);
            De > 1 && console.log("drilling down to z%d-%d-%d", Z, Y, ne);
            let je, it = Z, Xe = Y, wt = ne;
            for (; !je && it > 0; ) it--, Xe >>= 1, wt >>= 1, je = this.tiles[Zt(it, Xe, wt)];
            return je && je.source ? (De > 1 && (console.log("found parent tile z%d-%d-%d", it, Xe, wt), console.time("drilling down")), this.splitTile(je.source, it, Xe, wt, Z, Y, ne), De > 1 && console.timeEnd("drilling down"), this.tiles[ve] ? ot(this.tiles[ve], Te) : null) : null;
          }
        }
        function Zt(Fe, Z, Y) {
          return 32 * ((1 << Fe) * Y + Z) + Fe;
        }
        class ii extends z {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              const ne = Z.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const _e = this._geoJSONIndex.getTile(ne.z, ne.x, ne.y);
              if (!_e) return null;
              const Te = new Q(_e.features, { version: 2, extent: m.$ });
              let De = (function(he) {
                const ve = new m.cM();
                return (function(je, it) {
                  for (const Xe in je.layers) it.writeMessage(3, ie, je.layers[Xe]);
                })(he, ve), ve.finish();
              })(Te);
              return De.byteOffset === 0 && De.byteLength === De.buffer.byteLength || (De = new Uint8Array(De)), { vectorTile: Te, rawData: De.buffer };
            }));
          }
          loadData(Z) {
            return m._(this, void 0, void 0, (function* () {
              var Y;
              (Y = this._pendingRequest) === null || Y === void 0 || Y.abort();
              const ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(Z, this._pendingRequest);
                const _e = yield this._pendingData;
                this._geoJSONIndex = Z.cluster ? new Ve((function({ superclusterOptions: De, clusterProperties: he }) {
                  if (!he || !De) return De;
                  const ve = {}, je = {}, it = { accumulated: null, zoom: 0 }, Xe = { properties: null }, wt = Object.keys(he);
                  for (const Pe of wt) {
                    const [$t, Qt] = he[Pe], Nt = m.cT(Qt), ur = m.cT(typeof $t == "string" ? [$t, ["accumulated"], ["get", Pe]] : $t);
                    ve[Pe] = Nt.value, je[Pe] = ur.value;
                  }
                  return De.map = (Pe) => {
                    Xe.properties = Pe;
                    const $t = {};
                    for (const Qt of wt) $t[Qt] = ve[Qt].evaluate(it, Xe);
                    return $t;
                  }, De.reduce = (Pe, $t) => {
                    Xe.properties = $t;
                    for (const Qt of wt) it.accumulated = Pe[Qt], Pe[Qt] = je[Qt].evaluate(it, Xe);
                  }, De;
                })(Z)).load(_e.features) : (function(De, he) {
                  return new mt(De, he);
                })(_e, Z.geojsonVtOptions), this.loaded = {};
                const Te = { data: _e };
                if (ne) {
                  const De = ne.finish();
                  De && (Te.resourceTiming = {}, Te.resourceTiming[Z.source] = JSON.parse(JSON.stringify(De)));
                }
                return Te;
              } catch (_e) {
                if (delete this._pendingRequest, m.cy(_e)) return { abandoned: true };
                throw _e;
              }
            }));
          }
          getData() {
            return m._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(Z) {
            const Y = this.loaded;
            return Y && Y[Z.uid] ? super.reloadTile(Z) : this.loadTile(Z);
          }
          loadAndProcessGeoJSON(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              let ne = yield this.loadGeoJSON(Z, Y);
              if (delete this._pendingRequest, typeof ne != "object") throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (X(ne, true), Z.filter) {
                const _e = m.cT(Z.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (_e.result === "error") throw new Error(_e.value.map(((De) => `${De.key}: ${De.message}`)).join(", "));
                ne = { type: "FeatureCollection", features: ne.features.filter(((De) => _e.value.evaluate({ zoom: 0 }, De))) };
              }
              return ne;
            }));
          }
          loadGeoJSON(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              const { promoteId: ne } = Z;
              if (Z.request) {
                const _e = yield m.j(Z.request, Y);
                return this._dataUpdateable = m.cV(_e.data, ne) ? m.cU(_e.data, ne) : void 0, _e.data;
              }
              if (typeof Z.data == "string") try {
                const _e = JSON.parse(Z.data);
                return this._dataUpdateable = m.cV(_e, ne) ? m.cU(_e, ne) : void 0, _e;
              } catch {
                throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              }
              if (!Z.dataDiff) throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${Z.source}`);
              return m.cW(this._dataUpdateable, Z.dataDiff, ne), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(Z) {
            return m._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(Z) {
            return this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId);
          }
          getClusterChildren(Z) {
            return this._geoJSONIndex.getChildren(Z.clusterId);
          }
          getClusterLeaves(Z) {
            return this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset);
          }
        }
        class wi {
          constructor(Z) {
            this.self = Z, this.actor = new m.J(Z), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (Y, ne) => {
              if (this.externalWorkerSourceTypes[Y]) throw new Error(`Worker source with name "${Y}" already registered.`);
              this.externalWorkerSourceTypes[Y] = ne;
            }, this.self.addProtocol = m.cA, this.self.removeProtocol = m.cB, this.self.registerRTLTextPlugin = (Y) => {
              m.cX.setMethods(Y);
            }, this.actor.registerMessageHandler("LDT", ((Y, ne) => this._getDEMWorkerSource(Y, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RDT", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(Y, ne.source).removeTile(ne);
            })))), this.actor.registerMessageHandler("GCEZ", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterExpansionZoom(ne);
            })))), this.actor.registerMessageHandler("GCC", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterChildren(ne);
            })))), this.actor.registerMessageHandler("GCL", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterLeaves(ne);
            })))), this.actor.registerMessageHandler("LD", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).loadData(ne))), this.actor.registerMessageHandler("GD", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).getData())), this.actor.registerMessageHandler("LT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).reloadTile(ne))), this.actor.registerMessageHandler("AT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).abortTile(ne))), this.actor.registerMessageHandler("RMT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).removeTile(ne))), this.actor.registerMessageHandler("RS", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              if (!this.workerSources[Y] || !this.workerSources[Y][ne.type] || !this.workerSources[Y][ne.type][ne.source]) return;
              const _e = this.workerSources[Y][ne.type][ne.source];
              delete this.workerSources[Y][ne.type][ne.source], _e.removeSource !== void 0 && _e.removeSource(ne);
            })))), this.actor.registerMessageHandler("RM", ((Y) => m._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[Y], delete this.availableImages[Y], delete this.workerSources[Y], delete this.demWorkerSources[Y];
            })))), this.actor.registerMessageHandler("SR", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              this.referrer = ne;
            })))), this.actor.registerMessageHandler("SRPS", ((Y, ne) => this._syncRTLPluginState(Y, ne))), this.actor.registerMessageHandler("IS", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              this.self.importScripts(ne);
            })))), this.actor.registerMessageHandler("SI", ((Y, ne) => this._setImages(Y, ne))), this.actor.registerMessageHandler("UL", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).update(ne.layers, ne.removedIds);
            })))), this.actor.registerMessageHandler("SL", ((Y, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).replace(ne);
            }))));
          }
          _setImages(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              this.availableImages[Z] = Y;
              for (const ne in this.workerSources[Z]) {
                const _e = this.workerSources[Z][ne];
                for (const Te in _e) _e[Te].availableImages = Y;
              }
            }));
          }
          _syncRTLPluginState(Z, Y) {
            return m._(this, void 0, void 0, (function* () {
              return yield m.cX.syncState(Y, this.self.importScripts);
            }));
          }
          _getAvailableImages(Z) {
            let Y = this.availableImages[Z];
            return Y || (Y = []), Y;
          }
          _getLayerIndex(Z) {
            let Y = this.layerIndexes[Z];
            return Y || (Y = this.layerIndexes[Z] = new s()), Y;
          }
          _getWorkerSource(Z, Y, ne) {
            if (this.workerSources[Z] || (this.workerSources[Z] = {}), this.workerSources[Z][Y] || (this.workerSources[Z][Y] = {}), !this.workerSources[Z][Y][ne]) {
              const _e = { sendAsync: (Te, De) => (Te.targetMapId = Z, this.actor.sendAsync(Te, De)) };
              switch (Y) {
                case "vector":
                  this.workerSources[Z][Y][ne] = new z(_e, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                case "geojson":
                  this.workerSources[Z][Y][ne] = new ii(_e, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                default:
                  this.workerSources[Z][Y][ne] = new this.externalWorkerSourceTypes[Y](_e, this._getLayerIndex(Z), this._getAvailableImages(Z));
              }
            }
            return this.workerSources[Z][Y][ne];
          }
          _getDEMWorkerSource(Z, Y) {
            return this.demWorkerSources[Z] || (this.demWorkerSources[Z] = {}), this.demWorkerSources[Z][Y] || (this.demWorkerSources[Z][Y] = new L()), this.demWorkerSources[Z][Y];
          }
        }
        return m.i(self) && (self.worker = new wi(self)), wi;
      })), f("index", ["exports", "./shared"], (function(m, s) {
        var C = "5.7.1";
        function T() {
          var v = new s.A(4);
          return s.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let M, z;
        const L = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(v, e, a) {
          const c = requestAnimationFrame(((_) => {
            p(), e(_);
          })), { unsubscribe: p } = s.s(v.signal, "abort", (() => {
            p(), cancelAnimationFrame(c), a(s.c());
          }), false);
        }, frameAsync(v) {
          return new Promise(((e, a) => {
            this.frame(v, e, a);
          }));
        }, getImageData(v, e = 0) {
          return this.getImageCanvasContext(v).getImageData(-e, -e, v.width + 2 * e, v.height + 2 * e);
        }, getImageCanvasContext(v) {
          const e = window.document.createElement("canvas"), a = e.getContext("2d", { willReadFrequently: true });
          if (!a) throw new Error("failed to create canvas 2d context");
          return e.width = v.width, e.height = v.height, a.drawImage(v, 0, 0, v.width, v.height), a;
        }, resolveURL: (v) => (M || (M = document.createElement("a")), M.href = v, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (z == null && (z = matchMedia("(prefers-reduced-motion: reduce)")), z.matches);
        } };
        class A {
          static testProp(e) {
            if (!A.docStyle) return e[0];
            for (let a = 0; a < e.length; a++) if (e[a] in A.docStyle) return e[a];
            return e[0];
          }
          static create(e, a, c) {
            const p = window.document.createElement(e);
            return a !== void 0 && (p.className = a), c && c.appendChild(p), p;
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a);
          }
          static disableDrag() {
            A.docStyle && A.selectProp && (A.userSelect = A.docStyle[A.selectProp], A.docStyle[A.selectProp] = "none");
          }
          static enableDrag() {
            A.docStyle && A.selectProp && (A.docStyle[A.selectProp] = A.userSelect);
          }
          static setTransform(e, a) {
            e.style[A.transformProp] = a;
          }
          static addEventListener(e, a, c, p = {}) {
            e.addEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static removeEventListener(e, a, c, p = {}) {
            e.removeEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", A.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", A.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", A.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return { x: a.width / e.offsetWidth || 1, y: a.height / e.offsetHeight || 1, boundingClientRect: a };
          }
          static getPoint(e, a, c) {
            const p = a.boundingClientRect;
            return new s.P((c.clientX - p.left) / a.x - e.clientLeft, (c.clientY - p.top) / a.y - e.clientTop);
          }
          static mousePos(e, a) {
            const c = A.getScale(e);
            return A.getPoint(e, c, a);
          }
          static touchPos(e, a) {
            const c = [], p = A.getScale(e);
            for (let _ = 0; _ < a.length; _++) c.push(A.getPoint(e, p, a[_]));
            return c;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), c = a.querySelectorAll("script");
            for (const p of c) p.remove();
            return A.clean(a), a.innerHTML;
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) A.removeAttributes(c), A.clean(c);
          }
          static removeAttributes(e) {
            for (const { name: a, value: c } of e.attributes) A.isPossiblyDangerous(a, c) && e.removeAttribute(a);
          }
        }
        A.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, A.selectProp = A.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), A.transformProp = A.testProp(["transform", "WebkitTransform"]);
        const O = { supported: false, testSupport: function(v) {
          !H && X && (Q ? ie(v) : U = v);
        } };
        let U, X, H = false, Q = false;
        function ie(v) {
          const e = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, e);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, X), v.isContextLost()) return;
            O.supported = true;
          } catch {
          }
          v.deleteTexture(e), H = true;
        }
        var te;
        typeof document < "u" && (X = document.createElement("img"), X.onload = () => {
          U && ie(U), U = null, Q = true;
        }, X.onerror = () => {
          H = true, U = null;
        }, X.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(v) {
          let e, a, c, p;
          v.resetRequestQueue = () => {
            e = [], a = 0, c = 0, p = {};
          }, v.addThrottleControl = (P) => {
            const R = c++;
            return p[R] = P, R;
          }, v.removeThrottleControl = (P) => {
            delete p[P], x();
          }, v.getImage = (P, R, D = true) => new Promise(((j, $) => {
            O.supported && (P.headers || (P.headers = {}), P.headers.accept = "image/webp,*/*"), s.e(P, { type: "image" }), e.push({ abortController: R, requestParameters: P, supportImageRefresh: D, state: "queued", onError: (V) => {
              $(V);
            }, onSuccess: (V) => {
              j(V);
            } }), x();
          }));
          const _ = (P) => s._(this, void 0, void 0, (function* () {
            P.state = "running";
            const { requestParameters: R, supportImageRefresh: D, onError: j, onSuccess: $, abortController: V } = P, W = D === false && !s.i(self) && !s.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((ce, me) => ce && me === "accept"), true));
            a++;
            const le = W ? k(R, V) : s.m(R, V);
            try {
              const ce = yield le;
              delete P.abortController, P.state = "completed", ce.data instanceof HTMLImageElement || s.b(ce.data) ? $(ce) : ce.data && $({ data: yield (se = ce.data, typeof createImageBitmap == "function" ? s.f(se) : s.h(se)), cacheControl: ce.cacheControl, expires: ce.expires });
            } catch (ce) {
              delete P.abortController, j(ce);
            } finally {
              a--, x();
            }
            var se;
          })), x = () => {
            const P = (() => {
              for (const R of Object.keys(p)) if (p[R]()) return true;
              return false;
            })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = a; R < P && e.length > 0; R++) {
              const D = e.shift();
              D.abortController.signal.aborted ? R-- : _(D);
            }
          }, k = (P, R) => new Promise(((D, j) => {
            const $ = new Image(), V = P.url, W = P.credentials;
            W && W === "include" ? $.crossOrigin = "use-credentials" : (W && W === "same-origin" || !s.d(V)) && ($.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              $.src = "", j(s.c());
            })), $.fetchPriority = "high", $.onload = () => {
              $.onerror = $.onload = null, D({ data: $ });
            }, $.onerror = () => {
              $.onerror = $.onload = null, R.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, $.src = V;
          }));
        })(te || (te = {})), te.resetRequestQueue();
        class re {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function J(v) {
          const e = [];
          if (typeof v == "string") e.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const a = [];
            for (const { id: c, url: p } of v) {
              const _ = `${c}${p}`;
              a.indexOf(_) === -1 && (a.push(_), e.push({ id: c, url: p }));
            }
          }
          return e;
        }
        function Se(v, e, a) {
          try {
            const c = new URL(v);
            return c.pathname += `${e}${a}`, c.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function fe(v) {
          const { userImage: e } = v;
          return !!(e && e.render && e.render()) && (v.data.replace(new Uint8Array(e.data.buffer)), true);
        }
        class oe extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: a, promiseResolve: c } of this.requestors) c(this._getImagesForIds(a));
              this.requestors = [];
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new s.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null;
            }
            return a;
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a);
          }
          _validate(e, a) {
            let c = true;
            const p = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, p && p.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = false), this._validateStretch(a.stretchY, p && p.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = false), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), c = false), c;
          }
          _validateStretch(e, a) {
            if (!e) return true;
            let c = 0;
            for (const p of e) {
              if (p[0] < c || p[1] < p[0] || a < p[1]) return false;
              c = p[1];
            }
            return true;
          }
          _validateContent(e, a) {
            if (!e) return true;
            if (e.length !== 4) return false;
            const c = a.spriteData, p = c && c.width || a.data.width, _ = c && c.height || a.data.height;
            return !(e[0] < 0 || p < e[0] || e[1] < 0 || _ < e[1] || e[2] < 0 || p < e[2] || e[3] < 0 || _ < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, a, c = true) {
            const p = this.getImage(e);
            if (c && (p.data.width !== a.data.width || p.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${p.data.width}x${p.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = p.version + 1, this.images[e] = a, this.updatedImages[e] = true;
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let p = true;
              if (!this.isLoaded()) for (const _ of e) this.images[_] || (p = false);
              this.isLoaded() || p ? a(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: a });
            }));
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let p = this.getImage(c);
              p || (this.fire(new s.l("styleimagemissing", { id: c })), p = this.getImage(c)), p ? a[c] = { data: p.data.clone(), pixelRatio: p.pixelRatio, sdf: p.sdf, version: p.version, stretchX: p.stretchX, stretchY: p.stretchY, content: p.content, textFitWidth: p.textFitWidth, textFitHeight: p.textFitHeight, hasRenderCallback: !!(p.userImage && p.userImage.render) } : s.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return a;
          }
          getPixelSize() {
            const { width: e, height: a } = this.atlasImage;
            return { width: e, height: a };
          }
          getPattern(e) {
            const a = this.patterns[e], c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const p = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, _ = new s.I(p, c);
              this.patterns[e] = { bin: p, position: _ };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const _ in this.patterns) e.push(this.patterns[_].bin);
            const { w: a, h: c } = s.p(e), p = this.atlasImage;
            p.resize({ width: a || 1, height: c || 1 });
            for (const _ in this.patterns) {
              const { bin: x } = this.patterns[_], k = x.x + 1, P = x.y + 1, R = this.getImage(_).data, D = R.width, j = R.height;
              s.R.copy(R, p, { x: 0, y: 0 }, { x: k, y: P }, { width: D, height: j }), s.R.copy(R, p, { x: 0, y: j - 1 }, { x: k, y: P - 1 }, { width: D, height: 1 }), s.R.copy(R, p, { x: 0, y: 0 }, { x: k, y: P + j }, { width: D, height: 1 }), s.R.copy(R, p, { x: D - 1, y: 0 }, { x: k - 1, y: P }, { width: 1, height: j }), s.R.copy(R, p, { x: 0, y: 0 }, { x: k + D, y: P }, { width: 1, height: j });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = true;
              const c = this.getImage(a);
              c || s.w(`Image with ID: "${a}" was not found`), fe(c) && this.updateImage(a, c);
            }
          }
        }
        const de = 1e20;
        function xe(v, e, a, c, p, _, x, k, P) {
          for (let R = e; R < e + c; R++) $e(v, a * _ + R, _, p, x, k, P);
          for (let R = a; R < a + p; R++) $e(v, R * _ + e, 1, c, x, k, P);
        }
        function $e(v, e, a, c, p, _, x) {
          _[0] = 0, x[0] = -de, x[1] = de, p[0] = v[e];
          for (let k = 1, P = 0, R = 0; k < c; k++) {
            p[k] = v[e + k * a];
            const D = k * k;
            do {
              const j = _[P];
              R = (p[k] - p[j] + D - j * j) / (k - j) / 2;
            } while (R <= x[P] && --P > -1);
            P++, _[P] = k, x[P] = R, x[P + 1] = de;
          }
          for (let k = 0, P = 0; k < c; k++) {
            for (; x[P + 1] < k; ) P++;
            const R = _[P], D = k - R;
            v[e + k * a] = p[R] + D * D;
          }
        }
        class Ve {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = [];
              for (const _ in e) for (const x of e[_]) a.push(this._getAndCacheGlyphsPromise(_, x));
              const c = yield Promise.all(a), p = {};
              for (const { stack: _, id: x, glyph: k } of c) p[_] || (p[_] = {}), p[_][x] = k && { id: k.id, bitmap: k.bitmap.clone(), metrics: k.metrics };
              return p;
            }));
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function* () {
              let c = this.entries[e];
              c || (c = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let p = c.glyphs[a];
              if (p !== void 0) return { stack: e, id: a, glyph: p };
              if (p = this._tinySDF(c, e, a), p) return c.glyphs[a] = p, { stack: e, id: a, glyph: p };
              const _ = Math.floor(a / 256);
              if (256 * _ > 65535) throw new Error("glyphs > 65535 not supported");
              if (c.ranges[_]) return { stack: e, id: a, glyph: p };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!c.requests[_]) {
                const k = Ve.loadGlyphRange(e, _, this.url, this.requestManager);
                c.requests[_] = k;
              }
              const x = yield c.requests[_];
              for (const k in x) this._doesCharSupportLocalGlyph(+k) || (c.glyphs[+k] = x[+k]);
              return c.ranges[_] = true, { stack: e, id: a, glyph: x[a] || null };
            }));
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, a, c) {
            const p = this.localIdeographFontFamily;
            if (!p || !this._doesCharSupportLocalGlyph(c)) return;
            let _ = e.tinySDF;
            if (!_) {
              let k = "400";
              /bold/i.test(a) ? k = "900" : /medium/i.test(a) ? k = "500" : /light/i.test(a) && (k = "200"), _ = e.tinySDF = new Ve.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: p, fontWeight: k });
            }
            const x = _.draw(String.fromCharCode(c));
            return { id: c, bitmap: new s.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        Ve.loadGlyphRange = function(v, e, a, c) {
          return s._(this, void 0, void 0, (function* () {
            const p = 256 * e, _ = p + 255, x = c.transformRequest(a.replace("{fontstack}", v).replace("{range}", `${p}-${_}`), "Glyphs"), k = yield s.n(x, new AbortController());
            if (!k || !k.data) throw new Error(`Could not load glyph range. range: ${e}, ${p}-${_}`);
            const P = {};
            for (const R of s.o(k.data)) P[R.id] = R;
            return P;
          }));
        }, Ve.TinySDF = class {
          constructor({ fontSize: v = 24, buffer: e = 3, radius: a = 8, cutoff: c = 0.25, fontFamily: p = "sans-serif", fontWeight: _ = "normal", fontStyle: x = "normal", lang: k = null } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = k;
            const P = this.size = v + 4 * e, R = this._createCanvas(P), D = this.ctx = R.getContext("2d", { willReadFrequently: true });
            D.font = `${x} ${_} ${v}px ${p}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P);
          }
          _createCanvas(v) {
            const e = document.createElement("canvas");
            return e.width = e.height = v, e;
          }
          draw(v) {
            const { width: e, actualBoundingBoxAscent: a, actualBoundingBoxDescent: c, actualBoundingBoxLeft: p, actualBoundingBoxRight: _ } = this.ctx.measureText(v), x = Math.ceil(a), k = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(_ - p))), P = Math.min(this.size - this.buffer, x + Math.ceil(c)), R = k + 2 * this.buffer, D = P + 2 * this.buffer, j = Math.max(R * D, 0), $ = new Uint8ClampedArray(j), V = { data: $, width: R, height: D, glyphWidth: k, glyphHeight: P, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
            if (k === 0 || P === 0) return V;
            const { ctx: W, buffer: le, gridInner: se, gridOuter: ce } = this;
            this.lang && (W.lang = this.lang), W.clearRect(le, le, k, P), W.fillText(v, le, le + x);
            const me = W.getImageData(le, le, k, P);
            ce.fill(de, 0, j), se.fill(0, 0, j);
            for (let we = 0; we < P; we++) for (let ye = 0; ye < k; ye++) {
              const ke = me.data[4 * (we * k + ye) + 3] / 255;
              if (ke === 0) continue;
              const Me = (we + le) * R + ye + le;
              if (ke === 1) ce[Me] = 0, se[Me] = de;
              else {
                const be = 0.5 - ke;
                ce[Me] = be > 0 ? be * be : 0, se[Me] = be < 0 ? be * be : 0;
              }
            }
            xe(ce, 0, 0, R, D, R, this.f, this.v, this.z), xe(se, le, le, k, P, R, this.f, this.v, this.z);
            for (let we = 0; we < j; we++) {
              const ye = Math.sqrt(ce[we]) - Math.sqrt(se[we]);
              $[we] = Math.round(255 - 255 * (ye / this.radius + this.cutoff));
            }
            return V;
          }
        };
        class Ke {
          constructor() {
            this.specification = s.v.light.position;
          }
          possiblyEvaluate(e, a) {
            return s.B(e.expression.evaluate(a));
          }
          interpolate(e, a, c) {
            return { x: s.C.number(e.x, a.x, c), y: s.C.number(e.y, a.y, c), z: s.C.number(e.z, a.z, c) };
          }
        }
        let lt;
        class vt extends s.E {
          constructor(e) {
            super(), lt = lt || new s.r({ anchor: new s.D(s.v.light.anchor), position: new Ke(), color: new s.D(s.v.light.color), intensity: new s.D(s.v.light.intensity) }), this._transitionable = new s.t(lt), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, a = {}) {
            if (!this._validate(s.x, e, a)) for (const c in e) {
              const p = e[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c) {
            return (!c || c.validate !== false) && s.y(this, e.call(s.z, { value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v }));
          }
        }
        const xt = new s.r({ "sky-color": new s.D(s.v.sky["sky-color"]), "horizon-color": new s.D(s.v.sky["horizon-color"]), "fog-color": new s.D(s.v.sky["fog-color"]), "fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"]) });
        class at extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(xt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0));
          }
          setSky(e, a = {}) {
            if (!this._validate(s.G, e, a)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const c in e) {
                const p = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== false && s.y(this, e.call(s.z, s.e({ value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class et {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c];
          }
          getDashRanges(e, a, c) {
            const p = [];
            let _ = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, x = e[0] * c, k = true;
            p.push({ left: _, right: x, isDash: k, zeroLength: e[0] === 0 });
            let P = e[0];
            for (let R = 1; R < e.length; R++) {
              k = !k;
              const D = e[R];
              _ = P * c, P += D, x = P * c, p.push({ left: _, right: x, isDash: k, zeroLength: D === 0 });
            }
            return p;
          }
          addRoundDash(e, a, c) {
            const p = a / 2;
            for (let _ = -c; _ <= c; _++) {
              const x = this.width * (this.nextRow + c + _);
              let k = 0, P = e[k];
              for (let R = 0; R < this.width; R++) {
                R / P.right > 1 && (P = e[++k]);
                const D = Math.abs(R - P.left), j = Math.abs(R - P.right), $ = Math.min(D, j);
                let V;
                const W = _ / c * (p + 1);
                if (P.isDash) {
                  const le = p - Math.abs(W);
                  V = Math.sqrt($ * $ + le * le);
                } else V = p - Math.sqrt($ * $ + W * W);
                this.data[x + R] = Math.max(0, Math.min(255, V + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let k = e.length - 1; k >= 0; --k) {
              const P = e[k], R = e[k + 1];
              P.zeroLength ? e.splice(k, 1) : R && R.isDash === P.isDash && (R.left = P.left, e.splice(k, 1));
            }
            const a = e[0], c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const p = this.width * this.nextRow;
            let _ = 0, x = e[_];
            for (let k = 0; k < this.width; k++) {
              k / x.right > 1 && (x = e[++_]);
              const P = Math.abs(k - x.left), R = Math.abs(k - x.right), D = Math.min(P, R);
              this.data[p + k] = Math.max(0, Math.min(255, (x.isDash ? D : -D) + 128));
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0, p = 2 * c + 1;
            if (this.nextRow + p > this.height) return s.w("LineAtlas out of space"), null;
            let _ = 0;
            for (let k = 0; k < e.length; k++) _ += e[k];
            if (_ !== 0) {
              const k = this.width / _, P = this.getDashRanges(e, this.width, k);
              a ? this.addRoundDash(P, k, c) : this.addRegularDash(P);
            }
            const x = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: _ };
            return this.nextRow += p, this.dirty = true, x;
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data));
          }
        }
        const ht = "maplibre_preloaded_worker_pool";
        class yt {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < yt.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = true, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((a) => {
              a.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[ht];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const nt = Math.floor(L.hardwareConcurrency / 2);
        let ut, Lt;
        function Ht() {
          return ut || (ut = new yt()), ut;
        }
        yt.workerCount = s.H(globalThis) ? Math.max(Math.min(nt, 3), 1) : 1;
        class zt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let p = 0; p < c.length; p++) {
              const _ = new s.J(c[p], a);
              _.name = `Worker ${p}`, this.actors.push(_);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, a) {
            const c = [];
            for (const p of this.actors) c.push(p.sendAsync({ type: e, data: a }));
            return Promise.all(c);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = true) {
            this.actors.forEach(((a) => {
              a.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a);
          }
        }
        function pr() {
          return Lt || (Lt = new zt(Ht(), s.K), Lt.registerMessageHandler("GR", ((v, e, a) => s.m(e, a)))), Lt;
        }
        function Jt(v, e) {
          const a = s.L();
          return s.M(a, a, [1, 1, 0]), s.N(a, a, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? s.O(a, a, v.calculatePosMatrix(e.toUnwrapped())) : a;
        }
        function tr(v, e, a, c, p, _, x) {
          var k;
          const P = (function($, V, W) {
            if ($) for (const le of $) {
              const se = V[le];
              if (se && se.source === W && se.type === "fill-extrusion") return true;
            }
            else for (const le in V) {
              const se = V[le];
              if (se.source === W && se.type === "fill-extrusion") return true;
            }
            return false;
          })((k = p == null ? void 0 : p.layers) !== null && k !== void 0 ? k : null, e, v.id), R = _.maxPitchScaleFactor(), D = v.tilesIn(c, R, P);
          D.sort(wr);
          const j = [];
          for (const $ of D) j.push({ wrappedTileID: $.tileID.wrapped().key, queryResults: $.tile.queryRenderedFeatures(e, a, v._state, $.queryGeometry, $.cameraQueryGeometry, $.scale, p, _, R, Jt(v.transform, $.tileID), x ? (V, W) => x($.tileID, V, W) : void 0) });
          return (function($, V) {
            for (const W in $) for (const le of $[W]) Er(le, V);
            return $;
          })((function($) {
            const V = {}, W = {};
            for (const le of $) {
              const se = le.queryResults, ce = le.wrappedTileID, me = W[ce] = W[ce] || {};
              for (const we in se) {
                const ye = se[we], ke = me[we] = me[we] || {}, Me = V[we] = V[we] || [];
                for (const be of ye) ke[be.featureIndex] || (ke[be.featureIndex] = true, Me.push(be));
              }
            }
            return V;
          })(j), v);
        }
        function wr(v, e) {
          const a = v.tileID, c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x;
        }
        function Er(v, e) {
          const a = v.feature, c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c;
        }
        function rr(v, e, a) {
          return s._(this, void 0, void 0, (function* () {
            let c = v;
            if (v.url ? c = (yield s.j(e.transformRequest(v.url, "Source"), a)).data : yield L.frameAsync(a), !c) return null;
            const p = s.Q(s.e(c, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (p.vectorLayerIds = c.vector_layers.map(((_) => _.id))), p;
          }));
        }
        class sr {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          extend(e) {
            const a = this._sw, c = this._ne;
            let p, _;
            if (e instanceof s.S) p = e, _ = e;
            else {
              if (!(e instanceof sr)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(sr.convert(e)) : this.extend(s.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.S.convert(e)) : this;
              if (p = e._sw, _ = e._ne, !p || !_) return this;
            }
            return a || c ? (a.lng = Math.min(p.lng, a.lng), a.lat = Math.min(p.lat, a.lat), c.lng = Math.max(_.lng, c.lng), c.lat = Math.max(_.lat, c.lat)) : (this._sw = new s.S(p.lng, p.lat), this._ne = new s.S(_.lng, _.lat)), this;
          }
          getCenter() {
            return new s.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new s.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new s.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: a, lat: c } = s.S.convert(e);
            let p = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (p = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && p;
          }
          static convert(e) {
            return e instanceof sr ? e : e && new sr(e);
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017, p = c / Math.cos(Math.PI / 180 * e.lat);
            return new sr(new s.S(e.lng - p, e.lat - c), new s.S(e.lng + p, e.lat + c));
          }
          adjustAntiMeridian() {
            const e = new s.S(this._sw.lng, this._sw.lat), a = new s.S(this._ne.lng, this._ne.lat);
            return new sr(e, e.lng > a.lng ? new s.S(a.lng + 360, a.lat) : a);
          }
        }
        class qt {
          constructor(e, a, c) {
            this.bounds = sr.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const a = Math.pow(2, e.z), c = Math.floor(s.V(this.bounds.getWest()) * a), p = Math.floor(s.U(this.bounds.getNorth()) * a), _ = Math.ceil(s.V(this.bounds.getEast()) * a), x = Math.ceil(s.U(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < _ && e.y >= p && e.y < x;
          }
        }
        class Dr extends s.E {
          constructor(e, a, c, p) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, s.e(this, s.Q(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({ type: "vector" }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(p);
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new qt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new s.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return s.e({}, this._options);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(a, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let p = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((_, x) => {
                  e.reloadPromise = { resolve: _, reject: x };
                }));
              } else e.actor = this.dispatcher.getActor(), p = "LT";
              e.abortController = new AbortController();
              try {
                const _ = yield e.actor.sendAsync({ type: p, data: c }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, _);
              } catch (_) {
                if (delete e.abortController, e.aborted) return;
                if (_ && _.status !== 404) throw _;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject);
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Cr extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(p), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = s.e({ type: "raster" }, a), s.e(this, s.Q(a, ["url", "scheme", "tileSize"]));
          }
          load() {
            return s._(this, arguments, void 0, (function* (e = false) {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, a && (s.e(this, a), a.bounds && (this.tileBounds = new qt(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (a) {
                this._tileJSONRequest = null, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return s.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const c = yield te.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const p = this.map.painter.context, _ = p.gl, x = c.data;
                  e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: true }) : (e.texture = new s.T(p, x, _.RGBA, { useMipmap: true }), e.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE, _.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Ct extends Cr {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const p = yield te.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (p && p.data) {
                  const _ = p.data;
                  this.map._refreshExpiredTiles && (p.cacheControl || p.expires) && e.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                  const x = s.b(_) && s.W() ? _ : yield this.readImageNow(_), k = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const P = yield e.actor.sendAsync({ type: "LDT", data: k });
                    e.dem = P, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
                  }
                }
              } catch (p) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (p) throw e.state = "errored", p;
              }
            }));
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && s.X()) {
                const a = e.width + 2, c = e.height + 2;
                try {
                  return new s.R({ width: a, height: c }, yield s.Y(e, -1, -1, a, c));
                } catch {
                }
              }
              return L.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const a = e.canonical, c = Math.pow(2, a.z), p = (a.x - 1 + c) % c, _ = a.x === 0 ? e.wrap - 1 : e.wrap, x = (a.x + 1 + c) % c, k = a.x + 1 === c ? e.wrap + 1 : e.wrap, P = {};
            return P[new s.Z(e.overscaledZ, _, a.z, p, a.y).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y).key] = { backfilled: false }, a.y > 0 && (P[new s.Z(e.overscaledZ, _, a.z, p, a.y - 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y - 1).key] = { backfilled: false }), a.y + 1 < c && (P[new s.Z(e.overscaledZ, _, a.z, p, a.y + 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y + 1).key] = { backfilled: false }), P;
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        class Ee extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: a.data }, this.actor = c.getActor(), this.setEventedParent(p), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: a.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128), tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : 0.375), extent: s.$, maxZoom: this.maxzoom, lineMetrics: a.lineMetrics || false, generateId: a.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom), minPoints: Math.max(2, a.clusterMinPoints || 2), extent: s.$, radius: this._pixelsToTileUnits(a.clusterRadius || 50), log: false, generateId: a.generateId || false }, clusterProperties: a.clusterProperties, filter: a.filter }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (s.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return s._(this, void 0, void 0, (function* () {
              const e = s.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map(((a) => a.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return s._(this, void 0, void 0, (function* () {
              const e = new sr(), a = yield this.getData();
              let c;
              switch (a.type) {
                case "FeatureCollection":
                  c = a.features.map(((p) => this.getCoordinatesFromGeometry(p.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  c = this.getCoordinatesFromGeometry(a.geometry);
                  break;
                default:
                  c = this.getCoordinatesFromGeometry(a);
              }
              if (c.length == 0) return e;
              for (let p = 0; p < c.length - 1; p += 2) e.extend([c[p], c[p + 1]]);
              return e;
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: a, offset: c } });
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: a } = this._pendingWorkerUpdate;
              if (!e && !a) return void s.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const c = s.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(L.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = true, this.fire(new s.l("dataloading", { dataType: "source" }));
              try {
                const p = yield this.actor.sendAsync({ type: "LD", data: c });
                if (this._isUpdatingWorker = false, this._removed || p.abandoned) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this._data = p.data;
                let _ = null;
                p.resourceTiming && p.resourceTiming[this.id] && (_ = p.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && _ && _.length > 0 && s.e(x, { resourceTiming: _ }), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
              } catch (p) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this.fire(new s.k(p));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, globalState: this.map.getGlobalState() };
              e.abortController = new AbortController();
              const p = yield this.actor.sendAsync({ type: a, data: c }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(p, this.map.painter, a === "RT");
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return s.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class ot extends s.E {
          constructor(e, a, c, p) {
            super(), this.flippedWindingOrder = false, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(p), this.options = a;
          }
          load(e) {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const a = yield te.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading());
              } catch (a) {
                this._request = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a1.fromLngLat);
            var c;
            return this.tileID = (function(p) {
              const _ = s.a2.fromPoints(p), x = _.width(), k = _.height(), P = Math.max(x, k), R = Math.max(0, Math.floor(-Math.log(P) / Math.LN2)), D = Math.pow(2, R);
              return new s.a4(R, Math.floor((_.minX + _.maxX) / 2 * D), Math.floor((_.minY + _.maxY) / 2 * D));
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map(((p) => this.tileID.getTilePoint(p)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const _ = this.tiles[p];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e) {
            const { minX: a, minY: c, maxX: p, maxY: _ } = s.a2.fromPoints(e), x = {};
            for (let k = 0; k <= s.a3; k++) {
              const P = Math.pow(2, k), R = Math.floor(a * P), D = Math.floor(c * P), j = Math.floor(p * P), $ = Math.floor(_ * P);
              x[k] = { minTileX: R, minTileY: D, maxTileX: j, maxTileY: $ };
            }
            return x;
          }
        }
        class Le extends ot {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.roundZoom = true, this.type = "video", this.options = a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a5(this.urls);
                if (this._loaded = true, !a) return;
                this.video = a, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (a) {
                this.fire(new s.k(a));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const _ = this.tiles[p];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Ye extends ot {
          constructor(e, a, c, p) {
            super(e, a, c, p), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(((_) => !Array.isArray(_) || _.length !== 2 || _.some(((x) => typeof x != "number")))) || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context, c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new s.T(a, this.canvas, c.RGBA, { premultiply: true });
            let p = false;
            for (const _ in this.tiles) {
              const x = this.tiles[_];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, p = true);
            }
            p && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
            return false;
          }
        }
        const ft = {}, bt = (v) => {
          switch (v) {
            case "geojson":
              return Ee;
            case "image":
              return ot;
            case "raster":
              return Cr;
            case "raster-dem":
              return Ct;
            case "vector":
              return Dr;
            case "video":
              return Le;
            case "canvas":
              return Ye;
          }
          return ft[v];
        }, tt = "RTLPluginLoaded";
        class mt extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = pr();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((a) => {
              throw this.status = "error", a;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function* (a, c = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = L.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(tt));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Zt = null;
        function ii() {
          return Zt || (Zt = new mt()), Zt;
        }
        class wi {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = s.a7(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const a = e + this.timeAdded;
            a < this.fadeEndTime || (this.fadeEndTime = a);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(p, _) {
                const x = {};
                if (!_) return x;
                for (const k of p) {
                  const P = k.layerIds.map(((R) => _.getLayer(R))).filter(Boolean);
                  if (P.length !== 0) {
                    k.layers = P, k.stateDependentLayerIds && (k.stateDependentLayers = k.stateDependentLayerIds.map(((R) => P.filter(((D) => D.id === R))[0])));
                    for (const R of P) x[R.id] = k;
                  }
                }
                return x;
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = false;
              for (const p in this.buckets) {
                const _ = this.buckets[p];
                if (_ instanceof s.a9) {
                  if (this.hasSymbolBuckets = true, !c) break;
                  _.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const p in this.buckets) {
                const _ = this.buckets[p];
                if (_ instanceof s.a9 && _.hasRTLText) {
                  this.hasRTLText = true, ii().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const p in this.buckets) {
                const _ = this.buckets[p];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(p).queryRadius(_));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new s.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const c in this.buckets) {
              const p = this.buckets[c];
              p.uploadPending() && p.upload(e);
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, a, c, p, _, x, k, P, R, D, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: _, scale: x, tileSize: this.tileSize, pixelPosMatrix: D, transform: P, params: k, queryPadding: this.queryPadding * R, getElevation: j }, e, a, c) : {};
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const p = c.loadVTLayers(), _ = a && a.sourceLayer ? a.sourceLayer : "", x = p._geojsonTileLayer || p[_];
            if (!x) return;
            const k = s.aa(a && a.filter), { z: P, x: R, y: D } = this.tileID.canonical, j = { z: P, x: R, y: D };
            for (let $ = 0; $ < x.length; $++) {
              const V = x.feature($);
              if (k.needGeometry) {
                const se = s.ab(V, true);
                if (!k.filter(new s.F(this.tileID.overscaledZ), se, this.tileID.canonical)) continue;
              } else if (!k.filter(new s.F(this.tileID.overscaledZ), V)) continue;
              const W = c.getId(V, _), le = new s.ac(V, P, R, D, W);
              le.tile = j, e.push(le);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = s.ad(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let p = false;
              if (this.expirationTime > c) p = false;
              else if (a) if (this.expirationTime < a) p = true;
              else {
                const _ = this.expirationTime - a;
                _ ? this.expirationTime = c + Math.max(_, 3e4) : p = true;
              }
              else p = true;
              p ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const p in this.buckets) {
              if (!a.style.hasLayer(p)) continue;
              const _ = this.buckets[p], x = _.layers[0].sourceLayer || "_geojsonTileLayer", k = c[x], P = e[x];
              if (!k || !P || Object.keys(P).length === 0) continue;
              _.update(P, k, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const R = a && a.style && a.style.getLayer(p);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(_)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < L.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = L.now() + e;
          }
          setDependencies(e, a) {
            const c = {};
            for (const p of a) c[p] = true;
            this.dependencies[e] = c;
          }
          hasDependency(e, a) {
            for (const c of e) {
              const p = this.dependencies[c];
              if (p) {
                for (const _ of a) if (p[_]) return true;
              }
            }
            return false;
          }
        }
        class Fe {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset();
          }
          reset() {
            for (const e in this.data) for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, a, c) {
            const p = e.wrapped().key;
            this.data[p] === void 0 && (this.data[p] = []);
            const _ = { value: a, timeout: void 0 };
            if (c !== void 0 && (_.timeout = setTimeout((() => {
              this.remove(e, _);
            }), c)), this.data[p].push(_), this.order.push(p), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value;
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key, p = a === void 0 ? 0 : this.data[c].indexOf(a), _ = this.data[c][p];
            return this.data[c].splice(p, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a);
            }
            return this;
          }
          filter(e) {
            const a = [];
            for (const c in this.data) for (const p of this.data[c]) e(p.value) || a.push(p);
            for (const c of a) this.remove(c.value.tileID, c);
          }
        }
        class Z {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, a, c) {
            const p = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][p] = this.stateChanges[e][p] || {}, s.e(this.stateChanges[e][p], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const _ in this.state[e]) _ !== p && (this.deletedStates[e][_] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][p] === null) {
              this.deletedStates[e][p] = {};
              for (const _ in this.state[e][p]) c[_] || (this.deletedStates[e][p][_] = null);
            } else for (const _ in c) this.deletedStates[e] && this.deletedStates[e][p] && this.deletedStates[e][p][_] === null && delete this.deletedStates[e][p][_];
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const p = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][p] !== null && (this.deletedStates[e][p] = this.deletedStates[e][p] || {}, this.deletedStates[e][p][c] = null);
            else if (a !== void 0) if (this.stateChanges[e] && this.stateChanges[e][p]) for (c in this.deletedStates[e][p] = {}, this.stateChanges[e][p]) this.deletedStates[e][p][c] = null;
            else this.deletedStates[e][p] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, a) {
            const c = String(a), p = s.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const _ = this.deletedStates[e][a];
              if (_ === null) return {};
              for (const x in _) delete p[x];
            }
            return p;
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a);
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const p in this.stateChanges) {
              this.state[p] = this.state[p] || {};
              const _ = {};
              for (const x in this.stateChanges[p]) this.state[p][x] || (this.state[p][x] = {}), s.e(this.state[p][x], this.stateChanges[p][x]), _[x] = this.state[p][x];
              c[p] = _;
            }
            for (const p in this.deletedStates) {
              this.state[p] = this.state[p] || {};
              const _ = {};
              if (this.deletedStates[p] === null) for (const x in this.state[p]) _[x] = {}, this.state[p][x] = {};
              else for (const x in this.deletedStates[p]) {
                if (this.deletedStates[p][x] === null) this.state[p][x] = {};
                else for (const k of Object.keys(this.deletedStates[p][x])) delete this.state[p][x][k];
                _[x] = this.state[p][x];
              }
              c[p] = c[p] || {}, s.e(c[p], _);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const p in e) e[p].setFeatureState(c, a);
          }
        }
        const Y = 89.25;
        function ne(v, e) {
          const a = s.ah(e.lat, -s.ai, s.ai);
          return new s.P(s.V(e.lng) * v, s.U(a) * v);
        }
        function _e(v, e) {
          return new s.a1(e.x / v, e.y / v).toLngLat();
        }
        function Te(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(s.ae(90 - v.pitch)), Math.tan(s.ae(Y - v.pitch)));
        }
        function De(v, e) {
          const a = v.canonical, c = e / s.af(a.z), p = a.x + Math.pow(2, a.z) * v.wrap, _ = s.ag(new Float64Array(16));
          return s.M(_, _, [p * c, a.y * c, 0]), s.N(_, _, [c / s.$, c / s.$, 1]), _;
        }
        function he(v, e, a, c, p) {
          const _ = s.a1.fromLngLat(v, e), x = p * s.aj(1, v.lat), k = x * Math.cos(s.ae(a)), P = Math.sqrt(x * x - k * k), R = P * Math.sin(s.ae(-c)), D = P * Math.cos(s.ae(-c));
          return new s.a1(_.x + R, _.y + D, _.z + k);
        }
        function ve(v, e, a) {
          const c = e.intersectsFrustum(v);
          if (!a || c === 0) return c;
          const p = e.intersectsPlane(a);
          return p === 0 ? 0 : c === 2 && p === 2 ? 2 : 1;
        }
        function je(v, e, a) {
          let c = 0;
          const p = (a - e) / 10;
          for (let _ = 0; _ < 10; _++) c += p * Math.pow(Math.cos(e + (_ + 0.5) / 10 * (a - e)), v);
          return c;
        }
        function it(v, e) {
          return function(a, c, p, _, x) {
            const k = 2 * ((v - 1) / s.ak(Math.cos(s.ae(Y - x)) / Math.cos(s.ae(Y))) - 1), P = Math.acos(p / _), R = 2 * je(k - 1, 0, s.ae(x / 2)), D = Math.min(s.ae(Y), P + s.ae(x / 2)), j = je(k - 1, Math.min(D, P - s.ae(x / 2)), D), $ = Math.atan(c / p), V = Math.hypot(c, p);
            let W = a;
            return W += s.ak(_ / V / Math.max(0.5, Math.cos(s.ae(x / 2)))), W += k * s.ak(Math.cos($)) / 2, W -= s.ak(Math.max(1, j / R / e)) / 2, W;
          };
        }
        const Xe = it(9.314, 3);
        function wt(v, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(v.zoom + s.ak(v.tileSize / e.tileSize));
          return Math.max(0, a);
        }
        function Pe(v, e) {
          const a = v.getCameraFrustum(), c = v.getClippingPlane(), p = v.screenPointToMercatorCoordinate(v.getCameraPoint()), _ = s.a1.fromLngLat(v.center, v.elevation);
          p.z = _.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const x = v.getCoveringTilesDetailsProvider(), k = x.allowVariableZoom(v, e), P = wt(v, e), R = e.minzoom || 0, D = e.maxzoom !== void 0 ? e.maxzoom : v.maxZoom, j = Math.min(Math.max(0, P), D), $ = Math.pow(2, j), V = [$ * p.x, $ * p.y, 0], W = [$ * _.x, $ * _.y, 0], le = Math.hypot(_.x - p.x, _.y - p.y), se = Math.abs(_.z - p.z), ce = Math.hypot(le, se), me = (ke) => ({ zoom: 0, x: 0, y: 0, wrap: ke, fullyVisible: false }), we = [], ye = [];
          if (v.renderWorldCopies && x.allowWorldCopies()) for (let ke = 1; ke <= 3; ke++) we.push(me(-ke)), we.push(me(ke));
          for (we.push(me(0)); we.length > 0; ) {
            const ke = we.pop(), Me = ke.x, be = ke.y;
            let Oe = ke.fullyVisible;
            const Qe = { x: Me, y: be, z: ke.zoom }, We = x.getTileBoundingVolume(Qe, ke.wrap, v.elevation, e);
            if (!Oe) {
              const Tt = ve(a, We, c);
              if (Tt === 0) continue;
              Oe = Tt === 2;
            }
            const Ze = x.distanceToTile2d(p.x, p.y, Qe, We);
            let Je = P;
            k && (Je = (e.calculateTileZoom || Xe)(v.zoom + s.ak(v.tileSize / e.tileSize), Ze, se, ce, v.fov)), Je = (e.roundZoom ? Math.round : Math.floor)(Je), Je = Math.max(0, Je);
            const kt = Math.min(Je, D);
            if (ke.wrap = x.getWrap(_, Qe, ke.wrap), ke.zoom >= kt) {
              if (ke.zoom < R) continue;
              const Tt = j - ke.zoom, pt = V[0] - 0.5 - (Me << Tt), Vt = V[1] - 0.5 - (be << Tt), _r = e.reparseOverscaled ? Math.max(ke.zoom, Je) : ke.zoom;
              ye.push({ tileID: new s.Z(ke.zoom === D ? _r : ke.zoom, ke.wrap, ke.zoom, Me, be), distanceSq: s.al([W[0] - 0.5 - Me, W[1] - 0.5 - be]), tileDistanceToCamera: Math.sqrt(pt * pt + Vt * Vt) });
            } else for (let Tt = 0; Tt < 4; Tt++) we.push({ zoom: ke.zoom + 1, x: (Me << 1) + Tt % 2, y: (be << 1) + (Tt >> 1), wrap: ke.wrap, fullyVisible: Oe });
          }
          return ye.sort(((ke, Me) => ke.distanceSq - Me.distanceSq)).map(((ke) => ke.tileID));
        }
        const $t = s.a2.fromPoints([new s.P(0, 0), new s.P(s.$, s.$)]);
        class Qt extends s.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", ((p) => this._dataHandler(p))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((p, _, x, k) => {
              const P = new (bt(_.type))(p, _, x, k);
              if (P.id !== p) throw new Error(`Expected Source id to be ${p} instead of ${P.id}`);
              return P;
            })(e, a, c, this), this._tiles = {}, this._cache = new Fe(0, ((p) => this._unloadTile(p))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Z(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, a, c) {
            return s._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c);
              } catch (p) {
                e.state = "errored", p.status !== 404 ? this._source.fire(new s.k(p, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(Nt).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, p) => {
              const _ = c.tileID, x = p.tileID, k = new s.P(_.canonical.x, _.canonical.y)._rotate(-this.transform.bearingInRadians), P = new s.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return _.overscaledZ - x.overscaledZ || P.y - k.y || P.x - k.x;
            })).map(((c) => c.tileID.key)) : a.map(((c) => c.tileID)).sort(Nt).map(((c) => c.key));
          }
          hasRenderableParent(e) {
            const a = this.findLoadedParent(e, 0);
            return !!a && this._isIdRenderable(a.tileID.key);
          }
          _isIdRenderable(e, a) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (a || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const a in this._tiles) e ? this._reloadTile(a, "expired") : this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading");
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a));
            }));
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = L.now(), c === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let p = 0; p < a.length; p++) {
              const _ = a[p];
              if (e.neighboringTiles && e.neighboringTiles[_]) {
                const x = this.getTileByID(_);
                c(e, x), c(x, e);
              }
            }
            function c(p, _) {
              p.needsHillshadePrepare = true, p.needsTerrainPrepare = true;
              let x = _.tileID.canonical.x - p.tileID.canonical.x;
              const k = _.tileID.canonical.y - p.tileID.canonical.y, P = Math.pow(2, p.tileID.canonical.z), R = _.tileID.key;
              x === 0 && k === 0 || Math.abs(k) > 1 || (Math.abs(x) > 1 && (Math.abs(x + P) === 1 ? x += P : Math.abs(x - P) === 1 && (x -= P)), _.dem && p.dem && (p.dem.backfillBorder(_.dem, x, k), p.neighboringTiles && p.neighboringTiles[R] && (p.neighboringTiles[R].backfilled = true)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, a, c, p) {
            for (const _ in this._tiles) {
              let x = this._tiles[_];
              if (p[_] || !x.hasData() || x.tileID.overscaledZ <= a || x.tileID.overscaledZ > c) continue;
              let k = x.tileID;
              for (; x && x.tileID.overscaledZ > a + 1; ) {
                const R = x.tileID.scaledTo(x.tileID.overscaledZ - 1);
                x = this._tiles[R.key], x && x.hasData() && (k = R);
              }
              let P = k;
              for (; P.overscaledZ > a; ) if (P = P.scaledTo(P.overscaledZ - 1), e[P.key] || e[P.canonical.key]) {
                p[k.key] = k;
                break;
              }
            }
          }
          findLoadedParent(e, a) {
            if (e.key in this._loadedParentTiles) {
              const c = this._loadedParentTiles[e.key];
              return c && c.tileID.overscaledZ >= a ? c : null;
            }
            for (let c = e.overscaledZ - 1; c >= a; c--) {
              const p = e.scaledTo(c), _ = this._getLoadedTile(p);
              if (_) return _;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a && a.hasData() ? a : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1, c = Math.ceil(e.height / this._source.tileSize) + 1, p = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), _ = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, p) : p;
            this._cache.setMaxSize(_);
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const p in this._tiles) {
                const _ = this._tiles[p];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + a), c[_.tileID.key] = _;
              }
              this._tiles = c;
              for (const p in this._timers) clearTimeout(this._timers[p]), delete this._timers[p];
              for (const p in this._tiles) this._setTileReloadTimer(p, this._tiles[p]);
            }
          }
          _updateCoveredAndRetainedTiles(e, a, c, p, _, x) {
            const k = {}, P = {}, R = Object.keys(e), D = L.now();
            for (const j of R) {
              const $ = e[j], V = this._tiles[j];
              if (!V || V.fadeEndTime !== 0 && V.fadeEndTime <= D) continue;
              const W = this.findLoadedParent($, a), le = this.findLoadedSibling($), se = W || le || null;
              se && (this._addTile(se.tileID), k[se.tileID.key] = se.tileID), P[j] = $;
            }
            this._retainLoadedChildren(P, p, c, e);
            for (const j in k) e[j] || (this._coveredTiles[j] = true, e[j] = k[j]);
            if (x) {
              const j = {}, $ = {};
              for (const V of _) this._tiles[V.key].hasData() ? j[V.key] = V : $[V.key] = V;
              for (const V in $) {
                const W = $[V].children(this._source.maxzoom);
                this._tiles[W[0].key] && this._tiles[W[1].key] && this._tiles[W[2].key] && this._tiles[W[3].key] && (j[W[0].key] = e[W[0].key] = W[0], j[W[1].key] = e[W[1].key] = W[1], j[W[2].key] = e[W[2].key] = W[2], j[W[3].key] = e[W[3].key] = W[3], delete $[V]);
              }
              for (const V in $) {
                const W = $[V], le = this.findLoadedParent(W, this._source.minzoom), se = this.findLoadedSibling(W), ce = le || se || null;
                if (ce) {
                  j[ce.tileID.key] = e[ce.tileID.key] = ce.tileID;
                  for (const me in j) j[me].isChildOf(ce.tileID) && delete j[me];
                }
              }
              for (const V in this._tiles) j[V] || (this._coveredTiles[V] = true);
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((D) => new s.Z(D.canonical.z, D.wrap, D.canonical.z, D.canonical.x, D.canonical.y))) : (c = Pe(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: a, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (c = c.filter(((D) => this._source.hasTile(D))))) : c = [];
            const p = wt(e, this._source), _ = Math.max(p - Qt.maxOverzooming, this._source.minzoom), x = Math.max(p + Qt.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const D = {};
              for (const j of c) if (j.canonical.z > this._source.minzoom) {
                const $ = j.scaledTo(j.canonical.z - 1);
                D[$.key] = $;
                const V = j.scaledTo(Math.max(this._source.minzoom, Math.min(j.canonical.z, 5)));
                D[V.key] = V;
              }
              c = c.concat(Object.values(D));
            }
            const k = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, k && this.fire(new s.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const P = this._updateRetainedTiles(c, p);
            ur(this._source.type) && this._updateCoveredAndRetainedTiles(P, _, x, p, c, a);
            for (const D in P) this._tiles[D].clearFadeHold();
            const R = s.am(this._tiles, P);
            for (const D of R) {
              const j = this._tiles[D];
              j.hasSymbolBuckets && !j.holdingForFade() ? j.setHoldDuration(this.map._fadeDuration) : j.hasSymbolBuckets && !j.symbolFadeFinished() || this._removeTile(D);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, a) {
            var c;
            const p = {}, _ = {}, x = Math.max(a - Qt.maxOverzooming, this._source.minzoom), k = Math.max(a + Qt.maxUnderzooming, this._source.minzoom), P = {};
            for (const R of e) {
              const D = this._addTile(R);
              p[R.key] = R, D.hasData() || a < this._source.maxzoom && (P[R.key] = R);
            }
            this._retainLoadedChildren(P, a, k, p);
            for (const R of e) {
              let D = this._tiles[R.key];
              if (D.hasData()) continue;
              if (a + 1 > this._source.maxzoom) {
                const $ = R.children(this._source.maxzoom)[0], V = this.getTile($);
                if (V && V.hasData()) {
                  p[$.key] = $;
                  continue;
                }
              } else {
                const $ = R.children(this._source.maxzoom);
                if (p[$[0].key] && p[$[1].key] && p[$[2].key] && p[$[3].key]) continue;
              }
              let j = D.wasRequested();
              for (let $ = R.overscaledZ - 1; $ >= x; --$) {
                const V = R.scaledTo($);
                if (_[V.key]) break;
                if (_[V.key] = true, D = this.getTile(V), !D && j && (D = this._addTile(V)), D) {
                  const W = D.hasData();
                  if ((W || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || j) && (p[V.key] = V), j = D.wasRequested(), W) break;
                }
              }
            }
            return p;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const a = [];
              let c, p = this._tiles[e].tileID;
              for (; p.overscaledZ > 0; ) {
                if (p.key in this._loadedParentTiles) {
                  c = this._loadedParentTiles[p.key];
                  break;
                }
                a.push(p.key);
                const _ = p.scaledTo(p.overscaledZ - 1);
                if (c = this._getLoadedTile(_), c) break;
                p = _;
              }
              for (const _ of a) this._loadedParentTiles[_] = c;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const a = this._tiles[e].tileID, c = this._getLoadedTile(a);
              this._loadedSiblingTiles[a.key] = c;
            }
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, a)));
            const c = a;
            return a || (a = new wi(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new s.l("dataloading", { tile: a, coord: a.tileID, dataType: "source" })), a;
          }
          _setTileReloadTimer(e, a) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), c));
          }
          refreshTiles(e) {
            for (const a in this._tiles) (this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some(((c) => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired");
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = true, this._abortTile(a), this._unloadTile(a))));
          }
          _dataHandler(e) {
            const a = e.sourceDataType;
            e.dataType === "source" && a === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && a === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, a, c) {
            const p = [], _ = this.transform;
            if (!_) return p;
            const x = _.getCoveringTilesDetailsProvider().allowWorldCopies(), k = c ? _.getCameraQueryGeometry(e) : e, P = (V) => _.screenPointToMercatorCoordinate(V, this.terrain), R = this.transformBbox(e, P, !x), D = this.transformBbox(k, P, !x), j = this.getIds(), $ = s.a2.fromPoints(D);
            for (let V = 0; V < j.length; V++) {
              const W = this._tiles[j[V]];
              if (W.holdingForFade()) continue;
              const le = x ? [W.tileID] : [W.tileID.unwrapTo(-1), W.tileID.unwrapTo(0)], se = Math.pow(2, _.zoom - W.tileID.overscaledZ), ce = a * W.queryPadding * s.$ / W.tileSize / se;
              for (const me of le) {
                const we = $.map(((ye) => me.getTilePoint(new s.a1(ye.x, ye.y))));
                if (we.expandBy(ce), we.intersects($t)) {
                  const ye = R.map(((Me) => me.getTilePoint(Me))), ke = D.map(((Me) => me.getTilePoint(Me)));
                  p.push({ tile: W, tileID: x ? me : me.unwrapTo(0), queryGeometry: ye, cameraQueryGeometry: ke, scale: se });
                }
              }
            }
            return p;
          }
          transformBbox(e, a, c) {
            let p = e.map(a);
            if (c) {
              const _ = s.a2.fromPoints(e);
              _.shrinkBy(1e-3 * Math.min(_.width(), _.height()));
              const x = _.map(a);
              s.a2.fromPoints(p).covers(x) || (p = p.map(((k) => k.x > 0.5 ? new s.a1(k.x - 1, k.y, k.z) : k)));
            }
            return p;
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map(((c) => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (ur(this._source.type)) {
              const e = L.now();
              for (const a in this._tiles) if (this._tiles[a].fadeEndTime >= e) return true;
            }
            return false;
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c);
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c);
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a);
          }
          setDependencies(e, a, c) {
            const p = this._tiles[e];
            p && p.setDependencies(a, c);
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter(((c) => !c.hasDependency(e, a)));
          }
        }
        function Nt(v, e) {
          const a = Math.abs(2 * v.wrap) - +(v.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return v.overscaledZ - e.overscaledZ || c - a || e.canonical.y - v.canonical.y || e.canonical.x - v.canonical.x;
        }
        function ur(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        Qt.maxOverzooming = 10, Qt.maxUnderzooming = 3;
        class Br {
          constructor(e, a) {
            this.reset(e, a);
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ah(e, 0, 1);
            let a = 1, c = this._distances[a];
            const p = e * this.paddedLength + this.padding;
            for (; c < p && a < this._distances.length; ) c = this._distances[++a];
            const _ = a - 1, x = this._distances[_], k = c - x, P = k > 0 ? (p - x) / k : 0;
            return this.points[_].mult(1 - P).add(this.points[a].mult(P));
          }
        }
        function Qr(v, e) {
          let a = true;
          return v === "always" || v !== "never" && e !== "never" || (a = false), a;
        }
        class ei {
          constructor(e, a, c) {
            const p = this.boxCells = [], _ = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) p.push([]), _.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, a, c, p, _) {
            this._forEachCell(a, c, p, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p), this.bboxes.push(_);
          }
          insertCircle(e, a, c, p) {
            this._forEachCell(a - p, c - p, a + p, c + p, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(p);
          }
          _insertBoxCell(e, a, c, p, _, x) {
            this.boxCells[_].push(x);
          }
          _insertCircleCell(e, a, c, p, _, x) {
            this.circleCells[_].push(x);
          }
          _query(e, a, c, p, _, x, k) {
            if (c < 0 || e > this.width || p < 0 || a > this.height) return [];
            const P = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= p) {
              if (_) return [{ key: null, x1: e, y1: a, x2: c, y2: p }];
              for (let R = 0; R < this.boxKeys.length; R++) P.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const D = this.circles[3 * R], j = this.circles[3 * R + 1], $ = this.circles[3 * R + 2];
                P.push({ key: this.circleKeys[R], x1: D - $, y1: j - $, x2: D + $, y2: j + $ });
              }
            } else this._forEachCell(e, a, c, p, this._queryCell, P, { hitTest: _, overlapMode: x, seenUids: { box: {}, circle: {} } }, k);
            return P;
          }
          query(e, a, c, p) {
            return this._query(e, a, c, p, false, null);
          }
          hitTest(e, a, c, p, _, x) {
            return this._query(e, a, c, p, true, _, x).length > 0;
          }
          hitTestCircle(e, a, c, p, _) {
            const x = e - c, k = e + c, P = a - c, R = a + c;
            if (k < 0 || x > this.width || R < 0 || P > this.height) return false;
            const D = [];
            return this._forEachCell(x, P, k, R, this._queryCellCircle, D, { hitTest: true, overlapMode: p, circle: { x: e, y: a, radius: c }, seenUids: { box: {}, circle: {} } }, _), D.length > 0;
          }
          _queryCell(e, a, c, p, _, x, k, P) {
            const { seenUids: R, hitTest: D, overlapMode: j } = k, $ = this.boxCells[_];
            if ($ !== null) {
              const W = this.bboxes;
              for (const le of $) if (!R.box[le]) {
                R.box[le] = true;
                const se = 4 * le, ce = this.boxKeys[le];
                if (e <= W[se + 2] && a <= W[se + 3] && c >= W[se + 0] && p >= W[se + 1] && (!P || P(ce)) && (!D || !Qr(j, ce.overlapMode)) && (x.push({ key: ce, x1: W[se], y1: W[se + 1], x2: W[se + 2], y2: W[se + 3] }), D)) return true;
              }
            }
            const V = this.circleCells[_];
            if (V !== null) {
              const W = this.circles;
              for (const le of V) if (!R.circle[le]) {
                R.circle[le] = true;
                const se = 3 * le, ce = this.circleKeys[le];
                if (this._circleAndRectCollide(W[se], W[se + 1], W[se + 2], e, a, c, p) && (!P || P(ce)) && (!D || !Qr(j, ce.overlapMode))) {
                  const me = W[se], we = W[se + 1], ye = W[se + 2];
                  if (x.push({ key: ce, x1: me - ye, y1: we - ye, x2: me + ye, y2: we + ye }), D) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e, a, c, p, _, x, k, P) {
            const { circle: R, seenUids: D, overlapMode: j } = k, $ = this.boxCells[_];
            if ($ !== null) {
              const W = this.bboxes;
              for (const le of $) if (!D.box[le]) {
                D.box[le] = true;
                const se = 4 * le, ce = this.boxKeys[le];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, W[se + 0], W[se + 1], W[se + 2], W[se + 3]) && (!P || P(ce)) && !Qr(j, ce.overlapMode)) return x.push(true), true;
              }
            }
            const V = this.circleCells[_];
            if (V !== null) {
              const W = this.circles;
              for (const le of V) if (!D.circle[le]) {
                D.circle[le] = true;
                const se = 3 * le, ce = this.circleKeys[le];
                if (this._circlesCollide(W[se], W[se + 1], W[se + 2], R.x, R.y, R.radius) && (!P || P(ce)) && !Qr(j, ce.overlapMode)) return x.push(true), true;
              }
            }
          }
          _forEachCell(e, a, c, p, _, x, k, P) {
            const R = this._convertToXCellCoord(e), D = this._convertToYCellCoord(a), j = this._convertToXCellCoord(c), $ = this._convertToYCellCoord(p);
            for (let V = R; V <= j; V++) for (let W = D; W <= $; W++) if (_.call(this, e, a, c, p, this.xCellCount * W + V, x, k, P)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, a, c, p, _, x) {
            const k = p - e, P = _ - a, R = c + x;
            return R * R > k * k + P * P;
          }
          _circleAndRectCollide(e, a, c, p, _, x, k) {
            const P = (x - p) / 2, R = Math.abs(e - (p + P));
            if (R > P + c) return false;
            const D = (k - _) / 2, j = Math.abs(a - (_ + D));
            if (j > D + c) return false;
            if (R <= P || j <= D) return true;
            const $ = R - P, V = j - D;
            return $ * $ + V * V <= c * c;
          }
        }
        function ni(v, e, a) {
          const c = s.L();
          if (!v) {
            const { vecSouth: j, vecEast: $ } = yr(e), V = T();
            V[0] = $[0], V[1] = $[1], V[2] = j[0], V[3] = j[1], p = V, (D = (x = (_ = V)[0]) * (R = _[3]) - (P = _[2]) * (k = _[1])) && (p[0] = R * (D = 1 / D), p[1] = -k * D, p[2] = -P * D, p[3] = x * D), c[0] = V[0], c[1] = V[1], c[4] = V[2], c[5] = V[3];
          }
          var p, _, x, k, P, R, D;
          return s.N(c, c, [1 / a, 1 / a, 1]), c;
        }
        function gr(v, e, a, c) {
          if (v) {
            const p = s.L();
            if (!e) {
              const { vecSouth: _, vecEast: x } = yr(a);
              p[0] = x[0], p[1] = x[1], p[4] = _[0], p[5] = _[1];
            }
            return s.N(p, p, [c, c, 1]), p;
          }
          return a.pixelsToClipSpaceMatrix;
        }
        function yr(v) {
          const e = Math.cos(v.rollInRadians), a = Math.sin(v.rollInRadians), c = Math.cos(v.pitchInRadians), p = Math.cos(v.bearingInRadians), _ = Math.sin(v.bearingInRadians), x = s.ar();
          x[0] = -p * c * a - _ * e, x[1] = -_ * c * a + p * e;
          const k = s.as(x);
          k < 1e-9 ? s.at(x) : s.au(x, x, 1 / k);
          const P = s.ar();
          P[0] = p * c * e - _ * a, P[1] = _ * c * e + p * a;
          const R = s.as(P);
          return R < 1e-9 ? s.at(P) : s.au(P, P, 1 / R), { vecEast: P, vecSouth: x };
        }
        function Wr(v, e, a, c) {
          let p;
          c ? (p = [v, e, c(v, e), 1], s.aw(p, p, a)) : (p = [v, e, 0, 1], bo(p, p, a));
          const _ = p[3];
          return { point: new s.P(p[0] / _, p[1] / _), signedDistanceFromCamera: _, isOccluded: false };
        }
        function ge(v, e) {
          return 0.5 + v / e * 0.5;
        }
        function dt(v, e) {
          return v.x >= -e[0] && v.x <= e[0] && v.y >= -e[1] && v.y <= e[1];
        }
        function Bt(v, e, a, c, p, _, x, k, P, R, D, j, $) {
          const V = a ? v.textSizeData : v.iconSizeData, W = s.an(V, e.transform.zoom), le = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], se = a ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          se.clear();
          const ce = v.lineVertexArray, me = a ? v.text.placedSymbolArray : v.icon.placedSymbolArray, we = e.transform.width / e.transform.height;
          let ye = false;
          for (let ke = 0; ke < me.length; ke++) {
            const Me = me.get(ke);
            if (Me.hidden || Me.writingMode === s.ao.vertical && !ye) {
              Sn(Me.numGlyphs, se);
              continue;
            }
            ye = false;
            const be = new s.P(Me.anchorX, Me.anchorY), Oe = { getElevation: $, pitchedLabelPlaneMatrix: c, lineVertexArray: ce, pitchWithMap: _, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: be, unwrappedTileID: P, width: R, height: D, translation: j }, Qe = tn(Me.anchorX, Me.anchorY, Oe);
            if (!dt(Qe.point, le)) {
              Sn(Me.numGlyphs, se);
              continue;
            }
            const We = ge(e.transform.cameraToCenterDistance, Qe.signedDistanceFromCamera), Ze = s.ap(V, W, Me), Je = _ ? Ze * e.transform.getPitchedTextCorrection(Me.anchorX, Me.anchorY, P) / We : Ze * We, kt = gt({ projectionContext: Oe, pitchedLabelPlaneMatrixInverse: p, symbol: Me, fontSize: Je, flip: false, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: se, aspectRatio: we, rotateToLine: k });
            ye = kt.useVertical, (kt.notEnoughRoom || ye || kt.needsFlipping && gt({ projectionContext: Oe, pitchedLabelPlaneMatrixInverse: p, symbol: Me, fontSize: Je, flip: true, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: se, aspectRatio: we, rotateToLine: k }).notEnoughRoom) && Sn(Me.numGlyphs, se);
          }
          a ? v.text.dynamicLayoutVertexBuffer.updateData(se) : v.icon.dynamicLayoutVertexBuffer.updateData(se);
        }
        function Rr(v, e, a, c, p, _, x, k) {
          const P = _.glyphStartIndex + _.numGlyphs, R = _.lineStartIndex, D = _.lineStartIndex + _.lineLength, j = e.getoffsetX(_.glyphStartIndex), $ = e.getoffsetX(P - 1), V = Un(v * j, a, c, p, _.segment, R, D, k, x);
          if (!V) return null;
          const W = Un(v * $, a, c, p, _.segment, R, D, k, x);
          return W ? k.projectionCache.anyProjectionOccluded ? null : { first: V, last: W } : null;
        }
        function $r(v, e, a, c) {
          return v === s.ao.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? { useVertical: true } : (v === s.ao.vertical ? e.y < a.y : e.x > a.x) ? { needsFlipping: true } : null;
        }
        function gt(v) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: a, symbol: c, fontSize: p, flip: _, keepUpright: x, glyphOffsetArray: k, dynamicLayoutVertexArray: P, aspectRatio: R, rotateToLine: D } = v, j = p / 24, $ = c.lineOffsetX * j, V = c.lineOffsetY * j;
          let W;
          if (c.numGlyphs > 1) {
            const le = c.glyphStartIndex + c.numGlyphs, se = c.lineStartIndex, ce = c.lineStartIndex + c.lineLength, me = Rr(j, k, $, V, _, c, D, e);
            if (!me) return { notEnoughRoom: true };
            const we = hn(me.first.point.x, me.first.point.y, e, a), ye = hn(me.last.point.x, me.last.point.y, e, a);
            if (x && !_) {
              const ke = $r(c.writingMode, we, ye, R);
              if (ke) return ke;
            }
            W = [me.first];
            for (let ke = c.glyphStartIndex + 1; ke < le - 1; ke++) {
              const Me = Un(j * k.getoffsetX(ke), $, V, _, c.segment, se, ce, e, D);
              if (!Me) return { notEnoughRoom: true };
              W.push(Me);
            }
            W.push(me.last);
          } else {
            if (x && !_) {
              const se = oi(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, ce = c.lineStartIndex + c.segment + 1, me = new s.P(e.lineVertexArray.getx(ce), e.lineVertexArray.gety(ce)), we = oi(me.x, me.y, e), ye = we.signedDistanceFromCamera > 0 ? we.point : cr(e.tileAnchorPoint, me, se, 1, e), ke = hn(se.x, se.y, e, a), Me = hn(ye.x, ye.y, e, a), be = $r(c.writingMode, ke, Me, R);
              if (be) return be;
            }
            const le = Un(j * k.getoffsetX(c.glyphStartIndex), $, V, _, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, D);
            if (!le || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            W = [le];
          }
          for (const le of W) s.av(P, le.point, le.angle);
          return {};
        }
        function cr(v, e, a, c, p) {
          const _ = v.add(v.sub(e)._unit()), x = oi(_.x, _.y, p).point, k = a.sub(x);
          return a.add(k._mult(c / k.mag()));
        }
        function lr(v, e, a) {
          const c = e.projectionCache;
          if (c.projections[v]) return c.projections[v];
          const p = new s.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), _ = oi(p.x, p.y, e);
          if (_.signedDistanceFromCamera > 0) return c.projections[v] = _.point, c.anyProjectionOccluded = c.anyProjectionOccluded || _.isOccluded, _.point;
          const x = v - a.direction;
          return cr(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), p, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e);
        }
        function oi(v, e, a) {
          const c = v + a.translation[0], p = e + a.translation[1];
          let _;
          return a.pitchWithMap ? (_ = Wr(c, p, a.pitchedLabelPlaneMatrix, a.getElevation), _.isOccluded = false) : (_ = a.transform.projectTileCoordinates(c, p, a.unwrappedTileID, a.getElevation), _.point.x = (0.5 * _.point.x + 0.5) * a.width, _.point.y = (0.5 * -_.point.y + 0.5) * a.height), _;
        }
        function hn(v, e, a, c) {
          if (a.pitchWithMap) {
            const p = [v, e, 0, 1];
            return s.aw(p, p, c), a.transform.projectTileCoordinates(p[0] / p[3], p[1] / p[3], a.unwrappedTileID, a.getElevation).point;
          }
          return { x: v / a.width * 2 - 1, y: 1 - e / a.height * 2 };
        }
        function tn(v, e, a) {
          return a.transform.projectTileCoordinates(v, e, a.unwrappedTileID, a.getElevation);
        }
        function dr(v, e, a) {
          return v._unit()._perp()._mult(e * a);
        }
        function Qo(v, e, a, c, p, _, x, k, P) {
          if (k.projectionCache.offsets[v]) return k.projectionCache.offsets[v];
          const R = a.add(e);
          if (v + P.direction < c || v + P.direction >= p) return k.projectionCache.offsets[v] = R, R;
          const D = lr(v + P.direction, k, P), j = dr(D.sub(a), x, P.direction), $ = a.add(j), V = D.add(j);
          return k.projectionCache.offsets[v] = s.ax(_, R, $, V) || R, k.projectionCache.offsets[v];
        }
        function Un(v, e, a, c, p, _, x, k, P) {
          const R = c ? v - e : v + e;
          let D = R > 0 ? 1 : -1, j = 0;
          c && (D *= -1, j = Math.PI), D < 0 && (j += Math.PI);
          let $, V = D > 0 ? _ + p : _ + p + 1;
          k.projectionCache.cachedAnchorPoint ? $ = k.projectionCache.cachedAnchorPoint : ($ = oi(k.tileAnchorPoint.x, k.tileAnchorPoint.y, k).point, k.projectionCache.cachedAnchorPoint = $);
          let W, le, se = $, ce = $, me = 0, we = 0;
          const ye = Math.abs(R), ke = [];
          let Me;
          for (; me + we <= ye; ) {
            if (V += D, V < _ || V >= x) return null;
            me += we, ce = se, le = W;
            const Qe = { absOffsetX: ye, direction: D, distanceFromAnchor: me, previousVertex: ce };
            if (se = lr(V, k, Qe), a === 0) ke.push(ce), Me = se.sub(ce);
            else {
              let We;
              const Ze = se.sub(ce);
              We = Ze.mag() === 0 ? dr(lr(V + D, k, Qe).sub(se), a, D) : dr(Ze, a, D), le || (le = ce.add(We)), W = Qo(V, We, se, _, x, le, a, k, Qe), ke.push(le), Me = W.sub(le);
            }
            we = Me.mag();
          }
          const be = Me._mult((ye - me) / we)._add(le || ce), Oe = j + Math.atan2(se.y - ce.y, se.x - ce.x);
          return ke.push(be), { point: be, angle: P ? Oe : 0, path: ke };
        }
        const ea = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Sn(v, e) {
          for (let a = 0; a < v; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(ea, 3 * c);
          }
        }
        function bo(v, e, a) {
          const c = e[0], p = e[1];
          return v[0] = a[0] * c + a[4] * p + a[12], v[1] = a[1] * c + a[5] * p + a[13], v[3] = a[3] * c + a[7] * p + a[15], v;
        }
        const Zr = 100;
        class Jn {
          constructor(e, a = new ei(e.width + 200, e.height + 200, 25), c = new ei(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Zr, this.screenBottomBoundary = e.height + Zr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, a, c, p, _, x, k, P, R, D, j, $) {
            const V = this.projectAndGetPerspectiveRatio(e.anchorPointX + P[0], e.anchorPointY + P[1], _, D, $), W = c * V.perspectiveRatio;
            let le;
            if (x || k) le = this._projectCollisionBox(e, W, p, _, x, k, P, V, D, j, $);
            else {
              const Me = V.x + (j ? j.x * W : 0), be = V.y + (j ? j.y * W : 0);
              le = { allPointsOccluded: false, box: [Me + e.x1 * W, be + e.y1 * W, Me + e.x2 * W, be + e.y2 * W] };
            }
            const [se, ce, me, we] = le.box, ye = x ? le.allPointsOccluded : V.isOccluded;
            let ke = ye;
            return ke || (ke = V.perspectiveRatio < this.perspectiveRatioCutoff), ke || (ke = !this.isInsideGrid(se, ce, me, we)), ke || a !== "always" && this.grid.hitTest(se, ce, me, we, a, R) ? { box: [se, ce, me, we], placeable: false, offscreen: false, occluded: ye } : { box: [se, ce, me, we], placeable: true, offscreen: this.isOffscreen(se, ce, me, we), occluded: ye };
          }
          placeCollisionCircles(e, a, c, p, _, x, k, P, R, D, j, $, V, W) {
            const le = [], se = new s.P(a.anchorX, a.anchorY), ce = this.getPerspectiveRatio(se.x, se.y, x, W), me = (R ? _ * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, x) / ce : _ * ce) / s.aB, we = { getElevation: W, pitchedLabelPlaneMatrix: k, lineVertexArray: c, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: se, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: V }, ye = Rr(me, p, a.lineOffsetX * me, a.lineOffsetY * me, false, a, false, we);
            let ke = false, Me = false, be = true;
            if (ye) {
              const Oe = 0.5 * j * ce + $, Qe = new s.P(-100, -100), We = new s.P(this.screenRightBoundary, this.screenBottomBoundary), Ze = new Br(), Je = ye.first, kt = ye.last;
              let Tt = [];
              for (let _r = Je.path.length - 1; _r >= 1; _r--) Tt.push(Je.path[_r]);
              for (let _r = 1; _r < kt.path.length; _r++) Tt.push(kt.path[_r]);
              const pt = 2.5 * Oe;
              if (R) {
                const _r = this.projectPathToScreenSpace(Tt, we);
                Tt = _r.some(((Or) => Or.signedDistanceFromCamera <= 0)) ? [] : _r.map(((Or) => Or.point));
              }
              let Vt = [];
              if (Tt.length > 0) {
                const _r = Tt[0].clone(), Or = Tt[0].clone();
                for (let Xr = 1; Xr < Tt.length; Xr++) _r.x = Math.min(_r.x, Tt[Xr].x), _r.y = Math.min(_r.y, Tt[Xr].y), Or.x = Math.max(Or.x, Tt[Xr].x), Or.y = Math.max(Or.y, Tt[Xr].y);
                Vt = _r.x >= Qe.x && Or.x <= We.x && _r.y >= Qe.y && Or.y <= We.y ? [Tt] : Or.x < Qe.x || _r.x > We.x || Or.y < Qe.y || _r.y > We.y ? [] : s.ay([Tt], Qe.x, Qe.y, We.x, We.y);
              }
              for (const _r of Vt) {
                Ze.reset(_r, 0.25 * Oe);
                let Or = 0;
                Or = Ze.length <= 0.5 * Oe ? 1 : Math.ceil(Ze.paddedLength / pt) + 1;
                for (let Xr = 0; Xr < Or; Xr++) {
                  const Gr = Xr / Math.max(Or - 1, 1), di = Ze.lerp(Gr), vi = di.x + Zr, vr = di.y + Zr;
                  le.push(vi, vr, Oe, 0);
                  const Yr = vi - Oe, Ti = vr - Oe, zi = vi + Oe, Ni = vr + Oe;
                  if (be = be && this.isOffscreen(Yr, Ti, zi, Ni), Me = Me || this.isInsideGrid(Yr, Ti, zi, Ni), e !== "always" && this.grid.hitTestCircle(vi, vr, Oe, e, D) && (ke = true, !P)) return { circles: [], offscreen: false, collisionDetected: ke };
                }
              }
            }
            return { circles: !P && ke || !Me || ce < this.perspectiveRatioCutoff ? [] : le, offscreen: be, collisionDetected: ke };
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(p, _) {
              const x = s.L();
              return s.aq(x, _.pitchedLabelPlaneMatrix), p.map(((k) => {
                const P = Wr(k.x, k.y, x, _.getElevation), R = _.transform.projectTileCoordinates(P.point.x, P.point.y, _.unwrappedTileID, _.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * _.width, R.point.y = (0.5 * -R.point.y + 0.5) * _.height, R;
              }));
            })(e, a);
            return (function(p) {
              let _ = 0, x = 0, k = 0, P = 0;
              for (let R = 0; R < p.length; R++) p[R].isOccluded ? (k = R + 1, P = 0) : (P++, P > x && (x = P, _ = k));
              return p.slice(_, _ + x);
            })(c);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [], c = new s.a2();
            for (const j of e) {
              const $ = new s.P(j.x + Zr, j.y + Zr);
              c.extend($), a.push($);
            }
            const { minX: p, minY: _, maxX: x, maxY: k } = c, P = this.grid.query(p, _, x, k).concat(this.ignoredGrid.query(p, _, x, k)), R = {}, D = {};
            for (const j of P) {
              const $ = j.key;
              if (R[$.bucketInstanceId] === void 0 && (R[$.bucketInstanceId] = {}), R[$.bucketInstanceId][$.featureIndex]) continue;
              const V = [new s.P(j.x1, j.y1), new s.P(j.x2, j.y1), new s.P(j.x2, j.y2), new s.P(j.x1, j.y2)];
              s.az(a, V) && (R[$.bucketInstanceId][$.featureIndex] = true, D[$.bucketInstanceId] === void 0 && (D[$.bucketInstanceId] = []), D[$.bucketInstanceId].push($.featureIndex));
            }
            return D;
          }
          insertCollisionBox(e, a, c, p, _, x) {
            (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: p, featureIndex: _, collisionGroupID: x, overlapMode: a }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, a, c, p, _, x) {
            const k = c ? this.ignoredGrid : this.grid, P = { bucketInstanceId: p, featureIndex: _, collisionGroupID: x, overlapMode: a };
            for (let R = 0; R < e.length; R += 4) k.insertCircle(P, e[R], e[R + 1], e[R + 2]);
          }
          projectAndGetPerspectiveRatio(e, a, c, p, _) {
            if (_) {
              let x;
              p ? (x = [e, a, p(e, a), 1], s.aw(x, x, _)) : (x = [e, a, 0, 1], bo(x, x, _));
              const k = x[3];
              return { x: (x[0] / k + 1) / 2 * this.transform.width + Zr, y: (-x[1] / k + 1) / 2 * this.transform.height + Zr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / k * 0.5, isOccluded: false, signedDistanceFromCamera: k };
            }
            {
              const x = this.transform.projectTileCoordinates(e, a, c, p);
              return { x: (x.point.x + 1) / 2 * this.transform.width + Zr, y: (1 - x.point.y) / 2 * this.transform.height + Zr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, a, c, p) {
            const _ = this.transform.projectTileCoordinates(e, a, c, p);
            return 0.5 + this.transform.cameraToCenterDistance / _.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, a, c, p) {
            return c < Zr || e >= this.screenRightBoundary || p < Zr || a > this.screenBottomBoundary;
          }
          isInsideGrid(e, a, c, p) {
            return c >= 0 && e < this.gridRightBoundary && p >= 0 && a < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = s.ag([]);
            return s.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, a, c, p, _, x, k, P, R, D, j) {
            let $ = 1, V = 0, W = 0, le = 1;
            const se = e.anchorPointX + k[0], ce = e.anchorPointY + k[1];
            if (x && !_) {
              const Tt = this.projectAndGetPerspectiveRatio(se + 1, ce, p, R, j), pt = Tt.x - P.x, Vt = Math.atan((Tt.y - P.y) / pt) + (pt < 0 ? Math.PI : 0), _r = Math.sin(Vt), Or = Math.cos(Vt);
              $ = Or, V = _r, W = -_r, le = Or;
            } else if (!x && _) {
              const Tt = yr(this.transform);
              $ = Tt.vecEast[0], V = Tt.vecEast[1], W = Tt.vecSouth[0], le = Tt.vecSouth[1];
            }
            let me = P.x, we = P.y, ye = a;
            _ && (me = se, we = ce, ye = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), ye *= this.transform.getPitchedTextCorrection(se, ce, p), D || (ye *= s.ah(0.5 + P.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), D && (me += $ * D.x * ye + W * D.y * ye, we += V * D.x * ye + le * D.y * ye);
            const ke = e.x1 * ye, Me = e.x2 * ye, be = (ke + Me) / 2, Oe = e.y1 * ye, Qe = e.y2 * ye, We = (Oe + Qe) / 2, Ze = [{ offsetX: ke, offsetY: Oe }, { offsetX: be, offsetY: Oe }, { offsetX: Me, offsetY: Oe }, { offsetX: Me, offsetY: We }, { offsetX: Me, offsetY: Qe }, { offsetX: be, offsetY: Qe }, { offsetX: ke, offsetY: Qe }, { offsetX: ke, offsetY: We }];
            let Je = [];
            for (const { offsetX: Tt, offsetY: pt } of Ze) Je.push(new s.P(me + $ * Tt + W * pt, we + V * Tt + le * pt));
            let kt = false;
            if (_) {
              const Tt = Je.map(((pt) => this.projectAndGetPerspectiveRatio(pt.x, pt.y, p, R, j)));
              kt = Tt.some(((pt) => !pt.isOccluded)), Je = Tt.map(((pt) => new s.P(pt.x, pt.y)));
            } else kt = true;
            return { box: s.aA(Je), allPointsOccluded: !kt };
          }
        }
        class rn {
          constructor(e, a, c, p) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : p && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Ur {
          constructor(e, a, c, p, _) {
            this.text = new rn(e ? e.text : null, a, c, _), this.icon = new rn(e ? e.icon : null, a, p, _);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Ll {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c;
          }
        }
        class wa {
          constructor(e, a, c, p, _) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = p, this.tileID = _;
          }
        }
        class Ds {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: a, predicate: (c) => c.collisionGroupID === a };
            }
            return this.collisionGroups[e];
          }
        }
        function xo(v, e, a, c, p) {
          const { horizontalAlign: _, verticalAlign: x } = s.aH(v);
          return new s.P(-(_ - 0.5) * e + c[0] * p, -(x - 0.5) * a + c[1] * p);
        }
        class wo {
          constructor(e, a, c, p, _) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Jn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new Ds(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, p) => a.getElevation(e, c, p) : null;
          }
          getBucketParts(e, a, c, p) {
            const _ = c.getBucket(a), x = c.latestFeatureIndex;
            if (!_ || !x || a.id !== _.layerIds[0]) return;
            const k = c.collisionBoxArray, P = _.layers[0].layout, R = _.layers[0].paint, D = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), j = c.tileSize / s.$, $ = c.tileID.toUnwrapped(), V = P.get("text-rotation-alignment") === "map", W = s.aC(c, 1, this.transform.zoom), le = s.aD(this.collisionIndex.transform, c, R.get("text-translate"), R.get("text-translate-anchor")), se = s.aD(this.collisionIndex.transform, c, R.get("icon-translate"), R.get("icon-translate-anchor")), ce = ni(V, this.transform, W);
            this.retainedQueryData[_.bucketInstanceId] = new wa(_.bucketInstanceId, x, _.sourceLayerIndex, _.index, c.tileID);
            const me = { bucket: _, layout: P, translationText: le, translationIcon: se, unwrappedTileID: $, pitchedLabelPlaneMatrix: ce, scale: D, textPixelRatio: j, holdingForFade: c.holdingForFade(), collisionBoxArray: k, partiallyEvaluatedTextSize: s.an(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
            if (p) for (const we of _.sortKeyRanges) {
              const { sortKey: ye, symbolInstanceStart: ke, symbolInstanceEnd: Me } = we;
              e.push({ sortKey: ye, symbolInstanceStart: ke, symbolInstanceEnd: Me, parameters: me });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: me });
          }
          attemptAnchorPlacement(e, a, c, p, _, x, k, P, R, D, j, $, V, W, le, se, ce, me, we, ye) {
            const ke = s.aE[e.textAnchor], Me = [e.textOffset0, e.textOffset1], be = xo(ke, c, p, Me, _), Oe = this.collisionIndex.placeCollisionBox(a, $, P, R, D, k, x, se, j.predicate, we, be, ye);
            if ((!me || this.collisionIndex.placeCollisionBox(me, $, P, R, D, k, x, ce, j.predicate, we, be, ye).placeable) && Oe.placeable) {
              let Qe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[V.crossTileID] && this.prevPlacement.placements[V.crossTileID] && this.prevPlacement.placements[V.crossTileID].text && (Qe = this.prevPlacement.variableOffsets[V.crossTileID].anchor), V.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[V.crossTileID] = { textOffset: Me, width: c, height: p, anchor: ke, textBoxScale: _, prevAnchor: Qe }, this.markUsedJustification(W, ke, V, le), W.allowVerticalPlacement && (this.markUsedOrientation(W, le, V), this.placedOrientations[V.crossTileID] = le), { shift: be, placedGlyphBoxes: Oe };
            }
          }
          placeLayerBucketPart(e, a, c) {
            const { bucket: p, layout: _, translationText: x, translationIcon: k, unwrappedTileID: P, pitchedLabelPlaneMatrix: R, textPixelRatio: D, holdingForFade: j, collisionBoxArray: $, partiallyEvaluatedTextSize: V, collisionGroup: W } = e.parameters, le = _.get("text-optional"), se = _.get("icon-optional"), ce = s.aF(_, "text-overlap", "text-allow-overlap"), me = ce === "always", we = s.aF(_, "icon-overlap", "icon-allow-overlap"), ye = we === "always", ke = _.get("text-rotation-alignment") === "map", Me = _.get("text-pitch-alignment") === "map", be = _.get("icon-text-fit") !== "none", Oe = _.get("symbol-z-order") === "viewport-y", Qe = me && (ye || !p.hasIconData() || se), We = ye && (me || !p.hasTextData() || le);
            !p.collisionArrays && $ && p.deserializeCollisionBoxes($);
            const Ze = this.retainedQueryData[p.bucketInstanceId].tileID, Je = this._getTerrainElevationFunc(Ze), kt = this.transform.getFastPathSimpleProjectionMatrix(Ze), Tt = (pt, Vt, _r) => {
              var Or, Xr;
              if (a[pt.crossTileID]) return;
              if (j) return void (this.placements[pt.crossTileID] = new Ll(false, false, false));
              let Gr = false, di = false, vi = true, vr = null, Yr = { box: null, placeable: false, offscreen: null, occluded: false }, Ti = { placeable: false }, zi = null, Ni = null, vn = null, so = 0, la = 0, ua = 0;
              Vt.textFeatureIndex ? so = Vt.textFeatureIndex : pt.useRuntimeCollisionCircles && (so = pt.featureIndex), Vt.verticalTextFeatureIndex && (la = Vt.verticalTextFeatureIndex);
              const ms = Vt.textBox;
              if (ms) {
                const Tn = (Ii) => {
                  let Fi = s.ao.horizontal;
                  if (p.allowVerticalPlacement && !Ii && this.prevPlacement) {
                    const Zn = this.prevPlacement.placedOrientations[pt.crossTileID];
                    Zn && (this.placedOrientations[pt.crossTileID] = Zn, Fi = Zn, this.markUsedOrientation(p, Fi, pt));
                  }
                  return Fi;
                }, lo = (Ii, Fi) => {
                  if (p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && Vt.verticalTextBox) {
                    for (const Zn of p.writingModes) if (Zn === s.ao.vertical ? (Yr = Fi(), Ti = Yr) : Yr = Ii(), Yr && Yr.placeable) break;
                  } else Yr = Ii();
                }, _n = pt.textAnchorOffsetStartIndex, ca = pt.textAnchorOffsetEndIndex;
                if (ca === _n) {
                  const Ii = (Fi, Zn) => {
                    const Mi = this.collisionIndex.placeCollisionBox(Fi, ce, D, Ze, P, Me, ke, x, W.predicate, Je, void 0, kt);
                    return Mi && Mi.placeable && (this.markUsedOrientation(p, Zn, pt), this.placedOrientations[pt.crossTileID] = Zn), Mi;
                  };
                  lo((() => Ii(ms, s.ao.horizontal)), (() => {
                    const Fi = Vt.verticalTextBox;
                    return p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && Fi ? Ii(Fi, s.ao.vertical) : { box: null, offscreen: null };
                  })), Tn(Yr && Yr.placeable);
                } else {
                  let Ii = s.aE[(Xr = (Or = this.prevPlacement) === null || Or === void 0 ? void 0 : Or.variableOffsets[pt.crossTileID]) === null || Xr === void 0 ? void 0 : Xr.anchor];
                  const Fi = (Mi, dl, vs) => {
                    const No = Mi.x2 - Mi.x1, uo = Mi.y2 - Mi.y1, da = pt.textBoxScale, Zh = be && we === "never" ? dl : null;
                    let Ln = null, Hh = ce === "never" ? 1 : 2, ed = "never";
                    Ii && Hh++;
                    for (let xu = 0; xu < Hh; xu++) {
                      for (let wu = _n; wu < ca; wu++) {
                        const ha = p.textAnchorOffsets.get(wu);
                        if (Ii && ha.textAnchor !== Ii) continue;
                        const Vo = this.attemptAnchorPlacement(ha, Mi, No, uo, da, ke, Me, D, Ze, P, W, ed, pt, p, vs, x, k, Zh, Je);
                        if (Vo && (Ln = Vo.placedGlyphBoxes, Ln && Ln.placeable)) return Gr = true, vr = Vo.shift, Ln;
                      }
                      Ii ? Ii = null : ed = ce;
                    }
                    return c && !Ln && (Ln = { box: this.collisionIndex.placeCollisionBox(ms, "always", D, Ze, P, Me, ke, x, W.predicate, Je, void 0, kt).box, offscreen: false, placeable: false, occluded: false }), Ln;
                  };
                  lo((() => Fi(ms, Vt.iconBox, s.ao.horizontal)), (() => {
                    const Mi = Vt.verticalTextBox;
                    return p.allowVerticalPlacement && (!Yr || !Yr.placeable) && pt.numVerticalGlyphVertices > 0 && Mi ? Fi(Mi, Vt.verticalIconBox, s.ao.vertical) : { box: null, occluded: true, offscreen: null };
                  })), Yr && (Gr = Yr.placeable, vi = Yr.offscreen);
                  const Zn = Tn(Yr && Yr.placeable);
                  if (!Gr && this.prevPlacement) {
                    const Mi = this.prevPlacement.variableOffsets[pt.crossTileID];
                    Mi && (this.variableOffsets[pt.crossTileID] = Mi, this.markUsedJustification(p, Mi.anchor, pt, Zn));
                  }
                }
              }
              if (zi = Yr, Gr = zi && zi.placeable, vi = zi && zi.offscreen, pt.useRuntimeCollisionCircles) {
                const Tn = p.text.placedSymbolArray.get(pt.centerJustifiedTextSymbolIndex), lo = s.ap(p.textSizeData, V, Tn), _n = _.get("text-padding");
                Ni = this.collisionIndex.placeCollisionCircles(ce, Tn, p.lineVertexArray, p.glyphOffsetArray, lo, P, R, c, Me, W.predicate, pt.collisionCircleDiameter, _n, x, Je), Ni.circles.length && Ni.collisionDetected && !c && s.w("Collisions detected, but collision boxes are not shown"), Gr = me || Ni.circles.length > 0 && !Ni.collisionDetected, vi = vi && Ni.offscreen;
              }
              if (Vt.iconFeatureIndex && (ua = Vt.iconFeatureIndex), Vt.iconBox) {
                const Tn = (lo) => this.collisionIndex.placeCollisionBox(lo, we, D, Ze, P, Me, ke, k, W.predicate, Je, be && vr ? vr : void 0, kt);
                Ti && Ti.placeable && Vt.verticalIconBox ? (vn = Tn(Vt.verticalIconBox), di = vn.placeable) : (vn = Tn(Vt.iconBox), di = vn.placeable), vi = vi && vn.offscreen;
              }
              const gs = le || pt.numHorizontalGlyphVertices === 0 && pt.numVerticalGlyphVertices === 0, $a = se || pt.numIconVertices === 0;
              gs || $a ? $a ? gs || (di = di && Gr) : Gr = di && Gr : di = Gr = di && Gr;
              const ja = di && vn.placeable;
              if (Gr && zi.placeable && this.collisionIndex.insertCollisionBox(zi.box, ce, _.get("text-ignore-placement"), p.bucketInstanceId, Ti && Ti.placeable && la ? la : so, W.ID), ja && this.collisionIndex.insertCollisionBox(vn.box, we, _.get("icon-ignore-placement"), p.bucketInstanceId, ua, W.ID), Ni && Gr && this.collisionIndex.insertCollisionCircles(Ni.circles, ce, _.get("text-ignore-placement"), p.bucketInstanceId, so, W.ID), c && this.storeCollisionData(p.bucketInstanceId, _r, Vt, zi, vn, Ni), pt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (p.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[pt.crossTileID] = new Ll((Gr || Qe) && !(zi == null ? void 0 : zi.occluded), (di || We) && !(vn == null ? void 0 : vn.occluded), vi || p.justReloaded), a[pt.crossTileID] = true;
            };
            if (Oe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const pt = p.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Vt = pt.length - 1; Vt >= 0; --Vt) {
                const _r = pt[Vt];
                Tt(p.symbolInstances.get(_r), p.collisionArrays[_r], _r);
              }
            } else for (let pt = e.symbolInstanceStart; pt < e.symbolInstanceEnd; pt++) Tt(p.symbolInstances.get(pt), p.collisionArrays[pt], pt);
            p.justReloaded = false;
          }
          storeCollisionData(e, a, c, p, _, x) {
            if (c.textBox || c.iconBox) {
              let k, P;
              this.collisionBoxArrays.has(e) ? k = this.collisionBoxArrays.get(e) : (k = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, k)), k.has(a) ? P = k.get(a) : (P = { text: null, icon: null }, k.set(a, P)), c.textBox && (P.text = p.box), c.iconBox && (P.icon = _.box);
            }
            if (x) {
              let k = this.collisionCircleArrays[e];
              k === void 0 && (k = this.collisionCircleArrays[e] = []);
              for (let P = 0; P < x.circles.length; P += 4) k.push(x.circles[P + 0] - Zr), k.push(x.circles[P + 1] - Zr), k.push(x.circles[P + 2]), k.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, a, c, p) {
            let _;
            _ = p === s.ao.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[s.aG(a)];
            const x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const k of x) k >= 0 && (e.text.placedSymbolArray.get(k).crossTileID = _ >= 0 && k !== _ ? 0 : c.crossTileID);
          }
          markUsedOrientation(e, a, c) {
            const p = a === s.ao.horizontal || a === s.ao.horizontalOnly ? a : 0, _ = a === s.ao.vertical ? a : 0, x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const k of x) e.text.placedSymbolArray.get(k).placedOrientation = p;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = false;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const p = a ? a.symbolFadeChange(e) : 1, _ = a ? a.opacities : {}, x = a ? a.variableOffsets : {}, k = a ? a.placedOrientations : {};
            for (const P in this.placements) {
              const R = this.placements[P], D = _[P];
              D ? (this.opacities[P] = new Ur(D, p, R.text, R.icon), c = c || R.text !== D.text.placed || R.icon !== D.icon.placed) : (this.opacities[P] = new Ur(null, p, R.text, R.icon, R.skipFade), c = c || R.text || R.icon);
            }
            for (const P in _) {
              const R = _[P];
              if (!this.opacities[P]) {
                const D = new Ur(R, p, false, false);
                D.isHidden() || (this.opacities[P] = D, c = c || R.text.placed || R.icon.placed);
              }
            }
            for (const P in x) this.variableOffsets[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.variableOffsets[P] = x[P]);
            for (const P in k) this.placedOrientations[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.placedOrientations[P] = k[P]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const p of a) {
              const _ = p.getBucket(e);
              _ && p.latestFeatureIndex && e.id === _.layerIds[0] && this.updateBucketOpacities(_, p.tileID, c, p.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, a, c, p) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const _ = e.layers[0], x = _.layout, k = new Ur(null, 0, false, false, true), P = x.get("text-allow-overlap"), R = x.get("icon-allow-overlap"), D = _._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset"), j = x.get("text-rotation-alignment") === "map", $ = x.get("text-pitch-alignment") === "map", V = x.get("icon-text-fit") !== "none", W = new Ur(null, 0, P && (R || !e.hasIconData() || x.get("icon-optional")), R && (P || !e.hasTextData() || x.get("text-optional")), true);
            !e.collisionArrays && p && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(p);
            const le = (ce, me, we) => {
              for (let ye = 0; ye < me / 4; ye++) ce.opacityVertexArray.emplaceBack(we);
              ce.hasVisibleVertices = ce.hasVisibleVertices || we !== ra;
            }, se = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ce = 0; ce < e.symbolInstances.length; ce++) {
              const me = e.symbolInstances.get(ce), { numHorizontalGlyphVertices: we, numVerticalGlyphVertices: ye, crossTileID: ke } = me;
              let Me = this.opacities[ke];
              c[ke] ? Me = k : Me || (Me = W, this.opacities[ke] = Me), c[ke] = true;
              const be = me.numIconVertices > 0, Oe = this.placedOrientations[me.crossTileID], Qe = Oe === s.ao.vertical, We = Oe === s.ao.horizontal || Oe === s.ao.horizontalOnly;
              if (we > 0 || ye > 0) {
                const Je = Fs(Me.text);
                le(e.text, we, Qe ? ra : Je), le(e.text, ye, We ? ra : Je);
                const kt = Me.text.isHidden();
                [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach(((Vt) => {
                  Vt >= 0 && (e.text.placedSymbolArray.get(Vt).hidden = kt || Qe ? 1 : 0);
                })), me.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = kt || We ? 1 : 0);
                const Tt = this.variableOffsets[me.crossTileID];
                Tt && this.markUsedJustification(e, Tt.anchor, me, Oe);
                const pt = this.placedOrientations[me.crossTileID];
                pt && (this.markUsedJustification(e, "left", me, pt), this.markUsedOrientation(e, pt, me));
              }
              if (be) {
                const Je = Fs(Me.icon), kt = !(V && me.verticalPlacedIconSymbolIndex && Qe);
                me.placedIconSymbolIndex >= 0 && (le(e.icon, me.numIconVertices, kt ? Je : ra), e.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = Me.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (le(e.icon, me.numVerticalIconVertices, kt ? ra : Je), e.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = Me.icon.isHidden());
              }
              const Ze = se && se.has(ce) ? se.get(ce) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Je = e.collisionArrays[ce];
                if (Je) {
                  let kt = new s.P(0, 0);
                  if (Je.textBox || Je.verticalTextBox) {
                    let Tt = true;
                    if (D) {
                      const pt = this.variableOffsets[ke];
                      pt ? (kt = xo(pt.anchor, pt.width, pt.height, pt.textOffset, pt.textBoxScale), j && kt._rotate($ ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Tt = false;
                    }
                    if (Je.textBox || Je.verticalTextBox) {
                      let pt;
                      Je.textBox && (pt = Qe), Je.verticalTextBox && (pt = We), zs(e.textCollisionBox.collisionVertexArray, Me.text.placed, !Tt || pt, Ze.text, kt.x, kt.y);
                    }
                  }
                  if (Je.iconBox || Je.verticalIconBox) {
                    const Tt = !!(!We && Je.verticalIconBox);
                    let pt;
                    Je.iconBox && (pt = Tt), Je.verticalIconBox && (pt = !Tt), zs(e.iconCollisionBox.collisionVertexArray, Me.icon.placed, pt, Ze.icon, V ? kt.x : 0, V ? kt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e;
          }
          setStale() {
            this.stale = true;
          }
        }
        function zs(v, e, a, c, p, _) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const x = c[0] - Zr, k = c[1] - Zr, P = c[2] - Zr, R = c[3] - Zr;
          v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, x, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, P, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, P, R), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, x, R);
        }
        const Bl = Math.pow(2, 25), Ol = Math.pow(2, 24), ta = Math.pow(2, 17), $l = Math.pow(2, 16), cc = Math.pow(2, 9), dc = Math.pow(2, 8), hc = Math.pow(2, 1);
        function Fs(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const e = v.placed ? 1 : 0, a = Math.floor(127 * v.opacity);
          return a * Bl + e * Ol + a * ta + e * $l + a * cc + e * dc + a * hc + e;
        }
        const ra = 0;
        class Ls {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, a, c, p, _) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (a.getBucketParts(x, p, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, x.sort(((k, P) => k.sortKey - P.sortKey))); this._currentPartIndex < x.length; ) if (a.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _()) return true;
            return false;
          }
        }
        class Bs {
          constructor(e, a, c, p, _, x, k, P) {
            this.placement = new wo(e, a, x, k, P), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = p, this._showCollisionBoxes = _, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, a, c) {
            const p = L.now(), _ = () => !this._forceFullPlacement && L.now() - p > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = a[e[this._currentPlacementIndex]], k = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= k) && (!x.maxzoom || x.maxzoom > k)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ls(x)), this._inProgressLayer.continuePlacement(c[x.source], this.placement, this._showCollisionBoxes, x, _)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const ia = 512 / s.$ / 2;
        class Os {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const p = /* @__PURE__ */ new Map();
            for (let _ = 0; _ < a.length; _++) {
              const x = a.get(_), k = x.key, P = p.get(k);
              P ? P.push(x) : p.set(k, [x]);
            }
            for (const [_, x] of p) {
              const k = { positions: x.map(((P) => ({ x: Math.floor(P.anchorX * ia), y: Math.floor(P.anchorY * ia) }))), crossTileIDs: x.map(((P) => P.crossTileID)) };
              if (k.positions.length > 128) {
                const P = new s.aI(k.positions.length, 16, Uint16Array);
                for (const { x: R, y: D } of k.positions) P.add(R, D);
                P.finish(), delete k.positions, k.index = P;
              }
              this._symbolsByKey[_] = k;
            }
          }
          getScaledCoordinates(e, a) {
            const { x: c, y: p, z: _ } = this.tileID.canonical, { x, y: k, z: P } = a.canonical, R = ia / Math.pow(2, P - _), D = (k * s.$ + e.anchorY) * R, j = p * s.$ * ia;
            return { x: Math.floor((x * s.$ + e.anchorX) * R - c * s.$ * ia), y: Math.floor(D - j) };
          }
          findMatches(e, a, c) {
            const p = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let _ = 0; _ < e.length; _++) {
              const x = e.get(_);
              if (x.crossTileID) continue;
              const k = this._symbolsByKey[x.key];
              if (!k) continue;
              const P = this.getScaledCoordinates(x, a);
              if (k.index) {
                const R = k.index.range(P.x - p, P.y - p, P.x + p, P.y + p).sort();
                for (const D of R) {
                  const j = k.crossTileIDs[D];
                  if (!c[j]) {
                    c[j] = true, x.crossTileID = j;
                    break;
                  }
                }
              } else if (k.positions) for (let R = 0; R < k.positions.length; R++) {
                const D = k.positions[R], j = k.crossTileIDs[R];
                if (Math.abs(D.x - P.x) <= p && Math.abs(D.y - P.y) <= p && !c[j]) {
                  c[j] = true, x.crossTileID = j;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class $s {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class fc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0) for (const c in this.indexes) {
              const p = this.indexes[c], _ = {};
              for (const x in p) {
                const k = p[x];
                k.tileID = k.tileID.unwrapTo(k.tileID.wrap + a), _[k.tileID.key] = k;
              }
              this.indexes[c] = _;
            }
            this.lng = e;
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) a.symbolInstances.get(_).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const p = this.usedCrossTileIDs[e.overscaledZ];
            for (const _ in this.indexes) {
              const x = this.indexes[_];
              if (Number(_) > e.overscaledZ) for (const k in x) {
                const P = x[k];
                P.tileID.isChildOf(e) && P.findMatches(a.symbolInstances, e, p);
              }
              else {
                const k = x[e.scaledTo(Number(_)).key];
                k && k.findMatches(a.symbolInstances, e, p);
              }
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) {
              const x = a.symbolInstances.get(_);
              x.crossTileID || (x.crossTileID = c.generate(), p[x.crossTileID] = true);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Os(e, a.symbolInstances, a.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists()) for (const p of c) delete this.usedCrossTileIDs[e][p];
          }
          removeStaleBuckets(e) {
            let a = false;
            for (const c in this.indexes) {
              const p = this.indexes[c];
              for (const _ in p) e[p[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, p[_]), delete p[_], a = true);
            }
            return a;
          }
        }
        class na {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new $s(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, a, c) {
            let p = this.layerIndexes[e.id];
            p === void 0 && (p = this.layerIndexes[e.id] = new fc());
            let _ = false;
            const x = {};
            p.handleWrapJump(c);
            for (const k of a) {
              const P = k.getBucket(e);
              P && e.id === P.layerIds[0] && (P.bucketInstanceId || (P.bucketInstanceId = ++this.maxBucketInstanceId), p.addBucket(k.tileID, P, this.crossTileIDs) && (_ = true), x[P.bucketInstanceId] = true);
            }
            return p.removeStaleBuckets(x) && (_ = true), _;
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach(((c) => {
              a[c] = true;
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c];
          }
        }
        var Ca = "void main() {fragColor=vec4(1.0);}";
        const Dn = { prelude: br(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: br("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: br("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: br(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: br(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: br(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: br(Ca, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: br(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: br(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: br("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: br("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: br(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: br("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: br(Ca, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: br(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: br(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: br(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: br(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: br(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: br(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: br(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: br(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: br(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: br(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: br(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: br(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: br(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: br(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: br(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: br(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: br("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: br("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: br("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: br("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: br(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: br("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function br(v, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = e.match(/in ([\w]+) ([\w]+)/g), p = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), _ = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = _ ? _.concat(p) : p, k = {};
          return { fragmentSource: v = v.replace(a, ((P, R, D, j, $) => (k[$] = true, R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
in ${D} ${j} ${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : `
#ifdef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = u_${$};
#endif
`))), vertexSource: e = e.replace(a, ((P, R, D, j, $) => {
            const V = j === "float" ? "vec2" : "vec4", W = $.match(/color/) ? "color" : V;
            return k[$] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${D} ${V} a_${$};
out ${D} ${j} ${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = a_${$};
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = unpack_mix_${W}(a_${$}, u_${$}_t);
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${D} ${V} a_${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : W === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = a_${$};
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = unpack_mix_${W}(a_${$}, u_${$}_t);
#else
    ${D} ${j} ${$} = u_${$};
#endif
`;
          })), staticAttributes: c, staticUniforms: x };
        }
        class Lo {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Co = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Qn = "#define PROJECTION_MERCATOR", Bo = "mercator";
        class xr {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return Bo;
          }
          get shaderDefine() {
            return Qn;
          }
          get shaderPreludeCode() {
            return Dn.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Dn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return s.aK.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, a, c, p, _) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(s.$, 0), x.emplaceBack(0, s.$), x.emplaceBack(s.$, s.$);
            const k = e.createVertexBuffer(x, Co.members), P = s.aM.simpleSegment(0, 0, 4, 2), R = new s.aN();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const D = e.createIndexBuffer(R);
            return this._cachedMesh = new Lo(k, D, P), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class Sa {
          constructor(e = 0, a = 0, c = 0, p = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(p) || p < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = p;
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = s.C.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = s.C.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = s.C.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = s.C.number(e.right, a.right, c)), this;
          }
          getCenter(e, a) {
            const c = s.ah((this.left + e - this.right) / 2, 0, e), p = s.ah((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(c, p);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new Sa(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function jl(v, e) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const a = e.lng - v.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0;
        }
        function Nl(v) {
          return Math.max(0, Math.floor(v));
        }
        class fn {
          constructor(e, a, c, p, _, x) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = x === void 0 || !!x, this._minZoom = a || 0, this._maxZoom = c || 22, this._minPitch = p ?? 0, this._maxPitch = _ ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Nl(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Sa(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Nl(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Sa(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new s.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const a = s.aO(e, -180, 180) * Math.PI / 180;
            var c, p, _, x, k, P, R, D, j;
            this._bearingInRadians !== a && (this._unmodified = false, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = T(), c = this._rotationMatrix, _ = -this._bearingInRadians, x = (p = this._rotationMatrix)[0], k = p[1], P = p[2], R = p[3], D = Math.sin(_), j = Math.cos(_), c[0] = x * j + P * D, c[1] = k * j + R * D, c[2] = x * -D + P * j, c[3] = k * -D + R * j);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const a = s.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = false, this._pitchInRadians = a, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = false, this._rollInRadians = a, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return s.aP(this._fovInRadians);
          }
          setFov(e) {
            e = s.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = s.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const a = this.getConstrained(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = false, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.af(a), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = a, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, a, c) {
            this._unmodified = false, this._edgeInsets.interpolate(e, a, c), this._constrain(), this._calcMatrices();
          }
          resize(e, a, c = true) {
            this._width = e, this._height = a, c && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new sr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-s.ai, s.ai]);
          }
          getConstrained(e, a) {
            return this._callbacks.getConstrained(e, a);
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const { minX: c, minY: p, maxX: _, maxY: x } = s.a2.fromPoints(a).extend(e);
              return [new s.P(c, p), new s.P(_, p), new s.P(_, x), new s.P(c, x), new s.P(c, p)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e = this._unmodified, { center: a, zoom: c } = this.getConstrained(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.ag(new Float64Array(16));
              s.N(e, e, [this._width / 2, -this._height / 2, 1]), s.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.ag(new Float64Array(16)), s.N(e, e, [1, -1, 1]), s.M(e, e, [-1, -1, 0]), s.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            const _ = c !== void 0 ? c : this.bearing, x = p = p !== void 0 ? p : this.pitch, k = s.a1.fromLngLat(e, a), P = -Math.cos(s.ae(x)), R = Math.sin(s.ae(x)), D = R * Math.sin(s.ae(_)), j = -R * Math.cos(s.ae(_));
            let $ = this.elevation;
            const V = a - $;
            let W;
            P * V >= 0 || Math.abs(P) < 0.1 ? (W = 1e4, $ = a + W * P) : W = -V / P;
            let le, se, ce = s.aQ(1, k.y), me = 0;
            do {
              if (me += 1, me > 10) break;
              se = W / ce, le = new s.a1(k.x + D * se, k.y + j * se), ce = 1 / le.meterInMercatorCoordinateUnits();
            } while (Math.abs(W - se * ce) > 1e-12);
            return { center: le.toLngLat(), elevation: $, zoom: s.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / se / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.aj(1, this.center.lat) * this.worldSize, c = this.cameraToCenterDistance / a, p = s.a1.fromLngLat(this.center, this.elevation), _ = he(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const x = this.calculateCenterFromCameraLngLatAlt(_.toLngLat(), s.aQ(_.z, p.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return he(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.$, 1 / a / s.$];
          }
        }
        class $i {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aR([], s.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2], c = s.aT(this.min), p = s.aT(this.max);
            for (let _ = 0; _ < a.length; _++) c[_] = a[_] ? this.min[_] : this.center[_], p[_] = a[_] ? this.center[_] : this.max[_];
            return p[2] = this.max[2], new $i(c, p);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let a = true;
            for (let c = 0; c < e.planes.length; c++) {
              const p = this.intersectsPlane(e.planes[c]);
              if (p === 0) return 0;
              p === 1 && (a = false);
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let a = e[3], c = e[3];
            for (let p = 0; p < 3; p++) e[p] > 0 ? (a += e[p] * this.min[p], c += e[p] * this.max[p]) : (c += e[p] * this.min[p], a += e[p] * this.max[p]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1;
          }
        }
        class pn {
          distanceToTile2d(e, a, c, p) {
            const _ = p.distanceX([e, a]), x = p.distanceY([e, a]);
            return Math.hypot(_, x);
          }
          getWrap(e, a, c) {
            return c;
          }
          getTileBoundingVolume(e, a, c, p) {
            var _, x;
            let k = 0, P = 0;
            if (p == null ? void 0 : p.terrain) {
              const D = new s.Z(e.z, a, e.z, e.x, e.y), j = p.terrain.getMinMaxElevation(D);
              k = (_ = j.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), P = (x = j.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            const R = 1 << e.z;
            return new $i([a + e.x / R, e.y / R, k], [a + (e.x + 1) / R, (e.y + 1) / R, P]);
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, p = s.ah(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > p;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Pi {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c;
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, p, _) {
            const x = _ ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], k = Math.pow(2, c), P = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((($) => (function(V, W, le, se) {
              const ce = s.aw([], V, W), me = 1 / ce[3] / le * se;
              return s.aY(ce, ce, [me, me, 1 / ce[3], me]);
            })($, e, a, k)));
            p && (function($, V, W, le) {
              const se = le ? 4 : 0, ce = le ? 0 : 4;
              let me = 0;
              const we = [], ye = [];
              for (let be = 0; be < 4; be++) {
                const Oe = s.aU([], $[be + ce], $[be + se]), Qe = s.aZ(Oe);
                s.aR(Oe, Oe, 1 / Qe), we.push(Qe), ye.push(Oe);
              }
              for (let be = 0; be < 4; be++) {
                const Oe = s.a_($[be + se], ye[be], W);
                me = Oe !== null && Oe >= 0 ? Math.max(me, Oe) : Math.max(me, we[be]);
              }
              const ke = (function(be, Oe) {
                const Qe = s.aU([], be[Oe[0]], be[Oe[1]]), We = s.aU([], be[Oe[2]], be[Oe[1]]), Ze = [0, 0, 0, 0];
                return s.aV(Ze, s.aW([], Qe, We)), Ze[3] = -s.aX(Ze, be[Oe[0]]), Ze;
              })($, V), Me = (function(be, Oe) {
                const Qe = s.a$(be), We = s.b0([], be, 1 / Qe), Ze = s.aU([], Oe, s.aR([], We, s.aX(Oe, We))), Je = s.a$(Ze);
                if (Je > 0) {
                  const kt = Math.sqrt(1 - We[3] * We[3]), Tt = s.aR([], We, -We[3]), pt = s.aS([], Tt, s.aR([], Ze, kt / Je));
                  return s.b1(Oe, pt);
                }
                return null;
              })(W, ke);
              if (Me !== null) {
                const be = Me / s.aX(ye[0], ke);
                me = Math.min(me, be);
              }
              for (let be = 0; be < 4; be++) {
                const Oe = Math.min(me, we[be]);
                $[be + ce] = [$[be + se][0] + ye[be][0] * Oe, $[be + se][1] + ye[be][1] * Oe, $[be + se][2] + ye[be][2] * Oe, 1];
              }
            })(P, x[0], p, _);
            const R = x.map((($) => {
              const V = s.aU([], P[$[0]], P[$[1]]), W = s.aU([], P[$[2]], P[$[1]]), le = s.aV([], s.aW([], V, W)), se = -s.aX(le, P[$[1]]);
              return le.concat(se);
            })), D = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const $ of P) for (let V = 0; V < 3; V++) D[V] = Math.min(D[V], $[V]), j[V] = Math.max(j[V], $[V]);
            return new Pi(P, R, new $i(D, j));
          }
        }
        class ti {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, a) {
          }
          constructor(e, a, c, p, _) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new fn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (x, k) => this.getConstrained(x, k) }, e, a, c, p, _), this._coveringTilesDetailsProvider = new pn();
          }
          clone() {
            const e = new ti();
            return e.apply(this), e;
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new s.P(0, 0)), p = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)), _ = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)), k = Math.floor(Math.min(c.x, p.x, _.x, x.x)), P = Math.floor(Math.max(c.x, p.x, _.x, x.x)), R = 1;
              for (let D = k - R; D <= P + R; D++) D !== 0 && a.push(new s.b2(D, e));
            }
            return a;
          }
          getCameraFrustum() {
            return Pi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e), c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c);
          }
          setLocationAtPoint(e, a) {
            const c = s.aj(this.elevation, this.center.lat), p = this.screenPointToMercatorCoordinateAtZ(a, c), _ = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c), x = s.a1.fromLngLat(e), k = new s.a1(x.x - (p.x - _.x), x.y - (p.y - _.y));
            this.setCenter(k == null ? void 0 : k.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a1.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a1.fromLngLat(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0, p = [e.x, e.y, 0, 1], _ = [e.x, e.y, 1, 1];
            s.aw(p, p, this._pixelMatrixInverse), s.aw(_, _, this._pixelMatrixInverse);
            const x = p[3], k = _[3], P = p[1] / x, R = _[1] / k, D = p[2] / x, j = _[2] / k, $ = D === j ? 0 : (c - D) / (j - D);
            return new s.a1(s.C.number(p[0] / x, _[0] / k, $) / this.worldSize, s.C.number(P, R, $) / this.worldSize, c);
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const p = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aw(p, p, c), new s.P(p[0] / p[3], p[1] / p[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Te(this));
            return new sr().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - Te(this);
          }
          calculatePosMatrix(e, a = false, c) {
            var p;
            const _ = (p = e.key) !== null && p !== void 0 ? p : s.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), x = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(_)) {
              const R = x.get(_);
              return c ? R.f32 : R.f64;
            }
            const k = De(e, this.worldSize);
            s.O(k, a ? this._alignedProjMatrix : this._viewProjMatrix, k);
            const P = { f64: k, f32: new Float32Array(k) };
            return x.set(_, P), c ? P.f32 : P.f64;
          }
          calculateFogMatrix(e) {
            const a = e.key, c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const p = De(e, this.worldSize);
            return s.O(p, this._fogMatrix, p), c.set(a, new Float32Array(p)), c.get(a);
          }
          getConstrained(e, a) {
            a = s.ah(+a, this.minZoom, this.maxZoom);
            const c = { center: new s.S(e.lng, e.lat), zoom: a };
            let p = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && p === null) {
              const we = 179.9999999999;
              p = [-we, we];
            }
            const _ = this.tileSize * s.af(c.zoom);
            let x = 0, k = _, P = 0, R = _, D = 0, j = 0;
            const { x: $, y: V } = this.size;
            if (this._helper._latRange) {
              const we = this._helper._latRange;
              x = s.U(we[1]) * _, k = s.U(we[0]) * _, k - x < V && (D = V / (k - x));
            }
            p && (P = s.aO(s.V(p[0]) * _, 0, _), R = s.aO(s.V(p[1]) * _, 0, _), R < P && (R += _), R - P < $ && (j = $ / (R - P)));
            const { x: W, y: le } = ne(_, e);
            let se, ce;
            const me = Math.max(j || 0, D || 0);
            if (me) {
              const we = new s.P(j ? (R + P) / 2 : W, D ? (k + x) / 2 : le);
              return c.center = _e(_, we).wrap(), c.zoom += s.ak(me), c;
            }
            if (this._helper._latRange) {
              const we = V / 2;
              le - we < x && (ce = x + we), le + we > k && (ce = k - we);
            }
            if (p) {
              const we = (P + R) / 2;
              let ye = W;
              this._helper._renderWorldCopies && (ye = s.aO(W, we - _ / 2, we + _ / 2));
              const ke = $ / 2;
              ye - ke < P && (se = P + ke), ye + ke > R && (se = R - ke);
            }
            if (se !== void 0 || ce !== void 0) {
              const we = new s.P(se ?? W, ce ?? le);
              c.center = _e(_, we).wrap();
            }
            return c;
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const p = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), _ = e - p * this._helper._pixelPerMeter / Math.cos(a), x = p < 0 ? _ : e, k = Math.PI / 2 + this.pitchInRadians, P = s.ae(this.fov) * (Math.abs(Math.cos(s.ae(this.roll))) * this.height + Math.abs(Math.sin(s.ae(this.roll))) * this.width) / this.height * (0.5 + c.y / this.height), R = Math.sin(P) * x / Math.sin(s.ah(Math.PI - k - P, 0.01, Math.PI - 0.01)), D = Te(this), j = Math.atan(D / this._helper.cameraToCenterDistance), $ = s.ae(0.75), V = j > $ ? 2 * j * (0.5 + c.y / (2 * D)) : $, W = Math.sin(V) * x / Math.sin(s.ah(Math.PI - k - V, 0.01, Math.PI - 0.01)), le = Math.min(R, W);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * le + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, a = ne(this.worldSize, this.center), c = a.x, p = a.y;
            this._helper._pixelPerMeter = s.aj(1, this.center.lat) * this.worldSize;
            const _ = s.ae(Math.min(this.pitch, Y)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(_));
            let k;
            this._calculateNearFarZIfNeeded(x, _, e), k = new Float64Array(16), s.b4(k, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.aq(this._invProjMatrix, k), k[8] = 2 * -e.x / this._helper._width, k[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b5(k), s.N(k, k, [1, -1, 1]), s.M(k, k, [0, 0, -this._helper.cameraToCenterDistance]), s.b6(k, k, -this.rollInRadians), s.b7(k, k, this.pitchInRadians), s.b6(k, k, -this.bearingInRadians), s.M(k, k, [-c, -p, 0]), this._mercatorMatrix = s.N([], k, [this.worldSize, this.worldSize, this.worldSize]), s.N(k, k, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k), s.M(k, k, [0, 0, -this.elevation]), this._viewProjMatrix = k, this._invViewProjMatrix = s.aq([], k);
            const P = [0, 0, -1, 1];
            s.aw(P, P, this._invViewProjMatrix), this._cameraPosition = [P[0] / P[3], P[1] / P[3], P[2] / P[3]], this._fogMatrix = new Float64Array(16), s.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.M(this._fogMatrix, this._fogMatrix, [-c, -p, 0]), s.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k);
            const R = this._helper._width % 2 / 2, D = this._helper._height % 2 / 2, j = Math.cos(this.bearingInRadians), $ = Math.sin(-this.bearingInRadians), V = c - Math.round(c) + j * R + $ * D, W = p - Math.round(p) + j * D + $ * R, le = new Float64Array(k);
            if (s.M(le, le, [V > 0.5 ? V - 1 : V, W > 0.5 ? W - 1 : W, 0]), this._alignedProjMatrix = le, k = s.aq(new Float64Array(16), this._pixelMatrix), !k) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = k, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)), a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aw(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return he(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, a) {
            const c = s.a1.fromLngLat(e), p = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return s.aw(p, p, this._viewProjMatrix), p[2] / p[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: a, aligned: c, applyTerrainMatrix: p } = e, _ = this._helper.getMercatorTileCoordinates(a), x = a ? this.calculatePosMatrix(a, c, true) : null;
            let k;
            return k = a && a.terrainRttPosMatrix32f && p ? a.terrainRttPosMatrix32f : x || s.b8(), { mainMatrix: k, tileMercatorCoords: _, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: k };
          }
          isLocationOccluded(e) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, a, c) {
            return 1;
          }
          transformLightDirection(e) {
            return s.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, a, c, p) {
            const _ = this.calculatePosMatrix(c);
            let x;
            p ? (x = [e, a, p(e, a), 1], s.aw(x, x, _)) : (x = [e, a, 0, 1], bo(x, x, _));
            const k = x[3];
            return { point: new s.P(x[0] / k, x[1] / k), signedDistanceFromCamera: k, isOccluded: false };
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a);
          }
          getMatrixForModel(e, a) {
            const c = s.a1.fromLngLat(e, a), p = c.meterInMercatorCoordinateUnits(), _ = s.b9();
            return s.M(_, _, [c.x, c.y, c.z]), s.b6(_, _, Math.PI), s.b7(_, _, Math.PI / 2), s.N(_, _, [-p, p, p]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = new s.Z(0, 0, 0, 0, 0), c = this.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: e }), p = De(a, this.worldSize);
            s.O(p, this._viewProjMatrix, p), c.tileMercatorCoords = [0, 0, 1, 1];
            const _ = [s.$, s.$, this.worldSize / this._helper.pixelsPerMeter], x = s.ba();
            return s.N(x, p, _), c.fallbackMatrix = x, c.mainMatrix = x, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function oh() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function mn(v) {
          if (v.useSlerp) if (v.k < 1) {
            const e = s.bb(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), a = s.bb(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), c = new Float64Array(4);
            s.bc(c, e, a, v.k);
            const p = s.bd(c);
            v.tr.setRoll(p.roll), v.tr.setPitch(p.pitch), v.tr.setBearing(p.bearing);
          } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(s.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(s.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(s.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function zn(v, e, a, c, p) {
          const _ = p.padding, x = ne(p.worldSize, a.getNorthWest()), k = ne(p.worldSize, a.getNorthEast()), P = ne(p.worldSize, a.getSouthEast()), R = ne(p.worldSize, a.getSouthWest()), D = s.ae(-c), j = x.rotate(D), $ = k.rotate(D), V = P.rotate(D), W = R.rotate(D), le = new s.P(Math.max(j.x, $.x, W.x, V.x), Math.max(j.y, $.y, W.y, V.y)), se = new s.P(Math.min(j.x, $.x, W.x, V.x), Math.min(j.y, $.y, W.y, V.y)), ce = le.sub(se), me = (p.width - (_.left + _.right + e.left + e.right)) / ce.x, we = (p.height - (_.top + _.bottom + e.top + e.bottom)) / ce.y;
          if (we < 0 || me < 0) return void oh();
          const ye = Math.min(s.ak(p.scale * Math.min(me, we)), v.maxZoom), ke = s.P.convert(v.offset), Me = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ae(c)), be = ke.add(Me).mult(p.scale / s.af(ye));
          return { center: _e(p.worldSize, x.add(P).div(2).sub(be)), zoom: ye, bearing: c };
        }
        class nn {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e, a) {
            const c = e.mag(), p = Math.abs(Te(a));
            return { easingOffset: e.mult(Math.min(0.75 * p / c, 1)), easingCenter: a.center };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < 0.01 || a.setLocationAtPoint(c, e.around);
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            return zn(e, a, c, p, _);
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.S.convert(a.center));
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.padding, _ = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, x = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, k = a.zoom !== void 0, P = !e.isPaddingEqual(a.padding);
            let R = false;
            const D = k ? +a.zoom : e.zoom;
            let j = e.centerPoint.add(a.offsetAsPoint);
            const $ = e.screenPointToLocation(j), { center: V, zoom: W } = e.getConstrained(s.S.convert(a.center || $), D ?? c);
            jl(e, V);
            const le = ne(e.worldSize, $), se = ne(e.worldSize, V).sub(le), ce = s.af(W - c);
            return R = W !== c, { easeFunc: (me) => {
              if (R && e.setZoom(s.C.number(c, W, me)), s.be(_, x) || mn({ startEulerAngles: _, endEulerAngles: x, tr: e, k: me, useSlerp: _.roll != x.roll }), P && (e.interpolatePadding(p, a.padding, me), j = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const we = s.af(e.zoom - c), ye = W > c ? Math.min(2, ce) : Math.max(0.5, ce), ke = Math.pow(ye, 1 - me), Me = _e(e.worldSize, le.add(se.mult(me * ke)).mult(we));
                e.setLocationAtPoint(e.renderWorldCopies ? Me.wrap() : Me, j);
              }
            }, isZooming: R, elevationCenter: V };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.zoom, _ = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), c ? +a.zoom : p), x = _.center, k = _.zoom;
            jl(e, x);
            const P = ne(e.worldSize, a.locationAtOffset), R = ne(e.worldSize, x).sub(P), D = R.mag(), j = s.af(k - p);
            let $;
            if (a.minZoom !== void 0) {
              const V = Math.min(+a.minZoom, p, k), W = e.getConstrained(x, V).zoom;
              $ = s.af(W - p);
            }
            return { easeFunc: (V, W, le, se) => {
              e.setZoom(V === 1 ? k : p + s.ak(W));
              const ce = V === 1 ? x : _e(e.worldSize, P.add(R.mult(le)).mult(W));
              e.setLocationAtPoint(e.renderWorldCopies ? ce.wrap() : ce, se);
            }, scaleOfZoom: j, targetCenter: x, scaleOfMinZoom: $, pixelPathLength: D };
          }
        }
        class si {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c;
          }
        }
        si.Replace = [1, 0], si.disabled = new si(si.Replace, s.bf.transparent, [false, false, false, false]), si.unblended = new si(si.Replace, s.bf.transparent, [true, true, true, true]), si.alphaBlended = new si([1, 771], s.bf.transparent, [true, true, true, true]);
        const ka = 2305;
        class nr {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c;
          }
        }
        nr.disabled = new nr(false, 1029, ka), nr.backCCW = new nr(true, 1029, ka), nr.frontCCW = new nr(true, 1028, ka);
        class mr {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c;
          }
        }
        mr.ReadOnly = false, mr.ReadWrite = true, mr.disabled = new mr(519, mr.ReadOnly, [0, 1]);
        const Oo = 7680;
        class Ar {
          constructor(e, a, c, p, _, x) {
            this.test = e, this.ref = a, this.mask = c, this.fail = p, this.depthFail = _, this.pass = x;
          }
        }
        Ar.disabled = new Ar({ func: 519, mask: 0 }, 0, 0, Oo, Oo, Oo);
        const Fn = /* @__PURE__ */ new WeakMap();
        function So(v) {
          var e;
          if (Fn.has(v)) return Fn.get(v);
          {
            const a = (e = v.getParameter(v.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Fn.set(v, a), a;
          }
        }
        class ko {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context, c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const p = new s.aL();
            p.emplaceBack(-1, -1), p.emplaceBack(2, -1), p.emplaceBack(-1, 2);
            const _ = new s.aN();
            _.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Lo(a.createVertexBuffer(p, Co.members), a.createIndexBuffer(_), s.aM.simpleSegment(0, 0, p.length, _.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const x = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, x), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(x), So(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context, p = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({ color: s.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, p.TRIANGLES, mr.disabled, Ar.disabled, si.unblended, nr.disabled, /* @__PURE__ */ ((_, x) => ({ u_input: _, u_output_expected: x }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && So(p)) {
              p.bindBuffer(p.PIXEL_PACK_BUFFER, this._pbo), p.readBuffer(p.COLOR_ATTACHMENT0), p.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), p.bindBuffer(p.PIXEL_PACK_BUFFER, null);
              const _ = p.fenceSync(p.SYNC_GPU_COMMANDS_COMPLETE, 0);
              p.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: _ };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && So(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ko._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128;
          }
        }
        const Vl = s.$ / 128;
        function pc(v, e) {
          const a = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, c = a + (v.generateBorders ? 2 : 0), p = a + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), _ = c + 1, x = p + 1, k = v.generateBorders ? -1 : 0, P = v.generateBorders || v.extendToNorthPole ? -1 : 0, R = a + (v.generateBorders ? 1 : 0), D = a + (v.generateBorders || v.extendToSouthPole ? 1 : 0), j = _ * x, $ = c * p * 6, V = _ * x > 65536;
          if (V && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const W = V || e === "32bit", le = new Int16Array(2 * j);
          let se = 0;
          for (let we = P; we <= D; we++) for (let ye = k; ye <= R; ye++) {
            let ke = ye / a * s.$;
            ye === -1 && (ke = -Vl), ye === a + 1 && (ke = s.$ + Vl);
            let Me = we / a * s.$;
            we === -1 && (Me = v.extendToNorthPole ? s.bh : -Vl), we === a + 1 && (Me = v.extendToSouthPole ? s.bi : s.$ + Vl), le[se++] = ke, le[se++] = Me;
          }
          const ce = W ? new Uint32Array($) : new Uint16Array($);
          let me = 0;
          for (let we = 0; we < p; we++) for (let ye = 0; ye < c; ye++) {
            const ke = ye + 1 + we * _, Me = ye + (we + 1) * _, be = ye + 1 + (we + 1) * _;
            ce[me++] = ye + we * _, ce[me++] = Me, ce[me++] = ke, ce[me++] = ke, ce[me++] = Me, ce[me++] = be;
          }
          return { vertices: le.buffer.slice(0), indices: ce.buffer.slice(0), uses32bitIndices: W };
        }
        const Qa = new s.aK({ fill: new s.bj(128, 2), line: new s.bj(512, 0), tile: new s.bj(128, 32), stencil: new s.bj(128, 1), circle: 3 });
        class js {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Dn.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Dn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Qa;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new ko(e));
            const a = s.U(this._errorQueryLatitudeDegrees), c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - 0.5 * Math.PI, p = this._errorMeasurement.updateErrorLoop(a, c), _ = L.now();
            p !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = p, this._errorMeasurementLastChangeTime = _);
            const x = Math.min(Math.max((_ - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = s.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bl(x));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, a, c, p, _) {
            const x = (_ === "stencil" ? Qa.stencil : Qa.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, { granularity: x, generateBorders: c, extendToNorthPole: a.y === 0 && p, extendToSouthPole: a.y === (1 << a.z) - 1 && p });
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const p = (function(_, x) {
              const k = pc(x, "16bit"), P = s.aL.deserialize({ arrayBuffer: k.vertices, length: k.vertices.byteLength / 2 / 2 }), R = s.aN.deserialize({ arrayBuffer: k.indices, length: k.indices.byteLength / 2 / 3 });
              return new Lo(_.createVertexBuffer(P, Co.members), _.createIndexBuffer(R), s.aM.simpleSegment(0, 0, P.length, R.length));
            })(e, a);
            return this._tileMeshCache[c] = p, p;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = L.now();
            let a = false;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Ul = new s.r({ type: new s.D(s.v.projection.type) });
        class Gl extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(Ul), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0)), this._mercatorProjection = new xr(), this._verticalPerspectiveProjection = new js();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, a, c, p, _) {
            return this.currentProjection.getMeshFromTileID(e, a, c, p, _);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function ql(v) {
          const e = es(v.worldSize, v.center.lat);
          return 2 * Math.PI * e;
        }
        function eo(v, e, a, c, p) {
          const _ = 1 / (1 << p), x = e / s.$ * _ + c * _, k = s.bo((v / s.$ * _ + a * _) * Math.PI * 2 + Math.PI, 2 * Math.PI), P = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(P), D = new Float64Array(3);
          return D[0] = Math.sin(k) * R, D[1] = Math.sin(P), D[2] = Math.cos(k) * R, D;
        }
        function ji(v) {
          return (function(e, a) {
            const c = Math.cos(a), p = new Float64Array(3);
            return p[0] = Math.sin(e) * c, p[1] = Math.sin(a), p[2] = Math.cos(e) * c, p;
          })(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function es(v, e) {
          return v / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Ns(v) {
          const e = Math.asin(v[1]) / Math.PI * 180, a = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (a > 1e-6) {
            const c = v[0] / a, p = Math.acos(v[2] / a), _ = (c > 0 ? p : -p) / Math.PI * 180;
            return new s.S(s.aO(_, -180, 180), e);
          }
          return new s.S(0, e);
        }
        function Pa(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function yi(v, e) {
          const a = Pa(v), c = Pa(e);
          return s.ak(c / a);
        }
        function ah(v, e) {
          const a = v.rotate(e.bearingInRadians), c = e.zoom + yi(e.center.lat, 0), p = s.bk(1 / Pa(e.center.lat), 1 / Pa(Math.min(Math.abs(e.center.lat), 60)), s.bn(c, 7, 3, 0, 1)), _ = 360 / ql({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new s.S(e.center.lng - a.x * _ * p, s.ah(e.center.lat + a.y * _, -s.ai, s.ai));
        }
        function Vs(v) {
          const e = 0.5 * v, a = Math.sin(e), c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a);
        }
        function mc(v, e, a, c) {
          const p = v.lat + a * c;
          if (Math.abs(a) > 1) {
            const _ = (Math.sign(v.lat + a) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, x = Math.abs(v.lat + a) * Math.PI / 180, k = Vs(_ + c * (x - _)), P = Vs(_), R = Vs(x);
            return new s.S(v.lng + e * ((k - P) / (R - P)), p);
          }
          return new s.S(v.lng + e * c, p);
        }
        class mp {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e, a, c, p) {
            const _ = `${e.z}_${e.x}_${e.y}_${(p == null ? void 0 : p.terrain) ? "t" : ""}`, x = this._cache.get(_);
            if (x) return x;
            const k = this._cachePrevious.get(_);
            if (k) return this._cache.set(_, k), k;
            const P = this._boundingVolumeFactory(e, a, c, p);
            return this._cache.set(_, P), this._hadAnyChanges = true, P;
          }
        }
        class ts {
          constructor(e, a, c, p) {
            this.min = c, this.max = p, this.points = e, this.planes = a;
          }
          static fromAabb(e, a) {
            const c = [];
            for (let p = 0; p < 8; p++) c.push([1 & ~p ? e[0] : a[0], (p >> 1 & 1) == 1 ? a[1] : e[1], (p >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new ts(c, [[-1, 0, 0, a[0]], [1, 0, 0, -e[0]], [0, -1, 0, a[1]], [0, 1, 0, -e[1]], [0, 0, -1, a[2]], [0, 0, 1, -e[2]]], e, a);
          }
          static fromCenterSizeAngles(e, a, c) {
            const p = s.br([], c[0], c[1], c[2]), _ = s.bs([], [a[0], 0, 0], p), x = s.bs([], [0, a[1], 0], p), k = s.bs([], [0, 0, a[2]], p), P = [...e], R = [...e];
            for (let j = 0; j < 8; j++) for (let $ = 0; $ < 3; $++) {
              const V = e[$] + _[$] * (1 & ~j ? -1 : 1) + x[$] * ((j >> 1 & 1) == 1 ? 1 : -1) + k[$] * ((j >> 2 & 1) == 1 ? 1 : -1);
              P[$] = Math.min(P[$], V), R[$] = Math.max(R[$], V);
            }
            const D = [];
            for (let j = 0; j < 8; j++) {
              const $ = [...e];
              s.aS($, $, s.aR([], _, 1 & ~j ? -1 : 1)), s.aS($, $, s.aR([], x, (j >> 1 & 1) == 1 ? 1 : -1)), s.aS($, $, s.aR([], k, (j >> 2 & 1) == 1 ? 1 : -1)), D.push($);
            }
            return new ts(D, [[..._, -s.aX(_, D[0])], [...x, -s.aX(x, D[0])], [...k, -s.aX(k, D[0])], [-_[0], -_[1], -_[2], -s.aX(_, D[7])], [-x[0], -x[1], -x[2], -s.aX(x, D[7])], [-k[0], -k[1], -k[2], -s.aX(k, D[7])]], P, R);
          }
          intersectsFrustum(e) {
            let a = true;
            const c = this.points.length, p = this.planes.length, _ = e.planes.length, x = e.points.length;
            for (let k = 0; k < _; k++) {
              const P = e.planes[k];
              let R = 0;
              for (let D = 0; D < c; D++) {
                const j = this.points[D];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < c && (a = false);
            }
            if (a) return 2;
            for (let k = 0; k < p; k++) {
              const P = this.planes[k];
              let R = 0;
              for (let D = 0; D < x; D++) {
                const j = e.points[D];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let p = 0; p < a; p++) {
              const _ = this.points[p];
              e[0] * _[0] + e[1] * _[1] + e[2] * _[2] + e[3] >= 0 && c++;
            }
            return c === a ? 2 : c === 0 ? 0 : 1;
          }
        }
        function Hi(v, e, a) {
          const c = v - e;
          return c < 0 ? -c : Math.max(0, c - a);
        }
        function Us(v, e, a, c, p) {
          const _ = v - a;
          let x;
          return x = _ < 0 ? Math.min(-_, 1 + _ - p) : _ > 1 ? Math.min(Math.max(_ - p, 0), 1 - _) : 0, Math.max(x, Hi(e, c, p));
        }
        class Po {
          constructor() {
            this._boundingVolumeCache = new mp(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, a, c, p) {
            const _ = 1 << c.z, x = 1 / _, k = c.x / _, P = c.y / _;
            let R = 2;
            return R = Math.min(R, Us(e, a, k, P, x)), R = Math.min(R, Us(e, a, k + 0.5, -P - x, x)), R = Math.min(R, Us(e, a, k + 0.5, 2 - P - x, x)), R;
          }
          getWrap(e, a, c) {
            const p = 1 << a.z, _ = 1 / p, x = a.x / p, k = Hi(e.x, x, _), P = Hi(e.x, x - 1, _), R = Hi(e.x, x + 1, _), D = Math.min(k, P, R);
            return D === R ? 1 : D === P ? -1 : 0;
          }
          allowVariableZoom(e, a) {
            return wt(e, a) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e, a, c, p) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, p);
          }
          _computeTileBoundingVolume(e, a, c, p) {
            var _, x;
            let k = 0, P = 0;
            if (p == null ? void 0 : p.terrain) {
              const R = new s.Z(e.z, a, e.z, e.x, e.y), D = p.terrain.getMinMaxElevation(R);
              k = (_ = D.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), P = (x = D.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            if (k /= s.bu, P /= s.bu, k += 1, P += 1, e.z <= 0) return ts.fromAabb([-P, -P, -P], [P, P, P]);
            if (e.z === 1) return ts.fromAabb([e.x === 0 ? -P : 0, e.y === 0 ? 0 : -P, -P], [e.x === 0 ? 0 : P, e.y === 0 ? P : 0, P]);
            {
              const R = [eo(0, 0, e.x, e.y, e.z), eo(s.$, 0, e.x, e.y, e.z), eo(s.$, s.$, e.x, e.y, e.z), eo(0, s.$, e.x, e.y, e.z)], D = [];
              for (const Ze of R) D.push(s.aR([], Ze, P));
              if (P !== k) for (const Ze of R) D.push(s.aR([], Ze, k));
              e.y === 0 && D.push([0, 1, 0]), e.y === (1 << e.z) - 1 && D.push([0, -1, 0]);
              const j = [1, 1, 1], $ = [-1, -1, -1];
              for (const Ze of D) for (let Je = 0; Je < 3; Je++) j[Je] = Math.min(j[Je], Ze[Je]), $[Je] = Math.max($[Je], Ze[Je]);
              const V = eo(s.$ / 2, s.$ / 2, e.x, e.y, e.z), W = s.aW([], [0, 1, 0], V);
              s.aV(W, W);
              const le = s.aW([], V, W);
              s.aV(le, le);
              const se = s.aW([], R[2], R[1]);
              s.aV(se, se);
              const ce = s.aW([], R[0], R[3]);
              s.aV(ce, ce), D.push(s.aR([], V, P)), e.y >= (1 << e.z) / 2 && D.push(s.aR([], eo(s.$ / 2, 0, e.x, e.y, e.z), P)), e.y < (1 << e.z) / 2 && D.push(s.aR([], eo(s.$ / 2, s.$, e.x, e.y, e.z), P));
              const me = Gs(V, D), we = Gs(le, D), ye = [-V[0], -V[1], -V[2], me.max], ke = [V[0], V[1], V[2], -me.min], Me = [-le[0], -le[1], -le[2], we.max], be = [le[0], le[1], le[2], -we.min], Oe = [...se, 0], Qe = [...ce, 0], We = [];
              return e.y === 0 ? We.push(s.bt(Qe, Oe, ye), s.bt(Qe, Oe, ke)) : We.push(s.bt(Me, Oe, ye), s.bt(Me, Oe, ke), s.bt(Me, Qe, ye), s.bt(Me, Qe, ke)), e.y === (1 << e.z) - 1 ? We.push(s.bt(Qe, Oe, ye), s.bt(Qe, Oe, ke)) : We.push(s.bt(be, Oe, ye), s.bt(be, Oe, ke), s.bt(be, Qe, ye), s.bt(be, Qe, ke)), new ts(We, [ye, ke, Me, be, Oe, Qe], j, $);
            }
          }
        }
        function Gs(v, e) {
          let a = 1 / 0, c = -1 / 0;
          for (const p of e) {
            const _ = s.aX(v, p);
            a = Math.min(a, _), c = Math.max(c, _);
          }
          return { min: a, max: c };
        }
        class qs {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a) {
            this._helper.resize(e, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = s.bv(), this._projectionMatrix = s.b9(), this._globeViewProjMatrix32f = s.b8(), this._globeViewProjMatrixNoCorrection = s.b9(), this._globeViewProjMatrixNoCorrectionInverted = s.b9(), this._globeProjMatrixInverted = s.b9(), this._cameraPosition = s.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new fn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._coveringTilesDetailsProvider = new Po();
          }
          clone() {
            const e = new qs();
            return e.apply(this), e;
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = s.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: a, applyGlobeMatrix: c } = e, p = this._helper.getMercatorTileCoordinates(a);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: p, clippingPlane: this._cachedClippingPlane, projectionTransition: c ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians, c = this.cameraToCenterDistance / e, p = Math.sin(a) * c, _ = Math.cos(a) * c + 1, x = 1 / Math.sqrt(p * p + _ * _) * 1;
            let k = -p, P = _;
            const R = Math.sqrt(k * k + P * P);
            k /= R, P /= R;
            const D = [0, k, P];
            s.bw(D, D, [0, 0, 0], -this.bearingInRadians), s.bx(D, D, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.by(D, D, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / s.aZ(D);
            return s.aR(D, D, j), [...D, -x * j];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ji(e));
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180, c = this._helper._center.lat * Math.PI / 180, p = Math.cos(c), _ = [Math.sin(a) * p, Math.sin(c), Math.cos(a) * p], x = [_[2], 0, -_[0]], k = [0, 0, 0];
            s.aW(k, x, _), s.aV(x, x), s.aV(k, k);
            const P = [0, 0, 0];
            return s.aV(P, [x[0] * e[0] + k[0] * e[1] + _[0] * e[2], x[1] * e[0] + k[1] * e[1] + _[1] * e[2], x[2] * e[0] + k[2] * e[1] + _[2] * e[2]]), P;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = (function(k, P, R) {
              const D = 1 / (1 << R.z);
              return new s.a1(k / s.$ * D + R.x * D, P / s.$ * D + R.y * D);
            })(e, a, c.canonical), _ = (x = p.y, [s.bo(p.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(_[1]);
          }
          projectTileCoordinates(e, a, c, p) {
            const _ = c.canonical, x = eo(e, a, _.x, _.y, _.z), k = 1 + (p ? p(e, a) : 0) / s.bu, P = [x[0] * k, x[1] * k, x[2] * k, 1];
            s.aw(P, P, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, D = R[0] * x[0] + R[1] * x[1] + R[2] * x[2] + R[3] < 0;
            return { point: new s.P(P[0] / P[3], P[1] / P[3]), signedDistanceFromCamera: P[3], isOccluded: D };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = es(this.worldSize, this.center.lat), a = s.ba(), c = s.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b4(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const p = this.centerOffset;
            a[8] = 2 * -p.x / this._helper._width, a[9] = 2 * p.y / this._helper._height, this._projectionMatrix = s.b5(a), this._globeProjMatrixInverted = s.ba(), s.aq(this._globeProjMatrixInverted, a), s.M(a, a, [0, 0, -this.cameraToCenterDistance]), s.b6(a, a, this.rollInRadians), s.b7(a, a, -this.pitchInRadians), s.b6(a, a, this.bearingInRadians), s.M(a, a, [0, 0, -e]);
            const _ = s.bp();
            _[0] = e, _[1] = e, _[2] = e, s.b7(c, a, this.center.lat * Math.PI / 180), s.bz(c, c, -this.center.lng * Math.PI / 180), s.N(c, c, _), this._globeViewProjMatrixNoCorrection = c, s.b7(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bz(a, a, -this.center.lng * Math.PI / 180), s.N(a, a, _), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.ba(), s.aq(this._globeViewProjMatrixNoCorrectionInverted, c);
            const x = s.bp();
            this._cameraPosition = s.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bw(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), s.bx(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), s.bw(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), s.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bx(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), s.by(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const k = s.b5(this._globeViewProjMatrixNoCorrectionInverted);
            s.N(k, k, [1, 1, -1]), this._cachedFrustum = Pi.fromInvProjectionMatrix(k, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.ba();
            return s.ag(a), a;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = ji(e);
            s.aR(c, c, 1 + a / s.bu);
            const p = s.bv();
            return s.aw(p, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), p[2] / p[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, a = 0.5 * this.height, c = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)], p = [];
            for (const j of c) p.push(this.unprojectScreenPoint(j));
            let _ = 0, x = 0, k = 0, P = 0;
            const R = this.center;
            for (const j of p) {
              const $ = s.bA(R.lng, j.lng), V = s.bA(R.lat, j.lat);
              $ < x && (x = $), $ > _ && (_ = $), V < P && (P = V), V > k && (k = V);
            }
            const D = [R.lng + x, R.lat + P, R.lng + _, R.lat + k];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (D[3] = 90, D[0] = -180, D[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (D[1] = -90, D[0] = -180, D[2] = 180), new sr(D);
          }
          getConstrained(e, a) {
            const c = s.ah(e.lat, -s.ai, s.ai), p = s.ah(+a, this.minZoom + yi(0, c), this.maxZoom);
            return { center: new s.S(e.lng, c), zoom: p };
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            const c = ji(this.unprojectScreenPoint(a)), p = ji(e), _ = s.bp();
            s.bB(_);
            const x = s.bp();
            s.by(x, c, _, -this.center.lng * Math.PI / 180), s.bx(x, x, _, this.center.lat * Math.PI / 180);
            const k = p[0] * p[0] + p[2] * p[2], P = x[0] * x[0];
            if (k < P) return;
            const R = Math.sqrt(k - P), D = -R, j = s.bC(p[0], p[2], x[0], R), $ = s.bC(p[0], p[2], x[0], D), V = s.bp();
            s.by(V, p, _, -j);
            const W = s.bC(V[1], V[2], x[1], x[2]), le = s.bp();
            s.by(le, p, _, -$);
            const se = s.bC(le[1], le[2], x[1], x[2]), ce = 0.5 * Math.PI, me = W >= -ce && W <= ce, we = se >= -ce && se <= ce;
            let ye, ke;
            if (me && we) {
              const Qe = this.center.lng * Math.PI / 180, We = this.center.lat * Math.PI / 180;
              s.bD(j, Qe) + s.bD(W, We) < s.bD($, Qe) + s.bD(se, We) ? (ye = j, ke = W) : (ye = $, ke = se);
            } else if (me) ye = j, ke = W;
            else {
              if (!we) return;
              ye = $, ke = se;
            }
            const Me = ye / Math.PI * 180, be = ke / Math.PI * 180, Oe = this.center.lat;
            this.setCenter(new s.S(Me, s.ah(be, -90, 90))), this.setZoom(this.zoom + yi(Oe, this.center.lat));
          }
          locationToScreenPoint(e, a) {
            const c = ji(e);
            if (a) {
              const p = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aR(c, c, 1 + p / s.bu);
            }
            return this._projectSurfacePointToScreen(c);
          }
          _projectSurfacePointToScreen(e) {
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((0.5 * a[0] + 0.5) * this.width, (0.5 * -a[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c;
            }
            return s.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition, p = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, p);
          }
          getRayDirectionFromPixel(e) {
            const a = s.bv();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aw(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = s.bp();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const p = s.bp();
            return s.aV(p, c), p;
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return false;
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1;
          }
          rayPlanetIntersection(e, a) {
            const c = s.aX(e, a), p = s.bp(), _ = s.bp();
            s.aR(_, a, c), s.aU(p, e, _);
            const x = 1 - s.aX(p, p);
            if (x < 0) return null;
            const k = s.aX(e, e) - 1, P = -c + (c < 0 ? 1 : -1) * Math.sqrt(x), R = k / P, D = P;
            return { tMin: Math.min(R, D), tMax: Math.max(R, D) };
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition, c = this.getRayDirectionFromPixel(e), p = this.rayPlanetIntersection(a, c);
            if (p) {
              const D = s.bp();
              s.aS(D, a, [c[0] * p.tMin, c[1] * p.tMin, c[2] * p.tMin]);
              const j = s.bp();
              return s.aV(j, D), Ns(j);
            }
            const _ = this._cachedClippingPlane, x = _[0] * c[0] + _[1] * c[1] + _[2] * c[2], k = -s.b1(_, a) / x, P = s.bp();
            if (k > 0) s.aS(P, a, [c[0] * k, c[1] * k, c[2] * k]);
            else {
              const D = s.bp();
              s.aS(D, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const j = s.b1(this._cachedClippingPlane, D);
              s.aU(P, D, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j]);
            }
            const R = (function(D) {
              const j = s.bp();
              return j[0] = D[0] * -D[3], j[1] = D[1] * -D[3], j[2] = D[2] * -D[3], { center: j, radius: Math.sqrt(1 - D[3] * D[3]) };
            })(_);
            return Ns((function(D, j, $) {
              const V = s.bp();
              s.aU(V, $, D);
              const W = s.bp();
              return s.bq(W, D, V, j / s.a$(V)), W;
            })(R.center, R.radius, P));
          }
          getMatrixForModel(e, a) {
            const c = s.S.convert(e), p = 1 / s.bu, _ = s.b9();
            return s.bz(_, _, c.lng / 180 * Math.PI), s.b7(_, _, -c.lat / 180 * Math.PI), s.M(_, _, [0, 0, 1 + a / s.bu]), s.b7(_, _, 0.5 * Math.PI), s.N(_, _, [p, p, p]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this.getProjectionData({ overscaledTileID: new s.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return a.tileMercatorCoords = [0, 0, 1, 1], a;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class Ws {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new fn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._globeness = 1, this._mercatorTransform = new ti(), this._verticalPerspectiveTransform = new qs();
          }
          clone() {
            const e = new Ws();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e), c = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix, clippingPlane: c.clippingPlane, tileMercatorCoords: c.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: a.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return s.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return s.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = this._mercatorTransform.getPitchedTextCorrection(e, a, c), _ = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return s.bk(p, _, this._globeness);
          }
          projectTileCoordinates(e, a, c, p) {
            return this.currentTransform.projectTileCoordinates(e, a, c, p);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, a) {
            return this.currentTransform.getConstrained(e, a);
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a);
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a);
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a);
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a);
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class on {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e, a) {
            const c = ah(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), { easingCenter: c, easingOffset: new s.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around, p = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const _ = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const x = a.zoom - _;
            if (x === 0) return;
            const k = s.bA(a.center.lng, p.lng), P = k / (Math.abs(k / 180) + 1), R = s.bA(a.center.lat, p.lat), D = a.getRayDirectionFromPixel(c), j = a.cameraPosition, $ = -1 * s.aX(j, D), V = s.bp();
            s.aS(V, j, [D[0] * $, D[1] * $, D[2] * $]);
            const W = s.aZ(V) - 1, le = Math.exp(0.5 * -Math.max(W - 0.3, 0)), se = es(a.worldSize, a.center.lat) / Math.min(a.width, a.height), ce = s.bn(se, 0.9, 0.5, 1, 0.25), me = (1 - s.af(-x)) * Math.min(le, ce), we = a.center.lat, ye = a.zoom, ke = new s.S(a.center.lng + P * me, s.ah(a.center.lat + R * me, -s.ai, s.ai));
            a.setLocationAtPoint(p, c);
            const Me = a.center, be = s.bn(Math.abs(k), 45, 85, 0, 1), Oe = s.bn(se, 0.75, 0.35, 0, 1), Qe = Math.pow(Math.max(be, Oe), 0.25), We = s.bA(Me.lng, ke.lng), Ze = s.bA(Me.lat, ke.lat);
            a.setCenter(new s.S(Me.lng + We * Qe, Me.lat + Ze * Qe).wrap()), a.setZoom(ye + yi(we, a.center.lat));
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const p = a.center.lat, _ = a.zoom;
            a.setCenter(ah(e.panDelta, a).wrap()), a.setZoom(_ + yi(p, a.center.lat));
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            const x = zn(e, a, c, p, _), k = a.left / _.width * 2 - 1, P = (_.width - a.right) / _.width * 2 - 1, R = a.top / _.height * -2 + 1, D = (_.height - a.bottom) / _.height * -2 + 1, j = s.bA(c.getWest(), c.getEast()) < 0, $ = j ? c.getEast() : c.getWest(), V = j ? c.getWest() : c.getEast(), W = Math.max(c.getNorth(), c.getSouth()), le = Math.min(c.getNorth(), c.getSouth()), se = $ + 0.5 * s.bA($, V), ce = W + 0.5 * s.bA(W, le), me = _.clone();
            me.setCenter(x.center), me.setBearing(x.bearing), me.setPitch(0), me.setRoll(0), me.setZoom(x.zoom);
            const we = me.modelViewProjectionMatrix, ye = [ji(c.getNorthWest()), ji(c.getNorthEast()), ji(c.getSouthWest()), ji(c.getSouthEast()), ji(new s.S(V, ce)), ji(new s.S($, ce)), ji(new s.S(se, W)), ji(new s.S(se, le))], ke = ji(x.center);
            let Me = Number.POSITIVE_INFINITY;
            for (const be of ye) k < 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(be, ke, we, "x", k))), P > 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(be, ke, we, "x", P))), R > 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(be, ke, we, "y", R))), D < 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(be, ke, we, "y", D)));
            if (Number.isFinite(Me) && Me !== 0) return x.zoom = me.zoom + s.ak(Me), x;
            oh();
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat, p = e.getConstrained(a.center ? s.S.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(p.wrap());
            const _ = a.zoom !== void 0 ? +a.zoom : e.zoom + yi(c, p.lat);
            e.zoom !== _ && e.setZoom(_);
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.center, _ = e.padding, x = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, k = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, P = a.zoom !== void 0, R = !e.isPaddingEqual(a.padding);
            let D = false;
            const j = a.center ? s.S.convert(a.center) : p, $ = e.getConstrained(j, c).center;
            jl(e, $);
            const V = e.clone();
            V.setCenter($), V.setZoom(P ? +a.zoom : c + yi(p.lat, j.lat)), V.setBearing(a.bearing);
            const W = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            V.setLocationAtPoint($, W);
            const le = (a.offset && a.offsetAsPoint.mag()) > 0 ? V.center : $, se = P ? +a.zoom : c + yi(p.lat, le.lat), ce = c + yi(p.lat, 0), me = se + yi(le.lat, 0), we = s.bA(p.lng, le.lng), ye = s.bA(p.lat, le.lat), ke = s.af(me - ce);
            return D = se !== c, { easeFunc: (Me) => {
              if (s.be(x, k) || mn({ startEulerAngles: x, endEulerAngles: k, tr: e, k: Me, useSlerp: x.roll != k.roll }), R && e.interpolatePadding(_, a.padding, Me), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const be = me > ce ? Math.min(2, ke) : Math.max(0.5, ke), Oe = Math.pow(be, 1 - Me), Qe = mc(p, we, ye, Me * Oe);
                e.setCenter(Qe.wrap());
              }
              if (D) {
                const be = s.C.number(ce, me, Me) + yi(0, e.center.lat);
                e.setZoom(be);
              }
            }, isZooming: D, elevationCenter: le };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.center, _ = e.zoom, x = e.padding, k = !e.isPaddingEqual(a.padding), P = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), _).center, R = c ? +a.zoom : e.zoom + yi(e.center.lat, P.lat), D = e.clone();
            D.setCenter(P), D.setZoom(R), D.setBearing(a.bearing);
            const j = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            D.setLocationAtPoint(P, j);
            const $ = D.center;
            jl(e, $);
            const V = (function(ye, ke, Me) {
              const be = ji(ke), Oe = ji(Me), Qe = s.aX(be, Oe), We = Math.acos(Qe), Ze = ql(ye);
              return We / (2 * Math.PI) * Ze;
            })(e, p, $), W = _ + yi(p.lat, 0), le = R + yi($.lat, 0), se = s.af(le - W);
            let ce;
            if (typeof a.minZoom == "number") {
              const ye = +a.minZoom + yi($.lat, 0), ke = Math.min(ye, W, le) + yi(0, $.lat), Me = e.getConstrained($, ke).zoom + yi($.lat, 0);
              ce = s.af(Me - W);
            }
            const me = s.bA(p.lng, $.lng), we = s.bA(p.lat, $.lat);
            return { easeFunc: (ye, ke, Me, be) => {
              const Oe = mc(p, me, we, Me);
              k && e.interpolatePadding(x, a.padding, ye);
              const Qe = ye === 1 ? $ : Oe;
              e.setCenter(Qe.wrap());
              const We = W + s.ak(ke);
              e.setZoom(ye === 1 ? R : We + yi(0, Qe.lat));
            }, scaleOfZoom: se, targetCenter: $, scaleOfMinZoom: ce, pixelPathLength: V };
          }
          static solveVectorScale(e, a, c, p, _) {
            const x = p === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]], k = [c[3], c[7], c[11], c[15]], P = e[0] * x[0] + e[1] * x[1] + e[2] * x[2], R = e[0] * k[0] + e[1] * k[1] + e[2] * k[2], D = a[0] * x[0] + a[1] * x[1] + a[2] * x[2], j = a[0] * k[0] + a[1] * k[1] + a[2] * k[2];
            return D + _ * R === P + _ * j || k[3] * (P - D) + x[3] * (j - R) + P * j == D * R ? null : (D + x[3] - _ * j - _ * k[3]) / (D - P - _ * j + _ * R);
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e;
          }
        }
        class sh {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new nn(), this._verticalPerspectiveCameraHelper = new on();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a);
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a);
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c);
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, p, _);
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a);
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a);
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a);
          }
        }
        const Wl = (v, e) => s.y(v, e && e.filter(((a) => a.identifier !== "source.canvas"))), gp = s.bE();
        class gc extends s.E {
          constructor(e, a = {}) {
            var c, p;
            super(), this._rtlPluginLoaded = () => {
              for (const x in this.sourceCaches) {
                const k = this.sourceCaches[x].getSource().type;
                k !== "vector" && k !== "geojson" || this.sourceCaches[x].reload();
              }
            }, this.map = e, this.dispatcher = new zt(Ht(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((x, k) => this.getGlyphs(x, k))), this.dispatcher.registerMessageHandler("GI", ((x, k) => this.getImages(x, k))), this.imageManager = new oe(), this.imageManager.setEventedParent(this);
            const _ = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((p = document.documentElement) === null || p === void 0 ? void 0 : p.lang) || void 0;
            this.glyphManager = new Ve(e._requestManager, a.localIdeographFontFamily, _), this.lineAtlas = new et(256, 512), this.crossTileSymbolIndex = new na(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.bF(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bG()), ii().on(tt, this._rtlPluginLoaded), this.on("data", ((x) => {
              if (x.dataType !== "source" || x.sourceDataType !== "metadata") return;
              const k = this.sourceCaches[x.sourceId];
              if (!k) return;
              const P = k.getSource();
              if (P && P.vectorLayerIds) for (const R in this._layers) {
                const D = this._layers[R];
                D.source === P.id && this._validateLayer(D);
              }
            }));
          }
          setGlobalStateProperty(e, a) {
            var c, p, _;
            this._checkLoaded();
            const x = a === null ? (_ = (p = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || p === void 0 ? void 0 : p.default) !== null && _ !== void 0 ? _ : null : a;
            if (s.bH(x, this._globalState[e])) return this;
            this._globalState[e] = x, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !s.bH(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = /* @__PURE__ */ new Set();
            for (const c in this._layers) {
              const p = this._layers[c], _ = p.getLayoutAffectingGlobalStateRefs(), x = p.getPaintAffectingGlobalStateRefs();
              for (const k of e) if (_.has(k) && a.add(p.source), x.has(k)) for (const { name: P, value: R } of x.get(k)) this._updatePaintProperty(p, P, R);
            }
            for (const c in this.sourceCaches) a.has(c) && (this._reloadSource(c), this._changed = true);
          }
          loadURL(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), a.validate = typeof a.validate != "boolean" || a.validate;
            const p = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const _ = this._loadStyleRequest;
            s.j(p, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, a, c);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !_.signal.aborted && this.fire(new s.k(x));
            }));
          }
          loadJSON(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), L.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== false, this._load(e, a, c);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._load(gp, { validate: false });
          }
          _load(e, a, c) {
            var p, _;
            let x = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !Wl(this, s.z(x))) {
              x = Object.assign({}, x), this._loaded = true, this.stylesheet = x;
              for (const k in x.sources) this.addSource(k, x.sources[k], { validate: false });
              x.sprite ? this._loadSprite(x.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(x.glyphs), this._createLayers(), this.light = new vt(this.stylesheet.light), this._setProjectionInternal(((p = this.stylesheet.projection) === null || p === void 0 ? void 0 : p.type) || "mercator"), this.sky = new at(this.stylesheet.sky), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.fire(new s.l("data", { dataType: "style" })), this.fire(new s.l("style.load"));
            }
          }
          _createLayers() {
            var e;
            const a = s.bI(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", a), this._order = a.map(((c) => c.id)), this._layers = {}, this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this._serializedLayers = null;
            for (const c of a) {
              const p = s.bJ(c);
              p.setEventedParent(this, { layer: { id: c.id } }), p.setGlobalState(this._globalState), this._layers[c.id] = p;
            }
          }
          _loadSprite(e, a = false, c = void 0) {
            let p;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(_, x, k, P) {
              return s._(this, void 0, void 0, (function* () {
                const R = J(_), D = k > 1 ? "@2x" : "", j = {}, $ = {};
                for (const { id: V, url: W } of R) {
                  const le = x.transformRequest(Se(W, D, ".json"), "SpriteJSON");
                  j[V] = s.j(le, P);
                  const se = x.transformRequest(Se(W, D, ".png"), "SpriteImage");
                  $[V] = te.getImage(se, P);
                }
                return yield Promise.all([...Object.values(j), ...Object.values($)]), (function(V, W) {
                  return s._(this, void 0, void 0, (function* () {
                    const le = {};
                    for (const se in V) {
                      le[se] = {};
                      const ce = L.getImageCanvasContext((yield W[se]).data), me = (yield V[se]).data;
                      for (const we in me) {
                        const { width: ye, height: ke, x: Me, y: be, sdf: Oe, pixelRatio: Qe, stretchX: We, stretchY: Ze, content: Je, textFitWidth: kt, textFitHeight: Tt } = me[we];
                        le[se][we] = { data: null, pixelRatio: Qe, sdf: Oe, stretchX: We, stretchY: Ze, content: Je, textFitWidth: kt, textFitHeight: Tt, spriteData: { width: ye, height: ke, x: Me, y: be, context: ce } };
                      }
                    }
                    return le;
                  }));
                })(j, $);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((_) => {
              if (this._spriteRequest = null, _) for (const x in _) {
                this._spritesImagesIds[x] = [];
                const k = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((P) => !(P in _))) : [];
                for (const P of k) this.imageManager.removeImage(P), this._changedImages[P] = true;
                for (const P in _[x]) {
                  const R = x === "default" ? P : `${x}:${P}`;
                  this._spritesImagesIds[x].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, _[x][P], false) : this.imageManager.addImage(R, _[x][P]), a && (this._changedImages[R] = true);
                }
              }
            })).catch(((_) => {
              this._spriteRequest = null, p = _, this.fire(new s.k(p));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), a && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" })), c && c(p);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const a = this.sourceCaches[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const p = a.getSource();
            (p.type === "geojson" || p.vectorLayerIds && p.vectorLayerIds.indexOf(c) === -1) && this.fire(new s.k(new Error(`Source layer "${c}" does not exist on source "${p.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, a = false) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bK(c) : c);
            const p = [];
            for (const _ of e) if (c[_]) {
              const x = a ? s.bK(c[_]) : c[_];
              p.push(x);
            }
            return p;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const p = this._layers[c];
              p.type !== "custom" && (e[c] = p.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return true;
            for (const p in this.sourceCaches) if (this.sourceCaches[p].hasTransition()) return true;
            for (const p in this._layers) if (this._layers[p].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const p = Object.keys(this._updatedLayers), _ = Object.keys(this._removedLayers);
              (p.length || _.length) && this._updateWorkerLayers(p, _);
              for (const x in this._updatedSources) {
                const k = this._updatedSources[x];
                if (k === "reload") this._reloadSource(x);
                else {
                  if (k !== "clear") throw new Error(`Invalid action ${k}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const c = {};
            for (const p in this.sourceCaches) {
              const _ = this.sourceCaches[p];
              c[p] = _.used, _.used = false;
            }
            for (const p of this._order) {
              const _ = this._layers[p];
              _.recalculate(e, this._availableImages), !_.isHidden(e.zoom) && _.source && (this.sourceCaches[_.source].used = true);
            }
            for (const p in c) {
              const _ = this.sourceCaches[p];
              !!c[p] != !!_.used && _.fire(new s.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: p }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, false), removedIds: a });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const p = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(p, e) : e, ((c = a.validate) === null || c === void 0 || c) && Wl(this, s.z(e))) return false;
            (e = s.bK(e)).layers = s.bI(e.layers);
            const _ = s.bL(p, e), x = this._getOperationsToPerform(_);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return false;
            for (const k of x.operations) k();
            return this.stylesheet = e, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e) {
            const a = [], c = [];
            for (const p of e) switch (p.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, p.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, p.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, p.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, p.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, p.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, p.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, p.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, p.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, p.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, p.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, p.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, p.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, p.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, p.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, p.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, p.args)));
                break;
              case "setTransition":
                a.push((() => {
                }));
                break;
              default:
                c.push(p.command);
            }
            return { operations: a, unimplemented: c };
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e);
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.z.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = true);
            const p = this.sourceCaches[e] = new Qt(e, a, this.dispatcher);
            p.style = this, p.setEventedParent(this, (() => ({ isSourceLoaded: p.loaded(), source: p.serialize(), sourceId: e }))), p.onAdd(this.map), this._changed = true;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers) if (this._layers[c].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], a.fire(new s.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), a.setEventedParent(null), a.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.sourceCaches[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = true;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const p = e.id;
            if (this.getLayer(p)) return void this.fire(new s.k(new Error(`Layer "${p}" already exists on this map.`)));
            let _;
            if (e.type === "custom") {
              if (Wl(this, s.bM(e))) return;
              _ = s.bJ(e);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(p, e.source), e = s.bK(e), e = s.e(e, { source: p })), this._validate(s.z.layer, `layers.${p}`, e, { arrayIndex: -1 }, c)) return;
              _ = s.bJ(e), this._validateLayer(_), _.setEventedParent(this, { layer: { id: p } });
            }
            const x = a ? this._order.indexOf(a) : this._order.length;
            if (a && x === -1) this.fire(new s.k(new Error(`Cannot add layer "${p}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(x, 0, p), this._layerOrderChanged = true, this._layers[p] = _, this._removedLayers[p] && _.source && _.type !== "custom") {
                const k = this._removedLayers[p];
                delete this._removedLayers[p], k.type !== _.type ? this._updatedSources[_.source] = "clear" : (this._updatedSources[_.source] = "reload", this.sourceCaches[_.source].pause());
              }
              this._updateLayer(_), _.onAdd && _.onAdd(this.map);
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const p = a ? this._order.indexOf(a) : this._order.length;
            a && p === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(p, 0, e), this._layerOrderChanged = true);
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? p.minzoom === a && p.maxzoom === c || (a != null && (p.minzoom = a), c != null && (p.maxzoom = c), this._updateLayer(p)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            if (p) {
              if (!s.bH(p.filter, a)) return a == null ? (p.setFilter(void 0), void this._updateLayer(p)) : void (this._validate(s.z.filter, `layers.${p.id}.filter`, a, null, c) || (p.setFilter(s.bK(a)), this._updateLayer(p)));
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return s.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bH(_.getLayoutProperty(a), c) || (_.setLayoutProperty(a, c, p), this._updateLayer(_)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bH(_.getPaintProperty(a), c) || this._updatePaintProperty(_, a, c, p) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, a, c, p = {}) {
            e.setPaintProperty(a, c, p) && this._updateLayer(e), this._changed = true, this._updatedPaintProps[e.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a);
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = e.sourceLayer, _ = this.sourceCaches[c];
            if (_ === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const x = _.getSource().type;
            x === "geojson" && p ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || p ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), _.setFeatureState(p, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = this.sourceCaches[c];
            if (p === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const _ = p.getSource().type, x = _ === "vector" ? e.sourceLayer : void 0;
            _ !== "vector" || x ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : p.removeFeatureState(x, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source, c = e.sourceLayer, p = this.sourceCaches[a];
            if (p !== void 0) return p.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), p.getFeatureState(c, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)));
          }
          getTransition() {
            return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bN(this.sourceCaches, ((_) => _.serialize())), a = this._serializeByIds(this._order, true), c = this.map.getTerrain() || void 0, p = this.stylesheet;
            return s.bO({ version: p.version, name: p.name, metadata: p.metadata, light: p.light, sky: p.sky, center: p.center, zoom: p.zoom, bearing: p.bearing, pitch: p.pitch, sprite: p.sprite, glyphs: p.glyphs, transition: p.transition, projection: p.projection, sources: e, layers: a, terrain: c }, ((_) => _ !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = true, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = (x) => this._layers[x].type === "fill-extrusion", c = {}, p = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) {
                c[k] = x;
                for (const P of e) {
                  const R = P[k];
                  if (R) for (const D of R) p.push(D);
                }
              }
            }
            p.sort(((x, k) => k.intersectionZ - x.intersectionZ));
            const _ = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) for (let P = p.length - 1; P >= 0; P--) {
                const R = p[P].feature;
                if (c[R.layer.id] < x) break;
                _.push(R), p.pop();
              }
              else for (const P of e) {
                const R = P[k];
                if (R) for (const D of R) _.push(D.feature);
              }
            }
            return _;
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(s.z.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const p = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of a.layers) {
                const D = this._layers[R];
                if (!D) return this.fire(new s.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                p[D.source] = true;
              }
            }
            const _ = [];
            a.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), k = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null, P = Object.assign(Object.assign({}, a), { layers: k });
            for (const R in this.sourceCaches) a.layers && !p[R] || _.push(tr(this.sourceCaches[R], this._layers, x, e, P, c, this.map.terrain ? (D, j, $) => this.map.terrain.getElevation(D, j, $) : void 0));
            return this.placement && _.push((function(R, D, j, $, V, W, le) {
              const se = {}, ce = W.queryRenderedSymbols($), me = [];
              for (const we of Object.keys(ce).map(Number)) me.push(le[we]);
              me.sort(wr);
              for (const we of me) {
                const ye = we.featureIndex.lookupSymbolFeatures(ce[we.bucketInstanceId], D, we.bucketIndex, we.sourceLayerIndex, V.filter, V.layers, V.availableImages, R);
                for (const ke in ye) {
                  const Me = se[ke] = se[ke] || [], be = ye[ke];
                  be.sort(((Oe, Qe) => {
                    const We = we.featureSortOrder;
                    if (We) {
                      const Ze = We.indexOf(Oe.featureIndex);
                      return We.indexOf(Qe.featureIndex) - Ze;
                    }
                    return Qe.featureIndex - Oe.featureIndex;
                  }));
                  for (const Oe of be) Me.push(Oe);
                }
              }
              return (function(we, ye, ke) {
                for (const Me in we) for (const be of we[Me]) Er(be, ke[ye[Me].source]);
                return we;
              })(se, R, j);
            })(this._layers, x, this.sourceCaches, e, P, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(_);
          }
          querySourceFeatures(e, a) {
            a && a.filter && this._validate(s.z.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.sourceCaches[e];
            return c ? (function(p, _) {
              const x = p.getRenderableIds().map(((R) => p.getTileByID(R))), k = [], P = {};
              for (let R = 0; R < x.length; R++) {
                const D = x[R], j = D.tileID.canonical.key;
                P[j] || (P[j] = true, D.querySourceFeatures(k, _));
              }
              return k;
            })(c, a) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let p = false;
            for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const _ = { now: L.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, a), this.light.updateTransitions(_);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let p = false;
            if (!e && !c) return;
            if (e && !c) p = true;
            else if (!e && c) p = true;
            else for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const _ = { now: L.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(_);
          }
          _setProjectionInternal(e) {
            const a = (function(c) {
              if (Array.isArray(c)) {
                const p = new Gl({ type: c });
                return { projection: p, transform: new Ws(), cameraHelper: new sh(p) };
              }
              switch (c) {
                case "mercator":
                  return { projection: new xr(), transform: new ti(), cameraHelper: new nn() };
                case "globe": {
                  const p = new Gl({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: p, transform: new Ws(), cameraHelper: new sh(p) };
                }
                case "vertical-perspective":
                  return { projection: new js(), transform: new qs(), cameraHelper: new on() };
                default:
                  return s.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), { projection: new xr(), transform: new ti(), cameraHelper: new nn() };
              }
            })(e);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.sourceCaches) this.sourceCaches[c].reload();
          }
          _validate(e, a, c, p, _ = {}) {
            return (!_ || _.validate !== false) && Wl(this, e.call(s.z, s.e({ key: a, style: this.serialize(), value: c, styleSpec: s.v }, p)));
          }
          _remove(e = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ii().off(tt, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.sourceCaches) {
              const c = this.sourceCaches[a];
              c.setEventedParent(null), c.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const a in this.sourceCaches) this.sourceCaches[a].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, a, c, p, _ = false) {
            let x = false, k = false;
            const P = {};
            for (const R of this._order) {
              const D = this._layers[R];
              if (D.type !== "symbol") continue;
              if (!P[D.source]) {
                const $ = this.sourceCaches[D.source];
                P[D.source] = $.getRenderableIds(true).map(((V) => $.getTileByID(V))).sort(((V, W) => W.tileID.overscaledZ - V.tileID.overscaledZ || (V.tileID.isLessThan(W.tileID) ? -1 : 1)));
              }
              const j = this.crossTileSymbolIndex.addLayer(D, P[D.source], e.center.lng);
              x = x || j;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((_ = _ || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(L.now(), e.zoom)) && (this.pauseablePlacement = new Bs(e, this.map.terrain, this._order, _, a, c, p, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, P), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(L.now()), k = true), x && this.pauseablePlacement.placement.setStale()), k || x) for (const R of this._order) {
              const D = this._layers[R];
              D.type === "symbol" && this.placement.updateLayerOpacities(D, P[D.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(L.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, a.icons), c;
            }));
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.glyphManager.getGlyphs(a.stacks), p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, [""]), c;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.z.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, a, c = {}, p) {
            this._checkLoaded();
            const _ = [{ id: e, url: a }], x = [...J(this.stylesheet.sprite), ..._];
            this._validate(s.z.sprite, "sprite", x, null, c) || (this.stylesheet.sprite = x, this._loadSprite(_, true, p));
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = J(this.stylesheet.sprite);
            if (a.find(((c) => c.id === e))) {
              if (this._spritesImagesIds[e]) for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = true;
              a.splice(a.findIndex(((c) => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return J(this.stylesheet.sprite);
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(s.z.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, true, c) : (this._unloadSprite(), c && c(null)));
          }
        }
        var vp = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class _p {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, a, c, p, _, x, k, P, R) {
            this.context = e;
            let D = this.boundPaintVertexBuffers.length !== p.length;
            for (let j = 0; !D && j < p.length; j++) this.boundPaintVertexBuffers[j] !== p[j] && (D = true);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || D || this.boundIndexBuffer !== _ || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== k || this.boundDynamicVertexBuffer2 !== P || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(a, c, p, _, x, k, P, R) : (e.bindVertexArray.set(this.vao), k && k.bind(), _ && _.dynamicDraw && _.bind(), P && P.bind(), R && R.bind());
          }
          freshBind(e, a, c, p, _, x, k, P) {
            const R = e.numAttributes, D = this.context, j = D.gl;
            this.vao && this.destroy(), this.vao = D.createVertexArray(), D.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = p, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = k, this.boundDynamicVertexBuffer3 = P, a.enableAttributes(j, e);
            for (const $ of c) $.enableAttributes(j, e);
            x && x.enableAttributes(j, e), k && k.enableAttributes(j, e), P && P.enableAttributes(j, e), a.bind(), a.setVertexAttribPointers(j, e, _);
            for (const $ of c) $.bind(), $.setVertexAttribPointers(j, e, _);
            x && (x.bind(), x.setVertexAttribPointers(j, e, _)), p && p.bind(), k && (k.bind(), k.setVertexAttribPointers(j, e, _)), P && (P.bind(), P.setVertexAttribPointers(j, e, _)), D.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Zl = (v, e, a, c, p) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: e, u_fog_color: a ? a.properties.get("fog-color") : s.bf.white, u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: p ? 0 : a ? a.calculateFogBlendOpacity(c) : 0, u_horizon_color: a ? a.properties.get("horizon-color") : s.bf.white, u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: p ? 1 : 0 }), vc = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Ta(v) {
          const e = [];
          for (let a = 0; a < v.length; a++) {
            if (v[a] === null) continue;
            const c = v[a].split(" ");
            e.push(c.pop());
          }
          return e;
        }
        class _c {
          constructor(e, a, c, p, _, x, k, P, R = []) {
            const D = e.gl;
            this.program = D.createProgram();
            const j = Ta(a.staticAttributes), $ = c ? c.getBinderAttributes() : [], V = j.concat($), W = Dn.prelude.staticUniforms ? Ta(Dn.prelude.staticUniforms) : [], le = k.staticUniforms ? Ta(k.staticUniforms) : [], se = a.staticUniforms ? Ta(a.staticUniforms) : [], ce = c ? c.getBinderUniforms() : [], me = W.concat(le).concat(se).concat(ce), we = [];
            for (const We of me) we.indexOf(We) < 0 && we.push(We);
            const ye = c ? c.defines() : [];
            So(D) && ye.unshift("#version 300 es"), _ && ye.push("#define OVERDRAW_INSPECTOR;"), x && ye.push("#define TERRAIN3D;"), P && ye.push(P), R && ye.push(...R);
            let ke = ye.concat(Dn.prelude.fragmentSource, k.fragmentSource, a.fragmentSource).join(`
`), Me = ye.concat(Dn.prelude.vertexSource, k.vertexSource, a.vertexSource).join(`
`);
            So(D) || (ke = (function(We) {
              return We.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(ke), Me = (function(We) {
              return We.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Me));
            const be = D.createShader(D.FRAGMENT_SHADER);
            if (D.isContextLost()) return void (this.failedToCreate = true);
            if (D.shaderSource(be, ke), D.compileShader(be), !D.getShaderParameter(be, D.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${D.getShaderInfoLog(be)}`);
            D.attachShader(this.program, be);
            const Oe = D.createShader(D.VERTEX_SHADER);
            if (D.isContextLost()) return void (this.failedToCreate = true);
            if (D.shaderSource(Oe, Me), D.compileShader(Oe), !D.getShaderParameter(Oe, D.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${D.getShaderInfoLog(Oe)}`);
            D.attachShader(this.program, Oe), this.attributes = {};
            const Qe = {};
            this.numAttributes = V.length;
            for (let We = 0; We < this.numAttributes; We++) V[We] && (D.bindAttribLocation(this.program, We, V[We]), this.attributes[V[We]] = We);
            if (D.linkProgram(this.program), !D.getProgramParameter(this.program, D.LINK_STATUS)) throw new Error(`Program failed to link: ${D.getProgramInfoLog(this.program)}`);
            D.deleteShader(Oe), D.deleteShader(be);
            for (let We = 0; We < we.length; We++) {
              const Ze = we[We];
              if (Ze && !Qe[Ze]) {
                const Je = D.getUniformLocation(this.program, Ze);
                Je && (Qe[Ze] = Je);
              }
            }
            this.fixedUniforms = p(e, Qe), this.terrainUniforms = ((We, Ze) => ({ u_depth: new s.bP(We, Ze.u_depth), u_terrain: new s.bP(We, Ze.u_terrain), u_terrain_dim: new s.bg(We, Ze.u_terrain_dim), u_terrain_matrix: new s.bR(We, Ze.u_terrain_matrix), u_terrain_unpack: new s.bS(We, Ze.u_terrain_unpack), u_terrain_exaggeration: new s.bg(We, Ze.u_terrain_exaggeration) }))(e, Qe), this.projectionUniforms = ((We, Ze) => ({ u_projection_matrix: new s.bR(We, Ze.u_projection_matrix), u_projection_tile_mercator_coords: new s.bS(We, Ze.u_projection_tile_mercator_coords), u_projection_clipping_plane: new s.bS(We, Ze.u_projection_clipping_plane), u_projection_transition: new s.bg(We, Ze.u_projection_transition), u_projection_fallback_matrix: new s.bR(We, Ze.u_projection_fallback_matrix) }))(e, Qe), this.binderUniforms = c ? c.getUniforms(e, Qe) : [];
          }
          draw(e, a, c, p, _, x, k, P, R, D, j, $, V, W, le, se, ce, me, we) {
            const ye = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(p), e.setColorMode(_), e.setCullFace(x), P) {
              e.activeTexture.set(ye.TEXTURE2), ye.bindTexture(ye.TEXTURE_2D, P.depthTexture), e.activeTexture.set(ye.TEXTURE3), ye.bindTexture(ye.TEXTURE_2D, P.texture);
              for (const Me in this.terrainUniforms) this.terrainUniforms[Me].set(P[Me]);
            }
            if (R) for (const Me in R) this.projectionUniforms[vc[Me]].set(R[Me]);
            if (k) for (const Me in this.fixedUniforms) this.fixedUniforms[Me].set(k[Me]);
            se && se.setUniforms(e, this.binderUniforms, W, { zoom: le });
            let ke = 0;
            switch (a) {
              case ye.LINES:
                ke = 2;
                break;
              case ye.TRIANGLES:
                ke = 3;
                break;
              case ye.LINE_STRIP:
                ke = 1;
            }
            for (const Me of V.get()) {
              const be = Me.vaos || (Me.vaos = {});
              (be[D] || (be[D] = new _p())).bind(e, this, j, se ? se.getPaintVertexBuffers() : [], $, Me.vertexOffset, ce, me, we), ye.drawElements(a, Me.primitiveLength * ke, ye.UNSIGNED_SHORT, Me.primitiveOffset * ke * 2);
            }
          }
        }
        function Hl(v, e, a) {
          const c = 1 / s.aC(a, 1, e.transform.tileZoom), p = Math.pow(2, a.tileID.overscaledZ), _ = a.tileSize * Math.pow(2, e.transform.tileZoom) / p, x = _ * (a.tileID.canonical.x + a.tileID.wrap * p), k = _ * a.tileID.canonical.y;
          return { u_image: 0, u_texsize: a.imageAtlasTexture.size, u_scale: [c, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [x >> 16, k >> 16], u_pixel_coord_lower: [65535 & x, 65535 & k] };
        }
        const to = (v, e, a, c) => {
          const p = v.style.light, _ = p.properties.get("position"), x = [_.x, _.y, _.z], k = s.bV();
          p.properties.get("anchor") === "viewport" && s.bW(k, v.transform.bearingInRadians), s.bX(x, x, k);
          const P = v.transform.transformLightDirection(x), R = p.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: P, u_lightintensity: p.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +e, u_opacity: a, u_fill_translate: c };
        }, yp = (v, e, a, c, p, _, x) => s.e(to(v, e, a, c), Hl(_, v, x), { u_height_factor: -Math.pow(2, p.overscaledZ) / x.tileSize / 8 }), Xl = (v, e, a, c) => s.e(Hl(e, v, a), { u_fill_translate: c }), Zs = (v, e) => ({ u_world: v, u_fill_translate: e }), Hs = (v, e, a, c, p) => s.e(Xl(v, e, a, p), { u_world: c }), bp = (v, e, a, c, p) => {
          const _ = v.transform;
          let x, k, P = 0;
          if (a.paint.get("circle-pitch-alignment") === "map") {
            const R = s.aC(e, 1, _.zoom);
            x = true, k = [R, R], P = R / (s.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * p;
          } else x = false, k = _.pixelsToGLUnits;
          return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: k, u_globe_extrude_scale: P, u_translate: c };
        }, Yl = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), xp = (v) => ({ u_viewport_size: [v.width, v.height] }), Ia = (v, e = 1) => ({ u_color: v, u_overlay: 0, u_overlay_scale: e }), lh = (v, e, a, c) => {
          const p = s.aC(v, 1, e) / (s.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * c;
          return { u_extrude_scale: s.aC(v, 1, e), u_intensity: a, u_globe_extrude_scale: p };
        }, yc = (v, e, a, c) => {
          const p = s.L();
          s.bY(p, 0, v.width, v.height, 0, 0, 1);
          const _ = v.context.gl;
          return { u_matrix: p, u_world: [_.drawingBufferWidth, _.drawingBufferHeight], u_image: a, u_color_ramp: c, u_opacity: e.paint.get("heatmap-opacity") };
        }, wp = (v, e, a) => {
          const c = a.paint.get("hillshade-accent-color");
          let p;
          switch (a.paint.get("hillshade-method")) {
            case "basic":
              p = 4;
              break;
            case "combined":
              p = 1;
              break;
            case "igor":
              p = 2;
              break;
            case "multidirectional":
              p = 3;
              break;
            default:
              p = 0;
          }
          const _ = a.getIlluminationProperties();
          for (let x = 0; x < _.directionRadians.length; x++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (_.directionRadians[x] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: bc(0, e.tileID), u_exaggeration: a.paint.get("hillshade-exaggeration"), u_altitudes: _.altitudeRadians, u_azimuths: _.directionRadians, u_accent: c, u_method: p, u_highlights: _.highlightColor, u_shadows: _.shadowColor };
        }, uh = (v, e) => {
          const a = e.stride, c = s.L();
          return s.bY(c, 0, s.$, -s.$, 0, 0, 1), s.M(c, c, [0, -s.$, 0]), { u_matrix: c, u_image: 1, u_dimension: [a, a], u_zoom: v.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function bc(v, e) {
          const a = Math.pow(2, e.canonical.z), c = e.canonical.y;
          return [new s.a1(0, c / a).toLngLat().lat, new s.a1(0, (c + 1) / a).toLngLat().lat];
        }
        const ch = (v, e, a = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: a, u_opacity: v.paint.get("color-relief-opacity") }), Kl = (v, e, a, c) => {
          const p = v.transform;
          return { u_translation: wc(v, e, a), u_ratio: c / s.aC(e, 1, p.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
        }, dh = (v, e, a, c, p) => s.e(Kl(v, e, a, c), { u_image: 0, u_image_height: p }), hh = (v, e, a, c, p) => {
          const _ = v.transform, x = xc(e, _);
          return { u_translation: wc(v, e, a), u_texsize: e.imageAtlasTexture.size, u_ratio: c / s.aC(e, 1, _.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [x, p.fromScale, p.toScale], u_fade: p.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
        }, Ma = (v, e, a, c, p, _) => {
          const x = v.lineAtlas, k = xc(e, v.transform), P = a.layout.get("line-cap") === "round", R = x.getDash(p.from, P), D = x.getDash(p.to, P), j = R.width * _.fromScale, $ = D.width * _.toScale;
          return s.e(Kl(v, e, a, c), { u_patternscale_a: [k / j, -R.height / 2], u_patternscale_b: [k / $, -D.height / 2], u_sdfgamma: x.width / (256 * Math.min(j, $) * v.pixelRatio) / 2, u_image: 0, u_tex_y_a: R.y, u_tex_y_b: D.y, u_mix: _.t });
        };
        function xc(v, e) {
          return 1 / s.aC(v, 1, e.tileZoom);
        }
        function wc(v, e, a) {
          return s.aD(v.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"));
        }
        const Xs = (v, e, a, c, p) => {
          return { u_tl_parent: v, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: a.mix, u_opacity: a.opacity * c.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: c.paint.get("raster-brightness-min"), u_brightness_high: c.paint.get("raster-brightness-max"), u_saturation_factor: (x = c.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (_ = c.paint.get("raster-contrast"), _ > 0 ? 1 / (1 - _) : 1 + _), u_spin_weights: Cp(c.paint.get("raster-hue-rotate")), u_coords_top: [p[0].x, p[0].y, p[1].x, p[1].y], u_coords_bottom: [p[3].x, p[3].y, p[2].x, p[2].y] };
          var _, x;
        };
        function Cp(v) {
          v *= Math.PI / 180;
          const e = Math.sin(v), a = Math.cos(v);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3];
        }
        const Ys = (v, e, a, c, p, _, x, k, P, R, D, j, $) => {
          const V = x.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: V.cameraToCenterDistance, u_pitch: V.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +a, u_aspect_ratio: V.width / V.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: k, u_coord_matrix: P, u_is_text: +D, u_pitch_with_map: +c, u_is_along_line: p, u_is_variable_anchor: _, u_texsize: j, u_texture: 0, u_translation: R, u_pitched_scale: $ };
        }, fh = (v, e, a, c, p, _, x, k, P, R, D, j, $, V) => {
          const W = x.transform;
          return s.e(Ys(v, e, a, c, p, _, x, k, P, R, D, j, V), { u_gamma_scale: c ? Math.cos(W.pitch * Math.PI / 180) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, Sp = (v, e, a, c, p, _, x, k, P, R, D, j, $) => s.e(fh(v, e, a, c, p, _, x, k, P, R, true, D, 0, $), { u_texsize_icon: j, u_texture_icon: 1 }), ph = (v, e) => ({ u_opacity: v, u_color: e }), mh = (v, e, a, c, p) => s.e((function(_, x, k, P) {
          const R = k.imageManager.getPattern(_.from.toString()), D = k.imageManager.getPattern(_.to.toString()), { width: j, height: $ } = k.imageManager.getPixelSize(), V = Math.pow(2, P.tileID.overscaledZ), W = P.tileSize * Math.pow(2, k.transform.tileZoom) / V, le = W * (P.tileID.canonical.x + P.tileID.wrap * V), se = W * P.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: D.tl, u_pattern_br_b: D.br, u_texsize: [j, $], u_mix: x.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: D.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / s.aC(P, 1, k.transform.tileZoom), u_pixel_coord_upper: [le >> 16, se >> 16], u_pixel_coord_lower: [65535 & le, 65535 & se] };
        })(a, p, e, c), { u_opacity: v }), Cc = (v, e) => {
        }, Sc = { fillExtrusion: (v, e) => ({ u_lightpos: new s.bT(v, e.u_lightpos), u_lightpos_globe: new s.bT(v, e.u_lightpos_globe), u_lightintensity: new s.bg(v, e.u_lightintensity), u_lightcolor: new s.bT(v, e.u_lightcolor), u_vertical_gradient: new s.bg(v, e.u_vertical_gradient), u_opacity: new s.bg(v, e.u_opacity), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillExtrusionPattern: (v, e) => ({ u_lightpos: new s.bT(v, e.u_lightpos), u_lightpos_globe: new s.bT(v, e.u_lightpos_globe), u_lightintensity: new s.bg(v, e.u_lightintensity), u_lightcolor: new s.bT(v, e.u_lightcolor), u_vertical_gradient: new s.bg(v, e.u_vertical_gradient), u_height_factor: new s.bg(v, e.u_height_factor), u_opacity: new s.bg(v, e.u_opacity), u_fill_translate: new s.bU(v, e.u_fill_translate), u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade) }), fill: (v, e) => ({ u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillPattern: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillOutline: (v, e) => ({ u_world: new s.bU(v, e.u_world), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillOutlinePattern: (v, e) => ({ u_world: new s.bU(v, e.u_world), u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade), u_fill_translate: new s.bU(v, e.u_fill_translate) }), circle: (v, e) => ({ u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_scale_with_map: new s.bP(v, e.u_scale_with_map), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_extrude_scale: new s.bU(v, e.u_extrude_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_globe_extrude_scale: new s.bg(v, e.u_globe_extrude_scale), u_translate: new s.bU(v, e.u_translate) }), collisionBox: (v, e) => ({ u_pixel_extrude_scale: new s.bU(v, e.u_pixel_extrude_scale) }), collisionCircle: (v, e) => ({ u_viewport_size: new s.bU(v, e.u_viewport_size) }), debug: (v, e) => ({ u_color: new s.bQ(v, e.u_color), u_overlay: new s.bP(v, e.u_overlay), u_overlay_scale: new s.bg(v, e.u_overlay_scale) }), depth: Cc, clippingMask: Cc, heatmap: (v, e) => ({ u_extrude_scale: new s.bg(v, e.u_extrude_scale), u_intensity: new s.bg(v, e.u_intensity), u_globe_extrude_scale: new s.bg(v, e.u_globe_extrude_scale) }), heatmapTexture: (v, e) => ({ u_matrix: new s.bR(v, e.u_matrix), u_world: new s.bU(v, e.u_world), u_image: new s.bP(v, e.u_image), u_color_ramp: new s.bP(v, e.u_color_ramp), u_opacity: new s.bg(v, e.u_opacity) }), hillshade: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_latrange: new s.bU(v, e.u_latrange), u_exaggeration: new s.bg(v, e.u_exaggeration), u_altitudes: new s.b_(v, e.u_altitudes), u_azimuths: new s.b_(v, e.u_azimuths), u_accent: new s.bQ(v, e.u_accent), u_method: new s.bP(v, e.u_method), u_shadows: new s.bZ(v, e.u_shadows), u_highlights: new s.bZ(v, e.u_highlights) }), hillshadePrepare: (v, e) => ({ u_matrix: new s.bR(v, e.u_matrix), u_image: new s.bP(v, e.u_image), u_dimension: new s.bU(v, e.u_dimension), u_zoom: new s.bg(v, e.u_zoom), u_unpack: new s.bS(v, e.u_unpack) }), colorRelief: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_unpack: new s.bS(v, e.u_unpack), u_dimension: new s.bU(v, e.u_dimension), u_elevation_stops: new s.bP(v, e.u_elevation_stops), u_color_stops: new s.bP(v, e.u_color_stops), u_color_ramp_size: new s.bP(v, e.u_color_ramp_size), u_opacity: new s.bg(v, e.u_opacity) }), line: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels) }), lineGradient: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_image: new s.bP(v, e.u_image), u_image_height: new s.bg(v, e.u_image_height) }), linePattern: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_texsize: new s.bU(v, e.u_texsize), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_image: new s.bP(v, e.u_image), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade) }), lineSDF: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_patternscale_a: new s.bU(v, e.u_patternscale_a), u_patternscale_b: new s.bU(v, e.u_patternscale_b), u_sdfgamma: new s.bg(v, e.u_sdfgamma), u_image: new s.bP(v, e.u_image), u_tex_y_a: new s.bg(v, e.u_tex_y_a), u_tex_y_b: new s.bg(v, e.u_tex_y_b), u_mix: new s.bg(v, e.u_mix) }), raster: (v, e) => ({ u_tl_parent: new s.bU(v, e.u_tl_parent), u_scale_parent: new s.bg(v, e.u_scale_parent), u_buffer_scale: new s.bg(v, e.u_buffer_scale), u_fade_t: new s.bg(v, e.u_fade_t), u_opacity: new s.bg(v, e.u_opacity), u_image0: new s.bP(v, e.u_image0), u_image1: new s.bP(v, e.u_image1), u_brightness_low: new s.bg(v, e.u_brightness_low), u_brightness_high: new s.bg(v, e.u_brightness_high), u_saturation_factor: new s.bg(v, e.u_saturation_factor), u_contrast_factor: new s.bg(v, e.u_contrast_factor), u_spin_weights: new s.bT(v, e.u_spin_weights), u_coords_top: new s.bS(v, e.u_coords_top), u_coords_bottom: new s.bS(v, e.u_coords_bottom) }), symbolIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texture: new s.bP(v, e.u_texture), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), symbolSDF: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texture: new s.bP(v, e.u_texture), u_gamma_scale: new s.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_is_halo: new s.bP(v, e.u_is_halo), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), symbolTextAndIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texsize_icon: new s.bU(v, e.u_texsize_icon), u_texture: new s.bP(v, e.u_texture), u_texture_icon: new s.bP(v, e.u_texture_icon), u_gamma_scale: new s.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_is_halo: new s.bP(v, e.u_is_halo), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), background: (v, e) => ({ u_opacity: new s.bg(v, e.u_opacity), u_color: new s.bQ(v, e.u_color) }), backgroundPattern: (v, e) => ({ u_opacity: new s.bg(v, e.u_opacity), u_image: new s.bP(v, e.u_image), u_pattern_tl_a: new s.bU(v, e.u_pattern_tl_a), u_pattern_br_a: new s.bU(v, e.u_pattern_br_a), u_pattern_tl_b: new s.bU(v, e.u_pattern_tl_b), u_pattern_br_b: new s.bU(v, e.u_pattern_br_b), u_texsize: new s.bU(v, e.u_texsize), u_mix: new s.bg(v, e.u_mix), u_pattern_size_a: new s.bU(v, e.u_pattern_size_a), u_pattern_size_b: new s.bU(v, e.u_pattern_size_b), u_scale_a: new s.bg(v, e.u_scale_a), u_scale_b: new s.bg(v, e.u_scale_b), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_tile_units_to_pixels: new s.bg(v, e.u_tile_units_to_pixels) }), terrain: (v, e) => ({ u_texture: new s.bP(v, e.u_texture), u_ele_delta: new s.bg(v, e.u_ele_delta), u_fog_matrix: new s.bR(v, e.u_fog_matrix), u_fog_color: new s.bQ(v, e.u_fog_color), u_fog_ground_blend: new s.bg(v, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.bg(v, e.u_fog_ground_blend_opacity), u_horizon_color: new s.bQ(v, e.u_horizon_color), u_horizon_fog_blend: new s.bg(v, e.u_horizon_fog_blend), u_is_globe_mode: new s.bg(v, e.u_is_globe_mode) }), terrainDepth: (v, e) => ({ u_ele_delta: new s.bg(v, e.u_ele_delta) }), terrainCoords: (v, e) => ({ u_texture: new s.bP(v, e.u_texture), u_terrain_coords_id: new s.bg(v, e.u_terrain_coords_id), u_ele_delta: new s.bg(v, e.u_ele_delta) }), projectionErrorMeasurement: (v, e) => ({ u_input: new s.bg(v, e.u_input), u_output_expected: new s.bg(v, e.u_output_expected) }), atmosphere: (v, e) => ({ u_sun_pos: new s.bT(v, e.u_sun_pos), u_atmosphere_blend: new s.bg(v, e.u_atmosphere_blend), u_globe_position: new s.bT(v, e.u_globe_position), u_globe_radius: new s.bg(v, e.u_globe_radius), u_inv_proj_matrix: new s.bR(v, e.u_inv_proj_matrix) }), sky: (v, e) => ({ u_sky_color: new s.bQ(v, e.u_sky_color), u_horizon_color: new s.bQ(v, e.u_horizon_color), u_horizon: new s.bU(v, e.u_horizon), u_horizon_normal: new s.bU(v, e.u_horizon_normal), u_sky_horizon_blend: new s.bg(v, e.u_sky_horizon_blend), u_sky_blend: new s.bg(v, e.u_sky_blend) }) };
        class gh {
          constructor(e, a, c) {
            this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), p.bufferData(p.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Jl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class $o {
          constructor(e, a, c, p) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = p, this.context = e;
            const _ = e.gl;
            this.buffer = _.createBuffer(), e.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const p = a.attributes[this.attributes[c].name];
              p !== void 0 && e.enableVertexAttribArray(p);
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let p = 0; p < this.attributes.length; p++) {
              const _ = this.attributes[p], x = a.attributes[_.name];
              x !== void 0 && e.vertexAttribPointer(x, _.components, e[Jl[_.type]], false, this.itemSize, _.offset + this.itemSize * (c || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Fr {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class kc extends Fr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Pc extends Fr {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = false);
          }
        }
        class vh extends Fr {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = false);
          }
        }
        class Tc extends Fr {
          getDefault() {
            return [true, true, true, true];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Ea extends Fr {
          getDefault() {
            return true;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = false);
          }
        }
        class Ic extends Fr {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = false);
          }
        }
        class kp extends Fr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
          }
        }
        class Pp extends Fr {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
          }
        }
        class Tp extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = false;
          }
        }
        class Ip extends Fr {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class _h extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = false;
          }
        }
        class Mp extends Fr {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = false);
          }
        }
        class yh extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = false;
          }
        }
        class Ql extends Fr {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class eu extends Fr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class tu extends Fr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = false);
          }
        }
        class Mc extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = false;
          }
        }
        class Ra extends Fr {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = false);
          }
        }
        class Ks extends Fr {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = false);
          }
        }
        class rs extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = false);
          }
        }
        class Gn extends Fr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = false);
          }
        }
        class bh extends Fr {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class xh extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Ec extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Aa extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = false;
          }
        }
        class ru extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class iu extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Js extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            So(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = false;
          }
        }
        class nu extends Fr {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
          }
        }
        class wh extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class is extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class oa extends Fr {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a;
          }
          getDefault() {
            return null;
          }
        }
        class Ch extends oa {
          setDirty() {
            this.dirty = true;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
          }
        }
        class Rc extends oa {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class kr extends oa {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        const Qs = "Framebuffer is not complete";
        class Ep {
          constructor(e, a, c, p, _) {
            this.context = e, this.width = a, this.height = c;
            const x = e.gl, k = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new Ch(e, k), p) this.depthAttachment = _ ? new kr(e, k) : new Rc(e, k);
            else if (_) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error(Qs);
          }
          destroy() {
            const e = this.context.gl, a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class Sh {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new kc(this), this.clearDepth = new Pc(this), this.clearStencil = new vh(this), this.colorMask = new Tc(this), this.depthMask = new Ea(this), this.stencilMask = new Ic(this), this.stencilFunc = new kp(this), this.stencilOp = new Pp(this), this.stencilTest = new Tp(this), this.depthRange = new Ip(this), this.depthTest = new _h(this), this.depthFunc = new Mp(this), this.blend = new yh(this), this.blendFunc = new Ql(this), this.blendColor = new eu(this), this.blendEquation = new tu(this), this.cullFace = new Mc(this), this.cullFaceSide = new Ra(this), this.frontFace = new Ks(this), this.program = new rs(this), this.activeTexture = new Gn(this), this.viewport = new bh(this), this.bindFramebuffer = new xh(this), this.bindRenderbuffer = new Ec(this), this.bindTexture = new Aa(this), this.bindVertexBuffer = new ru(this), this.bindElementBuffer = new iu(this), this.bindVertexArray = new Js(this), this.pixelStoreUnpack = new nu(this), this.pixelStoreUnpackPremultiplyAlpha = new wh(this), this.pixelStoreUnpackFlipY = new is(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), So(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const p = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : p == null ? void 0 : p.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : p == null ? void 0 : p.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const p = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = p == null ? void 0 : p.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e, a) {
            return new gh(this, e, a);
          }
          createVertexBuffer(e, a, c) {
            return new $o(this, e, a, c);
          }
          createRenderbuffer(e, a, c) {
            const p = this.gl, _ = p.createRenderbuffer();
            return this.bindRenderbuffer.set(_), p.renderbufferStorage(p.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), _;
          }
          createFramebuffer(e, a, c, p) {
            return new Ep(this, e, a, c, p);
          }
          clear({ color: e, depth: a, stencil: c }) {
            const p = this.gl;
            let _ = 0;
            e && (_ |= p.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), a !== void 0 && (_ |= p.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(true)), c !== void 0 && (_ |= p.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), p.clear(_);
          }
          setCullFace(e) {
            e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(false);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e) {
            s.bH(e.blendFunction, si.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return So(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var a;
            return So(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let aa;
        function kh(v, e, a, c, p) {
          const _ = v.context, x = v.transform, k = _.gl, P = v.useProgram("collisionBox"), R = [];
          let D = 0, j = 0;
          for (let ce = 0; ce < c.length; ce++) {
            const me = c[ce], we = e.getTile(me).getBucket(a);
            if (!we) continue;
            const ye = p ? we.textCollisionBox : we.iconCollisionBox, ke = we.collisionCircleArray;
            ke.length > 0 && (R.push({ circleArray: ke, circleOffset: j, coord: me }), D += ke.length / 4, j = D), ye && P.draw(_, k.LINES, mr.disabled, Ar.disabled, v.colorModeForRenderPass(), nr.disabled, Yl(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(me), x.getProjectionData({ overscaledTileID: me, applyGlobeMatrix: true, applyTerrainMatrix: true }), a.id, ye.layoutVertexBuffer, ye.indexBuffer, ye.segments, null, v.transform.zoom, null, null, ye.collisionVertexBuffer);
          }
          if (!p || !R.length) return;
          const $ = v.useProgram("collisionCircle"), V = new s.b$();
          V.resize(4 * D), V._trim();
          let W = 0;
          for (const ce of R) for (let me = 0; me < ce.circleArray.length / 4; me++) {
            const we = 4 * me, ye = ce.circleArray[we + 0], ke = ce.circleArray[we + 1], Me = ce.circleArray[we + 2], be = ce.circleArray[we + 3];
            V.emplace(W++, ye, ke, Me, be, 0), V.emplace(W++, ye, ke, Me, be, 1), V.emplace(W++, ye, ke, Me, be, 2), V.emplace(W++, ye, ke, Me, be, 3);
          }
          (!aa || aa.length < 2 * D) && (aa = (function(ce) {
            const me = 2 * ce, we = new s.c1();
            we.resize(me), we._trim();
            for (let ye = 0; ye < me; ye++) {
              const ke = 6 * ye;
              we.uint16[ke + 0] = 4 * ye + 0, we.uint16[ke + 1] = 4 * ye + 1, we.uint16[ke + 2] = 4 * ye + 2, we.uint16[ke + 3] = 4 * ye + 2, we.uint16[ke + 4] = 4 * ye + 3, we.uint16[ke + 5] = 4 * ye + 0;
            }
            return we;
          })(D));
          const le = _.createIndexBuffer(aa, true), se = _.createVertexBuffer(V, s.c0.members, true);
          for (const ce of R) {
            const me = xp(v.transform);
            $.draw(_, k.TRIANGLES, mr.disabled, Ar.disabled, v.colorModeForRenderPass(), nr.disabled, me, v.style.map.terrain && v.style.map.terrain.getTerrainData(ce.coord), null, a.id, se, le, s.aM.simpleSegment(0, 2 * ce.circleOffset, ce.circleArray.length, ce.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          se.destroy(), le.destroy();
        }
        const Rp = s.ag(new Float32Array(16));
        function Ph(v, e, a, c, p, _) {
          const { horizontalAlign: x, verticalAlign: k } = s.aH(v);
          return new s.P((-(x - 0.5) * e / p + c[0]) * _, (-(k - 0.5) * a / p + c[1]) * _);
        }
        function Ap(v, e, a, c, p, _) {
          const x = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let k = c.mult(_);
            a || (k = k.rotate(-p));
            const P = x.add(k);
            return Wr(P.x, P.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (a) {
            const k = oi(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(v), P = Math.atan(k.y / k.x) + (k.x < 0 ? Math.PI : 0);
            return v.add(c.rotate(P));
          }
          return v.add(c);
        }
        function Ac(v, e, a, c, p, _, x, k, P, R, D, j) {
          const $ = v.text.placedSymbolArray, V = v.text.dynamicLayoutVertexArray, W = v.icon.dynamicLayoutVertexArray, le = {};
          V.clear();
          for (let se = 0; se < $.length; se++) {
            const ce = $.get(se), me = ce.hidden || !ce.crossTileID || v.allowVerticalPlacement && !ce.placedOrientation ? null : c[ce.crossTileID];
            if (me) {
              const we = new s.P(ce.anchorX, ce.anchorY), ye = { getElevation: j, width: p.width, height: p.height, pitchedLabelPlaneMatrix: _, pitchWithMap: a, transform: p, tileAnchorPoint: we, translation: R, unwrappedTileID: D }, ke = a ? tn(we.x, we.y, ye) : oi(we.x, we.y, ye), Me = ge(p.cameraToCenterDistance, ke.signedDistanceFromCamera);
              let be = s.ap(v.textSizeData, k, ce) * Me / s.aB;
              a && (be *= v.tilePixelRatio / x);
              const { width: Oe, height: Qe, anchor: We, textOffset: Ze, textBoxScale: Je } = me, kt = Ph(We, Oe, Qe, Ze, Je, be), Tt = p.getPitchedTextCorrection(we.x + R[0], we.y + R[1], D), pt = Ap(ke.point, ye, e, kt, -p.bearingInRadians, Tt), Vt = v.allowVerticalPlacement && ce.placedOrientation === s.ao.vertical ? Math.PI / 2 : 0;
              for (let _r = 0; _r < ce.numGlyphs; _r++) s.av(V, pt, Vt);
              P && ce.associatedIconIndex >= 0 && (le[ce.associatedIconIndex] = { shiftedAnchor: pt, angle: Vt });
            } else Sn(ce.numGlyphs, V);
          }
          if (P) {
            W.clear();
            const se = v.icon.placedSymbolArray;
            for (let ce = 0; ce < se.length; ce++) {
              const me = se.get(ce);
              if (me.hidden) Sn(me.numGlyphs, W);
              else {
                const we = le[ce];
                if (we) for (let ye = 0; ye < me.numGlyphs; ye++) s.av(W, we.shiftedAnchor, we.angle);
                else Sn(me.numGlyphs, W);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(W);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(V);
        }
        function ou(v, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function el(v, e, a, c, p, _, x, k, P, R, D, j, $) {
          const V = v.context, W = V.gl, le = v.transform, se = k === "map", ce = P === "map", me = k !== "viewport" && a.layout.get("symbol-placement") !== "point", we = se && !ce && !me, ye = !a.layout.get("symbol-sort-key").isConstant();
          let ke = false;
          const Me = v.getDepthModeForSublayer(0, mr.ReadOnly), be = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Oe = [], Qe = le.getCircleRadiusCorrection();
          for (const We of c) {
            const Ze = e.getTile(We), Je = Ze.getBucket(a);
            if (!Je) continue;
            const kt = p ? Je.text : Je.icon;
            if (!kt || !kt.segments.get().length || !kt.hasVisibleVertices) continue;
            const Tt = kt.programConfigurations.get(a.id), pt = p || Je.sdfIcons, Vt = p ? Je.textSizeData : Je.iconSizeData, _r = ce || le.pitch !== 0, Or = v.useProgram(ou(pt, p, Je), Tt), Xr = s.an(Vt, le.zoom), Gr = v.style.map.terrain && v.style.map.terrain.getTerrainData(We);
            let di, vi, vr, Yr, Ti = [0, 0], zi = null;
            if (p) vi = Ze.glyphAtlasTexture, vr = W.LINEAR, di = Ze.glyphAtlasTexture.size, Je.iconsInText && (Ti = Ze.imageAtlasTexture.size, zi = Ze.imageAtlasTexture, Yr = _r || v.options.rotating || v.options.zooming || Vt.kind === "composite" || Vt.kind === "camera" ? W.LINEAR : W.NEAREST);
            else {
              const Ii = a.layout.get("icon-size").constantOr(0) !== 1 || Je.iconsNeedLinear;
              vi = Ze.imageAtlasTexture, vr = pt || v.options.rotating || v.options.zooming || Ii || _r ? W.LINEAR : W.NEAREST, di = Ze.imageAtlasTexture.size;
            }
            const Ni = s.aC(Ze, 1, v.transform.zoom), vn = ni(se, v.transform, Ni), so = s.L();
            s.aq(so, vn);
            const la = gr(ce, se, v.transform, Ni), ua = s.aD(le, Ze, _, x), ms = le.getProjectionData({ overscaledTileID: We, applyGlobeMatrix: !$, applyTerrainMatrix: true }), gs = be && Je.hasTextData(), $a = a.layout.get("icon-text-fit") !== "none" && gs && Je.hasIconData();
            if (me) {
              const Ii = v.style.map.terrain ? (Zn, Mi) => v.style.map.terrain.getElevation(We, Zn, Mi) : null, Fi = a.layout.get("text-rotation-alignment") === "map";
              Bt(Je, v, p, vn, so, ce, R, Fi, We.toUnwrapped(), le.width, le.height, ua, Ii);
            }
            const ja = p && be || $a, Tn = me || ja ? Rp : ce ? vn : v.transform.clipSpaceToPixelsMatrix, lo = pt && a.paint.get(p ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let _n;
            _n = pt ? Je.iconsInText ? Sp(Vt.kind, Xr, we, ce, me, ja, v, Tn, la, ua, di, Ti, Qe) : fh(Vt.kind, Xr, we, ce, me, ja, v, Tn, la, ua, p, di, 0, Qe) : Ys(Vt.kind, Xr, we, ce, me, ja, v, Tn, la, ua, p, di, Qe);
            const ca = { program: Or, buffers: kt, uniformValues: _n, projectionData: ms, atlasTexture: vi, atlasTextureIcon: zi, atlasInterpolation: vr, atlasInterpolationIcon: Yr, isSDF: pt, hasHalo: lo };
            if (ye && Je.canOverlap) {
              ke = true;
              const Ii = kt.segments.get();
              for (const Fi of Ii) Oe.push({ segments: new s.aM([Fi]), sortKey: Fi.sortKey, state: ca, terrainData: Gr });
            } else Oe.push({ segments: kt.segments, sortKey: 0, state: ca, terrainData: Gr });
          }
          ke && Oe.sort(((We, Ze) => We.sortKey - Ze.sortKey));
          for (const We of Oe) {
            const Ze = We.state;
            if (V.activeTexture.set(W.TEXTURE0), Ze.atlasTexture.bind(Ze.atlasInterpolation, W.CLAMP_TO_EDGE), Ze.atlasTextureIcon && (V.activeTexture.set(W.TEXTURE1), Ze.atlasTextureIcon && Ze.atlasTextureIcon.bind(Ze.atlasInterpolationIcon, W.CLAMP_TO_EDGE)), Ze.isSDF) {
              const Je = Ze.uniformValues;
              Ze.hasHalo && (Je.u_is_halo = 1, tl(Ze.buffers, We.segments, a, v, Ze.program, Me, D, j, Je, Ze.projectionData, We.terrainData)), Je.u_is_halo = 0;
            }
            tl(Ze.buffers, We.segments, a, v, Ze.program, Me, D, j, Ze.uniformValues, Ze.projectionData, We.terrainData);
          }
        }
        function tl(v, e, a, c, p, _, x, k, P, R, D) {
          const j = c.context;
          p.draw(j, j.gl.TRIANGLES, _, x, k, nr.backCCW, P, D, R, a.id, v.layoutVertexBuffer, v.indexBuffer, e, a.paint, c.transform.zoom, v.programConfigurations.get(a.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function Dc(v, e, a, c, p) {
          const _ = v.context, x = _.gl, k = Ar.disabled, P = new si([x.ONE, x.ONE], s.bf.transparent, [true, true, true, true]), R = e.getBucket(a);
          if (!R) return;
          const D = c.key;
          let j = a.heatmapFbos.get(D);
          j || (j = rl(_, e.tileSize, e.tileSize), a.heatmapFbos.set(D, j)), _.bindFramebuffer.set(j.framebuffer), _.viewport.set([0, 0, e.tileSize, e.tileSize]), _.clear({ color: s.bf.transparent });
          const $ = R.programConfigurations.get(a.id), V = v.useProgram("heatmap", $, !p), W = v.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), le = v.style.map.terrain.getTerrainData(c);
          V.draw(_, x.TRIANGLES, mr.disabled, k, P, nr.disabled, lh(e, v.transform.zoom, a.paint.get("heatmap-intensity"), 1), le, W, a.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, a.paint, v.transform.zoom, $);
        }
        function Th(v, e, a, c, p) {
          const _ = v.context, x = _.gl, k = v.transform;
          _.setColorMode(v.colorModeForRenderPass());
          const P = il(_, e), R = a.key, D = e.heatmapFbos.get(R);
          if (!D) return;
          _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, D.colorAttachment.get()), _.activeTexture.set(x.TEXTURE1), P.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const j = k.getProjectionData({ overscaledTileID: a, applyTerrainMatrix: p, applyGlobeMatrix: !c });
          v.useProgram("heatmapTexture").draw(_, x.TRIANGLES, mr.disabled, Ar.disabled, v.colorModeForRenderPass(), nr.disabled, yc(v, e, 0, 1), null, j, e.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, e.paint, k.zoom), D.destroy(), e.heatmapFbos.delete(R);
        }
        function rl(v, e, a) {
          var c, p;
          const _ = v.gl, x = _.createTexture();
          _.bindTexture(_.TEXTURE_2D, x), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.LINEAR), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.LINEAR);
          const k = (c = v.HALF_FLOAT) !== null && c !== void 0 ? c : _.UNSIGNED_BYTE, P = (p = v.RGBA16F) !== null && p !== void 0 ? p : _.RGBA;
          _.texImage2D(_.TEXTURE_2D, 0, P, e, a, 0, _.RGBA, k, null);
          const R = v.createFramebuffer(e, a, false, false);
          return R.colorAttachment.set(x), R;
        }
        function il(v, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(v, e.colorRamp, v.gl.RGBA)), e.colorRampTexture;
        }
        function nl(v, e, a, c, p) {
          if (!a || !c || !c.imageAtlas) return;
          const _ = c.imageAtlas.patternPositions;
          let x = _[a.to.toString()], k = _[a.from.toString()];
          if (!x && k && (x = k), !k && x && (k = x), !x || !k) {
            const P = p.getPaintProperty(e);
            x = _[P], k = _[P];
          }
          x && k && v.setConstantPatternPositions(x, k);
        }
        function au(v, e, a, c, p, _, x, k) {
          const P = v.context.gl, R = "fill-pattern", D = a.paint.get(R), j = D && D.constantOr(1), $ = a.getCrossfadeParameters();
          let V, W, le, se, ce;
          const me = v.transform, we = a.paint.get("fill-translate"), ye = a.paint.get("fill-translate-anchor");
          x ? (W = j && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", V = P.LINES) : (W = j ? "fillPattern" : "fill", V = P.TRIANGLES);
          const ke = D.constantOr(null);
          for (const Me of c) {
            const be = e.getTile(Me);
            if (j && !be.patternsLoaded()) continue;
            const Oe = be.getBucket(a);
            if (!Oe) continue;
            const Qe = Oe.programConfigurations.get(a.id), We = v.useProgram(W, Qe), Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(Me);
            j && (v.context.activeTexture.set(P.TEXTURE0), be.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), Qe.updatePaintBuffers($)), nl(Qe, R, ke, be, a);
            const Je = me.getProjectionData({ overscaledTileID: Me, applyGlobeMatrix: !k, applyTerrainMatrix: true }), kt = s.aD(me, be, we, ye);
            if (x) {
              se = Oe.indexBuffer2, ce = Oe.segments2;
              const pt = [P.drawingBufferWidth, P.drawingBufferHeight];
              le = W === "fillOutlinePattern" && j ? Hs(v, $, be, pt, kt) : Zs(pt, kt);
            } else se = Oe.indexBuffer, ce = Oe.segments, le = j ? Xl(v, $, be, kt) : { u_fill_translate: kt };
            const Tt = v.stencilModeForClipping(Me);
            We.draw(v.context, V, p, Tt, _, nr.backCCW, le, Ze, Je, a.id, Oe.layoutVertexBuffer, se, ce, a.paint, v.transform.zoom, Qe);
          }
        }
        function zc(v, e, a, c, p, _, x, k) {
          const P = v.context, R = P.gl, D = "fill-extrusion-pattern", j = a.paint.get(D), $ = j.constantOr(1), V = a.getCrossfadeParameters(), W = a.paint.get("fill-extrusion-opacity"), le = j.constantOr(null), se = v.transform;
          for (const ce of c) {
            const me = e.getTile(ce), we = me.getBucket(a);
            if (!we) continue;
            const ye = v.style.map.terrain && v.style.map.terrain.getTerrainData(ce), ke = we.programConfigurations.get(a.id), Me = v.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", ke);
            $ && (v.context.activeTexture.set(R.TEXTURE0), me.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), ke.updatePaintBuffers(V));
            const be = se.getProjectionData({ overscaledTileID: ce, applyGlobeMatrix: !k, applyTerrainMatrix: true });
            nl(ke, D, le, me, a);
            const Oe = s.aD(se, me, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")), Qe = a.paint.get("fill-extrusion-vertical-gradient"), We = $ ? yp(v, Qe, W, Oe, ce, V, me) : to(v, Qe, W, Oe);
            Me.draw(P, P.gl.TRIANGLES, p, _, x, nr.backCCW, We, ye, be, a.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, a.paint, v.transform.zoom, ke, v.style.map.terrain && we.centroidVertexBuffer);
          }
        }
        function Da(v, e, a, c, p, _, x, k, P) {
          var R;
          const D = v.style.projection, j = v.context, $ = v.transform, V = j.gl, W = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`], le = v.useProgram("hillshade", null, false, W), se = !v.options.moving;
          for (const ce of c) {
            const me = e.getTile(ce), we = me.fbo;
            if (!we) continue;
            const ye = D.getMeshFromTileID(j, ce.canonical, k, true, "raster"), ke = (R = v.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ce);
            j.activeTexture.set(V.TEXTURE0), V.bindTexture(V.TEXTURE_2D, we.colorAttachment.get());
            const Me = $.getProjectionData({ overscaledTileID: ce, aligned: se, applyGlobeMatrix: !P, applyTerrainMatrix: true });
            le.draw(j, V.TRIANGLES, _, p[ce.overscaledZ], x, nr.backCCW, wp(v, me, a), ke, Me, a.id, ye.vertexBuffer, ye.indexBuffer, ye.segments);
          }
        }
        function Fc(v, e, a, c, p, _, x, k, P) {
          var R;
          const D = v.style.projection, j = v.context, $ = v.transform, V = j.gl, W = v.useProgram("colorRelief"), le = !v.options.moving;
          let se = true, ce = 0;
          for (const me of c) {
            const we = e.getTile(me), ye = we.dem;
            if (se) {
              const We = V.getParameter(V.MAX_TEXTURE_SIZE), { elevationTexture: Ze, colorTexture: Je } = a.getColorRampTextures(j, We, ye.getUnpackVector());
              j.activeTexture.set(V.TEXTURE1), Ze.bind(V.NEAREST, V.CLAMP_TO_EDGE), j.activeTexture.set(V.TEXTURE4), Je.bind(V.LINEAR, V.CLAMP_TO_EDGE), se = false, ce = Ze.size[0];
            }
            if (!ye || !ye.data) continue;
            const ke = ye.stride, Me = ye.getPixels();
            if (j.activeTexture.set(V.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(false), we.demTexture = we.demTexture || v.getTileTexture(ke), we.demTexture) {
              const We = we.demTexture;
              We.update(Me, { premultiply: false }), We.bind(V.LINEAR, V.CLAMP_TO_EDGE);
            } else we.demTexture = new s.T(j, Me, V.RGBA, { premultiply: false }), we.demTexture.bind(V.LINEAR, V.CLAMP_TO_EDGE);
            const be = D.getMeshFromTileID(j, me.canonical, k, true, "raster"), Oe = (R = v.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(me), Qe = $.getProjectionData({ overscaledTileID: me, aligned: le, applyGlobeMatrix: !P, applyTerrainMatrix: true });
            W.draw(j, V.TRIANGLES, _, p[me.overscaledZ], x, nr.backCCW, ch(a, we.dem, ce), Oe, Qe, a.id, be.vertexBuffer, be.indexBuffer, be.segments);
          }
        }
        const su = [new s.P(0, 0), new s.P(s.$, 0), new s.P(s.$, s.$), new s.P(0, s.$)];
        function za(v, e, a, c, p, _, x, k, P = false, R = false) {
          const D = c[c.length - 1].overscaledZ, j = v.context, $ = j.gl, V = v.useProgram("raster"), W = v.transform, le = v.style.projection, se = v.colorModeForRenderPass(), ce = !v.options.moving;
          for (const me of c) {
            const we = v.getDepthModeForSublayer(me.overscaledZ - D, a.paint.get("raster-opacity") === 1 ? mr.ReadWrite : mr.ReadOnly, $.LESS), ye = e.getTile(me);
            ye.registerFadeDuration(a.paint.get("raster-fade-duration"));
            const ke = e.findLoadedParent(me, 0), Me = e.findLoadedSibling(me), be = Lc(ye, ke || Me || null, e, a, v.transform, v.style.map.terrain);
            let Oe, Qe;
            const We = a.paint.get("raster-resampling") === "nearest" ? $.NEAREST : $.LINEAR;
            j.activeTexture.set($.TEXTURE0), ye.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), j.activeTexture.set($.TEXTURE1), ke ? (ke.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), Oe = Math.pow(2, ke.tileID.overscaledZ - ye.tileID.overscaledZ), Qe = [ye.tileID.canonical.x * Oe % 1, ye.tileID.canonical.y * Oe % 1]) : ye.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), ye.texture.useMipmap && j.extTextureFilterAnisotropic && v.transform.pitch > 20 && $.texParameterf($.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(me), Je = W.getProjectionData({ overscaledTileID: me, aligned: ce, applyGlobeMatrix: !R, applyTerrainMatrix: true }), kt = Xs(Qe || [0, 0], Oe || 1, be, a, k), Tt = le.getMeshFromTileID(j, me.canonical, _, x, "raster");
            V.draw(j, $.TRIANGLES, we, p ? p[me.overscaledZ] : Ar.disabled, se, P ? nr.frontCCW : nr.backCCW, kt, Ze, Je, a.id, Tt.vertexBuffer, Tt.indexBuffer, Tt.segments);
          }
        }
        function Lc(v, e, a, c, p, _) {
          const x = c.paint.get("raster-fade-duration");
          if (!_ && x > 0) {
            const k = L.now(), P = (k - v.timeAdded) / x, R = e ? (k - e.timeAdded) / x : -1, D = a.getSource(), j = wt(p, { tileSize: D.tileSize, roundZoom: D.roundZoom }), $ = !e || Math.abs(e.tileID.overscaledZ - j) > Math.abs(v.tileID.overscaledZ - j), V = $ && v.refreshedUponExpiration ? 1 : s.ah($ ? P : 1 - R, 0, 1);
            return v.refreshedUponExpiration && P >= 1 && (v.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - V } : { opacity: V, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Ih = new s.bf(1, 0, 0, 1), Mh = new s.bf(0, 1, 0, 1), lu = new s.bf(0, 0, 1, 1), Bc = new s.bf(1, 0, 1, 1), Dp = new s.bf(0, 1, 1, 1);
        function Oc(v, e, a, c) {
          To(v, 0, e + a / 2, v.transform.width, a, c);
        }
        function gi(v, e, a, c) {
          To(v, e - a / 2, 0, a, v.transform.height, c);
        }
        function To(v, e, a, c, p, _) {
          const x = v.context, k = x.gl;
          k.enable(k.SCISSOR_TEST), k.scissor(e * v.pixelRatio, a * v.pixelRatio, c * v.pixelRatio, p * v.pixelRatio), x.clear({ color: _ }), k.disable(k.SCISSOR_TEST);
        }
        function qn(v, e, a) {
          const c = v.context, p = c.gl, _ = v.useProgram("debug"), x = mr.disabled, k = Ar.disabled, P = v.colorModeForRenderPass(), R = "$debug", D = v.style.map.terrain && v.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(p.TEXTURE0);
          const j = e.getTileByID(a.key).latestRawTileData, $ = Math.floor((j && j.byteLength || 0) / 1024), V = e.getTile(a).tileSize, W = 512 / Math.min(V, 512) * (a.overscaledZ / v.transform.zoom) * 0.5;
          let le = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (le += ` => ${a.overscaledZ}`), (function(ce, me) {
            ce.initDebugOverlayCanvas();
            const we = ce.debugOverlayCanvas, ye = ce.context.gl, ke = ce.debugOverlayCanvas.getContext("2d");
            ke.clearRect(0, 0, we.width, we.height), ke.shadowColor = "white", ke.shadowBlur = 2, ke.lineWidth = 1.5, ke.strokeStyle = "white", ke.textBaseline = "top", ke.font = "bold 36px Open Sans, sans-serif", ke.fillText(me, 5, 5), ke.strokeText(me, 5, 5), ce.debugOverlayTexture.update(we), ce.debugOverlayTexture.bind(ye.LINEAR, ye.CLAMP_TO_EDGE);
          })(v, `${le} ${$}kB`);
          const se = v.transform.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: true, applyTerrainMatrix: true });
          _.draw(c, p.TRIANGLES, x, k, si.alphaBlended, nr.disabled, Ia(s.bf.transparent, W), null, se, R, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), _.draw(c, p.LINE_STRIP, x, k, P, nr.disabled, Ia(s.bf.red), D, se, R, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function uu(v, e, a, c) {
          const { isRenderingGlobe: p } = c, _ = v.context, x = _.gl, k = v.transform, P = v.colorModeForRenderPass(), R = v.getDepthModeFor3D(), D = v.useProgram("terrain");
          _.bindFramebuffer.set(null), _.viewport.set([0, 0, v.width, v.height]);
          for (const j of a) {
            const $ = e.getTerrainMesh(j.tileID), V = v.renderToTexture.getTexture(j), W = e.getTerrainData(j.tileID);
            _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, V.texture);
            const le = e.getMeshFrameDelta(k.zoom), se = k.calculateFogMatrix(j.tileID.toUnwrapped()), ce = Zl(le, se, v.style.sky, k.pitch, p), me = k.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            D.draw(_, x.TRIANGLES, R, Ar.disabled, P, nr.backCCW, ce, W, me, "terrain", $.vertexBuffer, $.indexBuffer, $.segments);
          }
        }
        function ol(v, e) {
          if (!e.mesh) {
            const a = new s.aL();
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new s.aN();
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new Lo(v.createVertexBuffer(a, Co.members), v.createIndexBuffer(c), s.aM.simpleSegment(0, 0, a.length, c.length));
          }
          return e.mesh;
        }
        class Eh {
          constructor(e, a) {
            this.context = new Sh(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: s.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Qt.maxUnderzooming + Qt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new na();
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const p of this.style._order) this.style._layers[p].resize();
          }
          setup() {
            const e = this.context, a = new s.aL();
            a.emplaceBack(0, 0), a.emplaceBack(s.$, 0), a.emplaceBack(0, s.$), a.emplaceBack(s.$, s.$), this.tileExtentBuffer = e.createVertexBuffer(a, Co.members), this.tileExtentSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const c = new s.aL();
            c.emplaceBack(0, 0), c.emplaceBack(s.$, 0), c.emplaceBack(0, s.$), c.emplaceBack(s.$, s.$), this.debugBuffer = e.createVertexBuffer(c, Co.members), this.debugSegments = s.aM.simpleSegment(0, 0, 4, 5);
            const p = new s.c6();
            p.emplaceBack(0, 0, 0, 0), p.emplaceBack(s.$, 0, s.$, 0), p.emplaceBack(0, s.$, 0, s.$), p.emplaceBack(s.$, s.$, s.$, s.$), this.rasterBoundsBuffer = e.createVertexBuffer(p, vp.members), this.rasterBoundsSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const _ = new s.aL();
            _.emplaceBack(0, 0), _.emplaceBack(s.$, 0), _.emplaceBack(0, s.$), _.emplaceBack(s.$, s.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(_, Co.members), this.rasterBoundsSegmentsPosOnly = s.aM.simpleSegment(0, 0, 4, 5);
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(x, Co.members), this.viewportSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const k = new s.c7();
            k.emplaceBack(0), k.emplaceBack(1), k.emplaceBack(3), k.emplaceBack(2), k.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(k);
            const P = new s.aN();
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(P);
            const R = this.context.gl;
            this.stencilClearMode = new Ar({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new Lo(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = s.L();
            s.bY(c, 0, this.width, this.height, 0, 0, 1), s.N(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const p = { mainMatrix: c, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: c };
            this.useProgram("clippingMask", null, true).draw(e, a.TRIANGLES, mr.disabled, this.stencilClearMode, si.disabled, nr.disabled, null, null, p, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const p = this.context;
            p.setColorMode(si.disabled), p.setDepthMode(mr.disabled);
            const _ = {};
            for (const x of a) _[x.key] = this.nextStencilID++;
            this._renderTileMasks(_, a, c, true), this._renderTileMasks(_, a, c, false), this._tileClippingMaskIDs = _;
          }
          _renderTileMasks(e, a, c, p) {
            const _ = this.context, x = _.gl, k = this.style.projection, P = this.transform, R = this.useProgram("clippingMask");
            for (const D of a) {
              const j = e[D.key], $ = this.style.map.terrain && this.style.map.terrain.getTerrainData(D), V = k.getMeshFromTileID(this.context, D.canonical, p, true, "stencil"), W = P.getProjectionData({ overscaledTileID: D, applyGlobeMatrix: !c, applyTerrainMatrix: true });
              R.draw(_, x.TRIANGLES, mr.disabled, new Ar({ func: x.ALWAYS, mask: 0 }, j, 255, x.KEEP, x.KEEP, x.REPLACE), si.disabled, c ? nr.disabled : nr.backCCW, null, $, W, "$clipping", V.vertexBuffer, V.indexBuffer, V.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, a = e.gl, c = this.style.projection, p = this.transform, _ = this.useProgram("depth"), x = this.getDepthModeFor3D(), k = Pe(p, { tileSize: p.tileSize });
            for (const P of k) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(P), D = c.getMeshFromTileID(this.context, P.canonical, true, true, "raster"), j = p.getProjectionData({ overscaledTileID: P, applyGlobeMatrix: true, applyTerrainMatrix: true });
              _.draw(e, a.TRIANGLES, x, Ar.disabled, si.disabled, nr.backCCW, null, R, j, "$clipping", D.vertexBuffer, D.indexBuffer, D.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, a = this.context.gl;
            return new Ar({ func: a.NOTEQUAL, mask: 255 }, e, 255, a.KEEP, a.KEEP, a.REPLACE);
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Ar({ func: a.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - p + 1;
            if (_ > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + _ > 256 && this.clearStencil();
              const x = {};
              for (let k = 0; k < _; k++) x[k + p] = new Ar({ func: a.GEQUAL, mask: 255 }, k + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += _, [x, c];
            }
            return [{ [p]: Ar.disabled }, c];
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - p + 1;
            if (this.clearStencil(), _ > 1) {
              const x = {}, k = {};
              for (let P = 0; P < _; P++) x[P + p] = new Ar({ func: a.GREATER, mask: 255 }, _ + 1 + P, 255, a.KEEP, a.KEEP, a.REPLACE), k[P + p] = new Ar({ func: a.GREATER, mask: 255 }, 1 + P, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * _ + 1, [x, k, c];
            }
            return this.nextStencilID = 3, [{ [p]: new Ar({ func: a.GREATER, mask: 255 }, 2, 255, a.KEEP, a.KEEP, a.REPLACE) }, { [p]: new Ar({ func: a.GREATER, mask: 255 }, 1, 255, a.KEEP, a.KEEP, a.REPLACE) }, c];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new si([e.CONSTANT_COLOR, e.ONE], new s.bf(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? si.unblended : si.alphaBlended;
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return mr.disabled;
            const p = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new mr(c || this.context.gl.LEQUAL, a, [p, p]);
          }
          getDepthModeFor3D() {
            return new mr(this.context.gl.LEQUAL, mr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, a) {
            var c, p;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(L.now()), this.imageManager.beginFrame();
            const _ = this.style._order, x = this.style.sourceCaches, k = {}, P = {}, R = {}, D = { isRenderingToTexture: false, isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0 };
            for (const $ in x) {
              const V = x[$];
              V.used && V.prepare(this.context), k[$] = V.getVisibleCoordinates(false), P[$] = k[$].slice().reverse(), R[$] = V.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let $ = 0; $ < _.length; $++) if (this.style._layers[_[$]].is3D()) {
              this.opaquePassCutoff = $;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const $ of _) {
              const V = this.style._layers[$];
              if (!V.hasOffscreenPass() || V.isHidden(this.transform.zoom)) continue;
              const W = P[V.source];
              (V.type === "custom" || W.length) && this.renderLayer(this, x[V.source], V, W, D);
            }
            if ((p = this.style.projection) === null || p === void 0 || p.updateGPUdependent({ context: this.context, useProgram: ($) => this.useProgram($) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: a.showOverdrawInspector ? s.bf.black : s.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function($, V) {
              const W = $.context, le = W.gl, se = ((Me, be, Oe) => {
                const Qe = Math.cos(be.rollInRadians), We = Math.sin(be.rollInRadians), Ze = Te(be), Je = be.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: Me.properties.get("sky-color"), u_horizon_color: Me.properties.get("horizon-color"), u_horizon: [(be.width / 2 - Ze * We) * Oe, (be.height / 2 + Ze * Qe) * Oe], u_horizon_normal: [-We, Qe], u_sky_horizon_blend: Me.properties.get("sky-horizon-blend") * be.height / 2 * Oe, u_sky_blend: Je };
              })(V, $.style.map.transform, $.pixelRatio), ce = new mr(le.LEQUAL, mr.ReadWrite, [0, 1]), me = Ar.disabled, we = $.colorModeForRenderPass(), ye = $.useProgram("sky"), ke = ol(W, V);
              ye.draw(W, le.TRIANGLES, ce, me, we, nr.disabled, se, null, void 0, "sky", ke.vertexBuffer, ke.indexBuffer, ke.segments);
            })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const $ = this.style._layers[_[this.currentLayer]], V = x[$.source], W = k[$.source];
              this._renderTileClippingMasks($, W, false), this.renderLayer(this, V, $, W, D);
            }
            this.renderPass = "translucent";
            let j = false;
            for (this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
              const $ = this.style._layers[_[this.currentLayer]], V = x[$.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer($, D)) continue;
              this.opaquePassEnabledForLayer() || j || (j = true, D.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const W = ($.type === "symbol" ? R : P)[$.source];
              this._renderTileClippingMasks($, k[$.source], !!this.renderToTexture), this.renderLayer(this, V, $, W, D);
            }
            if (D.isRenderingGlobe && (function($, V, W) {
              const le = $.context, se = le.gl, ce = $.useProgram("atmosphere"), me = new mr(se.LEQUAL, mr.ReadOnly, [0, 1]), we = $.transform, ye = (function(Je, kt) {
                const Tt = Je.properties.get("position"), pt = [-Tt.x, -Tt.y, -Tt.z], Vt = s.ag(new Float64Array(16));
                return Je.properties.get("anchor") === "map" && (s.b6(Vt, Vt, kt.rollInRadians), s.b7(Vt, Vt, -kt.pitchInRadians), s.b6(Vt, Vt, kt.bearingInRadians), s.b7(Vt, Vt, kt.center.lat * Math.PI / 180), s.bz(Vt, Vt, -kt.center.lng * Math.PI / 180)), s.c5(pt, pt, Vt), pt;
              })(W, $.transform), ke = we.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), Me = V.properties.get("atmosphere-blend") * ke.projectionTransition;
              if (Me === 0) return;
              const be = es(we.worldSize, we.center.lat), Oe = we.inverseProjectionMatrix, Qe = new Float64Array(4);
              Qe[3] = 1, s.aw(Qe, Qe, we.modelViewProjectionMatrix), Qe[0] /= Qe[3], Qe[1] /= Qe[3], Qe[2] /= Qe[3], Qe[3] = 1, s.aw(Qe, Qe, Oe), Qe[0] /= Qe[3], Qe[1] /= Qe[3], Qe[2] /= Qe[3], Qe[3] = 1;
              const We = /* @__PURE__ */ ((Je, kt, Tt, pt, Vt) => ({ u_sun_pos: Je, u_atmosphere_blend: kt, u_globe_position: Tt, u_globe_radius: pt, u_inv_proj_matrix: Vt }))(ye, Me, [Qe[0], Qe[1], Qe[2]], be, Oe), Ze = ol(le, V);
              ce.draw(le, se.TRIANGLES, me, Ar.disabled, si.alphaBlended, nr.disabled, We, null, null, "atmosphere", Ze.vertexBuffer, Ze.indexBuffer, Ze.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const $ = (function(V, W) {
                let le = null;
                const se = Object.values(V._layers).flatMap(((ye) => ye.source && !ye.isHidden(W) ? [V.sourceCaches[ye.source]] : [])), ce = se.filter(((ye) => ye.getSource().type === "vector")), me = se.filter(((ye) => ye.getSource().type !== "vector")), we = (ye) => {
                  (!le || le.getSource().maxzoom < ye.getSource().maxzoom) && (le = ye);
                };
                return ce.forEach(((ye) => we(ye))), le || me.forEach(((ye) => we(ye))), le;
              })(this.style, this.transform.zoom);
              $ && (function(V, W, le) {
                for (let se = 0; se < le.length; se++) qn(V, W, le[se]);
              })(this, $, $.getVisibleCoordinates());
            }
            this.options.showPadding && (function($) {
              const V = $.transform.padding;
              Oc($, $.transform.height - (V.top || 0), 3, Ih), Oc($, V.bottom || 0, 3, Mh), gi($, V.left || 0, 3, lu), gi($, $.transform.width - (V.right || 0), 3, Bc);
              const W = $.transform.centerPoint;
              (function(le, se, ce, me) {
                To(le, se - 1, ce - 10, 2, 20, me), To(le, se - 10, ce - 1, 20, 2, me);
              })($, W.x, $.transform.height - W.y, Dp);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
            let p = this.terrainFacilitator.dirty;
            p || (p = e ? !s.c8(a, c) : !s.c9(a, c)), p || (p = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), p && (s.ca(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(_, x) {
              const k = _.context, P = k.gl, R = _.transform, D = si.unblended, j = new mr(P.LEQUAL, mr.ReadWrite, [0, 1]), $ = x.sourceCache.getRenderableTiles(), V = _.useProgram("terrainDepth");
              k.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 });
              for (const W of $) {
                const le = x.getTerrainMesh(W.tileID), se = x.getTerrainData(W.tileID), ce = R.getProjectionData({ overscaledTileID: W.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), me = { u_ele_delta: x.getMeshFrameDelta(R.zoom) };
                V.draw(k, P.TRIANGLES, j, Ar.disabled, D, nr.backCCW, me, se, ce, "terrain", le.vertexBuffer, le.indexBuffer, le.segments);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain), (function(_, x) {
              const k = _.context, P = k.gl, R = _.transform, D = si.unblended, j = new mr(P.LEQUAL, mr.ReadWrite, [0, 1]), $ = x.getCoordsTexture(), V = x.sourceCache.getRenderableTiles(), W = _.useProgram("terrainCoords");
              k.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 }), x.coordsIndex = [];
              for (const le of V) {
                const se = x.getTerrainMesh(le.tileID), ce = x.getTerrainData(le.tileID);
                k.activeTexture.set(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, $.texture);
                const me = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(R.zoom) }, we = R.getProjectionData({ overscaledTileID: le.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                W.draw(k, P.TRIANGLES, j, Ar.disabled, D, nr.backCCW, me, ce, we, "terrain", se.vertexBuffer, se.indexBuffer, se.segments), x.coordsIndex.push(le.tileID.key);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, a, c, p, _) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (p || []).length) && (this.id = c.id, s.cb(c) ? (function(x, k, P, R, D, j) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: $ } = j, V = Ar.disabled, W = x.colorModeForRenderPass();
              (P._unevaluatedLayout.hasValue("text-variable-anchor") || P._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(le, se, ce, me, we, ye, ke, Me, be) {
                const Oe = se.transform, Qe = se.style.map.terrain, We = we === "map", Ze = ye === "map";
                for (const Je of le) {
                  const kt = me.getTile(Je), Tt = kt.getBucket(ce);
                  if (!Tt || !Tt.text || !Tt.text.segments.get().length) continue;
                  const pt = s.an(Tt.textSizeData, Oe.zoom), Vt = s.aC(kt, 1, se.transform.zoom), _r = ni(We, se.transform, Vt), Or = ce.layout.get("icon-text-fit") !== "none" && Tt.hasIconData();
                  if (pt) {
                    const Xr = Math.pow(2, Oe.zoom - kt.tileID.overscaledZ), Gr = Qe ? (di, vi) => Qe.getElevation(Je, di, vi) : null;
                    Ac(Tt, We, Ze, be, Oe, _r, Xr, pt, Or, s.aD(Oe, kt, ke, Me), Je.toUnwrapped(), Gr);
                  }
                }
              })(R, x, P, k, P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), D), P.paint.get("icon-opacity").constantOr(1) !== 0 && el(x, k, P, R, false, P.paint.get("icon-translate"), P.paint.get("icon-translate-anchor"), P.layout.get("icon-rotation-alignment"), P.layout.get("icon-pitch-alignment"), P.layout.get("icon-keep-upright"), V, W, $), P.paint.get("text-opacity").constantOr(1) !== 0 && el(x, k, P, R, true, P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.layout.get("text-keep-upright"), V, W, $), k.map.showCollisionBoxes && (kh(x, k, P, R, true), kh(x, k, P, R, false));
            })(e, a, c, p, this.style.placement.variableOffsets, _) : s.cc(c) ? (function(x, k, P, R, D) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = P.paint.get("circle-opacity"), V = P.paint.get("circle-stroke-width"), W = P.paint.get("circle-stroke-opacity"), le = !P.layout.get("circle-sort-key").isConstant();
              if ($.constantOr(1) === 0 && (V.constantOr(1) === 0 || W.constantOr(1) === 0)) return;
              const se = x.context, ce = se.gl, me = x.transform, we = x.getDepthModeForSublayer(0, mr.ReadOnly), ye = Ar.disabled, ke = x.colorModeForRenderPass(), Me = [], be = me.getCircleRadiusCorrection();
              for (let Oe = 0; Oe < R.length; Oe++) {
                const Qe = R[Oe], We = k.getTile(Qe), Ze = We.getBucket(P);
                if (!Ze) continue;
                const Je = P.paint.get("circle-translate"), kt = P.paint.get("circle-translate-anchor"), Tt = s.aD(me, We, Je, kt), pt = Ze.programConfigurations.get(P.id), Vt = x.useProgram("circle", pt), _r = Ze.layoutVertexBuffer, Or = Ze.indexBuffer, Xr = x.style.map.terrain && x.style.map.terrain.getTerrainData(Qe), Gr = { programConfiguration: pt, program: Vt, layoutVertexBuffer: _r, indexBuffer: Or, uniformValues: bp(x, We, P, Tt, be), terrainData: Xr, projectionData: me.getProjectionData({ overscaledTileID: Qe, applyGlobeMatrix: !j, applyTerrainMatrix: true }) };
                if (le) {
                  const di = Ze.segments.get();
                  for (const vi of di) Me.push({ segments: new s.aM([vi]), sortKey: vi.sortKey, state: Gr });
                } else Me.push({ segments: Ze.segments, sortKey: 0, state: Gr });
              }
              le && Me.sort(((Oe, Qe) => Oe.sortKey - Qe.sortKey));
              for (const Oe of Me) {
                const { programConfiguration: Qe, program: We, layoutVertexBuffer: Ze, indexBuffer: Je, uniformValues: kt, terrainData: Tt, projectionData: pt } = Oe.state;
                We.draw(se, ce.TRIANGLES, we, ye, ke, nr.backCCW, kt, Tt, pt, P.id, Ze, Je, Oe.segments, P.paint, x.transform.zoom, Qe);
              }
            })(e, a, c, p, _) : s.cd(c) ? (function(x, k, P, R, D) {
              if (P.paint.get("heatmap-opacity") === 0) return;
              const j = x.context, { isRenderingToTexture: $, isRenderingGlobe: V } = D;
              if (x.style.map.terrain) {
                for (const W of R) {
                  const le = k.getTile(W);
                  k.hasRenderableParent(W) || (x.renderPass === "offscreen" ? Dc(x, le, P, W, V) : x.renderPass === "translucent" && Th(x, P, W, $, V));
                }
                j.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(W, le, se, ce) {
                const me = W.context, we = me.gl, ye = W.transform, ke = Ar.disabled, Me = new si([we.ONE, we.ONE], s.bf.transparent, [true, true, true, true]);
                (function(be, Oe, Qe) {
                  const We = be.gl;
                  be.activeTexture.set(We.TEXTURE1), be.viewport.set([0, 0, Oe.width / 4, Oe.height / 4]);
                  let Ze = Qe.heatmapFbos.get(s.c2);
                  Ze ? (We.bindTexture(We.TEXTURE_2D, Ze.colorAttachment.get()), be.bindFramebuffer.set(Ze.framebuffer)) : (Ze = rl(be, Oe.width / 4, Oe.height / 4), Qe.heatmapFbos.set(s.c2, Ze));
                })(me, W, se), me.clear({ color: s.bf.transparent });
                for (let be = 0; be < ce.length; be++) {
                  const Oe = ce[be];
                  if (le.hasRenderableParent(Oe)) continue;
                  const Qe = le.getTile(Oe), We = Qe.getBucket(se);
                  if (!We) continue;
                  const Ze = We.programConfigurations.get(se.id), Je = W.useProgram("heatmap", Ze), kt = ye.getProjectionData({ overscaledTileID: Oe, applyGlobeMatrix: true, applyTerrainMatrix: false }), Tt = ye.getCircleRadiusCorrection();
                  Je.draw(me, we.TRIANGLES, mr.disabled, ke, Me, nr.backCCW, lh(Qe, ye.zoom, se.paint.get("heatmap-intensity"), Tt), null, kt, se.id, We.layoutVertexBuffer, We.indexBuffer, We.segments, se.paint, ye.zoom, Ze);
                }
                me.viewport.set([0, 0, W.width, W.height]);
              })(x, k, P, R) : x.renderPass === "translucent" && (function(W, le) {
                const se = W.context, ce = se.gl;
                se.setColorMode(W.colorModeForRenderPass());
                const me = le.heatmapFbos.get(s.c2);
                me && (se.activeTexture.set(ce.TEXTURE0), ce.bindTexture(ce.TEXTURE_2D, me.colorAttachment.get()), se.activeTexture.set(ce.TEXTURE1), il(se, le).bind(ce.LINEAR, ce.CLAMP_TO_EDGE), W.useProgram("heatmapTexture").draw(se, ce.TRIANGLES, mr.disabled, Ar.disabled, W.colorModeForRenderPass(), nr.disabled, yc(W, le, 0, 1), null, null, le.id, W.viewportBuffer, W.quadTriangleIndexBuffer, W.viewportSegments, le.paint, W.transform.zoom));
              })(x, P);
            })(e, a, c, p, _) : s.ce(c) ? (function(x, k, P, R, D) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = P.paint.get("line-opacity"), V = P.paint.get("line-width");
              if ($.constantOr(1) === 0 || V.constantOr(1) === 0) return;
              const W = x.getDepthModeForSublayer(0, mr.ReadOnly), le = x.colorModeForRenderPass(), se = P.paint.get("line-dasharray"), ce = P.paint.get("line-pattern"), me = ce.constantOr(1), we = P.paint.get("line-gradient"), ye = P.getCrossfadeParameters(), ke = me ? "linePattern" : se ? "lineSDF" : we ? "lineGradient" : "line", Me = x.context, be = Me.gl, Oe = x.transform;
              let Qe = true;
              for (const We of R) {
                const Ze = k.getTile(We);
                if (me && !Ze.patternsLoaded()) continue;
                const Je = Ze.getBucket(P);
                if (!Je) continue;
                const kt = Je.programConfigurations.get(P.id), Tt = x.context.program.get(), pt = x.useProgram(ke, kt), Vt = Qe || pt.program !== Tt, _r = x.style.map.terrain && x.style.map.terrain.getTerrainData(We), Or = ce.constantOr(null);
                if (Or && Ze.imageAtlas) {
                  const vr = Ze.imageAtlas, Yr = vr.patternPositions[Or.to.toString()], Ti = vr.patternPositions[Or.from.toString()];
                  Yr && Ti && kt.setConstantPatternPositions(Yr, Ti);
                }
                const Xr = Oe.getProjectionData({ overscaledTileID: We, applyGlobeMatrix: !j, applyTerrainMatrix: true }), Gr = Oe.getPixelScale(), di = me ? hh(x, Ze, P, Gr, ye) : se ? Ma(x, Ze, P, Gr, se, ye) : we ? dh(x, Ze, P, Gr, Je.lineClipsArray.length) : Kl(x, Ze, P, Gr);
                if (me) Me.activeTexture.set(be.TEXTURE0), Ze.imageAtlasTexture.bind(be.LINEAR, be.CLAMP_TO_EDGE), kt.updatePaintBuffers(ye);
                else if (se && (Vt || x.lineAtlas.dirty)) Me.activeTexture.set(be.TEXTURE0), x.lineAtlas.bind(Me);
                else if (we) {
                  const vr = Je.gradients[P.id];
                  let Yr = vr.texture;
                  if (P.gradientVersion !== vr.version) {
                    let Ti = 256;
                    if (P.stepInterpolant) {
                      const zi = k.getSource().maxzoom, Ni = We.canonical.z === zi ? Math.ceil(1 << x.transform.maxZoom - We.canonical.z) : 1;
                      Ti = s.ah(s.c3(Je.maxLineLength / s.$ * 1024 * Ni), 256, Me.maxTextureSize);
                    }
                    vr.gradient = s.c4({ expression: P.gradientExpression(), evaluationKey: "lineProgress", resolution: Ti, image: vr.gradient || void 0, clips: Je.lineClipsArray }), vr.texture ? vr.texture.update(vr.gradient) : vr.texture = new s.T(Me, vr.gradient, be.RGBA), vr.version = P.gradientVersion, Yr = vr.texture;
                  }
                  Me.activeTexture.set(be.TEXTURE0), Yr.bind(P.stepInterpolant ? be.NEAREST : be.LINEAR, be.CLAMP_TO_EDGE);
                }
                const vi = x.stencilModeForClipping(We);
                pt.draw(Me, be.TRIANGLES, W, vi, le, nr.disabled, di, _r, Xr, P.id, Je.layoutVertexBuffer, Je.indexBuffer, Je.segments, P.paint, x.transform.zoom, kt, Je.layoutVertexBuffer2), Qe = false;
              }
            })(e, a, c, p, _) : s.cf(c) ? (function(x, k, P, R, D) {
              const j = P.paint.get("fill-color"), $ = P.paint.get("fill-opacity");
              if ($.constantOr(1) === 0) return;
              const { isRenderingToTexture: V } = D, W = x.colorModeForRenderPass(), le = P.paint.get("fill-pattern"), se = x.opaquePassEnabledForLayer() && !le.constantOr(1) && j.constantOr(s.bf.transparent).a === 1 && $.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === se) {
                const ce = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? mr.ReadWrite : mr.ReadOnly);
                au(x, k, P, R, ce, W, false, V);
              }
              if (x.renderPass === "translucent" && P.paint.get("fill-antialias")) {
                const ce = x.getDepthModeForSublayer(P.getPaintProperty("fill-outline-color") ? 2 : 0, mr.ReadOnly);
                au(x, k, P, R, ce, W, true, V);
              }
            })(e, a, c, p, _) : s.cg(c) ? (function(x, k, P, R, D) {
              const j = P.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: $ } = D;
              if (x.renderPass === "translucent") {
                const V = new mr(x.context.gl.LEQUAL, mr.ReadWrite, x.depthRangeFor3D);
                if (j !== 1 || P.paint.get("fill-extrusion-pattern").constantOr(1)) zc(x, k, P, R, V, Ar.disabled, si.disabled, $), zc(x, k, P, R, V, x.stencilModeFor3D(), x.colorModeForRenderPass(), $);
                else {
                  const W = x.colorModeForRenderPass();
                  zc(x, k, P, R, V, Ar.disabled, W, $);
                }
              }
            })(e, a, c, p, _) : s.ch(c) ? (function(x, k, P, R, D) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = x.context, V = x.style.projection.useSubdivision, W = x.getDepthModeForSublayer(0, mr.ReadOnly), le = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(se, ce, me, we, ye, ke, Me) {
                const be = se.context, Oe = be.gl;
                for (const Qe of me) {
                  const We = ce.getTile(Qe), Ze = We.dem;
                  if (!Ze || !Ze.data || !We.needsHillshadePrepare) continue;
                  const Je = Ze.dim, kt = Ze.stride, Tt = Ze.getPixels();
                  if (be.activeTexture.set(Oe.TEXTURE1), be.pixelStoreUnpackPremultiplyAlpha.set(false), We.demTexture = We.demTexture || se.getTileTexture(kt), We.demTexture) {
                    const Vt = We.demTexture;
                    Vt.update(Tt, { premultiply: false }), Vt.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE);
                  } else We.demTexture = new s.T(be, Tt, Oe.RGBA, { premultiply: false }), We.demTexture.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE);
                  be.activeTexture.set(Oe.TEXTURE0);
                  let pt = We.fbo;
                  if (!pt) {
                    const Vt = new s.T(be, { width: Je, height: Je, data: null }, Oe.RGBA);
                    Vt.bind(Oe.LINEAR, Oe.CLAMP_TO_EDGE), pt = We.fbo = be.createFramebuffer(Je, Je, true, false), pt.colorAttachment.set(Vt.texture);
                  }
                  be.bindFramebuffer.set(pt.framebuffer), be.viewport.set([0, 0, Je, Je]), se.useProgram("hillshadePrepare").draw(be, Oe.TRIANGLES, ye, ke, Me, nr.disabled, uh(We.tileID, Ze), null, null, we.id, se.rasterBoundsBuffer, se.quadTriangleIndexBuffer, se.rasterBoundsSegments), We.needsHillshadePrepare = false;
                }
              })(x, k, R, P, W, Ar.disabled, le), $.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (V) {
                const [se, ce, me] = x.stencilConfigForOverlapTwoPass(R);
                Da(x, k, P, me, se, W, le, false, j), Da(x, k, P, me, ce, W, le, true, j);
              } else {
                const [se, ce] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                Da(x, k, P, ce, se, W, le, false, j);
              }
            })(e, a, c, p, _) : s.ci(c) ? (function(x, k, P, R, D) {
              if (x.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: j } = D, $ = x.style.projection.useSubdivision, V = x.getDepthModeForSublayer(0, mr.ReadOnly), W = x.colorModeForRenderPass();
              if ($) {
                const [le, se, ce] = x.stencilConfigForOverlapTwoPass(R);
                Fc(x, k, P, ce, le, V, W, false, j), Fc(x, k, P, ce, se, V, W, true, j);
              } else {
                const [le, se] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                Fc(x, k, P, se, le, V, W, false, j);
              }
            })(e, a, c, p, _) : s.cj(c) ? (function(x, k, P, R, D) {
              if (x.renderPass !== "translucent" || P.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: j } = D, $ = k.getSource(), V = x.style.projection.useSubdivision;
              if ($ instanceof ot) za(x, k, P, R, null, false, false, $.tileCoords, $.flippedWindingOrder, j);
              else if (V) {
                const [W, le, se] = x.stencilConfigForOverlapTwoPass(R);
                za(x, k, P, se, W, false, true, su, false, j), za(x, k, P, se, le, true, true, su, false, j);
              } else {
                const [W, le] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                za(x, k, P, le, W, false, true, su, false, j);
              }
            })(e, a, c, p, _) : s.ck(c) ? (function(x, k, P, R, D) {
              const j = P.paint.get("background-color"), $ = P.paint.get("background-opacity");
              if ($ === 0) return;
              const { isRenderingToTexture: V } = D, W = x.context, le = W.gl, se = x.style.projection, ce = x.transform, me = ce.tileSize, we = P.paint.get("background-pattern");
              if (x.isPatternMissing(we)) return;
              const ye = !we && j.a === 1 && $ === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== ye) return;
              const ke = Ar.disabled, Me = x.getDepthModeForSublayer(0, ye === "opaque" ? mr.ReadWrite : mr.ReadOnly), be = x.colorModeForRenderPass(), Oe = x.useProgram(we ? "backgroundPattern" : "background"), Qe = R || Pe(ce, { tileSize: me, terrain: x.style.map.terrain });
              we && (W.activeTexture.set(le.TEXTURE0), x.imageManager.bind(x.context));
              const We = P.getCrossfadeParameters();
              for (const Ze of Qe) {
                const Je = ce.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !V, applyTerrainMatrix: true }), kt = we ? mh($, x, we, { tileID: Ze, tileSize: me }, We) : ph($, j), Tt = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ze), pt = se.getMeshFromTileID(W, Ze.canonical, false, true, "raster");
                Oe.draw(W, le.TRIANGLES, Me, ke, be, nr.backCCW, kt, Tt, Je, P.id, pt.vertexBuffer, pt.indexBuffer, pt.segments);
              }
            })(e, 0, c, p, _) : s.cl(c) && (function(x, k, P, R) {
              const { isRenderingGlobe: D } = R, j = x.context, $ = P.implementation, V = x.style.projection, W = x.transform, le = W.getProjectionDataForCustomLayer(D), se = { farZ: W.farZ, nearZ: W.nearZ, fov: W.fov * Math.PI / 180, modelViewProjectionMatrix: W.modelViewProjectionMatrix, projectionMatrix: W.projectionMatrix, shaderData: { variantName: V.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${V.shaderPreludeCode.vertexSource}`, define: V.shaderDefine }, defaultProjectionData: le }, ce = $.renderingMode ? $.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const me = $.prerender;
                me && (x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), me.call($, j.gl, se), j.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), j.setStencilMode(Ar.disabled);
                const me = ce === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, mr.ReadOnly);
                j.setDepthMode(me), $.render(j.gl, se), j.setDirty(), x.setBaseState(), j.bindFramebuffer.set(null);
              }
            })(e, 0, c, _));
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return false;
            if (!e.from || !e.to) return true;
            const a = this.imageManager.getPattern(e.from.toString()), c = this.imageManager.getPattern(e.to.toString());
            return !a || !c;
          }
          useProgram(e, a, c = false, p = []) {
            this.cache = this.cache || {};
            const _ = !!this.style.map.terrain, x = this.style.projection, k = c ? Dn.projectionMercator : x.shaderPreludeCode, P = c ? Qn : x.shaderDefine, R = e + (a ? a.cacheKey : "") + `/${c ? Bo : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (_ ? "/terrain" : "") + (p ? `/${p.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new _c(this.context, Dn[e], a, Sc[e], this._showOverdrawInspector, _, k, P, p)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: a } = this.context.gl;
            return this.width !== e || this.height !== a;
          }
        }
        function Fa(v, e) {
          let a, c = false, p = null, _ = null;
          const x = () => {
            p = null, c && (v.apply(_, a), p = setTimeout(x, e), c = false);
          };
          return (...k) => (c = true, _ = this, a = k, p || x(), p);
        }
        class cu {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map(((p) => p.split("="))).forEach(((p) => {
                  p[0] === this._hashName && (c = p);
                })), (c && c[1] || "").split("/");
              }
              return a.split("/");
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return false;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: c, pitch: +(a[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a);
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let p = c;
              p.split("&").length > 0 && (p = p.split("&")[0]), this._hashName && (p = `${this._hashName}=${c}`);
              let _ = window.location.hash.replace(p, "");
              _.startsWith("#&") ? _ = _.slice(0, 1) + _.slice(2) : _ === "#" && (_ = "");
              let x = window.location.href.replace(/(#.+)?$/, _);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = Fa(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const a = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, p = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, p), x = Math.round(a.lng * _) / _, k = Math.round(a.lat * _) / _, P = this._map.getBearing(), R = this._map.getPitch();
            let D = "";
            if (D += e ? `/${x}/${k}/${c}` : `${c}/${k}/${x}`, (P || R) && (D += "/" + Math.round(10 * P) / 10), R && (D += `/${Math.round(R)}`), this._hashName) {
              const j = this._hashName;
              let $ = false;
              const V = window.location.hash.slice(1).split("&").map(((W) => {
                const le = W.split("=")[0];
                return le === j ? ($ = true, `${le}=${D}`) : W;
              })).filter(((W) => W));
              return $ || V.push(`${j}=${D}`), `#${V.join("&")}`;
            }
            return `#${D}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return false;
            try {
              new s.S(+e[2], +e[1]);
            } catch {
              return false;
            }
            const a = +e[0], c = +(e[3] || 0), p = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && p >= this._map.getMinPitch() && p <= this._map.getMaxPitch();
          }
        }
        const jo = { linearity: 0.3, easing: s.cm(0, 0, 0.3, 1) }, $c = s.e({ deceleration: 2500, maxSpeed: 1400 }, jo), Rh = s.e({ deceleration: 20, maxSpeed: 1400 }, jo), Ah = s.e({ deceleration: 1e3, maxSpeed: 360 }, jo), Dh = s.e({ deceleration: 1e3, maxSpeed: 90 }, jo), zh = s.e({ deceleration: 1e3, maxSpeed: 360 }, jo);
        class Fh {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: L.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, a = L.now();
            for (; e.length > 0 && a - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: _ } of this._inertiaBuffer) a.zoom += _.zoomDelta || 0, a.bearing += _.bearingDelta || 0, a.pitch += _.pitchDelta || 0, a.roll += _.rollDelta || 0, _.panDelta && a.pan._add(_.panDelta), _.around && (a.around = _.around), _.pinchAround && (a.pinchAround = _.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, p = {};
            if (a.pan.mag()) {
              const _ = ns(a.pan.mag(), c, s.e({}, $c, e || {})), x = a.pan.mult(_.amount / a.pan.mag()), k = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              p.center = k.easingCenter, p.offset = k.easingOffset, ro(p, _);
            }
            if (a.zoom) {
              const _ = ns(a.zoom, c, Rh);
              p.zoom = this._map.transform.zoom + _.amount, ro(p, _);
            }
            if (a.bearing) {
              const _ = ns(a.bearing, c, Ah);
              p.bearing = this._map.transform.bearing + s.ah(_.amount, -179, 179), ro(p, _);
            }
            if (a.pitch) {
              const _ = ns(a.pitch, c, Dh);
              p.pitch = this._map.transform.pitch + _.amount, ro(p, _);
            }
            if (a.roll) {
              const _ = ns(a.roll, c, zh);
              p.roll = this._map.transform.roll + s.ah(_.amount, -179, 179), ro(p, _);
            }
            if (p.zoom || p.bearing) {
              const _ = a.pinchAround === void 0 ? a.around : a.pinchAround;
              p.around = _ ? this._map.unproject(_) : this._map.getCenter();
            }
            return this.clear(), s.e(p, { noMoveStart: true });
          }
        }
        function ro(v, e) {
          (!v.duration || v.duration < e.duration) && (v.duration = e.duration, v.easing = e.easing);
        }
        function ns(v, e, a) {
          const { maxSpeed: c, linearity: p, deceleration: _ } = a, x = s.ah(v * p / (e / 1e3), -c, c), k = Math.abs(x) / (_ * p);
          return { easing: a.easing, duration: 1e3 * k, amount: x * (k / 2) };
        }
        class kn extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c, p = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const _ = A.mousePos(a.getCanvas(), c), x = a.unproject(_);
            super(e, s.e({ point: _, lngLat: x, originalEvent: c }, p)), this._defaultPrevented = false, this.target = a;
          }
        }
        class os extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            const p = e === "touchend" ? c.changedTouches : c.touches, _ = A.touchPos(a.getCanvasContainer(), p), x = _.map(((P) => a.unproject(P))), k = _.reduce(((P, R, D, j) => P.add(R.div(j.length))), new s.P(0, 0));
            super(e, { points: _, point: k, lngLats: x, lngLat: a.unproject(k), originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class jc extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            super(e, { originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class Lh {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new jc(e.type, this._map, e));
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new kn(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new kn(e.type, this._map, e));
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new kn(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new kn(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new kn(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new kn(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new os(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new os(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new os(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new os(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Bh {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new kn(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new kn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new kn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class as {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain);
          }
        }
        class Nc {
          constructor(e, a) {
            this._map = e, this._tr = new as(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (A.disableDrag(), this._startPos = this._lastPos = a, this._active = true);
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const p = this._startPos;
            this._lastPos = c, this._box || (this._box = A.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const _ = Math.min(p.x, c.x), x = Math.max(p.x, c.x), k = Math.min(p.y, c.y), P = Math.max(p.y, c.y);
            A.setTransform(this._box, `translate(${_}px,${k}px)`), this._box.style.width = x - _ + "px", this._box.style.height = P - k + "px";
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos, p = a;
            if (this.reset(), A.suppressClick(), c.x !== p.x || c.y !== p.y) return this._map.fire(new s.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (_) => _.fitScreenCoordinates(c, p, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (A.remove(this._box), this._box = null), A.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, { originalEvent: a }));
          }
        }
        function ss(v, e) {
          if (v.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < v.length; c++) a[v[c].identifier] = e[c];
          return a;
        }
        class Oh {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(p) {
              const _ = new s.P(0, 0);
              for (const x of p) _._add(x);
              return _.div(p.length);
            })(a), this.touches = ss(c, a)));
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const p = ss(c, a);
            for (const _ in this.touches) {
              const x = p[_];
              (!x || x.dist(this.touches[_]) > 30) && (this.aborted = true);
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = true), c.length === 0) {
              const p = !this.aborted && this.centroid;
              if (this.reset(), p) return p;
            }
          }
        }
        class Pn {
          constructor(e) {
            this.singleTap = new Oh(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this.singleTap.touchend(e, a, c);
            if (p) {
              const _ = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(p) < 30;
              if (_ && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = p, this.count === this.numTaps) return this.reset(), p;
            }
          }
        }
        class io {
          constructor(e) {
            this._tr = new as(e), this._zoomIn = new Pn({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Pn({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this._zoomIn.touchend(e, a, c), _ = this._zoomOut.touchend(e, a, c), x = this._tr;
            return p ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(p) }, { originalEvent: e }) }) : _ ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(_) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ls {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = true, a;
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const p = Array.isArray(a) ? a[0] : a;
            return !this._moved && p.dist(c) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = p, this._move(c, p));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && A.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const no = 0, us = 2, zp = { [no]: 1, [us]: 2 };
        class al {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const a = A.mouseButton(e);
            this._eventButton = a;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const p = zp[c];
              return a.buttons === void 0 || (a.buttons & p) !== p;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return A.mouseButton(e) === this._eventButton;
          }
        }
        class Fp {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class Lp {
          constructor(e = new al({ checkCorrectEvent: () => true }), a = new Fp()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a;
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.startMove(a)), ((a) => this.oneFingerTouchMoveStateManager.startMove(a)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.endMove(a)), ((a) => this.oneFingerTouchMoveStateManager.endMove(a)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidStartEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidMoveEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidEndEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)));
          }
        }
        const sl = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class ll {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new s.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = true);
            const p = ss(c, a), _ = new s.P(0, 0), x = new s.P(0, 0);
            let k = 0;
            for (const R in p) {
              const D = p[R], j = this._touches[R];
              j && (_._add(D), x._add(D.sub(j)), k++, p[R] = D);
            }
            if (this._touches = p, this._shouldBePrevented(k) || !x.mag()) return;
            const P = x.div(k);
            return this._sum._add(P), this._sum.mag() < this._clickTolerance ? void 0 : { around: _.div(k), panDelta: P };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class oo {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]));
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [p, _] = this._firstTwoTouches, x = Ft(c, a, p), k = Ft(c, a, _);
            if (!x || !k) return;
            const P = this._aroundCenter ? null : x.add(k).div(2);
            return this._move([x, k], P, e);
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [p, _] = this._firstTwoTouches, x = Ft(c, a, p), k = Ft(c, a, _);
            x && k || (this._active && A.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = true, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Ft(v, e, a) {
          for (let c = 0; c < v.length; c++) if (v[c].identifier === a) return e[c];
        }
        function Vc(v, e) {
          return Math.log(v / e) / Math.LN2;
        }
        class du extends oo {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Vc(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Vc(this._distance, c), pinchAround: a };
          }
        }
        function Uc(v, e) {
          return 180 * v.angleWith(e) / Math.PI;
        }
        class cs extends oo {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, a, c) {
            const p = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Uc(this._vector, p), pinchAround: a };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360, c = Uc(e, this._startVector);
            return Math.abs(c) < a;
          }
        }
        function La(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class hu extends oo {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length;
          }
          _start(e) {
            this._lastPoints = e, La(e[0].sub(e[1])) && (this._valid = false);
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const p = e[0].sub(this._lastPoints[0]), _ = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(p, _, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = true, { pitchDelta: (p.y + _.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const p = e.mag() >= 2, _ = a.mag() >= 2;
            if (!p && !_) return;
            if (!p || !_) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const x = e.y > 0 == a.y > 0;
            return La(e) && La(a) && x;
          }
        }
        const Ir = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class fu {
          constructor(e) {
            this._tr = new as(e);
            const a = Ir;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0, c = 0, p = 0, _ = 0, x = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), _ = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), _ = 1);
                break;
              case 38:
                e.shiftKey ? p = 1 : (e.preventDefault(), x = -1);
                break;
              case 40:
                e.shiftKey ? p = -1 : (e.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, p = 0), { cameraAnimation: (k) => {
              const P = this._tr;
              k.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Bp, zoom: a ? Math.round(P.zoom) + a * (e.shiftKey ? 2 : 1) : P.zoom, bearing: P.bearing + c * this._bearingStep, pitch: P.pitch + p * this._pitchStep, offset: [-_ * this._panStep, -x * this._panStep], center: P.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Bp(v) {
          return v * (2 - v);
        }
        const pu = 4.000244140625, Op = 1 / 450;
        class $h {
          constructor(e, a) {
            this._onTimeout = (c) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
            }, this._map = e, this._tr = new as(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Op;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = L.now(), p = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % pu == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : p > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(p * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = A.mousePos(this._map.getCanvas(), e), c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(s.S.convert(c.center)) : a, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const k = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += k), typeof this._targetZoom == "number" && (this._targetZoom += k);
            }
            if (this._delta !== 0) {
              const k = this._type === "wheel" && Math.abs(this._delta) > pu ? this._wheelZoomRate : this._defaultZoomRate;
              let P = 2 / (1 + Math.exp(-Math.abs(this._delta * k)));
              this._delta < 0 && P !== 0 && (P = 1 / P);
              const R = typeof this._targetZoom != "number" ? e.scale : s.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), s.ak(R * P)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, c = this._startZoom, p = this._easing;
            let _, x = false;
            if (this._type === "wheel" && c && p) {
              const k = L.now() - this._lastWheelEventTime, P = Math.min((k + 5) / 200, 1), R = p(P);
              _ = s.C.number(c, a, R), P < 1 ? this._frameId || (this._frameId = true) : x = true;
            } else _ = a, x = true;
            return this._active = true, x && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = _, { noInertia: true, needsRenderFrame: !x, zoomDelta: _ - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let a = s.co;
            if (this._prevEase) {
              const c = this._prevEase, p = (L.now() - c.start) / c.duration, _ = c.easing(p + 0.01) - c.easing(p), x = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, k = Math.sqrt(0.0729 - x * x);
              a = s.cm(x, k, 0.25, 1);
            }
            return this._prevEase = { start: L.now(), duration: e, easing: a }, a;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Gc {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class qc {
          constructor(e) {
            this._tr = new as(e), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e, a) {
            return e.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(a) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class jh {
          constructor() {
            this._tap = new Pn({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, a, c) {
            if (!this._swipePoint) if (this._tapTime) {
              const p = a[0], _ = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(p) < 30;
              _ && x ? c.length > 0 && (this._swipePoint = p, this._swipeTouch = c[0].identifier) : this.reset();
            } else this._tap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const p = a[0], _ = p.y - this._swipePoint.y;
                return this._swipePoint = p, e.preventDefault(), this._active = true, { zoomDelta: _ / 128 };
              }
            } else this._tap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const p = this._tap.touchend(e, a, c);
              p && (this._tapTime = e.timeStamp, this._tapPoint = p);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Nh {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Wc {
          constructor(e, a, c, p) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = p;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Vh {
          constructor(e, a, c, p) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = p, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Uh {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = A.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), p = document.createElement("div");
            p.className = "maplibregl-desktop-message", p.textContent = a, this._container.appendChild(p);
            const _ = document.createElement("div");
            _.className = "maplibregl-mobile-message", _.textContent = c, this._container.appendChild(_), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (A.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", { gestureType: e, originalEvent: a })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const ao = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class ri extends s.l {
        }
        function ds(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class Zc {
          constructor(e, a) {
            this.handleWindowEvent = (p) => {
              this.handleEvent(p, `${p.type}Window`);
            }, this.handleEvent = (p, _) => {
              if (p.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const x = p.type === "renderFrame" ? void 0 : p, k = { needsRenderFrame: false }, P = {}, R = {};
              for (const { handlerName: $, handler: V, allowed: W } of this._handlers) {
                if (!V.isEnabled()) continue;
                let le;
                if (this._blockedByActive(R, W, $)) V.reset();
                else if (V[_ || p.type]) {
                  if (s.cp(p, _ || p.type)) {
                    const se = A.mousePos(this._map.getCanvas(), p);
                    le = V[_ || p.type](p, se);
                  } else if (s.cq(p, _ || p.type)) {
                    const se = this._getMapTouches(p.touches), ce = A.touchPos(this._map.getCanvas(), se);
                    le = V[_ || p.type](p, ce, se);
                  } else s.cr(_ || p.type) || (le = V[_ || p.type](p));
                  this.mergeHandlerResult(k, P, le, $, x), le && le.needsRenderFrame && this._triggerRenderFrame();
                }
                (le || V.isActive()) && (R[$] = V);
              }
              const D = {};
              for (const $ in this._previousActiveHandlers) R[$] || (D[$] = x);
              this._previousActiveHandlers = R, (Object.keys(D).length || ds(k)) && (this._changes.push([k, P, D]), this._triggerRenderFrame()), (Object.keys(R).length || ds(k)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: j } = k;
              j && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], j(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Fh(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: true }], [c, "touchmove", { passive: false }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: false }], [c, "keyup", void 0], [c, "wheel", { passive: false }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [p, _, x] of this._listeners) A.addEventListener(p, _, p === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [e, a, c] of this._listeners) A.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c);
          }
          _addDefaultHandlers(e) {
            const a = this._map, c = a.getCanvasContainer();
            this._add("mapEvent", new Lh(a, e));
            const p = a.boxZoom = new Nc(a, e);
            this._add("boxZoom", p), e.interactive && e.boxZoom && p.enable();
            const _ = a.cooperativeGestures = new Uh(a, e.cooperativeGestures);
            this._add("cooperativeGestures", _), e.cooperativeGestures && _.enable();
            const x = new io(a), k = new qc(a);
            a.doubleClickZoom = new Gc(k, x), this._add("tapZoom", x), this._add("clickZoom", k), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const P = new jh();
            this._add("tapDragZoom", P);
            const R = a.touchPitch = new hu(a);
            this._add("touchPitch", R), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const D = () => a.project(a.getCenter()), j = (function({ enable: ye, clickTolerance: ke, aroundCenter: Me = true, minPixelCenterThreshold: be = 100, rotateDegreesPerPixelMoved: Oe = 0.8 }, Qe) {
              const We = new al({ checkCorrectEvent: (Ze) => A.mouseButton(Ze) === 0 && Ze.ctrlKey || A.mouseButton(Ze) === 2 && !Ze.ctrlKey });
              return new ls({ clickTolerance: ke, move: (Ze, Je) => {
                const kt = Qe();
                if (Me && Math.abs(kt.y - Ze.y) > be) return { bearingDelta: s.cn(new s.P(Ze.x, Je.y), Je, kt) };
                let Tt = (Je.x - Ze.x) * Oe;
                return Me && Je.y < kt.y && (Tt = -Tt), { bearingDelta: Tt };
              }, moveStateManager: We, enable: ye, assignEvents: sl });
            })(e, D), $ = (function({ enable: ye, clickTolerance: ke, pitchDegreesPerPixelMoved: Me = -0.5 }) {
              const be = new al({ checkCorrectEvent: (Oe) => A.mouseButton(Oe) === 0 && Oe.ctrlKey || A.mouseButton(Oe) === 2 });
              return new ls({ clickTolerance: ke, move: (Oe, Qe) => ({ pitchDelta: (Qe.y - Oe.y) * Me }), moveStateManager: be, enable: ye, assignEvents: sl });
            })(e), V = (function({ enable: ye, clickTolerance: ke, rollDegreesPerPixelMoved: Me = 0.3 }, be) {
              const Oe = new al({ checkCorrectEvent: (Qe) => A.mouseButton(Qe) === 2 && Qe.ctrlKey });
              return new ls({ clickTolerance: ke, move: (Qe, We) => {
                const Ze = be();
                let Je = (We.x - Qe.x) * Me;
                return We.y < Ze.y && (Je = -Je), { rollDelta: Je };
              }, moveStateManager: Oe, enable: ye, assignEvents: sl });
            })(e, D);
            a.dragRotate = new Wc(e, j, $, V), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", $, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", V, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const W = (function({ enable: ye, clickTolerance: ke }) {
              const Me = new al({ checkCorrectEvent: (be) => A.mouseButton(be) === 0 && !be.ctrlKey });
              return new ls({ clickTolerance: ke, move: (be, Oe) => ({ around: Oe, panDelta: Oe.sub(be) }), activateOnStart: true, moveStateManager: Me, enable: ye, assignEvents: sl });
            })(e), le = new ll(e, a);
            a.dragPan = new Nh(c, W, le), this._add("mousePan", W), this._add("touchPan", le, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const se = new cs(), ce = new du();
            a.touchZoomRotate = new Vh(c, ce, se, P), this._add("touchRotate", se, ["touchPan", "touchZoom"]), this._add("touchZoom", ce, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate);
            const me = a.scrollZoom = new $h(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", me, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const we = a.keyboard = new fu(a);
            this._add("keyboard", we), e.interactive && e.keyboard && a.keyboard.enable(), this._add("blockableMapEvent", new Bh(a));
          }
          _add(e, a, c) {
            this._handlers.push({ handlerName: e, handler: a, allowed: c }), this._handlersById[e] = a;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: a } of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!ao(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, a, c) {
            for (const p in e) if (p !== c && (!a || a.indexOf(p) < 0)) return true;
            return false;
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a;
          }
          mergeHandlerResult(e, a, c, p, _) {
            if (!c) return;
            s.e(e, c);
            const x = { handlerName: p, originalEvent: c.originalEvent || _ };
            c.zoomDelta !== void 0 && (a.zoom = x), c.panDelta !== void 0 && (a.drag = x), c.rollDelta !== void 0 && (a.roll = x), c.pitchDelta !== void 0 && (a.pitch = x), c.bearingDelta !== void 0 && (a.rotate = x);
          }
          _applyChanges() {
            const e = {}, a = {}, c = {};
            for (const [p, _, x] of this._changes) p.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(p.panDelta)), p.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + p.zoomDelta), p.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + p.bearingDelta), p.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + p.pitchDelta), p.rollDelta && (e.rollDelta = (e.rollDelta || 0) + p.rollDelta), p.around !== void 0 && (e.around = p.around), p.pinchAround !== void 0 && (e.pinchAround = p.pinchAround), p.noInertia && (e.noInertia = p.noInertia), s.e(a, _), s.e(c, x);
            this._updateMapTransform(e, a, c), this._changes = [];
          }
          _updateMapTransform(e, a, c) {
            const p = this._map, _ = p._getTransformForUpdate(), x = p.terrain;
            if (!(ds(e) || x && this._terrainMovement)) return this._fireEvents(a, c, true);
            p._stop(true);
            let { panDelta: k, zoomDelta: P, bearingDelta: R, pitchDelta: D, rollDelta: j, around: $, pinchAround: V } = e;
            V !== void 0 && ($ = V), $ = $ || p.transform.centerPoint, x && !_.isPointOnMapSurface($) && ($ = _.centerPoint);
            const W = { panDelta: k, zoomDelta: P, rollDelta: j, pitchDelta: D, bearingDelta: R, around: $ };
            this._map.cameraHelper.useGlobeControls && !_.isPointOnMapSurface($) && ($ = _.centerPoint);
            const le = $.distSqr(_.centerPoint) < 0.01 ? _.center : _.screenPointToLocation(k ? $.sub(k) : $);
            x ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(W, _), this._terrainMovement || !a.drag && !a.zoom ? a.drag && this._terrainMovement ? _.setCenter(_.screenPointToLocation(_.centerPoint.sub(k))) : this._map.cameraHelper.handleMapControlsPan(W, _, le) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(W, _, le))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(W, _), this._map.cameraHelper.handleMapControlsPan(W, _, le)), p._applyUpdatedTransform(_), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, true);
          }
          _fireEvents(e, a, c) {
            const p = ao(this._eventsInProgress), _ = ao(e), x = {};
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._eventsInProgress[j] || (x[`${j}start`] = $), this._eventsInProgress[j] = e[j];
            }
            !p && _ && this._fireEvent("movestart", _.originalEvent);
            for (const j in x) this._fireEvent(j, x[j]);
            _ && this._fireEvent("move", _.originalEvent);
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._fireEvent(j, $);
            }
            const k = {};
            let P;
            for (const j in this._eventsInProgress) {
              const { handlerName: $, originalEvent: V } = this._eventsInProgress[j];
              this._handlersById[$].isActive() || (delete this._eventsInProgress[j], P = a[$] || V, k[`${j}end`] = P);
            }
            for (const j in k) this._fireEvent(j, k[j]);
            const R = ao(this._eventsInProgress), D = (p || _) && !R;
            if (D && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j);
            }
            if (c && D) {
              this._updatingCamera = true;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (V) => V !== 0 && -this._bearingSnap < V && V < this._bearingSnap;
              !j || !j.essential && L.prefersReducedMotion ? (this._map.fire(new s.l("moveend", { originalEvent: P })), $(this._map.getBearing()) && this._map.resetNorth()) : ($(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = true, this._map.easeTo(j, { originalEvent: P })), this._updatingCamera = false;
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? { originalEvent: a } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new ri("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Gh extends s.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const p = Math.min((L.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(p)), p < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a;
          }
          getCenter() {
            return new s.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, a) {
            return this.jumpTo({ center: e }, a);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, a) {
            return this.jumpTo({ elevation: e }, a), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, a, c) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({ offset: e }, a), c);
          }
          panTo(e, a, c) {
            return this.easeTo(s.e({ center: e }, a), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, a) {
            return this.jumpTo({ zoom: e }, a), this;
          }
          zoomTo(e, a, c) {
            return this.easeTo(s.e({ zoom: e }, a), c);
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this;
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, a) {
            return this.jumpTo({ bearing: e }, a), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, a) {
            return this.jumpTo({ padding: e }, a), this;
          }
          rotateTo(e, a, c) {
            return this.easeTo(s.e({ bearing: e }, a), c);
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({ duration: 1e3 }, e), a), this;
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), a), this;
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, a) {
            return this.jumpTo({ pitch: e }, a), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, a) {
            return this.jumpTo({ roll: e }, a), this;
          }
          cameraForBounds(e, a) {
            e = sr.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a);
          }
          _cameraForBoxAndBearing(e, a, c, p) {
            const _ = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (p = s.e({ padding: _, offset: [0, 0], maxZoom: this.transform.maxZoom }, p)).padding == "number") {
              const R = p.padding;
              p.padding = { top: R, bottom: R, right: R, left: R };
            }
            const x = s.e(_, p.padding);
            p.padding = x;
            const k = this.transform, P = new sr(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(p, x, P, c, k);
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c);
          }
          fitScreenCoordinates(e, a, c, p, _) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), c, p), p, _);
          }
          _fitInternal(e, a, c) {
            return e ? (delete (a = s.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this;
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let p = false, _ = false, x = false;
            const k = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const P = c.zoom !== k;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (p = true, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (_ = true, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (x = true, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), P && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), p && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), _ && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), x && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a));
          }
          calculateCameraOptionsFromTo(e, a, c, p = 0) {
            const _ = s.a1.fromLngLat(e, a), x = s.a1.fromLngLat(c, p), k = x.x - _.x, P = x.y - _.y, R = x.z - _.z, D = Math.hypot(k, P, R);
            if (D === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(k, P), $ = s.ak(this.transform.cameraToCenterDistance / D / this.transform.tileSize), V = 180 * Math.atan2(k, -P) / Math.PI;
            let W = 180 * Math.acos(j / D) / Math.PI;
            return W = R < 0 ? 90 - W : 90 + W, { center: x.toLngLat(), elevation: p, zoom: $, pitch: W, bearing: V };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, p, _) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, p);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: c, pitch: p, roll: _ };
          }
          easeTo(e, a) {
            this._stop(false, e.easeId), ((e = s.e({ offset: [0, 0], duration: 500, easing: s.co }, e)).animate === false || !e.essential && L.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(), p = this.getBearing(), _ = c.pitch, x = c.roll, k = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, P = "pitch" in e ? +e.pitch : _, R = "roll" in e ? this._normalizeBearing(e.roll, x) : x, D = "padding" in e ? e.padding : c.padding, j = s.P.convert(e.offset);
            let $, V;
            e.around && ($ = s.S.convert(e.around), V = c.locationToScreenPoint($));
            const W = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, le = this.cameraHelper.handleEaseTo(c, { bearing: k, pitch: P, roll: R, padding: D, around: $, aroundPoint: V, offsetAsPoint: j, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || p !== k, this._pitching = this._pitching || P !== _, this._rolling = this._rolling || R !== x, this._padding = !c.isPaddingEqual(D), this._zooming = this._zooming || le.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, W), this.terrain && this._prepareElevation(le.elevationCenter), this._ease(((se) => {
              le.easeFunc(se), this.terrain && !e.freezeElevation && this._updateElevation(se), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), ((se) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, se);
            }), e), this;
          }
          _prepareEase(e, a, c = {}) {
            this._moving = true, a || c.moving || this.fire(new s.l("movestart", e)), this._zooming && !c.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new s.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a;
            }
            this.transform.setElevation(s.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(), c = e.getCameraAltitude(), p = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < p) {
              const _ = this.calculateCameraOptionsFromTo(a, p, e.center, e.elevation);
              return { pitch: _.pitch, zoom: _.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push(((p) => this._elevateCameraIfInsideTerrain(p))), this.transformCameraUpdate && a.push(((p) => this.transformCameraUpdate(p))), !a.length) return;
            const c = e.clone();
            for (const p of a) {
              const _ = c.clone(), { center: x, zoom: k, roll: P, pitch: R, bearing: D, elevation: j } = p(_);
              x && _.setCenter(x), j !== void 0 && _.setElevation(j), k !== void 0 && _.setZoom(k), P !== void 0 && _.setRoll(P), R !== void 0 && _.setPitch(R), D !== void 0 && _.setBearing(D), c.apply(_);
            }
            this.transform.apply(c);
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e));
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming, p = this._rotating, _ = this._pitching, x = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, c && this.fire(new s.l("zoomend", e)), p && this.fire(new s.l("rotateend", e)), _ && this.fire(new s.l("pitchend", e)), x && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e));
          }
          flyTo(e, a) {
            if (!e.essential && L.prefersReducedMotion) {
              const Je = s.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Je, a);
            }
            this.stop(), e = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.co }, e);
            const c = this._getTransformForUpdate(), p = c.bearing, _ = c.pitch, x = c.roll, k = c.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, R = "pitch" in e ? +e.pitch : _, D = "roll" in e ? this._normalizeBearing(e.roll, x) : x, j = "padding" in e ? e.padding : c.padding, $ = s.P.convert(e.offset);
            let V = c.centerPoint.add($);
            const W = c.screenPointToLocation(V), le = this.cameraHelper.handleFlyTo(c, { bearing: P, pitch: R, roll: D, padding: j, locationAtOffset: W, offsetAsPoint: $, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let se = e.curve;
            const ce = Math.max(c.width, c.height), me = ce / le.scaleOfZoom, we = le.pixelPathLength;
            typeof le.scaleOfMinZoom == "number" && (se = Math.sqrt(ce / le.scaleOfMinZoom / we * 2));
            const ye = se * se;
            function ke(Je) {
              const kt = (me * me - ce * ce + (Je ? -1 : 1) * ye * ye * we * we) / (2 * (Je ? me : ce) * ye * we);
              return Math.log(Math.sqrt(kt * kt + 1) - kt);
            }
            function Me(Je) {
              return (Math.exp(Je) - Math.exp(-Je)) / 2;
            }
            function be(Je) {
              return (Math.exp(Je) + Math.exp(-Je)) / 2;
            }
            const Oe = ke(false);
            let Qe = function(Je) {
              return be(Oe) / be(Oe + se * Je);
            }, We = function(Je) {
              return ce * ((be(Oe) * (Me(kt = Oe + se * Je) / be(kt)) - Me(Oe)) / ye) / we;
              var kt;
            }, Ze = (ke(true) - Oe) / se;
            if (Math.abs(we) < 2e-6 || !isFinite(Ze)) {
              if (Math.abs(ce - me) < 1e-6) return this.easeTo(e, a);
              const Je = me < ce ? -1 : 1;
              Ze = Math.abs(Math.log(me / ce)) / se, We = () => 0, Qe = (kt) => Math.exp(Je * se * kt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Ze / ("screenSpeed" in e ? +e.screenSpeed / se : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = true, this._rotating = p !== P, this._pitching = R !== _, this._rolling = D !== x, this._padding = !c.isPaddingEqual(j), this._prepareEase(a, false), this.terrain && this._prepareElevation(le.targetCenter), this._ease(((Je) => {
              const kt = Je * Ze, Tt = 1 / Qe(kt), pt = We(kt);
              this._rotating && c.setBearing(s.C.number(p, P, Je)), this._pitching && c.setPitch(s.C.number(_, R, Je)), this._rolling && c.setRoll(s.C.number(x, D, Je)), this._padding && (c.interpolatePadding(k, j, Je), V = c.centerPoint.add($)), le.easeFunc(Je, Tt, pt, V), this.terrain && !e.freezeElevation && this._updateElevation(Je), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const p = this._onEaseEnd;
              delete this._onEaseEnd, p.call(this, a);
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(false), this;
          }
          _ease(e, a, c) {
            c.animate === false || c.duration === 0 ? (e(1), a()) : (this._easeStart = L.now(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, a) {
            e = s.aO(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const Hc = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Xc {
          constructor(e = Hc) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (a) => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = A.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = A.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = A.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((p) => typeof p != "string" ? "" : p))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const p = this._map.style.stylesheet;
              this.styleOwner = p.owner, this.styleId = p.id;
            }
            const a = this._map.style.sourceCaches;
            for (const p in a) {
              const _ = a[p];
              if (_.used || _.usedForTerrain) {
                const x = _.getSource();
                x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
              }
            }
            e = e.filter(((p) => String(p).trim())), e.sort(((p, _) => p.length - _.length)), e = e.filter(((p, _) => {
              for (let x = _ + 1; x < e.length; x++) if (e[x].indexOf(p) >= 0) return false;
              return true;
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = A.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class qh {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = A.create("div", "maplibregl-ctrl");
            const a = A.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Io {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({ callback: e, id: a, cancelled: false }), a;
          }
          remove(e) {
            const a = this._currentlyRunning, c = a ? this._queue.concat(a) : this._queue;
            for (const p of c) if (p.id === e) return void (p.cancelled = true);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a) if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var mu = s.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Gt extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = L.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = true, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e, a) {
            this.sourceCache.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const p of Pe(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: a, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) c[p.key] = true, this._renderableTilesKeys.push(p.key), this._tiles[p.key] || (p.terrainRttPosMatrix32f = new Float64Array(16), s.bY(p.terrainRttPosMatrix32f, 0, s.$, s.$, 0, 0, 1), this._tiles[p.key] = new wi(p, this.tileSize), this._lastTilesetChange = L.now());
            for (const p in this._tiles) c[p] || delete this._tiles[p];
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const p = this._tiles[c].tileID, _ = e.clone(), x = s.ba();
              if (p.canonical.equals(e.canonical)) s.bY(x, 0, s.$, s.$, 0, 0, 1);
              else if (p.canonical.isChildOf(e.canonical)) {
                const k = p.canonical.z - e.canonical.z, P = p.canonical.x - (p.canonical.x >> k << k), R = p.canonical.y - (p.canonical.y >> k << k), D = s.$ >> k;
                s.bY(x, 0, D, D, 0, 0, 1), s.M(x, x, [-P * D, -R * D, 0]);
              } else {
                if (!e.canonical.isChildOf(p.canonical)) continue;
                {
                  const k = e.canonical.z - p.canonical.z, P = e.canonical.x - (e.canonical.x >> k << k), R = e.canonical.y - (e.canonical.y >> k << k), D = s.$ >> k;
                  s.bY(x, 0, s.$, s.$, 0, 0, 1), s.M(x, x, [P * D, R * D, 0]), s.N(x, x, [1 / 2 ** k, 1 / 2 ** k, 0]);
                }
              }
              _.terrainRttPosMatrix32f = new Float32Array(x), a[c] = _;
            }
            return a;
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const p of this._renderableTilesKeys) {
              const _ = this._tiles[p].tileID;
              if (!this._isWithinTileRanges(_, a)) continue;
              const x = e.clone(), k = s.ba();
              if (_.canonical.z === e.canonical.z) {
                const P = e.canonical.x - _.canonical.x, R = e.canonical.y - _.canonical.y;
                s.bY(k, 0, s.$, s.$, 0, 0, 1), s.M(k, k, [P * s.$, R * s.$, 0]);
              } else if (_.canonical.z > e.canonical.z) {
                const P = _.canonical.z - e.canonical.z, R = _.canonical.x - (_.canonical.x >> P << P), D = _.canonical.y - (_.canonical.y >> P << P), j = e.canonical.x - (_.canonical.x >> P), $ = e.canonical.y - (_.canonical.y >> P), V = s.$ >> P;
                s.bY(k, 0, V, V, 0, 0, 1), s.M(k, k, [-R * V + j * s.$, -D * V + $ * s.$, 0]);
              } else {
                const P = e.canonical.z - _.canonical.z, R = e.canonical.x - (e.canonical.x >> P << P), D = e.canonical.y - (e.canonical.y >> P << P), j = (e.canonical.x >> P) - _.canonical.x, $ = (e.canonical.y >> P) - _.canonical.y, V = s.$ << P;
                s.bY(k, 0, V, V, 0, 0, 1), s.M(k, k, [R * s.$ + j * V, D * s.$ + $ * V, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(k), c[p] = x;
            }
            return c;
          }
          getSourceTile(e, a) {
            const c = this.sourceCache._source;
            let p = e.overscaledZ - this.deltaZoom;
            if (p > c.maxzoom && (p = c.maxzoom), p < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(p).key);
            let _ = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!_ || !_.dem) && a) for (; p >= c.minzoom && (!_ || !_.dem); ) _ = this.sourceCache.getTileByID(e.scaledTo(p--).key);
            return _;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY;
          }
        }
        class er {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new Gt(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, a, c, p = s.$) {
            var _;
            if (!(a >= 0 && a < p && c >= 0 && c < p)) return 0;
            const x = this.getTerrainData(e), k = (_ = x.tile) === null || _ === void 0 ? void 0 : _.dem;
            if (!k) return 0;
            const P = s.cs([], [a / p * s.$, c / p * s.$], x.u_terrain_matrix), R = [P[0] * k.dim, P[1] * k.dim], D = Math.floor(R[0]), j = Math.floor(R[1]), $ = R[0] - D, V = R[1] - j;
            return k.get(D, j) * (1 - $) * (1 - V) + k.get(D + 1, j) * $ * (1 - V) + k.get(D, j + 1) * (1 - $) * V + k.get(D + 1, j + 1) * $ * V;
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.ct(a, e.wrap())) return 0;
            const { tileID: c, mercatorX: p, mercatorY: _ } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, p % s.$, _ % s.$, s.$);
          }
          getElevation(e, a, c, p = s.$) {
            return this.getDEMElevation(e, a, c, p) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const p = this.painter.context, _ = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(p, _, p.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(p, new s.R({ width: 1, height: 1 }), p.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.ag([]);
            }
            const a = this.sourceCache.getSourceTile(e, true);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const p = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), { premultiply: false }) : a.demTexture = new s.T(p, a.dem.getPixels(), p.gl.RGBA, { premultiply: false }), a.demTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = false;
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const p = this.sourceCache.sourceCache._source.maxzoom;
              let _ = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= p ? _ = e.canonical.z - p : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = e.canonical.x - (e.canonical.x >> _ << _), k = e.canonical.y - (e.canonical.y >> _ << _), P = s.cu(new Float64Array(16), [1 / (s.$ << _), 1 / (s.$ << _), 0]);
              s.M(P, P, [x * s.$, k * s.$, 0]), this._demMatrixCache[e.key] = { matrix: P, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: a && a.dem && a.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (a && a.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: a };
          }
          getFramebuffer(e) {
            const a = this.painter, c = a.width / devicePixelRatio, p = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === p || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, p, true, false), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, p))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let _ = 0, x = 0; _ < this._coordsTextureSize; _++) for (let k = 0; k < this._coordsTextureSize; k++, x += 4) a[x + 0] = 255 & k, a[x + 1] = 255 & _, a[x + 2] = k >> 8 << 4 | _ >> 8, a[x + 3] = 0;
            const c = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(a.buffer)), p = new s.T(e, c, e.gl.RGBA, { premultiply: false });
            return p.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = p, p;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(true);
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl, _ = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), k = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), p.readPixels(_, k - x - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const P = a[0] + (a[2] >> 4 << 8), R = a[1] + ((15 & a[2]) << 8), D = this.coordsIndex[255 - a[3]], j = D && this.sourceCache.getTileByID(D);
            if (!j) return null;
            const $ = this._coordsTextureSize, V = (1 << j.tileID.canonical.z) * $;
            return new s.a1((j.tileID.canonical.x * $ + P) / V + j.tileID.wrap, (j.tileID.canonical.y * $ + R) / V, this.getElevation(j.tileID, P, R, $));
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), p.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256;
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0, p = c && e.canonical.y === 0, _ = c && e.canonical.y === (1 << e.canonical.z) - 1, x = `m_${p ? "n" : ""}_${_ ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const k = this.painter.context, P = new s.cv(), R = new s.aN(), D = this.meshSize, j = s.$ / D, $ = D * D;
            for (let be = 0; be <= D; be++) for (let Oe = 0; Oe <= D; Oe++) P.emplaceBack(Oe * j, be * j, 0);
            for (let be = 0; be < $; be += D + 1) for (let Oe = 0; Oe < D; Oe++) R.emplaceBack(Oe + be, D + Oe + be + 1, D + Oe + be + 2), R.emplaceBack(Oe + be, D + Oe + be + 2, Oe + be + 1);
            const V = P.length, W = V + (D + 1), le = (D + 1) * D, se = p ? s.bh : 0, ce = p ? 0 : 1, me = _ ? s.bi : s.$, we = _ ? 0 : 1;
            for (let be = 0; be <= D; be++) P.emplaceBack(be * j, se, ce);
            for (let be = 0; be <= D; be++) P.emplaceBack(be * j, me, we);
            for (let be = 0; be < D; be++) R.emplaceBack(le + be, W + be, W + be + 1), R.emplaceBack(le + be, W + be + 1, le + be + 1), R.emplaceBack(0 + be, V + be + 1, V + be), R.emplaceBack(0 + be, 0 + be + 1, V + be + 1);
            const ye = P.length, ke = ye + 2 * (D + 1);
            for (const be of [0, 1]) for (let Oe = 0; Oe <= D; Oe++) for (const Qe of [0, 1]) P.emplaceBack(be * s.$, Oe * j, Qe);
            for (let be = 0; be < 2 * D; be += 2) R.emplaceBack(ye + be, ye + be + 1, ye + be + 3), R.emplaceBack(ye + be, ye + be + 3, ye + be + 2), R.emplaceBack(ke + be, ke + be + 3, ke + be + 1), R.emplaceBack(ke + be, ke + be + 2, ke + be + 3);
            const Me = new Lo(k.createVertexBuffer(P, mu.members), k.createIndexBuffer(R), s.aM.simpleSegment(0, 0, P.length, R.length));
            return this._meshCache[x] = Me, Me;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const { tileID: p } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(p).minElevation) !== null && c !== void 0 ? c : 0;
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile, c = { minElevation: null, maxElevation: null };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c;
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = s.a1.fromLngLat(e.wrap()), p = (1 << a) * s.$, _ = c.x * p, x = c.y * p, k = Math.floor(_ / s.$), P = Math.floor(x / s.$);
            return { tileID: new s.Z(a, 0, a, k, P), mercatorX: _, mercatorY: x };
          }
        }
        class gu {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), c = new s.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), { id: e, fbo: a, texture: c, stamp: -1, inUse: false };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((a) => e.id !== a)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed) if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = false;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === false;
          }
        }
        const sa = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class vu {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new gu(e.context, 30, a.sourceCache.tileSize * a.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((c) => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.sourceCaches) {
              this._coordsAscending[c] = {};
              const p = e.sourceCaches[c].getVisibleCoordinates(), _ = e.sourceCaches[c].getSource(), x = _ instanceof ot ? _.terrainTileRanges : null;
              for (const k of p) {
                const P = this.terrain.sourceCache.getTerrainCoords(k, x);
                for (const R in P) this._coordsAscending[c][R] || (this._coordsAscending[c][R] = []), this._coordsAscending[c][R].push(P[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const p = e._layers[c], _ = p.source;
              if (sa[p.type] && !this._coordsAscendingStr[_]) {
                this._coordsAscendingStr[_] = {};
                for (const x in this._coordsAscending[_]) this._coordsAscendingStr[_][x] = this._coordsAscending[_][x].map(((k) => k.key)).sort().join();
              }
            }
            for (const c of this._renderableTiles) for (const p in this._coordsAscendingStr) {
              const _ = this._coordsAscendingStr[p][c.tileID.key];
              _ && _ !== c.rttCoords[p] && (c.rtt = []);
            }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return false;
            const c = Object.assign(Object.assign({}, a), { isRenderingToTexture: true }), p = e.type, _ = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (sa[p] && (this._prevType && sa[this._prevType] || this._stacks.push([]), this._prevType = p, this._stacks[this._stacks.length - 1].push(e.id), !x)) return true;
            if (sa[this._prevType] || sa[p] && x) {
              this._prevType = p;
              const k = this._stacks.length - 1, P = this._stacks[k] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (uu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[k]) {
                  const j = this.pool.getObjectForId(R.rtt[k].id);
                  if (j.stamp === R.rtt[k].stamp) {
                    this.pool.useObject(j);
                    continue;
                  }
                }
                const D = this.pool.getOrCreateFreeObject();
                this.pool.useObject(D), this.pool.stampObject(D), R.rtt[k] = { id: D.id, stamp: D.stamp }, _.context.bindFramebuffer.set(D.fbo.framebuffer), _.context.clear({ color: s.bf.transparent, stencil: 0 }), _.currentStencilSource = void 0;
                for (let j = 0; j < P.length; j++) {
                  const $ = _.style._layers[P[j]], V = $.source ? this._coordsAscending[$.source][R.tileID.key] : [R.tileID];
                  _.context.viewport.set([0, 0, D.fbo.width, D.fbo.height]), _._renderTileClippingMasks($, V, true), _.renderLayer(_, _.style.sourceCaches[$.source], $, V, c), $.source && (R.rttCoords[$.source] = this._coordsAscendingStr[$.source][R.tileID.key]);
                }
              }
              return uu(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), sa[p];
            }
            return false;
          }
        }
        const gn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Wh = C, Wn = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Hc, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, $p = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class ul {
          constructor(e, a, c = false) {
            this.mousedown = (_) => {
              this.startMove(_, A.mousePos(this.element, _)), A.addEventListener(window, "mousemove", this.mousemove), A.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (_) => {
              this.move(_, A.mousePos(this.element, _));
            }, this.mouseup = (_) => {
              this._rotatePitchHandler.dragEnd(_), this.offTemp();
            }, this.touchstart = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = A.touchPos(this.element, _.targetTouches)[0], this.startMove(_, this._startPos), A.addEventListener(window, "touchmove", this.touchmove, { passive: false }), A.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._lastPos = A.touchPos(this.element, _.targetTouches)[0], this.move(_, this._lastPos));
            }, this.touchend = (_) => {
              _.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = a;
            const p = new Lp();
            this._rotatePitchHandler = new ls({ clickTolerance: 3, move: (_, x) => {
              const k = a.getBoundingClientRect(), P = new s.P((k.bottom - k.top) / 2, (k.right - k.left) / 2);
              return { bearingDelta: s.cn(new s.P(_.x, x.y), x, P), pitchDelta: c ? -0.5 * (x.y - _.y) : void 0 };
            }, moveStateManager: p, enable: true, assignEvents: () => {
            } }), this.map = e, A.addEventListener(a, "mousedown", this.mousedown), A.addEventListener(a, "touchstart", this.touchstart, { passive: false }), A.addEventListener(a, "touchcancel", this.reset);
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), A.disableDrag();
          }
          move(e, a) {
            const c = this.map, { bearingDelta: p, pitchDelta: _ } = this._rotatePitchHandler.dragMove(e, a) || {};
            p && c.setBearing(c.getBearing() + p), _ && c.setPitch(c.getPitch() + _);
          }
          off() {
            const e = this.element;
            A.removeEventListener(e, "mousedown", this.mousedown), A.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend), A.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            A.enableDrag(), A.removeEventListener(window, "mousemove", this.mousemove), A.removeEventListener(window, "mouseup", this.mouseup), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Hr;
        function bi(v, e, a, c = false) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return v == null ? void 0 : v.wrap();
          const p = new s.S(v.lng, v.lat);
          if (v = new s.S(v.lng, v.lat), e) {
            const _ = new s.S(v.lng - 360, v.lat), x = new s.S(v.lng + 360, v.lat), k = a.locationToScreenPoint(v).distSqr(e);
            a.locationToScreenPoint(_).distSqr(e) < k ? v = _ : a.locationToScreenPoint(x).distSqr(e) < k && (v = x);
          }
          for (; Math.abs(v.lng - a.center.lng) > 180; ) {
            const _ = a.locationToScreenPoint(v);
            if (_.x >= 0 && _.y >= 0 && _.x <= a.width && _.y <= a.height) break;
            v.lng > a.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== p.lng && a.isPointOnMapSurface(a.locationToScreenPoint(v)) ? v : p;
        }
        const _u = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function hs(v, e, a) {
          const c = v.classList;
          for (const p in _u) c.remove(`maplibregl-${a}-anchor-${p}`);
          c.add(`maplibregl-${a}-anchor-${e}`);
        }
        class fs extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = (a) => {
              const c = a.code, p = a.charCode || a.keyCode;
              c !== "Space" && c !== "Enter" && p !== 32 && p !== 13 || this.togglePopup();
            }, this._onMapClick = (a) => {
              const c = a.originalEvent.target, p = this._element;
              this._popup && (c === p || p.contains(c)) && this.togglePopup();
            }, this._update = (a) => {
              if (!this._map) return;
              const c = this._map.loaded() && !this._map.isMoving();
              ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = bi(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let p = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let _ = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), A.setTransform(this._element, `${_u[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${_} ${p}`), L.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(a && a.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (a) => {
              if (!this._isDragging) {
                const c = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = a.point.dist(this._pointerdownPos) >= c;
              }
              this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (a) => {
              this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || false, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = A.create("div");
              const a = A.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, p = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${p}px`), a.setAttributeNS(null, "viewBox", `0 0 ${p} ${c}`);
              const _ = A.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "stroke", "none"), _.setAttributeNS(null, "stroke-width", "1"), _.setAttributeNS(null, "fill", "none"), _.setAttributeNS(null, "fill-rule", "evenodd");
              const x = A.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const k = A.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), k.setAttributeNS(null, "fill", "#000000");
              const P = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const ce of P) {
                const me = A.createNS("http://www.w3.org/2000/svg", "ellipse");
                me.setAttributeNS(null, "opacity", "0.04"), me.setAttributeNS(null, "cx", "10.5"), me.setAttributeNS(null, "cy", "5.80029008"), me.setAttributeNS(null, "rx", ce.rx), me.setAttributeNS(null, "ry", ce.ry), k.appendChild(me);
              }
              const R = A.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const D = A.createNS("http://www.w3.org/2000/svg", "path");
              D.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(D);
              const j = A.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const $ = A.createNS("http://www.w3.org/2000/svg", "path");
              $.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild($);
              const V = A.createNS("http://www.w3.org/2000/svg", "g");
              V.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), V.setAttributeNS(null, "fill", "#FFFFFF");
              const W = A.createNS("http://www.w3.org/2000/svg", "g");
              W.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const le = A.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#000000"), le.setAttributeNS(null, "opacity", "0.25"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962");
              const se = A.createNS("http://www.w3.org/2000/svg", "circle");
              se.setAttributeNS(null, "fill", "#FFFFFF"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962"), W.appendChild(le), W.appendChild(se), x.appendChild(k), x.appendChild(R), x.appendChild(j), x.appendChild(V), x.appendChild(W), a.appendChild(x), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", p * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((a) => {
              a.preventDefault();
            })), this._element.addEventListener("mousedown", ((a) => {
              a.preventDefault();
            })), hs(this._element, this._anchor, "marker"), e && e.className) for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), A.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = s.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const p = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [p, -1 * (38.1 - 13.5 + p)], "bottom-right": [-p, -1 * (38.1 - 13.5 + p)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = false) {
            var a, c;
            const p = (a = this._map) === null || a === void 0 ? void 0 : a.terrain, _ = this._map.transform.isLocationOccluded(this._lngLat);
            if (!p || _) {
              const V = _ ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== V && (this._element.style.opacity = V));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, k = x.terrain.depthAtPoint(this._pos), P = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, P) - k < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / x.transform.pixelsPerMeter, D = Math.sin(x.getPitch() * Math.PI / 180) * R, j = x.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), $ = x.transform.lngLatToCameraDepth(this._lngLat, P + D) - j > 6e-3;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && $ && this._popup.remove(), this._element.style.opacity = $ ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(true), this;
          }
        }
        const Yc = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let ps = 0, Ba = false;
        const cl = { maxWidth: 100, unit: "metric" };
        function yu(v, e, a) {
          const c = a && a.maxWidth || 100, p = v._container.clientHeight / 2, _ = v._container.clientWidth / 2, x = v.unproject([_ - c / 2, p]), k = v.unproject([_ + c / 2, p]), P = Math.round(v.project(k).x - v.project(x).x), R = Math.min(c, P, v._container.clientWidth), D = x.distanceTo(k);
          if (a && a.unit === "imperial") {
            const j = 3.2808 * D;
            j > 5280 ? Oa(e, R, j / 5280, v._getUIString("ScaleControl.Miles")) : Oa(e, R, j, v._getUIString("ScaleControl.Feet"));
          } else a && a.unit === "nautical" ? Oa(e, R, D / 1852, v._getUIString("ScaleControl.NauticalMiles")) : D >= 1e3 ? Oa(e, R, D / 1e3, v._getUIString("ScaleControl.Kilometers")) : Oa(e, R, D, v._getUIString("ScaleControl.Meters"));
        }
        function Oa(v, e, a, c) {
          const p = (function(_) {
            const x = Math.pow(10, `${Math.floor(_)}`.length - 1);
            let k = _ / x;
            return k = k >= 10 ? 10 : k >= 5 ? 5 : k >= 3 ? 3 : k >= 2 ? 2 : k >= 1 ? 1 : (function(P) {
              const R = Math.pow(10, Math.ceil(-Math.log(P) / Math.LN10));
              return Math.round(P * R) / R;
            })(k), x * k;
          })(a);
          v.style.width = e * (p / a) + "px", v.innerHTML = `${p}&nbsp;${c}`;
        }
        const Kc = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Jc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function bu(v) {
          if (v) {
            if (typeof v == "number") {
              const e = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new s.P(0, 0), top: new s.P(0, v), "top-left": new s.P(e, e), "top-right": new s.P(-e, e), bottom: new s.P(0, -v), "bottom-left": new s.P(e, -e), "bottom-right": new s.P(-e, -e), left: new s.P(v, 0), right: new s.P(-v, 0) };
            }
            if (v instanceof s.P || Array.isArray(v)) {
              const e = s.P.convert(v);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: s.P.convert(v.center || [0, 0]), top: s.P.convert(v.top || [0, 0]), "top-left": s.P.convert(v["top-left"] || [0, 0]), "top-right": s.P.convert(v["top-right"] || [0, 0]), bottom: s.P.convert(v.bottom || [0, 0]), "bottom-left": s.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(v["bottom-right"] || [0, 0]), left: s.P.convert(v.left || [0, 0]), right: s.P.convert(v.right || [0, 0]) };
          }
          return bu(new s.P(0, 0));
        }
        const Qc = C;
        m.AJAXError = s.cz, m.Event = s.l, m.Evented = s.E, m.LngLat = s.S, m.MercatorCoordinate = s.a1, m.Point = s.P, m.addProtocol = s.cA, m.config = s.a, m.removeProtocol = s.cB, m.AttributionControl = Xc, m.BoxZoomHandler = Nc, m.CanvasSource = Ye, m.CooperativeGesturesHandler = Uh, m.DoubleClickZoomHandler = Gc, m.DragPanHandler = Nh, m.DragRotateHandler = Wc, m.EdgeInsets = Sa, m.FullscreenControl = class extends s.E {
          constructor(v = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            A.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = A.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            A.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, m.GeoJSONSource = Ee, m.GeolocateControl = class extends s.E {
          constructor(v) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const a = new s.S(e.coords.longitude, e.coords.latitude), c = e.coords.accuracy, p = this._map.getBearing(), _ = s.e({ bearing: p }, this.options.fitBoundsOptions), x = sr.fromLngLat(a, c);
              this._map.fitBounds(x, _, { geolocateSource: true });
            }, this._updateMarker = (e) => {
              if (e) {
                const a = new s.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && Ba) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = A.create("button", "maplibregl-ctrl-geolocate", this._container), A.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === false) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = A.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new fs({ element: this._dotElement }), this._circleElement = A.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new fs({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((a) => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")));
                }));
              }
            }, this.options = s.e({}, Yc, v);
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function* (e = false) {
                if (Hr !== void 0 && !e) return Hr;
                if (window.navigator.permissions === void 0) return Hr = !!window.navigator.geolocation, Hr;
                try {
                  Hr = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Hr = !!window.navigator.geolocation;
                }
                return Hr;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), A.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, ps = 0, Ba = false;
          }
          _isOutOfMapMaxBounds(v) {
            const e = this._map.getMaxBounds(), a = v.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const v = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && v)) return;
            const e = this._map.project(v), a = this._map.unproject([e.x + 100, e.y]), c = v.distanceTo(a) / 100, p = 2 * this._accuracy / c;
            this._circleElement.style.width = `${p.toFixed(2)}px`, this._circleElement.style.height = `${p.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ps--, Ba = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ps++, ps > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, Ba = true) : (v = this.options.positionOptions, Ba = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, m.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const e = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = A.create("button", "maplibregl-ctrl-globe", this._container), A.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, m.Hash = cu, m.ImageSource = ot, m.KeyboardHandler = fu, m.LngLatBounds = sr, m.LogoControl = qh, m.Map = class extends Gh {
          constructor(v) {
            var e, a;
            s.cw.mark(s.cx.create);
            const c = Object.assign(Object.assign(Object.assign({}, Wn), v), { canvasContextAttributes: Object.assign(Object.assign({}, Wn.canvasContextAttributes), v.canvasContextAttributes) });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const p = new ti(), _ = new nn();
            if (c.minZoom !== void 0 && p.setMinZoom(c.minZoom), c.maxZoom !== void 0 && p.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && p.setMinPitch(c.minPitch), c.maxPitch !== void 0 && p.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && p.setRenderWorldCopies(c.renderWorldCopies), super(p, _, { bearingSnap: c.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Io(), this._controls = [], this._mapId = s.a7(), this._contextLost = (k) => {
              k.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", { originalEvent: k }));
            }, this._contextRestored = (k) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", { originalEvent: k }));
            }, this._onMapScroll = (k) => {
              if (k.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === true, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === true, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === true, this._collectResourceTiming = c.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, gn), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = te.addThrottleControl((() => this.isMoving())), this._requestManager = new re(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`);
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container;
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let k = false;
              const P = Fa(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                k ? P(R) : k = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Zc(this, c), this._hash = c.hash && new cu(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: c.center, elevation: c.elevation, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, roll: c.roll }), c.bounds && (this.resize(), this.fitBounds(c.bounds, s.e({}, c.fitBoundsOptions, { duration: 0 }))));
            const x = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, { localIdeographFontFamily: c.localIdeographFontFamily }), c.attributionControl && this.addControl(new Xc(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new qh(), c.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const k = s.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(k);
              }
            })), this.on("data", ((k) => {
              this._update(k.dataType === "style"), this.fire(new s.l(`${k.dataType}data`, k));
            })), this.on("dataloading", ((k) => {
              this.fire(new s.l(`${k.dataType}dataloading`, k));
            })), this.on("dataabort", ((k) => {
              this.fire(new s.l("sourcedataabort", k));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, e) {
            return this.style.setGlobalStateProperty(v, e), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, e) {
            if (e === void 0 && (e = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = v.onAdd(this);
            this._controls.push(v);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(v);
            return e > -1 && this._controls.splice(e, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          coveringTiles(v) {
            return Pe(this.transform, v);
          }
          calculateCameraOptionsFromTo(v, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, e, a, c);
          }
          resize(v, e = true) {
            const [a, c] = this._containerDimensions(), p = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, p), this.painter.resize(a, c, p), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const k = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, k), this.painter.resize(a, c, k);
            }
            this._resizeTransform(e);
            const _ = !this._moving;
            return _ && (this.stop(), this.fire(new s.l("movestart", v)).fire(new s.l("move", v))), this.fire(new s.l("resize", v)), _ && this.fire(new s.l("moveend", v)), this;
          }
          _resizeTransform(v = true) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, v), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, v);
          }
          _getClampedPixelRatio(v, e) {
            const { 0: a, 1: c } = this._maxCanvasSize, p = this.getPixelRatio(), _ = v * p, x = e * p;
            return Math.min(_ > a ? a / _ : 1, x > c ? c / x : 1) * p;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(sr.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(s.S.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(s.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, e, a) {
            if (v === "mouseenter" || v === "mouseover") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (_) => {
                const x = e.filter(((P) => this.getLayer(P))), k = x.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: x }) : [];
                k.length ? c || (c = true, a.call(this, new kn(v, this, _.originalEvent, { features: k }))) : c = false;
              }, mouseout: () => {
                c = false;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (x) => {
                const k = e.filter(((P) => this.getLayer(P)));
                (k.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: k }) : []).length ? c = true : c && (c = false, a.call(this, new kn(v, this, x.originalEvent)));
              }, mouseout: (x) => {
                c && (c = false, a.call(this, new kn(v, this, x.originalEvent)));
              } } };
            }
            {
              const c = (p) => {
                const _ = e.filter(((k) => this.getLayer(k))), x = _.length !== 0 ? this.queryRenderedFeatures(p.point, { layers: _ }) : [];
                x.length && (p.features = x, a.call(this, p), delete p.features);
              };
              return { layers: e, listener: a, delegates: { [v]: c } };
            }
          }
          _saveDelegatedListener(v, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(e);
          }
          _removeDelegatedListener(v, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const c = this._delegatedListeners[v];
            for (let p = 0; p < c.length; p++) {
              const _ = c[p];
              if (_.listener === a && _.layers.length === e.length && _.layers.every(((x) => e.includes(x)))) {
                for (const x in _.delegates) this.off(x, _.delegates[x]);
                return void c.splice(p, 1);
              }
            }
          }
          on(v, e, a) {
            if (a === void 0) return super.on(v, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(v, c, a);
            this._saveDelegatedListener(v, p);
            for (const _ in p.delegates) this.on(_, p.delegates[_]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, c, a);
            } };
          }
          once(v, e, a) {
            if (a === void 0) return super.once(v, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(v, c, a);
            for (const _ in p.delegates) {
              const x = p.delegates[_];
              p.delegates[_] = (...k) => {
                this._removeDelegatedListener(v, c, a), x(...k);
              };
            }
            this._saveDelegatedListener(v, p);
            for (const _ in p.delegates) this.once(_, p.delegates[_]);
            return this;
          }
          off(v, e, a) {
            return a === void 0 ? super.off(v, e) : (this._removeDelegatedListener(v, typeof e == "string" ? [e] : e, a), this);
          }
          queryRenderedFeatures(v, e) {
            if (!this.style) return [];
            let a;
            const c = v instanceof s.P || Array.isArray(v), p = c ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (c ? {} : v) || {}, p instanceof s.P || typeof p[0] == "number") a = [s.P.convert(p)];
            else {
              const _ = s.P.convert(p[0]), x = s.P.convert(p[1]);
              a = [_, new s.P(x.x, _.y), x, new s.P(_.x, x.y), _];
            }
            return this.style.queryRenderedFeatures(a, e, this.transform);
          }
          querySourceFeatures(v, e) {
            return this.style.querySourceFeatures(v, e);
          }
          setStyle(v, e) {
            return (e = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== false && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(v, e));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const e = this._locale[v];
            if (e == null) throw new Error(`Missing UI string '${v}'`);
            return e;
          }
          _updateStyle(v, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(v, e)));
            const p = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new gc(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, e, p) : this.style.loadJSON(v, e, p), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new gc(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, e) {
            if (typeof v == "string") {
              const a = this._requestManager.transformRequest(v, "Style");
              s.j(a, new AbortController()).then(((c) => {
                this._updateDiff(c.data, e);
              })).catch(((c) => {
                c && this.fire(new s.k(c));
              }));
            } else typeof v == "object" && this._updateDiff(v, e);
          }
          _updateDiff(v, e) {
            try {
              this.style.setState(v, e) && this._update(true);
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`), this._updateStyle(v, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
          }
          addSource(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, e), this._update(true);
          }
          isSourceLoaded(v) {
            const e = this.style && this.style.sourceCaches[v];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const e = this.style.sourceCaches[v.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === v.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === v.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new er(this.painter, e, v), this.painter.renderToTexture = new vu(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (a) => {
                var c;
                a.dataType === "style" ? this.terrain.sourceCache.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(a.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, e;
            return (e = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const e in v) {
              const a = v[e]._tiles;
              for (const c in a) {
                const p = a[c];
                if (p.state !== "loaded" && p.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(true);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = it(Math.max(1, v), Math.max(1, e));
            } else for (const c in this.style.sourceCaches) this.style.sourceCaches[c].getSource().calculateTileZoom = it(Math.max(1, v), Math.max(1, e));
            return this._update(true), this;
          }
          refreshTiles(v, e) {
            const a = this.style.sourceCaches[v];
            if (!a) throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
            e === void 0 ? a.reload(true) : a.refreshTiles(e.map(((c) => new s.a4(c.z, c.x, c.y))));
          }
          addImage(v, e, a = {}) {
            const { pixelRatio: c = 1, sdf: p = false, stretchX: _, stretchY: x, content: k, textFitWidth: P, textFitHeight: R } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: D, height: j, data: $ } = e, V = e;
                return this.style.addImage(v, { data: new s.R({ width: D, height: j }, new Uint8Array($)), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: P, textFitHeight: R, sdf: p, version: 0, userImage: V }), V.onAdd && V.onAdd(this, v), this;
              }
            }
            {
              const { width: D, height: j, data: $ } = L.getImageData(e);
              this.style.addImage(v, { data: new s.R({ width: D, height: j }, $), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: P, textFitHeight: R, sdf: p, version: 0 });
            }
          }
          updateImage(v, e) {
            const a = this.style.getImage(v);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || s.b(e) ? L.getImageData(e) : e, { width: p, height: _, data: x } = c;
            if (p === void 0 || _ === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (p !== a.data.width || _ !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const k = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(x, k), this.style.updateImage(v, a), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new s.k(new Error("Missing required image id"))), false);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return te.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, e), this._update(true);
          }
          moveLayer(v, e) {
            return this.style.moveLayer(v, e), this._update(true);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(true);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, e, a) {
            return this.style.setLayerZoomRange(v, e, a), this._update(true);
          }
          setFilter(v, e, a = {}) {
            return this.style.setFilter(v, e, a), this._update(true);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, e, a, c = {}) {
            return this.style.setPaintProperty(v, e, a, c), this._update(true);
          }
          getPaintProperty(v, e) {
            return this.style.getPaintProperty(v, e);
          }
          setLayoutProperty(v, e, a, c = {}) {
            return this.style.setLayoutProperty(v, e, a, c), this._update(true);
          }
          getLayoutProperty(v, e) {
            return this.style.getLayoutProperty(v, e);
          }
          setGlyphs(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, e), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, e, a, ((c) => {
              c || this._update(true);
            })), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, e, ((a) => {
              a || this._update(true);
            })), this;
          }
          setLight(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(v, e), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(v, e), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, e) {
            return this.style.setFeatureState(v, e), this._update();
          }
          removeFeatureState(v, e) {
            return this.style.removeFeatureState(v, e), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, e = 0;
            return this._container && (v = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [v, e];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const e = this._canvasContainer = A.create("div", "maplibregl-canvas-container", v);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = A.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(), c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const p = this._controlContainer = A.create("div", "maplibregl-control-container", v), _ = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              _[x] = A.create("div", `maplibregl-ctrl-${x} `, p);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(v, e, a) {
            this._canvas.width = Math.floor(a * v), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((c) => {
              e = { requestedAttributes: v }, c && (e.statusMessage = c.statusMessage, e.type = c.type);
            }), { once: true });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c);
            }
            this.painter = new Eh(a, this.transform), O.testSupport(a);
          }
          migrateProjection(v, e) {
            super.migrateProjection(v, e), this.painter.transform = v, this.fire(new s.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var e, a, c, p, _;
            const x = this._idleTriggered ? this._fadeDuration : 0, k = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let P = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const j = this.transform.zoom, $ = L.now();
              this.style.zoomHistory.update(j, $);
              const V = new s.F(j, { now: $, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition(), globalState: this.style.getGlobalState() }), W = V.crossFadingFactor();
              W === 1 && W === this._crossFadingFactor || (P = true, this._crossFadingFactor = W), this.style.update(V);
            }
            const R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== k;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((p = this.style.projection) === null || p === void 0 ? void 0 : p.transitionState, (_ = this.style.projection) === null || _ === void 0 ? void 0 : _.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = true, s.cw.mark(s.cx.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || P) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const D = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return D || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || D || (this._fullyLoaded = true, s.cw.mark(s.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), te.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (e == null ? void 0 : e.loseContext) && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), A.remove(this._canvasContainer), A.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), s.cw.clearMetrics(), this._removed = true, this.fire(new s.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), L.frame(this._frameRequest, ((v) => {
              s.cw.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (e) {
                if (!s.cy(e) && !(function(a) {
                  return a.message === Qs;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return Wh;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(true);
          }
        }, m.MapMouseEvent = kn, m.MapTouchEvent = os, m.MapWheelEvent = jc, m.Marker = fs, m.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), a = e === this._map.getMaxZoom(), c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c);
            }, this.options = s.e({}, $p, v), this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = A.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ul(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            A.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, e) {
            const a = A.create("button", v, this._container);
            return a.type = "button", a.addEventListener("click", e), a;
          }
        }, m.Popup = class extends s.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && A.remove(this._content), this._container && (A.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = A.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = A.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = bi(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const p = bu(this.options.offset);
              if (!c) {
                const x = this._container.offsetWidth, k = this._container.offsetHeight;
                let P;
                P = a.y + p.bottom.y < k ? ["top"] : a.y > this._map.transform.height - k ? ["bottom"] : [], a.x < x / 2 ? P.push("left") : a.x > this._map.transform.width - x / 2 && P.push("right"), c = P.length === 0 ? "bottom" : P.join("-");
              }
              let _ = a.add(p[c]);
              this.options.subpixelPositioning || (_ = _.round()), A.setTransform(this._container, `${_u[c]} translate(${_.x}px,${_.y}px)`), hs(this._container, c, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = s.e(Object.create(Kc), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = s.S.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const e = document.createDocumentFragment(), a = document.createElement("body");
            let c;
            for (a.innerHTML = v; c = a.firstChild, c; ) e.appendChild(c);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = A.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = A.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(Jc);
            v && v.focus();
          }
        }, m.RasterDEMTileSource = Ct, m.RasterTileSource = Cr, m.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              yu(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, yu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, cl), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, m.ScrollZoomHandler = $h, m.Style = gc, m.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = A.create("button", "maplibregl-ctrl-terrain", this._container), A.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, m.TwoFingersTouchPitchHandler = hu, m.TwoFingersTouchRotateHandler = cs, m.TwoFingersTouchZoomHandler = du, m.TwoFingersTouchZoomRotateHandler = Vh, m.VectorTileSource = Dr, m.VideoSource = Le, m.addSourceType = (v, e) => s._(void 0, void 0, void 0, (function* () {
          if (bt(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((a, c) => {
            ft[a] = c;
          })(v, e);
        })), m.clearPrewarmedResources = function() {
          const v = ut;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(ht), ut = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, m.createTileMesh = pc, m.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, m.getRTLTextPluginStatus = function() {
          return ii().getRTLTextPluginStatus();
        }, m.getVersion = function() {
          return Qc;
        }, m.getWorkerCount = function() {
          return yt.workerCount;
        }, m.getWorkerUrl = function() {
          return s.a.WORKER_URL;
        }, m.importScriptInWorkers = function(v) {
          return pr().broadcast("IS", v);
        }, m.prewarm = function() {
          Ht().acquire(ht);
        }, m.setMaxParallelImageRequests = function(v) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, m.setRTLTextPlugin = function(v, e) {
          return ii().setRTLTextPlugin(v, e);
        }, m.setWorkerCount = function(v) {
          yt.workerCount = v;
        }, m.setWorkerUrl = function(v) {
          s.a.WORKER_URL = v;
        };
      }));
      var g = l;
      return g;
    }));
  })(zf)), zf.exports;
}
var Is = r6();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const i6 = Symbol("map"), sc = i6, Qd = Symbol("isLoaded"), n6 = Symbol("isInitialized"), Xb = n6, Hg = Symbol("componentId"), Xg = Symbol("sourceId"), Yb = Symbol("sourceLayerRegistry"), o6 = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function a6(r, i, l, d) {
  return (f) => l.emit(d, { type: f.type, map: i, component: r, event: f });
}
function s6(r, i) {
  const l = Is.LngLat.convert(r), d = Is.LngLat.convert(i);
  return l.lng === d.lng && l.lat === d.lat;
}
var eh = ((r) => (r.TOP_LEFT = "top-left", r.TOP_RIGHT = "top-right", r.BOTTOM_LEFT = "bottom-left", r.BOTTOM_RIGHT = "bottom-right", r))(eh || {});
const lc = Object.values(eh), F_ = /* @__PURE__ */ new Map(), l6 = Symbol("default");
function u6(r, i, l = l6) {
  var _a3;
  let d = F_.get(l);
  return d || (d = Vw({ isLoaded: false, isMounted: false, language: null }), F_.set(l, d)), d.isLoaded = ((_a3 = i.value) == null ? void 0 : _a3.loaded()) || false, d.isMounted = false, d.component = r, d.map = i.value, d;
}
const Kb = st({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (r) => r in eh }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(r, i) {
  const l = Nv(Xd()), d = Al(), f = Al(), g = Ae(false), m = Ae(false), s = /* @__PURE__ */ new Map(), C = u6(l, f, r.mapKey);
  Jr(sc, f), Jr(Qd, m), Jr(Xb, g), Jr(Hg, l.uid), Jr(Xg, ""), ar(() => r.bearing, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setBearing(L));
  }), ar(() => r.bounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.fitBounds(L, r.fitBoundsOptions));
  }), ar(() => r.center, (L) => {
    var _a3, _b2;
    const A = (_a3 = f.value) == null ? void 0 : _a3.getCenter();
    L && A && !s6(L, A) && ((_b2 = f.value) == null ? void 0 : _b2.setCenter(L));
  }), ar(() => r.maxBounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxBounds(L));
  }), ar(() => r.maxPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxPitch(L));
  }), ar(() => r.maxZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxZoom(L));
  }), ar(() => r.minPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinPitch(L));
  }), ar(() => r.minZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinZoom(L));
  }), ar(() => r.pitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setPitch(L));
  }), ar(() => r.renderWorldCopies, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setRenderWorldCopies(L));
  }), ar(() => r.mapStyle, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setStyle(L));
  }), ar(() => r.transformRequest, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setTransformRequest(L));
  }), ar(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  }), ar(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  });
  function T() {
    C.isMounted = true;
    const L = { ...r, style: r.mapStyle, container: d.value };
    for (const A of Object.keys(L)) L[A] === void 0 && delete L[A];
    if (f.value = Nv(new Is.Map(L)), C.map = f.value, g.value = true, s.set("__load", () => (m.value = true, C.isLoaded = true)), f.value.on("load", s.get("__load")), s.set("__moveend", () => i.emit("update:center", f.value.getCenter())), f.value.on("moveend", s.get("__moveend")), s.set("__zoomend", () => i.emit("update:zoom", f.value.getZoom())), f.value.on("zoomend", s.get("__zoomend")), s.set("__pitchend", () => i.emit("update:pitch", f.value.getPitch())), f.value.on("pitchend", s.get("__pitchend")), s.set("__rotateend", () => i.emit("update:bearing", f.value.getBearing())), f.value.on("rotateend", s.get("__rotateend")), l.vnode.props) {
      for (const A of o6) if (l.vnode.props["onMap:" + A]) {
        const O = `map:${A}`, U = a6(l, f.value, i, O);
        s.set(A, U), f.value.on(A, U);
      }
    }
    f.value.getCanvas().addEventListener("webglcontextlost", z);
  }
  async function M() {
    C.isMounted = false, C.isLoaded = false, m.value = false, f.value && (f.value.getCanvas().removeEventListener("webglcontextlost", z), g.value = false, s.forEach((L, A) => {
      f.value.off(A.startsWith("__") ? A.substring(2) : A, L);
    }), f.value.remove());
  }
  function z() {
    M(), Nn(T);
  }
  return Qi(T), Cn(M), i.expose({ map: f }), () => [F("div", { ref: d, style: { height: r.height, width: r.width } }), g.value && i.slots.default ? i.slots.default({}) : void 0];
}, render() {
  return null;
} });
function c6(r, i, l) {
  ar(r, (d) => {
    var _a3, _b2;
    d && lc.indexOf(d) === -1 || (((_a3 = i.value) == null ? void 0 : _a3.hasControl(l)) && i.value.removeControl(l), (_b2 = i.value) == null ? void 0 : _b2.addControl(l, d));
  }, { immediate: true });
}
function th(r, i) {
  const l = fr(sc), d = fr(Xb), f = Al();
  return f.value = r(), c6(() => i.position, l, f.value), Cn(() => {
    var _a3;
    return d.value && ((_a3 = l.value) == null ? void 0 : _a3.removeControl(f.value));
  }), { control: f, map: l };
}
class d6 {
  constructor(i, l) {
    __publicField(this, "container");
    this.isAdded = i, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return eh.TOP_LEFT;
  }
  onAdd() {
    return Nn(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(i) {
    this.container.className = i;
  }
}
const L_ = st({ name: "MglCustomControl", props: { position: { type: String, validator: (r) => lc.indexOf(r) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(r, { slots: i }) {
  const l = Ae(false), { control: d } = th(() => new d6(l, r.class), r);
  return ar(() => r.class, () => d.value.setClasses(r.class)), () => {
    var _a3;
    return l.value ? F(_y, { to: d.value.container }, (_a3 = i.default) == null ? void 0 : _a3.call(i, {})) : Kr("custom-component");
  };
}, render() {
  return null;
} }), Jb = st({ name: "MglFullscreenControl", props: { position: { type: String, validator: (r) => lc.indexOf(r) !== -1 }, container: { type: Object, default: null } }, setup(r) {
  const { control: i, map: l } = th(() => new Is.FullscreenControl({ container: r.container || void 0 }), r);
  function d() {
    Nn(() => {
      var _a3;
      return (_a3 = l.value) == null ? void 0 : _a3.resize();
    });
  }
  i.value.on("fullscreenstart", d), i.value.on("fullscreenend", d), Cn(() => {
    i.value.off("fullscreenstart", d), i.value.off("fullscreenend", d);
  });
}, render() {
  return null;
} }), h6 = st({ name: "MglGeolocateControl", props: { position: { type: String, default: eh.TOP_RIGHT, validator: (r) => lc.indexOf(r) !== -1 }, positionOptions: { type: Object, default: () => ({ enableHighAccuracy: false, timeout: 6e3 }) }, fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) }, trackUserLocation: { type: Boolean, default: false }, showAccuracyCircle: { type: Boolean, default: true }, showUserLocation: { type: Boolean, default: true } }, emits: ["trackuserlocationstart", "trackuserlocationend", "userlocationlostfocus", "userlocationfocus", "geolocate", "error", "outofmaxbounds"], setup(r, i) {
  const { control: l } = th(() => new Is.GeolocateControl({ positionOptions: r.positionOptions, fitBoundsOptions: r.fitBoundsOptions, trackUserLocation: r.trackUserLocation, showAccuracyCircle: r.showAccuracyCircle, showUserLocation: r.showUserLocation }), r);
  function d(f) {
    const g = (m) => {
      i.emit(f, m);
    };
    l.value.on(f, g), Cn(() => {
      l.value.off(f, g);
    });
  }
  d("trackuserlocationstart"), d("trackuserlocationend"), d("userlocationlostfocus"), d("userlocationfocus"), d("geolocate"), d("error"), d("outofmaxbounds");
}, render() {
  return null;
} }), Qb = st({ name: "MglNavigationControl", props: { position: { type: String, validator: (r) => lc.indexOf(r) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(r) {
  th(() => new Is.NavigationControl({ showCompass: r.showCompass, showZoom: r.showZoom, visualizePitch: r.visualizePitch }), r);
}, render() {
  return null;
} });
var e1 = ((r) => (r.IMPERIAL = "imperial", r.METRIC = "metric", r.NAUTICAL = "nautical", r))(e1 || {});
const f6 = Object.values(e1), t1 = st({ name: "MglScaleControl", props: { position: { type: String, validator: (r) => lc.indexOf(r) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (r) => f6.indexOf(r) !== -1 } }, setup(r) {
  th(() => new Is.ScaleControl({ maxWidth: r.maxWidth, unit: r.unit }), r);
}, render() {
  return null;
} });
let p6 = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(i, l) {
    this.unmountHandlers.set(i, l);
  }
  unregisterUnmountHandler(i) {
    this.unmountHandlers.delete(i);
  }
  unmount() {
    this.unmountHandlers.forEach((i) => i());
  }
}, Yg = (_a2 = class {
  static genSourceOpts(i) {
    const l = { ...i };
    for (const d of Object.keys(l)) (l[d] === void 0 || d === "sourceId") && delete l[d];
    return l;
  }
  static getSourceRef(i, l) {
    const d = typeof l == "string", f = String(i) + (d ? l : "");
    let g = _a2.REFS.get(f);
    return g || (g = Ae(d ? null : void 0), _a2.REFS.set(f, g)), g;
  }
}, __publicField(_a2, "REFS", /* @__PURE__ */ new Map()), _a2);
function m6(r, i, l) {
  const d = fr(sc), f = fr(Qd);
  function g() {
    f.value && (d.value.addSource(i.sourceId, Yg.genSourceOpts(i)), r.value = d.value.getSource(i.sourceId));
  }
  return ar(f, g, { immediate: true }), d.value.on("style.load", g), Cn(() => {
    f.value && (l.unmount(), d.value.removeSource(i.sourceId)), d.value.off("style.load", g);
  });
}
const g6 = st({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(r, { slots: i }) {
  const l = fr(Hg), d = Yg.getSourceRef(l, r.sourceId), f = new p6(), g = { ...r, type: "geojson" };
  return Jr(Xg, r.sourceId), Jr(Yb, f), m6(d, g, f), ar([Nw(r.data) ? r.data : () => r.data, d], ([m, s]) => {
    s == null ? void 0 : s.setData(m || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [Kr("GeoJSON Source"), d.value && i.default ? i.default({}) : void 0];
} }), Ko = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function Rs() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function v6(r, i, l, d) {
  const f = { id: r, type: i, source: l.source || d, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const g of Object.keys(f)) f[g] === void 0 && delete f[g];
  return f;
}
function _6(r, i, l) {
  if (l.props) for (const d of Ko) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.on(d, i, l.props[f]);
  }
}
function y6(r, i, l) {
  if (l.props) for (const d of Ko) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.off(d, i, l.props[f]);
  }
}
function r1(r, i) {
  const l = fr(sc), d = fr(Qd), f = fr(Yb);
  function g() {
    d.value && (i && y6(l.value, r, i.vnode), l.value.getLayer(r) && l.value.removeLayer(r));
  }
  f.registerUnmountHandler(r, g), Cn(() => {
    f.unregisterUnmountHandler(r), g();
  });
}
st({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...Ko], setup(r) {
  const i = fr(sc), l = fr(Qd);
  return r1(r.layerId), ar(() => r.layout, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setLayoutProperty(r.layerId, f, g);
  }), ar(() => r.paint, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setPaintProperty(r.layerId, f, g);
  }), ar(l, (d) => {
    d && i.value.addLayer({ id: r.layerId, type: "background", metadata: r.metadata, minzoom: r.minzoom, maxzoom: r.maxzoom, layout: r.layout, paint: r.paint }, r.before || void 0);
  }, { immediate: true }), () => Kr("Background Layer");
} });
function As(r, i) {
  const l = fr(Xg);
  if (!l && !i.source) return;
  const d = Xd(), f = fr(sc), g = fr(Qd), m = fr(Hg), s = Yg.getSourceRef(m, i.source || l);
  return r1(i.layerId, d), ar(() => i.minzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), ar(() => i.maxzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), ar(() => i.layout, (C) => {
    if (C) for (const [T, M] of Object.entries(C)) f.value.setLayoutProperty(i.layerId, T, M);
  }, { deep: true }), ar(() => i.paint, (C) => {
    if (C) for (const [T, M] of Object.entries(C)) f.value.setPaintProperty(i.layerId, T, M);
  }, { deep: true }), ar(() => i.filter, (C) => f.value.setFilter(i.layerId, C), { deep: true }), ar([g, s], ([C, T]) => {
    C && (T || T === void 0) && (f.value.addLayer(v6(i.layerId, r, i, l), i.before || void 0), _6(f.value, i.layerId, d.vnode));
  }, { immediate: true }), () => Kr(`${r} Layer`);
}
st({ name: "MglCircleLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("circle", r);
} });
st({ name: "MglFillLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("fill", r);
} });
st({ name: "MglFillExtrusionLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("fill-extrusion", r);
} });
st({ name: "MglHeatmapLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("heatmap", r);
} });
st({ name: "MglHillshadeLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("hillshade", r);
} });
const b6 = st({ name: "MglLineLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("line", r);
} });
st({ name: "MglRasterLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("raster", r);
} });
st({ name: "MglSymbolLayer", props: Rs(), emits: [...Ko], setup(r) {
  return As("symbol", r);
} });
function wn() {
  return wn = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) ({}).hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, wn.apply(null, arguments);
}
var Mn;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(Mn || (Mn = {}));
const un = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, Ai = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount" }, Ff = 10;
function Gm(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function B_(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function O_(r) {
  return !!(function(i) {
    return typeof i == "number" && !isNaN(new Date(i).valueOf());
  })(r);
}
const x6 = "Feature mode property does not match the mode being added to";
var Qu;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(Qu || (Qu = {}));
const w6 = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class cp {
  get state() {
    return this._state;
  }
  set state(i) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(i) {
    if (typeof i != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = i;
  }
  registerBehaviors(i) {
  }
  constructor(i, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = w6, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = Qu.Drawing, this.mode = "base", l || this.updateOptions(i);
  }
  updateOptions(i) {
    i != null && i.styles && (this.styles = wn({}, this._styles, i.styles)), i != null && i.pointerDistance && (this.pointerDistance = i.pointerDistance), i != null && i.validation && (this.validate = i && i.validation), i != null && i.projection && (this.projection = i.projection), (i == null ? void 0 : i.pointerEvents) !== void 0 && (this.pointerEvents = i.pointerEvents);
  }
  allowPointerEvent(i, l) {
    return typeof i == "boolean" ? i : typeof i != "function" || i(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(i) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = i.store, this.store.registerOnChange(i.onChange), this.setDoubleClickToZoom = i.setDoubleClickToZoom, this.project = i.project, this.unproject = i.unproject, this.onSelect = i.onSelect, this.onDeselect = i.onDeselect, this.setCursor = i.setCursor, this.onStyleChange = i.onChange, this.onFinish = i.onFinish, this.coordinatePrecision = i.coordinatePrecision, this.registerBehaviors({ mode: i.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: i.coordinatePrecision, projection: this.projection });
  }
  validateFeature(i) {
    return this.performFeatureValidation(i);
  }
  afterFeatureAdded(i) {
  }
  afterFeatureUpdated(i) {
  }
  performFeatureValidation(i) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(d, f) {
      let g;
      if (Gm(d)) if (d.id == null) g = "Feature has no id";
      else if (typeof d.id != "string" && typeof d.id != "number") g = "Feature must be string or number as per GeoJSON spec";
      else if (f(d.id)) if (Gm(d.geometry)) if (Gm(d.properties)) if (typeof d.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(d.geometry.type)) if (Array.isArray(d.geometry.coordinates)) {
        if (!d.properties.mode || typeof d.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else g = "Feature coordinates is not an array";
      else g = "Feature is not Point, LineString or Polygon";
      else g = "Feature has no properties";
      else g = "Feature has no geometry";
      else g = "Feature must match the id strategy (default is UUID4)";
      else g = "Feature is not object";
      return g ? { valid: false, reason: g } : { valid: true };
    })(i, this.store.idStrategy.isValidId);
    if (this.validate) {
      const d = this.validate(i, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional });
      return { valid: l.valid && d.valid, reason: d.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(i, l) {
    const d = this.performFeatureValidation(i);
    return d.valid ? i.properties.mode !== this.mode ? { valid: false, reason: x6 } : l(i) : { valid: false, reason: d.reason };
  }
  onFinish(i, l) {
  }
  onDeselect(i) {
  }
  onSelect(i) {
  }
  onKeyDown(i) {
  }
  onKeyUp(i) {
  }
  onMouseMove(i) {
  }
  onClick(i) {
  }
  onDragStart(i, l) {
  }
  onDrag(i, l) {
  }
  onDragEnd(i, l) {
  }
  getHexColorStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getNumericStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getStylingValue(i, l, d) {
    return i === void 0 ? l : typeof i == "function" ? i(d) : i;
  }
}
class C6 extends cp {
  constructor(...i) {
    super(...i), this.type = Qu.Select;
  }
}
function Ms(r, i) {
  const l = (T) => T * Math.PI / 180, d = l(r[1]), f = l(r[0]), g = l(i[1]), m = g - d, s = l(i[0]) - f, C = Math.sin(m / 2) * Math.sin(m / 2) + Math.cos(d) * Math.cos(g) * Math.sin(s / 2) * Math.sin(s / 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C)) * 6371e3 / 1e3;
}
const i1 = 63710088e-1;
function Xn(r) {
  return r % 360 * Math.PI / 180;
}
function S6(r) {
  return r / 6371.0088;
}
function ec(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function Di(r, i = 9) {
  const l = Math.pow(10, i);
  return Math.round(r * l) / l;
}
const $_ = 57.29577951308232, j_ = 0.017453292519943295, Uf = 6378137, Ri = (r, i) => ({ x: r === 0 ? 0 : r * j_ * Uf, y: i === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + i * j_ / 2)) * Uf }), tc = (r, i) => ({ lng: r === 0 ? 0 : $_ * (r / Uf), lat: i === 0 ? 0 : (2 * Math.atan(Math.exp(i / Uf)) - Math.PI / 2) * $_ });
function k6(r) {
  let i;
  if (r.geometry.type === "Polygon") i = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    i = [r.geometry.coordinates];
  }
  const l = [];
  for (let g = 0; g < i.length; g++) for (let m = 0; m < i[g].length - 1; m++) for (let s = 0; s < i.length; s++) for (let C = 0; C < i[s].length - 1; C++) f(g, m, s, C);
  return l.length > 0;
  function d(g) {
    return g < 0 || g > 1;
  }
  function f(g, m, s, C) {
    const T = i[g][m], M = i[g][m + 1], z = i[s][C], L = i[s][C + 1], A = (function(X, H, Q, ie) {
      if (Cf(X, Q) || Cf(X, ie) || Cf(H, Q) || Cf(ie, Q)) return null;
      const te = X[0], re = X[1], J = H[0], Se = H[1], fe = Q[0], oe = Q[1], de = ie[0], xe = ie[1], $e = (te - J) * (oe - xe) - (re - Se) * (fe - de);
      return $e === 0 ? null : [((te * Se - re * J) * (fe - de) - (te - J) * (fe * xe - oe * de)) / $e, ((te * Se - re * J) * (oe - xe) - (re - Se) * (fe * xe - oe * de)) / $e];
    })(T, M, z, L);
    if (A === null) return;
    let O, U;
    O = M[0] !== T[0] ? (A[0] - T[0]) / (M[0] - T[0]) : (A[1] - T[1]) / (M[1] - T[1]), U = L[0] !== z[0] ? (A[0] - z[0]) / (L[0] - z[0]) : (A[1] - z[1]) / (L[1] - z[1]), d(O) || d(U) || (A.toString(), l.push(A));
  }
}
function Cf(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function Kg(r, i) {
  return N_(r[0]) <= i && N_(r[1]) <= i;
}
function n1(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (l = r[0]) >= -180 && l <= 180 && (i = r[1]) >= -90 && i <= 90;
  var i, l;
}
function N_(r) {
  let i = 1, l = 0;
  for (; Math.round(r * i) / i !== r; ) i *= 10, l++;
  return l;
}
const Xa = (r, i) => {
  const { x: l, y: d } = r, { x: f, y: g } = i, m = f - l, s = g - d;
  return Math.sqrt(s * s + m * m);
};
class Kn {
  constructor({ store: i, mode: l, project: d, unproject: f, pointerDistance: g, coordinatePrecision: m, projection: s }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = i, this.mode = l, this.project = d, this.unproject = f, this.pointerDistance = g, this.coordinatePrecision = m, this.projection = s;
  }
}
function o1({ unproject: r, point: i, pointerDistance: l }) {
  const d = l / 2, { x: f, y: g } = i;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(f - d, g - d), r(f + d, g - d), r(f + d, g + d), r(f - d, g + d), r(f - d, g - d)].map((m) => [m.lng, m.lat])] } };
}
class Gf extends Kn {
  constructor(i) {
    super(i);
  }
  create(i) {
    const { containerX: l, containerY: d } = i;
    return o1({ unproject: this.unproject, point: { x: l, y: d }, pointerDistance: this.pointerDistance });
  }
}
class qf extends Kn {
  constructor(i) {
    super(i);
  }
  measure(i, l) {
    const { x: d, y: f } = this.project(l[0], l[1]);
    return Xa({ x: d, y: f }, { x: i.containerX, y: i.containerY });
  }
}
class Pg extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => this.getSnappable(f, (g) => !!(g.properties && g.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (f, g) => this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode && m.id !== g)).coordinate, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      s.forEach((C, T) => {
        const M = this.pixelDistance.measure(i, C);
        M < g.minDist && M < this.pointerDistance && (g.coordinate = C, g.minDist = M, g.featureId = m.id, g.featureCoordinateIndex = T);
      });
    }), g;
  }
}
function V_(r, i, l) {
  const d = Xn(r[0]), f = Xn(r[1]), g = Xn(l), m = S6(i), s = Math.asin(Math.sin(f) * Math.cos(m) + Math.cos(f) * Math.sin(m) * Math.cos(g));
  return [ec(d + Math.atan2(Math.sin(g) * Math.sin(m) * Math.cos(f), Math.cos(m) - Math.sin(f) * Math.sin(s))), ec(s)];
}
function U_(r, i) {
  const l = Xn(r[0]), d = Xn(i[0]), f = Xn(r[1]), g = Xn(i[1]), m = Math.sin(d - l) * Math.cos(g), s = Math.cos(f) * Math.sin(g) - Math.sin(f) * Math.cos(g) * Math.cos(d - l);
  return ec(Math.atan2(m, s));
}
function P6({ x: r, y: i }, { x: l, y: d }) {
  const f = l - r, g = d - i;
  if (f === 0 && g === 0) return 0;
  let m = Math.atan2(g, f);
  return m *= 180 / Math.PI, m > 180 ? m -= 360 : m < -180 && (m += 360), m;
}
function T6(r, i, l) {
  const d = [], f = r.length;
  let g, m, s, C = 0;
  for (let M = 0; M < r.length && !(i >= C && M === r.length - 1); M++) {
    if (C > i && d.length === 0) {
      if (g = i - C, !g) return d.push(r[M]), d;
      m = U_(r[M], r[M - 1]) - 180, s = V_(r[M], g, m), d.push(s);
    }
    if (C >= l) return g = l - C, g ? (m = U_(r[M], r[M - 1]) - 180, s = V_(r[M], g, m), d.push(s), d) : (d.push(r[M]), d);
    if (C >= i && d.push(r[M]), M === r.length - 1) return d;
    C += Ms(r[M], r[M + 1]);
  }
  if (C < i && r.length === f) throw new Error("Start position is beyond line");
  const T = r[r.length - 1];
  return [T, T];
}
function Sf(r) {
  return r * (Math.PI / 180);
}
function G_(r) {
  return r * (180 / Math.PI);
}
class I6 extends Kn {
  constructor(i) {
    super(i), this.config = void 0, this.config = i;
  }
  generateInsertionCoordinates(i, l, d) {
    const f = [i, l];
    let g = 0;
    for (let T = 0; T < f.length - 1; T++) g += Ms(f[0], f[1]);
    if (g <= d) return f;
    let m = g / d - 1;
    Number.isInteger(m) || (m = Math.floor(m) + 1);
    const s = [];
    for (let T = 0; T < m; T++) {
      const M = T6(f, d * T, d * (T + 1));
      s.push(M);
    }
    const C = [];
    for (let T = 0; T < s.length; T++) C.push(s[T][1]);
    return this.limitCoordinates(C);
  }
  generateInsertionGeodesicCoordinates(i, l, d) {
    const f = Ms(i, l), g = (function(m, s, C) {
      const T = [], M = Sf(m[1]), z = Sf(m[0]), L = Sf(s[1]), A = Sf(s[0]);
      C += 1;
      const O = 2 * Math.asin(Math.sqrt(Math.sin((L - M) / 2) ** 2 + Math.cos(M) * Math.cos(L) * Math.sin((A - z) / 2) ** 2));
      if (O === 0 || isNaN(O)) return T;
      for (let U = 0; U <= C; U++) {
        const X = U / C, H = Math.sin((1 - X) * O) / Math.sin(O), Q = Math.sin(X * O) / Math.sin(O), ie = H * Math.cos(M) * Math.cos(z) + Q * Math.cos(L) * Math.cos(A), te = H * Math.cos(M) * Math.sin(z) + Q * Math.cos(L) * Math.sin(A), re = H * Math.sin(M) + Q * Math.sin(L);
        if (isNaN(ie) || isNaN(te) || isNaN(re)) continue;
        const J = Math.atan2(re, Math.sqrt(ie ** 2 + te ** 2)), Se = Math.atan2(te, ie);
        isNaN(J) || isNaN(Se) || T.push([G_(Se), G_(J)]);
      }
      return T.slice(1, -1);
    })(i, l, Math.floor(f / d));
    return this.limitCoordinates(g);
  }
  limitCoordinates(i) {
    return i.map((l) => [Di(l[0], this.config.coordinatePrecision), Di(l[1], this.config.coordinatePrecision)]);
  }
}
function M6(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function E6(r, i) {
  if (r.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < r.geometry.coordinates.length; l++) {
    if (!n1(r.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!Kg(r.geometry.coordinates[l], i)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function q_(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function bl(r, i) {
  const l = (function(d, f) {
    const [g, m, s] = d, [C, T, M] = f;
    return g * C + m * T + s * M;
  })(r, i) / (q_(r) * q_(i));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function qm(r) {
  const i = Xn(r[1]), l = Xn(r[0]);
  return [Math.cos(i) * Math.cos(l), Math.cos(i) * Math.sin(l), Math.sin(i)];
}
function xl(r) {
  const [i, l, d] = r, f = ec(Math.asin(d));
  return [ec(Math.atan2(l, i)), f];
}
function R6(r, i, l) {
  const d = qm(r), f = qm(i), g = qm(l), [m, s, C] = g, [T, M, z] = (function(xe, $e) {
    const [Ve, Ke, lt] = xe, [vt, xt, at] = $e;
    return [Ke * at - lt * xt, lt * vt - Ve * at, Ve * xt - Ke * vt];
  })(d, f), L = M * C - z * s, A = z * m - T * C, O = T * s - M * m, U = O * M - A * z, X = L * z - O * T, H = A * T - L * M, Q = 1 / Math.sqrt(Math.pow(U, 2) + Math.pow(X, 2) + Math.pow(H, 2)), ie = [U * Q, X * Q, H * Q], te = [-1 * U * Q, -1 * X * Q, -1 * H * Q], re = bl(d, f), J = bl(d, ie), Se = bl(f, ie), fe = bl(d, te), oe = bl(f, te);
  let de;
  return de = J < fe && J < oe || Se < fe && Se < oe ? ie : te, bl(d, de) > re || bl(f, de) > re ? Ms(xl(de), xl(d)) <= Ms(xl(de), xl(f)) ? [xl(d), true, false] : [xl(f), false, true] : [xl(de), false, false];
}
function A6(r, i, l) {
  const d = i.x - r.x, f = i.y - r.y, g = Math.max(0, Math.min(1, ((l.x - r.x) * d + (l.y - r.y) * f) / (d * d + f * f)));
  return { x: r.x + g * d, y: r.y + g * f };
}
class a1 extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => {
      const g = this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode));
      return g.coordinate ? [Di(g.coordinate[0], this.config.coordinatePrecision), Di(g.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (f, g) => {
      const m = this.getSnappable(f, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== g));
      return m.coordinate ? [Di(m.coordinate[0], this.config.coordinatePrecision), Di(m.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      const C = [];
      for (let L = 0; L < s.length - 1; L++) C.push([s[L], s[L + 1]]);
      let T;
      const M = [i.lng, i.lat];
      if (this.config.projection === "web-mercator" ? T = (function(L, A) {
        let O = [1 / 0, 1 / 0], U = 1 / 0, X = 0;
        for (let H of A) {
          const Q = H[0], ie = H[1];
          let te, re = 1 / 0;
          const J = Ri(Q[0], Q[1]), Se = Ri(ie[0], ie[1]), fe = Ri(L[0], L[1]);
          if (Q[0] === L[0] && Q[1] === L[1]) te = Q;
          else if (ie[0] === L[0] && ie[1] === L[1]) te = ie;
          else {
            const { x: oe, y: de } = A6(J, Se, fe), { lng: xe, lat: $e } = tc(oe, de);
            te = [xe, $e];
          }
          te && (re = Xa(fe, Ri(te[0], te[1])), re < U && (O = te, U = re, X = A.indexOf(H)));
        }
        return U === 1 / 0 ? void 0 : { coordinate: O, lineIndex: X, distance: U };
      })(M, C) : this.config.projection === "globe" && (T = (function(L, A) {
        let O = [1 / 0, 1 / 0], U = 1 / 0, X = 0;
        for (let H of A) {
          const Q = H[0], ie = H[1];
          let te, re = 1 / 0;
          Q[0] === L[0] && Q[1] === L[1] ? te = Q : ie[0] === L[0] && ie[1] === L[1] ? te = ie : [te] = R6(Q, ie, L), te && (re = Ms(L, te), re < U && (O = te, U = re, X = A.indexOf(H)));
        }
        return U === 1 / 0 ? void 0 : { coordinate: O, distance: U, lineIndex: X };
      })(M, C)), !T) return;
      const z = this.pixelDistance.measure(i, T.coordinate);
      z < g.minDistance && z < this.pointerDistance && (g.featureId = m.id, g.coordinate = [Di(T.coordinate[0], this.config.coordinatePrecision), Di(T.coordinate[1], this.config.coordinatePrecision)], g.featureCoordinateIndex = T.lineIndex, g.minDistance = z);
    }), g;
  }
}
const D6 = { cancel: "Escape", finish: "Enter" }, z6 = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class F6 extends cp {
  constructor(i) {
    super(i, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = D6, this.snapping = void 0, this.cursors = z6, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = wn({}, this.cursors, i.cursors)), i != null && i.snapping && (this.snapping = i.snapping), (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : i != null && i.keyEvents && (this.keyEvents = wn({}, this.keyEvents, i.keyEvents)), i != null && i.insertCoordinates && (this.insertCoordinates = i.insertCoordinates), i && i.editable && (this.editable = i.editable);
  }
  updateSnappedCoordinate(i) {
    const l = this.snapCoordinate(i);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [d] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [Ai.SNAPPING_POINT]: true } }]);
        this.snappedPointId = d;
      }
      i.lng = l[0], i.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const i = this.store.getGeometryCopy(this.currentId);
    i.coordinates.pop(), this.updateGeometries([...i.coordinates], void 0, Mn.Commit), this.store.updateProperty([{ id: this.currentId, property: Ai.CURRENTLY_DRAWING, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(i, l, d) {
    if (!this.currentId) return;
    const f = { type: "LineString", coordinates: i };
    if (this.validate && !this.validate({ type: "Feature", geometry: f }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: d }).valid) return;
    const g = [{ id: this.currentId, geometry: f }];
    this.closingPointId && l && g.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), d === "commit" && (this.lastCommittedCoordinates = f.coordinates), this.store.updateGeometry(g);
  }
  generateInsertCoordinates(i, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const d = Ms(i, l) / (this.insertCoordinates.value + 1);
    let f = [];
    return this.projection === "globe" ? f = this.insertPoint.generateInsertionGeodesicCoordinates(i, l, d) : this.projection === "web-mercator" && (f = this.insertPoint.generateInsertionCoordinates(i, l, d)), f;
  }
  createLine(i) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [i, i] }, properties: { mode: this.mode, [Ai.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [i, i], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(i) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [d] = this.store.create([{ geometry: { type: "Point", coordinates: [...i] }, properties: { mode: this.mode, [Ai.CLOSING_POINT]: true } }]);
    this.closingPointId = d, this.setCursor(this.cursors.close);
    const f = [...l, i];
    this.updateGeometries(f, void 0, Mn.Commit), this.currentCoordinate++;
  }
  updateToLine(i, l) {
    if (!this.currentId) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates, [f, g] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : d[d.length - 2], { x: m, y: s } = this.project(f, g);
    if (Xa({ x: m, y: s }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const C = [...d, i];
    this.updateGeometries(C, d[d.length - 1], Mn.Commit), this.currentCoordinate++;
  }
  registerBehaviors(i) {
    this.coordinateSnapping = new Pg(i, new qf(i), new Gf(i)), this.insertPoint = new I6(i), this.clickBoundingBox = new Gf(i), this.pixelDistance = new qf(i), this.lineSnapping = new a1(i, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new Pg(i, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(i) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = i;
    const l = this.updateSnappedCoordinate(i) || [i.lng, i.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates;
    if (d.pop(), this.closingPointId) {
      const [g, m] = d[d.length - 1], { x: s, y: C } = this.project(g, m);
      Xa({ x: s, y: C }, { x: i.containerX, y: i.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let f = [...d, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const g = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], m = l;
      if (!M6(g, m)) {
        const s = this.generateInsertCoordinates(g, m);
        f = [...this.lastCommittedCoordinates.slice(0, -1), ...s, l];
      }
    }
    this.updateGeometries(f, void 0, Mn.Provisional);
  }
  onRightClick(i) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: d } = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
    if (!l || d === void 0) return;
    const f = this.store.getGeometryCopy(l);
    let g;
    if (f.type === "LineString" && (g = f.coordinates, !(g.length <= 2))) {
      if (g.splice(d, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: f }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(i) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(i) || [i.lng, i.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: i.containerX, y: i.containerY });
  }
  onClick(i) {
    (i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(i), this.mouseMove = false, i.button === "right" ? this.onRightClick(i) : i.button === "left" && this.onLeftClick(i));
  }
  onKeyDown() {
  }
  onKeyUp(i) {
    i.key === this.keyEvents.cancel && this.cleanUp(), i.key === this.keyEvents.finish && this.close();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.editable) return;
    let d;
    if (this.state === "started") {
      const f = this.lineSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      f.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = f.featureCoordinateIndex, this.editedFeatureId = f.featureId, d = f.coordinate);
      const g = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      g.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = g.featureCoordinateIndex, this.editedFeatureId = g.featureId, d = g.coordinate);
    }
    if (this.editedFeatureId && d) {
      if (!this.editedPointId) {
        const [f] = this.store.create([{ geometry: { type: "Point", coordinates: d }, properties: { mode: this.mode, [Ai.EDITED]: true } }]);
        this.editedPointId = f;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const d = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? d.coordinates[this.editedFeatureCoordinateIndex] = [i.lng, i.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, d.coordinates.splice(this.editedInsertIndex, 0, [i.lng, i.lat]), this.editedFeatureCoordinateIndex++);
    const f = { type: "LineString", coordinates: d.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: f, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: f }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Ai.EDITED, value: true }]));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: Ai.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const i = this.currentId, l = this.closingPointId, d = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      i !== void 0 && this.store.delete([i]), d !== void 0 && this.store.delete([d]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(i) {
    const l = wn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "LineString" && i.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, i), l.zIndex = Ff, l;
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = i.properties[Ai.CLOSING_POINT];
      return l.pointColor = this.getHexColorStylingValue(d ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, i), l.pointWidth = this.getNumericStylingValue(d ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, i), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => E6(l, this.coordinatePrecision));
  }
  lineStringFilter(i) {
    return !!(i.geometry.type === "LineString" && i.properties && i.properties.mode === this.mode);
  }
  snapCoordinate(i) {
    var l, d, f;
    let g;
    if ((l = this.snapping) != null && l.toLine) {
      let m;
      m = this.currentId ? this.lineSnapping.getSnappableCoordinate(i, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(i), m && (g = m);
    }
    return (d = this.snapping) != null && d.toCoordinate && (g = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(i, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(i)), (f = this.snapping) != null && f.toCustom && (g = this.snapping.toCustom(i, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), g;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === i.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const L6 = "Feature is not a Point", B6 = "Feature has invalid coordinates", O6 = "Feature has coordinates with excessive precision";
function $6(r, i) {
  return r.geometry.type !== "Point" ? { valid: false, reason: L6 } : n1(r.geometry.coordinates) ? Kg(r.geometry.coordinates, i) ? { valid: true } : { valid: false, reason: O6 } : { valid: false, reason: B6 };
}
const j6 = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class N6 extends cp {
  constructor(i) {
    super(i, true), this.mode = "point", this.cursors = j6, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = wn({}, this.cursors, i.cursors)), i != null && i.editable && (this.editable = i.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(i, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, i)) {
      if (this.editable) {
        const d = this.getNearestPointFeature(i);
        this.editedFeatureId = d == null ? void 0 : d.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, i) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [i.lng, i.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Ai.EDITED, value: true }])));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: Ai.EDITED, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(i) {
    this.pixelDistance = new qf(i), this.clickBoundingBox = new Gf(i);
  }
  styleFeature(i) {
    const l = wn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = !!(i.id && this.editedFeatureId === i.id);
      l.pointWidth = this.getNumericStylingValue(d ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(d ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, i), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => $6(l, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const l = { type: "Point", coordinates: [i.lng, i.lat] }, d = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: d }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid) return;
    const [f] = this.store.create([{ geometry: l, properties: d }]);
    this.onFinish(f, { mode: this.mode, action: "draw" });
  }
  onRightClick(i) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(i);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(i) {
    const l = this.clickBoundingBox.create(i), d = this.store.search(l);
    let f, g = 1 / 0;
    for (let m = 0; m < d.length; m++) {
      const s = d[m];
      if (s.geometry.type !== "Point" || s.properties.mode !== this.mode) continue;
      const C = this.pixelDistance.measure(i, s.geometry.coordinates);
      C > g || C > this.pointerDistance || (g = C, f = s);
    }
    return f;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class V6 extends Kn {
  constructor(i) {
    super(i);
  }
  createOrUpdate(i) {
    const l = this.store.getGeometryCopy(i), d = this.store.getPropertiesCopy(i);
    let f;
    if (l.type === "Polygon") f = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      f = l.coordinates;
    }
    const g = this.store.getPropertiesCopy(i), m = g.coordinatePointIds;
    if (m) if (m && m.every((s) => this.store.has(s))) {
      const s = g.coordinatePointIds, C = s.map((T) => this.store.getGeometryCopy(T).coordinates);
      if (s.length !== f.length) {
        this.deleteCoordinatePoints(s);
        const T = this.createPoints(f, d.mode, i);
        this.setFeatureCoordinatePoints(i, T);
      } else f.forEach((T, M) => {
        T[0] === C[M][0] && T[1] === C[M][1] || this.store.updateGeometry([{ id: s[M], geometry: { type: "Point", coordinates: T } }]);
      });
    } else {
      const s = m.filter((T) => this.store.has(T));
      s.length && this.deleteCoordinatePoints(s);
      const C = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, C);
    }
    else {
      const s = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, s);
    }
  }
  deletePointsByFeatureIds(i) {
    for (const l of i) this.deleteIfPresent(l);
  }
  getUpdated(i, l) {
    const d = this.store.getPropertiesCopy(i);
    if (d.coordinatePointIds) return d.coordinatePointIds.map((f, g) => ({ id: f, geometry: wn({}, this.store.getGeometryCopy(f), { coordinates: l[g] }) }));
  }
  createPoints(i, l, d) {
    return this.store.create(i.map((f, g) => ({ geometry: { type: "Point", coordinates: f }, properties: { mode: l, [Ai.COORDINATE_POINT]: true, [Ai.COORDINATE_POINT_FEATURE_ID]: d, index: g } })));
  }
  setFeatureCoordinatePoints(i, l) {
    this.store.updateProperty([{ id: i, property: Ai.COORDINATE_POINT_IDS, value: l }]);
  }
  deleteCoordinatePoints(i) {
    const l = i.filter((d) => this.store.has(d));
    this.store.delete(l);
  }
  deleteIfPresent(i) {
    const l = this.store.getPropertiesCopy(i).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(i, null));
  }
}
function Tg(r, i) {
  const l = r, d = i, f = Xn(l[1]), g = Xn(d[1]);
  let m = Xn(d[0] - l[0]);
  m > Math.PI && (m -= 2 * Math.PI), m < -Math.PI && (m += 2 * Math.PI);
  const s = Math.log(Math.tan(g / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)), C = (ec(Math.atan2(m, s)) + 360) % 360;
  return C > 180 ? -(360 - C) : C;
}
function s1(r, i, l) {
  let d = i;
  i < 0 && (d = -Math.abs(d));
  const f = d / i1, g = r[0] * Math.PI / 180, m = Xn(r[1]), s = Xn(l), C = f * Math.cos(s);
  let T = m + C;
  Math.abs(T) > Math.PI / 2 && (T = T > 0 ? Math.PI - T : -Math.PI - T);
  const M = Math.log(Math.tan(T / 2 + Math.PI / 4) / Math.tan(m / 2 + Math.PI / 4)), z = Math.abs(M) > 1e-11 ? C / M : Math.cos(m), L = [(180 * (g + f * Math.sin(s) / z) / Math.PI + 540) % 360 - 180, 180 * T / Math.PI];
  return L[0] += L[0] - r[0] > 180 ? -360 : r[0] - L[0] > 180 ? 360 : 0, L;
}
function U6(r, i, l, d, f) {
  const g = d(r[0], r[1]), m = d(i[0], i[1]), { lng: s, lat: C } = f((g.x + m.x) / 2, (g.y + m.y) / 2);
  return [Di(s, l), Di(C, l)];
}
function G6(r, i, l) {
  const d = s1(r, 1e3 * Ms(r, i) / 2, Tg(r, i));
  return [Di(d[0], l), Di(d[1], l)];
}
function W_({ featureCoords: r, precision: i, unproject: l, project: d, projection: f }) {
  const g = [];
  for (let m = 0; m < r.length - 1; m++) {
    let s;
    if (f === "web-mercator") s = U6(r[m], r[m + 1], i, d, l);
    else {
      if (f !== "globe") throw new Error("Invalid projection");
      s = G6(r[m], r[m + 1], i);
    }
    g.push(s);
  }
  return g;
}
class q6 extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = i, this.selectionPointBehavior = l, this.coordinatePointBehavior = d;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(i) {
  }
  insert(i, l, d) {
    const f = this.store.getGeometryCopy(l), { midPointFeatureId: g, midPointSegment: m } = this.store.getPropertiesCopy(l), s = this.store.getGeometryCopy(g), C = s.type === "Polygon" ? s.coordinates[0] : s.coordinates;
    C.splice(m + 1, 0, f.coordinates), s.coordinates = s.type === "Polygon" ? [C] : C, this.store.updateGeometry([{ id: g, geometry: s }]), this.store.getPropertiesCopy(i)[Ai.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(i), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(C, g, d), this.selectionPointBehavior.create(C, s.type, g);
  }
  create(i, l, d) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(f, g, m, s, C, T) {
      return W_({ featureCoords: f, precision: m, project: s, unproject: C, projection: T }).map((M, z) => ({ geometry: { type: "Point", coordinates: M }, properties: g(z) }));
    })(i, (f) => ({ mode: this.mode, [un.MID_POINT]: true, midPointSegment: f, midPointFeatureId: l }), d, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(i) {
    if (this._midPoints.length !== 0) return W_({ featureCoords: i, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, d) => ({ id: this._midPoints[d], geometry: { type: "Point", coordinates: l } }));
  }
}
class W6 extends Kn {
  constructor(i) {
    super(i), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(i) {
  }
  create(i, l, d) {
    this._selectionPoints = this.store.create((function(f, g, m) {
      const s = [], C = g === "Polygon" ? f.length - 1 : f.length;
      for (let T = 0; T < C; T++) s.push({ geometry: { type: "Point", coordinates: f[T] }, properties: m(T) });
      return s;
    })(i, l, (f) => ({ mode: this.mode, index: f, [un.SELECTION_POINT]: true, [un.SELECTION_POINT_FEATURE_ID]: d })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(i) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, d) => ({ id: l, geometry: { type: "Point", coordinates: i[d] } }));
  }
  getOneUpdated(i, l) {
    if (this._selectionPoints[i] !== void 0) return { id: this._selectionPoints[i], geometry: { type: "Point", coordinates: l } };
  }
}
function l1(r, i) {
  let l = false;
  for (let m = 0, s = i.length; m < s; m++) {
    const C = i[m];
    for (let T = 0, M = C.length, z = M - 1; T < M; z = T++) (f = C[T])[1] > (d = r)[1] != (g = C[z])[1] > d[1] && d[0] < (g[0] - f[0]) * (d[1] - f[1]) / (g[1] - f[1]) + f[0] && (l = !l);
  }
  var d, f, g;
  return l;
}
const Ig = (r, i, l) => {
  const d = (g) => g * g, f = (g, m) => d(g.x - m.x) + d(g.y - m.y);
  return Math.sqrt(((g, m, s) => {
    const C = f(m, s);
    if (C === 0) return f(g, m);
    let T = ((g.x - m.x) * (s.x - m.x) + (g.y - m.y) * (s.y - m.y)) / C;
    return T = Math.max(0, Math.min(1, T)), f(g, { x: m.x + T * (s.x - m.x), y: m.y + T * (s.y - m.y) });
  })(r, i, l));
};
class Z6 extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = i, this.createClickBoundingBox = l, this.pixelDistance = d;
  }
  find(i, l) {
    let d, f, g, m, s = 1 / 0, C = 1 / 0, T = 1 / 0;
    const M = this.createClickBoundingBox.create(i), z = this.store.search(M);
    for (let L = 0; L < z.length; L++) {
      const A = z[L], O = A.geometry;
      if (O.type === "Point") {
        if (A.properties.selectionPoint || A.properties.coordinatePoint || !l && A.properties[un.MID_POINT]) continue;
        const U = this.pixelDistance.measure(i, O.coordinates);
        A.properties[un.MID_POINT] && U < this.pointerDistance && U < T ? (T = U, g = A) : !A.properties[un.MID_POINT] && U < this.pointerDistance && U < s && (s = U, d = A);
      } else if (O.type === "LineString") {
        if (d) continue;
        for (let U = 0; U < O.coordinates.length - 1; U++) {
          const X = O.coordinates[U], H = O.coordinates[U + 1], Q = Ig({ x: i.containerX, y: i.containerY }, this.project(X[0], X[1]), this.project(H[0], H[1]));
          Q < this.pointerDistance && Q < C && (C = Q, f = A);
        }
      } else if (O.type === "Polygon") {
        if (d || f) continue;
        l1([i.lng, i.lat], O.coordinates) && (m = A);
      }
    }
    return { clickedFeature: d || f || m, clickedMidPoint: g };
  }
}
class H6 extends Kn {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = i, this.featuresAtCursorEvent = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  startDragging(i, l) {
    this.draggedFeatureId = l, this.dragPosition = [i.lng, i.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(i, l) {
    const { clickedFeature: d } = this.featuresAtCursorEvent.find(i, true);
    return !(!d || d.id !== l);
  }
  drag(i, l) {
    if (!this.draggedFeatureId) return;
    const d = this.store.getGeometryCopy(this.draggedFeatureId), f = [i.lng, i.lat];
    if (d.type === "Polygon" || d.type === "LineString") {
      let g, m;
      if (d.type === "Polygon" ? (g = d.coordinates[0], m = g.length - 1) : (g = d.coordinates, m = g.length), !this.dragPosition) return false;
      for (let M = 0; M < m; M++) {
        const z = g[M];
        let L, A;
        if (this.config.projection === "web-mercator") {
          const O = Ri(this.dragPosition[0], this.dragPosition[1]), U = Ri(f[0], f[1]), X = Ri(z[0], z[1]), H = { x: O.x - U.x, y: O.y - U.y }, Q = X.x - H.x, ie = X.y - H.y, { lng: te, lat: re } = tc(Q, ie);
          L = te, A = re;
        } else {
          const O = [this.dragPosition[0] - f[0], this.dragPosition[1] - f[1]];
          L = z[0] - O[0], A = z[1] - O[1];
        }
        if (L = Di(L, this.config.coordinatePrecision), A = Di(A, this.config.coordinatePrecision), L > 180 || L < -180 || A > 90 || A < -90) return false;
        g[M] = [L, A];
      }
      d.type === "Polygon" && (g[g.length - 1] = [g[0][0], g[0][1]]);
      const s = this.selectionPoints.getUpdated(g) || [], C = this.midPoints.getUpdated(g) || [], T = this.coordinatePoints.getUpdated(this.draggedFeatureId, g) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: d }, ...s, ...C, ...T]), this.dragPosition = [i.lng, i.lat];
    } else d.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: f } }]), this.dragPosition = [i.lng, i.lat]);
  }
}
class X6 extends Kn {
  constructor(i, l, d, f, g, m, s) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g, this.coordinateSnapping = m, this.lineSnapping = s;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  snapCoordinate(i, l, d) {
    let f = [i.lng, i.lat];
    const g = (m) => !!(m.properties && m.properties.mode === d.properties.mode && m.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let m;
      m = this.lineSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l.toCoordinate) {
      let m;
      m = this.coordinateSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l != null && l.toCustom) {
      let m;
      m = l.toCustom(i, { currentCoordinate: this.draggedCoordinate.index, currentId: d.id, getCurrentGeometrySnapshot: d.id ? () => this.store.getGeometryCopy(d.id) : () => null, project: this.project, unproject: this.unproject }), m && (f = m);
    }
    return f;
  }
  drag(i, l, d, f) {
    const g = this.draggedCoordinate.id;
    if (g === null) return false;
    const m = this.draggedCoordinate.index, s = this.store.getGeometryCopy(g), C = this.store.getPropertiesCopy(g), T = s.type === "LineString" ? s.coordinates : s.coordinates[0], M = s.type === "Polygon" && (m === T.length - 1 || m === 0), z = { type: "Feature", id: g, geometry: s, properties: C }, L = this.snapCoordinate(i, f, z);
    if (i.lng > 180 || i.lng < -180 || i.lat > 90 || i.lat < -90) return false;
    if (M) {
      const H = T.length - 1;
      T[0] = L, T[H] = L;
    } else T[m] = L;
    const A = this.selectionPoints.getOneUpdated(m, L), O = A ? [A] : [], U = this.midPoints.getUpdated(T) || [], X = this.coordinatePoints.getUpdated(g, T) || [];
    return !(s.type !== "Point" && !l && k6({ geometry: s }) || d && !d(z, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: g, geometry: s }, ...O, ...U, ...X]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function Z_(r) {
  let i = 0, l = 0, d = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((f) => {
    i += f[0], l += f[1], d++;
  }, true), [i / d, l / d];
}
const u1 = (r, i) => {
  if (i === 0 || i === 360 || i === -360) return r;
  const l = 0.017453292519943295 * i, d = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([m, s]) => Ri(m, s)), f = d.reduce((m, s) => ({ x: m.x + s.x, y: m.y + s.y }), { x: 0, y: 0 });
  f.x /= d.length, f.y /= d.length;
  const g = d.map((m) => ({ x: f.x + (m.x - f.x) * Math.cos(l) - (m.y - f.y) * Math.sin(l), y: f.y + (m.x - f.x) * Math.sin(l) + (m.y - f.y) * Math.cos(l) })).map(({ x: m, y: s }) => [tc(m, s).lng, tc(m, s).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = g : r.geometry.coordinates = g, r;
};
function Mg(r) {
  const i = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((l) => {
    const { x: d, y: f } = Ri(l[0], l[1]);
    return [d, f];
  });
  return r.geometry.type === "Polygon" ? (function(l) {
    let d = 0, f = 0, g = 0;
    const m = l.length;
    for (let s = 0; s < m - 1; s++) {
      const [C, T] = l[s], [M, z] = l[s + 1], L = C * z - M * T;
      d += L, f += (C + M) * L, g += (T + z) * L;
    }
    return d /= 2, f /= 6 * d, g /= 6 * d, { x: f, y: g };
  })(i) : (function(l) {
    const d = l.length;
    let f = 0, g = 0;
    for (let m = 0; m < d; m++) {
      const [s, C] = l[m];
      f += s, g += C;
    }
    return { x: f / d, y: g / d };
  })(i);
}
class Y6 extends Kn {
  constructor(i, l, d, f) {
    super(i), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = i, this.selectionPoints = l, this.midPoints = d, this.coordinatePoints = f;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(i, l, d) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const f = this.selectedGeometry;
    if (f.type !== "Polygon" && f.type !== "LineString") return;
    const g = [i.lng, i.lat];
    let m;
    const s = { type: "Feature", geometry: f, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Mg(s));
      const L = Ri(i.lng, i.lat);
      if (m = P6(this.selectedGeometryWebMercatorCentroid, L), m === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = m);
      u1(s, -(this.lastBearing - m));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = Z_({ geometry: f })), m = Tg(this.selectedGeometryCentroid, g), !this.lastBearing) return void (this.lastBearing = m + 180);
      (function(L, A) {
        if (A === 0 || A === 360 || A === -360) return L;
        const O = Z_(L);
        (L.geometry.type === "Polygon" ? L.geometry.coordinates[0] : L.geometry.coordinates).forEach((U) => {
          const X = Tg(O, U) + A, H = (function(ie, te) {
            ie[0] += ie[0] - te[0] > 180 ? -360 : te[0] - ie[0] > 180 ? 360 : 0;
            const re = i1, J = te[1] * Math.PI / 180, Se = ie[1] * Math.PI / 180, fe = Se - J;
            let oe = Math.abs(ie[0] - te[0]) * Math.PI / 180;
            oe > Math.PI && (oe -= 2 * Math.PI);
            const de = Math.log(Math.tan(Se / 2 + Math.PI / 4) / Math.tan(J / 2 + Math.PI / 4)), xe = Math.abs(de) > 1e-11 ? fe / de : Math.cos(J);
            return Math.sqrt(fe * fe + xe * xe * oe * oe) * re;
          })(O, U), Q = s1(O, H, X);
          U[0] = Q[0], U[1] = Q[1];
        });
      })(s, -(this.lastBearing - (m + 180)));
    }
    const C = f.type === "Polygon" ? f.coordinates[0] : f.coordinates;
    C.forEach((L) => {
      L[0] = Di(L[0], this.coordinatePrecision), L[1] = Di(L[1], this.coordinatePrecision);
    });
    const T = this.midPoints.getUpdated(C) || [], M = this.selectionPoints.getUpdated(C) || [], z = this.coordinatePoints.getUpdated(l, C) || [];
    if (d && !d({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: f }, ...M, ...T, ...z]), this.projection === "web-mercator" ? this.lastBearing = m : this.projection === "globe" && (this.lastBearing = m + 180);
  }
}
class K6 extends Kn {
  constructor(i, l) {
    super(i), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = i, this.dragCoordinateResizeBehavior = l;
  }
  scale(i, l, d) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const f = this.dragCoordinateResizeBehavior.getDraggableIndex(i, l);
      this.dragCoordinateResizeBehavior.startDragging(l, f);
    }
    this.dragCoordinateResizeBehavior.drag(i, "center-fixed", d);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function c1({ coordinates: r, originX: i, originY: l, xScale: d, yScale: f }) {
  d === 1 && f === 1 || r.forEach((g) => {
    const { x: m, y: s } = Ri(g[0], g[1]), C = i + (m - i) * d, T = l + (s - l) * f, { lng: M, lat: z } = tc(C, T);
    g[0] = M, g[1] = z;
  });
}
class J6 extends Kn {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  isValidDragWebMercator(i, l, d) {
    switch (i) {
      case 0:
        if (l <= 0 || d >= 0) return false;
        break;
      case 1:
        if (d >= 0) return false;
        break;
      case 2:
        if (l >= 0 || d >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || d <= 0) return false;
        break;
      case 5:
        if (d <= 0) return false;
        break;
      case 6:
        if (l <= 0 || d <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const i = this.getFeature(this.draggedCoordinate.id);
    if (!i) return null;
    const l = this.getNormalisedCoordinates(i.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: i, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = Mg(d);
    if (!s) return null;
    const C = Ri(m[0], m[1]), { closestBBoxIndex: T } = this.getIndexesWebMercator(f, C), M = Ri(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: T, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  centerFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = Mg(d);
    if (!s) return null;
    const C = Ri(m[0], m[1]), { closestBBoxIndex: T } = this.getIndexesWebMercator(f, C), M = Ri(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: T, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  scaleFixedWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    if (!this.isValidDragWebMercator(i, l.x - f.x, l.y - f.y)) return null;
    let m = Xa(l, f) / Xa(l, d);
    return m < 0 && (m = this.minimumScale), c1({ coordinates: g, originX: l.x, originY: l.y, xScale: m, yScale: m }), g;
  }
  oppositeFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Ri(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), T = { x: d[s][0], y: d[s][1] }, M = Ri(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: T }), f;
  }
  oppositeWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Ri(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), T = { x: d[s][0], y: d[s][1] }, M = Ri(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: T }), f;
  }
  scaleWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    const m = l.x - f.x, s = l.y - f.y;
    if (!this.isValidDragWebMercator(i, m, s)) return null;
    let C = 1;
    m !== 0 && i !== 1 && i !== 5 && (C = 1 - (l.x - d.x - m) / m);
    let T = 1;
    return s !== 0 && i !== 3 && i !== 7 && (T = 1 - (l.y - d.y - s) / s), this.validateScale(C, T) ? (C < 0 && (C = this.minimumScale), T < 0 && (T = this.minimumScale), this.performWebMercatorScale(g, l.x, l.y, C, T), g) : null;
  }
  getFeature(i) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(i);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: i, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(i) {
    return i.type === "Polygon" ? i.coordinates[0] : i.coordinates;
  }
  validateScale(i, l) {
    const d = !isNaN(i) && l < Number.MAX_SAFE_INTEGER, f = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return d && f;
  }
  performWebMercatorScale(i, l, d, f, g) {
    i.forEach((m) => {
      const { x: s, y: C } = Ri(m[0], m[1]), T = l + (s - l) * f, M = d + (C - d) * g, { lng: z, lat: L } = tc(T, M);
      m[0] = z, m[1] = L;
    });
  }
  getBBoxWebMercator(i) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (i = i.map((s) => {
      const { x: C, y: T } = Ri(s[0], s[1]);
      return [C, T];
    })).forEach(([s, C]) => {
      s < l[0] && (l[0] = s), C < l[1] && (l[1] = C), s > l[2] && (l[2] = s), C > l[3] && (l[3] = C);
    });
    const [d, f, g, m] = l;
    return [[d, m], [(d + g) / 2, m], [g, m], [g, m + (f - m) / 2], [g, f], [(d + g) / 2, f], [d, f], [d, m + (f - m) / 2]];
  }
  getIndexesWebMercator(i, l) {
    let d, f = 1 / 0;
    for (let g = 0; g < i.length; g++) {
      const m = Xa({ x: l.x, y: l.y }, { x: i[g][0], y: i[g][1] });
      m < f && (d = g, f = m);
    }
    if (d === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[d], closestBBoxIndex: d };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  drag(i, l, d) {
    if (!this.draggedCoordinate.id) return false;
    const f = this.getFeature(this.draggedCoordinate.id);
    if (!f) return false;
    let g = null;
    if (l === "center" ? g = this.centerWebMercatorDrag(i) : l === "opposite" ? g = this.oppositeWebMercatorDrag(i) : l === "center-fixed" ? g = this.centerFixedWebMercatorDrag(i) : l === "opposite-fixed" && (g = this.oppositeFixedWebMercatorDrag(i)), !g) return false;
    for (let M = 0; M < g.length; M++) {
      const z = g[M];
      if (z[0] = Di(z[0], this.coordinatePrecision), z[1] = Di(z[1], this.coordinatePrecision), !Kg(z, this.coordinatePrecision)) return false;
    }
    const m = this.midPoints.getUpdated(g) || [], s = this.selectionPoints.getUpdated(g) || [], C = this.coordinatePoints.getUpdated(f.id, g) || [], T = { type: f.geometry.type, coordinates: f.geometry.type === "Polygon" ? [g] : g };
    return !(d && !d({ id: this.draggedCoordinate.id, type: "Feature", geometry: T, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: T }, ...s, ...m, ...C]), 0));
  }
}
const Q6 = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, H_ = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class eI extends C6 {
  constructor(i) {
    super(i, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = Q6, this.cursors = H_, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    if (super.updateOptions(i), this.cursors = i && i.cursors ? wn({}, this.cursors, i.cursors) : H_, (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : i != null && i.keyEvents && (this.keyEvents = wn({}, this.keyEvents, i.keyEvents)), (i == null ? void 0 : i.dragEventThrottle) !== void 0 && (this.dragEventThrottle = i.dragEventThrottle), (i == null ? void 0 : i.allowManualDeselection) !== void 0 && (this.allowManualDeselection = i.allowManualDeselection), i != null && i.flags) {
      this.flags = wn({}, this.flags, i.flags), this.validations = {};
      for (const l in this.flags) {
        const d = this.flags[l].feature;
        d && d.validation && (this.validations[l] = d.validation);
      }
    }
  }
  selectFeature(i) {
    this.select(i, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(i) {
    this.pixelDistance = new qf(i), this.clickBoundingBox = new Gf(i), this.featuresAtMouseEvent = new Z6(i, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new W6(i), this.coordinatePoints = new V6(i), this.midPoints = new q6(i, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new Pg(i, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new a1(i, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new Y6(i, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new H6(i, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new X6(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new J6(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new K6(i, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const i = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: un.SELECTED, value: false }));
    this.store.updateProperty(i), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(i) {
    if (!this.selectionPoints.ids.length) return;
    let l, d = 1 / 0;
    if (this.selectionPoints.ids.forEach((L) => {
      const A = this.store.getGeometryCopy(L), O = this.pixelDistance.measure(i, A.coordinates);
      O < this.pointerDistance && O < d && (d = O, l = this.store.getPropertiesCopy(L));
    }), !l) return;
    const f = l.selectionPointFeatureId, g = l.index, m = this.store.getPropertiesCopy(f), s = this.flags[m.mode], C = this.validations[m.mode];
    if (!(s && s.feature && s.feature.coordinates && s.feature.coordinates.deletable)) return;
    const T = this.store.getGeometryCopy(f);
    let M;
    if (T.type === "Polygon") {
      if (M = T.coordinates[0], M.length <= 4) return;
    } else if (T.type === "LineString" && (M = T.coordinates, M.length <= 2)) return;
    if (!M || (T.type !== "Polygon" || g !== 0 && g !== M.length - 1 ? M.splice(g, 1) : (M.shift(), M.pop(), M.push([M[0][0], M[0][1]])), C && !C({ id: f, type: "Feature", geometry: T, properties: m }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid)) return;
    const z = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(z), this.store.updateGeometry([{ id: f, geometry: T }]), m.coordinatePointIds && this.coordinatePoints.createOrUpdate(f), this.selectionPoints.create(M, T.type, f), s && s.feature && s.feature.coordinates && s.feature.coordinates.midpoints && this.midPoints.create(M, f, this.coordinatePrecision);
  }
  select(i, l = true) {
    if (this.selected[0] === i) return;
    const { mode: d } = this.store.getPropertiesCopy(i), f = this.flags[d];
    if (!f || !f.feature) return;
    const g = this.selected[0];
    if (g) {
      if (g === i) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [i], this.store.updateProperty([{ id: i, property: un.SELECTED, value: true }]), this.onSelect(i);
    const { type: m, coordinates: s } = this.store.getGeometryCopy(i);
    if (m !== "LineString" && m !== "Polygon") return;
    const C = m === "LineString" ? s : s[0];
    C && f && f.feature.coordinates && (this.selectionPoints.create(C, m, i), f.feature.coordinates.midpoints && this.midPoints.create(C, i, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const { clickedFeature: l, clickedMidPoint: d } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
    if (this.selected.length && d) this.midPoints.insert(this.selected[0], d.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  canScale(i) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => i.heldKeys.includes(l));
  }
  canRotate(i) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => i.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(i) {
    const l = this.canRotate(i), d = this.canScale(i);
    (l || d) && i.preventDefault();
  }
  onKeyDown(i) {
    this.preventDefaultKeyEvent(i);
  }
  onKeyUp(i) {
    if (this.preventDefaultKeyEvent(i), this.keyEvents.delete && i.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && i.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.selected.length) return;
    const d = this.store.getPropertiesCopy(this.selected[0]), f = this.flags[d.mode];
    if (!(f && f.feature && (f.feature.draggable || f.feature.coordinates && f.feature.coordinates.draggable || f.feature.coordinates && f.feature.coordinates.resizable || f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const g = this.selected[0], m = this.dragCoordinate.getDraggableIndex(i, g);
    if (f && f.feature && f.feature.coordinates && (f.feature.coordinates.draggable || f.feature.coordinates.resizable) && m !== -1) return this.setCursor(this.cursors.dragStart), f.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(g, m) : this.dragCoordinate.startDragging(g, m), void l(false);
    if (f && f.feature && f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: s } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
      if (this.selected.length && s) {
        this.midPoints.insert(g, s.id, this.coordinatePrecision);
        const C = this.dragCoordinate.getDraggableIndex(i, g);
        return this.dragCoordinate.startDragging(g, C), void l(false);
      }
    }
    return f && f.feature && f.feature.draggable && this.dragFeature.canDrag(i, g) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(i, g), void l(false)) : void 0;
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i)) return;
    const d = this.selected[0];
    if (!d) return;
    const f = this.store.getPropertiesCopy(d), g = this.flags[f.mode], m = (g && g.feature && g.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const s = this.validations[f.mode];
    if (g && g.feature && g.feature.rotateable && this.canRotate(i)) return l(false), void this.rotateFeature.rotate(i, d, s);
    if (g && g.feature && g.feature.scaleable && this.canScale(i)) return l(false), void this.scaleFeature.scale(i, d, s);
    if (this.dragCoordinateResizeFeature.isDragging() && g.feature && g.feature.coordinates && g.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(i, g.feature.coordinates.resizable, s);
    }
    if (this.dragCoordinate.isDragging()) {
      var C;
      const T = (C = g.feature) == null || (C = C.coordinates) == null ? void 0 : C.snappable;
      let M = { toCoordinate: false };
      return T === true ? M = { toCoordinate: true } : typeof T == "object" && (M = T), void this.dragCoordinate.drag(i, m, s, M);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(i, s) : l(true);
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(i) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((g) => {
      if (l) return;
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = true);
    });
    let d = false;
    if (this.selectionPoints.ids.forEach((g) => {
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = false, d = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: f } = this.featuresAtMouseEvent.find(i, true);
    this.setCursor(this.selected.length > 0 && (f && f.id === this.selected[0] || d) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(i) {
    const l = wn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.properties.mode === this.mode && i.geometry.type === "Point") {
      if (i.properties.selectionPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, i), l.zIndex = 30, l;
      if (i.properties.midPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, i), l.zIndex = 50, l;
    } else if (i.properties[un.SELECTED]) {
      if (i.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, i), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, i), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, i), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, i), l.zIndex = Ff, l;
      if (i.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, i), l.zIndex = Ff, l;
      if (i.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, i), l.zIndex = Ff, l;
    }
    return l;
  }
  afterFeatureUpdated(i) {
    if (this.selected.length && i.id === this.selected[0]) {
      var l, d;
      const f = this.flags[i.properties.mode];
      if (f == null || (l = f.feature) == null || !l.coordinates) return;
      const g = i.geometry.type, m = i.id;
      let s;
      if (this.selectionPoints.delete(), this.midPoints.delete(), g === "Polygon") s = i.geometry.coordinates[0];
      else {
        if (g !== "LineString") return;
        s = i.geometry.coordinates;
      }
      this.selectionPoints.create(s, g, m), f != null && (d = f.feature) != null && (d = d.coordinates) != null && d.midpoints && this.midPoints.create(g === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates, m, this.coordinatePrecision);
    }
  }
}
class tI extends cp {
  constructor(...i) {
    super(...i), this.type = Qu.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return wn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function d1(r, i, l, d, f) {
  for (; d > l; ) {
    if (d - l > 600) {
      const C = d - l + 1, T = i - l + 1, M = Math.log(C), z = 0.5 * Math.exp(2 * M / 3), L = 0.5 * Math.sqrt(M * z * (C - z) / C) * (T - C / 2 < 0 ? -1 : 1);
      d1(r, i, Math.max(l, Math.floor(i - T * z / C + L)), Math.min(d, Math.floor(i + (C - T) * z / C + L)), f);
    }
    const g = r[i];
    let m = l, s = d;
    for (Cd(r, l, i), f(r[d], g) > 0 && Cd(r, l, d); m < s; ) {
      for (Cd(r, m, s), m++, s--; f(r[m], g) < 0; ) m++;
      for (; f(r[s], g) > 0; ) s--;
    }
    f(r[l], g) === 0 ? Cd(r, l, s) : (s++, Cd(r, s, d)), s <= i && (l = s + 1), i <= s && (d = s - 1);
  }
}
function Cd(r, i, l) {
  const d = r[i];
  r[i] = r[l], r[l] = d;
}
function Uu(r, i) {
  Pd(r, 0, r.children.length, i, r);
}
function Pd(r, i, l, d, f) {
  f || (f = Zu([])), f.minX = 1 / 0, f.minY = 1 / 0, f.maxX = -1 / 0, f.maxY = -1 / 0;
  for (let g = i; g < l; g++) {
    const m = r.children[g];
    Td(f, r.leaf ? d(m) : m);
  }
  return f;
}
function Td(r, i) {
  return r.minX = Math.min(r.minX, i.minX), r.minY = Math.min(r.minY, i.minY), r.maxX = Math.max(r.maxX, i.maxX), r.maxY = Math.max(r.maxY, i.maxY), r;
}
function rI(r, i) {
  return r.minX - i.minX;
}
function iI(r, i) {
  return r.minY - i.minY;
}
function Wm(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function kf(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function nI(r, i) {
  const l = Math.max(r.minX, i.minX), d = Math.max(r.minY, i.minY), f = Math.min(r.maxX, i.maxX), g = Math.min(r.maxY, i.maxY);
  return Math.max(0, f - l) * Math.max(0, g - d);
}
function Zm(r, i) {
  return r.minX <= i.minX && r.minY <= i.minY && i.maxX <= r.maxX && i.maxY <= r.maxY;
}
function Pf(r, i) {
  return i.minX <= r.maxX && i.minY <= r.maxY && i.maxX >= r.minX && i.maxY >= r.minY;
}
function Zu(r) {
  return { children: r, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function X_(r, i, l, d, f) {
  const g = [i, l];
  for (; g.length; ) {
    if ((l = g.pop()) - (i = g.pop()) <= d) continue;
    const m = i + Math.ceil((l - i) / d / 2) * d;
    d1(r, m, i, l, f), g.push(i, m, m, l);
  }
}
class oI {
  constructor(i) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, i), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(i) {
    let l = this.data;
    const d = [];
    if (!Pf(i, l)) return d;
    const f = this.toBBox, g = [];
    for (; l; ) {
      for (let m = 0; m < l.children.length; m++) {
        const s = l.children[m], C = l.leaf ? f(s) : s;
        Pf(i, C) && (l.leaf ? d.push(s) : Zm(i, C) ? this._all(s, d) : g.push(s));
      }
      l = g.pop();
    }
    return d;
  }
  collides(i) {
    let l = this.data;
    if (Pf(i, l)) {
      const d = [];
      for (; l; ) {
        for (let f = 0; f < l.children.length; f++) {
          const g = l.children[f], m = l.leaf ? this.toBBox(g) : g;
          if (Pf(i, m)) {
            if (l.leaf || Zm(i, m)) return true;
            d.push(g);
          }
        }
        l = d.pop();
      }
    }
    return false;
  }
  load(i) {
    if (i.length < this._minEntries) {
      for (let d = 0; d < i.length; d++) this.insert(i[d]);
      return;
    }
    let l = this._build(i.slice(), 0, i.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const d = this.data;
        this.data = l, l = d;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(i) {
    this._insert(i, this.data.height - 1);
  }
  clear() {
    this.data = Zu([]);
  }
  remove(i) {
    let l = this.data;
    const d = this.toBBox(i), f = [], g = [];
    let m, s, C = false;
    for (; l || f.length; ) {
      if (l || (l = f.pop(), s = f[f.length - 1], m = g.pop(), C = true), l.leaf) {
        const T = l.children.indexOf(i);
        T !== -1 && (l.children.splice(T, 1), f.push(l), this._condense(f));
      }
      C || l.leaf || !Zm(l, d) ? s ? (m++, l = s.children[m], C = false) : l = null : (f.push(l), g.push(m), m = 0, s = l, l = l.children[0]);
    }
  }
  toBBox(i) {
    return i;
  }
  compareMinX(i, l) {
    return i.minX - l.minX;
  }
  compareMinY(i, l) {
    return i.minY - l.minY;
  }
  _all(i, l) {
    const d = [];
    for (; i; ) i.leaf ? l.push(...i.children) : d.push(...i.children), i = d.pop();
    return l;
  }
  _build(i, l, d, f) {
    const g = d - l + 1;
    let m, s = this._maxEntries;
    if (g <= s) return m = Zu(i.slice(l, d + 1)), Uu(m, this.toBBox), m;
    f || (f = Math.ceil(Math.log(g) / Math.log(s)), s = Math.ceil(g / Math.pow(s, f - 1))), m = Zu([]), m.leaf = false, m.height = f;
    const C = Math.ceil(g / s), T = C * Math.ceil(Math.sqrt(s));
    X_(i, l, d, T, this.compareMinX);
    for (let M = l; M <= d; M += T) {
      const z = Math.min(M + T - 1, d);
      X_(i, M, z, C, this.compareMinY);
      for (let L = M; L <= z; L += C) {
        const A = Math.min(L + C - 1, z);
        m.children.push(this._build(i, L, A, f - 1));
      }
    }
    return Uu(m, this.toBBox), m;
  }
  _chooseSubtree(i, l, d, f) {
    for (; f.push(l), !l.leaf && f.length - 1 !== d; ) {
      let s, C = 1 / 0, T = 1 / 0;
      for (let M = 0; M < l.children.length; M++) {
        const z = l.children[M], L = Wm(z), A = (g = i, m = z, (Math.max(m.maxX, g.maxX) - Math.min(m.minX, g.minX)) * (Math.max(m.maxY, g.maxY) - Math.min(m.minY, g.minY)) - L);
        A < T ? (T = A, C = L < C ? L : C, s = z) : A === T && L < C && (C = L, s = z);
      }
      l = s || l.children[0];
    }
    var g, m;
    return l;
  }
  _insert(i, l, d) {
    const f = d ? i : this.toBBox(i), g = [], m = this._chooseSubtree(f, this.data, l, g);
    for (m.children.push(i), Td(m, f); l >= 0 && g[l].children.length > this._maxEntries; ) this._split(g, l), l--;
    this._adjustParentBBoxes(f, g, l);
  }
  _split(i, l) {
    const d = i[l], f = d.children.length, g = this._minEntries;
    this._chooseSplitAxis(d, g, f);
    const m = this._chooseSplitIndex(d, g, f), s = Zu(d.children.splice(m, d.children.length - m));
    s.height = d.height, s.leaf = d.leaf, Uu(d, this.toBBox), Uu(s, this.toBBox), l ? i[l - 1].children.push(s) : this._splitRoot(d, s);
  }
  _splitRoot(i, l) {
    this.data = Zu([i, l]), this.data.height = i.height + 1, this.data.leaf = false, Uu(this.data, this.toBBox);
  }
  _chooseSplitIndex(i, l, d) {
    let f, g = 1 / 0, m = 1 / 0;
    for (let s = l; s <= d - l; s++) {
      const C = Pd(i, 0, s, this.toBBox), T = Pd(i, s, d, this.toBBox), M = nI(C, T), z = Wm(C) + Wm(T);
      M < g ? (g = M, f = s, m = z < m ? z : m) : M === g && z < m && (m = z, f = s);
    }
    return f || d - l;
  }
  _chooseSplitAxis(i, l, d) {
    const f = i.leaf ? this.compareMinX : rI, g = i.leaf ? this.compareMinY : iI;
    this._allDistMargin(i, l, d, f) < this._allDistMargin(i, l, d, g) && i.children.sort(f);
  }
  _allDistMargin(i, l, d, f) {
    i.children.sort(f);
    const g = this.toBBox, m = Pd(i, 0, l, g), s = Pd(i, d - l, d, g);
    let C = kf(m) + kf(s);
    for (let T = l; T < d - l; T++) {
      const M = i.children[T];
      Td(m, i.leaf ? g(M) : M), C += kf(m);
    }
    for (let T = d - l - 1; T >= l; T--) {
      const M = i.children[T];
      Td(s, i.leaf ? g(M) : M), C += kf(s);
    }
    return C;
  }
  _adjustParentBBoxes(i, l, d) {
    for (let f = d; f >= 0; f--) Td(l[f], i);
  }
  _condense(i) {
    for (let l, d = i.length - 1; d >= 0; d--) i[d].children.length === 0 ? d > 0 ? (l = i[d - 1].children, l.splice(l.indexOf(i[d]), 1)) : this.clear() : Uu(i[d], this.toBBox);
  }
}
class aI {
  constructor(i) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new oI(i && i.maxEntries ? i.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(i, l) {
    this.idToNode.set(i.id, l), this.nodeToId.set(l, i.id);
  }
  toBBox(i) {
    const l = [], d = [];
    let f;
    if (i.geometry.type === "Polygon") f = i.geometry.coordinates[0];
    else if (i.geometry.type === "LineString") f = i.geometry.coordinates;
    else {
      if (i.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      f = [i.geometry.coordinates];
    }
    for (let s = 0; s < f.length; s++) d.push(f[s][1]), l.push(f[s][0]);
    const g = Math.min(...d), m = Math.max(...d);
    return { minX: Math.min(...l), minY: g, maxX: Math.max(...l), maxY: m };
  }
  insert(i) {
    if (this.idToNode.get(String(i.id))) throw new Error("Feature already exists");
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  load(i) {
    const l = [], d = /* @__PURE__ */ new Set();
    i.forEach((f) => {
      const g = this.toBBox(f);
      if (this.setMaps(f, g), d.has(String(f.id))) throw new Error(`Duplicate feature ID found ${f.id}`);
      d.add(String(f.id)), l.push(g);
    }), this.tree.load(l);
  }
  update(i) {
    this.remove(i.id);
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  remove(i) {
    const l = this.idToNode.get(i);
    if (!l) throw new Error(`${i} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(i) {
    return this.tree.search(this.toBBox(i)).map((l) => this.nodeToId.get(l));
  }
  collides(i) {
    return this.tree.collides(this.toBBox(i));
  }
}
const sI = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const i = 16 * Math.random() | 0;
  return (r == "x" ? i : 3 & i | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class lI {
  constructor(i) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new aI(), this.tracked = !i || i.tracked !== false, this.idStrategy = i && i.idStrategy ? i.idStrategy : sI;
  }
  clone(i) {
    return JSON.parse(JSON.stringify(i));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(i) {
    return !!this.store[i];
  }
  load(i, l, d, f) {
    if (i.length === 0) return [];
    let g = this.clone(i);
    const m = [], s = [];
    return g = g.filter((C) => {
      C.id == null && (C.id = this.idStrategy.getId());
      const T = C.id;
      if (l) {
        const M = l(C);
        if (!M.valid) return s.push({ id: T, valid: false, reason: M.reason }), false;
      }
      if (this.tracked) {
        if (C.properties.createdAt) {
          if (!O_(C.properties.createdAt)) return s.push({ id: C.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else C.properties.createdAt = +/* @__PURE__ */ new Date();
        if (C.properties.updatedAt) {
          if (!O_(C.properties.updatedAt)) return s.push({ id: C.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else C.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(T) ? (s.push({ id: T, valid: false, reason: `Feature already exists with this id: ${T}` }), false) : (this.store[T] = C, m.push(T), d && d(C), s.push({ id: T, valid: true }), true);
    }), this.spatialIndex.load(g), m.length > 0 && this._onChange(m, "create", f), s;
  }
  search(i, l) {
    const d = this.spatialIndex.search(i).map((f) => this.store[f]);
    return this.clone(l ? d.filter(l) : d);
  }
  registerOnChange(i) {
    this._onChange = (l, d, f) => {
      i(l, d, f);
    };
  }
  getGeometryCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(i, l) {
    const d = [];
    i.forEach(({ id: f, property: g, value: m }) => {
      const s = this.store[f];
      if (!s) throw new Error(`No feature with this (${f}), can not update geometry`);
      d.push(f), m === void 0 ? delete s.properties[g] : s.properties[g] = m, this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  updateGeometry(i, l) {
    const d = [];
    i.forEach(({ id: f, geometry: g }) => {
      d.push(f);
      const m = this.store[f];
      if (!m) throw new Error(`No feature with this (${f}), can not update geometry`);
      m.geometry = this.clone(g), this.spatialIndex.update(m), this.tracked && (m.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  create(i, l) {
    const d = [];
    return i.forEach(({ geometry: f, properties: g }) => {
      let m, s = wn({}, g);
      this.tracked && (m = +/* @__PURE__ */ new Date(), g ? (s.createdAt = typeof g.createdAt == "number" ? g.createdAt : m, s.updatedAt = typeof g.updatedAt == "number" ? g.updatedAt : m) : s = { createdAt: m, updatedAt: m });
      const C = this.getId(), T = { id: C, type: "Feature", geometry: f, properties: s };
      this.store[C] = T, this.spatialIndex.insert(T), d.push(C);
    }), this._onChange && this._onChange([...d], "create", l), d;
  }
  delete(i, l) {
    i.forEach((d) => {
      if (!this.store[d]) throw new Error(`No feature with id ${d}, can not delete`);
      delete this.store[d], this.spatialIndex.remove(d);
    }), this._onChange && this._onChange([...i], "delete", l);
  }
  copy(i) {
    return this.clone(this.store[i]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((i) => this.store[i]));
  }
  copyAllWhere(i) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && i(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class Gu {
  constructor({ name: i, callback: l, unregister: d, register: f }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = i, this.register = () => {
      this.registered || (this.registered = true, f(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, d(l));
    }, this.callback = l;
  }
}
var uI = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const i = this.getMapEventElement(), { left: l, top: d } = i.getBoundingClientRect();
    return { containerX: r.clientX - l, containerY: r.clientY - d };
  }
  getDrawEventFromEvent(r, i = false) {
    const l = this.getLngLatFromEvent(r);
    if (!l) return null;
    const { lng: d, lat: f } = l, { containerX: g, containerY: m } = this.getMapElementXYPosition(r), s = this.getButton(r), C = Array.from(this._heldKeys);
    return { lng: Di(d, this._coordinatePrecision), lat: Di(f, this._coordinatePrecision), containerX: g, containerY: m, button: s, heldKeys: C, isContextMenu: i };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((i) => {
      i.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new Gu({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState = "pre-dragging", this._lastDrawEvent = i);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new Gu({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const i = this.getDrawEventFromEvent(r);
      if (i) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(i), this._lastDrawEvent = i;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, d = { x: i.containerX, y: i.containerY }, f = this._currentModeCallbacks.getState(), g = Xa(l, d);
        let m = false;
        if (m = f === "drawing" ? g < this._minPixelDragDistanceDrawing : f === "selecting" ? g < this._minPixelDragDistanceSelecting : g < this._minPixelDragDistance, m) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(i, (s) => {
          this.setDraggability.bind(this)(s);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(i, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new Gu({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new Gu({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(i, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (i.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(i)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new Gu({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new Gu({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
function Eg(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return true;
  if (r === void 0) return false;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return false;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const i = Object.getPrototypeOf(r);
    if (i !== Object.prototype && i !== null) return false;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return false;
  if (Array.isArray(r)) {
    for (const i of r) if (!Eg(i)) return false;
  }
  return typeof r == "object" && Object.keys(r).every((i) => typeof i == "string" && Eg(r[i]));
}
class cI {
  constructor(i) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = i.adapter, this._mode = new tI();
    const l = /* @__PURE__ */ new Set(), d = i.modes.reduce((M, z) => {
      if (l.has(z.mode)) throw new Error(`There is already a ${z.mode} mode provided`);
      return l.add(z.mode), M[z.mode] = z, M;
    }, {}), f = Object.keys(d);
    if (f.length === 0) throw new Error("No modes provided");
    f.forEach((M) => {
      if (d[M].type === Qu.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = M;
      }
    }), this._modes = wn({}, d, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new lI({ tracked: !!i.tracked, idStrategy: i.idStrategy ? i.idStrategy : void 0 });
    const g = (M) => {
      const z = [], L = this._store.copyAll().filter((A) => !M.includes(A.id) || (z.push(A), false));
      return { changed: z, unchanged: L };
    }, m = (M, z) => {
      this._enabled && this._eventListeners.finish.forEach((L) => {
        L(M, z);
      });
    }, s = (M, z, L) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((U) => {
        U(M, z, L);
      });
      const { changed: A, unchanged: O } = g(M);
      z === "create" ? this._adapter.render({ created: A, deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles()) : z === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: A }, this.getModeStyles()) : z === "delete" ? this._adapter.render({ created: [], deletedIds: M, unchanged: O, updated: [] }, this.getModeStyles()) : z === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles());
    }, C = (M) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((A) => {
        A(M);
      });
      const { changed: z, unchanged: L } = g([M]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: z }, this.getModeStyles());
    }, T = (M) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((A) => {
        A();
      });
      const { changed: z, unchanged: L } = g([M]);
      z && this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: z }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((M) => {
      this._modes[M].register({ mode: M, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: s, onSelect: C, onDeselect: T, onFinish: m, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const i = {};
    return Object.keys(this._modes).forEach((l) => {
      i[l] = (d) => this._instanceSelectMode && d.properties[un.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(d) : this._modes[l].styleFeature.bind(this._modes[l])(d);
    }), i;
  }
  featuresAtLocation({ lng: i, lat: l }, d) {
    const f = d && d.pointerDistance !== void 0 ? d.pointerDistance : 30, g = !d || d.ignoreSelectFeatures === void 0 || d.ignoreSelectFeatures, m = !(!d || d.ignoreCoordinatePoints === void 0) && d.ignoreCoordinatePoints, s = !(!d || d.ignoreCurrentlyDrawing === void 0) && d.ignoreCurrentlyDrawing, C = !(!d || d.ignoreClosingPoints === void 0) && d.ignoreClosingPoints, T = this._adapter.unproject.bind(this._adapter), M = this._adapter.project.bind(this._adapter), z = M(i, l), L = o1({ unproject: T, point: z, pointerDistance: f });
    return this._store.search(L).filter((A) => {
      if (g && (A.properties[un.MID_POINT] || A.properties[un.SELECTION_POINT]) || m && A.properties[Ai.COORDINATE_POINT] || C && A.properties[Ai.CLOSING_POINT] || s && A.properties[Ai.CURRENTLY_DRAWING]) return false;
      if (A.geometry.type === "Point") {
        const O = A.geometry.coordinates, U = M(O[0], O[1]);
        return Xa(z, U) < f;
      }
      if (A.geometry.type === "LineString") {
        const O = A.geometry.coordinates;
        for (let U = 0; U < O.length - 1; U++) {
          const X = O[U], H = O[U + 1];
          if (Ig(z, M(X[0], X[1]), M(H[0], H[1])) < f) return true;
        }
        return false;
      }
      if (l1([i, l], A.geometry.coordinates)) return true;
      if (d != null && d.includePolygonsWithinPointerDistance) {
        const O = A.geometry.coordinates;
        for (const U of O) for (let X = 0; X < U.length - 1; X++) {
          const H = U[X], Q = U[X + 1], ie = M(H[0], H[1]), te = M(Q[0], Q[1]);
          if (Ig(z, ie, te) < f) return true;
        }
      }
      return false;
    });
  }
  getSelectModeOrThrow() {
    const i = this.getSelectMode({ switchToSelectMode: true });
    if (!i) throw new Error("No select mode defined in instance");
    return i;
  }
  getSelectMode({ switchToSelectMode: i }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return i && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(i) {
    return !!(i.properties[un.MID_POINT] || i.properties[un.SELECTION_POINT] || i.properties[Ai.COORDINATE_POINT] || i.properties[Ai.SNAPPING_POINT]);
  }
  setModeStyles(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].styles = l;
  }
  updateModeOptions(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(i) {
    if (this._store.has(i)) return this._store.copy(i);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(i) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[i], this._mode.start();
  }
  removeFeatures(i) {
    this.checkEnabled();
    const l = [];
    i.forEach((d) => {
      if (!this._store.has(d)) throw new Error(`No feature with id ${d}, can not delete`);
      const f = this._store.copy(d);
      f.properties[un.SELECTED] && this.deselectFeature(d), f.properties[Ai.COORDINATE_POINT_IDS] && l.push(...f.properties[Ai.COORDINATE_POINT_IDS]);
    }), this._store.delete([...i, ...l], { origin: "api" });
  }
  selectFeature(i) {
    this.getSelectModeOrThrow().selectFeature(i);
  }
  deselectFeature(i) {
    this.getSelectModeOrThrow().deselectFeature(i);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(i) {
    return this._store.has(i);
  }
  checkIsReservedProperty(i) {
    return ![...Object.values(un), ...Object.values(Ai)].includes(i);
  }
  updateFeatureProperties(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode;
    if (!this._modes[f]) throw new Error(`No mode with name ${f} present in instance`);
    const g = Object.entries(l);
    g.forEach(([m, s]) => {
      if (!this.checkIsReservedProperty(m)) throw new Error(`You are trying to update a reserved property name: ${m}. Please choose another name.`);
      if (s !== void 0 && !Eg(s)) throw new Error(`Invalid JSON value provided for property ${m}`);
    }), this._store.updateProperty(g.map(([m, s]) => ({ id: d.id, property: m, value: s })), { origin: "api" });
  }
  updateFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(d && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== d.geometry.type) throw new Error(`Geometry type mismatch: expected ${d.geometry.type}, got ${l.type}`);
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    const m = wn({}, d, { geometry: l }), s = g.validateFeature(m);
    if (!s.valid) throw new Error(`Feature validation failed: ${s.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: d.id, geometry: l }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(m);
      const C = m.properties[un.SELECTED], T = this.getSelectMode({ switchToSelectMode: false });
      T && C && T.afterFeatureUpdated(m);
    }
  }
  transformFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    let d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    let m;
    if (d.geometry.type === "Polygon") m = d.geometry.coordinates[0];
    else {
      if (d.geometry.type !== "LineString") throw new Error(`Feature geometry type ${d.geometry.type} is not supported for transformation`);
      m = d.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: s, y: C } = Ri(l.origin[0], l.origin[1]);
      c1({ coordinates: m, originX: s, originY: C, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (d = u1(d, l.options.angle || 0), m = d.geometry.type === "Polygon" ? d.geometry.coordinates[0] : d.geometry.coordinates);
    if (m = m.map((s) => [Di(s[0], this._adapter.getCoordinatePrecision()), Di(s[1], this._adapter.getCoordinatePrecision())]), d.geometry.coordinates = d.geometry.type === "Polygon" ? [m] : m, this._store.updateGeometry([{ id: d.id, geometry: d.geometry }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(d);
      const s = d.properties[un.SELECTED], C = this.getSelectMode({ switchToSelectMode: false });
      C && s && C.afterFeatureUpdated(d);
    }
  }
  addFeatures(i) {
    return this.checkEnabled(), i.length === 0 ? [] : this._store.load(i, (l) => {
      if (B_(l)) {
        const d = l.properties.mode, f = this._modes[d];
        if (!f) return { id: l.id, valid: false, reason: `${d} mode is not in the list of instantiated modes` };
        const g = f.validateFeature.bind(f)(l);
        return { id: l.id, valid: g.valid, reason: g.reason ? g.reason : g.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (B_(l)) {
        const d = this._modes[l.properties.mode];
        d && d.afterFeatureAdded && d.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((i) => {
        i();
      });
    }, getState: () => this._mode.state, onClick: (i) => {
      this._mode.onClick(i);
    }, onMouseMove: (i) => {
      this._mode.onMouseMove(i);
    }, onKeyDown: (i) => {
      this._mode.onKeyDown(i);
    }, onKeyUp: (i) => {
      this._mode.onKeyUp(i);
    }, onDragStart: (i, l) => {
      this._mode.onDragStart(i, l);
    }, onDrag: (i, l) => {
      this._mode.onDrag(i, l);
    }, onDragEnd: (i, l) => {
      this._mode.onDragEnd(i, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(i, l) {
    const { lng: d, lat: f } = i;
    return this.featuresAtLocation({ lng: d, lat: f }, l);
  }
  getFeaturesAtPointerEvent(i, l) {
    const d = this._adapter.getLngLatFromEvent.bind(this._adapter)(i);
    return d === null ? [] : this.featuresAtLocation(d, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) || d.push(l);
  }
  off(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) && d.splice(d.indexOf(l), 1);
  }
}
class dI extends uI.TerraDrawBaseAdapter {
  constructor(i) {
    super(i), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = i.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = i.renderBelowLayerId, this._prefixId = i.prefixId || "td";
  }
  _addGeoJSONSource(i, l) {
    this._map.addSource(i, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(i) {
    return this._map.addLayer({ id: i + "-outline", source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(i, l) {
    l === "Point" && this._addPointLayer(i), l === "LineString" && this._addLineLayer(i), l === "Polygon" && (this._addFillLayer(i), this._addFillOutlineLayer(i));
  }
  _addGeoJSONLayer(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._addGeoJSONSource(d, l), this._addLayer(d, i), d;
  }
  _setGeoJSONLayerData(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._map.getSource(d).setData({ type: "FeatureCollection", features: l }), d;
  }
  updateChangedIds(i) {
    [...i.updated, ...i.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), i.deletedIds.length > 0 && (this.changedIds.deletion = true), i.created.length === 0 && i.updated.length === 0 && i.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(i) {
    const { left: l, top: d } = this._container.getBoundingClientRect();
    return this.unproject(i.clientX - l, i.clientY - d);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(i) {
    i ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(i, l) {
    const { x: d, y: f } = this._map.project({ lng: i, lat: l });
    return { x: d, y: f };
  }
  unproject(i, l) {
    const { lng: d, lat: f } = this._map.unproject({ x: i, y: l });
    return { lng: d, lat: f };
  }
  setCursor(i) {
    const l = this._map.getCanvas();
    i === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = i;
  }
  setDoubleClickToZoom(i) {
    i ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(i, l) {
    this.updateChangedIds(i), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const d = [...i.created, ...i.updated, ...i.unchanged], f = [], g = [], m = [];
      for (let M = 0; M < d.length; M++) {
        const z = d[M], { properties: L } = z, A = l[L.mode](z);
        z.geometry.type === "Point" ? (L.pointColor = A.pointColor, L.pointOutlineColor = A.pointOutlineColor, L.pointOutlineWidth = A.pointOutlineWidth, L.pointWidth = A.pointWidth, L.zIndex = A.zIndex, f.push(z)) : z.geometry.type === "LineString" ? (L.lineStringColor = A.lineStringColor, L.lineStringWidth = A.lineStringWidth, g.push(z)) : z.geometry.type === "Polygon" && (L.polygonFillColor = A.polygonFillColor, L.polygonFillOpacity = A.polygonFillOpacity, L.polygonOutlineColor = A.polygonOutlineColor, L.polygonOutlineWidth = A.polygonOutlineWidth, m.push(z));
      }
      const s = this.changedIds.deletion || this.changedIds.styling, C = s || this.changedIds.linestrings, T = s || this.changedIds.polygons;
      (s || this.changedIds.points) && this._setGeoJSONLayerData("Point", f), C && this._setGeoJSONLayerData("LineString", g), T && this._setGeoJSONLayerData("Polygon", m), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(i) {
    var l;
    super.register(i);
    const d = this._addGeoJSONLayer("Polygon", []), f = this._addGeoJSONLayer("LineString", []), g = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(g, this._renderBeforeLayerId), this._map.moveLayer(f, g), this._map.moveLayer(d + "-outline", f), this._map.moveLayer(d, f)), (l = this._currentModeCallbacks) != null && l.onReady && this._currentModeCallbacks.onReady();
  }
}
const bn = [];
for (let r = 0; r < 256; ++r) bn.push((r + 256).toString(16).slice(1));
function hI(r, i = 0) {
  return (bn[r[i + 0]] + bn[r[i + 1]] + bn[r[i + 2]] + bn[r[i + 3]] + "-" + bn[r[i + 4]] + bn[r[i + 5]] + "-" + bn[r[i + 6]] + bn[r[i + 7]] + "-" + bn[r[i + 8]] + bn[r[i + 9]] + "-" + bn[r[i + 10]] + bn[r[i + 11]] + bn[r[i + 12]] + bn[r[i + 13]] + bn[r[i + 14]] + bn[r[i + 15]]).toLowerCase();
}
let Hm;
const fI = new Uint8Array(16);
function pI() {
  if (!Hm) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Hm = crypto.getRandomValues.bind(crypto);
  }
  return Hm(fI);
}
const mI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Y_ = { randomUUID: mI };
function Ad(r, i, l) {
  var _a3;
  if (Y_.randomUUID && !r) return Y_.randomUUID();
  r = r || {};
  const d = r.random ?? ((_a3 = r.rng) == null ? void 0 : _a3.call(r)) ?? pI();
  if (d.length < 16) throw new Error("Random bytes length must be >= 16");
  return d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, hI(d);
}
function Xo() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function gI() {
  return { ...Xo(), version: 1, signature: void 0 };
}
class Rl {
  constructor(i = Ad(), l, d, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = i, this.routes = l || { id: Ad(), meta: Xo(), routes: [] }, this.drafts = d || { id: Ad(), meta: Xo(), drafts: [] }, this.meta = { ...gI(), ...f };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(i) {
    return new Rl(i.id, i.routes, i.drafts, i.meta);
  }
  clone() {
    return Rl.fromStorage(this.toStorage());
  }
  updateName(i) {
    this.meta.name = i, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(i) {
    this.meta.description = i, this.meta.modification_timestamp = Date.now();
  }
  addTag(i) {
    this.meta.tags.includes(i) || (this.meta.tags.push(i), this.meta.modification_timestamp = Date.now());
  }
  removeTag(i) {
    const l = this.meta.tags.indexOf(i);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class vI {
  constructor(i = [], l = Ad(), d = Xo()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = d || Xo(), this.routesInternal = i;
  }
  get name() {
    return this.meta || (this.meta = Xo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Xo()), this.meta.name = i;
  }
  get routes() {
    return Ga(this.routesInternal);
  }
  set routes(i) {
    this.routesInternal = Ga(i);
  }
  findRoute(i) {
    return this.routesInternal.find((l) => l.id === i);
  }
  existRoute(i) {
    return this.routesInternal.some((l) => l.id === i);
  }
  addRoute(i) {
    if (this.existRoute(i.id)) throw new Error(`[CartoSketch.Route] Route ${i.id} already exist`);
    this.routesInternal.push(Ga(i)), this.updateModificationTime();
  }
  updateRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${i.id} not found`);
    this.routesInternal[l] = Ga(i), this.updateModificationTime();
  }
  removeRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((i) => i.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((i) => i.exportToStorage()) });
  }
}
class Xm {
  constructor(i = Ad(), l = [], d = {}, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = i, this.meta = { ...Xo(), record_timespan: 0, ...f }, this.properties = d, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = Xo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Xo()), this.meta.name = i;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(i) {
    this.meta.distance = i;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(i) {
    this.meta.record_timespan = i;
  }
  setPoints(i) {
    this.points = Ga(i), this.updateModificationTime();
  }
  appendPoint(i) {
    this.points.push(Ga(i)), this.updateModificationTime();
  }
  getPoints() {
    return Ga(this.points);
  }
  setProperties(i) {
    const l = Ga(i);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((i) => [i.longitude, i.latitude]) } };
  }
  exportToStorage() {
    return Ga({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var ai = ((r) => (r.MIGRATION_FAILED = "MIGRATION_FAILED", r.INVALID_VERSION = "INVALID_VERSION", r.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", r.ROLLBACK_FAILED = "ROLLBACK_FAILED", r.VALIDATION_FAILED = "VALIDATION_FAILED", r.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", r.DATA_CORRUPTION = "DATA_CORRUPTION", r))(ai || {});
class fi extends Uw {
  constructor(i, l = "MIGRATION_FAILED", d) {
    super(i, d);
    __publicField(this, "code");
    __publicField(this, "domain", Gw.GENERIC);
    this.code = l;
  }
}
class pa extends fi {
  constructor(i, l = "INVALID_VERSION", d, f, g) {
    super(i, l, g), this.currentVersion = d, this.targetVersion = f;
  }
}
class jr extends fi {
  constructor(i, l, d, f) {
    super(i, "VALIDATION_FAILED", f), this.field = l, this.value = d;
  }
}
class K_ extends fi {
  constructor(i, l, d) {
    super(i, "DATA_CORRUPTION", d), this.corruptedData = l;
  }
}
class _I extends fi {
  constructor(i, l, d, f) {
    super(i, "ROLLBACK_FAILED", f), this.originalError = l, this.rollbackError = d;
  }
}
class Sd {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(i) {
    try {
      if (typeof i == "object" && i !== null && "version" in i) {
        const l = i.version;
        if (typeof l == "number" && l >= 0) return Oi(l);
      }
      if (this.isRouteCollectionFormat(i)) return Oi(0);
      if (this.isSketchArrayFormat(i)) return Oi(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const d = l instanceof pa ? l : new pa(`Failed to extract version from data: ${l}`, ai.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static isRouteCollectionFormat(i) {
    return typeof i == "object" && i !== null && "routes" in i && !("sketches" in i) && Array.isArray(i.routes);
  }
  static isSketchArrayFormat(i) {
    return Array.isArray(i) && i.length > 0 && this.isSketchObject(i[0]);
  }
  static isSketchObject(i) {
    return typeof i == "object" && i !== null && "id" in i && "meta" in i && "routes" in i && "drafts" in i;
  }
  static validateVersion(i) {
    try {
      if (i < this.MIN_SUPPORTED_VERSION) throw new pa(`Version ${i} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, ai.UNSUPPORTED_VERSION, i);
      if (i > this.CURRENT_VERSION) throw new pa(`Version ${i} is above current version ${this.CURRENT_VERSION}`, ai.UNSUPPORTED_VERSION, i, this.CURRENT_VERSION);
      return Oi(void 0);
    } catch (l) {
      const d = l instanceof pa ? l : new pa(`Version validation failed: ${l}`, ai.INVALID_VERSION, i, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static addVersionMetadata(i, l = this.CURRENT_VERSION) {
    return { ...i, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(i) {
    try {
      if (typeof i == "object" && i !== null && this.VERSION_KEY in i) {
        const l = i[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return Oi(l);
      }
      return Oi(null);
    } catch (l) {
      const d = l instanceof pa ? l : new pa(`Failed to extract version metadata: ${l}`, ai.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static isValidVersionInfo(i) {
    return typeof i == "object" && i !== null && "version" in i && "timestamp" in i && typeof i.version == "number" && typeof i.timestamp == "number";
  }
  static determineMigrationPath(i, l) {
    try {
      const d = this.validateVersion(i);
      if (d.isErr()) throw d.error;
      const f = this.validateVersion(l);
      if (f.isErr()) throw f.error;
      if (i === l) return Oi([]);
      const g = [], m = i < l ? 1 : -1;
      for (let s = i; s !== l; s += m) g.push(s + m);
      return Oi(g);
    } catch (d) {
      const f = d instanceof pa ? d : new pa(`Failed to determine migration path: ${d}`, ai.INVALID_VERSION, i, l, d instanceof Error ? d : new Error(String(d)));
      return zr(f);
    }
  }
  static isMigrationNeeded(i) {
    return this.extractVersion(i).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(Sd, "CURRENT_VERSION", 1);
__publicField(Sd, "VERSION_KEY", "_data_version");
__publicField(Sd, "MIN_SUPPORTED_VERSION", 0);
class Wa {
  static validateSketchData(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Sketch data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes", "drafts"];
      for (const g of d) if (!(g in l)) throw new jr(`Missing required field: ${g}`, g, l[g]);
      if (typeof l.id != "string" || !l.id) throw new jr("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new jr("Sketch meta must be an object", "meta", l.meta);
      const f = this.validateRouteCollectionData(l.routes);
      if (f.isErr()) throw f.error;
      if (!l.drafts || typeof l.drafts != "object") throw new jr("Sketch drafts must be an object", "drafts", l.drafts);
      return Oi(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateRouteCollectionData(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Route collection data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes"];
      for (const f of d) if (!(f in l)) throw new jr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new jr("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new jr("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new jr("Routes must be an array", "routes", l.routes);
      for (let f = 0; f < l.routes.length; f++) {
        const g = l.routes[f], m = this.validateRouteItem(g);
        if (m.isErr()) throw new jr(`Invalid route at index ${f}: ${m.error.message}`, `routes[${f}]`, g, m.error);
      }
      return Oi(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateRouteItem(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Route item must be an object", "data", i);
      const l = i, d = ["id", "meta", "properties", "points"];
      for (const f of d) if (!(f in l)) throw new jr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new jr("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new jr("Route points must be an array", "points", l.points);
      for (let f = 0; f < l.points.length; f++) {
        const g = l.points[f];
        if (!g || typeof g != "object") throw new jr(`Route point at index ${f} must be an object`, `points[${f}]`, g);
        const m = g;
        if (typeof m.latitude != "number" || typeof m.longitude != "number") throw new jr(`Route point at index ${f} must have numeric latitude and longitude`, `points[${f}]`, g);
      }
      return Oi(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateSketchArray(i) {
    try {
      if (!Array.isArray(i)) throw new jr("Sketch array must be an array", "data", i);
      if (i.length === 0) throw new jr("Sketch array cannot be empty", "data.length", i.length);
      for (let l = 0; l < i.length; l++) {
        const d = i[l], f = this.validateSketchData(d);
        if (f.isErr()) throw new jr(`Invalid sketch at index ${l}: ${f.error.message}`, `[${l}]`, d, f.error);
      }
      return Oi(i);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateData(i, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(i);
      case "route-collection":
        return this.validateRouteCollectionData(i);
      case "sketch-array":
        return this.validateSketchArray(i);
      default:
        return zr(new jr(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(i, l) {
    try {
      const d = this.validateData(i, l);
      return d.isErr() ? zr(new K_(`Data validation failed: ${d.error.message}`, i, d.error)) : Oi({ isValid: true, errors: [], warnings: [] });
    } catch (d) {
      return zr(new K_(`Data integrity check failed: ${d}`, i, d instanceof Error ? d : new Error(String(d))));
    }
  }
}
class yI {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(i) {
    try {
      const l = Wa.validateRouteCollectionData(i);
      if (l.isErr()) return zr(new fi(`Invalid route collection data: ${l.error.message}`, ai.VALIDATION_FAILED, l.error));
      const d = l.value, f = new Rl();
      f.meta.name = d.meta.name || "Migrated Routes", f.meta.description = d.meta.description || "Migrated from route collection", f.meta.creation_timestamp = d.meta.creation_timestamp, f.meta.modification_timestamp = Date.now(), f.routes = d;
      const g = [f.toStorage()];
      return Oi(g);
    } catch (l) {
      return zr(new fi(`Route collection to sketch migration failed: ${l}`, ai.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(i) {
    try {
      const l = Wa.validateSketchArray(i);
      if (l.isErr()) return zr(new fi(`Invalid sketch array data for rollback: ${l.error.message}`, ai.VALIDATION_FAILED, l.error));
      const d = l.value;
      if (d.length === 0) return zr(new fi("Cannot rollback: empty sketch array", ai.MIGRATION_FAILED));
      const f = d[0];
      return Oi(f.routes);
    } catch (l) {
      return zr(new fi(`Route collection to sketch rollback failed: ${l}`, ai.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(i) {
    return Wa.validateRouteCollectionData(i).map(() => {
    }).mapErr((l) => new jr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Wa.validateSketchArray(i).map(() => {
    }).mapErr((l) => new jr(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class bI {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return zr(new fi("Sketch V1 to V2 migration not yet implemented", ai.STRATEGY_NOT_FOUND));
  }
  validateBefore(i) {
    return Wa.validateSketchArray(i).map(() => {
    }).mapErr((l) => new jr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return zr(new jr("Sketch V2 validation not yet implemented", void 0, i));
  }
}
const _xI = class _xI {
  static register(i) {
    const l = this.getStrategyKey(i.fromVersion, i.toVersion);
    this.strategies.set(l, i);
  }
  static getStrategy(i, l) {
    const d = this.getStrategyKey(i, l), f = this.strategies.get(d);
    return f ? Oi(f) : zr(new fi(`No migration strategy found for version ${i} to ${l}`, ai.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(i, l) {
    const d = this.getStrategyKey(i, l);
    return this.strategies.has(d);
  }
  static getStrategyKey(i, l) {
    return `${i}->${l}`;
  }
};
__publicField(_xI, "strategies", /* @__PURE__ */ new Map());
_xI.register(new yI()), _xI.register(new bI());
let xI = _xI;
class wI {
  static createStrategy(i, l) {
    return xI.getStrategy(i, l);
  }
  static createStrategiesForPath(i) {
    try {
      const l = [];
      for (let d = 0; d < i.length; d++) {
        const f = d === 0 ? i[0] - 1 : i[d - 1], g = i[d], m = this.createStrategy(f, g);
        if (m.isErr()) return zr(m.error);
        l.push(m.value);
      }
      return Oi(l);
    } catch (l) {
      return zr(new fi(`Failed to create strategies for migration path: ${l}`, ai.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class CI {
  static isMigrationNeeded(i) {
    return Sd.isMigrationNeeded(i);
  }
  static getDataVersion(i) {
    return Sd.extractVersion(i);
  }
  static migrateToCurrent(i, l = {}) {
    return this.migrateToVersion(i, Sd.getCurrentVersion(), l);
  }
  static migrateToVersion(i, l, d = {}) {
    try {
      const f = { ...this.DEFAULT_OPTIONS, ...d }, g = Sd.extractVersion(i);
      if (g.isErr()) return zr(new fi(`Failed to extract current version: ${g.error.message}`, ai.INVALID_VERSION, g.error));
      const m = g.value;
      if (m === l) return Oi({ data: i, fromVersion: m, toVersion: l, migratedVersions: [] });
      const s = Sd.determineMigrationPath(m, l);
      if (s.isErr()) return zr(new fi(`Failed to determine migration path: ${s.error.message}`, ai.INVALID_VERSION, s.error));
      const C = s.value, T = wI.createStrategiesForPath(C);
      if (T.isErr()) return zr(T.error);
      const M = T.value;
      if (f.validateBefore) {
        const O = this.validateDataBeforeMigration(i, m);
        if (O.isErr()) return zr(new fi(`Pre-migration validation failed: ${O.error.message}`, ai.VALIDATION_FAILED, O.error));
      }
      const z = f.enableRollback ? i : void 0;
      let L = i;
      const A = [];
      for (const O of M) {
        const U = this.executeMigrationWithRetry(O, L, f);
        if (U.isErr()) {
          if (f.enableRollback && z) {
            const X = this.rollbackToVersion(z);
            if (X.isErr()) return zr(new _I(`Migration failed and rollback also failed: ${X.error.message}`, U.error, X.error));
          }
          return zr(U.error);
        }
        L = U.value, A.push(O.toVersion);
      }
      if (f.validateAfter) {
        const O = this.validateDataAfterMigration(L, l);
        if (O.isErr()) return zr(new fi(`Post-migration validation failed: ${O.error.message}`, ai.VALIDATION_FAILED, O.error));
      }
      return Oi({ data: L, fromVersion: m, toVersion: l, migratedVersions: A, rollbackData: f.enableRollback ? z : void 0 });
    } catch (f) {
      return zr(new fi(`Migration service error: ${f}`, ai.MIGRATION_FAILED, f instanceof Error ? f : new Error(String(f))));
    }
  }
  static executeMigrationWithRetry(i, l, d) {
    let f = null;
    for (let g = 0; g <= (d.maxRetries || 0); g++) {
      try {
        const m = i.migrate(l);
        if (m.isErr()) {
          f = m.error;
          continue;
        }
        if (i.validateAfter) {
          const s = i.validateAfter(m.value);
          if (s.isErr()) {
            f = new fi(`Post-migration validation failed: ${s.error.message}`, ai.VALIDATION_FAILED, s.error);
            continue;
          }
        }
        return Oi(m.value);
      } catch (m) {
        f = new fi(`Migration attempt ${g + 1} failed: ${m}`, ai.MIGRATION_FAILED, m instanceof Error ? m : new Error(String(m)));
      }
      g < (d.maxRetries || 0) && d.retryDelay && console.warn(`Migration failed, retrying in ${d.retryDelay}ms...`);
    }
    return zr(f || new fi("Migration failed after all retry attempts", ai.MIGRATION_FAILED));
  }
  static rollbackToVersion(i) {
    try {
      return Oi(i);
    } catch (l) {
      return zr(new fi(`Rollback failed: ${l}`, ai.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(i, l) {
    switch (l) {
      case 0:
        return Wa.validateRouteCollectionData(i).map(() => {
        }).mapErr((d) => new fi(`Route collection validation failed: ${d.message}`, ai.VALIDATION_FAILED, d));
      case 1:
        return Wa.validateSketchArray(i).map(() => {
        }).mapErr((d) => new fi(`Sketch array validation failed: ${d.message}`, ai.VALIDATION_FAILED, d));
      default:
        return zr(new fi(`Unknown version for pre-migration validation: ${l}`, ai.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(i, l) {
    switch (l) {
      case 1:
        return Wa.validateSketchArray(i).map(() => {
        }).mapErr((d) => new fi(`Sketch array validation failed: ${d.message}`, ai.VALIDATION_FAILED, d));
      default:
        return zr(new fi(`Unknown version for post-migration validation: ${l}`, ai.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(i, l) {
    return Wa.checkDataIntegrity(i, l);
  }
}
__publicField(CI, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const Jg = yy("sketches", () => {
  const r = Ae([]), i = Ae(null), l = Ae(null), d = ze(() => {
    if (!i.value) return null;
    const fe = r.value.find((oe) => oe.id === i.value);
    return fe ? new vI(fe.routes.routes.map((oe) => new Xm(oe.id, oe.points, oe.properties, oe.meta)), fe.routes.id, fe.routes.meta) : null;
  }), f = ze(() => d.value ? d.value.routes.map((fe) => ({ id: fe.id, name: fe.name, points: fe.getPoints(), meta: fe.meta })) : []), g = ze(() => i.value && r.value.find((fe) => fe.id === i.value) || null), m = ze(() => g.value ? g.value.drafts.drafts : []);
  async function s() {
    const fe = await H2("sketches");
    if (fe) {
      const oe = CI.migrateToCurrent(fe, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (oe.isErr()) {
        console.error("[SketchStore] Data migration failed:", oe.error), await C();
        return;
      }
      const de = oe.value;
      de.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${de.fromVersion} to ${de.toVersion}`), Array.isArray(de.data) ? (r.value = de.data.map((xe) => Rl.fromStorage(xe)), r.value.forEach((xe) => {
        xe.routes.routes.forEach(async ($e) => {
          if ($e.points.length > 1 && !$e.meta.distance) try {
            $e.meta.distance = await km($e.points);
          } catch (Ve) {
            console.warn("Failed to calculate route distance:", Ve), $e.meta.distance = 0;
          }
        });
      }), !i.value && r.value.length > 0 && (i.value = r.value[0].id)) : await C();
    } else await C();
  }
  async function C() {
    const fe = new Rl();
    fe.meta.name = "Default Sketch", r.value = [fe], i.value = fe.id, await Mo("sketches", r.value.map((oe) => oe.toStorage())), await Eo();
  }
  async function T(fe = "New Sketch") {
    const oe = new Rl();
    return oe.meta.name = fe, r.value.push(oe), await Mo("sketches", r.value.map((de) => de.toStorage())), await Eo(), oe;
  }
  async function M(fe, oe) {
    const de = r.value.find((xe) => xe.id === fe);
    de && (oe.name !== void 0 && de.updateName(oe.name), oe.description !== void 0 && de.updateDescription(oe.description), oe.tags !== void 0 && (de.meta.tags.forEach((xe) => de.removeTag(xe)), oe.tags.forEach((xe) => de.addTag(xe))), await Mo("sketches", r.value.map((xe) => xe.toStorage())), await Eo());
  }
  async function z(fe) {
    const oe = r.value.findIndex((de) => de.id === fe);
    oe !== -1 && (r.value.splice(oe, 1), i.value === fe && (i.value = r.value.length > 0 ? r.value[0].id : null), await Mo("sketches", r.value.map((de) => de.toStorage())), await Eo());
  }
  function L(fe) {
    i.value = fe, l.value = null;
  }
  async function A(fe, oe = {}, de = {}) {
    g.value || await C();
    const xe = new Xm(void 0, [], oe, de);
    return xe.meta.name = fe, g.value && g.value.routes.routes.push(xe.exportToStorage()), await Mo("sketches", r.value.map(($e) => $e.toStorage())), await Eo(), xe;
  }
  async function O(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.findIndex((de) => de.id === fe);
    oe !== -1 && (g.value.routes.routes.splice(oe, 1), l.value === fe && (l.value = null), await Mo("sketches", r.value.map((de) => de.toStorage())), await Eo());
  }
  async function U(fe, oe) {
    if (!g.value) return;
    const de = g.value.routes.routes.find((xe) => xe.id === fe);
    if (de) {
      if (de.points.push(oe), de.meta.modification_timestamp = Date.now(), de.points.length > 1) try {
        if (de.meta.distance) {
          const xe = await km([de.points[de.points.length - 2], oe]);
          de.meta.distance += xe;
        } else {
          const xe = await km(de.points);
          de.meta.distance = xe;
        }
      } catch (xe) {
        console.warn("Failed to calculate route distance:", xe), de.meta.distance || (de.meta.distance = 0);
      }
      await Mo("sketches", r.value.map((xe) => xe.toStorage())), await Eo();
    }
  }
  async function X(fe, oe) {
    if (!g.value) return;
    const de = g.value.routes.routes.find((xe) => xe.id === fe);
    de && (oe.meta !== void 0 && (de.meta = { ...de.meta, ...oe.meta }), oe.properties !== void 0 && (de.properties = { ...de.properties, ...oe.properties }), de.meta.modification_timestamp = Date.now(), await Mo("sketches", r.value.map((xe) => xe.toStorage())), await Eo());
  }
  async function H(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((de) => de.id === fe);
    oe && (oe.points = [], oe.meta.modification_timestamp = Date.now(), await Mo("sketches", r.value.map((de) => de.toStorage())), await Eo());
  }
  function Q(fe) {
    if (!g.value) return null;
    const oe = g.value.routes.routes.find((de) => de.id === fe);
    return oe ? new Xm(oe.id, oe.points, oe.properties, oe.meta) : null;
  }
  function ie(fe) {
    l.value = fe;
  }
  async function te(fe, oe = {}, de = {}) {
    g.value || await C();
    const xe = { id: crypto.randomUUID(), meta: { ...Xo(), ...de }, shape: fe, properties: oe };
    return g.value && g.value.drafts.drafts.push(xe), await Mo("sketches", r.value.map(($e) => $e.toStorage())), await Eo(), xe;
  }
  async function re(fe, oe) {
    if (!g.value) return;
    const de = g.value.drafts.drafts.find((xe) => xe.id === fe);
    de && (oe.shape !== void 0 && (de.shape = oe.shape), oe.properties !== void 0 && (de.properties = { ...de.properties, ...oe.properties }), oe.meta !== void 0 && (de.meta = { ...de.meta, ...oe.meta }, de.meta.modification_timestamp = Date.now()), await Mo("sketches", r.value.map((xe) => xe.toStorage())), await Eo());
  }
  async function J(fe) {
    if (!g.value) return;
    const oe = g.value.drafts.drafts.findIndex((de) => de.id === fe);
    oe !== -1 && (g.value.drafts.drafts.splice(oe, 1), await Mo("sketches", r.value.map((de) => de.toStorage())), await Eo());
  }
  function Se(fe) {
    return g.value && g.value.drafts.drafts.find((oe) => oe.id === fe) || null;
  }
  return { sketches: r, currentSketchId: i, currentRouteId: l, routeCollection: d, routes: f, currentSketch: g, currentDrafts: m, init: s, createSketch: T, updateSketch: M, deleteSketch: z, setCurrentSketchId: L, addRoute: A, deleteRoute: O, addPointToRoute: U, updateRoute: X, clearRoutePoints: H, getRouteById: Q, setCurrentRouteId: ie, addDraft: te, updateDraft: re, deleteDraft: J, getDraftById: Se };
}), h1 = yy("routes", () => {
  const r = Jg(), i = ze(() => r.routeCollection), l = ze({ get: () => r.currentRouteId, set: (J) => r.setCurrentRouteId(J) }), d = Ae(0);
  ar(l, (J) => {
    var _a3, _b2;
    J && (d.value = ((_b2 = (_a3 = r.getRouteById(J)) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const f = Ae(false), g = Ae(-1), m = Ae(null);
  let s;
  const C = ze(() => r.routes);
  function T(J) {
    m.value = J;
  }
  async function M() {
    await r.init();
  }
  async function z(J, Se = {}) {
    return await r.addRoute(J, Se);
  }
  async function L(J) {
    await r.deleteRoute(J);
  }
  async function A(J, Se) {
    await r.addPointToRoute(J, Se);
  }
  async function O(J, Se) {
    await r.updateRoute(J, Se);
  }
  async function U(J) {
    await r.clearRoutePoints(J);
  }
  function X(J) {
    return r.getRouteById(J);
  }
  function H(J) {
    r.setCurrentRouteId(J);
  }
  function Q(J) {
    f.value || !m.value || (f.value = true, J && A(l.value, J), g.value = m.value.addLocationListener((Se) => {
      l.value && A(l.value, Se);
    }), r.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), s = setInterval(async () => {
      const Se = r.getRouteById(l.value);
      Se.recordTimespan !== void 0 && Se.meta.modification_timestamp && (d.value = Se.recordTimespan + (Date.now() - Se.meta.modification_timestamp), await r.updateRoute(l.value, { meta: { record_timespan: d.value } }));
    }, 100));
  }
  function ie() {
    !f.value || !m.value || (g.value !== -1 && (m.value.removeLocationListener(g.value), g.value = -1), s && (clearTimeout(s), s = void 0), f.value = false);
  }
  async function te(J) {
    try {
      if (!m.value) throw new Error("Geolocation service not available");
      if (f.value) ie();
      else if (l.value) Q();
      else {
        const Se = await z(J("trackerView.nameNewRoute"));
        H(Se.id), Q(m.value.getLastKnownLocation());
      }
    } catch (Se) {
      throw console.error(Se), Se;
    }
  }
  function re() {
    g.value !== -1 && m.value && (m.value.removeLocationListener(g.value), g.value = -1), f.value = false;
  }
  return { routeCollection: i, routes: C, currentRouteId: l, isRecording: f, watchingHandler: g, currentRouteRecordTimespan: d, setLocator: T, init: M, addRoute: z, deleteRoute: L, addPointToRoute: A, updateRoute: O, clearRoutePoints: U, getRouteById: X, setCurrentRouteId: H, startRecording: Q, stopRecording: ie, toggleRecording: te, cleanup: re };
}), SI = { class: "upload-container" }, kI = { class: "action-buttons" }, PI = st({ __name: "TextFileUploaderDialog", props: Dl({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: Dl(["update:value", "confirm"], ["update:show"]), setup(r, { emit: i }) {
  const l = sp(), d = r, f = i, g = Dd(r, "show");
  let m = [];
  const s = (M) => {
    m = [];
    for (const z of M) {
      const L = z.file;
      if (L) if (d.types.includes(L.type)) {
        const A = new FileReader();
        A.onload = (O) => {
          var _a3;
          ((_a3 = O.target) == null ? void 0 : _a3.result) && m.push(O.target.result), m.length === M.length && f("update:value", m);
        }, A.readAsText(L);
      } else l.warning(`Skipped file ${z.name} due to unsupported type ${L.type}`);
    }
  }, C = () => {
    f("confirm", m), g.value = false;
  }, T = (M) => {
    var _a3, _b2;
    return d.types.includes(((_a3 = M.file.file) == null ? void 0 : _a3.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = M.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${d.types.join("', '")}']`), false);
  };
  return (M, z) => (St(), Sr(ee(Bd), { show: g.value, "onUpdate:show": z[2] || (z[2] = (L) => g.value = L), preset: "dialog", title: "Dialog" }, { header: Ge(() => [...z[3] || (z[3] = [Pr(" File Upload ", -1)])]), default: Ge(() => [It("div", SI, [Ne(ee(e6), { multiple: d.multiple ?? false, onChange: z[0] || (z[0] = ({ fileList: L }) => s(L)), onBeforeUpload: T }, { default: Ge(() => [Ne(ee(Ub), null, { default: Ge(() => [Ne(ee(ki), { size: 36, name: "upload", class: "upload-icon" }, { default: Ge(() => [(St(), Sr(Yu(d.icon ?? ee(ab))))]), _: 1 }), It("div", null, ir(d.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: Ge(() => [It("div", kI, [Ne(ee(Vr), { onClick: z[1] || (z[1] = (L) => g.value = false) }, { default: Ge(() => [...z[4] || (z[4] = [Pr(" Cancel ", -1)])]), _: 1 }), Ne(ee(Vr), { type: "primary", onClick: C }, { default: Ge(() => [...z[5] || (z[5] = [Pr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), TI = yo(PI, [["__scopeId", "data-v-14c5a0c1"]]), II = st({ __name: "MglDrawer", props: Dl({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: Dl(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(r, { emit: i }) {
  nc((L) => ({ a1b7bba2: ee(f).modalColor, "305889d2": ee(f).borderRadius, "60287bc6": M.value, "048a7f4c": T.value }));
  const l = r, d = i, f = Fl(), g = qw("route-drawer"), m = ze(() => l.position || "left"), s = ze(() => {
    var _a3, _b2, _c, _d2;
    return Math.min(hg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d2 = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d2.clientWidth) ?? 1 / 0) - 48);
  }), C = ze(() => {
    var _a3, _b2, _c, _d2;
    return Math.min(hg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d2 = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d2.clientHeight) ?? 1 / 0) - 48);
  }), T = ze(() => m.value === "left" ? `${-16 - s.value}px` : m.value === "right" ? `${16 + s.value}px` : m.value === "top" ? `${-16 - C.value}px` : m.value === "bottom" ? `${16 + C.value}px` : "0px"), M = ze(() => m.value === "left" || m.value === "right" ? `${s.value}px` : `${C.value}px`), z = Dd(r, "show");
  return ar(s, () => d("update:width", s.value)), ar(C, () => d("update:height", C.value)), (L, A) => (St(), Sr(Ao, { name: `slide-${m.value}` }, { default: Ge(() => [va(It("div", { ref: "route-drawer", class: kl(["route-drawer", `route-drawer--${m.value}`]), onClick: A[0] || (A[0] = (O) => d("click", O)), onContextmenu: A[1] || (A[1] = (O) => d("contextmenu", O)) }, [zg(L.$slots, "default", {}, void 0, true)], 34), [[Ka, z.value]])]), _: 3 }, 8, ["name"]));
} }), MI = yo(II, [["__scopeId", "data-v-72b274a7"]]), EI = { class: "menu-list" }, RI = ["onClick", "onContextmenu", "onTouchstart"], AI = { class: "swipe-container" }, DI = { style: { height: "fit-content", padding: "8px 12px" } }, zI = ["onClick"], FI = { style: { padding: "16px" } }, LI = 120, BI = 40, OI = st({ __name: "SelectableSwipeableMenuList", props: Dl({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: Dl(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(r, { emit: i }) {
  nc((te) => ({ af602246: ee(m).hoverColor, "2c598f52": ee(m).primaryColor, f032366a: ee(m).bodyColor, "6ce963b2": s.value }));
  const l = r, d = Dd(r, "selection"), f = Dd(r, "multipleSelection"), g = i, m = Fl(), s = Ae("0s"), C = Ae({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), T = Ae(false), M = Ae(0), z = Ae(0), L = Ae(null);
  function A(te, re) {
    C.value.activeId !== re && H();
    const J = te.touches[0];
    C.value = { startX: J.clientX, delta: C.value.delta ?? 0, currentX: J.clientX, containerWidth: te.currentTarget.offsetWidth, activeId: re, leftMax: LI, rightMax: BI };
  }
  function O(te) {
    C.value.activeId && (C.value.currentX = te.touches[0].clientX, C.value.delta += C.value.currentX - C.value.startX, C.value.delta = hg(C.value.delta, -C.value.leftMax, C.value.rightMax), C.value.startX = te.touches[0].clientX);
  }
  function U() {
    if (!C.value.activeId) return;
    s.value = `${Math.abs(C.value.delta) / C.value.containerWidth * 0.3}s`, setTimeout(() => {
      s.value = "0s";
    }, 300);
    const te = C.value.delta < 0 ? C.value.leftMax : C.value.rightMax;
    C.value.delta = Math.abs(C.value.delta) > te * 0.4 ? Math.sign(C.value.delta) * te : 0, C.value.delta === 0 && Math.abs(C.value.delta) < 5;
  }
  function X(te, re) {
    te.stopPropagation(), !(C.value.delta > 5) && (H(), d.value !== re.id && (d.value = re.id));
  }
  function H() {
    C.value.delta > 0 || (C.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function Q(te, re) {
    if (te.stopPropagation(), te.preventDefault(), T.value) {
      T.value = false;
      return;
    }
    L.value = re, M.value = te.clientX, z.value = te.clientY, T.value = true, g("contextmenu", te, re);
  }
  function ie(te) {
    const re = [...f.value];
    if (re.includes(te)) {
      const J = re.indexOf(te);
      re.splice(J, 1);
    } else re.push(te);
    f.value = re;
  }
  return (te, re) => (St(), Xt(qr, null, [It("div", EI, [(St(true), Xt(qr, null, dn(l.items, (J) => (St(), Xt("div", { key: J.id, class: kl(["menu-list-item", ...J.id === d.value ? ["active"] : []]), style: ws({ "touch-action": C.value.activeId === J.id ? "pan-y" : "auto" }), onClick: (Se) => X(Se, J), onContextmenu: zd((Se) => Q(Se, J), ["prevent"]), onTouchstart: (Se) => A(Se, J.id), onTouchmove: O, onTouchend: U }, [It("div", AI, [It("div", { class: "content-col", style: ws({ transform: `translateX(${C.value.activeId === J.id || C.value.delta > 0 ? C.value.delta : 0}px)`, willChange: C.value.activeId === J.id ? "transform" : "auto", flexDirection: C.value.delta >= 0 || C.value.activeId !== J.id ? "row" : "row-reverse" }) }, [zg(te.$slots, "item", { item: J }, () => [It("div", DI, [It("div", null, ir(J.name ?? "Untitled"), 1)])], true)], 4), It("div", { class: "actions-col", style: ws({ width: `${C.value.activeId === J.id && C.value.delta < 0 ? -C.value.delta : 0}px`, visibility: C.value.activeId === J.id && C.value.delta < 0 ? "visible" : "hidden", willChange: C.value.activeId === J.id ? "width" : "auto" }) }, [(St(true), Xt(qr, null, dn(l.swipeActions, (Se) => (St(), Xt("button", { key: Se.name, class: "menu-action", style: ws({ background: Se.color || ee(m).primaryColorSuppl }), onClick: () => {
    Se.action(J.id), C.value.activeId = null;
  } }, ir(Se.label), 13, zI))), 128))], 4), It("div", { class: "select-col", style: ws({ width: `${C.value.delta > 0 ? C.value.delta : 0}px`, backgroundColor: d.value === J.id ? ee(m).primaryColor : "transparent", visibility: C.value.delta > 0 ? "visible" : "hidden" }) }, [It("div", FI, [Ne(ee($k), { checked: f.value.includes(J.id), style: ws({ border: d.value === J.id ? `1px solid ${ee(m).bodyColor}` : "none", BorderRadius: d.value === J.id ? ee(m).borderRadiusSmall : "none" }), "onUpdate:checked": () => ie(J.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, RI))), 128))]), Ne(ee(Vy), { show: T.value, x: M.value, y: z.value, options: l.menuOptions.map((J) => {
    var _a3;
    return { ...J, label: ((_a3 = J.label) == null ? void 0 : _a3.value) ?? J.label };
  }), placement: "bottom-start", trigger: "manual", onClick: re[0] || (re[0] = (J) => T.value = false), onClickoutside: re[1] || (re[1] = (J) => T.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), $I = yo(OI, [["__scopeId", "data-v-b353d352"]]), jI = { class: "drawer-floating" }, NI = { class: "drawer-container" }, VI = { class: "drawer-header" }, UI = { class: "drawer-title" }, GI = { class: "drawer-content" }, qI = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, WI = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, ZI = { key: 0 }, HI = st({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: Dl(["update:width"], ["update:show"]), setup(r, { emit: i }) {
  nc((fe) => ({ "627d638a": ee(C).borderRadius, "71a1839a": ee(C).hoverColor, "8e0c4596": ee(C).primaryColorPressed, "63c7eba6": ee(C).primaryColor, "46d552b5": ee(C).bodyColor }));
  const d = new Ng().isMobile, { t: f } = zo(), g = kb(), m = i, s = h1(), C = Fl(), T = Dd(r, "show"), M = Ae(false), z = Ae(0), L = Ae(0), A = Ae(null), O = Ae(false), U = Ae(""), X = Ae(null), H = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    M.value = false, s.addRoute(f("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], Q = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a3;
    ((_a3 = A.value) == null ? void 0 : _a3.id) && (U.value = A.value.name || "", O.value = true);
  } } }, { label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    A.value && s.deleteRoute(A.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...H], ie = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (fe) => {
    const oe = s.routes.find((de) => de.id === fe);
    X.value = fe, U.value = (oe == null ? void 0 : oe.name) || "", O.value = true;
  } }, { label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (fe) => s.deleteRoute(fe), color: C.value.errorColorSuppl }];
  function te(fe) {
    if (fe.stopPropagation(), fe.preventDefault(), X.value = s.currentRouteId, M.value) {
      M.value = false;
      return;
    }
    z.value = fe.clientX, L.value = fe.clientY, M.value = true;
  }
  async function re(fe) {
    U.value.trim() && (await s.updateRoute(fe, { name: U.value.trim() }), O.value = false);
  }
  const J = Ae([]);
  function Se() {
    g.warning({ title: f("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: f("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: f("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: f("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      J.value.forEach((fe) => {
        s.deleteRoute(fe), J.value = J.value.filter((oe) => oe !== fe);
      });
    } });
  }
  return (fe, oe) => (St(), Xt(qr, null, [Ne(MI, { show: T.value, "onUpdate:show": oe[3] || (oe[3] = (de) => T.value = de), position: ee(d) ? "bottom" : "left", onClick: oe[4] || (oe[4] = () => ee(s).currentRouteId = null), "onUpdate:width": oe[5] || (oe[5] = (de) => m("update:width", de)), onContextmenu: oe[6] || (oe[6] = (de) => te(de)) }, { default: Ge(() => [It("div", jI, [ee(d) && T.value ? zg(fe.$slots, "bottom-floating", { key: 0 }, void 0, true) : Kr("", true)]), It("div", NI, [It("div", VI, [It("p", UI, ir(ee(f)("components.trackerViewRouteDrawer.routes")), 1), J.value.length > 0 ? (St(), Sr(ee(Vr), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: Se }, { icon: Ge(() => [Ne(ee(ki), { component: ee(np) }, null, 8, ["component"])]), _: 1 })) : Kr("", true)]), It("div", GI, [Ne($I, { selection: ee(s).currentRouteId, "onUpdate:selection": oe[0] || (oe[0] = (de) => ee(s).currentRouteId = de), "multiple-selection": J.value, "onUpdate:multipleSelection": oe[1] || (oe[1] = (de) => J.value = de), items: ee(s).routes, "menu-options": Q, "swipe-actions": ie, onContextmenu: oe[2] || (oe[2] = (de, xe) => {
    X.value = (xe == null ? void 0 : xe.id) ?? null, A.value = xe ?? null;
  }) }, { item: Ge(({ item: de }) => {
    var _a3;
    return [It("div", qI, [It("div", null, ir(de.name ?? ee(f)("components.trackerViewRouteDrawer.nameNewRoute")), 1), It("div", WI, [It("div", null, ir(ee(f)("components.trackerViewRouteDrawer.points", { num: de.points.length })), 1), de.points.length > 1 && ((_a3 = de.meta) == null ? void 0 : _a3.distance) ? (St(), Xt("div", ZI, ir(ee(f)("components.trackerViewRouteDrawer.distance", { distance: ee(Ww)(de.meta.distance) })), 1)) : Kr("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), Ne(ee(Vy), { show: M.value, x: z.value, y: L.value, options: H.map((de) => ({ ...de, label: de.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: oe[7] || (oe[7] = (de) => M.value = false) }, null, 8, ["show", "x", "y", "options"]), Ne(ee(Bd), { show: O.value, "onUpdate:show": oe[10] || (oe[10] = (de) => O.value = de), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: oe[11] || (oe[11] = () => {
    X.value && re(X.value);
  }) }, { default: Ge(() => [Ne(ee(mo), { value: U.value, "onUpdate:value": oe[8] || (oe[8] = (de) => U.value = de), placeholder: "Enter new route name", onKeyup: oe[9] || (oe[9] = by(() => {
    X.value && re(X.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), XI = yo(HI, [["__scopeId", "data-v-9e932b50"]]), YI = { class: "map-layout-container" }, KI = { class: "map-layout" }, JI = { key: 0, style: { width: "100%", height: "100%" } }, QI = ["title", "onClick"], e4 = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, t4 = { style: { "font-family": "monospace", "padding-left": "8px" } }, r4 = st({ __name: "TrackerView", setup(r) {
  nc((yt) => {
    var _a3, _b2, _c;
    return { "2c69e1d6": (_a3 = ee(vd).Button.common) == null ? void 0 : _a3.successColorSuppl, "69ecb927": ee(d).boxShadow3, "26d04306": ee(d).borderRadius, "86fb57d0": ee(d).borderColor, "06f6ab58": (_b2 = ee(vd).Button.common) == null ? void 0 : _b2.primaryColorSuppl, "098d059a": (_c = ee(vd).Button.common) == null ? void 0 : _c.errorColorSuppl };
  });
  const l = new Ng().isMobile, d = Fl(), f = X2(), g = sp(), m = fr("geolocation"), { t: s } = zo(), C = zo(), T = Ae(7), z = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", L = Ae({ latitude: 0, longitude: 0 }), A = Al(null), O = Al(null), U = Ae("select"), X = h1();
  X.setLocator(m);
  const H = fr("noSleep"), Q = ze(() => {
    var _a3;
    return X.currentRouteId ? ((_a3 = X.routes.find((nt) => nt.id === X.currentRouteId)) == null ? void 0 : _a3.points) || [] : [];
  }), ie = Ae(false), te = new Is.Marker(), re = ze(() => {
    if (Q.value.length > 1 || Q.value.length === 0) return te.remove(), { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: X.currentRouteId }, geometry: { type: "LineString", coordinates: Q.value.map((yt) => [yt.longitude, yt.latitude]) } }] };
    if (Q.value.length === 1) {
      te.setLngLat([Q.value[0].longitude, Q.value[0].latitude]);
      const yt = A.value;
      yt && te.addTo(yt);
    }
    return { type: "FeatureCollection", features: [] };
  }), J = [{ mode: new N6(), name: s("trackerView.terraDrawTools.point"), icon: Uy }, { mode: new F6(), name: s("trackerView.terraDrawTools.line"), icon: y3 }, { mode: new eI({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: s("trackerView.terraDrawTools.select"), icon: v3 }];
  ar([() => f.settings.mapLanguage, () => C.locale.value], (yt) => {
    yt && A.value && Se(A.value, yt[0] === "interface" ? yt[1] : yt[0]);
  });
  const Se = (yt, nt) => {
    const ut = nt === "zh-CN" ? "zh" : "en", Lt = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const Ht of Lt) yt.setLayoutProperty(Ht, "text-field", ["get", `name:${ut}`]);
  };
  function fe(yt) {
    var _a3;
    A.value = yt.map, A.value && Se(A.value, C.locale.value), (_a3 = A.value) == null ? void 0 : _a3.on("click", () => {
      Ke.value = false;
    }), O.value = new cI({ adapter: new dI({ map: A.value }), modes: J.map((nt) => nt.mode) }), O.value.start();
  }
  let oe = true;
  async function de() {
    try {
      X.isRecording || (oe = X.currentRouteId === null), await X.toggleRecording(s), !X.isRecording && oe && (vt.value = true, setTimeout(() => {
        vt.value = false;
      }, 3e3)), X.isRecording ? H.enable() : H.disable();
    } catch (yt) {
      console.error(yt), H.disable();
    }
  }
  const xe = Ae(async () => {
  });
  function $e() {
    Ke.value = false, g.warning("Not implemented yet");
  }
  const Ve = Ae(0), Ke = Ae(false);
  ar(Ke, (yt) => {
    var _a3;
    return (_a3 = A.value) == null ? void 0 : _a3.easeTo({ padding: l ? { bottom: yt ? Ve.value : 0 } : { left: yt ? Ve.value : 0 }, duration: 500 });
  });
  const lt = () => Ke.value = !Ke.value, vt = Ae(false), xt = Ae(""), at = Ae(false);
  Qi(async () => {
    var _a3;
    await X.init();
    try {
      const yt = await m.getCurrentLocation();
      if (yt.isOk()) L.value = yt.value, m.isUsingGPS() || g.warning(s("trackerView.gpsWarning"), { duration: 5e3 });
      else throw yt.error;
    } catch (yt) {
      xt.value = yt.message ?? String(yt);
    }
    at.value = true, (_a3 = O.value) == null ? void 0 : _a3.start();
  });
  const et = false;
  function ht(yt) {
    const nt = yt / 1e3, ut = nt / 60, Lt = ut / 60, Ht = nt % 60, zt = ut % 60, pr = Lt;
    let Jt = "";
    return Math.floor(pr) > 0 && (Jt += `${String(Math.floor(pr))}h `), Math.floor(zt) > 0 && (Jt += `${String(Math.floor(zt))}m `), Jt += `${String(Ht.toFixed(1)).padStart(4, "0")}s`, Jt;
  }
  return (yt, nt) => (St(), Xt("div", YI, [It("div", KI, [Ne(Ao, { name: "map-load" }, { default: Ge(() => [at.value && !xt.value ? (St(), Xt("div", JI, [Ne(ee(Kb), { "map-style": z, center: [L.value.longitude, L.value.latitude], zoom: T.value, height: "100%", "onMap:load": fe }, { default: Ge(() => [Ne(ee(Qb), { position: "top-left" }), ee(m).isUsingGPS() || et ? (St(), Sr(ee(h6), { key: 0, position: "top-left", "track-user-location": true })) : Kr("", true), Ne(ee(Jb), { position: "top-left" }), Ne(ee(t1), { position: "bottom-left" }), !ee(l) || et ? (St(), Sr(ee(L_), { key: 1, position: "top-right" }, { default: Ge(() => [(St(), Xt(qr, null, dn(J, (ut) => It("button", { key: ut.name, class: kl(["btn-control", "btn-draw-mode", { active: ut.mode.mode === U.value }]), title: ut.name, onClick: () => {
    var _a3, _b2, _c;
    console.log("activeDrawMethod", U.value), U.value === ut.mode.mode ? ((_a3 = O.value) == null ? void 0 : _a3.setMode("select"), U.value = "select") : (U.value = ut.mode.mode, (_b2 = O.value) == null ? void 0 : _b2.start(), (_c = O.value) == null ? void 0 : _c.setMode(ut.mode.mode));
  } }, [Ne(ee(ki), { size: 20 }, { default: Ge(() => [(St(), Sr(Yu(ut.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, QI)), 64))]), _: 1 })) : Kr("", true), Ne(ee(L_), { position: "bottom-left" }, { default: Ge(() => [Ne(ee(Lg), { trigger: "manual", show: vt.value }, { trigger: Ge(() => [It("button", { class: "btn-control btn-route-toggle", onClick: lt }, [Ne(ee(ki), { size: 24 }, { default: Ge(() => [Ne(ee(Vg))]), _: 1 })])]), default: Ge(() => [It("span", null, ir(ee(s)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), Ne(ee(g6), { "source-id": "geojson", data: re.value }, { default: Ge(() => [Ne(ee(b6), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-color": "#008800", "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"])]), _: 1 }, 8, ["center", "zoom"])])) : (St(), Xt("div", e4, [xt.value ? (St(), Sr(ee(ck), { key: 1, title: ee(s)("app.error"), type: "error" }, { default: Ge(() => [It("div", null, [nt[3] || (nt[3] = It("br", null, null, -1)), It("b", null, ir(ee(s)("app.error")) + ": ", 1), nt[4] || (nt[4] = It("br", null, null, -1)), It("code", null, ir(xt.value), 1)])]), _: 1 }, 8, ["title"])) : (St(), Sr(ee(b5), { key: 0, size: "large" }, { description: Ge(() => [Ne(ee(Ua), null, { default: Ge(() => [Pr(ir(ee(s)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 }))]))]), _: 1 })]), Ne(TI, { show: ie.value, "onUpdate:show": nt[0] || (nt[0] = (ut) => ie.value = ut), types: ["application/json", "text/plain"], onConfirm: xe.value }, null, 8, ["show", "onConfirm"]), Ne(XI, { show: Ke.value, "onUpdate:show": nt[1] || (nt[1] = (ut) => Ke.value = ut), "onUpdate:width": nt[2] || (nt[2] = (ut) => Ve.value = ut) }, { "bottom-floating": Ge(() => [Ne(ee(Zv), { theme: ee(vd) }, { default: Ge(() => [Q.value.length > 1 ? (St(), Sr(ee(Vr), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: $e }, { default: Ge(() => [...nt[5] || (nt[5] = [Pr(" Follow ", -1)])]), _: 1 })) : Kr("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), ee(l) || et ? (St(), Xt("div", { key: 0, class: kl(["mobile-record-button-container", { "drawer-open": Ke.value }]) }, [Ne(ee(Zv), { theme: ee(vd) }, { default: Ge(() => [Ne(ee(Vr), { type: ee(X).isRecording ? "error" : "primary", size: "large", class: kl(["mobile-record-button", ee(X).isRecording ? "recording" : "not-recording"]), onClick: de }, { icon: Ge(() => [Ne(ee(ki), { size: 20 }, { default: Ge(() => [(St(), Sr(Yu(ee(X).isRecording ? ee(M3) : ee(S3)), { size: ee(X).isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: Ge(() => [Pr(" " + ir(ee(X).isRecording ? ee(s)("trackerView.uiRecordingStatus.on") : ee(s)("trackerView.uiRecordingStatus.off")) + " ", 1), It("p", t4, ir(ee(X).currentRouteRecordTimespan ? `(${ht(ee(X).currentRouteRecordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : Kr("", true)]));
} }), f1 = yo(r4, [["__scopeId", "data-v-3302da49"]]), i4 = Object.freeze(Object.defineProperty({ __proto__: null, default: f1 }, Symbol.toStringTag, { value: "Module" })), n4 = { class: "container" }, o4 = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, a4 = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, s4 = { style: { "font-weight": "500" } }, l4 = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, u4 = st({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(r, { emit: i }) {
  const { t: l } = zo(), d = r, f = i;
  function g(s) {
    f("select", s);
  }
  function m(s) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && f("remove", s);
  }
  return (s, C) => (St(), Xt("div", n4, [Ne(ee(lp), { class: "select-listview", hoverable: "" }, { default: Ge(() => [(St(true), Xt(qr, null, dn(d.list, (T) => (St(), Sr(ee(up), { key: T.id, title: T.name, onClick: (M) => g(T.id) }, { prefix: Ge(() => [It("div", o4, [Ne(ee(ki), { size: "20" }, { default: Ge(() => [Ne(ee(ob))]), _: 1 })])]), suffix: Ge(() => [Ne(ee(Vr), { quaternary: "", circle: "", onClick: zd((M) => m(T.id), ["stop"]) }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(np))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), default: Ge(() => [It("div", a4, [It("div", s4, ir(T.name), 1), It("div", l4, [(St(true), Xt(qr, null, dn(T.tags, (M) => (St(), Sr(ee(Do), { key: M, size: "small", type: "info" }, { default: Ge(() => [Pr(ir(M.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), c4 = yo(u4, [["__scopeId", "data-v-dc2c6049"]]), d4 = st({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(r, { emit: i }) {
  const { t: l } = zo(), d = r, f = [{ title: l("sketchEdit.import"), icon: ab, callback: () => {
    s("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Od, callback: () => s("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: w3, callback: () => {
    g.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], g = Ae(false), m = Ae(d.placement);
  ar(d, () => {
    g.value = d.active, m.value = d.placement;
  }, { deep: true }), ar(g, () => {
    s("update:active", g.value);
  });
  const s = i;
  return (C, T) => (St(), Sr(ee(Pb), { show: g.value, "onUpdate:show": T[2] || (T[2] = (M) => g.value = M), width: 502, placement: m.value, "auto-focus": false }, { default: Ge(() => [Ne(ee(Tb), { title: ee(l)("sketchEdit.cartoSketchLibrary") }, { footer: Ge(() => [Ne(ee(Dk), null, { default: Ge(() => [(St(), Xt(qr, null, dn(f, (M) => Ne(ee(Vr), { key: M.title, secondary: M.secondary, type: M.type, title: M.title, onClick: M.callback }, { icon: Ge(() => [Ne(ee(ki), { size: M.iconSize }, { default: Ge(() => [(St(), Sr(Yu(M.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: Ge(() => [Ne(c4, { list: r.list, onRemove: T[0] || (T[0] = (M) => s("remove", M)), onSelect: T[1] || (T[1] = (M) => s("select", M)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), h4 = ["title", "onClick"], Tf = 20, f4 = st({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(r, { emit: i }) {
  const { t: l } = zo(), d = i, f = [{ title: l("sketchEdit.save"), icon: c3, iconSize: Tf, callback: () => d("save") }, { title: l("sketchEdit.open"), icon: m3, iconSize: Tf, callback: () => d("open") }, { title: l("sketchEdit.newComponent"), icon: Od, iconSize: Tf, callback: () => d("create") }, { title: l("sketchEdit.editMetadata"), icon: Y2, iconSize: Tf, callback: () => d("edit-meta") }];
  return (g, m) => (St(), Sr(ee(u_), { justify: "space-between", align: "center" }, { default: Ge(() => [Ne(ee(Ua), { strong: "" }, { default: Ge(() => [Pr(ir(g.sketchName || ee(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), Ne(ee(u_), { align: "center" }, { default: Ge(() => [g.sketchName !== void 0 ? (St(), Sr(ee(Do), { key: 0, type: "info", size: "small" }, { default: Ge(() => [Pr(ir(g.draftCount || 0) + " " + ir(ee(l)("sketchEdit.drafts")) + ", " + ir(g.routeCount || 0) + " " + ir(ee(l)("sketchEdit.routes")), 1)]), _: 1 })) : Kr("", true), (St(), Xt(qr, null, dn(f, (s, C) => It("div", { key: C, title: s.title, class: "tool-tip-item", onClick: s.callback }, [Ne(ee(ki), { size: s.iconSize }, { default: Ge(() => [(St(), Sr(Yu(s.icon)))]), _: 2 }, 1032, ["size"])], 8, h4)), 64))]), _: 1 })]), _: 1 }));
} }), p4 = yo(f4, [["__scopeId", "data-v-5b012717"]]), m4 = { key: 0, class: "empty-state" }, g4 = st({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(r, { emit: i }) {
  const { t: l } = zo(), d = i;
  return (f, g) => (St(), Xt(qr, null, [Ne(ee(lp), { hoverable: "" }, { default: Ge(() => [(St(true), Xt(qr, null, dn(f.components, (m) => (St(), Sr(ee(up), { key: m.value, class: kl({ "selected-component": f.selectedId === m.value }), onClick: () => d("select", m.value, m.type) }, { prefix: Ge(() => [Ne(ee(ki), { color: m.type === "draft" ? "#007bff" : "#28a745" }, { default: Ge(() => [(St(), Sr(Yu(m.type === "draft" ? ee(ob) : ee(Vg))))]), _: 2 }, 1032, ["color"])]), suffix: Ge(() => [Ne(ee(l5), { onPositiveClick: (s) => d("delete", m.value, m.type) }, { trigger: Ge(() => [Ne(ee(Vr), { quaternary: "", circle: "", size: "small" }, { default: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(np))]), _: 1 })]), _: 1 })]), default: Ge(() => [Pr(" " + ir(ee(l)("sketchEdit.deleteComponent")), 1)]), _: 1 }, 8, ["onPositiveClick"])]), default: Ge(() => [Pr(" " + ir(m.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), f.components.length === 0 ? (St(), Xt("div", m4, [Ne(ee($d), { description: ee(l)("sketchEdit.noComponentsYet") }, { extra: Ge(() => [Ne(ee(Vr), { size: "small", onClick: g[0] || (g[0] = (m) => d("create")) }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : Kr("", true)], 64));
} }), v4 = yo(g4, [["__scopeId", "data-v-3addb8a0"]]), _4 = { key: 0, class: "properties-panel" }, y4 = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, b4 = st({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(r, { emit: i }) {
  const { t: l } = zo(), d = i;
  return (f, g) => f.component ? (St(), Xt("div", _4, [Ne(ee(I5), { type: "line", animated: "", "default-value": "properties" }, { default: Ge(() => [Ne(ee(P_), { name: "properties", tab: ee(l)("sketchEdit.properties") }, { default: Ge(() => [Ne(ee(Nd), null, { default: Ge(() => [Ne(ee(xn), { label: ee(l)("sketchEdit.visible") }, { default: Ge(() => [Ne(ee(jb), { value: f.component.properties.visible !== false, "onUpdate:value": g[0] || (g[0] = (m) => d("updateProperties", { visible: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), f.type === "draft" ? (St(), Xt(qr, { key: 0 }, [Ne(ee(xn), { label: ee(l)("sketchEdit.fillColor") }, { default: Ge(() => [Ne(ee(Lm), { value: f.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": g[1] || (g[1] = (m) => d("updateProperties", { fillColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.strokeColor") }, { default: Ge(() => [Ne(ee(Lm), { value: f.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": g[2] || (g[2] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.strokeThickness") }, { default: Ge(() => [Ne(ee(w_), { value: f.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": g[3] || (g[3] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Kr("", true), f.type === "route" ? (St(), Xt(qr, { key: 1 }, [Ne(ee(xn), { label: ee(l)("sketchEdit.strokeColor") }, { default: Ge(() => [Ne(ee(Lm), { value: f.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": g[4] || (g[4] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.strokeThickness") }, { default: Ge(() => [Ne(ee(w_), { value: f.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": g[5] || (g[5] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Kr("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), Ne(ee(P_), { name: "metadata", tab: ee(l)("sketchEdit.metadata") }, { default: Ge(() => [Ne(ee(Nd), null, { default: Ge(() => [Ne(ee(xn), { label: ee(l)("sketchEdit.name") }, { default: Ge(() => [Ne(ee(mo), { value: f.component.meta.name, "onUpdate:value": g[6] || (g[6] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: m, description: ((_a3 = f.component) == null ? void 0 : _a3.meta.description) ?? "", tags: ((_b2 = f.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.description") }, { default: Ge(() => [Ne(ee(mo), { value: f.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": g[7] || (g[7] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = f.component) == null ? void 0 : _a3.meta.name) ?? "", description: m, tags: ((_b2 = f.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.tags") }, { default: Ge(() => [Ne(ee(YP), { value: f.component.meta.tags || [], placeholder: ee(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": g[8] || (g[8] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = f.component) == null ? void 0 : _a3.meta.name) ?? "", description: ((_b2 = f.component) == null ? void 0 : _b2.meta.description) ?? "", tags: m });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: "UUID" }, { default: Ge(() => [Ne(ee(mo), { value: f.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (St(), Xt("div", y4, [Ne(ee($d), { description: ee(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), x4 = yo(b4, [["__scopeId", "data-v-f700b4bc"]]), w4 = "dCeXFrS9lgSF8hm5C6nm", C4 = `https://api.maptiler.com/maps/basic-v2/style.json?key=${w4}`;
function S4() {
  const r = Ae(7), i = Al(null), l = Ae([0, 0]);
  function d(m) {
    i.value = m.map;
  }
  function f(m) {
    l.value = m, i.value && i.value.setCenter(m);
  }
  function g(m) {
    r.value = m, i.value && i.value.setZoom(m);
  }
  return { zoom: r, map: i, center: l, styleUrl: C4, initMap: d, setCenter: f, setZoom: g };
}
function k4(r, i) {
  const l = [];
  return r.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "draft" });
  }), i.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "route" });
  }), l;
}
function P4() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function T4() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function I4() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const M4 = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, E4 = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, R4 = { class: "sketch-edit-container" }, A4 = { class: "grid-layout" }, D4 = { class: "meta-info-section" }, z4 = { class: "metadata-item" }, F4 = { class: "metadata-item" }, L4 = st({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(r) {
  const i = r, { t: l } = zo(), d = sp(), f = Jg(), { zoom: g, styleUrl: m, initMap: s } = S4(), C = Ae(false), T = Ae(null), M = Ae(null), z = Ae(false), L = Ae(""), A = Ae("draft"), O = Ae(false), U = Ae({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), X = Ae(""), H = ze(() => f.currentSketch), Q = ze(() => f.currentDrafts), ie = ze(() => {
    var _a3;
    return ((_a3 = H.value) == null ? void 0 : _a3.routes.routes) || [];
  }), te = ze(() => !!H.value), re = ze(() => !T.value || !M.value ? null : M.value === "draft" ? f.getDraftById(T.value) : f.getRouteById(T.value)), J = ze(() => k4(Q.value, ie.value));
  async function Se() {
    if (H.value) try {
      await f.updateSketch(H.value.id, { name: H.value.meta.name, description: H.value.meta.description, tags: H.value.meta.tags }), d.success(l("sketchEdit.saveSuccess"));
    } catch (at) {
      d.error(l("sketchEdit.saveError")), console.error(at);
    }
  }
  async function fe() {
    const at = prompt(l("sketchEdit.enterSketchName"));
    at && (await f.createSketch(at), C.value = false);
  }
  async function oe() {
    if (!(!L.value.trim() || !H.value)) try {
      if (A.value === "draft") {
        const at = await f.addDraft(P4(), T4(), { name: L.value });
        T.value = at.id, M.value = "draft";
      } else {
        const at = await f.addRoute(L.value, I4());
        T.value = at.id, M.value = "route";
      }
      z.value = false, L.value = "", d.success(l("sketchEdit.componentCreated"));
    } catch (at) {
      d.error(l("sketchEdit.componentCreateError")), console.error(at);
    }
  }
  async function de(at, et) {
    try {
      et === "draft" ? await f.deleteDraft(at) : await f.deleteRoute(at), T.value === at && (T.value = null, M.value = null), d.success(l("sketchEdit.componentDeleted"));
    } catch (ht) {
      d.error(l("sketchEdit.componentDeleteError")), console.error(ht);
    }
  }
  async function xe(at) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(T.value, { properties: at }) : await f.updateRoute(T.value, { properties: at }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  async function $e(at) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(T.value, { meta: at }) : await f.updateRoute(T.value, { name: at.name }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  function Ve() {
    H.value && (U.value = { name: H.value.meta.name, description: H.value.meta.description, tags: [...H.value.meta.tags], created_by: H.value.meta.created_by, modified_by: H.value.meta.modified_by }, O.value = true);
  }
  function Ke() {
    X.value.trim() && !U.value.tags.includes(X.value.trim()) && (U.value.tags.push(X.value.trim()), X.value = "");
  }
  function lt(at) {
    U.value.tags = U.value.tags.filter((et) => et !== at);
  }
  async function vt() {
    if (H.value) try {
      await f.updateSketch(H.value.id, { name: U.value.name, description: U.value.description, tags: U.value.tags }), O.value = false, d.success(l("sketchEdit.saveSuccess"));
    } catch (at) {
      d.error(l("sketchEdit.saveError")), console.error(at);
    }
  }
  Qi(() => {
    i.sketchId && f.setCurrentSketchId(i.sketchId);
  }), ar(() => f.currentSketchId, (at) => {
    at && (T.value = null, M.value = null);
  });
  const xt = (at) => new Date(at).toLocaleString();
  return (at, et) => (St(), Xt(qr, null, [Ne(d4, { active: C.value, "onUpdate:active": et[0] || (et[0] = (ht) => C.value = ht), list: ee(f).sketches.map((ht) => ({ id: ht.id, name: ht.meta.name, tags: ht.meta.tags })), placement: "right", onNew: fe, onRemove: et[1] || (et[1] = (ht) => ee(f).deleteSketch(ht)), onSelect: et[2] || (et[2] = (ht) => ee(f).setCurrentSketchId(ht)) }, null, 8, ["active", "list"]), Ne(ee(Bd), { show: z.value, "onUpdate:show": et[6] || (et[6] = (ht) => z.value = ht), preset: "dialog", title: ee(l)("sketchEdit.createNewComponent") }, { action: Ge(() => [Ne(ee(Vr), { onClick: et[5] || (et[5] = (ht) => z.value = false) }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.cancel")), 1)]), _: 1 }), Ne(ee(Vr), { type: "primary", disabled: !L.value.trim(), onClick: oe }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: Ge(() => [Ne(ee(Nd), null, { default: Ge(() => [It("div", M4, [Ne(ee(xn), { label: ee(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: Ge(() => [Ne(ee(mo), { value: L.value, "onUpdate:value": et[3] || (et[3] = (ht) => L.value = ht), placeholder: ee(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.type") }, { default: Ge(() => [Ne(ee(mg), { value: A.value, "onUpdate:value": et[4] || (et[4] = (ht) => A.value = ht), "consistent-menu-width": false, options: [{ label: ee(l)("sketchEdit.draftShape"), value: "draft" }, { label: ee(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), Ne(ee(Bd), { show: O.value, "onUpdate:show": et[11] || (et[11] = (ht) => O.value = ht), preset: "dialog", title: ee(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: Ge(() => [Ne(ee(Vr), { onClick: et[10] || (et[10] = (ht) => O.value = false) }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.cancel")), 1)]), _: 1 }), Ne(ee(Vr), { type: "primary", disabled: !U.value.name.trim(), onClick: vt }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: Ge(() => [Ne(ee(Nd), null, { default: Ge(() => [Ne(ee(xn), { label: ee(l)("sketchEdit.name") }, { default: Ge(() => [Ne(ee(mo), { value: U.value.name, "onUpdate:value": et[7] || (et[7] = (ht) => U.value.name = ht), placeholder: ee(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.description") }, { default: Ge(() => [Ne(ee(mo), { value: U.value.description, "onUpdate:value": et[8] || (et[8] = (ht) => U.value.description = ht), type: "textarea", placeholder: ee(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(l)("sketchEdit.tags") }, { default: Ge(() => [It("div", E4, [Ne(ee(mo), { value: X.value, "onUpdate:value": et[9] || (et[9] = (ht) => X.value = ht), placeholder: ee(l)("sketchEdit.addTagPlaceholder"), onKeydown: by(zd(Ke, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), Ne(ee(Vr), { onClick: Ke }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.add")), 1)]), _: 1 })]), (St(true), Xt(qr, null, dn(U.value.tags, (ht) => (St(), Sr(ee(Do), { key: ht, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: (yt) => lt(ht) }, { default: Ge(() => [Pr(ir(ht), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), U.value.tags.length === 0 ? (St(), Sr(ee($d), { key: 0, description: ee(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : Kr("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), It("div", R4, [It("div", A4, [It("div", D4, [Ne(ee(qa), null, { default: Ge(() => {
    var _a3;
    return [Ne(p4, { "sketch-name": (_a3 = H.value) == null ? void 0 : _a3.meta.name, "draft-count": Q.value.length, "route-count": ie.value.length, onSave: Se, onOpen: et[12] || (et[12] = (ht) => C.value = true), onCreate: et[13] || (et[13] = (ht) => z.value = true), onEditMeta: Ve }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), Ne(ee(k_), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: Ge(() => [Ne(ee(k_), { style: { height: "100%" }, direction: "vertical" }, { 1: Ge(() => [Ne(ee(qa), { style: { height: "100%" }, title: ee(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": Ge(() => [Ne(ee(Vr), { quaternary: "", circle: "", onClick: et[16] || (et[16] = (ht) => z.value = true) }, { icon: Ge(() => [Ne(ee(Od))]), _: 1 })]), default: Ge(() => [Ne(v4, { components: J.value, "selected-id": T.value, onSelect: et[14] || (et[14] = (ht, yt) => {
    T.value = ht, M.value = yt;
  }), onDelete: de, onCreate: et[15] || (et[15] = (ht) => z.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: Ge(() => [Ne(ee(qa), { class: "map-container", "content-style": "padding: 0;" }, { default: Ge(() => [Ne(ee(Kb), { "map-style": ee(m), center: [0, 0], zoom: ee(g), height: "100%", "onMap:load": ee(s) }, { default: Ge(() => [Ne(ee(Qb), { position: "top-left" }), Ne(ee(t1), { position: "bottom-left" }), Ne(ee(Jb), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), te.value ? Kr("", true) : (St(), Sr(ee($d), { key: 0, description: ee(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(K2))]), _: 1 })]), extra: Ge(() => [Ne(ee(Vr), { size: "small", onClick: et[17] || (et[17] = (ht) => C.value = true) }, { default: Ge(() => [Pr(ir(ee(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: Ge(() => [Ne(ee(qa), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: Ge(() => [re.value ? (St(), Sr(ee(Ua), { key: 0, depth: "3", class: "metadata" }, { default: Ge(() => [It("div", z4, ir(ee(l)("sketchEdit.createdTimeBy", { user: re.value.meta.created_by, time: xt(re.value.meta.creation_timestamp) })), 1), It("div", F4, ir(ee(l)("sketchEdit.modifiedTimeBy", { user: re.value.meta.modified_by, time: xt(re.value.meta.modification_timestamp) })), 1)]), _: 1 })) : Kr("", true)]), default: Ge(() => [Ne(x4, { component: re.value, type: M.value, onUpdateProperties: xe, onUpdateMeta: et[18] || (et[18] = (ht) => $e(ht)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), B4 = yo(L4, [["__scopeId", "data-v-b8cdd1f5"]]), O4 = { class: "sketch-centre-view" }, $4 = { class: "header" }, j4 = { class: "title" }, N4 = { class: "card-header" }, V4 = { key: 0, class: "tags" }, U4 = { class: "card-content" }, G4 = { class: "meta-info" }, q4 = { class: "meta-item" }, W4 = { class: "meta-item" }, Z4 = { class: "meta-item" }, H4 = { key: 0, class: "empty-state" }, X4 = st({ __name: "SketchCentreView", setup(r) {
  nc((oe) => ({ "460cb2d9": ee(fe).bodyColor }));
  const { t: i } = zo(), l = kb(), d = sp(), f = Fl(), g = Jg(), m = ze(() => g.sketches), s = ze({ get: () => g.currentSketchId, set: (oe) => g.setCurrentSketchId(oe) }), C = (oe) => {
    const de = s.value === oe;
    return { borderColor: de ? f.value.primaryColor : "", borderWidth: de ? "2px" : "1px", padding: de ? "0px" : "1px", zIndex: de ? 0 : 1 };
  }, T = Ae(false), M = Ae(""), z = Ae(""), L = Ae(false), A = Ae(""), O = async () => {
    await g.init();
  }, U = (oe) => new Date(oe).toLocaleDateString(), X = (oe) => oe.routes.routes.length, H = (oe) => oe.drafts.drafts.length, Q = (oe) => {
    g.setCurrentSketchId(oe);
  }, ie = (oe) => {
    A.value = oe, L.value = true;
  }, te = async () => {
    if (!M.value.trim()) {
      d.error(i("sketchCentreView.nameRequired"));
      return;
    }
    const oe = await g.createSketch(M.value);
    await g.updateSketch(oe.id, { description: z.value }), g.setCurrentSketchId(oe.id), T.value = false, M.value = "", z.value = "", d.success(i("sketchCentreView.sketchCreated"));
  }, re = (oe) => {
    const de = m.value.find((xe) => xe.id === oe);
    de && l.warning({ title: i("sketchCentreView.deleteConfirmation.title"), content: i("sketchCentreView.deleteConfirmation.prompt", { name: de.meta.name }), positiveText: i("sketchCentreView.deleteConfirmation.yes"), negativeText: i("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await g.deleteSketch(oe), d.success(i("sketchCentreView.sketchDeleted"));
    } });
  }, { width: J } = Gy(), Se = ze(() => Math.floor(J.value / 360));
  Qi(() => {
    O();
  });
  const fe = Fl();
  return (oe, de) => (St(), Xt("div", O4, [It("div", $4, [It("h1", j4, ir(ee(i)("sketchCentreView.title")), 1), Ne(ee(Vr), { type: "primary", secondary: "", circle: "", onClick: de[0] || (de[0] = (xe) => T.value = true) }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(Od))]), _: 1 })]), _: 1 })]), Ne(ee(UT), { cols: Se.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: Ge(() => [(St(true), Xt(qr, null, dn(m.value, (xe) => (St(), Sr(ee(jT), { key: xe.id }, { default: Ge(() => [Ne(ee(qa), { class: kl(["sketch-card", { selected: s.value === xe.id }]), style: ws(C(xe.id)), hoverable: "", bordered: "", clickable: "", onClick: ($e) => Q(xe.id) }, { header: Ge(() => [It("div", N4, [Ne(ee(Ua), { class: "sketch-name" }, { default: Ge(() => [Pr(ir(xe.meta.name), 1)]), _: 2 }, 1024), xe.meta.tags.length > 0 ? (St(), Xt("div", V4, [(St(true), Xt(qr, null, dn(xe.meta.tags.slice(0, 3), ($e) => (St(), Sr(ee(Do), { key: $e, size: "small", round: "", type: "info" }, { default: Ge(() => [Pr(ir($e.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), xe.meta.tags.length > 3 ? (St(), Sr(ee(Do), { key: 0, size: "small", round: "", type: "info" }, { default: Ge(() => [Pr(" +" + ir(xe.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : Kr("", true)])) : Kr("", true)])]), "header-extra": Ge(() => [Ne(ee(Cl), null, { default: Ge(() => [Ne(ee(Vr), { quaternary: "", circle: "", size: "small", onClick: zd(($e) => ie(xe.id), ["stop"]) }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(h3))]), _: 1 })]), _: 1 }, 8, ["onClick"]), Ne(ee(Vr), { quaternary: "", circle: "", size: "small", onClick: zd(($e) => re(xe.id), ["stop"]) }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(np))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), _: 2 }, 1024)]), default: Ge(() => [It("div", U4, [Ne(ee(Ua), { depth: "3", class: "description" }, { default: Ge(() => [Pr(ir(xe.meta.description || ee(i)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), It("div", G4, [It("div", q4, [Ne(ee(ki), { size: 16 }, { default: Ge(() => [Ne(ee(l3))]), _: 1 }), Ne(ee(Ua), { depth: "3", style: { "font-size": "12px" } }, { default: Ge(() => [Pr(ir(U(xe.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), It("div", W4, [Ne(ee(ki), { size: 16 }, { default: Ge(() => [Ne(ee(Vg))]), _: 1 }), Ne(ee(Ua), { depth: "3", style: { "font-size": "12px" } }, { default: Ge(() => [Pr(ir(X(xe)) + " " + ir(ee(i)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), It("div", Z4, [Ne(ee(ki), { size: 16 }, { default: Ge(() => [Ne(ee(nb))]), _: 1 }), Ne(ee(Ua), { depth: "3", style: { "font-size": "12px" } }, { default: Ge(() => [Pr(ir(H(xe)) + " " + ir(ee(i)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), m.value.length === 0 ? (St(), Xt("div", H4, [Ne(ee(ki), { size: "48", depth: "3" }, { default: Ge(() => [Ne(ee(Uy))]), _: 1 }), Ne(ee(Ua), { depth: "3" }, { default: Ge(() => [Pr(ir(ee(i)("sketchCentreView.emptyState")), 1)]), _: 1 }), Ne(ee(Vr), { type: "primary", onClick: de[1] || (de[1] = (xe) => T.value = true) }, { icon: Ge(() => [Ne(ee(ki), null, { default: Ge(() => [Ne(ee(Od))]), _: 1 })]), default: Ge(() => [Pr(" " + ir(ee(i)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : Kr("", true), Ne(ee(Bd), { show: T.value, "onUpdate:show": de[5] || (de[5] = (xe) => T.value = xe), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: ee(i)("sketchCentreView.newSketch") }, { footer: Ge(() => [Ne(ee(Cl), { justify: "end" }, { default: Ge(() => [Ne(ee(Vr), { onClick: de[4] || (de[4] = (xe) => T.value = false) }, { default: Ge(() => [Pr(ir(ee(i)("sketchCentreView.cancel")), 1)]), _: 1 }), Ne(ee(Vr), { type: "primary", onClick: te }, { default: Ge(() => [Pr(ir(ee(i)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: Ge(() => [Ne(ee(Nd), { model: { name: M.value, description: z.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: Ge(() => [Ne(ee(xn), { label: ee(i)("sketchCentreView.sketchName"), required: "" }, { default: Ge(() => [Ne(ee(mo), { value: M.value, "onUpdate:value": de[2] || (de[2] = (xe) => M.value = xe), placeholder: ee(i)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(ee(xn), { label: ee(i)("sketchCentreView.description") }, { default: Ge(() => [Ne(ee(mo), { value: z.value, "onUpdate:value": de[3] || (de[3] = (xe) => z.value = xe), type: "textarea", placeholder: ee(i)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), Ne(ee(Pb), { show: L.value, "onUpdate:show": de[6] || (de[6] = (xe) => L.value = xe), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: Ge(() => [Ne(ee(Tb), { title: ee(i)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: Ge(() => [A.value ? (St(), Sr(B4, { key: 0, "sketch-id": A.value }, null, 8, ["sketch-id"])) : Kr("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), p1 = yo(X4, [["__scopeId", "data-v-00cdfd4b"]]), Y4 = Object.freeze(Object.defineProperty({ __proto__: null, default: p1 }, Symbol.toStringTag, { value: "Module" })), J_ = {};
function K4(r) {
  let i = J_[r];
  if (i) return i;
  i = J_[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    i.push(d);
  }
  for (let l = 0; l < r.length; l++) {
    const d = r.charCodeAt(l);
    i[d] = "%" + ("0" + d.toString(16).toUpperCase()).slice(-2);
  }
  return i;
}
function rc(r, i) {
  typeof i != "string" && (i = rc.defaultChars);
  const l = K4(i);
  return r.replace(/(%[a-f0-9]{2})+/gi, function(d) {
    let f = "";
    for (let g = 0, m = d.length; g < m; g += 3) {
      const s = parseInt(d.slice(g + 1, g + 3), 16);
      if (s < 128) {
        f += l[s];
        continue;
      }
      if ((s & 224) === 192 && g + 3 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16);
        if ((C & 192) === 128) {
          const T = s << 6 & 1984 | C & 63;
          T < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(T), g += 3;
          continue;
        }
      }
      if ((s & 240) === 224 && g + 6 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), T = parseInt(d.slice(g + 7, g + 9), 16);
        if ((C & 192) === 128 && (T & 192) === 128) {
          const M = s << 12 & 61440 | C << 6 & 4032 | T & 63;
          M < 2048 || M >= 55296 && M <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(M), g += 6;
          continue;
        }
      }
      if ((s & 248) === 240 && g + 9 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), T = parseInt(d.slice(g + 7, g + 9), 16), M = parseInt(d.slice(g + 10, g + 12), 16);
        if ((C & 192) === 128 && (T & 192) === 128 && (M & 192) === 128) {
          let z = s << 18 & 1835008 | C << 12 & 258048 | T << 6 & 4032 | M & 63;
          z < 65536 || z > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (z -= 65536, f += String.fromCharCode(55296 + (z >> 10), 56320 + (z & 1023))), g += 9;
          continue;
        }
      }
      f += "\uFFFD";
    }
    return f;
  });
}
rc.defaultChars = ";/?:@&=+$,#";
rc.componentChars = "";
const Q_ = {};
function J4(r) {
  let i = Q_[r];
  if (i) return i;
  i = Q_[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    /^[0-9a-z]$/i.test(d) ? i.push(d) : i.push("%" + ("0" + l.toString(16).toUpperCase()).slice(-2));
  }
  for (let l = 0; l < r.length; l++) i[r.charCodeAt(l)] = r[l];
  return i;
}
function rh(r, i, l) {
  typeof i != "string" && (l = i, i = rh.defaultChars), typeof l > "u" && (l = true);
  const d = J4(i);
  let f = "";
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r.charCodeAt(g);
    if (l && s === 37 && g + 2 < m && /^[0-9a-f]{2}$/i.test(r.slice(g + 1, g + 3))) {
      f += r.slice(g, g + 3), g += 2;
      continue;
    }
    if (s < 128) {
      f += d[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && g + 1 < m) {
        const C = r.charCodeAt(g + 1);
        if (C >= 56320 && C <= 57343) {
          f += encodeURIComponent(r[g] + r[g + 1]), g++;
          continue;
        }
      }
      f += "%EF%BF%BD";
      continue;
    }
    f += encodeURIComponent(r[g]);
  }
  return f;
}
rh.defaultChars = ";/?:@&=+$,-_.!~*'()#";
rh.componentChars = "-_.!~*'()";
function Qg(r) {
  let i = "";
  return i += r.protocol || "", i += r.slashes ? "//" : "", i += r.auth ? r.auth + "@" : "", r.hostname && r.hostname.indexOf(":") !== -1 ? i += "[" + r.hostname + "]" : i += r.hostname || "", i += r.port ? ":" + r.port : "", i += r.pathname || "", i += r.search || "", i += r.hash || "", i;
}
function Wf() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Q4 = /^([a-z0-9.+-]+:)/i, eM = /:[0-9]*$/, tM = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, rM = ["<", ">", '"', "`", " ", "\r", `
`, "	"], iM = ["{", "}", "|", "\\", "^", "`"].concat(rM), nM = ["'"].concat(iM), ey = ["%", "/", "?", ";", "#"].concat(nM), ty = ["/", "?", "#"], oM = 255, ry = /^[+a-z0-9A-Z_-]{0,63}$/, aM = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, iy = { javascript: true, "javascript:": true }, ny = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
function e0(r, i) {
  if (r && r instanceof Wf) return r;
  const l = new Wf();
  return l.parse(r, i), l;
}
Wf.prototype.parse = function(r, i) {
  let l, d, f, g = r;
  if (g = g.trim(), !i && r.split("#").length === 1) {
    const T = tM.exec(g);
    if (T) return this.pathname = T[1], T[2] && (this.search = T[2]), this;
  }
  let m = Q4.exec(g);
  if (m && (m = m[0], l = m.toLowerCase(), this.protocol = m, g = g.substr(m.length)), (i || m || g.match(/^\/\/[^@\/]+@[^@\/]+/)) && (f = g.substr(0, 2) === "//", f && !(m && iy[m]) && (g = g.substr(2), this.slashes = true)), !iy[m] && (f || m && !ny[m])) {
    let T = -1;
    for (let O = 0; O < ty.length; O++) d = g.indexOf(ty[O]), d !== -1 && (T === -1 || d < T) && (T = d);
    let M, z;
    T === -1 ? z = g.lastIndexOf("@") : z = g.lastIndexOf("@", T), z !== -1 && (M = g.slice(0, z), g = g.slice(z + 1), this.auth = M), T = -1;
    for (let O = 0; O < ey.length; O++) d = g.indexOf(ey[O]), d !== -1 && (T === -1 || d < T) && (T = d);
    T === -1 && (T = g.length), g[T - 1] === ":" && T--;
    const L = g.slice(0, T);
    g = g.slice(T), this.parseHost(L), this.hostname = this.hostname || "";
    const A = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!A) {
      const O = this.hostname.split(/\./);
      for (let U = 0, X = O.length; U < X; U++) {
        const H = O[U];
        if (H && !H.match(ry)) {
          let Q = "";
          for (let ie = 0, te = H.length; ie < te; ie++) H.charCodeAt(ie) > 127 ? Q += "x" : Q += H[ie];
          if (!Q.match(ry)) {
            const ie = O.slice(0, U), te = O.slice(U + 1), re = H.match(aM);
            re && (ie.push(re[1]), te.unshift(re[2])), te.length && (g = te.join(".") + g), this.hostname = ie.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > oM && (this.hostname = ""), A && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const s = g.indexOf("#");
  s !== -1 && (this.hash = g.substr(s), g = g.slice(0, s));
  const C = g.indexOf("?");
  return C !== -1 && (this.search = g.substr(C), g = g.slice(0, C)), g && (this.pathname = g), ny[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Wf.prototype.parseHost = function(r) {
  let i = eM.exec(r);
  i && (i = i[0], i !== ":" && (this.port = i.substr(1)), r = r.substr(0, r.length - i.length)), r && (this.hostname = r);
};
const sM = Object.freeze(Object.defineProperty({ __proto__: null, decode: rc, encode: rh, format: Qg, parse: e0 }, Symbol.toStringTag, { value: "Module" })), m1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, g1 = /[\0-\x1F\x7F-\x9F]/, lM = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, t0 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, v1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, _1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, uM = Object.freeze(Object.defineProperty({ __proto__: null, Any: m1, Cc: g1, Cf: lM, P: t0, S: v1, Z: _1 }, Symbol.toStringTag, { value: "Module" })), cM = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((r) => r.charCodeAt(0))), dM = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((r) => r.charCodeAt(0)));
var Ym;
const hM = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), fM = (Ym = String.fromCodePoint) !== null && Ym !== void 0 ? Ym : function(r) {
  let i = "";
  return r > 65535 && (r -= 65536, i += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), i += String.fromCharCode(r), i;
};
function pM(r) {
  var i;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (i = hM.get(r)) !== null && i !== void 0 ? i : r;
}
var cn;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(cn || (cn = {}));
const mM = 32;
var Ps;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ps || (Ps = {}));
function Rg(r) {
  return r >= cn.ZERO && r <= cn.NINE;
}
function gM(r) {
  return r >= cn.UPPER_A && r <= cn.UPPER_F || r >= cn.LOWER_A && r <= cn.LOWER_F;
}
function vM(r) {
  return r >= cn.UPPER_A && r <= cn.UPPER_Z || r >= cn.LOWER_A && r <= cn.LOWER_Z || Rg(r);
}
function _M(r) {
  return r === cn.EQUALS || vM(r);
}
var ln;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(ln || (ln = {}));
var ks;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(ks || (ks = {}));
class yM {
  constructor(i, l, d) {
    this.decodeTree = i, this.emitCodePoint = l, this.errors = d, this.state = ln.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ks.Strict;
  }
  startEntity(i) {
    this.decodeMode = i, this.state = ln.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(i, l) {
    switch (this.state) {
      case ln.EntityStart:
        return i.charCodeAt(l) === cn.NUM ? (this.state = ln.NumericStart, this.consumed += 1, this.stateNumericStart(i, l + 1)) : (this.state = ln.NamedEntity, this.stateNamedEntity(i, l));
      case ln.NumericStart:
        return this.stateNumericStart(i, l);
      case ln.NumericDecimal:
        return this.stateNumericDecimal(i, l);
      case ln.NumericHex:
        return this.stateNumericHex(i, l);
      case ln.NamedEntity:
        return this.stateNamedEntity(i, l);
    }
  }
  stateNumericStart(i, l) {
    return l >= i.length ? -1 : (i.charCodeAt(l) | mM) === cn.LOWER_X ? (this.state = ln.NumericHex, this.consumed += 1, this.stateNumericHex(i, l + 1)) : (this.state = ln.NumericDecimal, this.stateNumericDecimal(i, l));
  }
  addToNumericResult(i, l, d, f) {
    if (l !== d) {
      const g = d - l;
      this.result = this.result * Math.pow(f, g) + parseInt(i.substr(l, g), f), this.consumed += g;
    }
  }
  stateNumericHex(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Rg(f) || gM(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 16), this.emitNumericEntity(f, 3);
    }
    return this.addToNumericResult(i, d, l, 16), -1;
  }
  stateNumericDecimal(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Rg(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 10), this.emitNumericEntity(f, 2);
    }
    return this.addToNumericResult(i, d, l, 10), -1;
  }
  emitNumericEntity(i, l) {
    var d;
    if (this.consumed <= l) return (d = this.errors) === null || d === void 0 || d.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (i === cn.SEMI) this.consumed += 1;
    else if (this.decodeMode === ks.Strict) return 0;
    return this.emitCodePoint(pM(this.result), this.consumed), this.errors && (i !== cn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(i, l) {
    const { decodeTree: d } = this;
    let f = d[this.treeIndex], g = (f & Ps.VALUE_LENGTH) >> 14;
    for (; l < i.length; l++, this.excess++) {
      const m = i.charCodeAt(l);
      if (this.treeIndex = bM(d, f, this.treeIndex + Math.max(1, g), m), this.treeIndex < 0) return this.result === 0 || this.decodeMode === ks.Attribute && (g === 0 || _M(m)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (f = d[this.treeIndex], g = (f & Ps.VALUE_LENGTH) >> 14, g !== 0) {
        if (m === cn.SEMI) return this.emitNamedEntityData(this.treeIndex, g, this.consumed + this.excess);
        this.decodeMode !== ks.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var i;
    const { result: l, decodeTree: d } = this, f = (d[l] & Ps.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(l, f, this.consumed), (i = this.errors) === null || i === void 0 || i.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(i, l, d) {
    const { decodeTree: f } = this;
    return this.emitCodePoint(l === 1 ? f[i] & ~Ps.VALUE_LENGTH : f[i + 1], d), l === 3 && this.emitCodePoint(f[i + 2], d), d;
  }
  end() {
    var i;
    switch (this.state) {
      case ln.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ks.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case ln.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case ln.NumericHex:
        return this.emitNumericEntity(0, 3);
      case ln.NumericStart:
        return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case ln.EntityStart:
        return 0;
    }
  }
}
function y1(r) {
  let i = "";
  const l = new yM(r, (d) => i += fM(d));
  return function(f, g) {
    let m = 0, s = 0;
    for (; (s = f.indexOf("&", s)) >= 0; ) {
      i += f.slice(m, s), l.startEntity(g);
      const T = l.write(f, s + 1);
      if (T < 0) {
        m = s + l.end();
        break;
      }
      m = s + T, s = T === 0 ? m + 1 : m;
    }
    const C = i + f.slice(m);
    return i = "", C;
  };
}
function bM(r, i, l, d) {
  const f = (i & Ps.BRANCH_LENGTH) >> 7, g = i & Ps.JUMP_TABLE;
  if (f === 0) return g !== 0 && d === g ? l : -1;
  if (g) {
    const C = d - g;
    return C < 0 || C >= f ? -1 : r[l + C] - 1;
  }
  let m = l, s = m + f - 1;
  for (; m <= s; ) {
    const C = m + s >>> 1, T = r[C];
    if (T < d) m = C + 1;
    else if (T > d) s = C - 1;
    else return r[C + f];
  }
  return -1;
}
const xM = y1(cM);
y1(dM);
function b1(r, i = ks.Legacy) {
  return xM(r, i);
}
function wM(r) {
  return Object.prototype.toString.call(r);
}
function r0(r) {
  return wM(r) === "[object String]";
}
const CM = Object.prototype.hasOwnProperty;
function SM(r, i) {
  return CM.call(r, i);
}
function dp(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    if (l) {
      if (typeof l != "object") throw new TypeError(l + "must be object");
      Object.keys(l).forEach(function(d) {
        r[d] = l[d];
      });
    }
  }), r;
}
function x1(r, i, l) {
  return [].concat(r.slice(0, i), l, r.slice(i + 1));
}
function i0(r) {
  return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111);
}
function Zf(r) {
  if (r > 65535) {
    r -= 65536;
    const i = 55296 + (r >> 10), l = 56320 + (r & 1023);
    return String.fromCharCode(i, l);
  }
  return String.fromCharCode(r);
}
const w1 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, kM = /&([a-z#][a-z0-9]{1,31});/gi, PM = new RegExp(w1.source + "|" + kM.source, "gi"), TM = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function IM(r, i) {
  if (i.charCodeAt(0) === 35 && TM.test(i)) {
    const d = i[1].toLowerCase() === "x" ? parseInt(i.slice(2), 16) : parseInt(i.slice(1), 10);
    return i0(d) ? Zf(d) : r;
  }
  const l = b1(r);
  return l !== r ? l : r;
}
function MM(r) {
  return r.indexOf("\\") < 0 ? r : r.replace(w1, "$1");
}
function ic(r) {
  return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(PM, function(i, l, d) {
    return l || IM(i, d);
  });
}
const EM = /[&<>"]/, RM = /[&<>"]/g, AM = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
function DM(r) {
  return AM[r];
}
function Es(r) {
  return EM.test(r) ? r.replace(RM, DM) : r;
}
const zM = /[.?*+^$[\]\\(){}|-]/g;
function FM(r) {
  return r.replace(zM, "\\$&");
}
function mi(r) {
  switch (r) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Gd(r) {
  if (r >= 8192 && r <= 8202) return true;
  switch (r) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function qd(r) {
  return t0.test(r) || v1.test(r);
}
function Wd(r) {
  switch (r) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function hp(r) {
  return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(//g, "\xDF")), r.toLowerCase().toUpperCase();
}
const LM = { mdurl: sM, ucmicro: uM }, BM = Object.freeze(Object.defineProperty({ __proto__: null, arrayReplaceAt: x1, assign: dp, escapeHtml: Es, escapeRE: FM, fromCodePoint: Zf, has: SM, isMdAsciiPunct: Wd, isPunctChar: qd, isSpace: mi, isString: r0, isValidEntityCode: i0, isWhiteSpace: Gd, lib: LM, normalizeReference: hp, unescapeAll: ic, unescapeMd: MM }, Symbol.toStringTag, { value: "Module" }));
function OM(r, i, l) {
  let d, f, g, m;
  const s = r.posMax, C = r.pos;
  for (r.pos = i + 1, d = 1; r.pos < s; ) {
    if (g = r.src.charCodeAt(r.pos), g === 93 && (d--, d === 0)) {
      f = true;
      break;
    }
    if (m = r.pos, r.md.inline.skipToken(r), g === 91) {
      if (m === r.pos - 1) d++;
      else if (l) return r.pos = C, -1;
    }
  }
  let T = -1;
  return f && (T = r.pos), r.pos = C, T;
}
function $M(r, i, l) {
  let d, f = i;
  const g = { ok: false, pos: 0, str: "" };
  if (r.charCodeAt(f) === 60) {
    for (f++; f < l; ) {
      if (d = r.charCodeAt(f), d === 10 || d === 60) return g;
      if (d === 62) return g.pos = f + 1, g.str = ic(r.slice(i + 1, f)), g.ok = true, g;
      if (d === 92 && f + 1 < l) {
        f += 2;
        continue;
      }
      f++;
    }
    return g;
  }
  let m = 0;
  for (; f < l && (d = r.charCodeAt(f), !(d === 32 || d < 32 || d === 127)); ) {
    if (d === 92 && f + 1 < l) {
      if (r.charCodeAt(f + 1) === 32) break;
      f += 2;
      continue;
    }
    if (d === 40 && (m++, m > 32)) return g;
    if (d === 41) {
      if (m === 0) break;
      m--;
    }
    f++;
  }
  return i === f || m !== 0 || (g.str = ic(r.slice(i, f)), g.pos = f, g.ok = true), g;
}
function jM(r, i, l, d) {
  let f, g = i;
  const m = { ok: false, can_continue: false, pos: 0, str: "", marker: 0 };
  if (d) m.str = d.str, m.marker = d.marker;
  else {
    if (g >= l) return m;
    let s = r.charCodeAt(g);
    if (s !== 34 && s !== 39 && s !== 40) return m;
    i++, g++, s === 40 && (s = 41), m.marker = s;
  }
  for (; g < l; ) {
    if (f = r.charCodeAt(g), f === m.marker) return m.pos = g + 1, m.str += ic(r.slice(i, g)), m.ok = true, m;
    if (f === 40 && m.marker === 41) return m;
    f === 92 && g + 1 < l && g++, g++;
  }
  return m.can_continue = true, m.str += ic(r.slice(i, g)), m;
}
const NM = Object.freeze(Object.defineProperty({ __proto__: null, parseLinkDestination: $M, parseLinkLabel: OM, parseLinkTitle: jM }, Symbol.toStringTag, { value: "Module" })), ba = {};
ba.code_inline = function(r, i, l, d, f) {
  const g = r[i];
  return "<code" + f.renderAttrs(g) + ">" + Es(g.content) + "</code>";
};
ba.code_block = function(r, i, l, d, f) {
  const g = r[i];
  return "<pre" + f.renderAttrs(g) + "><code>" + Es(r[i].content) + `</code></pre>
`;
};
ba.fence = function(r, i, l, d, f) {
  const g = r[i], m = g.info ? ic(g.info).trim() : "";
  let s = "", C = "";
  if (m) {
    const M = m.split(/(\s+)/g);
    s = M[0], C = M.slice(2).join("");
  }
  let T;
  if (l.highlight ? T = l.highlight(g.content, s, C) || Es(g.content) : T = Es(g.content), T.indexOf("<pre") === 0) return T + `
`;
  if (m) {
    const M = g.attrIndex("class"), z = g.attrs ? g.attrs.slice() : [];
    M < 0 ? z.push(["class", l.langPrefix + s]) : (z[M] = z[M].slice(), z[M][1] += " " + l.langPrefix + s);
    const L = { attrs: z };
    return `<pre><code${f.renderAttrs(L)}>${T}</code></pre>
`;
  }
  return `<pre><code${f.renderAttrs(g)}>${T}</code></pre>
`;
};
ba.image = function(r, i, l, d, f) {
  const g = r[i];
  return g.attrs[g.attrIndex("alt")][1] = f.renderInlineAsText(g.children, l, d), f.renderToken(r, i, l);
};
ba.hardbreak = function(r, i, l) {
  return l.xhtmlOut ? `<br />
` : `<br>
`;
};
ba.softbreak = function(r, i, l) {
  return l.breaks ? l.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ba.text = function(r, i) {
  return Es(r[i].content);
};
ba.html_block = function(r, i) {
  return r[i].content;
};
ba.html_inline = function(r, i) {
  return r[i].content;
};
function uc() {
  this.rules = dp({}, ba);
}
uc.prototype.renderAttrs = function(i) {
  let l, d, f;
  if (!i.attrs) return "";
  for (f = "", l = 0, d = i.attrs.length; l < d; l++) f += " " + Es(i.attrs[l][0]) + '="' + Es(i.attrs[l][1]) + '"';
  return f;
};
uc.prototype.renderToken = function(i, l, d) {
  const f = i[l];
  let g = "";
  if (f.hidden) return "";
  f.block && f.nesting !== -1 && l && i[l - 1].hidden && (g += `
`), g += (f.nesting === -1 ? "</" : "<") + f.tag, g += this.renderAttrs(f), f.nesting === 0 && d.xhtmlOut && (g += " /");
  let m = false;
  if (f.block && (m = true, f.nesting === 1 && l + 1 < i.length)) {
    const s = i[l + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === f.tag) && (m = false);
  }
  return g += m ? `>
` : ">", g;
};
uc.prototype.renderInline = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i);
  }
  return d;
};
uc.prototype.renderInlineAsText = function(r, i, l) {
  let d = "";
  for (let f = 0, g = r.length; f < g; f++) switch (r[f].type) {
    case "text":
      d += r[f].content;
      break;
    case "image":
      d += this.renderInlineAsText(r[f].children, i, l);
      break;
    case "html_inline":
    case "html_block":
      d += r[f].content;
      break;
    case "softbreak":
    case "hardbreak":
      d += `
`;
      break;
  }
  return d;
};
uc.prototype.render = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    s === "inline" ? d += this.renderInline(r[g].children, i, l) : typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i, l);
  }
  return d;
};
function Yn() {
  this.__rules__ = [], this.__cache__ = null;
}
Yn.prototype.__find__ = function(r) {
  for (let i = 0; i < this.__rules__.length; i++) if (this.__rules__[i].name === r) return i;
  return -1;
};
Yn.prototype.__compile__ = function() {
  const r = this, i = [""];
  r.__rules__.forEach(function(l) {
    l.enabled && l.alt.forEach(function(d) {
      i.indexOf(d) < 0 && i.push(d);
    });
  }), r.__cache__ = {}, i.forEach(function(l) {
    r.__cache__[l] = [], r.__rules__.forEach(function(d) {
      d.enabled && (l && d.alt.indexOf(l) < 0 || r.__cache__[l].push(d.fn));
    });
  });
};
Yn.prototype.at = function(r, i, l) {
  const d = this.__find__(r), f = l || {};
  if (d === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__[d].fn = i, this.__rules__[d].alt = f.alt || [], this.__cache__ = null;
};
Yn.prototype.before = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Yn.prototype.after = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f + 1, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Yn.prototype.push = function(r, i, l) {
  const d = l || {};
  this.__rules__.push({ name: r, enabled: true, fn: i, alt: d.alt || [] }), this.__cache__ = null;
};
Yn.prototype.enable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = true, l.push(d);
  }, this), this.__cache__ = null, l;
};
Yn.prototype.enableOnly = function(r, i) {
  Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(l) {
    l.enabled = false;
  }), this.enable(r, i);
};
Yn.prototype.disable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = false, l.push(d);
  }, this), this.__cache__ = null, l;
};
Yn.prototype.getRules = function(r) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[r] || [];
};
function Jo(r, i, l) {
  this.type = r, this.tag = i, this.attrs = null, this.map = null, this.nesting = l, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Jo.prototype.attrIndex = function(i) {
  if (!this.attrs) return -1;
  const l = this.attrs;
  for (let d = 0, f = l.length; d < f; d++) if (l[d][0] === i) return d;
  return -1;
};
Jo.prototype.attrPush = function(i) {
  this.attrs ? this.attrs.push(i) : this.attrs = [i];
};
Jo.prototype.attrSet = function(i, l) {
  const d = this.attrIndex(i), f = [i, l];
  d < 0 ? this.attrPush(f) : this.attrs[d] = f;
};
Jo.prototype.attrGet = function(i) {
  const l = this.attrIndex(i);
  let d = null;
  return l >= 0 && (d = this.attrs[l][1]), d;
};
Jo.prototype.attrJoin = function(i, l) {
  const d = this.attrIndex(i);
  d < 0 ? this.attrPush([i, l]) : this.attrs[d][1] = this.attrs[d][1] + " " + l;
};
function C1(r, i, l) {
  this.src = r, this.env = l, this.tokens = [], this.inlineMode = false, this.md = i;
}
C1.prototype.Token = Jo;
const VM = /\r\n?|\n/g, UM = /\0/g;
function GM(r) {
  let i;
  i = r.src.replace(VM, `
`), i = i.replace(UM, "\uFFFD"), r.src = i;
}
function qM(r) {
  let i;
  r.inlineMode ? (i = new r.Token("inline", "", 0), i.content = r.src, i.map = [0, 1], i.children = [], r.tokens.push(i)) : r.md.block.parse(r.src, r.md, r.env, r.tokens);
}
function WM(r) {
  const i = r.tokens;
  for (let l = 0, d = i.length; l < d; l++) {
    const f = i[l];
    f.type === "inline" && r.md.inline.parse(f.content, r.md, r.env, f.children);
  }
}
function ZM(r) {
  return /^<a[>\s]/i.test(r);
}
function HM(r) {
  return /^<\/a\s*>/i.test(r);
}
function XM(r) {
  const i = r.tokens;
  if (r.md.options.linkify) for (let l = 0, d = i.length; l < d; l++) {
    if (i[l].type !== "inline" || !r.md.linkify.pretest(i[l].content)) continue;
    let f = i[l].children, g = 0;
    for (let m = f.length - 1; m >= 0; m--) {
      const s = f[m];
      if (s.type === "link_close") {
        for (m--; f[m].level !== s.level && f[m].type !== "link_open"; ) m--;
        continue;
      }
      if (s.type === "html_inline" && (ZM(s.content) && g > 0 && g--, HM(s.content) && g++), !(g > 0) && s.type === "text" && r.md.linkify.test(s.content)) {
        const C = s.content;
        let T = r.md.linkify.match(C);
        const M = [];
        let z = s.level, L = 0;
        T.length > 0 && T[0].index === 0 && m > 0 && f[m - 1].type === "text_special" && (T = T.slice(1));
        for (let A = 0; A < T.length; A++) {
          const O = T[A].url, U = r.md.normalizeLink(O);
          if (!r.md.validateLink(U)) continue;
          let X = T[A].text;
          T[A].schema ? T[A].schema === "mailto:" && !/^mailto:/i.test(X) ? X = r.md.normalizeLinkText("mailto:" + X).replace(/^mailto:/, "") : X = r.md.normalizeLinkText(X) : X = r.md.normalizeLinkText("http://" + X).replace(/^http:\/\//, "");
          const H = T[A].index;
          if (H > L) {
            const re = new r.Token("text", "", 0);
            re.content = C.slice(L, H), re.level = z, M.push(re);
          }
          const Q = new r.Token("link_open", "a", 1);
          Q.attrs = [["href", U]], Q.level = z++, Q.markup = "linkify", Q.info = "auto", M.push(Q);
          const ie = new r.Token("text", "", 0);
          ie.content = X, ie.level = z, M.push(ie);
          const te = new r.Token("link_close", "a", -1);
          te.level = --z, te.markup = "linkify", te.info = "auto", M.push(te), L = T[A].lastIndex;
        }
        if (L < C.length) {
          const A = new r.Token("text", "", 0);
          A.content = C.slice(L), A.level = z, M.push(A);
        }
        i[l].children = f = x1(f, m, M);
      }
    }
  }
}
const S1 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, YM = /\((c|tm|r)\)/i, KM = /\((c|tm|r)\)/ig, JM = { c: "\xA9", r: "\xAE", tm: "\u2122" };
function QM(r, i) {
  return JM[i.toLowerCase()];
}
function eE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && (d.content = d.content.replace(KM, QM)), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function tE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && S1.test(d.content) && (d.content = d.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function rE(r) {
  let i;
  if (r.md.options.typographer) for (i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type === "inline" && (YM.test(r.tokens[i].content) && eE(r.tokens[i].children), S1.test(r.tokens[i].content) && tE(r.tokens[i].children));
}
const iE = /['"]/, oy = /['"]/g, ay = "\u2019";
function If(r, i, l) {
  return r.slice(0, i) + l + r.slice(i + 1);
}
function nE(r, i) {
  let l;
  const d = [];
  for (let f = 0; f < r.length; f++) {
    const g = r[f], m = r[f].level;
    for (l = d.length - 1; l >= 0 && !(d[l].level <= m); l--) ;
    if (d.length = l + 1, g.type !== "text") continue;
    let s = g.content, C = 0, T = s.length;
    e: for (; C < T; ) {
      oy.lastIndex = C;
      const M = oy.exec(s);
      if (!M) break;
      let z = true, L = true;
      C = M.index + 1;
      const A = M[0] === "'";
      let O = 32;
      if (M.index - 1 >= 0) O = s.charCodeAt(M.index - 1);
      else for (l = f - 1; l >= 0 && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l--) if (r[l].content) {
        O = r[l].content.charCodeAt(r[l].content.length - 1);
        break;
      }
      let U = 32;
      if (C < T) U = s.charCodeAt(C);
      else for (l = f + 1; l < r.length && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l++) if (r[l].content) {
        U = r[l].content.charCodeAt(0);
        break;
      }
      const X = Wd(O) || qd(String.fromCharCode(O)), H = Wd(U) || qd(String.fromCharCode(U)), Q = Gd(O), ie = Gd(U);
      if (ie ? z = false : H && (Q || X || (z = false)), Q ? L = false : X && (ie || H || (L = false)), U === 34 && M[0] === '"' && O >= 48 && O <= 57 && (L = z = false), z && L && (z = X, L = H), !z && !L) {
        A && (g.content = If(g.content, M.index, ay));
        continue;
      }
      if (L) for (l = d.length - 1; l >= 0; l--) {
        let te = d[l];
        if (d[l].level < m) break;
        if (te.single === A && d[l].level === m) {
          te = d[l];
          let re, J;
          A ? (re = i.md.options.quotes[2], J = i.md.options.quotes[3]) : (re = i.md.options.quotes[0], J = i.md.options.quotes[1]), g.content = If(g.content, M.index, J), r[te.token].content = If(r[te.token].content, te.pos, re), C += J.length - 1, te.token === f && (C += re.length - 1), s = g.content, T = s.length, d.length = l;
          continue e;
        }
      }
      z ? d.push({ token: f, pos: M.index, single: A, level: m }) : L && A && (g.content = If(g.content, M.index, ay));
    }
  }
}
function oE(r) {
  if (r.md.options.typographer) for (let i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type !== "inline" || !iE.test(r.tokens[i].content) || nE(r.tokens[i].children, r);
}
function aE(r) {
  let i, l;
  const d = r.tokens, f = d.length;
  for (let g = 0; g < f; g++) {
    if (d[g].type !== "inline") continue;
    const m = d[g].children, s = m.length;
    for (i = 0; i < s; i++) m[i].type === "text_special" && (m[i].type = "text");
    for (i = l = 0; i < s; i++) m[i].type === "text" && i + 1 < s && m[i + 1].type === "text" ? m[i + 1].content = m[i].content + m[i + 1].content : (i !== l && (m[l] = m[i]), l++);
    i !== l && (m.length = l);
  }
}
const Km = [["normalize", GM], ["block", qM], ["inline", WM], ["linkify", XM], ["replacements", rE], ["smartquotes", oE], ["text_join", aE]];
function n0() {
  this.ruler = new Yn();
  for (let r = 0; r < Km.length; r++) this.ruler.push(Km[r][0], Km[r][1]);
}
n0.prototype.process = function(r) {
  const i = this.ruler.getRules("");
  for (let l = 0, d = i.length; l < d; l++) i[l](r);
};
n0.prototype.State = C1;
function xa(r, i, l, d) {
  this.src = r, this.md = i, this.env = l, this.tokens = d, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const f = this.src;
  for (let g = 0, m = 0, s = 0, C = 0, T = f.length, M = false; m < T; m++) {
    const z = f.charCodeAt(m);
    if (!M) if (mi(z)) {
      s++, z === 9 ? C += 4 - C % 4 : C++;
      continue;
    } else M = true;
    (z === 10 || m === T - 1) && (z !== 10 && m++, this.bMarks.push(g), this.eMarks.push(m), this.tShift.push(s), this.sCount.push(C), this.bsCount.push(0), M = false, s = 0, C = 0, g = m + 1);
  }
  this.bMarks.push(f.length), this.eMarks.push(f.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
xa.prototype.push = function(r, i, l) {
  const d = new Jo(r, i, l);
  return d.block = true, l < 0 && this.level--, d.level = this.level, l > 0 && this.level++, this.tokens.push(d), d;
};
xa.prototype.isEmpty = function(i) {
  return this.bMarks[i] + this.tShift[i] >= this.eMarks[i];
};
xa.prototype.skipEmptyLines = function(i) {
  for (let l = this.lineMax; i < l && !(this.bMarks[i] + this.tShift[i] < this.eMarks[i]); i++) ;
  return i;
};
xa.prototype.skipSpaces = function(i) {
  for (let l = this.src.length; i < l; i++) {
    const d = this.src.charCodeAt(i);
    if (!mi(d)) break;
  }
  return i;
};
xa.prototype.skipSpacesBack = function(i, l) {
  if (i <= l) return i;
  for (; i > l; ) if (!mi(this.src.charCodeAt(--i))) return i + 1;
  return i;
};
xa.prototype.skipChars = function(i, l) {
  for (let d = this.src.length; i < d && this.src.charCodeAt(i) === l; i++) ;
  return i;
};
xa.prototype.skipCharsBack = function(i, l, d) {
  if (i <= d) return i;
  for (; i > d; ) if (l !== this.src.charCodeAt(--i)) return i + 1;
  return i;
};
xa.prototype.getLines = function(i, l, d, f) {
  if (i >= l) return "";
  const g = new Array(l - i);
  for (let m = 0, s = i; s < l; s++, m++) {
    let C = 0;
    const T = this.bMarks[s];
    let M = T, z;
    for (s + 1 < l || f ? z = this.eMarks[s] + 1 : z = this.eMarks[s]; M < z && C < d; ) {
      const L = this.src.charCodeAt(M);
      if (mi(L)) L === 9 ? C += 4 - (C + this.bsCount[s]) % 4 : C++;
      else if (M - T < this.tShift[s]) C++;
      else break;
      M++;
    }
    C > d ? g[m] = new Array(C - d + 1).join(" ") + this.src.slice(M, z) : g[m] = this.src.slice(M, z);
  }
  return g.join("");
};
xa.prototype.Token = Jo;
const sE = 65536;
function Jm(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  return r.src.slice(l, d);
}
function sy(r) {
  const i = [], l = r.length;
  let d = 0, f = r.charCodeAt(d), g = false, m = 0, s = "";
  for (; d < l; ) f === 124 && (g ? (s += r.substring(m, d - 1), m = d) : (i.push(s + r.substring(m, d)), s = "", m = d + 1)), g = f === 92, d++, f = r.charCodeAt(d);
  return i.push(s + r.substring(m)), i;
}
function lE(r, i, l, d) {
  if (i + 2 > l) return false;
  let f = i + 1;
  if (r.sCount[f] < r.blkIndent || r.sCount[f] - r.blkIndent >= 4) return false;
  let g = r.bMarks[f] + r.tShift[f];
  if (g >= r.eMarks[f]) return false;
  const m = r.src.charCodeAt(g++);
  if (m !== 124 && m !== 45 && m !== 58 || g >= r.eMarks[f]) return false;
  const s = r.src.charCodeAt(g++);
  if (s !== 124 && s !== 45 && s !== 58 && !mi(s) || m === 45 && mi(s)) return false;
  for (; g < r.eMarks[f]; ) {
    const te = r.src.charCodeAt(g);
    if (te !== 124 && te !== 45 && te !== 58 && !mi(te)) return false;
    g++;
  }
  let C = Jm(r, i + 1), T = C.split("|");
  const M = [];
  for (let te = 0; te < T.length; te++) {
    const re = T[te].trim();
    if (!re) {
      if (te === 0 || te === T.length - 1) continue;
      return false;
    }
    if (!/^:?-+:?$/.test(re)) return false;
    re.charCodeAt(re.length - 1) === 58 ? M.push(re.charCodeAt(0) === 58 ? "center" : "right") : re.charCodeAt(0) === 58 ? M.push("left") : M.push("");
  }
  if (C = Jm(r, i).trim(), C.indexOf("|") === -1 || r.sCount[i] - r.blkIndent >= 4) return false;
  T = sy(C), T.length && T[0] === "" && T.shift(), T.length && T[T.length - 1] === "" && T.pop();
  const z = T.length;
  if (z === 0 || z !== M.length) return false;
  if (d) return true;
  const L = r.parentType;
  r.parentType = "table";
  const A = r.md.block.ruler.getRules("blockquote"), O = r.push("table_open", "table", 1), U = [i, 0];
  O.map = U;
  const X = r.push("thead_open", "thead", 1);
  X.map = [i, i + 1];
  const H = r.push("tr_open", "tr", 1);
  H.map = [i, i + 1];
  for (let te = 0; te < T.length; te++) {
    const re = r.push("th_open", "th", 1);
    M[te] && (re.attrs = [["style", "text-align:" + M[te]]]);
    const J = r.push("inline", "", 0);
    J.content = T[te].trim(), J.children = [], r.push("th_close", "th", -1);
  }
  r.push("tr_close", "tr", -1), r.push("thead_close", "thead", -1);
  let Q, ie = 0;
  for (f = i + 2; f < l && !(r.sCount[f] < r.blkIndent); f++) {
    let te = false;
    for (let J = 0, Se = A.length; J < Se; J++) if (A[J](r, f, l, true)) {
      te = true;
      break;
    }
    if (te || (C = Jm(r, f).trim(), !C) || r.sCount[f] - r.blkIndent >= 4 || (T = sy(C), T.length && T[0] === "" && T.shift(), T.length && T[T.length - 1] === "" && T.pop(), ie += z - T.length, ie > sE)) break;
    if (f === i + 2) {
      const J = r.push("tbody_open", "tbody", 1);
      J.map = Q = [i + 2, 0];
    }
    const re = r.push("tr_open", "tr", 1);
    re.map = [f, f + 1];
    for (let J = 0; J < z; J++) {
      const Se = r.push("td_open", "td", 1);
      M[J] && (Se.attrs = [["style", "text-align:" + M[J]]]);
      const fe = r.push("inline", "", 0);
      fe.content = T[J] ? T[J].trim() : "", fe.children = [], r.push("td_close", "td", -1);
    }
    r.push("tr_close", "tr", -1);
  }
  return Q && (r.push("tbody_close", "tbody", -1), Q[1] = f), r.push("table_close", "table", -1), U[1] = f, r.parentType = L, r.line = f, true;
}
function uE(r, i, l) {
  if (r.sCount[i] - r.blkIndent < 4) return false;
  let d = i + 1, f = d;
  for (; d < l; ) {
    if (r.isEmpty(d)) {
      d++;
      continue;
    }
    if (r.sCount[d] - r.blkIndent >= 4) {
      d++, f = d;
      continue;
    }
    break;
  }
  r.line = f;
  const g = r.push("code_block", "code", 0);
  return g.content = r.getLines(i, f, 4 + r.blkIndent, false) + `
`, g.map = [i, r.line], true;
}
function cE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || f + 3 > g) return false;
  const m = r.src.charCodeAt(f);
  if (m !== 126 && m !== 96) return false;
  let s = f;
  f = r.skipChars(f, m);
  let C = f - s;
  if (C < 3) return false;
  const T = r.src.slice(s, f), M = r.src.slice(f, g);
  if (m === 96 && M.indexOf(String.fromCharCode(m)) >= 0) return false;
  if (d) return true;
  let z = i, L = false;
  for (; z++, !(z >= l || (f = s = r.bMarks[z] + r.tShift[z], g = r.eMarks[z], f < g && r.sCount[z] < r.blkIndent)); ) if (r.src.charCodeAt(f) === m && !(r.sCount[z] - r.blkIndent >= 4) && (f = r.skipChars(f, m), !(f - s < C) && (f = r.skipSpaces(f), !(f < g)))) {
    L = true;
    break;
  }
  C = r.sCount[i], r.line = z + (L ? 1 : 0);
  const A = r.push("fence", "code", 0);
  return A.info = M, A.content = r.getLines(i + 1, z, C, true), A.markup = T, A.map = [i, r.line], true;
}
function dE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  const m = r.lineMax;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 62) return false;
  if (d) return true;
  const s = [], C = [], T = [], M = [], z = r.md.block.ruler.getRules("blockquote"), L = r.parentType;
  r.parentType = "blockquote";
  let A = false, O;
  for (O = i; O < l; O++) {
    const ie = r.sCount[O] < r.blkIndent;
    if (f = r.bMarks[O] + r.tShift[O], g = r.eMarks[O], f >= g) break;
    if (r.src.charCodeAt(f++) === 62 && !ie) {
      let re = r.sCount[O] + 1, J, Se;
      r.src.charCodeAt(f) === 32 ? (f++, re++, Se = false, J = true) : r.src.charCodeAt(f) === 9 ? (J = true, (r.bsCount[O] + re) % 4 === 3 ? (f++, re++, Se = false) : Se = true) : J = false;
      let fe = re;
      for (s.push(r.bMarks[O]), r.bMarks[O] = f; f < g; ) {
        const oe = r.src.charCodeAt(f);
        if (mi(oe)) oe === 9 ? fe += 4 - (fe + r.bsCount[O] + (Se ? 1 : 0)) % 4 : fe++;
        else break;
        f++;
      }
      A = f >= g, C.push(r.bsCount[O]), r.bsCount[O] = r.sCount[O] + 1 + (J ? 1 : 0), T.push(r.sCount[O]), r.sCount[O] = fe - re, M.push(r.tShift[O]), r.tShift[O] = f - r.bMarks[O];
      continue;
    }
    if (A) break;
    let te = false;
    for (let re = 0, J = z.length; re < J; re++) if (z[re](r, O, l, true)) {
      te = true;
      break;
    }
    if (te) {
      r.lineMax = O, r.blkIndent !== 0 && (s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), T.push(r.sCount[O]), r.sCount[O] -= r.blkIndent);
      break;
    }
    s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), T.push(r.sCount[O]), r.sCount[O] = -1;
  }
  const U = r.blkIndent;
  r.blkIndent = 0;
  const X = r.push("blockquote_open", "blockquote", 1);
  X.markup = ">";
  const H = [i, 0];
  X.map = H, r.md.block.tokenize(r, i, O);
  const Q = r.push("blockquote_close", "blockquote", -1);
  Q.markup = ">", r.lineMax = m, r.parentType = L, H[1] = r.line;
  for (let ie = 0; ie < M.length; ie++) r.bMarks[ie + i] = s[ie], r.tShift[ie + i] = M[ie], r.sCount[ie + i] = T[ie], r.bsCount[ie + i] = C[ie];
  return r.blkIndent = U, true;
}
function hE(r, i, l, d) {
  const f = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let g = r.bMarks[i] + r.tShift[i];
  const m = r.src.charCodeAt(g++);
  if (m !== 42 && m !== 45 && m !== 95) return false;
  let s = 1;
  for (; g < f; ) {
    const T = r.src.charCodeAt(g++);
    if (T !== m && !mi(T)) return false;
    T === m && s++;
  }
  if (s < 3) return false;
  if (d) return true;
  r.line = i + 1;
  const C = r.push("hr", "hr", 0);
  return C.map = [i, r.line], C.markup = Array(s + 1).join(String.fromCharCode(m)), true;
}
function ly(r, i) {
  const l = r.eMarks[i];
  let d = r.bMarks[i] + r.tShift[i];
  const f = r.src.charCodeAt(d++);
  if (f !== 42 && f !== 45 && f !== 43) return -1;
  if (d < l) {
    const g = r.src.charCodeAt(d);
    if (!mi(g)) return -1;
  }
  return d;
}
function uy(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  let f = l;
  if (f + 1 >= d) return -1;
  let g = r.src.charCodeAt(f++);
  if (g < 48 || g > 57) return -1;
  for (; ; ) {
    if (f >= d) return -1;
    if (g = r.src.charCodeAt(f++), g >= 48 && g <= 57) {
      if (f - l >= 10) return -1;
      continue;
    }
    if (g === 41 || g === 46) break;
    return -1;
  }
  return f < d && (g = r.src.charCodeAt(f), !mi(g)) ? -1 : f;
}
function fE(r, i) {
  const l = r.level + 2;
  for (let d = i + 2, f = r.tokens.length - 2; d < f; d++) r.tokens[d].level === l && r.tokens[d].type === "paragraph_open" && (r.tokens[d + 2].hidden = true, r.tokens[d].hidden = true, d += 2);
}
function pE(r, i, l, d) {
  let f, g, m, s, C = i, T = true;
  if (r.sCount[C] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[C] - r.listIndent >= 4 && r.sCount[C] < r.blkIndent) return false;
  let M = false;
  d && r.parentType === "paragraph" && r.sCount[C] >= r.blkIndent && (M = true);
  let z, L, A;
  if ((A = uy(r, C)) >= 0) {
    if (z = true, m = r.bMarks[C] + r.tShift[C], L = Number(r.src.slice(m, A - 1)), M && L !== 1) return false;
  } else if ((A = ly(r, C)) >= 0) z = false;
  else return false;
  if (M && r.skipSpaces(A) >= r.eMarks[C]) return false;
  if (d) return true;
  const O = r.src.charCodeAt(A - 1), U = r.tokens.length;
  z ? (s = r.push("ordered_list_open", "ol", 1), L !== 1 && (s.attrs = [["start", L]])) : s = r.push("bullet_list_open", "ul", 1);
  const X = [C, 0];
  s.map = X, s.markup = String.fromCharCode(O);
  let H = false;
  const Q = r.md.block.ruler.getRules("list"), ie = r.parentType;
  for (r.parentType = "list"; C < l; ) {
    g = A, f = r.eMarks[C];
    const te = r.sCount[C] + A - (r.bMarks[C] + r.tShift[C]);
    let re = te;
    for (; g < f; ) {
      const lt = r.src.charCodeAt(g);
      if (lt === 9) re += 4 - (re + r.bsCount[C]) % 4;
      else if (lt === 32) re++;
      else break;
      g++;
    }
    const J = g;
    let Se;
    J >= f ? Se = 1 : Se = re - te, Se > 4 && (Se = 1);
    const fe = te + Se;
    s = r.push("list_item_open", "li", 1), s.markup = String.fromCharCode(O);
    const oe = [C, 0];
    s.map = oe, z && (s.info = r.src.slice(m, A - 1));
    const de = r.tight, xe = r.tShift[C], $e = r.sCount[C], Ve = r.listIndent;
    if (r.listIndent = r.blkIndent, r.blkIndent = fe, r.tight = true, r.tShift[C] = J - r.bMarks[C], r.sCount[C] = re, J >= f && r.isEmpty(C + 1) ? r.line = Math.min(r.line + 2, l) : r.md.block.tokenize(r, C, l, true), (!r.tight || H) && (T = false), H = r.line - C > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = Ve, r.tShift[C] = xe, r.sCount[C] = $e, r.tight = de, s = r.push("list_item_close", "li", -1), s.markup = String.fromCharCode(O), C = r.line, oe[1] = C, C >= l || r.sCount[C] < r.blkIndent || r.sCount[C] - r.blkIndent >= 4) break;
    let Ke = false;
    for (let lt = 0, vt = Q.length; lt < vt; lt++) if (Q[lt](r, C, l, true)) {
      Ke = true;
      break;
    }
    if (Ke) break;
    if (z) {
      if (A = uy(r, C), A < 0) break;
      m = r.bMarks[C] + r.tShift[C];
    } else if (A = ly(r, C), A < 0) break;
    if (O !== r.src.charCodeAt(A - 1)) break;
  }
  return z ? s = r.push("ordered_list_close", "ol", -1) : s = r.push("bullet_list_close", "ul", -1), s.markup = String.fromCharCode(O), X[1] = C, r.line = C, r.parentType = ie, T && fE(r, U), true;
}
function mE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i], m = i + 1;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 91) return false;
  function s(Q) {
    const ie = r.lineMax;
    if (Q >= ie || r.isEmpty(Q)) return null;
    let te = false;
    if (r.sCount[Q] - r.blkIndent > 3 && (te = true), r.sCount[Q] < 0 && (te = true), !te) {
      const Se = r.md.block.ruler.getRules("reference"), fe = r.parentType;
      r.parentType = "reference";
      let oe = false;
      for (let de = 0, xe = Se.length; de < xe; de++) if (Se[de](r, Q, ie, true)) {
        oe = true;
        break;
      }
      if (r.parentType = fe, oe) return null;
    }
    const re = r.bMarks[Q] + r.tShift[Q], J = r.eMarks[Q];
    return r.src.slice(re, J + 1);
  }
  let C = r.src.slice(f, g + 1);
  g = C.length;
  let T = -1;
  for (f = 1; f < g; f++) {
    const Q = C.charCodeAt(f);
    if (Q === 91) return false;
    if (Q === 93) {
      T = f;
      break;
    } else if (Q === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (Q === 92 && (f++, f < g && C.charCodeAt(f) === 10)) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    }
  }
  if (T < 0 || C.charCodeAt(T + 1) !== 58) return false;
  for (f = T + 2; f < g; f++) {
    const Q = C.charCodeAt(f);
    if (Q === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!mi(Q)) break;
  }
  const M = r.md.helpers.parseLinkDestination(C, f, g);
  if (!M.ok) return false;
  const z = r.md.normalizeLink(M.str);
  if (!r.md.validateLink(z)) return false;
  f = M.pos;
  const L = f, A = m, O = f;
  for (; f < g; f++) {
    const Q = C.charCodeAt(f);
    if (Q === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!mi(Q)) break;
  }
  let U = r.md.helpers.parseLinkTitle(C, f, g);
  for (; U.can_continue; ) {
    const Q = s(m);
    if (Q === null) break;
    C += Q, f = g, g = C.length, m++, U = r.md.helpers.parseLinkTitle(C, f, g, U);
  }
  let X;
  for (f < g && O !== f && U.ok ? (X = U.str, f = U.pos) : (X = "", f = L, m = A); f < g; ) {
    const Q = C.charCodeAt(f);
    if (!mi(Q)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10 && X) for (X = "", f = L, m = A; f < g; ) {
    const Q = C.charCodeAt(f);
    if (!mi(Q)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10) return false;
  const H = hp(C.slice(1, T));
  return H ? (d || (typeof r.env.references > "u" && (r.env.references = {}), typeof r.env.references[H] > "u" && (r.env.references[H] = { title: X, href: z }), r.line = m), true) : false;
}
const gE = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], vE = "[a-zA-Z_:][a-zA-Z0-9:._-]*", _E = "[^\"'=<>`\\x00-\\x20]+", yE = "'[^']*'", bE = '"[^"]*"', xE = "(?:" + _E + "|" + yE + "|" + bE + ")", wE = "(?:\\s+" + vE + "(?:\\s*=\\s*" + xE + ")?)", k1 = "<[A-Za-z][A-Za-z0-9\\-]*" + wE + "*\\s*\\/?>", P1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", CE = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", SE = "<[?][\\s\\S]*?[?]>", kE = "<![A-Za-z][^>]*>", PE = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", TE = new RegExp("^(?:" + k1 + "|" + P1 + "|" + CE + "|" + SE + "|" + kE + "|" + PE + ")"), IE = new RegExp("^(?:" + k1 + "|" + P1 + ")"), qu = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + gE.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(IE.source + "\\s*$"), /^$/, false]];
function ME(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || !r.md.options.html || r.src.charCodeAt(f) !== 60) return false;
  let m = r.src.slice(f, g), s = 0;
  for (; s < qu.length && !qu[s][0].test(m); s++) ;
  if (s === qu.length) return false;
  if (d) return qu[s][2];
  let C = i + 1;
  if (!qu[s][1].test(m)) {
    for (; C < l && !(r.sCount[C] < r.blkIndent); C++) if (f = r.bMarks[C] + r.tShift[C], g = r.eMarks[C], m = r.src.slice(f, g), qu[s][1].test(m)) {
      m.length !== 0 && C++;
      break;
    }
  }
  r.line = C;
  const T = r.push("html_block", "", 0);
  return T.map = [i, C], T.content = r.getLines(i, C, r.blkIndent, true), true;
}
function EE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let m = r.src.charCodeAt(f);
  if (m !== 35 || f >= g) return false;
  let s = 1;
  for (m = r.src.charCodeAt(++f); m === 35 && f < g && s <= 6; ) s++, m = r.src.charCodeAt(++f);
  if (s > 6 || f < g && !mi(m)) return false;
  if (d) return true;
  g = r.skipSpacesBack(g, f);
  const C = r.skipCharsBack(g, 35, f);
  C > f && mi(r.src.charCodeAt(C - 1)) && (g = C), r.line = i + 1;
  const T = r.push("heading_open", "h" + String(s), 1);
  T.markup = "########".slice(0, s), T.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = r.src.slice(f, g).trim(), M.map = [i, r.line], M.children = [];
  const z = r.push("heading_close", "h" + String(s), -1);
  return z.markup = "########".slice(0, s), true;
}
function RE(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph");
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  const f = r.parentType;
  r.parentType = "paragraph";
  let g = 0, m, s = i + 1;
  for (; s < l && !r.isEmpty(s); s++) {
    if (r.sCount[s] - r.blkIndent > 3) continue;
    if (r.sCount[s] >= r.blkIndent) {
      let A = r.bMarks[s] + r.tShift[s];
      const O = r.eMarks[s];
      if (A < O && (m = r.src.charCodeAt(A), (m === 45 || m === 61) && (A = r.skipChars(A, m), A = r.skipSpaces(A), A >= O))) {
        g = m === 61 ? 1 : 2;
        break;
      }
    }
    if (r.sCount[s] < 0) continue;
    let L = false;
    for (let A = 0, O = d.length; A < O; A++) if (d[A](r, s, l, true)) {
      L = true;
      break;
    }
    if (L) break;
  }
  if (!g) return false;
  const C = r.getLines(i, s, r.blkIndent, false).trim();
  r.line = s + 1;
  const T = r.push("heading_open", "h" + String(g), 1);
  T.markup = String.fromCharCode(m), T.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = C, M.map = [i, r.line - 1], M.children = [];
  const z = r.push("heading_close", "h" + String(g), -1);
  return z.markup = String.fromCharCode(m), r.parentType = f, true;
}
function AE(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph"), f = r.parentType;
  let g = i + 1;
  for (r.parentType = "paragraph"; g < l && !r.isEmpty(g); g++) {
    if (r.sCount[g] - r.blkIndent > 3 || r.sCount[g] < 0) continue;
    let T = false;
    for (let M = 0, z = d.length; M < z; M++) if (d[M](r, g, l, true)) {
      T = true;
      break;
    }
    if (T) break;
  }
  const m = r.getLines(i, g, r.blkIndent, false).trim();
  r.line = g;
  const s = r.push("paragraph_open", "p", 1);
  s.map = [i, r.line];
  const C = r.push("inline", "", 0);
  return C.content = m, C.map = [i, r.line], C.children = [], r.push("paragraph_close", "p", -1), r.parentType = f, true;
}
const Mf = [["table", lE, ["paragraph", "reference"]], ["code", uE], ["fence", cE, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", dE, ["paragraph", "reference", "blockquote", "list"]], ["hr", hE, ["paragraph", "reference", "blockquote", "list"]], ["list", pE, ["paragraph", "reference", "blockquote"]], ["reference", mE], ["html_block", ME, ["paragraph", "reference", "blockquote"]], ["heading", EE, ["paragraph", "reference", "blockquote"]], ["lheading", RE], ["paragraph", AE]];
function fp() {
  this.ruler = new Yn();
  for (let r = 0; r < Mf.length; r++) this.ruler.push(Mf[r][0], Mf[r][1], { alt: (Mf[r][2] || []).slice() });
}
fp.prototype.tokenize = function(r, i, l) {
  const d = this.ruler.getRules(""), f = d.length, g = r.md.options.maxNesting;
  let m = i, s = false;
  for (; m < l && (r.line = m = r.skipEmptyLines(m), !(m >= l || r.sCount[m] < r.blkIndent)); ) {
    if (r.level >= g) {
      r.line = l;
      break;
    }
    const C = r.line;
    let T = false;
    for (let M = 0; M < f; M++) if (T = d[M](r, m, l, false), T) {
      if (C >= r.line) throw new Error("block rule didn't increment state.line");
      break;
    }
    if (!T) throw new Error("none of the block rules matched");
    r.tight = !s, r.isEmpty(r.line - 1) && (s = true), m = r.line, m < l && r.isEmpty(m) && (s = true, m++, r.line = m);
  }
};
fp.prototype.parse = function(r, i, l, d) {
  if (!r) return;
  const f = new this.State(r, i, l, d);
  this.tokenize(f, f.line, f.lineMax);
};
fp.prototype.State = xa;
function ih(r, i, l, d) {
  this.src = r, this.env = l, this.md = i, this.tokens = d, this.tokens_meta = Array(d.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
ih.prototype.pushPending = function() {
  const r = new Jo("text", "", 0);
  return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
};
ih.prototype.push = function(r, i, l) {
  this.pending && this.pushPending();
  const d = new Jo(r, i, l);
  let f = null;
  return l < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), d.level = this.level, l > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], f = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(d), this.tokens_meta.push(f), d;
};
ih.prototype.scanDelims = function(r, i) {
  const l = this.posMax, d = this.src.charCodeAt(r), f = r > 0 ? this.src.charCodeAt(r - 1) : 32;
  let g = r;
  for (; g < l && this.src.charCodeAt(g) === d; ) g++;
  const m = g - r, s = g < l ? this.src.charCodeAt(g) : 32, C = Wd(f) || qd(String.fromCharCode(f)), T = Wd(s) || qd(String.fromCharCode(s)), M = Gd(f), z = Gd(s), L = !z && (!T || M || C), A = !M && (!C || z || T);
  return { can_open: L && (i || !A || C), can_close: A && (i || !L || T), length: m };
};
ih.prototype.Token = Jo;
function DE(r) {
  switch (r) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function zE(r, i) {
  let l = r.pos;
  for (; l < r.posMax && !DE(r.src.charCodeAt(l)); ) l++;
  return l === r.pos ? false : (i || (r.pending += r.src.slice(r.pos, l)), r.pos = l, true);
}
const FE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function LE(r, i) {
  if (!r.md.options.linkify || r.linkLevel > 0) return false;
  const l = r.pos, d = r.posMax;
  if (l + 3 > d || r.src.charCodeAt(l) !== 58 || r.src.charCodeAt(l + 1) !== 47 || r.src.charCodeAt(l + 2) !== 47) return false;
  const f = r.pending.match(FE);
  if (!f) return false;
  const g = f[1], m = r.md.linkify.matchAtStart(r.src.slice(l - g.length));
  if (!m) return false;
  let s = m.url;
  if (s.length <= g.length) return false;
  s = s.replace(/\*+$/, "");
  const C = r.md.normalizeLink(s);
  if (!r.md.validateLink(C)) return false;
  if (!i) {
    r.pending = r.pending.slice(0, -g.length);
    const T = r.push("link_open", "a", 1);
    T.attrs = [["href", C]], T.markup = "linkify", T.info = "auto";
    const M = r.push("text", "", 0);
    M.content = r.md.normalizeLinkText(s);
    const z = r.push("link_close", "a", -1);
    z.markup = "linkify", z.info = "auto";
  }
  return r.pos += s.length - g.length, true;
}
function BE(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 10) return false;
  const d = r.pending.length - 1, f = r.posMax;
  if (!i) if (d >= 0 && r.pending.charCodeAt(d) === 32) if (d >= 1 && r.pending.charCodeAt(d - 1) === 32) {
    let g = d - 1;
    for (; g >= 1 && r.pending.charCodeAt(g - 1) === 32; ) g--;
    r.pending = r.pending.slice(0, g), r.push("hardbreak", "br", 0);
  } else r.pending = r.pending.slice(0, -1), r.push("softbreak", "br", 0);
  else r.push("softbreak", "br", 0);
  for (l++; l < f && mi(r.src.charCodeAt(l)); ) l++;
  return r.pos = l, true;
}
const o0 = [];
for (let r = 0; r < 256; r++) o0.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
  o0[r.charCodeAt(0)] = 1;
});
function OE(r, i) {
  let l = r.pos;
  const d = r.posMax;
  if (r.src.charCodeAt(l) !== 92 || (l++, l >= d)) return false;
  let f = r.src.charCodeAt(l);
  if (f === 10) {
    for (i || r.push("hardbreak", "br", 0), l++; l < d && (f = r.src.charCodeAt(l), !!mi(f)); ) l++;
    return r.pos = l, true;
  }
  let g = r.src[l];
  if (f >= 55296 && f <= 56319 && l + 1 < d) {
    const s = r.src.charCodeAt(l + 1);
    s >= 56320 && s <= 57343 && (g += r.src[l + 1], l++);
  }
  const m = "\\" + g;
  if (!i) {
    const s = r.push("text_special", "", 0);
    f < 256 && o0[f] !== 0 ? s.content = g : s.content = m, s.markup = m, s.info = "escape";
  }
  return r.pos = l + 1, true;
}
function $E(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 96) return false;
  const f = l;
  l++;
  const g = r.posMax;
  for (; l < g && r.src.charCodeAt(l) === 96; ) l++;
  const m = r.src.slice(f, l), s = m.length;
  if (r.backticksScanned && (r.backticks[s] || 0) <= f) return i || (r.pending += m), r.pos += s, true;
  let C = l, T;
  for (; (T = r.src.indexOf("`", C)) !== -1; ) {
    for (C = T + 1; C < g && r.src.charCodeAt(C) === 96; ) C++;
    const M = C - T;
    if (M === s) {
      if (!i) {
        const z = r.push("code_inline", "code", 0);
        z.markup = m, z.content = r.src.slice(l, T).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return r.pos = C, true;
    }
    r.backticks[M] = T;
  }
  return r.backticksScanned = true, i || (r.pending += m), r.pos += s, true;
}
function jE(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 126) return false;
  const f = r.scanDelims(r.pos, true);
  let g = f.length;
  const m = String.fromCharCode(d);
  if (g < 2) return false;
  let s;
  g % 2 && (s = r.push("text", "", 0), s.content = m, g--);
  for (let C = 0; C < g; C += 2) s = r.push("text", "", 0), s.content = m + m, r.delimiters.push({ marker: d, length: 0, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  return r.pos += f.length, true;
}
function cy(r, i) {
  let l;
  const d = [], f = i.length;
  for (let g = 0; g < f; g++) {
    const m = i[g];
    if (m.marker !== 126 || m.end === -1) continue;
    const s = i[m.end];
    l = r.tokens[m.token], l.type = "s_open", l.tag = "s", l.nesting = 1, l.markup = "~~", l.content = "", l = r.tokens[s.token], l.type = "s_close", l.tag = "s", l.nesting = -1, l.markup = "~~", l.content = "", r.tokens[s.token - 1].type === "text" && r.tokens[s.token - 1].content === "~" && d.push(s.token - 1);
  }
  for (; d.length; ) {
    const g = d.pop();
    let m = g + 1;
    for (; m < r.tokens.length && r.tokens[m].type === "s_close"; ) m++;
    m--, g !== m && (l = r.tokens[m], r.tokens[m] = r.tokens[g], r.tokens[g] = l);
  }
}
function NE(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  cy(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && cy(r, i[d].delimiters);
}
const T1 = { tokenize: jE, postProcess: NE };
function VE(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 95 && d !== 42) return false;
  const f = r.scanDelims(r.pos, d === 42);
  for (let g = 0; g < f.length; g++) {
    const m = r.push("text", "", 0);
    m.content = String.fromCharCode(d), r.delimiters.push({ marker: d, length: f.length, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  }
  return r.pos += f.length, true;
}
function dy(r, i) {
  const l = i.length;
  for (let d = l - 1; d >= 0; d--) {
    const f = i[d];
    if (f.marker !== 95 && f.marker !== 42 || f.end === -1) continue;
    const g = i[f.end], m = d > 0 && i[d - 1].end === f.end + 1 && i[d - 1].marker === f.marker && i[d - 1].token === f.token - 1 && i[f.end + 1].token === g.token + 1, s = String.fromCharCode(f.marker), C = r.tokens[f.token];
    C.type = m ? "strong_open" : "em_open", C.tag = m ? "strong" : "em", C.nesting = 1, C.markup = m ? s + s : s, C.content = "";
    const T = r.tokens[g.token];
    T.type = m ? "strong_close" : "em_close", T.tag = m ? "strong" : "em", T.nesting = -1, T.markup = m ? s + s : s, T.content = "", m && (r.tokens[i[d - 1].token].content = "", r.tokens[i[f.end + 1].token].content = "", d--);
  }
}
function UE(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  dy(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && dy(r, i[d].delimiters);
}
const I1 = { tokenize: VE, postProcess: UE };
function GE(r, i) {
  let l, d, f, g, m = "", s = "", C = r.pos, T = true;
  if (r.src.charCodeAt(r.pos) !== 91) return false;
  const M = r.pos, z = r.posMax, L = r.pos + 1, A = r.md.helpers.parseLinkLabel(r, r.pos, true);
  if (A < 0) return false;
  let O = A + 1;
  if (O < z && r.src.charCodeAt(O) === 40) {
    for (T = false, O++; O < z && (l = r.src.charCodeAt(O), !(!mi(l) && l !== 10)); O++) ;
    if (O >= z) return false;
    if (C = O, f = r.md.helpers.parseLinkDestination(r.src, O, r.posMax), f.ok) {
      for (m = r.md.normalizeLink(f.str), r.md.validateLink(m) ? O = f.pos : m = "", C = O; O < z && (l = r.src.charCodeAt(O), !(!mi(l) && l !== 10)); O++) ;
      if (f = r.md.helpers.parseLinkTitle(r.src, O, r.posMax), O < z && C !== O && f.ok) for (s = f.str, O = f.pos; O < z && (l = r.src.charCodeAt(O), !(!mi(l) && l !== 10)); O++) ;
    }
    (O >= z || r.src.charCodeAt(O) !== 41) && (T = true), O++;
  }
  if (T) {
    if (typeof r.env.references > "u") return false;
    if (O < z && r.src.charCodeAt(O) === 91 ? (C = O + 1, O = r.md.helpers.parseLinkLabel(r, O), O >= 0 ? d = r.src.slice(C, O++) : O = A + 1) : O = A + 1, d || (d = r.src.slice(L, A)), g = r.env.references[hp(d)], !g) return r.pos = M, false;
    m = g.href, s = g.title;
  }
  if (!i) {
    r.pos = L, r.posMax = A;
    const U = r.push("link_open", "a", 1), X = [["href", m]];
    U.attrs = X, s && X.push(["title", s]), r.linkLevel++, r.md.inline.tokenize(r), r.linkLevel--, r.push("link_close", "a", -1);
  }
  return r.pos = O, r.posMax = z, true;
}
function qE(r, i) {
  let l, d, f, g, m, s, C, T, M = "";
  const z = r.pos, L = r.posMax;
  if (r.src.charCodeAt(r.pos) !== 33 || r.src.charCodeAt(r.pos + 1) !== 91) return false;
  const A = r.pos + 2, O = r.md.helpers.parseLinkLabel(r, r.pos + 1, false);
  if (O < 0) return false;
  if (g = O + 1, g < L && r.src.charCodeAt(g) === 40) {
    for (g++; g < L && (l = r.src.charCodeAt(g), !(!mi(l) && l !== 10)); g++) ;
    if (g >= L) return false;
    for (T = g, s = r.md.helpers.parseLinkDestination(r.src, g, r.posMax), s.ok && (M = r.md.normalizeLink(s.str), r.md.validateLink(M) ? g = s.pos : M = ""), T = g; g < L && (l = r.src.charCodeAt(g), !(!mi(l) && l !== 10)); g++) ;
    if (s = r.md.helpers.parseLinkTitle(r.src, g, r.posMax), g < L && T !== g && s.ok) for (C = s.str, g = s.pos; g < L && (l = r.src.charCodeAt(g), !(!mi(l) && l !== 10)); g++) ;
    else C = "";
    if (g >= L || r.src.charCodeAt(g) !== 41) return r.pos = z, false;
    g++;
  } else {
    if (typeof r.env.references > "u") return false;
    if (g < L && r.src.charCodeAt(g) === 91 ? (T = g + 1, g = r.md.helpers.parseLinkLabel(r, g), g >= 0 ? f = r.src.slice(T, g++) : g = O + 1) : g = O + 1, f || (f = r.src.slice(A, O)), m = r.env.references[hp(f)], !m) return r.pos = z, false;
    M = m.href, C = m.title;
  }
  if (!i) {
    d = r.src.slice(A, O);
    const U = [];
    r.md.inline.parse(d, r.md, r.env, U);
    const X = r.push("image", "img", 0), H = [["src", M], ["alt", ""]];
    X.attrs = H, X.children = U, X.content = d, C && H.push(["title", C]);
  }
  return r.pos = g, r.posMax = L, true;
}
const WE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, ZE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function HE(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 60) return false;
  const d = r.pos, f = r.posMax;
  for (; ; ) {
    if (++l >= f) return false;
    const m = r.src.charCodeAt(l);
    if (m === 60) return false;
    if (m === 62) break;
  }
  const g = r.src.slice(d + 1, l);
  if (ZE.test(g)) {
    const m = r.md.normalizeLink(g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const T = r.push("link_close", "a", -1);
      T.markup = "autolink", T.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  if (WE.test(g)) {
    const m = r.md.normalizeLink("mailto:" + g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const T = r.push("link_close", "a", -1);
      T.markup = "autolink", T.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  return false;
}
function XE(r) {
  return /^<a[>\s]/i.test(r);
}
function YE(r) {
  return /^<\/a\s*>/i.test(r);
}
function KE(r) {
  const i = r | 32;
  return i >= 97 && i <= 122;
}
function JE(r, i) {
  if (!r.md.options.html) return false;
  const l = r.posMax, d = r.pos;
  if (r.src.charCodeAt(d) !== 60 || d + 2 >= l) return false;
  const f = r.src.charCodeAt(d + 1);
  if (f !== 33 && f !== 63 && f !== 47 && !KE(f)) return false;
  const g = r.src.slice(d).match(TE);
  if (!g) return false;
  if (!i) {
    const m = r.push("html_inline", "", 0);
    m.content = g[0], XE(m.content) && r.linkLevel++, YE(m.content) && r.linkLevel--;
  }
  return r.pos += g[0].length, true;
}
const QE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, eR = /^&([a-z][a-z0-9]{1,31});/i;
function tR(r, i) {
  const l = r.pos, d = r.posMax;
  if (r.src.charCodeAt(l) !== 38 || l + 1 >= d) return false;
  if (r.src.charCodeAt(l + 1) === 35) {
    const g = r.src.slice(l).match(QE);
    if (g) {
      if (!i) {
        const m = g[1][0].toLowerCase() === "x" ? parseInt(g[1].slice(1), 16) : parseInt(g[1], 10), s = r.push("text_special", "", 0);
        s.content = i0(m) ? Zf(m) : Zf(65533), s.markup = g[0], s.info = "entity";
      }
      return r.pos += g[0].length, true;
    }
  } else {
    const g = r.src.slice(l).match(eR);
    if (g) {
      const m = b1(g[0]);
      if (m !== g[0]) {
        if (!i) {
          const s = r.push("text_special", "", 0);
          s.content = m, s.markup = g[0], s.info = "entity";
        }
        return r.pos += g[0].length, true;
      }
    }
  }
  return false;
}
function hy(r) {
  const i = {}, l = r.length;
  if (!l) return;
  let d = 0, f = -2;
  const g = [];
  for (let m = 0; m < l; m++) {
    const s = r[m];
    if (g.push(0), (r[d].marker !== s.marker || f !== s.token - 1) && (d = m), f = s.token, s.length = s.length || 0, !s.close) continue;
    i.hasOwnProperty(s.marker) || (i[s.marker] = [-1, -1, -1, -1, -1, -1]);
    const C = i[s.marker][(s.open ? 3 : 0) + s.length % 3];
    let T = d - g[d] - 1, M = T;
    for (; T > C; T -= g[T] + 1) {
      const z = r[T];
      if (z.marker === s.marker && z.open && z.end < 0) {
        let L = false;
        if ((z.close || s.open) && (z.length + s.length) % 3 === 0 && (z.length % 3 !== 0 || s.length % 3 !== 0) && (L = true), !L) {
          const A = T > 0 && !r[T - 1].open ? g[T - 1] + 1 : 0;
          g[m] = m - T + A, g[T] = A, s.open = false, z.end = m, z.close = false, M = -1, f = -2;
          break;
        }
      }
    }
    M !== -1 && (i[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = M);
  }
}
function rR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  hy(r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && hy(i[d].delimiters);
}
function iR(r) {
  let i, l, d = 0;
  const f = r.tokens, g = r.tokens.length;
  for (i = l = 0; i < g; i++) f[i].nesting < 0 && d--, f[i].level = d, f[i].nesting > 0 && d++, f[i].type === "text" && i + 1 < g && f[i + 1].type === "text" ? f[i + 1].content = f[i].content + f[i + 1].content : (i !== l && (f[l] = f[i]), l++);
  i !== l && (f.length = l);
}
const Qm = [["text", zE], ["linkify", LE], ["newline", BE], ["escape", OE], ["backticks", $E], ["strikethrough", T1.tokenize], ["emphasis", I1.tokenize], ["link", GE], ["image", qE], ["autolink", HE], ["html_inline", JE], ["entity", tR]], eg = [["balance_pairs", rR], ["strikethrough", T1.postProcess], ["emphasis", I1.postProcess], ["fragments_join", iR]];
function nh() {
  this.ruler = new Yn();
  for (let r = 0; r < Qm.length; r++) this.ruler.push(Qm[r][0], Qm[r][1]);
  this.ruler2 = new Yn();
  for (let r = 0; r < eg.length; r++) this.ruler2.push(eg[r][0], eg[r][1]);
}
nh.prototype.skipToken = function(r) {
  const i = r.pos, l = this.ruler.getRules(""), d = l.length, f = r.md.options.maxNesting, g = r.cache;
  if (typeof g[i] < "u") {
    r.pos = g[i];
    return;
  }
  let m = false;
  if (r.level < f) {
    for (let s = 0; s < d; s++) if (r.level++, m = l[s](r, true), r.level--, m) {
      if (i >= r.pos) throw new Error("inline rule didn't increment state.pos");
      break;
    }
  } else r.pos = r.posMax;
  m || r.pos++, g[i] = r.pos;
};
nh.prototype.tokenize = function(r) {
  const i = this.ruler.getRules(""), l = i.length, d = r.posMax, f = r.md.options.maxNesting;
  for (; r.pos < d; ) {
    const g = r.pos;
    let m = false;
    if (r.level < f) {
      for (let s = 0; s < l; s++) if (m = i[s](r, false), m) {
        if (g >= r.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    }
    if (m) {
      if (r.pos >= d) break;
      continue;
    }
    r.pending += r.src[r.pos++];
  }
  r.pending && r.pushPending();
};
nh.prototype.parse = function(r, i, l, d) {
  const f = new this.State(r, i, l, d);
  this.tokenize(f);
  const g = this.ruler2.getRules(""), m = g.length;
  for (let s = 0; s < m; s++) g[s](f);
};
nh.prototype.State = ih;
function nR(r) {
  const i = {};
  r = r || {}, i.src_Any = m1.source, i.src_Cc = g1.source, i.src_Z = _1.source, i.src_P = t0.source, i.src_ZPCc = [i.src_Z, i.src_P, i.src_Cc].join("|"), i.src_ZCc = [i.src_Z, i.src_Cc].join("|");
  const l = "[><\uFF5C]";
  return i.src_pseudo_letter = "(?:(?!" + l + "|" + i.src_ZPCc + ")" + i.src_Any + ")", i.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", i.src_auth = "(?:(?:(?!" + i.src_ZCc + "|[@/\\[\\]()]).)+@)?", i.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", i.src_host_terminator = "(?=$|" + l + "|" + i.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + i.src_ZPCc + "))", i.src_path = "(?:[/?#](?:(?!" + i.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + i.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + i.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + i.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + i.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + i.src_ZCc + "|[']).)+\\'|\\'(?=" + i.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + i.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + i.src_ZCc + "|$)|;(?!" + i.src_ZCc + "|$)|\\!+(?!" + i.src_ZCc + "|[!]|$)|\\?(?!" + i.src_ZCc + "|[?]|$))+|\\/)?", i.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', i.src_xn = "xn--[a-z0-9\\-]{1,59}", i.src_domain_root = "(?:" + i.src_xn + "|" + i.src_pseudo_letter + "{1,63})", i.src_domain = "(?:" + i.src_xn + "|(?:" + i.src_pseudo_letter + ")|(?:" + i.src_pseudo_letter + "(?:-|" + i.src_pseudo_letter + "){0,61}" + i.src_pseudo_letter + "))", i.src_host = "(?:(?:(?:(?:" + i.src_domain + ")\\.)*" + i.src_domain + "))", i.tpl_host_fuzzy = "(?:" + i.src_ip4 + "|(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%)))", i.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%))", i.src_host_strict = i.src_host + i.src_host_terminator, i.tpl_host_fuzzy_strict = i.tpl_host_fuzzy + i.src_host_terminator, i.src_host_port_strict = i.src_host + i.src_port + i.src_host_terminator, i.tpl_host_port_fuzzy_strict = i.tpl_host_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_port_no_ip_fuzzy_strict = i.tpl_host_no_ip_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + i.src_ZPCc + "|>|$))", i.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + i.src_ZCc + ")(" + i.src_email_name + "@" + i.tpl_host_fuzzy_strict + ")", i.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_fuzzy_strict + i.src_path + ")", i.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_no_ip_fuzzy_strict + i.src_path + ")", i;
}
function Ag(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    l && Object.keys(l).forEach(function(d) {
      r[d] = l[d];
    });
  }), r;
}
function pp(r) {
  return Object.prototype.toString.call(r);
}
function oR(r) {
  return pp(r) === "[object String]";
}
function aR(r) {
  return pp(r) === "[object Object]";
}
function sR(r) {
  return pp(r) === "[object RegExp]";
}
function fy(r) {
  return pp(r) === "[object Function]";
}
function lR(r) {
  return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const M1 = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
function uR(r) {
  return Object.keys(r || {}).reduce(function(i, l) {
    return i || M1.hasOwnProperty(l);
  }, false);
}
const cR = { "http:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.http || (l.re.http = new RegExp("^\\/\\/" + l.re.src_auth + l.re.src_host_port_strict + l.re.src_path, "i")), l.re.http.test(d) ? d.match(l.re.http)[0].length : 0;
} }, "https:": "http:", "ftp:": "http:", "//": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.no_http || (l.re.no_http = new RegExp("^" + l.re.src_auth + "(?:localhost|(?:(?:" + l.re.src_domain + ")\\.)+" + l.re.src_domain_root + ")" + l.re.src_port + l.re.src_host_terminator + l.re.src_path, "i")), l.re.no_http.test(d) ? i >= 3 && r[i - 3] === ":" || i >= 3 && r[i - 3] === "/" ? 0 : d.match(l.re.no_http)[0].length : 0;
} }, "mailto:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.mailto || (l.re.mailto = new RegExp("^" + l.re.src_email_name + "@" + l.re.src_host_strict, "i")), l.re.mailto.test(d) ? d.match(l.re.mailto)[0].length : 0;
} } }, dR = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", hR = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function fR(r) {
  r.__index__ = -1, r.__text_cache__ = "";
}
function pR(r) {
  return function(i, l) {
    const d = i.slice(l);
    return r.test(d) ? d.match(r)[0].length : 0;
  };
}
function py() {
  return function(r, i) {
    i.normalize(r);
  };
}
function Hf(r) {
  const i = r.re = nR(r.__opts__), l = r.__tlds__.slice();
  r.onCompile(), r.__tlds_replaced__ || l.push(dR), l.push(i.src_xn), i.src_tlds = l.join("|");
  function d(s) {
    return s.replace("%TLDS%", i.src_tlds);
  }
  i.email_fuzzy = RegExp(d(i.tpl_email_fuzzy), "i"), i.link_fuzzy = RegExp(d(i.tpl_link_fuzzy), "i"), i.link_no_ip_fuzzy = RegExp(d(i.tpl_link_no_ip_fuzzy), "i"), i.host_fuzzy_test = RegExp(d(i.tpl_host_fuzzy_test), "i");
  const f = [];
  r.__compiled__ = {};
  function g(s, C) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + C);
  }
  Object.keys(r.__schemas__).forEach(function(s) {
    const C = r.__schemas__[s];
    if (C === null) return;
    const T = { validate: null, link: null };
    if (r.__compiled__[s] = T, aR(C)) {
      sR(C.validate) ? T.validate = pR(C.validate) : fy(C.validate) ? T.validate = C.validate : g(s, C), fy(C.normalize) ? T.normalize = C.normalize : C.normalize ? g(s, C) : T.normalize = py();
      return;
    }
    if (oR(C)) {
      f.push(s);
      return;
    }
    g(s, C);
  }), f.forEach(function(s) {
    r.__compiled__[r.__schemas__[s]] && (r.__compiled__[s].validate = r.__compiled__[r.__schemas__[s]].validate, r.__compiled__[s].normalize = r.__compiled__[r.__schemas__[s]].normalize);
  }), r.__compiled__[""] = { validate: null, normalize: py() };
  const m = Object.keys(r.__compiled__).filter(function(s) {
    return s.length > 0 && r.__compiled__[s];
  }).map(lR).join("|");
  r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), fR(r);
}
function mR(r, i) {
  const l = r.__index__, d = r.__last_index__, f = r.__text_cache__.slice(l, d);
  this.schema = r.__schema__.toLowerCase(), this.index = l + i, this.lastIndex = d + i, this.raw = f, this.text = f, this.url = f;
}
function Dg(r, i) {
  const l = new mR(r, i);
  return r.__compiled__[l.schema].normalize(l, r), l;
}
function _o(r, i) {
  if (!(this instanceof _o)) return new _o(r, i);
  i || uR(r) && (i = r, r = {}), this.__opts__ = Ag({}, M1, i), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Ag({}, cR, r), this.__compiled__ = {}, this.__tlds__ = hR, this.__tlds_replaced__ = false, this.re = {}, Hf(this);
}
_o.prototype.add = function(i, l) {
  return this.__schemas__[i] = l, Hf(this), this;
};
_o.prototype.set = function(i) {
  return this.__opts__ = Ag(this.__opts__, i), this;
};
_o.prototype.test = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return false;
  let l, d, f, g, m, s, C, T, M;
  if (this.re.schema_test.test(i)) {
    for (C = this.re.schema_search, C.lastIndex = 0; (l = C.exec(i)) !== null; ) if (g = this.testSchemaAt(i, l[2], C.lastIndex), g) {
      this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + g;
      break;
    }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (T = i.search(this.re.host_fuzzy_test), T >= 0 && (this.__index__ < 0 || T < this.__index__) && (d = i.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (m = d.index + d[1].length, (this.__index__ < 0 || m < this.__index__) && (this.__schema__ = "", this.__index__ = m, this.__last_index__ = d.index + d[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (M = i.indexOf("@"), M >= 0 && (f = i.match(this.re.email_fuzzy)) !== null && (m = f.index + f[1].length, s = f.index + f[0].length, (this.__index__ < 0 || m < this.__index__ || m === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = m, this.__last_index__ = s))), this.__index__ >= 0;
};
_o.prototype.pretest = function(i) {
  return this.re.pretest.test(i);
};
_o.prototype.testSchemaAt = function(i, l, d) {
  return this.__compiled__[l.toLowerCase()] ? this.__compiled__[l.toLowerCase()].validate(i, d, this) : 0;
};
_o.prototype.match = function(i) {
  const l = [];
  let d = 0;
  this.__index__ >= 0 && this.__text_cache__ === i && (l.push(Dg(this, d)), d = this.__last_index__);
  let f = d ? i.slice(d) : i;
  for (; this.test(f); ) l.push(Dg(this, d)), f = f.slice(this.__last_index__), d += this.__last_index__;
  return l.length ? l : null;
};
_o.prototype.matchAtStart = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return null;
  const l = this.re.schema_at_start.exec(i);
  if (!l) return null;
  const d = this.testSchemaAt(i, l[2], l[0].length);
  return d ? (this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + d, Dg(this, 0)) : null;
};
_o.prototype.tlds = function(i, l) {
  return i = Array.isArray(i) ? i : [i], l ? (this.__tlds__ = this.__tlds__.concat(i).sort().filter(function(d, f, g) {
    return d !== g[f - 1];
  }).reverse(), Hf(this), this) : (this.__tlds__ = i.slice(), this.__tlds_replaced__ = true, Hf(this), this);
};
_o.prototype.normalize = function(i) {
  i.schema || (i.url = "http://" + i.url), i.schema === "mailto:" && !/^mailto:/i.test(i.url) && (i.url = "mailto:" + i.url);
};
_o.prototype.onCompile = function() {
};
const Xu = 2147483647, ma = 36, a0 = 1, Zd = 26, gR = 38, vR = 700, E1 = 72, R1 = 128, A1 = "-", _R = /^xn--/, yR = /[^\0-\x7F]/, bR = /[\x2E\u3002\uFF0E\uFF61]/g, xR = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, tg = ma - a0, ga = Math.floor, rg = String.fromCharCode;
function Cs(r) {
  throw new RangeError(xR[r]);
}
function wR(r, i) {
  const l = [];
  let d = r.length;
  for (; d--; ) l[d] = i(r[d]);
  return l;
}
function D1(r, i) {
  const l = r.split("@");
  let d = "";
  l.length > 1 && (d = l[0] + "@", r = l[1]), r = r.replace(bR, ".");
  const f = r.split("."), g = wR(f, i).join(".");
  return d + g;
}
function z1(r) {
  const i = [];
  let l = 0;
  const d = r.length;
  for (; l < d; ) {
    const f = r.charCodeAt(l++);
    if (f >= 55296 && f <= 56319 && l < d) {
      const g = r.charCodeAt(l++);
      (g & 64512) == 56320 ? i.push(((f & 1023) << 10) + (g & 1023) + 65536) : (i.push(f), l--);
    } else i.push(f);
  }
  return i;
}
const CR = (r) => String.fromCodePoint(...r), SR = function(r) {
  return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : ma;
}, my = function(r, i) {
  return r + 22 + 75 * (r < 26) - ((i != 0) << 5);
}, F1 = function(r, i, l) {
  let d = 0;
  for (r = l ? ga(r / vR) : r >> 1, r += ga(r / i); r > tg * Zd >> 1; d += ma) r = ga(r / tg);
  return ga(d + (tg + 1) * r / (r + gR));
}, L1 = function(r) {
  const i = [], l = r.length;
  let d = 0, f = R1, g = E1, m = r.lastIndexOf(A1);
  m < 0 && (m = 0);
  for (let s = 0; s < m; ++s) r.charCodeAt(s) >= 128 && Cs("not-basic"), i.push(r.charCodeAt(s));
  for (let s = m > 0 ? m + 1 : 0; s < l; ) {
    const C = d;
    for (let M = 1, z = ma; ; z += ma) {
      s >= l && Cs("invalid-input");
      const L = SR(r.charCodeAt(s++));
      L >= ma && Cs("invalid-input"), L > ga((Xu - d) / M) && Cs("overflow"), d += L * M;
      const A = z <= g ? a0 : z >= g + Zd ? Zd : z - g;
      if (L < A) break;
      const O = ma - A;
      M > ga(Xu / O) && Cs("overflow"), M *= O;
    }
    const T = i.length + 1;
    g = F1(d - C, T, C == 0), ga(d / T) > Xu - f && Cs("overflow"), f += ga(d / T), d %= T, i.splice(d++, 0, f);
  }
  return String.fromCodePoint(...i);
}, B1 = function(r) {
  const i = [];
  r = z1(r);
  const l = r.length;
  let d = R1, f = 0, g = E1;
  for (const C of r) C < 128 && i.push(rg(C));
  const m = i.length;
  let s = m;
  for (m && i.push(A1); s < l; ) {
    let C = Xu;
    for (const M of r) M >= d && M < C && (C = M);
    const T = s + 1;
    C - d > ga((Xu - f) / T) && Cs("overflow"), f += (C - d) * T, d = C;
    for (const M of r) if (M < d && ++f > Xu && Cs("overflow"), M === d) {
      let z = f;
      for (let L = ma; ; L += ma) {
        const A = L <= g ? a0 : L >= g + Zd ? Zd : L - g;
        if (z < A) break;
        const O = z - A, U = ma - A;
        i.push(rg(my(A + O % U, 0))), z = ga(O / U);
      }
      i.push(rg(my(z, 0))), g = F1(f, T, s === m), f = 0, ++s;
    }
    ++f, ++d;
  }
  return i.join("");
}, kR = function(r) {
  return D1(r, function(i) {
    return _R.test(i) ? L1(i.slice(4).toLowerCase()) : i;
  });
}, PR = function(r) {
  return D1(r, function(i) {
    return yR.test(i) ? "xn--" + B1(i) : i;
  });
}, O1 = { version: "2.3.1", ucs2: { decode: z1, encode: CR }, decode: L1, encode: B1, toASCII: PR, toUnicode: kR }, TR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, IR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, MR = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }, ER = { default: TR, zero: IR, commonmark: MR }, RR = /^(vbscript|javascript|file|data):/, AR = /^data:image\/(gif|png|jpeg|webp);/;
function DR(r) {
  const i = r.trim().toLowerCase();
  return RR.test(i) ? AR.test(i) : true;
}
const $1 = ["http:", "https:", "mailto:"];
function zR(r) {
  const i = e0(r, true);
  if (i.hostname && (!i.protocol || $1.indexOf(i.protocol) >= 0)) try {
    i.hostname = O1.toASCII(i.hostname);
  } catch {
  }
  return rh(Qg(i));
}
function FR(r) {
  const i = e0(r, true);
  if (i.hostname && (!i.protocol || $1.indexOf(i.protocol) >= 0)) try {
    i.hostname = O1.toUnicode(i.hostname);
  } catch {
  }
  return rc(Qg(i), rc.defaultChars + "%");
}
function Fo(r, i) {
  if (!(this instanceof Fo)) return new Fo(r, i);
  i || r0(r) || (i = r || {}, r = "default"), this.inline = new nh(), this.block = new fp(), this.core = new n0(), this.renderer = new uc(), this.linkify = new _o(), this.validateLink = DR, this.normalizeLink = zR, this.normalizeLinkText = FR, this.utils = BM, this.helpers = dp({}, NM), this.options = {}, this.configure(r), i && this.set(i);
}
Fo.prototype.set = function(r) {
  return dp(this.options, r), this;
};
Fo.prototype.configure = function(r) {
  const i = this;
  if (r0(r)) {
    const l = r;
    if (r = ER[l], !r) throw new Error('Wrong `markdown-it` preset "' + l + '", check name');
  }
  if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return r.options && i.set(r.options), r.components && Object.keys(r.components).forEach(function(l) {
    r.components[l].rules && i[l].ruler.enableOnly(r.components[l].rules), r.components[l].rules2 && i[l].ruler2.enableOnly(r.components[l].rules2);
  }), this;
};
Fo.prototype.enable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.enable(r, true));
  }, this), l = l.concat(this.inline.ruler2.enable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + d);
  return this;
};
Fo.prototype.disable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.disable(r, true));
  }, this), l = l.concat(this.inline.ruler2.disable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + d);
  return this;
};
Fo.prototype.use = function(r) {
  const i = [this].concat(Array.prototype.slice.call(arguments, 1));
  return r.apply(r, i), this;
};
Fo.prototype.parse = function(r, i) {
  if (typeof r != "string") throw new Error("Input data should be a String");
  const l = new this.core.State(r, this, i);
  return this.core.process(l), l.tokens;
};
Fo.prototype.render = function(r, i) {
  return i = i || {}, this.renderer.render(this.parse(r, i), this.options, i);
};
Fo.prototype.parseInline = function(r, i) {
  const l = new this.core.State(r, this, i);
  return l.inlineMode = true, this.core.process(l), l.tokens;
};
Fo.prototype.renderInline = function(r, i) {
  return i = i || {}, this.renderer.render(this.parseInline(r, i), this.options, i);
};
const gy = st((r) => {
  const i = Al(new Fo(r.options ?? {}));
  for (const d of r.plugins ?? []) i.value.use(d);
  const l = ze(() => i.value.render(r.source));
  return () => F("div", { innerHTML: l.value });
}, { props: ["source", "options", "plugins"] }), LR = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, BR = { class: "about-view" }, OR = { id: "project", class: "section project-section" }, $R = { class: "project-header" }, jR = { class: "project-description" }, NR = { id: "data-sources", class: "section data-sources" }, VR = ["href"], UR = { id: "credits", class: "section credits-section" }, GR = { class: "credit-content" }, qR = { key: 1 }, WR = { class: "license-text" }, ZR = { class: "credit-links" }, HR = ["href"], XR = ["href"], YR = { __name: "AboutView", setup(r) {
  nc((C) => ({ "1e81317d": `${s.value}px` }));
  const i = Fl(), { t: l } = zo(), d = Ae(false), f = () => {
    d.value = window.innerWidth >= 700;
  };
  Qi(() => {
    f(), window.addEventListener("resize", f);
  }), Zw(() => {
    window.removeEventListener("resize", f);
  });
  const g = Ae(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), m = (C) => C.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((T) => T.split(`
`).map((M) => M.trim()).join(" ")).join(`

`).trim(), s = Ae(20);
  return (C, T) => (St(), Xt("div", BR, [d.value ? (St(), Sr(ee(gb), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: Ge(() => [Ne(ee(Af), { title: ee(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), Ne(ee(Af), { title: ee(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), Ne(ee(Af), { title: ee(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : Kr("", true), It("section", OR, [Ne(ee(qa), null, { default: Ge(() => [It("div", $R, [Ne(ee(Lb), { width: "100", src: g.value, "preview-disabled": "" }, null, 8, ["src"]), Ne(ee(A5), null, { default: Ge(() => [...T[0] || (T[0] = [Pr("Trackmaker", -1)])]), _: 1 })]), It("p", jR, ir(ee(l)("aboutView.description")), 1), Ne(ee(a_), { class: "license-collapse" }, { default: Ge(() => [Ne(ee(s_), { title: "License", name: "license" }, { header: Ge(() => [Ne(ee(Cl), null, { default: Ge(() => [Ne(ee(xf), null, { default: Ge(() => [...T[1] || (T[1] = [Pr("License", -1)])]), _: 1 }), Ne(ee(Do), { type: "info", round: "", size: "small" }, { default: Ge(() => [...T[2] || (T[2] = [Pr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: Ge(() => [Ne(ee(gy), { source: ee(LR), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), It("section", NR, [Ne(ee(qa), null, { header: Ge(() => [Pr(ir(ee(l)("aboutView.sections.dataSource")), 1)]), footer: Ge(() => [Ne(ee(gy), { source: ee(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: Ge(() => [Ne(ee(lp), null, { default: Ge(() => [(St(true), Xt(qr, null, dn(ee(Hw), (M) => (St(), Sr(ee(up), { key: M.id }, { default: Ge(() => [Ne(ee(Cl), null, { default: Ge(() => [Ne(ee(xf), null, { default: Ge(() => [Pr(ir(M.name), 1)]), _: 2 }, 1024), M.license ? (St(), Sr(ee(Do), { key: 0, type: "info", round: "", size: "small" }, { default: Ge(() => [Pr(ir(M.license), 1)]), _: 2 }, 1024)) : Kr("", true)]), _: 2 }, 1024)]), suffix: Ge(() => [It("a", { href: M.url, class: "external-link" }, [Ne(ee(ki), { size: s.value, color: ee(i).textColor1 }, { default: Ge(() => [Ne(ee(Qv))]), _: 1 }, 8, ["size", "color"])], 8, VR)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), It("section", UR, [Ne(ee(qa), { hoverable: "" }, { header: Ge(() => [Pr(ir(ee(l)("aboutView.sections.credits")), 1)]), default: Ge(() => [Ne(ee(xf), null, { default: Ge(() => [Pr(ir(ee(l)("aboutView.creditIntro")), 1)]), _: 1 }), Ne(ee(a_), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: Ge(() => [(St(true), Xt(qr, null, dn(ee(Xw).sort((M, z) => M.name.localeCompare(z.name)), (M) => (St(), Sr(ee(s_), { key: M.id, title: M.name, name: M.id }, { header: Ge(() => [Ne(ee(Cl), null, { default: Ge(() => [Pr(ir(M.name) + " ", 1), M.licenseType.trim() ? (St(), Sr(ee(Cl), { key: 0 }, { default: Ge(() => [(St(true), Xt(qr, null, dn(M.licenseType.trim().split(",").map((z) => z.trim()), (z) => (St(), Sr(ee(Do), { key: z, round: "", type: "info", size: "small" }, { default: Ge(() => [Pr(ir(z), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : Kr("", true)]), _: 2 }, 1024)]), "header-extra": Ge(() => [It("div", ZR, [M.homepage ? (St(), Xt("a", { key: 0, href: M.homepage }, [Ne(ee(ki), { size: s.value, color: ee(i).textColor1 }, { default: Ge(() => [Ne(ee(Qv))]), _: 1 }, 8, ["size", "color"])], 8, HR)) : Kr("", true), M.url ? (St(), Xt("a", { key: 1, href: M.url }, [Ne(ee(ki), { size: s.value, color: ee(i).textColor1 }, { default: Ge(() => [M.url.includes("github") ? (St(), Sr(ee(a3), { key: 0 })) : (St(), Sr(ee(nb), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, XR)) : Kr("", true)])]), default: Ge(() => [It("div", GR, [It("p", null, ir(M.description), 1), M.license.trim() ? (St(), Sr(ee(MP), { key: 0 })) : Kr("", true), M.license ? (St(), Xt("div", qR, [Ne(ee(xf), null, { default: Ge(() => [...T[3] || (T[3] = [It("strong", null, "License:", -1)])]), _: 1 }), It("div", WR, [It("pre", null, ir(m(M.license)), 1)])])) : Kr("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, j1 = yo(YR, [["__scopeId", "data-v-e19031a0"]]), KR = Object.freeze(Object.defineProperty({ __proto__: null, default: j1 }, Symbol.toStringTag, { value: "Module" })), JR = { class: "settings-view" }, QR = { class: "settings-layout" }, eA = { class: "settings-content" }, tA = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, rA = { key: 0 }, iA = { key: 1 }, nA = { key: 2 }, oA = { key: 0, class: "settings-nav" }, aA = st({ __name: "SettingsView", setup(r) {
  const i = new Ng(), l = ze(() => i.isMobile), { width: d } = Gy(), f = ze(() => d.value < 800), g = ze(() => d.value < 680), { t: m, availableLocales: s } = zo(), C = fr("settings"), T = ze(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: m("settings.appearance.theme.options.light") }, { value: "dark", label: m("settings.appearance.theme.options.dark") }, { value: "system", label: m("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.interfaceLanguage.options.${M}`) })) }, { title: "mapLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.mapLanguage.options.${M}`) })).concat([{ value: "interface", label: m("settings.language.mapLanguage.options.interface") }]) }] }]);
  return Qi(() => {
    C.init();
  }), (M, z) => (St(), Xt("div", JR, [It("div", QR, [It("div", eA, [(St(true), Xt(qr, null, dn(T.value, (L) => (St(), Sr(ee(qa), { id: "appearance", key: L.title, title: M.$t(`settings.${L.title}.title`) }, { default: Ge(() => [Ne(ee(lp), null, { default: Ge(() => [(St(true), Xt(qr, null, dn(L.items, (A) => (St(), Sr(ee(up), { key: A.title }, { default: Ge(() => [It("div", tA, [Ne(ee(PP), { style: { "white-space": "nowrap" }, tooltip: { trigger: l.value ? "click" : "hover" } }, { tooltip: Ge(() => [Pr(ir(A.items ? M.$t(`settings.${L.title}.${A.title}.title`) : M.$t(`settings.${L.title}.${A.title}`)), 1)]), default: Ge(() => [Pr(ir(A.items ? M.$t(`settings.${L.title}.${A.title}.title`) : M.$t(`settings.${L.title}.${A.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), A.type === "radio" ? (St(), Xt("div", rA, [f.value ? (St(), Sr(ee(mg), { key: 1, value: ee(C).settings[A.title], "onUpdate:value": (O) => ee(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (St(), Sr(ee(SP), { key: 0, value: ee(C).settings[A.title], "onUpdate:value": (O) => ee(C).settings[A.title] = O }, { default: Ge(() => [(St(true), Xt(qr, null, dn(A.items, (O) => (St(), Sr(ee(bP), { key: O.value, value: O.value, label: O.label, checked: ee(C).settings[A.title] === O.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : A.type === "select" ? (St(), Xt("div", iA, [Ne(ee(mg), { value: ee(C).settings[A.title], "onUpdate:value": (O) => ee(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : A.type === "checkbox" ? (St(), Xt("div", nA, [Ne(ee(jb), { value: ee(C).settings[A.title], "onUpdate:value": (O) => ee(C).settings[A.title] = O }, null, 8, ["value", "onUpdate:value"])])) : Kr("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), g.value ? Kr("", true) : (St(), Xt("div", oA, [Ne(ee(gb), { "show-rail": true, style: { width: "128px" } }, { default: Ge(() => [(St(true), Xt(qr, null, dn(T.value, (L) => (St(), Sr(ee(Af), { key: L.title, title: M.$t(`settings.${L.title}.title`), href: `#${L.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), N1 = yo(aA, [["__scopeId", "data-v-eb834239"]]), sA = Object.freeze(Object.defineProperty({ __proto__: null, default: N1 }, Symbol.toStringTag, { value: "Module" })), hA = J2({ history: Q2("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: ff() ? f1 : () => hf(() => Promise.resolve().then(() => i4), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: ff() ? p1 : () => hf(() => Promise.resolve().then(() => Y4), void 0, import.meta.url) }, { path: "/about", name: "about", component: ff() ? j1 : () => hf(() => Promise.resolve().then(() => KR), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: ff() ? N1 : () => hf(() => Promise.resolve().then(() => sA), void 0, import.meta.url) }] });
export {
  hA as default
};
