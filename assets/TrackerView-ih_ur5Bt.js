import { d as q, c as oe, o as A, J as Ui, a as B, h as p, m as Wi, j as R, b as O, i as ge, t as X, B as Et, w as ai, T as Ai, F as Ie, p as Gi, I as Vi, L as Xi, q as Ae, M as xe, N as Ge, C as ce, y as j, s as $, v as k, z as _e, D as vt, A as le, _ as Xe, u as at, O as Hi, Q as Yi, n as ze, R as Ft, S as Ki, U as yt, V as qi, W as we, P as li, x as be, X as Ji, G as zt, k as Zi } from "./index-DSvGlfEm.js";
import { u as bt } from "./vue-i18n-X8X1EhHF.js";
import { E as Qi, A as eo, u as to, a as di, U as io, b as oo, T as ro, f as no, N as so, y as ao, L as lo, h as co, M as uo, C as ho, S as Nt, R as po, _ as go, V as fo } from "./sketch-store-1qWYR_A9.js";
import { m as mo } from "./index-CrzEBEnk.js";
import { E as Bt, W as Ot, I as Tt, S as Lt, B as he, e as ci, M as vo, v as yo } from "./text-VZIHOOUl.js";
import { I as lt, m as S, n as N, o as T, l as L, N as bo, J as ui, w as de, K as hi, u as He, q as ue, p as pi, L as xo, t as re, v as Ye, i as gi, M as Co, O as wo, P as Po, E as fi, C as mi, j as xt, G as Ne, Q as Pe, R as ko, S as So, F as Mo, T as dt, U as Ut, W as Io, H as _o } from "./light-DfzEfYBd.js";
import { f as Ct } from "./light-CNVlFFN8.js";
import { i as vi, N as yi, u as bi, d as Do } from "./light-D7aXBowW.js";
import { N as jt, i as Ro, b as Ue } from "./light-Cy1AeMog.js";
import { T as Eo, U as Fo, V as Bo, W as Oo, X as To, N as xi, R as Te, Q as Lo, S as Wt } from "./settings-store-CKhvurrf.js";
import { N as jo, D as $o, d as zo, a as No } from "./Image-DZFEhzXt.js";
import { u as ct } from "./use-theme-vars-BOeZxSBS.js";
import { t as ht } from "./use-locale-Dy4qq2qj.js";
import "./Suffix-BlDmlKJv.js";
import "./vue-router-D76nXCqn.js";
import "./Tooltip-DMQY7OZD.js";
import "./light-5CGb8Hbk.js";
function Uo(o, e, t) {
  return o === o && (t !== void 0 && (o = o <= t ? o : t), e !== void 0 && (o = o >= e ? o : e)), o;
}
function wt(o, e, t) {
  return t === void 0 && (t = e, e = void 0), t !== void 0 && (t = ht(t), t = t === t ? t : 0), e !== void 0 && (e = ht(e), e = e === e ? e : 0), Uo(ht(o), e, t);
}
const Wo = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ao = q({ name: "HandFinger", render: function(e, t) {
  return A(), oe("svg", Wo, t[0] || (t[0] = [Ui('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), Go = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Vo = q({ name: "Line", render: function(e, t) {
  return A(), oe("svg", Go, t[0] || (t[0] = [B("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [B("circle", { cx: "6", cy: "18", r: "2" }), B("circle", { cx: "18", cy: "6", r: "2" }), B("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), Xo = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ho = q({ name: "PlayerRecord", render: function(e, t) {
  return A(), oe("svg", Xo, t[0] || (t[0] = [B("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Yo = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ko = q({ name: "Square", render: function(e, t) {
  return A(), oe("svg", Yo, t[0] || (t[0] = [B("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), qo = lt("attach", () => p("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, p("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, p("g", { fill: "currentColor", "fill-rule": "nonzero" }, p("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), Jo = lt("cancel", () => p("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, p("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, p("g", { fill: "currentColor", "fill-rule": "nonzero" }, p("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), Zo = lt("retry", () => p("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, p("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), p("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), Qo = lt("trash", () => p("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, p("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), p("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), p("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), p("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), er = S("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [N("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), T("closable", [S("alert-body", [N("title", `
 padding-right: 24px;
 `)])]), N("icon", { color: "var(--n-icon-color)" }), S("alert-body", { padding: "var(--n-padding)" }, [N("title", { color: "var(--n-title-text-color)" }), N("content", { color: "var(--n-content-text-color)" })]), Ct({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), N("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), N("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), T("show-icon", [S("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), T("right-adjust", [S("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), S("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [N("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [L("& +", [N("content", { marginTop: "9px" })])]), N("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), N("icon", { transition: "color .3s var(--n-bezier)" })]), tr = Object.assign(Object.assign({}, ue.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), ir = q({ name: "Alert", inheritAttrs: false, props: tr, slots: Object, setup(o) {
  const { mergedClsPrefixRef: e, mergedBorderedRef: t, inlineThemeDisabled: i, mergedRtlRef: r } = He(o), n = ue("Alert", "-alert", er, Eo, o, e), s = pi("Alert", r, e), a = R(() => {
    const { common: { cubicBezierEaseInOut: g }, self: f } = n.value, { fontSize: v, borderRadius: w, titleFontWeight: I, lineHeight: P, iconSize: _, iconMargin: x, iconMarginRtl: y, closeIconSize: m, closeBorderRadius: C, closeSize: D, closeMargin: b, closeMarginRtl: M, padding: E } = f, { type: F } = o, { left: V, right: U } = xo(x);
    return { "--n-bezier": g, "--n-color": f[re("color", F)], "--n-close-icon-size": m, "--n-close-border-radius": C, "--n-close-color-hover": f[re("closeColorHover", F)], "--n-close-color-pressed": f[re("closeColorPressed", F)], "--n-close-icon-color": f[re("closeIconColor", F)], "--n-close-icon-color-hover": f[re("closeIconColorHover", F)], "--n-close-icon-color-pressed": f[re("closeIconColorPressed", F)], "--n-icon-color": f[re("iconColor", F)], "--n-border": f[re("border", F)], "--n-title-text-color": f[re("titleTextColor", F)], "--n-content-text-color": f[re("contentTextColor", F)], "--n-line-height": P, "--n-border-radius": w, "--n-font-size": v, "--n-title-font-weight": I, "--n-icon-size": _, "--n-icon-margin": x, "--n-icon-margin-rtl": y, "--n-close-size": D, "--n-close-margin": b, "--n-close-margin-rtl": M, "--n-padding": E, "--n-icon-margin-left": V, "--n-icon-margin-right": U };
  }), l = i ? Ye("alert", R(() => o.type[0]), a, o) : void 0, d = O(true), c = () => {
    const { onAfterLeave: g, onAfterHide: f } = o;
    g && g(), f && f();
  };
  return { rtlEnabled: s, mergedClsPrefix: e, mergedBordered: t, visible: d, handleCloseClick: () => {
    var g;
    Promise.resolve((g = o.onClose) === null || g === void 0 ? void 0 : g.call(o)).then((f) => {
      f !== false && (d.value = false);
    });
  }, handleAfterLeave: () => {
    c();
  }, mergedTheme: n, cssVars: i ? void 0 : a, themeClass: l == null ? void 0 : l.themeClass, onRender: l == null ? void 0 : l.onRender };
}, render() {
  var o;
  return (o = this.onRender) === null || o === void 0 || o.call(this), p(jt, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: e, $slots: t } = this, i = { class: [`${e}-alert`, this.themeClass, this.closable && `${e}-alert--closable`, this.showIcon && `${e}-alert--show-icon`, !this.title && this.closable && `${e}-alert--right-adjust`, this.rtlEnabled && `${e}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? p("div", Object.assign({}, Wi(this.$attrs, i)), this.closable && p(bo, { clsPrefix: e, class: `${e}-alert__close`, onClick: this.handleCloseClick }), this.bordered && p("div", { class: `${e}-alert__border` }), this.showIcon && p("div", { class: `${e}-alert__icon`, "aria-hidden": "true" }, ui(t.icon, () => [p(de, { clsPrefix: e }, { default: () => {
      switch (this.type) {
        case "success":
          return p(Lt, null);
        case "info":
          return p(Tt, null);
        case "warning":
          return p(Ot, null);
        case "error":
          return p(Bt, null);
        default:
          return null;
      }
    } })])), p("div", { class: [`${e}-alert-body`, this.mergedBordered && `${e}-alert-body--bordered`] }, hi(t.header, (r) => {
      const n = r || this.title;
      return n ? p("div", { class: `${e}-alert-body__title` }, n) : null;
    }), t.default && p("div", { class: `${e}-alert-body__content` }, t))) : null;
  } });
} }), or = gi("n-checkbox-group"), rr = () => p("svg", { viewBox: "0 0 64 64", class: "check-icon" }, p("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), nr = () => p("svg", { viewBox: "0 0 100 100", class: "line-icon" }, p("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), sr = L([S("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [T("show-label", "line-height: var(--n-label-line-height);"), L("&:hover", [S("checkbox-box", [N("border", "border: var(--n-border-checked);")])]), L("&:focus:not(:active)", [S("checkbox-box", [N("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), T("inside-table", [S("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), T("checked", [S("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [S("checkbox-icon", [L(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), T("indeterminate", [S("checkbox-box", [S("checkbox-icon", [L(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), L(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), T("checked, indeterminate", [L("&:focus:not(:active)", [S("checkbox-box", [N("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), S("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [N("border", { border: "var(--n-border-checked)" })])]), T("disabled", { cursor: "not-allowed" }, [T("checked", [S("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [N("border", { border: "var(--n-border-disabled-checked)" }), S("checkbox-icon", [L(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), S("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [N("border", `
 border: var(--n-border-disabled);
 `), S("checkbox-icon", [L(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), N("label", `
 color: var(--n-text-color-disabled);
 `)]), S("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), S("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [N("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), S("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [L(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), vi({ left: "1px", top: "1px" })])]), N("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [L("&:empty", { display: "none" })])]), Co(S("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), wo(S("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), ar = Object.assign(Object.assign({}, ue.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), lr = q({ name: "Checkbox", props: ar, setup(o) {
  const e = ge(or, null), t = O(null), { mergedClsPrefixRef: i, inlineThemeDisabled: r, mergedRtlRef: n } = He(o), s = O(o.defaultChecked), a = X(o, "checked"), l = fi(a, s), d = mi(() => {
    if (e) {
      const m = e.valueSetRef.value;
      return m && o.value !== void 0 ? m.has(o.value) : false;
    } else return l.value === o.checkedValue;
  }), c = bi(o, { mergedSize(m) {
    const { size: C } = o;
    if (C !== void 0) return C;
    if (e) {
      const { value: D } = e.mergedSizeRef;
      if (D !== void 0) return D;
    }
    if (m) {
      const { mergedSize: D } = m;
      if (D !== void 0) return D.value;
    }
    return "medium";
  }, mergedDisabled(m) {
    const { disabled: C } = o;
    if (C !== void 0) return C;
    if (e) {
      if (e.disabledRef.value) return true;
      const { maxRef: { value: D }, checkedCountRef: b } = e;
      if (D !== void 0 && b.value >= D && !d.value) return true;
      const { minRef: { value: M } } = e;
      if (M !== void 0 && b.value <= M && d.value) return true;
    }
    return m ? m.disabled.value : false;
  } }), { mergedDisabledRef: u, mergedSizeRef: h } = c, g = ue("Checkbox", "-checkbox", sr, Fo, o, i);
  function f(m) {
    if (e && o.value !== void 0) e.toggleCheckbox(!d.value, o.value);
    else {
      const { onChange: C, "onUpdate:checked": D, onUpdateChecked: b } = o, { nTriggerFormInput: M, nTriggerFormChange: E } = c, F = d.value ? o.uncheckedValue : o.checkedValue;
      D && Ne(D, F, m), b && Ne(b, F, m), C && Ne(C, F, m), M(), E(), s.value = F;
    }
  }
  function v(m) {
    u.value || f(m);
  }
  function w(m) {
    if (!u.value) switch (m.key) {
      case " ":
      case "Enter":
        f(m);
    }
  }
  function I(m) {
    switch (m.key) {
      case " ":
        m.preventDefault();
    }
  }
  const P = { focus: () => {
    var m;
    (m = t.value) === null || m === void 0 || m.focus();
  }, blur: () => {
    var m;
    (m = t.value) === null || m === void 0 || m.blur();
  } }, _ = pi("Checkbox", n, i), x = R(() => {
    const { value: m } = h, { common: { cubicBezierEaseInOut: C }, self: { borderRadius: D, color: b, colorChecked: M, colorDisabled: E, colorTableHeader: F, colorTableHeaderModal: V, colorTableHeaderPopover: U, checkMarkColor: J, checkMarkColorDisabled: W, border: Z, borderFocus: Q, borderDisabled: ae, borderChecked: Be, boxShadowFocus: z, textColor: G, textColorDisabled: H, checkMarkColorDisabledChecked: me, colorDisabledChecked: Oe, borderDisabledChecked: Ke, labelPadding: qe, labelLineHeight: Ce, labelFontWeight: $i, [re("fontSize", m)]: zi, [re("size", m)]: Ni } } = g.value;
    return { "--n-label-line-height": Ce, "--n-label-font-weight": $i, "--n-size": Ni, "--n-bezier": C, "--n-border-radius": D, "--n-border": Z, "--n-border-checked": Be, "--n-border-focus": Q, "--n-border-disabled": ae, "--n-border-disabled-checked": Ke, "--n-box-shadow-focus": z, "--n-color": b, "--n-color-checked": M, "--n-color-table": F, "--n-color-table-modal": V, "--n-color-table-popover": U, "--n-color-disabled": E, "--n-color-disabled-checked": Oe, "--n-text-color": G, "--n-text-color-disabled": H, "--n-check-mark-color": J, "--n-check-mark-color-disabled": W, "--n-check-mark-color-disabled-checked": me, "--n-font-size": zi, "--n-label-padding": qe };
  }), y = r ? Ye("checkbox", R(() => h.value[0]), x, o) : void 0;
  return Object.assign(c, P, { rtlEnabled: _, selfRef: t, mergedClsPrefix: i, mergedDisabled: u, renderedChecked: d, mergedTheme: g, labelId: xt(), handleClick: v, handleKeyUp: w, handleKeyDown: I, cssVars: r ? void 0 : x, themeClass: y == null ? void 0 : y.themeClass, onRender: y == null ? void 0 : y.onRender });
}, render() {
  var o;
  const { $slots: e, renderedChecked: t, mergedDisabled: i, indeterminate: r, privateInsideTable: n, cssVars: s, labelId: a, label: l, mergedClsPrefix: d, focusable: c, handleKeyUp: u, handleKeyDown: h, handleClick: g } = this;
  (o = this.onRender) === null || o === void 0 || o.call(this);
  const f = hi(e.default, (v) => l || v ? p("span", { class: `${d}-checkbox__label`, id: a }, l || v) : null);
  return p("div", { ref: "selfRef", class: [`${d}-checkbox`, this.themeClass, this.rtlEnabled && `${d}-checkbox--rtl`, t && `${d}-checkbox--checked`, i && `${d}-checkbox--disabled`, r && `${d}-checkbox--indeterminate`, n && `${d}-checkbox--inside-table`, f && `${d}-checkbox--show-label`], tabindex: i || !c ? void 0 : 0, role: "checkbox", "aria-checked": r ? "mixed" : t, "aria-labelledby": a, style: s, onKeyup: u, onKeydown: h, onClick: g, onMousedown: () => {
    Po("selectstart", window, (v) => {
      v.preventDefault();
    }, { once: true });
  } }, p("div", { class: `${d}-checkbox-box-wrapper` }, "\xA0", p("div", { class: `${d}-checkbox-box` }, p(yi, null, { default: () => this.indeterminate ? p("div", { key: "indeterminate", class: `${d}-checkbox-icon` }, nr()) : p("div", { key: "check", class: `${d}-checkbox-icon` }, rr()) }), p("div", { class: `${d}-checkbox-box__border` }))), f);
} }), dr = { success: p(Lt, null), error: p(Bt, null), warning: p(Ot, null), info: p(Tt, null) }, cr = q({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(o, { slots: e }) {
  function t(r, n, s, a) {
    const { gapDegree: l, viewBoxWidth: d, strokeWidth: c } = o, u = 50, h = 0, g = u, f = 0, v = 2 * u, w = 50 + c / 2, I = `M ${w},${w} m ${h},${g}
      a ${u},${u} 0 1 1 ${f},${-v}
      a ${u},${u} 0 1 1 ${-f},${v}`, P = Math.PI * 2 * u, _ = { stroke: a === "rail" ? s : typeof o.fillColor == "object" ? "url(#gradient)" : s, strokeDasharray: `${r / 100 * (P - l)}px ${d * 8}px`, strokeDashoffset: `-${l / 2}px`, transformOrigin: n ? "center" : void 0, transform: n ? `rotate(${n}deg)` : void 0 };
    return { pathString: I, pathStyle: _ };
  }
  const i = () => {
    const r = typeof o.fillColor == "object", n = r ? o.fillColor.stops[0] : "", s = r ? o.fillColor.stops[1] : "";
    return r && p("defs", null, p("linearGradient", { id: "gradient", x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, p("stop", { offset: "0%", "stop-color": n }), p("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: r, railColor: n, strokeWidth: s, offsetDegree: a, status: l, percentage: d, showIndicator: c, indicatorTextColor: u, unit: h, gapOffsetDegree: g, clsPrefix: f } = o, { pathString: v, pathStyle: w } = t(100, 0, n, "rail"), { pathString: I, pathStyle: P } = t(d, a, r, "fill"), _ = 100 + s;
    return p("div", { class: `${f}-progress-content`, role: "none" }, p("div", { class: `${f}-progress-graph`, "aria-hidden": true }, p("div", { class: `${f}-progress-graph-circle`, style: { transform: g ? `rotate(${g}deg)` : void 0 } }, p("svg", { viewBox: `0 0 ${_} ${_}` }, i(), p("g", null, p("path", { class: `${f}-progress-graph-circle-rail`, d: v, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: w })), p("g", null, p("path", { class: [`${f}-progress-graph-circle-fill`, d === 0 && `${f}-progress-graph-circle-fill--empty`], d: I, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: P }))))), c ? p("div", null, e.default ? p("div", { class: `${f}-progress-custom-content`, role: "none" }, e.default()) : l !== "default" ? p("div", { class: `${f}-progress-icon`, "aria-hidden": true }, p(de, { clsPrefix: f }, { default: () => dr[l] })) : p("div", { class: `${f}-progress-text`, style: { color: u }, role: "none" }, p("span", { class: `${f}-progress-text__percentage` }, d), p("span", { class: `${f}-progress-text__unit` }, h))) : null);
  };
} }), ur = { success: p(Lt, null), error: p(Bt, null), warning: p(Ot, null), info: p(Tt, null) }, hr = q({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(o, { slots: e }) {
  const t = R(() => Pe(o.height)), i = R(() => {
    var s, a;
    return typeof o.fillColor == "object" ? `linear-gradient(to right, ${(s = o.fillColor) === null || s === void 0 ? void 0 : s.stops[0]} , ${(a = o.fillColor) === null || a === void 0 ? void 0 : a.stops[1]})` : o.fillColor;
  }), r = R(() => o.railBorderRadius !== void 0 ? Pe(o.railBorderRadius) : o.height !== void 0 ? Pe(o.height, { c: 0.5 }) : ""), n = R(() => o.fillBorderRadius !== void 0 ? Pe(o.fillBorderRadius) : o.railBorderRadius !== void 0 ? Pe(o.railBorderRadius) : o.height !== void 0 ? Pe(o.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: s, railColor: a, railStyle: l, percentage: d, unit: c, indicatorTextColor: u, status: h, showIndicator: g, processing: f, clsPrefix: v } = o;
    return p("div", { class: `${v}-progress-content`, role: "none" }, p("div", { class: `${v}-progress-graph`, "aria-hidden": true }, p("div", { class: [`${v}-progress-graph-line`, { [`${v}-progress-graph-line--indicator-${s}`]: true }] }, p("div", { class: `${v}-progress-graph-line-rail`, style: [{ backgroundColor: a, height: t.value, borderRadius: r.value }, l] }, p("div", { class: [`${v}-progress-graph-line-fill`, f && `${v}-progress-graph-line-fill--processing`], style: { maxWidth: `${o.percentage}%`, background: i.value, height: t.value, lineHeight: t.value, borderRadius: n.value } }, s === "inside" ? p("div", { class: `${v}-progress-graph-line-indicator`, style: { color: u } }, e.default ? e.default() : `${d}${c}`) : null)))), g && s === "outside" ? p("div", null, e.default ? p("div", { class: `${v}-progress-custom-content`, style: { color: u }, role: "none" }, e.default()) : h === "default" ? p("div", { role: "none", class: `${v}-progress-icon ${v}-progress-icon--as-text`, style: { color: u } }, d, c) : p("div", { class: `${v}-progress-icon`, "aria-hidden": true }, p(de, { clsPrefix: v }, { default: () => ur[h] }))) : null);
  };
} });
function At(o, e, t = 100) {
  return `m ${t / 2} ${t / 2 - o} a ${o} ${o} 0 1 1 0 ${2 * o} a ${o} ${o} 0 1 1 0 -${2 * o}`;
}
const pr = q({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(o, { slots: e }) {
  const t = R(() => o.percentage.map((n, s) => `${Math.PI * n / 100 * (o.viewBoxWidth / 2 - o.strokeWidth / 2 * (1 + 2 * s) - o.circleGap * s) * 2}, ${o.viewBoxWidth * 8}`)), i = (r, n) => {
    const s = o.fillColor[n], a = typeof s == "object" ? s.stops[0] : "", l = typeof s == "object" ? s.stops[1] : "";
    return typeof o.fillColor[n] == "object" && p("linearGradient", { id: `gradient-${n}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, p("stop", { offset: "0%", "stop-color": a }), p("stop", { offset: "100%", "stop-color": l }));
  };
  return () => {
    const { viewBoxWidth: r, strokeWidth: n, circleGap: s, showIndicator: a, fillColor: l, railColor: d, railStyle: c, percentage: u, clsPrefix: h } = o;
    return p("div", { class: `${h}-progress-content`, role: "none" }, p("div", { class: `${h}-progress-graph`, "aria-hidden": true }, p("div", { class: `${h}-progress-graph-circle` }, p("svg", { viewBox: `0 0 ${r} ${r}` }, p("defs", null, u.map((g, f) => i(g, f))), u.map((g, f) => p("g", { key: f }, p("path", { class: `${h}-progress-graph-circle-rail`, d: At(r / 2 - n / 2 * (1 + 2 * f) - s * f, n, r), "stroke-width": n, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: d[f] }, c[f]] }), p("path", { class: [`${h}-progress-graph-circle-fill`, g === 0 && `${h}-progress-graph-circle-fill--empty`], d: At(r / 2 - n / 2 * (1 + 2 * f) - s * f, n, r), "stroke-width": n, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: t.value[f], strokeDashoffset: 0, stroke: typeof l[f] == "object" ? `url(#gradient-${f})` : l[f] } })))))), a && e.default ? p("div", null, p("div", { class: `${h}-progress-text` }, e.default())) : null);
  };
} }), gr = L([S("progress", { display: "inline-block" }, [S("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), T("line", `
 width: 100%;
 display: block;
 `, [S("progress-content", `
 display: flex;
 align-items: center;
 `, [S("progress-graph", { flex: 1 })]), S("progress-custom-content", { marginLeft: "14px" }), S("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [T("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), T("circle, dashboard", { width: "120px" }, [S("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), S("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), S("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), T("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [S("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), S("progress-content", { position: "relative" }), S("progress-graph", { position: "relative" }, [S("progress-graph-circle", [L("svg", { verticalAlign: "bottom" }), S("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [T("empty", { opacity: 0 })]), S("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), S("progress-graph-line", [T("indicator-inside", [S("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [S("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), S("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), T("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [S("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), S("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), S("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [S("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [T("processing", [L("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), L("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), fr = Object.assign(Object.assign({}, ue.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), mr = q({ name: "Progress", props: fr, setup(o) {
  const e = R(() => o.indicatorPlacement || o.indicatorPosition), t = R(() => {
    if (o.gapDegree || o.gapDegree === 0) return o.gapDegree;
    if (o.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: i, inlineThemeDisabled: r } = He(o), n = ue("Progress", "-progress", gr, Bo, o, i), s = R(() => {
    const { status: l } = o, { common: { cubicBezierEaseInOut: d }, self: { fontSize: c, fontSizeCircle: u, railColor: h, railHeight: g, iconSizeCircle: f, iconSizeLine: v, textColorCircle: w, textColorLineInner: I, textColorLineOuter: P, lineBgProcessing: _, fontWeightCircle: x, [re("iconColor", l)]: y, [re("fillColor", l)]: m } } = n.value;
    return { "--n-bezier": d, "--n-fill-color": m, "--n-font-size": c, "--n-font-size-circle": u, "--n-font-weight-circle": x, "--n-icon-color": y, "--n-icon-size-circle": f, "--n-icon-size-line": v, "--n-line-bg-processing": _, "--n-rail-color": h, "--n-rail-height": g, "--n-text-color-circle": w, "--n-text-color-line-inner": I, "--n-text-color-line-outer": P };
  }), a = r ? Ye("progress", R(() => o.status[0]), s, o) : void 0;
  return { mergedClsPrefix: i, mergedIndicatorPlacement: e, gapDeg: t, cssVars: r ? void 0 : s, themeClass: a == null ? void 0 : a.themeClass, onRender: a == null ? void 0 : a.onRender };
}, render() {
  const { type: o, cssVars: e, indicatorTextColor: t, showIndicator: i, status: r, railColor: n, railStyle: s, color: a, percentage: l, viewBoxWidth: d, strokeWidth: c, mergedIndicatorPlacement: u, unit: h, borderRadius: g, fillBorderRadius: f, height: v, processing: w, circleGap: I, mergedClsPrefix: P, gapDeg: _, gapOffsetDegree: x, themeClass: y, $slots: m, onRender: C } = this;
  return C == null ? void 0 : C(), p("div", { class: [y, `${P}-progress`, `${P}-progress--${o}`, `${P}-progress--${r}`], style: e, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": l, role: o === "circle" || o === "line" || o === "dashboard" ? "progressbar" : "none" }, o === "circle" || o === "dashboard" ? p(cr, { clsPrefix: P, status: r, showIndicator: i, indicatorTextColor: t, railColor: n, fillColor: a, railStyle: s, offsetDegree: this.offsetDegree, percentage: l, viewBoxWidth: d, strokeWidth: c, gapDegree: _ === void 0 ? o === "dashboard" ? 75 : 0 : _, gapOffsetDegree: x, unit: h }, m) : o === "line" ? p(hr, { clsPrefix: P, status: r, showIndicator: i, indicatorTextColor: t, railColor: n, fillColor: a, railStyle: s, percentage: l, processing: w, indicatorPlacement: u, unit: h, fillBorderRadius: f, railBorderRadius: g, height: v }, m) : o === "multiple-circle" ? p(pr, { clsPrefix: P, strokeWidth: c, railColor: n, fillColor: a, railStyle: s, viewBoxWidth: d, percentage: l, showIndicator: i, circleGap: I }, m) : null);
} }), vr = L([L("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), S("spin-container", `
 position: relative;
 `, [S("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [ko()])]), S("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), S("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [T("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), S("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), S("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [T("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), yr = { small: 20, medium: 18, large: 16 }, br = Object.assign(Object.assign({}, ue.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), xr = q({ name: "Spin", props: br, slots: Object, setup(o) {
  const { mergedClsPrefixRef: e, inlineThemeDisabled: t } = He(o), i = ue("Spin", "-spin", vr, Oo, o, e), r = R(() => {
    const { size: l } = o, { common: { cubicBezierEaseInOut: d }, self: c } = i.value, { opacitySpinning: u, color: h, textColor: g } = c, f = typeof l == "number" ? So(l) : c[re("size", l)];
    return { "--n-bezier": d, "--n-opacity-spinning": u, "--n-size": f, "--n-color": h, "--n-text-color": g };
  }), n = t ? Ye("spin", R(() => {
    const { size: l } = o;
    return typeof l == "number" ? String(l) : l[0];
  }), r, o) : void 0, s = Mo(o, ["spinning", "show"]), a = O(false);
  return ai((l) => {
    let d;
    if (s.value) {
      const { delay: c } = o;
      if (c) {
        d = window.setTimeout(() => {
          a.value = true;
        }, c), l(() => {
          clearTimeout(d);
        });
        return;
      }
    }
    a.value = s.value;
  }), { mergedClsPrefix: e, active: a, mergedStrokeWidth: R(() => {
    const { strokeWidth: l } = o;
    if (l !== void 0) return l;
    const { size: d } = o;
    return yr[typeof d == "number" ? "medium" : d];
  }), cssVars: t ? void 0 : r, themeClass: n == null ? void 0 : n.themeClass, onRender: n == null ? void 0 : n.onRender };
}, render() {
  var o, e;
  const { $slots: t, mergedClsPrefix: i, description: r } = this, n = t.icon && this.rotate, s = (r || t.description) && p("div", { class: `${i}-spin-description` }, r || ((o = t.description) === null || o === void 0 ? void 0 : o.call(t))), a = t.icon ? p("div", { class: [`${i}-spin-body`, this.themeClass] }, p("div", { class: [`${i}-spin`, n && `${i}-spin--rotate`], style: t.default ? "" : this.cssVars }, t.icon()), s) : p("div", { class: [`${i}-spin-body`, this.themeClass] }, p(Do, { clsPrefix: i, style: t.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${i}-spin` }), s);
  return (e = this.onRender) === null || e === void 0 || e.call(this), t.default ? p("div", { class: [`${i}-spin-container`, this.themeClass], style: this.cssVars }, p("div", { class: [`${i}-spin-content`, this.active && `${i}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, t), p(Et, { name: "fade-in-transition" }, { default: () => this.active ? a : null })) : a;
} }), Fe = gi("n-upload"), Cr = L([S("upload", "width: 100%;", [T("dragger-inside", [S("upload-trigger", `
 display: block;
 `)]), T("drag-over", [S("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), S("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [L("&:hover", `
 border: var(--n-dragger-border-hover);
 `), T("disabled", `
 cursor: not-allowed;
 `)]), S("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [L("+", [S("upload-file-list", "margin-top: 8px;")]), T("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), T("image-card", `
 width: 96px;
 height: 96px;
 `, [S("base-icon", `
 font-size: 24px;
 `), S("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), S("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [L("a, img", "outline: none;"), T("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [S("upload-file", "cursor: not-allowed;")]), T("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), S("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Ct(), S("progress", [Ct({ foldPadding: true })]), L("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [S("upload-file-info", [N("action", `
 opacity: 1;
 `)])]), T("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [S("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [S("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), N("name", `
 padding: 0 8px;
 `), N("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [L("img", `
 width: 100%;
 `)])])]), T("text-type", [S("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), T("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [S("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), S("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [N("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [L("img", `
 width: 100%;
 `)])]), L("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), L("&:hover", [L("&::before", "opacity: 1;"), S("upload-file-info", [N("thumbnail", "opacity: .12;")])])]), T("error-status", [L("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), S("upload-file-info", [N("name", "color: var(--n-item-text-color-error);"), N("thumbnail", "color: var(--n-item-text-color-error);")]), T("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), T("with-url", `
 cursor: pointer;
 `, [S("upload-file-info", [N("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [L("a", `
 text-decoration: underline;
 `)])])]), S("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [N("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [S("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), N("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [S("button", [L("&:not(:last-child)", { marginRight: "4px" }), S("base-icon", [L("svg", [vi()])])]), T("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), T("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), N("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [L("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), S("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), Ci = "__UPLOAD_DRAGGER__", wi = q({ name: "UploadDragger", [Ci]: true, setup(o, { slots: e }) {
  const t = ge(Fe, null);
  return t || dt("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: i }, mergedDisabledRef: { value: r }, maxReachedRef: { value: n } } = t;
    return p("div", { class: [`${i}-upload-dragger`, (r || n) && `${i}-upload-dragger--disabled`] }, e);
  };
} }), wr = p("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, p("g", { fill: "none" }, p("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" }))), Pr = p("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, p("g", { fill: "none" }, p("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" }))), kr = q({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: ge(Fe).mergedThemeRef };
}, render() {
  return p(jt, null, { default: () => this.show ? p(mr, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var Pt = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(c) {
      try {
        d(i.next(c));
      } catch (u) {
        s(u);
      }
    }
    function l(c) {
      try {
        d(i.throw(c));
      } catch (u) {
        s(u);
      }
    }
    function d(c) {
      c.done ? n(c.value) : r(c.value).then(a, l);
    }
    d((i = i.apply(o, e || [])).next());
  });
};
function Pi(o) {
  return o.includes("image/");
}
function Gt(o = "") {
  const e = o.split("/"), i = e[e.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(i) || [""])[0];
}
const Vt = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, ki = (o) => {
  if (o.type) return Pi(o.type);
  const e = Gt(o.name || "");
  if (Vt.test(e)) return true;
  const t = o.thumbnailUrl || o.url || "", i = Gt(t);
  return !!(/^data:image\//.test(t) || Vt.test(i));
};
function Sr(o) {
  return Pt(this, void 0, void 0, function* () {
    return yield new Promise((e) => {
      if (!o.type || !Pi(o.type)) {
        e("");
        return;
      }
      e(window.URL.createObjectURL(o));
    });
  });
}
const Mr = Ro && window.FileReader && window.File;
function Ir(o) {
  return o.isDirectory;
}
function _r(o) {
  return o.isFile;
}
function Dr(o, e) {
  return Pt(this, void 0, void 0, function* () {
    const t = [];
    function i(r) {
      return Pt(this, void 0, void 0, function* () {
        for (const n of r) if (n) {
          if (e && Ir(n)) {
            const s = n.createReader();
            let a = [], l;
            try {
              do
                l = yield new Promise((d, c) => {
                  s.readEntries(d, c);
                }), a = a.concat(l);
              while (l.length > 0);
            } catch (d) {
              Ut("upload", "error happens when handling directory upload", d);
            }
            yield i(a);
          } else if (_r(n)) try {
            const s = yield new Promise((a, l) => {
              n.file(a, l);
            });
            t.push({ file: s, entry: n, source: "dnd" });
          } catch (s) {
            Ut("upload", "error happens when handling file upload", s);
          }
        }
      });
    }
    return yield i(o), t;
  });
}
function Ve(o) {
  const { id: e, name: t, percentage: i, status: r, url: n, file: s, thumbnailUrl: a, type: l, fullPath: d, batchId: c } = o;
  return { id: e, name: t, percentage: i ?? null, status: r, url: n ?? null, file: s ?? null, thumbnailUrl: a ?? null, type: l ?? null, fullPath: d ?? null, batchId: c ?? null };
}
function Rr(o, e, t) {
  return o = o.toLowerCase(), e = e.toLocaleLowerCase(), t = t.toLocaleLowerCase(), t.split(",").map((r) => r.trim()).filter(Boolean).some((r) => {
    if (r.startsWith(".")) {
      if (o.endsWith(r)) return true;
    } else if (r.includes("/")) {
      const [n, s] = e.split("/"), [a, l] = r.split("/");
      if ((a === "*" || n && a && a === n) && (l === "*" || s && l && l === s)) return true;
    } else return true;
    return false;
  });
}
var Xt = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(c) {
      try {
        d(i.next(c));
      } catch (u) {
        s(u);
      }
    }
    function l(c) {
      try {
        d(i.throw(c));
      } catch (u) {
        s(u);
      }
    }
    function d(c) {
      c.done ? n(c.value) : r(c.value).then(a, l);
    }
    d((i = i.apply(o, e || [])).next());
  });
};
const Je = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, Er = q({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(o) {
  const e = ge(Fe), t = O(null), i = O(""), r = R(() => {
    const { file: y } = o;
    return y.status === "finished" ? "success" : y.status === "error" ? "error" : "info";
  }), n = R(() => {
    const { file: y } = o;
    if (y.status === "error") return "error";
  }), s = R(() => {
    const { file: y } = o;
    return y.status === "uploading";
  }), a = R(() => {
    if (!e.showCancelButtonRef.value) return false;
    const { file: y } = o;
    return ["uploading", "pending", "error"].includes(y.status);
  }), l = R(() => {
    if (!e.showRemoveButtonRef.value) return false;
    const { file: y } = o;
    return ["finished"].includes(y.status);
  }), d = R(() => {
    if (!e.showDownloadButtonRef.value) return false;
    const { file: y } = o;
    return ["finished"].includes(y.status);
  }), c = R(() => {
    if (!e.showRetryButtonRef.value) return false;
    const { file: y } = o;
    return ["error"].includes(y.status);
  }), u = mi(() => i.value || o.file.thumbnailUrl || o.file.url), h = R(() => {
    if (!e.showPreviewButtonRef.value) return false;
    const { file: { status: y }, listType: m } = o;
    return ["finished"].includes(y) && u.value && m === "image-card";
  });
  function g() {
    return Xt(this, void 0, void 0, function* () {
      const y = e.onRetryRef.value;
      y && (yield y({ file: o.file })) === false || e.submit(o.file.id);
    });
  }
  function f(y) {
    y.preventDefault();
    const { file: m } = o;
    ["finished", "pending", "error"].includes(m.status) ? w(m) : ["uploading"].includes(m.status) ? P(m) : Io("upload", "The button clicked type is unknown.");
  }
  function v(y) {
    y.preventDefault(), I(o.file);
  }
  function w(y) {
    const { xhrMap: m, doChange: C, onRemoveRef: { value: D }, mergedFileListRef: { value: b } } = e;
    Promise.resolve(D ? D({ file: Object.assign({}, y), fileList: b, index: o.index }) : true).then((M) => {
      if (M === false) return;
      const E = Object.assign({}, y, { status: "removed" });
      m.delete(y.id), C(E, void 0, { remove: true });
    });
  }
  function I(y) {
    const { onDownloadRef: { value: m }, customDownloadRef: { value: C } } = e;
    Promise.resolve(m ? m(Object.assign({}, y)) : true).then((D) => {
      D !== false && (C ? C(Object.assign({}, y)) : zo(y.url, y.name));
    });
  }
  function P(y) {
    const { xhrMap: m } = e, C = m.get(y.id);
    C == null ? void 0 : C.abort(), w(Object.assign({}, y));
  }
  function _(y) {
    const { onPreviewRef: { value: m } } = e;
    if (m) m(o.file, { event: y });
    else if (o.listType === "image-card") {
      const { value: C } = t;
      if (!C) return;
      C.click();
    }
  }
  const x = () => Xt(this, void 0, void 0, function* () {
    const { listType: y } = o;
    y !== "image" && y !== "image-card" || e.shouldUseThumbnailUrlRef.value(o.file) && (i.value = yield e.getFileThumbnailUrlResolver(o.file));
  });
  return ai(() => {
    x();
  }), { mergedTheme: e.mergedThemeRef, progressStatus: r, buttonType: n, showProgress: s, disabled: e.mergedDisabledRef, showCancelButton: a, showRemoveButton: l, showDownloadButton: d, showRetryButton: c, showPreviewButton: h, mergedThumbnailUrl: u, shouldUseThumbnailUrl: e.shouldUseThumbnailUrlRef, renderIcon: e.renderIconRef, imageRef: t, handleRemoveOrCancelClick: f, handleDownloadClick: v, handleRetryClick: g, handlePreviewClick: _ };
}, render() {
  const { clsPrefix: o, mergedTheme: e, listType: t, file: i, renderIcon: r } = this;
  let n;
  const s = t === "image";
  s || t === "image-card" ? n = !this.shouldUseThumbnailUrl(i) || !this.mergedThumbnailUrl ? p("span", { class: `${o}-upload-file-info__thumbnail` }, r ? r(i) : ki(i) ? p(de, { clsPrefix: o }, { default: wr }) : p(de, { clsPrefix: o }, { default: Pr })) : p("a", { rel: "noopener noreferer", target: "_blank", href: i.url || void 0, class: `${o}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, t === "image-card" ? p(jo, { src: this.mergedThumbnailUrl || void 0, previewSrc: i.url || void 0, alt: i.name, ref: "imageRef" }) : p("img", { src: this.mergedThumbnailUrl || void 0, alt: i.name })) : n = p("span", { class: `${o}-upload-file-info__thumbnail` }, r ? r(i) : p(de, { clsPrefix: o }, { default: () => p(qo, null) }));
  const l = p(kr, { show: this.showProgress, percentage: i.percentage || 0, status: this.progressStatus }), d = t === "text" || t === "image";
  return p("div", { class: [`${o}-upload-file`, `${o}-upload-file--${this.progressStatus}-status`, i.url && i.status !== "error" && t !== "image-card" && `${o}-upload-file--with-url`, `${o}-upload-file--${t}-type`] }, p("div", { class: `${o}-upload-file-info` }, n, p("div", { class: `${o}-upload-file-info__name` }, d && (i.url && i.status !== "error" ? p("a", { rel: "noopener noreferer", target: "_blank", href: i.url || void 0, onClick: this.handlePreviewClick }, i.name) : p("span", { onClick: this.handlePreviewClick }, i.name)), s && l), p("div", { class: [`${o}-upload-file-info__action`, `${o}-upload-file-info__action--${t}-type`] }, this.showPreviewButton ? p(he, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: e.peers.Button, themeOverrides: e.peerOverrides.Button, builtinThemeOverrides: Je }, { icon: () => p(de, { clsPrefix: o }, { default: () => p(Qi, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && p(he, { key: "cancelOrTrash", theme: e.peers.Button, themeOverrides: e.peerOverrides.Button, quaternary: true, builtinThemeOverrides: Je, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => p(yi, null, { default: () => this.showRemoveButton ? p(de, { clsPrefix: o, key: "trash" }, { default: () => p(Qo, null) }) : p(de, { clsPrefix: o, key: "cancel" }, { default: () => p(Jo, null) }) }) }), this.showRetryButton && !this.disabled && p(he, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: e.peers.Button, themeOverrides: e.peerOverrides.Button, builtinThemeOverrides: Je }, { icon: () => p(de, { clsPrefix: o }, { default: () => p(Zo, null) }) }), this.showDownloadButton ? p(he, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: e.peers.Button, themeOverrides: e.peerOverrides.Button, builtinThemeOverrides: Je }, { icon: () => p(de, { clsPrefix: o }, { default: () => p($o, null) }) }) : null)), !s && l);
} }), Si = q({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(o, { slots: e }) {
  const t = ge(Fe, null);
  t || dt("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: i, mergedDisabledRef: r, maxReachedRef: n, listTypeRef: s, dragOverRef: a, openOpenFileDialog: l, draggerInsideRef: d, handleFileAddition: c, mergedDirectoryDndRef: u, triggerClassRef: h, triggerStyleRef: g } = t, f = R(() => s.value === "image-card");
  function v() {
    r.value || n.value || l();
  }
  function w(x) {
    x.preventDefault(), a.value = true;
  }
  function I(x) {
    x.preventDefault(), a.value = true;
  }
  function P(x) {
    x.preventDefault(), a.value = false;
  }
  function _(x) {
    var y;
    if (x.preventDefault(), !d.value || r.value || n.value) {
      a.value = false;
      return;
    }
    const m = (y = x.dataTransfer) === null || y === void 0 ? void 0 : y.items;
    (m == null ? void 0 : m.length) ? Dr(Array.from(m).map((C) => C.webkitGetAsEntry()), u.value).then((C) => {
      c(C);
    }).finally(() => {
      a.value = false;
    }) : a.value = false;
  }
  return () => {
    var x;
    const { value: y } = i;
    return o.abstract ? (x = e.default) === null || x === void 0 ? void 0 : x.call(e, { handleClick: v, handleDrop: _, handleDragOver: w, handleDragEnter: I, handleDragLeave: P }) : p("div", { class: [`${y}-upload-trigger`, (r.value || n.value) && `${y}-upload-trigger--disabled`, f.value && `${y}-upload-trigger--image-card`, h.value], style: g.value, onClick: v, onDrop: _, onDragover: w, onDragenter: I, onDragleave: P }, f.value ? p(wi, null, { default: () => ui(e.default, () => [p(de, { clsPrefix: y }, { default: () => p(eo, null) })]) }) : e);
  };
} }), Fr = q({ name: "UploadFileList", setup(o, { slots: e }) {
  const t = ge(Fe, null);
  t || dt("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: i, mergedClsPrefixRef: r, listTypeRef: n, mergedFileListRef: s, fileListClassRef: a, fileListStyleRef: l, cssVarsRef: d, themeClassRef: c, maxReachedRef: u, showTriggerRef: h, imageGroupPropsRef: g } = t, f = R(() => n.value === "image-card"), v = () => s.value.map((I, P) => p(Er, { clsPrefix: r.value, key: I.id, file: I, index: P, listType: n.value })), w = () => f.value ? p(No, Object.assign({}, g.value), { default: v }) : p(jt, { group: true }, { default: v });
  return () => {
    const { value: I } = r, { value: P } = i;
    return p("div", { class: [`${I}-upload-file-list`, f.value && `${I}-upload-file-list--grid`, P ? c == null ? void 0 : c.value : void 0, a.value], style: [P && d ? d.value : "", l.value] }, w(), h.value && !u.value && f.value && p(Si, null, e));
  };
} });
var Ht = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(c) {
      try {
        d(i.next(c));
      } catch (u) {
        s(u);
      }
    }
    function l(c) {
      try {
        d(i.throw(c));
      } catch (u) {
        s(u);
      }
    }
    function d(c) {
      c.done ? n(c.value) : r(c.value).then(a, l);
    }
    d((i = i.apply(o, e || [])).next());
  });
};
function Br(o, e, t) {
  const { doChange: i, xhrMap: r } = o;
  let n = 0;
  function s(l) {
    var d;
    let c = Object.assign({}, e, { status: "error", percentage: n });
    r.delete(e.id), c = Ve(((d = o.onError) === null || d === void 0 ? void 0 : d.call(o, { file: c, event: l })) || c), i(c, l);
  }
  function a(l) {
    var d;
    if (o.isErrorState) {
      if (o.isErrorState(t)) {
        s(l);
        return;
      }
    } else if (t.status < 200 || t.status >= 300) {
      s(l);
      return;
    }
    let c = Object.assign({}, e, { status: "finished", percentage: n });
    r.delete(e.id), c = Ve(((d = o.onFinish) === null || d === void 0 ? void 0 : d.call(o, { file: c, event: l })) || c), i(c, l);
  }
  return { handleXHRLoad: a, handleXHRError: s, handleXHRAbort(l) {
    const d = Object.assign({}, e, { status: "removed", file: null, percentage: n });
    r.delete(e.id), i(d, l);
  }, handleXHRProgress(l) {
    const d = Object.assign({}, e, { status: "uploading" });
    if (l.lengthComputable) {
      const c = Math.ceil(l.loaded / l.total * 100);
      d.percentage = c, n = c;
    }
    i(d, l);
  } };
}
function Or(o) {
  const { inst: e, file: t, data: i, headers: r, withCredentials: n, action: s, customRequest: a } = o, { doChange: l } = o.inst;
  let d = 0;
  a({ file: t, data: i, headers: r, withCredentials: n, action: s, onProgress(c) {
    const u = Object.assign({}, t, { status: "uploading" }), h = c.percent;
    u.percentage = h, d = h, l(u);
  }, onFinish() {
    var c;
    let u = Object.assign({}, t, { status: "finished", percentage: d });
    u = Ve(((c = e.onFinish) === null || c === void 0 ? void 0 : c.call(e, { file: u })) || u), l(u);
  }, onError() {
    var c;
    let u = Object.assign({}, t, { status: "error", percentage: d });
    u = Ve(((c = e.onError) === null || c === void 0 ? void 0 : c.call(e, { file: u })) || u), l(u);
  } });
}
function Tr(o, e, t) {
  const i = Br(o, e, t);
  t.onabort = i.handleXHRAbort, t.onerror = i.handleXHRError, t.onload = i.handleXHRLoad, t.upload && (t.upload.onprogress = i.handleXHRProgress);
}
function Mi(o, e) {
  return typeof o == "function" ? o({ file: e }) : o || {};
}
function Lr(o, e, t) {
  const i = Mi(e, t);
  i && Object.keys(i).forEach((r) => {
    o.setRequestHeader(r, i[r]);
  });
}
function jr(o, e, t) {
  const i = Mi(e, t);
  i && Object.keys(i).forEach((r) => {
    o.append(r, i[r]);
  });
}
function $r(o, e, t, { method: i, action: r, withCredentials: n, responseType: s, headers: a, data: l }) {
  const d = new XMLHttpRequest();
  d.responseType = s, o.xhrMap.set(t.id, d), d.withCredentials = n;
  const c = new FormData();
  if (jr(c, l, t), t.file !== null && c.append(e, t.file), Tr(o, t, d), r !== void 0) {
    d.open(i.toUpperCase(), r), Lr(d, a, t), d.send(c);
    const u = Object.assign({}, t, { status: "uploading" });
    o.doChange(u);
  }
}
const zr = Object.assign(Object.assign({}, ue.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (o) => Mr ? ki(o) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), Nr = q({ name: "Upload", props: zr, setup(o) {
  o.abstract && o.listType === "image-card" && dt("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: e, inlineThemeDisabled: t } = He(o), i = ue("Upload", "-upload", Cr, To, o, e), r = bi(o), n = O(o.defaultFileList), s = X(o, "fileList"), a = O(null), l = { value: false }, d = O(false), c = /* @__PURE__ */ new Map(), u = fi(s, n), h = R(() => u.value.map(Ve)), g = R(() => {
    const { max: b } = o;
    return b !== void 0 ? h.value.length >= b : false;
  });
  function f() {
    var b;
    (b = a.value) === null || b === void 0 || b.click();
  }
  function v(b) {
    const M = b.target;
    _(M.files ? Array.from(M.files).map((E) => ({ file: E, entry: null, source: "input" })) : null, b), M.value = "";
  }
  function w(b) {
    const { "onUpdate:fileList": M, onUpdateFileList: E } = o;
    M && Ne(M, b), E && Ne(E, b), n.value = b;
  }
  const I = R(() => o.multiple || o.directory), P = (b, M, E = { append: false, remove: false }) => {
    const { append: F, remove: V } = E, U = Array.from(h.value), J = U.findIndex((W) => W.id === b.id);
    if (F || V || ~J) {
      F ? U.push(b) : V ? U.splice(J, 1) : U.splice(J, 1, b);
      const { onChange: W } = o;
      W && W({ file: b, fileList: U, event: M }), w(U);
    }
  };
  function _(b, M) {
    if (!b || b.length === 0) return;
    const { onBeforeUpload: E } = o;
    b = I.value ? b : [b[0]];
    const { max: F, accept: V } = o;
    b = b.filter(({ file: J, source: W }) => W === "dnd" && (V == null ? void 0 : V.trim()) ? Rr(J.name, J.type, V) : true), F && (b = b.slice(0, F - h.value.length));
    const U = xt();
    Promise.all(b.map((J) => Ht(this, [J], void 0, function* ({ file: W, entry: Z }) {
      var Q;
      const ae = { id: xt(), batchId: U, name: W.name, status: "pending", percentage: 0, file: W, url: null, type: W.type, thumbnailUrl: null, fullPath: (Q = Z == null ? void 0 : Z.fullPath) !== null && Q !== void 0 ? Q : `/${W.webkitRelativePath || W.name}` };
      return !E || (yield E({ file: ae, fileList: h.value })) !== false ? ae : null;
    }))).then((J) => Ht(this, void 0, void 0, function* () {
      let W = Promise.resolve();
      J.forEach((Z) => {
        W = W.then(Vi).then(() => {
          Z && P(Z, M, { append: true });
        });
      }), yield W;
    })).then(() => {
      o.defaultUpload && x();
    });
  }
  function x(b) {
    const { method: M, action: E, withCredentials: F, headers: V, data: U, name: J } = o, W = b !== void 0 ? h.value.filter((Q) => Q.id === b) : h.value, Z = b !== void 0;
    W.forEach((Q) => {
      const { status: ae } = Q;
      (ae === "pending" || ae === "error" && Z) && (o.customRequest ? Or({ inst: { doChange: P, xhrMap: c, onFinish: o.onFinish, onError: o.onError }, file: Q, action: E, withCredentials: F, headers: V, data: U, customRequest: o.customRequest }) : $r({ doChange: P, xhrMap: c, onFinish: o.onFinish, onError: o.onError, isErrorState: o.isErrorState }, J, Q, { method: M, action: E, withCredentials: F, responseType: o.responseType, headers: V, data: U }));
    });
  }
  function y(b) {
    var M;
    if (b.thumbnailUrl) return b.thumbnailUrl;
    const { createThumbnailUrl: E } = o;
    return E ? (M = E(b.file, b)) !== null && M !== void 0 ? M : b.url || "" : b.url ? b.url : b.file ? Sr(b.file) : "";
  }
  const m = R(() => {
    const { common: { cubicBezierEaseInOut: b }, self: { draggerColor: M, draggerBorder: E, draggerBorderHover: F, itemColorHover: V, itemColorHoverError: U, itemTextColorError: J, itemTextColorSuccess: W, itemTextColor: Z, itemIconColor: Q, itemDisabledOpacity: ae, lineHeight: Be, borderRadius: z, fontSize: G, itemBorderImageCardError: H, itemBorderImageCard: me } } = i.value;
    return { "--n-bezier": b, "--n-border-radius": z, "--n-dragger-border": E, "--n-dragger-border-hover": F, "--n-dragger-color": M, "--n-font-size": G, "--n-item-color-hover": V, "--n-item-color-hover-error": U, "--n-item-disabled-opacity": ae, "--n-item-icon-color": Q, "--n-item-text-color": Z, "--n-item-text-color-error": J, "--n-item-text-color-success": W, "--n-line-height": Be, "--n-item-border-image-card-error": H, "--n-item-border-image-card": me };
  }), C = t ? Ye("upload", void 0, m, o) : void 0;
  Gi(Fe, { mergedClsPrefixRef: e, mergedThemeRef: i, showCancelButtonRef: X(o, "showCancelButton"), showDownloadButtonRef: X(o, "showDownloadButton"), showRemoveButtonRef: X(o, "showRemoveButton"), showRetryButtonRef: X(o, "showRetryButton"), onRemoveRef: X(o, "onRemove"), onDownloadRef: X(o, "onDownload"), customDownloadRef: X(o, "customDownload"), mergedFileListRef: h, triggerClassRef: X(o, "triggerClass"), triggerStyleRef: X(o, "triggerStyle"), shouldUseThumbnailUrlRef: X(o, "shouldUseThumbnailUrl"), renderIconRef: X(o, "renderIcon"), xhrMap: c, submit: x, doChange: P, showPreviewButtonRef: X(o, "showPreviewButton"), onPreviewRef: X(o, "onPreview"), getFileThumbnailUrlResolver: y, listTypeRef: X(o, "listType"), dragOverRef: d, openOpenFileDialog: f, draggerInsideRef: l, handleFileAddition: _, mergedDisabledRef: r.mergedDisabledRef, maxReachedRef: g, fileListClassRef: X(o, "fileListClass"), fileListStyleRef: X(o, "fileListStyle"), abstractRef: X(o, "abstract"), acceptRef: X(o, "accept"), cssVarsRef: t ? void 0 : m, themeClassRef: C == null ? void 0 : C.themeClass, onRender: C == null ? void 0 : C.onRender, showTriggerRef: X(o, "showTrigger"), imageGroupPropsRef: X(o, "imageGroupProps"), mergedDirectoryDndRef: R(() => {
    var b;
    return (b = o.directoryDnd) !== null && b !== void 0 ? b : o.directory;
  }), onRetryRef: X(o, "onRetry") });
  const D = { clear: () => {
    n.value = [];
  }, submit: x, openOpenFileDialog: f };
  return Object.assign({ mergedClsPrefix: e, draggerInsideRef: l, inputElRef: a, mergedTheme: i, dragOver: d, mergedMultiple: I, cssVars: t ? void 0 : m, themeClass: C == null ? void 0 : C.themeClass, onRender: C == null ? void 0 : C.onRender, handleFileInputChange: v }, D);
}, render() {
  var o, e;
  const { draggerInsideRef: t, mergedClsPrefix: i, $slots: r, directory: n, onRender: s } = this;
  if (r.default && !this.abstract) {
    const l = r.default()[0];
    !((o = l == null ? void 0 : l.type) === null || o === void 0) && o[Ci] && (t.value = true);
  }
  const a = p("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${i}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: n || void 0, directory: n || void 0 }));
  return this.abstract ? p(Ie, null, (e = r.default) === null || e === void 0 ? void 0 : e.call(r), p(Ai, { to: "body" }, a)) : (s == null ? void 0 : s(), p("div", { class: [`${i}-upload`, t.value && `${i}-upload--dragger-inside`, this.dragOver && `${i}-upload--drag-over`, this.themeClass], style: this.cssVars }, a, this.showTrigger && this.listType !== "image-card" && p(Si, null, r), this.showFileList && p(Fr, null, r)));
} });
function te() {
  return te = Object.assign ? Object.assign.bind() : function(o) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) ({}).hasOwnProperty.call(t, i) && (o[i] = t[i]);
    }
    return o;
  }, te.apply(null, arguments);
}
var ie;
(function(o) {
  o.Commit = "commit", o.Provisional = "provisional", o.Finish = "finish";
})(ie || (ie = {}));
const ee = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, kt = "currentlyDrawing", We = "edited", St = "closingPoint", Ii = "snappingPoint", Mt = "coordinatePoint", Ur = "coordinatePointFeatureId", ot = "coordinatePointIds", it = 10;
function pt(o) {
  return !!(o && typeof o == "object" && o !== null && !Array.isArray(o));
}
function Yt(o) {
  return !!(o && typeof o == "object" && "properties" in o && typeof o.properties == "object" && o.properties !== null && "mode" in o.properties);
}
function Kt(o) {
  return !!(function(e) {
    return typeof e == "number" && !isNaN(new Date(e).valueOf());
  })(o);
}
const Wr = "Feature mode property does not match the mode being added to";
var De;
(function(o) {
  o.Drawing = "drawing", o.Select = "select", o.Static = "static", o.Render = "render";
})(De || (De = {}));
const Ar = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class ut {
  get state() {
    return this._state;
  }
  set state(e) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(e) {
    if (typeof e != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = e;
  }
  registerBehaviors(e) {
  }
  constructor(e, t = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = Ar, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = De.Drawing, this.mode = "base", t || this.updateOptions(e);
  }
  updateOptions(e) {
    e != null && e.styles && (this.styles = te({}, this._styles, e.styles)), e != null && e.pointerDistance && (this.pointerDistance = e.pointerDistance), e != null && e.validation && (this.validate = e && e.validation), e != null && e.projection && (this.projection = e.projection), (e == null ? void 0 : e.pointerEvents) !== void 0 && (this.pointerEvents = e.pointerEvents);
  }
  allowPointerEvent(e, t) {
    return typeof e == "boolean" ? e : typeof e != "function" || e(t);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(e) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = e.store, this.store.registerOnChange(e.onChange), this.setDoubleClickToZoom = e.setDoubleClickToZoom, this.project = e.project, this.unproject = e.unproject, this.onSelect = e.onSelect, this.onDeselect = e.onDeselect, this.setCursor = e.setCursor, this.onStyleChange = e.onChange, this.onFinish = e.onFinish, this.coordinatePrecision = e.coordinatePrecision, this.registerBehaviors({ mode: e.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: e.coordinatePrecision, projection: this.projection });
  }
  validateFeature(e) {
    return this.performFeatureValidation(e);
  }
  afterFeatureAdded(e) {
  }
  afterFeatureUpdated(e) {
  }
  performFeatureValidation(e) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const t = (function(i, r) {
      let n;
      if (pt(i)) if (i.id == null) n = "Feature has no id";
      else if (typeof i.id != "string" && typeof i.id != "number") n = "Feature must be string or number as per GeoJSON spec";
      else if (r(i.id)) if (pt(i.geometry)) if (pt(i.properties)) if (typeof i.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(i.geometry.type)) if (Array.isArray(i.geometry.coordinates)) {
        if (!i.properties.mode || typeof i.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else n = "Feature coordinates is not an array";
      else n = "Feature is not Point, LineString or Polygon";
      else n = "Feature has no properties";
      else n = "Feature has no geometry";
      else n = "Feature must match the id strategy (default is UUID4)";
      else n = "Feature is not object";
      return n ? { valid: false, reason: n } : { valid: true };
    })(e, this.store.idStrategy.isValidId);
    if (this.validate) {
      const i = this.validate(e, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Provisional });
      return { valid: t.valid && i.valid, reason: i.reason };
    }
    return { valid: t.valid, reason: t.reason };
  }
  validateModeFeature(e, t) {
    const i = this.performFeatureValidation(e);
    return i.valid ? e.properties.mode !== this.mode ? { valid: false, reason: Wr } : t(e) : { valid: false, reason: i.reason };
  }
  onFinish(e, t) {
  }
  onDeselect(e) {
  }
  onSelect(e) {
  }
  onKeyDown(e) {
  }
  onKeyUp(e) {
  }
  onMouseMove(e) {
  }
  onClick(e) {
  }
  onDragStart(e, t) {
  }
  onDrag(e, t) {
  }
  onDragEnd(e, t) {
  }
  getHexColorStylingValue(e, t, i) {
    return this.getStylingValue(e, t, i);
  }
  getNumericStylingValue(e, t, i) {
    return this.getStylingValue(e, t, i);
  }
  getStylingValue(e, t, i) {
    return e === void 0 ? t : typeof e == "function" ? e(i) : e;
  }
}
class Gr extends ut {
  constructor(...e) {
    super(...e), this.type = De.Select;
  }
}
function fe(o, e) {
  const t = (d) => d * Math.PI / 180, i = t(o[1]), r = t(o[0]), n = t(e[1]), s = n - i, a = t(e[0]) - r, l = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(i) * Math.cos(n) * Math.sin(a / 2) * Math.sin(a / 2);
  return 2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)) * 6371e3 / 1e3;
}
const _i = 63710088e-1;
function ne(o) {
  return o % 360 * Math.PI / 180;
}
function Vr(o) {
  return o / 6371.0088;
}
function Re(o) {
  return o % (2 * Math.PI) * 180 / Math.PI;
}
function K(o, e = 9) {
  const t = Math.pow(10, e);
  return Math.round(o * t) / t;
}
const qt = 57.29577951308232, Jt = 0.017453292519943295, rt = 6378137, Y = (o, e) => ({ x: o === 0 ? 0 : o * Jt * rt, y: e === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + e * Jt / 2)) * rt }), Ee = (o, e) => ({ lng: o === 0 ? 0 : qt * (o / rt), lat: e === 0 ? 0 : (2 * Math.atan(Math.exp(e / rt)) - Math.PI / 2) * qt });
function Xr(o) {
  let e;
  if (o.geometry.type === "Polygon") e = o.geometry.coordinates;
  else {
    if (o.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    e = [o.geometry.coordinates];
  }
  const t = [];
  for (let n = 0; n < e.length; n++) for (let s = 0; s < e[n].length - 1; s++) for (let a = 0; a < e.length; a++) for (let l = 0; l < e[a].length - 1; l++) r(n, s, a, l);
  return t.length > 0;
  function i(n) {
    return n < 0 || n > 1;
  }
  function r(n, s, a, l) {
    const d = e[n][s], c = e[n][s + 1], u = e[a][l], h = e[a][l + 1], g = (function(w, I, P, _) {
      if (Ze(w, P) || Ze(w, _) || Ze(I, P) || Ze(_, P)) return null;
      const x = w[0], y = w[1], m = I[0], C = I[1], D = P[0], b = P[1], M = _[0], E = _[1], F = (x - m) * (b - E) - (y - C) * (D - M);
      return F === 0 ? null : [((x * C - y * m) * (D - M) - (x - m) * (D * E - b * M)) / F, ((x * C - y * m) * (b - E) - (y - C) * (D * E - b * M)) / F];
    })(d, c, u, h);
    if (g === null) return;
    let f, v;
    f = c[0] !== d[0] ? (g[0] - d[0]) / (c[0] - d[0]) : (g[1] - d[1]) / (c[1] - d[1]), v = h[0] !== u[0] ? (g[0] - u[0]) / (h[0] - u[0]) : (g[1] - u[1]) / (h[1] - u[1]), i(f) || i(v) || (g.toString(), t.push(g));
  }
}
function Ze(o, e) {
  return o[0] === e[0] && o[1] === e[1];
}
function $t(o, e) {
  return Zt(o[0]) <= e && Zt(o[1]) <= e;
}
function Di(o) {
  return o.length === 2 && typeof o[0] == "number" && typeof o[1] == "number" && o[0] !== 1 / 0 && o[1] !== 1 / 0 && (t = o[0]) >= -180 && t <= 180 && (e = o[1]) >= -90 && e <= 90;
  var e, t;
}
function Zt(o) {
  let e = 1, t = 0;
  for (; Math.round(o * e) / e !== o; ) e *= 10, t++;
  return t;
}
const pe = (o, e) => {
  const { x: t, y: i } = o, { x: r, y: n } = e, s = r - t, a = n - i;
  return Math.sqrt(a * a + s * s);
};
class se {
  constructor({ store: e, mode: t, project: i, unproject: r, pointerDistance: n, coordinatePrecision: s, projection: a }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = e, this.mode = t, this.project = i, this.unproject = r, this.pointerDistance = n, this.coordinatePrecision = s, this.projection = a;
  }
}
function Ri({ unproject: o, point: e, pointerDistance: t }) {
  const i = t / 2, { x: r, y: n } = e;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[o(r - i, n - i), o(r + i, n - i), o(r + i, n + i), o(r - i, n + i), o(r - i, n - i)].map((s) => [s.lng, s.lat])] } };
}
class nt extends se {
  constructor(e) {
    super(e);
  }
  create(e) {
    const { containerX: t, containerY: i } = e;
    return Ri({ unproject: this.unproject, point: { x: t, y: i }, pointerDistance: this.pointerDistance });
  }
}
class st extends se {
  constructor(e) {
    super(e);
  }
  measure(e, t) {
    const { x: i, y: r } = this.project(t[0], t[1]);
    return pe({ x: i, y: r }, { x: e.containerX, y: e.containerY });
  }
}
class It extends se {
  constructor(e, t, i) {
    super(e), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (r) => this.getSnappable(r, (n) => !!(n.properties && n.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (r, n) => this.getSnappable(r, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== n)).coordinate, this.config = e, this.pixelDistance = t, this.clickBoundingBox = i;
  }
  getSnappable(e, t) {
    const i = this.clickBoundingBox.create(e), r = this.store.search(i, t), n = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return r.forEach((s) => {
      let a;
      if (s.geometry.type === "Polygon") a = s.geometry.coordinates[0];
      else {
        if (s.geometry.type !== "LineString") return;
        a = s.geometry.coordinates;
      }
      a.forEach((l, d) => {
        const c = this.pixelDistance.measure(e, l);
        c < n.minDist && c < this.pointerDistance && (n.coordinate = l, n.minDist = c, n.featureId = s.id, n.featureCoordinateIndex = d);
      });
    }), n;
  }
}
function Qt(o, e, t) {
  const i = ne(o[0]), r = ne(o[1]), n = ne(t), s = Vr(e), a = Math.asin(Math.sin(r) * Math.cos(s) + Math.cos(r) * Math.sin(s) * Math.cos(n));
  return [Re(i + Math.atan2(Math.sin(n) * Math.sin(s) * Math.cos(r), Math.cos(s) - Math.sin(r) * Math.sin(a))), Re(a)];
}
function ei(o, e) {
  const t = ne(o[0]), i = ne(e[0]), r = ne(o[1]), n = ne(e[1]), s = Math.sin(i - t) * Math.cos(n), a = Math.cos(r) * Math.sin(n) - Math.sin(r) * Math.cos(n) * Math.cos(i - t);
  return Re(Math.atan2(s, a));
}
function Hr({ x: o, y: e }, { x: t, y: i }) {
  const r = t - o, n = i - e;
  if (r === 0 && n === 0) return 0;
  let s = Math.atan2(n, r);
  return s *= 180 / Math.PI, s > 180 ? s -= 360 : s < -180 && (s += 360), s;
}
function Yr(o, e, t) {
  const i = [], r = o.length;
  let n, s, a, l = 0;
  for (let c = 0; c < o.length && !(e >= l && c === o.length - 1); c++) {
    if (l > e && i.length === 0) {
      if (n = e - l, !n) return i.push(o[c]), i;
      s = ei(o[c], o[c - 1]) - 180, a = Qt(o[c], n, s), i.push(a);
    }
    if (l >= t) return n = t - l, n ? (s = ei(o[c], o[c - 1]) - 180, a = Qt(o[c], n, s), i.push(a), i) : (i.push(o[c]), i);
    if (l >= e && i.push(o[c]), c === o.length - 1) return i;
    l += fe(o[c], o[c + 1]);
  }
  if (l < e && o.length === r) throw new Error("Start position is beyond line");
  const d = o[o.length - 1];
  return [d, d];
}
function Qe(o) {
  return o * (Math.PI / 180);
}
function ti(o) {
  return o * (180 / Math.PI);
}
class Kr extends se {
  constructor(e) {
    super(e), this.config = void 0, this.config = e;
  }
  generateInsertionCoordinates(e, t, i) {
    const r = [e, t];
    let n = 0;
    for (let d = 0; d < r.length - 1; d++) n += fe(r[0], r[1]);
    if (n <= i) return r;
    let s = n / i - 1;
    Number.isInteger(s) || (s = Math.floor(s) + 1);
    const a = [];
    for (let d = 0; d < s; d++) {
      const c = Yr(r, i * d, i * (d + 1));
      a.push(c);
    }
    const l = [];
    for (let d = 0; d < a.length; d++) l.push(a[d][1]);
    return this.limitCoordinates(l);
  }
  generateInsertionGeodesicCoordinates(e, t, i) {
    const r = fe(e, t), n = (function(s, a, l) {
      const d = [], c = Qe(s[1]), u = Qe(s[0]), h = Qe(a[1]), g = Qe(a[0]);
      l += 1;
      const f = 2 * Math.asin(Math.sqrt(Math.sin((h - c) / 2) ** 2 + Math.cos(c) * Math.cos(h) * Math.sin((g - u) / 2) ** 2));
      if (f === 0 || isNaN(f)) return d;
      for (let v = 0; v <= l; v++) {
        const w = v / l, I = Math.sin((1 - w) * f) / Math.sin(f), P = Math.sin(w * f) / Math.sin(f), _ = I * Math.cos(c) * Math.cos(u) + P * Math.cos(h) * Math.cos(g), x = I * Math.cos(c) * Math.sin(u) + P * Math.cos(h) * Math.sin(g), y = I * Math.sin(c) + P * Math.sin(h);
        if (isNaN(_) || isNaN(x) || isNaN(y)) continue;
        const m = Math.atan2(y, Math.sqrt(_ ** 2 + x ** 2)), C = Math.atan2(x, _);
        isNaN(m) || isNaN(C) || d.push([ti(C), ti(m)]);
      }
      return d.slice(1, -1);
    })(e, t, Math.floor(r / i));
    return this.limitCoordinates(n);
  }
  limitCoordinates(e) {
    return e.map((t) => [K(t[0], this.config.coordinatePrecision), K(t[1], this.config.coordinatePrecision)]);
  }
}
function qr(o, e) {
  return o[0] === e[0] && o[1] === e[1];
}
function Jr(o, e) {
  if (o.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (o.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let t = 0; t < o.geometry.coordinates.length; t++) {
    if (!Di(o.geometry.coordinates[t])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!$t(o.geometry.coordinates[t], e)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function ii(o) {
  return Math.sqrt(Math.pow(o[0], 2) + Math.pow(o[1], 2) + Math.pow(o[2], 2));
}
function ve(o, e) {
  const t = (function(i, r) {
    const [n, s, a] = i, [l, d, c] = r;
    return n * l + s * d + a * c;
  })(o, e) / (ii(o) * ii(e));
  return Math.acos(Math.min(Math.max(t, -1), 1));
}
function gt(o) {
  const e = ne(o[1]), t = ne(o[0]);
  return [Math.cos(e) * Math.cos(t), Math.cos(e) * Math.sin(t), Math.sin(e)];
}
function ye(o) {
  const [e, t, i] = o, r = Re(Math.asin(i));
  return [Re(Math.atan2(t, e)), r];
}
function Zr(o, e, t) {
  const i = gt(o), r = gt(e), n = gt(t), [s, a, l] = n, [d, c, u] = (function(E, F) {
    const [V, U, J] = E, [W, Z, Q] = F;
    return [U * Q - J * Z, J * W - V * Q, V * Z - U * W];
  })(i, r), h = c * l - u * a, g = u * s - d * l, f = d * a - c * s, v = f * c - g * u, w = h * u - f * d, I = g * d - h * c, P = 1 / Math.sqrt(Math.pow(v, 2) + Math.pow(w, 2) + Math.pow(I, 2)), _ = [v * P, w * P, I * P], x = [-1 * v * P, -1 * w * P, -1 * I * P], y = ve(i, r), m = ve(i, _), C = ve(r, _), D = ve(i, x), b = ve(r, x);
  let M;
  return M = m < D && m < b || C < D && C < b ? _ : x, ve(i, M) > y || ve(r, M) > y ? fe(ye(M), ye(i)) <= fe(ye(M), ye(r)) ? [ye(i), true, false] : [ye(r), false, true] : [ye(M), false, false];
}
function Qr(o, e, t) {
  const i = e.x - o.x, r = e.y - o.y, n = Math.max(0, Math.min(1, ((t.x - o.x) * i + (t.y - o.y) * r) / (i * i + r * r)));
  return { x: o.x + n * i, y: o.y + n * r };
}
class Ei extends se {
  constructor(e, t, i) {
    super(e), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (r) => {
      const n = this.getSnappable(r, (s) => !!(s.properties && s.properties.mode === this.mode));
      return n.coordinate ? [K(n.coordinate[0], this.config.coordinatePrecision), K(n.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (r, n) => {
      const s = this.getSnappable(r, (a) => !!(a.properties && a.properties.mode === this.mode && a.id !== n));
      return s.coordinate ? [K(s.coordinate[0], this.config.coordinatePrecision), K(s.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = e, this.pixelDistance = t, this.clickBoundingBox = i;
  }
  getSnappable(e, t) {
    const i = this.clickBoundingBox.create(e), r = this.store.search(i, t), n = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return r.forEach((s) => {
      let a;
      if (s.geometry.type === "Polygon") a = s.geometry.coordinates[0];
      else {
        if (s.geometry.type !== "LineString") return;
        a = s.geometry.coordinates;
      }
      const l = [];
      for (let h = 0; h < a.length - 1; h++) l.push([a[h], a[h + 1]]);
      let d;
      const c = [e.lng, e.lat];
      if (this.config.projection === "web-mercator" ? d = (function(h, g) {
        let f = [1 / 0, 1 / 0], v = 1 / 0, w = 0;
        for (let I of g) {
          const P = I[0], _ = I[1];
          let x, y = 1 / 0;
          const m = Y(P[0], P[1]), C = Y(_[0], _[1]), D = Y(h[0], h[1]);
          if (P[0] === h[0] && P[1] === h[1]) x = P;
          else if (_[0] === h[0] && _[1] === h[1]) x = _;
          else {
            const { x: b, y: M } = Qr(m, C, D), { lng: E, lat: F } = Ee(b, M);
            x = [E, F];
          }
          x && (y = pe(D, Y(x[0], x[1])), y < v && (f = x, v = y, w = g.indexOf(I)));
        }
        return v === 1 / 0 ? void 0 : { coordinate: f, lineIndex: w, distance: v };
      })(c, l) : this.config.projection === "globe" && (d = (function(h, g) {
        let f = [1 / 0, 1 / 0], v = 1 / 0, w = 0;
        for (let I of g) {
          const P = I[0], _ = I[1];
          let x, y = 1 / 0;
          P[0] === h[0] && P[1] === h[1] ? x = P : _[0] === h[0] && _[1] === h[1] ? x = _ : [x] = Zr(P, _, h), x && (y = fe(h, x), y < v && (f = x, v = y, w = g.indexOf(I)));
        }
        return v === 1 / 0 ? void 0 : { coordinate: f, distance: v, lineIndex: w };
      })(c, l)), !d) return;
      const u = this.pixelDistance.measure(e, d.coordinate);
      u < n.minDistance && u < this.pointerDistance && (n.featureId = s.id, n.coordinate = [K(d.coordinate[0], this.config.coordinatePrecision), K(d.coordinate[1], this.config.coordinatePrecision)], n.featureCoordinateIndex = d.lineIndex, n.minDistance = u);
    }), n;
  }
}
const en = { cancel: "Escape", finish: "Enter" }, tn = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class on extends ut {
  constructor(e) {
    super(e, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = en, this.snapping = void 0, this.cursors = tn, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(e);
  }
  updateOptions(e) {
    super.updateOptions(e), e != null && e.cursors && (this.cursors = te({}, this.cursors, e.cursors)), e != null && e.snapping && (this.snapping = e.snapping), (e == null ? void 0 : e.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : e != null && e.keyEvents && (this.keyEvents = te({}, this.keyEvents, e.keyEvents)), e != null && e.insertCoordinates && (this.insertCoordinates = e.insertCoordinates), e && e.editable && (this.editable = e.editable);
  }
  updateSnappedCoordinate(e) {
    const t = this.snapCoordinate(e);
    if (t) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: t } }]);
      else {
        const [i] = this.store.create([{ geometry: { type: "Point", coordinates: t }, properties: { mode: this.mode, [Ii]: true } }]);
        this.snappedPointId = i;
      }
      e.lng = t[0], e.lat = t[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return t;
  }
  close() {
    if (this.currentId === void 0) return;
    const e = this.store.getGeometryCopy(this.currentId);
    e.coordinates.pop(), this.updateGeometries([...e.coordinates], void 0, ie.Commit), this.store.updateProperty([{ id: this.currentId, property: kt, value: void 0 }]);
    const t = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(t, { mode: this.mode, action: "draw" });
  }
  updateGeometries(e, t, i) {
    if (!this.currentId) return;
    const r = { type: "LineString", coordinates: e };
    if (this.validate && !this.validate({ type: "Feature", geometry: r }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: i }).valid) return;
    const n = [{ id: this.currentId, geometry: r }];
    this.closingPointId && t && n.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: t } }), i === "commit" && (this.lastCommittedCoordinates = r.coordinates), this.store.updateGeometry(n);
  }
  generateInsertCoordinates(e, t) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const i = fe(e, t) / (this.insertCoordinates.value + 1);
    let r = [];
    return this.projection === "globe" ? r = this.insertPoint.generateInsertionGeodesicCoordinates(e, t, i) : this.projection === "web-mercator" && (r = this.insertPoint.generateInsertionCoordinates(e, t, i)), r;
  }
  createLine(e) {
    const [t] = this.store.create([{ geometry: { type: "LineString", coordinates: [e, e] }, properties: { mode: this.mode, [kt]: true } }]);
    this.lastCommittedCoordinates = [e, e], this.currentId = t, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(e) {
    if (!this.currentId) return;
    const t = this.store.getGeometryCopy(this.currentId).coordinates, [i] = this.store.create([{ geometry: { type: "Point", coordinates: [...e] }, properties: { mode: this.mode, [St]: true } }]);
    this.closingPointId = i, this.setCursor(this.cursors.close);
    const r = [...t, e];
    this.updateGeometries(r, void 0, ie.Commit), this.currentCoordinate++;
  }
  updateToLine(e, t) {
    if (!this.currentId) return;
    const i = this.store.getGeometryCopy(this.currentId).coordinates, [r, n] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : i[i.length - 2], { x: s, y: a } = this.project(r, n);
    if (pe({ x: s, y: a }, { x: t.x, y: t.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const l = [...i, e];
    this.updateGeometries(l, i[i.length - 1], ie.Commit), this.currentCoordinate++;
  }
  registerBehaviors(e) {
    this.coordinateSnapping = new It(e, new st(e), new nt(e)), this.insertPoint = new Kr(e), this.clickBoundingBox = new nt(e), this.pixelDistance = new st(e), this.lineSnapping = new Ei(e, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new It(e, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(e) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = e;
    const t = this.updateSnappedCoordinate(e) || [e.lng, e.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const i = this.store.getGeometryCopy(this.currentId).coordinates;
    if (i.pop(), this.closingPointId) {
      const [n, s] = i[i.length - 1], { x: a, y: l } = this.project(n, s);
      pe({ x: a, y: l }, { x: e.containerX, y: e.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let r = [...i, t];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const n = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], s = t;
      if (!qr(n, s)) {
        const a = this.generateInsertCoordinates(n, s);
        r = [...this.lastCommittedCoordinates.slice(0, -1), ...a, t];
      }
    }
    this.updateGeometries(r, void 0, ie.Provisional);
  }
  onRightClick(e) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: t, featureCoordinateIndex: i } = this.coordinateSnapping.getSnappable(e, (s) => this.lineStringFilter(s));
    if (!t || i === void 0) return;
    const r = this.store.getGeometryCopy(t);
    let n;
    if (r.type === "LineString" && (n = r.coordinates, !(n.length <= 2))) {
      if (n.splice(i, 1), this.validate && !this.validate({ id: t, type: "Feature", geometry: r, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: t, geometry: r }]), this.onFinish(t, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(e) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const t = this.snapCoordinate(e) || [e.lng, e.lat];
    this.currentCoordinate === 0 ? this.createLine(t) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(t) : this.currentId && this.updateToLine(t, { x: e.containerX, y: e.containerY });
  }
  onClick(e) {
    (e.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, e) || e.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, e) || e.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(e), this.mouseMove = false, e.button === "right" ? this.onRightClick(e) : e.button === "left" && this.onLeftClick(e));
  }
  onKeyDown() {
  }
  onKeyUp(e) {
    e.key === this.keyEvents.cancel && this.cleanUp(), e.key === this.keyEvents.finish && this.close();
  }
  onDragStart(e, t) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, e) || !this.editable) return;
    let i;
    if (this.state === "started") {
      const r = this.lineSnapping.getSnappable(e, (s) => this.lineStringFilter(s));
      r.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = r.featureCoordinateIndex, this.editedFeatureId = r.featureId, i = r.coordinate);
      const n = this.coordinateSnapping.getSnappable(e, (s) => this.lineStringFilter(s));
      n.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = n.featureCoordinateIndex, this.editedFeatureId = n.featureId, i = n.coordinate);
    }
    if (this.editedFeatureId && i) {
      if (!this.editedPointId) {
        const [r] = this.store.create([{ geometry: { type: "Point", coordinates: i }, properties: { mode: this.mode, [We]: true } }]);
        this.editedPointId = r;
      }
      this.setCursor(this.cursors.dragStart), t(false);
    }
  }
  onDrag(e, t) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, e) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const i = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? i.coordinates[this.editedFeatureCoordinateIndex] = [e.lng, e.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, i.coordinates.splice(this.editedInsertIndex, 0, [e.lng, e.lat]), this.editedFeatureCoordinateIndex++);
    const r = { type: "LineString", coordinates: i.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: r, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: r }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [e.lng, e.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: We, value: true }]));
  }
  onDragEnd(e, t) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: We, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, t(true));
  }
  cleanUp() {
    const e = this.currentId, t = this.closingPointId, i = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      e !== void 0 && this.store.delete([e]), i !== void 0 && this.store.delete([i]), t !== void 0 && this.store.delete([t]);
    } catch {
    }
  }
  styleFeature(e) {
    const t = te({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (e.type === "Feature" && e.geometry.type === "LineString" && e.properties.mode === this.mode) return t.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, t.lineStringColor, e), t.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, t.lineStringWidth, e), t.zIndex = it, t;
    if (e.type === "Feature" && e.geometry.type === "Point" && e.properties.mode === this.mode) {
      const i = e.properties[St];
      return t.pointColor = this.getHexColorStylingValue(i ? this.styles.closingPointColor : this.styles.snappingPointColor, t.pointColor, e), t.pointWidth = this.getNumericStylingValue(i ? this.styles.closingPointWidth : this.styles.snappingPointWidth, t.pointWidth, e), t.pointOutlineColor = this.getHexColorStylingValue(i ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", e), t.pointOutlineWidth = this.getNumericStylingValue(i ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, e), t.zIndex = 50, t;
    }
    return t;
  }
  validateFeature(e) {
    return this.validateModeFeature(e, (t) => Jr(t, this.coordinatePrecision));
  }
  lineStringFilter(e) {
    return !!(e.geometry.type === "LineString" && e.properties && e.properties.mode === this.mode);
  }
  snapCoordinate(e) {
    var t, i, r;
    let n;
    if ((t = this.snapping) != null && t.toLine) {
      let s;
      s = this.currentId ? this.lineSnapping.getSnappableCoordinate(e, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(e), s && (n = s);
    }
    return (i = this.snapping) != null && i.toCoordinate && (n = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(e, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(e)), (r = this.snapping) != null && r.toCustom && (n = this.snapping.toCustom(e, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), n;
  }
  afterFeatureUpdated(e) {
    this.editedFeatureId === e.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === e.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const rn = "Feature is not a Point", nn = "Feature has invalid coordinates", sn = "Feature has coordinates with excessive precision";
function an(o, e) {
  return o.geometry.type !== "Point" ? { valid: false, reason: rn } : Di(o.geometry.coordinates) ? $t(o.geometry.coordinates, e) ? { valid: true } : { valid: false, reason: sn } : { valid: false, reason: nn };
}
const ln = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class dn extends ut {
  constructor(e) {
    super(e, true), this.mode = "point", this.cursors = ln, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(e);
  }
  updateOptions(e) {
    super.updateOptions(e), e != null && e.cursors && (this.cursors = te({}, this.cursors, e.cursors)), e != null && e.editable && (this.editable = e.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(e) {
    e.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, e) || e.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e) ? this.onRightClick(e) : e.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, e) && this.onLeftClick(e);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(e, t) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, e)) {
      if (this.editable) {
        const i = this.getNearestPointFeature(e);
        this.editedFeatureId = i == null ? void 0 : i.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), t(false));
    }
  }
  onDrag(e, t) {
    this.allowPointerEvent(this.pointerEvents.onDrag, e) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [e.lng, e.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [e.lng, e.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: We, value: true }])));
  }
  onDragEnd(e, t) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: We, value: false }]), this.editedFeatureId = void 0, t(true));
  }
  registerBehaviors(e) {
    this.pixelDistance = new st(e), this.clickBoundingBox = new nt(e);
  }
  styleFeature(e) {
    const t = te({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (e.type === "Feature" && e.geometry.type === "Point" && e.properties.mode === this.mode) {
      const i = !!(e.id && this.editedFeatureId === e.id);
      t.pointWidth = this.getNumericStylingValue(i ? this.styles.editedPointWidth : this.styles.pointWidth, t.pointWidth, e), t.pointColor = this.getHexColorStylingValue(i ? this.styles.editedPointColor : this.styles.pointColor, t.pointColor, e), t.pointOutlineColor = this.getHexColorStylingValue(i ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, t.pointOutlineColor, e), t.pointOutlineWidth = this.getNumericStylingValue(i ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, e), t.zIndex = 30;
    }
    return t;
  }
  validateFeature(e) {
    return this.validateModeFeature(e, (t) => an(t, this.coordinatePrecision));
  }
  onLeftClick(e) {
    const t = { type: "Point", coordinates: [e.lng, e.lat] }, i = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: t, properties: i }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Finish }).valid) return;
    const [r] = this.store.create([{ geometry: t, properties: i }]);
    this.onFinish(r, { mode: this.mode, action: "draw" });
  }
  onRightClick(e) {
    if (!this.editable) return;
    const t = this.getNearestPointFeature(e);
    t && this.store.delete([t.id]);
  }
  getNearestPointFeature(e) {
    const t = this.clickBoundingBox.create(e), i = this.store.search(t);
    let r, n = 1 / 0;
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      if (a.geometry.type !== "Point" || a.properties.mode !== this.mode) continue;
      const l = this.pixelDistance.measure(e, a.geometry.coordinates);
      l > n || l > this.pointerDistance || (n = l, r = a);
    }
    return r;
  }
  afterFeatureUpdated(e) {
    this.editedFeatureId === e.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class cn extends se {
  constructor(e) {
    super(e);
  }
  createOrUpdate(e) {
    const t = this.store.getGeometryCopy(e), i = this.store.getPropertiesCopy(e);
    let r;
    if (t.type === "Polygon") r = t.coordinates[0].slice(0, -1);
    else {
      if (t.type !== "LineString") return;
      r = t.coordinates;
    }
    const n = this.store.getPropertiesCopy(e), s = n.coordinatePointIds;
    if (s) if (s && s.every((a) => this.store.has(a))) {
      const a = n.coordinatePointIds, l = a.map((d) => this.store.getGeometryCopy(d).coordinates);
      if (a.length !== r.length) {
        this.deleteCoordinatePoints(a);
        const d = this.createPoints(r, i.mode, e);
        this.setFeatureCoordinatePoints(e, d);
      } else r.forEach((d, c) => {
        d[0] === l[c][0] && d[1] === l[c][1] || this.store.updateGeometry([{ id: a[c], geometry: { type: "Point", coordinates: d } }]);
      });
    } else {
      const a = s.filter((d) => this.store.has(d));
      a.length && this.deleteCoordinatePoints(a);
      const l = this.createPoints(r, i.mode, e);
      this.setFeatureCoordinatePoints(e, l);
    }
    else {
      const a = this.createPoints(r, i.mode, e);
      this.setFeatureCoordinatePoints(e, a);
    }
  }
  deletePointsByFeatureIds(e) {
    for (const t of e) this.deleteIfPresent(t);
  }
  getUpdated(e, t) {
    const i = this.store.getPropertiesCopy(e);
    if (i.coordinatePointIds) return i.coordinatePointIds.map((r, n) => ({ id: r, geometry: te({}, this.store.getGeometryCopy(r), { coordinates: t[n] }) }));
  }
  createPoints(e, t, i) {
    return this.store.create(e.map((r, n) => ({ geometry: { type: "Point", coordinates: r }, properties: { mode: t, [Mt]: true, [Ur]: i, index: n } })));
  }
  setFeatureCoordinatePoints(e, t) {
    this.store.updateProperty([{ id: e, property: ot, value: t }]);
  }
  deleteCoordinatePoints(e) {
    const t = e.filter((i) => this.store.has(i));
    this.store.delete(t);
  }
  deleteIfPresent(e) {
    const t = this.store.getPropertiesCopy(e).coordinatePointIds;
    t && (this.deleteCoordinatePoints(t), this.setFeatureCoordinatePoints(e, null));
  }
}
function _t(o, e) {
  const t = o, i = e, r = ne(t[1]), n = ne(i[1]);
  let s = ne(i[0] - t[0]);
  s > Math.PI && (s -= 2 * Math.PI), s < -Math.PI && (s += 2 * Math.PI);
  const a = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)), l = (Re(Math.atan2(s, a)) + 360) % 360;
  return l > 180 ? -(360 - l) : l;
}
function Fi(o, e, t) {
  let i = e;
  e < 0 && (i = -Math.abs(i));
  const r = i / _i, n = o[0] * Math.PI / 180, s = ne(o[1]), a = ne(t), l = r * Math.cos(a);
  let d = s + l;
  Math.abs(d) > Math.PI / 2 && (d = d > 0 ? Math.PI - d : -Math.PI - d);
  const c = Math.log(Math.tan(d / 2 + Math.PI / 4) / Math.tan(s / 2 + Math.PI / 4)), u = Math.abs(c) > 1e-11 ? l / c : Math.cos(s), h = [(180 * (n + r * Math.sin(a) / u) / Math.PI + 540) % 360 - 180, 180 * d / Math.PI];
  return h[0] += h[0] - o[0] > 180 ? -360 : o[0] - h[0] > 180 ? 360 : 0, h;
}
function un(o, e, t, i, r) {
  const n = i(o[0], o[1]), s = i(e[0], e[1]), { lng: a, lat: l } = r((n.x + s.x) / 2, (n.y + s.y) / 2);
  return [K(a, t), K(l, t)];
}
function hn(o, e, t) {
  const i = Fi(o, 1e3 * fe(o, e) / 2, _t(o, e));
  return [K(i[0], t), K(i[1], t)];
}
function oi({ featureCoords: o, precision: e, unproject: t, project: i, projection: r }) {
  const n = [];
  for (let s = 0; s < o.length - 1; s++) {
    let a;
    if (r === "web-mercator") a = un(o[s], o[s + 1], e, i, t);
    else {
      if (r !== "globe") throw new Error("Invalid projection");
      a = hn(o[s], o[s + 1], e);
    }
    n.push(a);
  }
  return n;
}
class pn extends se {
  constructor(e, t, i) {
    super(e), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = e, this.selectionPointBehavior = t, this.coordinatePointBehavior = i;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(e) {
  }
  insert(e, t, i) {
    const r = this.store.getGeometryCopy(t), { midPointFeatureId: n, midPointSegment: s } = this.store.getPropertiesCopy(t), a = this.store.getGeometryCopy(n), l = a.type === "Polygon" ? a.coordinates[0] : a.coordinates;
    l.splice(s + 1, 0, r.coordinates), a.coordinates = a.type === "Polygon" ? [l] : l, this.store.updateGeometry([{ id: n, geometry: a }]), this.store.getPropertiesCopy(e)[ot] && this.coordinatePointBehavior.createOrUpdate(e), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(l, n, i), this.selectionPointBehavior.create(l, a.type, n);
  }
  create(e, t, i) {
    if (!this.store.has(t)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(r, n, s, a, l, d) {
      return oi({ featureCoords: r, precision: s, project: a, unproject: l, projection: d }).map((c, u) => ({ geometry: { type: "Point", coordinates: c }, properties: n(u) }));
    })(e, (r) => ({ mode: this.mode, [ee.MID_POINT]: true, midPointSegment: r, midPointFeatureId: t }), i, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(e) {
    if (this._midPoints.length !== 0) return oi({ featureCoords: e, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((t, i) => ({ id: this._midPoints[i], geometry: { type: "Point", coordinates: t } }));
  }
}
class gn extends se {
  constructor(e) {
    super(e), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(e) {
  }
  create(e, t, i) {
    this._selectionPoints = this.store.create((function(r, n, s) {
      const a = [], l = n === "Polygon" ? r.length - 1 : r.length;
      for (let d = 0; d < l; d++) a.push({ geometry: { type: "Point", coordinates: r[d] }, properties: s(d) });
      return a;
    })(e, t, (r) => ({ mode: this.mode, index: r, [ee.SELECTION_POINT]: true, [ee.SELECTION_POINT_FEATURE_ID]: i })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(e) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((t, i) => ({ id: t, geometry: { type: "Point", coordinates: e[i] } }));
  }
  getOneUpdated(e, t) {
    if (this._selectionPoints[e] !== void 0) return { id: this._selectionPoints[e], geometry: { type: "Point", coordinates: t } };
  }
}
function Bi(o, e) {
  let t = false;
  for (let s = 0, a = e.length; s < a; s++) {
    const l = e[s];
    for (let d = 0, c = l.length, u = c - 1; d < c; u = d++) (r = l[d])[1] > (i = o)[1] != (n = l[u])[1] > i[1] && i[0] < (n[0] - r[0]) * (i[1] - r[1]) / (n[1] - r[1]) + r[0] && (t = !t);
  }
  var i, r, n;
  return t;
}
const Dt = (o, e, t) => {
  const i = (n) => n * n, r = (n, s) => i(n.x - s.x) + i(n.y - s.y);
  return Math.sqrt(((n, s, a) => {
    const l = r(s, a);
    if (l === 0) return r(n, s);
    let d = ((n.x - s.x) * (a.x - s.x) + (n.y - s.y) * (a.y - s.y)) / l;
    return d = Math.max(0, Math.min(1, d)), r(n, { x: s.x + d * (a.x - s.x), y: s.y + d * (a.y - s.y) });
  })(o, e, t));
};
class fn extends se {
  constructor(e, t, i) {
    super(e), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = e, this.createClickBoundingBox = t, this.pixelDistance = i;
  }
  find(e, t) {
    let i, r, n, s, a = 1 / 0, l = 1 / 0, d = 1 / 0;
    const c = this.createClickBoundingBox.create(e), u = this.store.search(c);
    for (let h = 0; h < u.length; h++) {
      const g = u[h], f = g.geometry;
      if (f.type === "Point") {
        if (g.properties.selectionPoint || g.properties.coordinatePoint || !t && g.properties[ee.MID_POINT]) continue;
        const v = this.pixelDistance.measure(e, f.coordinates);
        g.properties[ee.MID_POINT] && v < this.pointerDistance && v < d ? (d = v, n = g) : !g.properties[ee.MID_POINT] && v < this.pointerDistance && v < a && (a = v, i = g);
      } else if (f.type === "LineString") {
        if (i) continue;
        for (let v = 0; v < f.coordinates.length - 1; v++) {
          const w = f.coordinates[v], I = f.coordinates[v + 1], P = Dt({ x: e.containerX, y: e.containerY }, this.project(w[0], w[1]), this.project(I[0], I[1]));
          P < this.pointerDistance && P < l && (l = P, r = g);
        }
      } else if (f.type === "Polygon") {
        if (i || r) continue;
        Bi([e.lng, e.lat], f.coordinates) && (s = g);
      }
    }
    return { clickedFeature: i || r || s, clickedMidPoint: n };
  }
}
class mn extends se {
  constructor(e, t, i, r, n) {
    super(e), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = e, this.featuresAtCursorEvent = t, this.selectionPoints = i, this.midPoints = r, this.coordinatePoints = n;
  }
  startDragging(e, t) {
    this.draggedFeatureId = t, this.dragPosition = [e.lng, e.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(e, t) {
    const { clickedFeature: i } = this.featuresAtCursorEvent.find(e, true);
    return !(!i || i.id !== t);
  }
  drag(e, t) {
    if (!this.draggedFeatureId) return;
    const i = this.store.getGeometryCopy(this.draggedFeatureId), r = [e.lng, e.lat];
    if (i.type === "Polygon" || i.type === "LineString") {
      let n, s;
      if (i.type === "Polygon" ? (n = i.coordinates[0], s = n.length - 1) : (n = i.coordinates, s = n.length), !this.dragPosition) return false;
      for (let c = 0; c < s; c++) {
        const u = n[c];
        let h, g;
        if (this.config.projection === "web-mercator") {
          const f = Y(this.dragPosition[0], this.dragPosition[1]), v = Y(r[0], r[1]), w = Y(u[0], u[1]), I = { x: f.x - v.x, y: f.y - v.y }, P = w.x - I.x, _ = w.y - I.y, { lng: x, lat: y } = Ee(P, _);
          h = x, g = y;
        } else {
          const f = [this.dragPosition[0] - r[0], this.dragPosition[1] - r[1]];
          h = u[0] - f[0], g = u[1] - f[1];
        }
        if (h = K(h, this.config.coordinatePrecision), g = K(g, this.config.coordinatePrecision), h > 180 || h < -180 || g > 90 || g < -90) return false;
        n[c] = [h, g];
      }
      i.type === "Polygon" && (n[n.length - 1] = [n[0][0], n[0][1]]);
      const a = this.selectionPoints.getUpdated(n) || [], l = this.midPoints.getUpdated(n) || [], d = this.coordinatePoints.getUpdated(this.draggedFeatureId, n) || [];
      if (t && !t({ type: "Feature", id: this.draggedFeatureId, geometry: i, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: ie.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: i }, ...a, ...l, ...d]), this.dragPosition = [e.lng, e.lat];
    } else i.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: r } }]), this.dragPosition = [e.lng, e.lat]);
  }
}
class vn extends se {
  constructor(e, t, i, r, n, s, a) {
    super(e), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = e, this.pixelDistance = t, this.selectionPoints = i, this.midPoints = r, this.coordinatePoints = n, this.coordinateSnapping = s, this.lineSnapping = a;
  }
  getClosestCoordinate(e, t) {
    const i = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let r;
    if (t.type === "LineString") r = t.coordinates;
    else {
      if (t.type !== "Polygon") return i;
      r = t.coordinates[0];
    }
    for (let n = 0; n < r.length; n++) {
      const s = this.pixelDistance.measure(e, r[n]);
      if (s < this.pointerDistance && s < i.dist) {
        const a = t.type === "Polygon" && (n === r.length - 1 || n === 0);
        i.dist = s, i.index = a ? 0 : n, i.isFirstOrLastPolygonCoord = a;
      }
    }
    return i;
  }
  getDraggableIndex(e, t) {
    const i = this.store.getGeometryCopy(t), r = this.getClosestCoordinate(e, i);
    return r.index === -1 ? -1 : r.index;
  }
  snapCoordinate(e, t, i) {
    let r = [e.lng, e.lat];
    const n = (s) => !!(s.properties && s.properties.mode === i.properties.mode && s.id !== this.draggedCoordinate.id);
    if (t != null && t.toLine) {
      let s;
      s = this.lineSnapping.getSnappable(e, n).coordinate, s && (r = s);
    }
    if (t.toCoordinate) {
      let s;
      s = this.coordinateSnapping.getSnappable(e, n).coordinate, s && (r = s);
    }
    if (t != null && t.toCustom) {
      let s;
      s = t.toCustom(e, { currentCoordinate: this.draggedCoordinate.index, currentId: i.id, getCurrentGeometrySnapshot: i.id ? () => this.store.getGeometryCopy(i.id) : () => null, project: this.project, unproject: this.unproject }), s && (r = s);
    }
    return r;
  }
  drag(e, t, i, r) {
    const n = this.draggedCoordinate.id;
    if (n === null) return false;
    const s = this.draggedCoordinate.index, a = this.store.getGeometryCopy(n), l = this.store.getPropertiesCopy(n), d = a.type === "LineString" ? a.coordinates : a.coordinates[0], c = a.type === "Polygon" && (s === d.length - 1 || s === 0), u = { type: "Feature", id: n, geometry: a, properties: l }, h = this.snapCoordinate(e, r, u);
    if (e.lng > 180 || e.lng < -180 || e.lat > 90 || e.lat < -90) return false;
    if (c) {
      const I = d.length - 1;
      d[0] = h, d[I] = h;
    } else d[s] = h;
    const g = this.selectionPoints.getOneUpdated(s, h), f = g ? [g] : [], v = this.midPoints.getUpdated(d) || [], w = this.coordinatePoints.getUpdated(n, d) || [];
    return !(a.type !== "Point" && !t && Xr({ geometry: a }) || i && !i(u, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: ie.Provisional }).valid || (this.store.updateGeometry([{ id: n, geometry: a }, ...f, ...v, ...w]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(e, t) {
    this.draggedCoordinate = { id: e, index: t };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function ri(o) {
  let e = 0, t = 0, i = 0;
  return (o.geometry.type === "Polygon" ? o.geometry.coordinates[0].slice(0, -1) : o.geometry.coordinates).forEach((r) => {
    e += r[0], t += r[1], i++;
  }, true), [e / i, t / i];
}
const Oi = (o, e) => {
  if (e === 0 || e === 360 || e === -360) return o;
  const t = 0.017453292519943295 * e, i = (o.geometry.type === "Polygon" ? o.geometry.coordinates[0] : o.geometry.coordinates).map(([s, a]) => Y(s, a)), r = i.reduce((s, a) => ({ x: s.x + a.x, y: s.y + a.y }), { x: 0, y: 0 });
  r.x /= i.length, r.y /= i.length;
  const n = i.map((s) => ({ x: r.x + (s.x - r.x) * Math.cos(t) - (s.y - r.y) * Math.sin(t), y: r.y + (s.x - r.x) * Math.sin(t) + (s.y - r.y) * Math.cos(t) })).map(({ x: s, y: a }) => [Ee(s, a).lng, Ee(s, a).lat]);
  return o.geometry.type === "Polygon" ? o.geometry.coordinates[0] = n : o.geometry.coordinates = n, o;
};
function Rt(o) {
  const e = (o.geometry.type === "Polygon" ? o.geometry.coordinates[0] : o.geometry.coordinates).map((t) => {
    const { x: i, y: r } = Y(t[0], t[1]);
    return [i, r];
  });
  return o.geometry.type === "Polygon" ? (function(t) {
    let i = 0, r = 0, n = 0;
    const s = t.length;
    for (let a = 0; a < s - 1; a++) {
      const [l, d] = t[a], [c, u] = t[a + 1], h = l * u - c * d;
      i += h, r += (l + c) * h, n += (d + u) * h;
    }
    return i /= 2, r /= 6 * i, n /= 6 * i, { x: r, y: n };
  })(e) : (function(t) {
    const i = t.length;
    let r = 0, n = 0;
    for (let s = 0; s < i; s++) {
      const [a, l] = t[s];
      r += a, n += l;
    }
    return { x: r / i, y: n / i };
  })(e);
}
class yn extends se {
  constructor(e, t, i, r) {
    super(e), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = e, this.selectionPoints = t, this.midPoints = i, this.coordinatePoints = r;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(e, t, i) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(t));
    const r = this.selectedGeometry;
    if (r.type !== "Polygon" && r.type !== "LineString") return;
    const n = [e.lng, e.lat];
    let s;
    const a = { type: "Feature", geometry: r, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Rt(a));
      const h = Y(e.lng, e.lat);
      if (s = Hr(this.selectedGeometryWebMercatorCentroid, h), s === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = s);
      Oi(a, -(this.lastBearing - s));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = ri({ geometry: r })), s = _t(this.selectedGeometryCentroid, n), !this.lastBearing) return void (this.lastBearing = s + 180);
      (function(h, g) {
        if (g === 0 || g === 360 || g === -360) return h;
        const f = ri(h);
        (h.geometry.type === "Polygon" ? h.geometry.coordinates[0] : h.geometry.coordinates).forEach((v) => {
          const w = _t(f, v) + g, I = (function(_, x) {
            _[0] += _[0] - x[0] > 180 ? -360 : x[0] - _[0] > 180 ? 360 : 0;
            const y = _i, m = x[1] * Math.PI / 180, C = _[1] * Math.PI / 180, D = C - m;
            let b = Math.abs(_[0] - x[0]) * Math.PI / 180;
            b > Math.PI && (b -= 2 * Math.PI);
            const M = Math.log(Math.tan(C / 2 + Math.PI / 4) / Math.tan(m / 2 + Math.PI / 4)), E = Math.abs(M) > 1e-11 ? D / M : Math.cos(m);
            return Math.sqrt(D * D + E * E * b * b) * y;
          })(f, v), P = Fi(f, I, w);
          v[0] = P[0], v[1] = P[1];
        });
      })(a, -(this.lastBearing - (s + 180)));
    }
    const l = r.type === "Polygon" ? r.coordinates[0] : r.coordinates;
    l.forEach((h) => {
      h[0] = K(h[0], this.coordinatePrecision), h[1] = K(h[1], this.coordinatePrecision);
    });
    const d = this.midPoints.getUpdated(l) || [], c = this.selectionPoints.getUpdated(l) || [], u = this.coordinatePoints.getUpdated(t, l) || [];
    if (i && !i({ id: t, type: "Feature", geometry: r, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: ie.Provisional })) return false;
    this.store.updateGeometry([{ id: t, geometry: r }, ...c, ...d, ...u]), this.projection === "web-mercator" ? this.lastBearing = s : this.projection === "globe" && (this.lastBearing = s + 180);
  }
}
class bn extends se {
  constructor(e, t) {
    super(e), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = e, this.dragCoordinateResizeBehavior = t;
  }
  scale(e, t, i) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const r = this.dragCoordinateResizeBehavior.getDraggableIndex(e, t);
      this.dragCoordinateResizeBehavior.startDragging(t, r);
    }
    this.dragCoordinateResizeBehavior.drag(e, "center-fixed", i);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function Ti({ coordinates: o, originX: e, originY: t, xScale: i, yScale: r }) {
  i === 1 && r === 1 || o.forEach((n) => {
    const { x: s, y: a } = Y(n[0], n[1]), l = e + (s - e) * i, d = t + (a - t) * r, { lng: c, lat: u } = Ee(l, d);
    n[0] = c, n[1] = u;
  });
}
class xn extends se {
  constructor(e, t, i, r, n) {
    super(e), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = e, this.pixelDistance = t, this.selectionPoints = i, this.midPoints = r, this.coordinatePoints = n;
  }
  getClosestCoordinate(e, t) {
    const i = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let r;
    if (t.type === "LineString") r = t.coordinates;
    else {
      if (t.type !== "Polygon") return i;
      r = t.coordinates[0];
    }
    for (let n = 0; n < r.length; n++) {
      const s = this.pixelDistance.measure(e, r[n]);
      if (s < this.pointerDistance && s < i.dist) {
        const a = t.type === "Polygon" && (n === r.length - 1 || n === 0);
        i.dist = s, i.index = a ? 0 : n, i.isFirstOrLastPolygonCoord = a;
      }
    }
    return i;
  }
  isValidDragWebMercator(e, t, i) {
    switch (e) {
      case 0:
        if (t <= 0 || i >= 0) return false;
        break;
      case 1:
        if (i >= 0) return false;
        break;
      case 2:
        if (t >= 0 || i >= 0) return false;
        break;
      case 3:
        if (t >= 0) return false;
        break;
      case 4:
        if (t >= 0 || i <= 0) return false;
        break;
      case 5:
        if (i <= 0) return false;
        break;
      case 6:
        if (t <= 0 || i <= 0) return false;
        break;
      case 7:
        if (t <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const e = this.getFeature(this.draggedCoordinate.id);
    if (!e) return null;
    const t = this.getNormalisedCoordinates(e.geometry);
    return { boundingBox: this.getBBoxWebMercator(t), feature: e, updatedCoords: t, selectedCoordinate: t[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(e) {
    const t = this.getSelectedFeatureDataWebMercator();
    if (!t) return null;
    const { feature: i, boundingBox: r, updatedCoords: n, selectedCoordinate: s } = t, a = Rt(i);
    if (!a) return null;
    const l = Y(s[0], s[1]), { closestBBoxIndex: d } = this.getIndexesWebMercator(r, l), c = Y(e.lng, e.lat);
    return this.scaleWebMercator({ closestBBoxIndex: d, updatedCoords: n, webMercatorCursor: c, webMercatorSelected: l, webMercatorOrigin: a }), n;
  }
  centerFixedWebMercatorDrag(e) {
    const t = this.getSelectedFeatureDataWebMercator();
    if (!t) return null;
    const { feature: i, boundingBox: r, updatedCoords: n, selectedCoordinate: s } = t, a = Rt(i);
    if (!a) return null;
    const l = Y(s[0], s[1]), { closestBBoxIndex: d } = this.getIndexesWebMercator(r, l), c = Y(e.lng, e.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: d, updatedCoords: n, webMercatorCursor: c, webMercatorSelected: l, webMercatorOrigin: a }), n;
  }
  scaleFixedWebMercator({ closestBBoxIndex: e, webMercatorOrigin: t, webMercatorSelected: i, webMercatorCursor: r, updatedCoords: n }) {
    if (!this.isValidDragWebMercator(e, t.x - r.x, t.y - r.y)) return null;
    let s = pe(t, r) / pe(t, i);
    return s < 0 && (s = this.minimumScale), Ti({ coordinates: n, originX: t.x, originY: t.y, xScale: s, yScale: s }), n;
  }
  oppositeFixedWebMercatorDrag(e) {
    const t = this.getSelectedFeatureDataWebMercator();
    if (!t) return null;
    const { boundingBox: i, updatedCoords: r, selectedCoordinate: n } = t, s = Y(n[0], n[1]), { oppositeBboxIndex: a, closestBBoxIndex: l } = this.getIndexesWebMercator(i, s), d = { x: i[a][0], y: i[a][1] }, c = Y(e.lng, e.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: l, updatedCoords: r, webMercatorCursor: c, webMercatorSelected: s, webMercatorOrigin: d }), r;
  }
  oppositeWebMercatorDrag(e) {
    const t = this.getSelectedFeatureDataWebMercator();
    if (!t) return null;
    const { boundingBox: i, updatedCoords: r, selectedCoordinate: n } = t, s = Y(n[0], n[1]), { oppositeBboxIndex: a, closestBBoxIndex: l } = this.getIndexesWebMercator(i, s), d = { x: i[a][0], y: i[a][1] }, c = Y(e.lng, e.lat);
    return this.scaleWebMercator({ closestBBoxIndex: l, updatedCoords: r, webMercatorCursor: c, webMercatorSelected: s, webMercatorOrigin: d }), r;
  }
  scaleWebMercator({ closestBBoxIndex: e, webMercatorOrigin: t, webMercatorSelected: i, webMercatorCursor: r, updatedCoords: n }) {
    const s = t.x - r.x, a = t.y - r.y;
    if (!this.isValidDragWebMercator(e, s, a)) return null;
    let l = 1;
    s !== 0 && e !== 1 && e !== 5 && (l = 1 - (t.x - i.x - s) / s);
    let d = 1;
    return a !== 0 && e !== 3 && e !== 7 && (d = 1 - (t.y - i.y - a) / a), this.validateScale(l, d) ? (l < 0 && (l = this.minimumScale), d < 0 && (d = this.minimumScale), this.performWebMercatorScale(n, t.x, t.y, l, d), n) : null;
  }
  getFeature(e) {
    if (this.draggedCoordinate.id === null) return null;
    const t = this.store.getGeometryCopy(e);
    return t.type !== "Polygon" && t.type !== "LineString" ? null : { id: e, type: "Feature", geometry: t, properties: {} };
  }
  getNormalisedCoordinates(e) {
    return e.type === "Polygon" ? e.coordinates[0] : e.coordinates;
  }
  validateScale(e, t) {
    const i = !isNaN(e) && t < Number.MAX_SAFE_INTEGER, r = !isNaN(t) && t < Number.MAX_SAFE_INTEGER;
    return i && r;
  }
  performWebMercatorScale(e, t, i, r, n) {
    e.forEach((s) => {
      const { x: a, y: l } = Y(s[0], s[1]), d = t + (a - t) * r, c = i + (l - i) * n, { lng: u, lat: h } = Ee(d, c);
      s[0] = u, s[1] = h;
    });
  }
  getBBoxWebMercator(e) {
    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (e = e.map((a) => {
      const { x: l, y: d } = Y(a[0], a[1]);
      return [l, d];
    })).forEach(([a, l]) => {
      a < t[0] && (t[0] = a), l < t[1] && (t[1] = l), a > t[2] && (t[2] = a), l > t[3] && (t[3] = l);
    });
    const [i, r, n, s] = t;
    return [[i, s], [(i + n) / 2, s], [n, s], [n, s + (r - s) / 2], [n, r], [(i + n) / 2, r], [i, r], [i, s + (r - s) / 2]];
  }
  getIndexesWebMercator(e, t) {
    let i, r = 1 / 0;
    for (let n = 0; n < e.length; n++) {
      const s = pe({ x: t.x, y: t.y }, { x: e[n][0], y: e[n][1] });
      s < r && (i = n, r = s);
    }
    if (i === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[i], closestBBoxIndex: i };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(e, t) {
    this.draggedCoordinate = { id: e, index: t };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(e, t) {
    const i = this.store.getGeometryCopy(t), r = this.getClosestCoordinate(e, i);
    return r.index === -1 ? -1 : r.index;
  }
  drag(e, t, i) {
    if (!this.draggedCoordinate.id) return false;
    const r = this.getFeature(this.draggedCoordinate.id);
    if (!r) return false;
    let n = null;
    if (t === "center" ? n = this.centerWebMercatorDrag(e) : t === "opposite" ? n = this.oppositeWebMercatorDrag(e) : t === "center-fixed" ? n = this.centerFixedWebMercatorDrag(e) : t === "opposite-fixed" && (n = this.oppositeFixedWebMercatorDrag(e)), !n) return false;
    for (let c = 0; c < n.length; c++) {
      const u = n[c];
      if (u[0] = K(u[0], this.coordinatePrecision), u[1] = K(u[1], this.coordinatePrecision), !$t(u, this.coordinatePrecision)) return false;
    }
    const s = this.midPoints.getUpdated(n) || [], a = this.selectionPoints.getUpdated(n) || [], l = this.coordinatePoints.getUpdated(r.id, n) || [], d = { type: r.geometry.type, coordinates: r.geometry.type === "Polygon" ? [n] : n };
    return !(i && !i({ id: this.draggedCoordinate.id, type: "Feature", geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: ie.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: d }, ...a, ...s, ...l]), 0));
  }
}
const Cn = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, ni = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class wn extends Gr {
  constructor(e) {
    super(e, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = Cn, this.cursors = ni, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(e);
  }
  updateOptions(e) {
    if (super.updateOptions(e), this.cursors = e && e.cursors ? te({}, this.cursors, e.cursors) : ni, (e == null ? void 0 : e.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : e != null && e.keyEvents && (this.keyEvents = te({}, this.keyEvents, e.keyEvents)), (e == null ? void 0 : e.dragEventThrottle) !== void 0 && (this.dragEventThrottle = e.dragEventThrottle), (e == null ? void 0 : e.allowManualDeselection) !== void 0 && (this.allowManualDeselection = e.allowManualDeselection), e != null && e.flags) {
      this.flags = te({}, this.flags, e.flags), this.validations = {};
      for (const t in this.flags) {
        const i = this.flags[t].feature;
        i && i.validation && (this.validations[t] = i.validation);
      }
    }
  }
  selectFeature(e) {
    this.select(e, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(e) {
    this.pixelDistance = new st(e), this.clickBoundingBox = new nt(e), this.featuresAtMouseEvent = new fn(e, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new gn(e), this.coordinatePoints = new cn(e), this.midPoints = new pn(e, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new It(e, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new Ei(e, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new yn(e, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new mn(e, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new vn(e, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new xn(e, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new bn(e, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const e = this.selected.filter((t) => this.store.has(t)).map((t) => ({ id: t, property: ee.SELECTED, value: false }));
    this.store.updateProperty(e), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(e) {
    if (!this.selectionPoints.ids.length) return;
    let t, i = 1 / 0;
    if (this.selectionPoints.ids.forEach((h) => {
      const g = this.store.getGeometryCopy(h), f = this.pixelDistance.measure(e, g.coordinates);
      f < this.pointerDistance && f < i && (i = f, t = this.store.getPropertiesCopy(h));
    }), !t) return;
    const r = t.selectionPointFeatureId, n = t.index, s = this.store.getPropertiesCopy(r), a = this.flags[s.mode], l = this.validations[s.mode];
    if (!(a && a.feature && a.feature.coordinates && a.feature.coordinates.deletable)) return;
    const d = this.store.getGeometryCopy(r);
    let c;
    if (d.type === "Polygon") {
      if (c = d.coordinates[0], c.length <= 4) return;
    } else if (d.type === "LineString" && (c = d.coordinates, c.length <= 2)) return;
    if (!c || (d.type !== "Polygon" || n !== 0 && n !== c.length - 1 ? c.splice(n, 1) : (c.shift(), c.pop(), c.push([c[0][0], c[0][1]])), l && !l({ id: r, type: "Feature", geometry: d, properties: s }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: ie.Commit }).valid)) return;
    const u = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(u), this.store.updateGeometry([{ id: r, geometry: d }]), s.coordinatePointIds && this.coordinatePoints.createOrUpdate(r), this.selectionPoints.create(c, d.type, r), a && a.feature && a.feature.coordinates && a.feature.coordinates.midpoints && this.midPoints.create(c, r, this.coordinatePrecision);
  }
  select(e, t = true) {
    if (this.selected[0] === e) return;
    const { mode: i } = this.store.getPropertiesCopy(e), r = this.flags[i];
    if (!r || !r.feature) return;
    const n = this.selected[0];
    if (n) {
      if (n === e) return;
      this.deselect();
    }
    t && this.setCursor(this.cursors.pointerOver), this.selected = [e], this.store.updateProperty([{ id: e, property: ee.SELECTED, value: true }]), this.onSelect(e);
    const { type: s, coordinates: a } = this.store.getGeometryCopy(e);
    if (s !== "LineString" && s !== "Polygon") return;
    const l = s === "LineString" ? a : a[0];
    l && r && r.feature.coordinates && (this.selectionPoints.create(l, s, e), r.feature.coordinates.midpoints && this.midPoints.create(l, e, this.coordinatePrecision));
  }
  onLeftClick(e) {
    const { clickedFeature: t, clickedMidPoint: i } = this.featuresAtMouseEvent.find(e, this.selected.length > 0);
    if (this.selected.length && i) this.midPoints.insert(this.selected[0], i.id, this.coordinatePrecision);
    else if (t && t.id) this.select(t.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(e) {
    e.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, e) || e.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e) ? this.onRightClick(e) : e.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, e) && this.onLeftClick(e);
  }
  canScale(e) {
    return this.keyEvents.scale && this.keyEvents.scale.every((t) => e.heldKeys.includes(t));
  }
  canRotate(e) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((t) => e.heldKeys.includes(t));
  }
  preventDefaultKeyEvent(e) {
    const t = this.canRotate(e), i = this.canScale(e);
    (t || i) && e.preventDefault();
  }
  onKeyDown(e) {
    this.preventDefaultKeyEvent(e);
  }
  onKeyUp(e) {
    if (this.preventDefaultKeyEvent(e), this.keyEvents.delete && e.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const t = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([t]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && e.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(e, t) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, e) || !this.selected.length) return;
    const i = this.store.getPropertiesCopy(this.selected[0]), r = this.flags[i.mode];
    if (!(r && r.feature && (r.feature.draggable || r.feature.coordinates && r.feature.coordinates.draggable || r.feature.coordinates && r.feature.coordinates.resizable || r.feature.coordinates && typeof r.feature.coordinates.midpoints == "object" && r.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const n = this.selected[0], s = this.dragCoordinate.getDraggableIndex(e, n);
    if (r && r.feature && r.feature.coordinates && (r.feature.coordinates.draggable || r.feature.coordinates.resizable) && s !== -1) return this.setCursor(this.cursors.dragStart), r.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(n, s) : this.dragCoordinate.startDragging(n, s), void t(false);
    if (r && r.feature && r.feature.coordinates && typeof r.feature.coordinates.midpoints == "object" && r.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: a } = this.featuresAtMouseEvent.find(e, this.selected.length > 0);
      if (this.selected.length && a) {
        this.midPoints.insert(n, a.id, this.coordinatePrecision);
        const l = this.dragCoordinate.getDraggableIndex(e, n);
        return this.dragCoordinate.startDragging(n, l), void t(false);
      }
    }
    return r && r.feature && r.feature.draggable && this.dragFeature.canDrag(e, n) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(e, n), void t(false)) : void 0;
  }
  onDrag(e, t) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, e)) return;
    const i = this.selected[0];
    if (!i) return;
    const r = this.store.getPropertiesCopy(i), n = this.flags[r.mode], s = (n && n.feature && n.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const a = this.validations[r.mode];
    if (n && n.feature && n.feature.rotateable && this.canRotate(e)) return t(false), void this.rotateFeature.rotate(e, i, a);
    if (n && n.feature && n.feature.scaleable && this.canScale(e)) return t(false), void this.scaleFeature.scale(e, i, a);
    if (this.dragCoordinateResizeFeature.isDragging() && n.feature && n.feature.coordinates && n.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return t(false), void this.dragCoordinateResizeFeature.drag(e, n.feature.coordinates.resizable, a);
    }
    if (this.dragCoordinate.isDragging()) {
      var l;
      const d = (l = n.feature) == null || (l = l.coordinates) == null ? void 0 : l.snappable;
      let c = { toCoordinate: false };
      return d === true ? c = { toCoordinate: true } : typeof d == "object" && (c = d), void this.dragCoordinate.drag(e, s, a, c);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(e, a) : t(true);
  }
  onDragEnd(e, t) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), t(true));
  }
  onMouseMove(e) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let t = false;
    this.midPoints.ids.forEach((n) => {
      if (t) return;
      const s = this.store.getGeometryCopy(n);
      this.pixelDistance.measure(e, s.coordinates) < this.pointerDistance && (t = true);
    });
    let i = false;
    if (this.selectionPoints.ids.forEach((n) => {
      const s = this.store.getGeometryCopy(n);
      this.pixelDistance.measure(e, s.coordinates) < this.pointerDistance && (t = false, i = true);
    }), t) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: r } = this.featuresAtMouseEvent.find(e, true);
    this.setCursor(this.selected.length > 0 && (r && r.id === this.selected[0] || i) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(e) {
    const t = te({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (e.properties.mode === this.mode && e.geometry.type === "Point") {
      if (e.properties.selectionPoint) return t.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, t.pointColor, e), t.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, t.pointOutlineColor, e), t.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, t.pointWidth, e), t.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, e), t.zIndex = 30, t;
      if (e.properties.midPoint) return t.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, t.pointColor, e), t.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, t.pointOutlineColor, e), t.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, e), t.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, e), t.zIndex = 50, t;
    } else if (e.properties[ee.SELECTED]) {
      if (e.geometry.type === "Polygon") return t.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, t.polygonFillColor, e), t.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, t.polygonOutlineWidth, e), t.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, t.polygonOutlineColor, e), t.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, t.polygonFillOpacity, e), t.zIndex = it, t;
      if (e.geometry.type === "LineString") return t.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, t.lineStringColor, e), t.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, t.lineStringWidth, e), t.zIndex = it, t;
      if (e.geometry.type === "Point") return t.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, t.pointWidth, e), t.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, t.pointColor, e), t.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, t.pointOutlineColor, e), t.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, t.pointOutlineWidth, e), t.zIndex = it, t;
    }
    return t;
  }
  afterFeatureUpdated(e) {
    if (this.selected.length && e.id === this.selected[0]) {
      var t, i;
      const r = this.flags[e.properties.mode];
      if (r == null || (t = r.feature) == null || !t.coordinates) return;
      const n = e.geometry.type, s = e.id;
      let a;
      if (this.selectionPoints.delete(), this.midPoints.delete(), n === "Polygon") a = e.geometry.coordinates[0];
      else {
        if (n !== "LineString") return;
        a = e.geometry.coordinates;
      }
      this.selectionPoints.create(a, n, s), r != null && (i = r.feature) != null && (i = i.coordinates) != null && i.midpoints && this.midPoints.create(n === "Polygon" ? e.geometry.coordinates[0] : e.geometry.coordinates, s, this.coordinatePrecision);
    }
  }
}
class Pn extends ut {
  constructor(...e) {
    super(...e), this.type = De.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return te({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function Li(o, e, t, i, r) {
  for (; i > t; ) {
    if (i - t > 600) {
      const l = i - t + 1, d = e - t + 1, c = Math.log(l), u = 0.5 * Math.exp(2 * c / 3), h = 0.5 * Math.sqrt(c * u * (l - u) / l) * (d - l / 2 < 0 ? -1 : 1);
      Li(o, e, Math.max(t, Math.floor(e - d * u / l + h)), Math.min(i, Math.floor(e + (l - d) * u / l + h)), r);
    }
    const n = o[e];
    let s = t, a = i;
    for (Le(o, t, e), r(o[i], n) > 0 && Le(o, t, i); s < a; ) {
      for (Le(o, s, a), s++, a--; r(o[s], n) < 0; ) s++;
      for (; r(o[a], n) > 0; ) a--;
    }
    r(o[t], n) === 0 ? Le(o, t, a) : (a++, Le(o, a, i)), a <= e && (t = a + 1), e <= a && (i = a - 1);
  }
}
function Le(o, e, t) {
  const i = o[e];
  o[e] = o[t], o[t] = i;
}
function ke(o, e) {
  je(o, 0, o.children.length, e, o);
}
function je(o, e, t, i, r) {
  r || (r = Me([])), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let n = e; n < t; n++) {
    const s = o.children[n];
    $e(r, o.leaf ? i(s) : s);
  }
  return r;
}
function $e(o, e) {
  return o.minX = Math.min(o.minX, e.minX), o.minY = Math.min(o.minY, e.minY), o.maxX = Math.max(o.maxX, e.maxX), o.maxY = Math.max(o.maxY, e.maxY), o;
}
function kn(o, e) {
  return o.minX - e.minX;
}
function Sn(o, e) {
  return o.minY - e.minY;
}
function ft(o) {
  return (o.maxX - o.minX) * (o.maxY - o.minY);
}
function et(o) {
  return o.maxX - o.minX + (o.maxY - o.minY);
}
function Mn(o, e) {
  const t = Math.max(o.minX, e.minX), i = Math.max(o.minY, e.minY), r = Math.min(o.maxX, e.maxX), n = Math.min(o.maxY, e.maxY);
  return Math.max(0, r - t) * Math.max(0, n - i);
}
function mt(o, e) {
  return o.minX <= e.minX && o.minY <= e.minY && e.maxX <= o.maxX && e.maxY <= o.maxY;
}
function tt(o, e) {
  return e.minX <= o.maxX && e.minY <= o.maxY && e.maxX >= o.minX && e.maxY >= o.minY;
}
function Me(o) {
  return { children: o, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function si(o, e, t, i, r) {
  const n = [e, t];
  for (; n.length; ) {
    if ((t = n.pop()) - (e = n.pop()) <= i) continue;
    const s = e + Math.ceil((t - e) / i / 2) * i;
    Li(o, s, e, t, r), n.push(e, s, s, t);
  }
}
class In {
  constructor(e) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!tt(e, t)) return i;
    const r = this.toBBox, n = [];
    for (; t; ) {
      for (let s = 0; s < t.children.length; s++) {
        const a = t.children[s], l = t.leaf ? r(a) : a;
        tt(e, l) && (t.leaf ? i.push(a) : mt(e, l) ? this._all(a, i) : n.push(a));
      }
      t = n.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (tt(e, t)) {
      const i = [];
      for (; t; ) {
        for (let r = 0; r < t.children.length; r++) {
          const n = t.children[r], s = t.leaf ? this.toBBox(n) : n;
          if (tt(e, s)) {
            if (t.leaf || mt(e, s)) return true;
            i.push(n);
          }
        }
        t = i.pop();
      }
    }
    return false;
  }
  load(e) {
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++) this.insert(e[i]);
      return;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (this.data.children.length) if (this.data.height === t.height) this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const i = this.data;
        this.data = t, t = i;
      }
      this._insert(t, this.data.height - t.height - 1, true);
    }
    else this.data = t;
  }
  insert(e) {
    this._insert(e, this.data.height - 1);
  }
  clear() {
    this.data = Me([]);
  }
  remove(e) {
    let t = this.data;
    const i = this.toBBox(e), r = [], n = [];
    let s, a, l = false;
    for (; t || r.length; ) {
      if (t || (t = r.pop(), a = r[r.length - 1], s = n.pop(), l = true), t.leaf) {
        const d = t.children.indexOf(e);
        d !== -1 && (t.children.splice(d, 1), r.push(t), this._condense(r));
      }
      l || t.leaf || !mt(t, i) ? a ? (s++, t = a.children[s], l = false) : t = null : (r.push(t), n.push(s), s = 0, a = t, t = t.children[0]);
    }
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  _all(e, t) {
    const i = [];
    for (; e; ) e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
    return t;
  }
  _build(e, t, i, r) {
    const n = i - t + 1;
    let s, a = this._maxEntries;
    if (n <= a) return s = Me(e.slice(t, i + 1)), ke(s, this.toBBox), s;
    r || (r = Math.ceil(Math.log(n) / Math.log(a)), a = Math.ceil(n / Math.pow(a, r - 1))), s = Me([]), s.leaf = false, s.height = r;
    const l = Math.ceil(n / a), d = l * Math.ceil(Math.sqrt(a));
    si(e, t, i, d, this.compareMinX);
    for (let c = t; c <= i; c += d) {
      const u = Math.min(c + d - 1, i);
      si(e, c, u, l, this.compareMinY);
      for (let h = c; h <= u; h += l) {
        const g = Math.min(h + l - 1, u);
        s.children.push(this._build(e, h, g, r - 1));
      }
    }
    return ke(s, this.toBBox), s;
  }
  _chooseSubtree(e, t, i, r) {
    for (; r.push(t), !t.leaf && r.length - 1 !== i; ) {
      let a, l = 1 / 0, d = 1 / 0;
      for (let c = 0; c < t.children.length; c++) {
        const u = t.children[c], h = ft(u), g = (n = e, s = u, (Math.max(s.maxX, n.maxX) - Math.min(s.minX, n.minX)) * (Math.max(s.maxY, n.maxY) - Math.min(s.minY, n.minY)) - h);
        g < d ? (d = g, l = h < l ? h : l, a = u) : g === d && h < l && (l = h, a = u);
      }
      t = a || t.children[0];
    }
    var n, s;
    return t;
  }
  _insert(e, t, i) {
    const r = i ? e : this.toBBox(e), n = [], s = this._chooseSubtree(r, this.data, t, n);
    for (s.children.push(e), $e(s, r); t >= 0 && n[t].children.length > this._maxEntries; ) this._split(n, t), t--;
    this._adjustParentBBoxes(r, n, t);
  }
  _split(e, t) {
    const i = e[t], r = i.children.length, n = this._minEntries;
    this._chooseSplitAxis(i, n, r);
    const s = this._chooseSplitIndex(i, n, r), a = Me(i.children.splice(s, i.children.length - s));
    a.height = i.height, a.leaf = i.leaf, ke(i, this.toBBox), ke(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    this.data = Me([e, t]), this.data.height = e.height + 1, this.data.leaf = false, ke(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let r, n = 1 / 0, s = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const l = je(e, 0, a, this.toBBox), d = je(e, a, i, this.toBBox), c = Mn(l, d), u = ft(l) + ft(d);
      c < n ? (n = c, r = a, s = u < s ? u : s) : c === n && u < s && (s = u, r = a);
    }
    return r || i - t;
  }
  _chooseSplitAxis(e, t, i) {
    const r = e.leaf ? this.compareMinX : kn, n = e.leaf ? this.compareMinY : Sn;
    this._allDistMargin(e, t, i, r) < this._allDistMargin(e, t, i, n) && e.children.sort(r);
  }
  _allDistMargin(e, t, i, r) {
    e.children.sort(r);
    const n = this.toBBox, s = je(e, 0, t, n), a = je(e, i - t, i, n);
    let l = et(s) + et(a);
    for (let d = t; d < i - t; d++) {
      const c = e.children[d];
      $e(s, e.leaf ? n(c) : c), l += et(s);
    }
    for (let d = i - t - 1; d >= t; d--) {
      const c = e.children[d];
      $e(a, e.leaf ? n(c) : c), l += et(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let r = i; r >= 0; r--) $e(t[r], e);
  }
  _condense(e) {
    for (let t, i = e.length - 1; i >= 0; i--) e[i].children.length === 0 ? i > 0 ? (t = e[i - 1].children, t.splice(t.indexOf(e[i]), 1)) : this.clear() : ke(e[i], this.toBBox);
  }
}
class _n {
  constructor(e) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new In(e && e.maxEntries ? e.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(e, t) {
    this.idToNode.set(e.id, t), this.nodeToId.set(t, e.id);
  }
  toBBox(e) {
    const t = [], i = [];
    let r;
    if (e.geometry.type === "Polygon") r = e.geometry.coordinates[0];
    else if (e.geometry.type === "LineString") r = e.geometry.coordinates;
    else {
      if (e.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      r = [e.geometry.coordinates];
    }
    for (let a = 0; a < r.length; a++) i.push(r[a][1]), t.push(r[a][0]);
    const n = Math.min(...i), s = Math.max(...i);
    return { minX: Math.min(...t), minY: n, maxX: Math.max(...t), maxY: s };
  }
  insert(e) {
    if (this.idToNode.get(String(e.id))) throw new Error("Feature already exists");
    const t = this.toBBox(e);
    this.setMaps(e, t), this.tree.insert(t);
  }
  load(e) {
    const t = [], i = /* @__PURE__ */ new Set();
    e.forEach((r) => {
      const n = this.toBBox(r);
      if (this.setMaps(r, n), i.has(String(r.id))) throw new Error(`Duplicate feature ID found ${r.id}`);
      i.add(String(r.id)), t.push(n);
    }), this.tree.load(t);
  }
  update(e) {
    this.remove(e.id);
    const t = this.toBBox(e);
    this.setMaps(e, t), this.tree.insert(t);
  }
  remove(e) {
    const t = this.idToNode.get(e);
    if (!t) throw new Error(`${e} not inserted into the spatial index`);
    this.tree.remove(t);
  }
  clear() {
    this.tree.clear();
  }
  search(e) {
    return this.tree.search(this.toBBox(e)).map((t) => this.nodeToId.get(t));
  }
  collides(e) {
    return this.tree.collides(this.toBBox(e));
  }
}
const Dn = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(o) {
  const e = 16 * Math.random() | 0;
  return (o == "x" ? e : 3 & e | 8).toString(16);
}), isValidId: (o) => typeof o == "string" && o.length === 36 };
class Rn {
  constructor(e) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new _n(), this.tracked = !e || e.tracked !== false, this.idStrategy = e && e.idStrategy ? e.idStrategy : Dn;
  }
  clone(e) {
    return JSON.parse(JSON.stringify(e));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(e) {
    return !!this.store[e];
  }
  load(e, t, i, r) {
    if (e.length === 0) return [];
    let n = this.clone(e);
    const s = [], a = [];
    return n = n.filter((l) => {
      l.id == null && (l.id = this.idStrategy.getId());
      const d = l.id;
      if (t) {
        const c = t(l);
        if (!c.valid) return a.push({ id: d, valid: false, reason: c.reason }), false;
      }
      if (this.tracked) {
        if (l.properties.createdAt) {
          if (!Kt(l.properties.createdAt)) return a.push({ id: l.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else l.properties.createdAt = +/* @__PURE__ */ new Date();
        if (l.properties.updatedAt) {
          if (!Kt(l.properties.updatedAt)) return a.push({ id: l.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else l.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(d) ? (a.push({ id: d, valid: false, reason: `Feature already exists with this id: ${d}` }), false) : (this.store[d] = l, s.push(d), i && i(l), a.push({ id: d, valid: true }), true);
    }), this.spatialIndex.load(n), s.length > 0 && this._onChange(s, "create", r), a;
  }
  search(e, t) {
    const i = this.spatialIndex.search(e).map((r) => this.store[r]);
    return this.clone(t ? i.filter(t) : i);
  }
  registerOnChange(e) {
    this._onChange = (t, i, r) => {
      e(t, i, r);
    };
  }
  getGeometryCopy(e) {
    const t = this.store[e];
    if (!t) throw new Error(`No feature with this id (${e}), can not get geometry copy`);
    return this.clone(t.geometry);
  }
  getPropertiesCopy(e) {
    const t = this.store[e];
    if (!t) throw new Error(`No feature with this id (${e}), can not get properties copy`);
    return this.clone(t.properties);
  }
  updateProperty(e, t) {
    const i = [];
    e.forEach(({ id: r, property: n, value: s }) => {
      const a = this.store[r];
      if (!a) throw new Error(`No feature with this (${r}), can not update geometry`);
      i.push(r), s === void 0 ? delete a.properties[n] : a.properties[n] = s, this.tracked && (a.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(i, "update", t);
  }
  updateGeometry(e, t) {
    const i = [];
    e.forEach(({ id: r, geometry: n }) => {
      i.push(r);
      const s = this.store[r];
      if (!s) throw new Error(`No feature with this (${r}), can not update geometry`);
      s.geometry = this.clone(n), this.spatialIndex.update(s), this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(i, "update", t);
  }
  create(e, t) {
    const i = [];
    return e.forEach(({ geometry: r, properties: n }) => {
      let s, a = te({}, n);
      this.tracked && (s = +/* @__PURE__ */ new Date(), n ? (a.createdAt = typeof n.createdAt == "number" ? n.createdAt : s, a.updatedAt = typeof n.updatedAt == "number" ? n.updatedAt : s) : a = { createdAt: s, updatedAt: s });
      const l = this.getId(), d = { id: l, type: "Feature", geometry: r, properties: a };
      this.store[l] = d, this.spatialIndex.insert(d), i.push(l);
    }), this._onChange && this._onChange([...i], "create", t), i;
  }
  delete(e, t) {
    e.forEach((i) => {
      if (!this.store[i]) throw new Error(`No feature with id ${i}, can not delete`);
      delete this.store[i], this.spatialIndex.remove(i);
    }), this._onChange && this._onChange([...e], "delete", t);
  }
  copy(e) {
    return this.clone(this.store[e]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((e) => this.store[e]));
  }
  copyAllWhere(e) {
    return this.clone(Object.keys(this.store).map((t) => this.store[t]).filter((t) => t.properties && e(t.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class Se {
  constructor({ name: e, callback: t, unregister: i, register: r }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = e, this.register = () => {
      this.registered || (this.registered = true, r(t));
    }, this.unregister = () => {
      this.register && (this.registered = false, i(t));
    }, this.callback = t;
  }
}
var En = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(o) {
    this._nextKeyUpIsContextMenu = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof o.minPixelDragDistance == "number" ? o.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof o.minPixelDragDistanceSelecting == "number" ? o.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof o.minPixelDragDistanceDrawing == "number" ? o.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof o.coordinatePrecision == "number" ? o.coordinatePrecision : 9;
  }
  getButton(o) {
    return o.button === -1 ? "neither" : o.button === 0 ? "left" : o.button === 1 ? "middle" : o.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(o) {
    const e = this.getMapEventElement(), { left: t, top: i } = e.getBoundingClientRect();
    return { containerX: o.clientX - t, containerY: o.clientY - i };
  }
  getDrawEventFromEvent(o, e = false) {
    const t = this.getLngLatFromEvent(o);
    if (!t) return null;
    const { lng: i, lat: r } = t, { containerX: n, containerY: s } = this.getMapElementXYPosition(o), a = this.getButton(o), l = Array.from(this._heldKeys);
    return { lng: K(i, this._coordinatePrecision), lat: K(r, this._coordinatePrecision), containerX: n, containerY: s, button: a, heldKeys: l, isContextMenu: e };
  }
  register(o) {
    this._currentModeCallbacks = o, this._listeners = this.getAdapterListeners(), this._listeners.forEach((e) => {
      e.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new Se({ name: "pointerdown", callback: (o) => {
      if (!this._currentModeCallbacks || !o.isPrimary) return;
      const e = this.getDrawEventFromEvent(o);
      e && (this._dragState = "pre-dragging", this._lastDrawEvent = e);
    }, register: (o) => {
      this.getMapEventElement().addEventListener("pointerdown", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("pointerdown", o);
    } }), new Se({ name: "pointermove", callback: (o) => {
      if (!this._currentModeCallbacks || !o.isPrimary) return;
      o.preventDefault();
      const e = this.getDrawEventFromEvent(o);
      if (e) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(e), this._lastDrawEvent = e;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const t = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, i = { x: e.containerX, y: e.containerY }, r = this._currentModeCallbacks.getState(), n = pe(t, i);
        let s = false;
        if (s = r === "drawing" ? n < this._minPixelDragDistanceDrawing : r === "selecting" ? n < this._minPixelDragDistanceSelecting : n < this._minPixelDragDistance, s) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(e, (a) => {
          this.setDraggability.bind(this)(a);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(e, (t) => {
        this.setDraggability.bind(this)(t);
      });
    }, register: (o) => {
      this.getMapEventElement().addEventListener("pointermove", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("pointermove", o);
    } }), new Se({ name: "contextmenu", callback: (o) => {
      this._currentModeCallbacks && (o.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (o) => {
      this.getMapEventElement().addEventListener("contextmenu", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("contextmenu", o);
    } }), new Se({ name: "pointerup", callback: (o) => {
      if (!this._currentModeCallbacks || o.target !== this.getMapEventElement() || !o.isPrimary) return;
      const e = this.getDrawEventFromEvent(o);
      e && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(e, (t) => {
        this.setDraggability.bind(this)(t);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (e.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(e)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (o) => {
      this.getMapEventElement().addEventListener("pointerup", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("pointerup", o);
    } }), new Se({ name: "keyup", callback: (o) => {
      this._currentModeCallbacks && (this._heldKeys.delete(o.key), this._currentModeCallbacks.onKeyUp({ key: o.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => o.preventDefault() }));
    }, register: (o) => {
      this.getMapEventElement().addEventListener("keyup", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("keyup", o);
    } }), new Se({ name: "keydown", callback: (o) => {
      this._currentModeCallbacks && (this._heldKeys.add(o.key), this._currentModeCallbacks.onKeyDown({ key: o.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => o.preventDefault() }));
    }, register: (o) => {
      this.getMapEventElement().addEventListener("keydown", o);
    }, unregister: (o) => {
      this.getMapEventElement().removeEventListener("keydown", o);
    } })];
  }
  unregister() {
    this._listeners.forEach((o) => {
      o.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
class Fn {
  constructor(e) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = e.adapter, this._mode = new Pn();
    const t = /* @__PURE__ */ new Set(), i = e.modes.reduce((c, u) => {
      if (t.has(u.mode)) throw new Error(`There is already a ${u.mode} mode provided`);
      return t.add(u.mode), c[u.mode] = u, c;
    }, {}), r = Object.keys(i);
    if (r.length === 0) throw new Error("No modes provided");
    r.forEach((c) => {
      if (i[c].type === De.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = c;
      }
    }), this._modes = te({}, i, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new Rn({ tracked: !!e.tracked, idStrategy: e.idStrategy ? e.idStrategy : void 0 });
    const n = (c) => {
      const u = [], h = this._store.copyAll().filter((g) => !c.includes(g.id) || (u.push(g), false));
      return { changed: u, unchanged: h };
    }, s = (c, u) => {
      this._enabled && this._eventListeners.finish.forEach((h) => {
        h(c, u);
      });
    }, a = (c, u, h) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((v) => {
        v(c, u, h);
      });
      const { changed: g, unchanged: f } = n(c);
      u === "create" ? this._adapter.render({ created: g, deletedIds: [], unchanged: f, updated: [] }, this.getModeStyles()) : u === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: f, updated: g }, this.getModeStyles()) : u === "delete" ? this._adapter.render({ created: [], deletedIds: c, unchanged: f, updated: [] }, this.getModeStyles()) : u === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: f, updated: [] }, this.getModeStyles());
    }, l = (c) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((g) => {
        g(c);
      });
      const { changed: u, unchanged: h } = n([c]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: h, updated: u }, this.getModeStyles());
    }, d = (c) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((g) => {
        g();
      });
      const { changed: u, unchanged: h } = n([c]);
      u && this._adapter.render({ created: [], deletedIds: [], unchanged: h, updated: u }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((c) => {
      this._modes[c].register({ mode: c, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: a, onSelect: l, onDeselect: d, onFinish: s, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const e = {};
    return Object.keys(this._modes).forEach((t) => {
      e[t] = (i) => this._instanceSelectMode && i.properties[ee.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(i) : this._modes[t].styleFeature.bind(this._modes[t])(i);
    }), e;
  }
  featuresAtLocation({ lng: e, lat: t }, i) {
    const r = i && i.pointerDistance !== void 0 ? i.pointerDistance : 30, n = !i || i.ignoreSelectFeatures === void 0 || i.ignoreSelectFeatures, s = !(!i || i.ignoreCoordinatePoints === void 0) && i.ignoreCoordinatePoints, a = !(!i || i.ignoreCurrentlyDrawing === void 0) && i.ignoreCurrentlyDrawing, l = !(!i || i.ignoreClosingPoints === void 0) && i.ignoreClosingPoints, d = this._adapter.unproject.bind(this._adapter), c = this._adapter.project.bind(this._adapter), u = c(e, t), h = Ri({ unproject: d, point: u, pointerDistance: r });
    return this._store.search(h).filter((g) => {
      if (n && (g.properties[ee.MID_POINT] || g.properties[ee.SELECTION_POINT]) || s && g.properties[Mt] || l && g.properties[St] || a && g.properties[kt]) return false;
      if (g.geometry.type === "Point") {
        const f = g.geometry.coordinates, v = c(f[0], f[1]);
        return pe(u, v) < r;
      }
      if (g.geometry.type === "LineString") {
        const f = g.geometry.coordinates;
        for (let v = 0; v < f.length - 1; v++) {
          const w = f[v], I = f[v + 1];
          if (Dt(u, c(w[0], w[1]), c(I[0], I[1])) < r) return true;
        }
        return false;
      }
      if (Bi([e, t], g.geometry.coordinates)) return true;
      if (i != null && i.includePolygonsWithinPointerDistance) {
        const f = g.geometry.coordinates;
        for (const v of f) for (let w = 0; w < v.length - 1; w++) {
          const I = v[w], P = v[w + 1], _ = c(I[0], I[1]), x = c(P[0], P[1]);
          if (Dt(u, _, x) < r) return true;
        }
      }
      return false;
    });
  }
  getSelectModeOrThrow() {
    const e = this.getSelectMode({ switchToSelectMode: true });
    if (!e) throw new Error("No select mode defined in instance");
    return e;
  }
  getSelectMode({ switchToSelectMode: e }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const t = this.getMode();
    return e && t !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(e) {
    return !!(e.properties[ee.MID_POINT] || e.properties[ee.SELECTION_POINT] || e.properties[Mt] || e.properties[Ii]);
  }
  setModeStyles(e, t) {
    if (this.checkEnabled(), !this._modes[e]) throw new Error("No mode with this name present");
    this._modes[e].styles = t;
  }
  updateModeOptions(e, t) {
    if (this.checkEnabled(), !this._modes[e]) throw new Error("No mode with this name present");
    this._modes[e].updateOptions(t);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(e) {
    if (this._store.has(e)) return this._store.copy(e);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(e) {
    if (this.checkEnabled(), !this._modes[e]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[e], this._mode.start();
  }
  removeFeatures(e) {
    this.checkEnabled();
    const t = [];
    e.forEach((i) => {
      if (!this._store.has(i)) throw new Error(`No feature with id ${i}, can not delete`);
      const r = this._store.copy(i);
      r.properties[ee.SELECTED] && this.deselectFeature(i), r.properties[ot] && t.push(...r.properties[ot]);
    }), this._store.delete([...e, ...t], { origin: "api" });
  }
  selectFeature(e) {
    this.getSelectModeOrThrow().selectFeature(e);
  }
  deselectFeature(e) {
    this.getSelectModeOrThrow().deselectFeature(e);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(e) {
    return this._store.has(e);
  }
  updateFeatureGeometry(e, t) {
    if (!this._store.has(e)) throw new Error(`No feature with id ${e} present in store`);
    const i = this._store.copy(e);
    if (this.isGuidanceFeature(i)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(i && t && t.type && t.coordinates)) throw new Error("Invalid geometry provided");
    if (t.type !== i.geometry.type) throw new Error(`Geometry type mismatch: expected ${i.geometry.type}, got ${t.type}`);
    const r = i.properties.mode, n = this._modes[r];
    if (!n) throw new Error(`No mode with name ${r} present in instance`);
    const s = te({}, i, { geometry: t }), a = n.validateFeature(s);
    if (!a.valid) throw new Error(`Feature validation failed: ${a.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: i.id, geometry: t }], { origin: "api" }), n.afterFeatureUpdated) {
      n.afterFeatureUpdated(s);
      const l = s.properties[ee.SELECTED], d = this.getSelectMode({ switchToSelectMode: false });
      d && l && d.afterFeatureUpdated(s);
    }
  }
  transformFeatureGeometry(e, t) {
    if (!this._store.has(e)) throw new Error(`No feature with id ${e} present in store`);
    let i = this._store.copy(e);
    if (this.isGuidanceFeature(i)) throw new Error("Guidance features are not allowed to be updated directly.");
    const r = i.properties.mode, n = this._modes[r];
    if (!n) throw new Error(`No mode with name ${r} present in instance`);
    let s;
    if (i.geometry.type === "Polygon") s = i.geometry.coordinates[0];
    else {
      if (i.geometry.type !== "LineString") throw new Error(`Feature geometry type ${i.geometry.type} is not supported for transformation`);
      s = i.geometry.coordinates;
    }
    if (t.projection != "web-mercator") throw new Error(`Projection ${t.projection} is not currently supported for transformation`);
    if (t.type === "scale") {
      const { x: a, y: l } = Y(t.origin[0], t.origin[1]);
      Ti({ coordinates: s, originX: a, originY: l, xScale: t.options.xScale || 1, yScale: t.options.yScale || 1 });
    } else t.type === "rotate" && (i = Oi(i, t.options.angle || 0), s = i.geometry.type === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates);
    if (s = s.map((a) => [K(a[0], this._adapter.getCoordinatePrecision()), K(a[1], this._adapter.getCoordinatePrecision())]), i.geometry.coordinates = i.geometry.type === "Polygon" ? [s] : s, this._store.updateGeometry([{ id: i.id, geometry: i.geometry }], { origin: "api" }), n.afterFeatureUpdated) {
      n.afterFeatureUpdated(i);
      const a = i.properties[ee.SELECTED], l = this.getSelectMode({ switchToSelectMode: false });
      l && a && l.afterFeatureUpdated(i);
    }
  }
  addFeatures(e) {
    return this.checkEnabled(), e.length === 0 ? [] : this._store.load(e, (t) => {
      if (Yt(t)) {
        const i = t.properties.mode, r = this._modes[i];
        if (!r) return { id: t.id, valid: false, reason: `${i} mode is not in the list of instantiated modes` };
        const n = r.validateFeature.bind(r)(t);
        return { id: t.id, valid: n.valid, reason: n.reason ? n.reason : n.valid ? void 0 : "Feature is invalid" };
      }
      return { id: t.id, valid: false, reason: "Mode property does not exist" };
    }, (t) => {
      if (Yt(t)) {
        const i = this._modes[t.properties.mode];
        i && i.afterFeatureAdded && i.afterFeatureAdded(t);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((e) => {
        e();
      });
    }, getState: () => this._mode.state, onClick: (e) => {
      this._mode.onClick(e);
    }, onMouseMove: (e) => {
      this._mode.onMouseMove(e);
    }, onKeyDown: (e) => {
      this._mode.onKeyDown(e);
    }, onKeyUp: (e) => {
      this._mode.onKeyUp(e);
    }, onDragStart: (e, t) => {
      this._mode.onDragStart(e, t);
    }, onDrag: (e, t) => {
      this._mode.onDrag(e, t);
    }, onDragEnd: (e, t) => {
      this._mode.onDragEnd(e, t);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(e, t) {
    const { lng: i, lat: r } = e;
    return this.featuresAtLocation({ lng: i, lat: r }, t);
  }
  getFeaturesAtPointerEvent(e, t) {
    const i = this._adapter.getLngLatFromEvent.bind(this._adapter)(e);
    return i === null ? [] : this.featuresAtLocation(i, t);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(e, t) {
    const i = this._eventListeners[e];
    i.includes(t) || i.push(t);
  }
  off(e, t) {
    const i = this._eventListeners[e];
    i.includes(t) && i.splice(i.indexOf(t), 1);
  }
}
class Bn extends En.TerraDrawBaseAdapter {
  constructor(e) {
    super(e), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = e.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = e.renderBelowLayerId, this._prefixId = e.prefixId || "td";
  }
  _addGeoJSONSource(e, t) {
    this._map.addSource(e, { type: "geojson", data: { type: "FeatureCollection", features: t }, tolerance: 0 });
  }
  _addFillLayer(e) {
    return this._map.addLayer({ id: e, source: e, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(e) {
    return this._map.addLayer({ id: e + "-outline", source: e, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(e) {
    return this._map.addLayer({ id: e, source: e, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(e) {
    return this._map.addLayer({ id: e, source: e, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(e, t) {
    t === "Point" && this._addPointLayer(e), t === "LineString" && this._addLineLayer(e), t === "Polygon" && (this._addFillLayer(e), this._addFillOutlineLayer(e));
  }
  _addGeoJSONLayer(e, t) {
    const i = `${this._prefixId}-${e.toLowerCase()}`;
    return this._addGeoJSONSource(i, t), this._addLayer(i, e), i;
  }
  _setGeoJSONLayerData(e, t) {
    const i = `${this._prefixId}-${e.toLowerCase()}`;
    return this._map.getSource(i).setData({ type: "FeatureCollection", features: t }), i;
  }
  updateChangedIds(e) {
    [...e.updated, ...e.created].forEach((t) => {
      t.geometry.type === "Point" ? this.changedIds.points = true : t.geometry.type === "LineString" ? this.changedIds.linestrings = true : t.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), e.deletedIds.length > 0 && (this.changedIds.deletion = true), e.created.length === 0 && e.updated.length === 0 && e.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(e) {
    const { left: t, top: i } = this._container.getBoundingClientRect();
    return this.unproject(e.clientX - t, e.clientY - i);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(e) {
    e ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(e, t) {
    const { x: i, y: r } = this._map.project({ lng: e, lat: t });
    return { x: i, y: r };
  }
  unproject(e, t) {
    const { lng: i, lat: r } = this._map.unproject({ x: e, y: t });
    return { lng: i, lat: r };
  }
  setCursor(e) {
    const t = this._map.getCanvas();
    e === "unset" ? t.style.removeProperty("cursor") : t.style.cursor = e;
  }
  setDoubleClickToZoom(e) {
    e ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(e, t) {
    this.updateChangedIds(e), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const i = [...e.created, ...e.updated, ...e.unchanged], r = [], n = [], s = [];
      for (let c = 0; c < i.length; c++) {
        const u = i[c], { properties: h } = u, g = t[h.mode](u);
        u.geometry.type === "Point" ? (h.pointColor = g.pointColor, h.pointOutlineColor = g.pointOutlineColor, h.pointOutlineWidth = g.pointOutlineWidth, h.pointWidth = g.pointWidth, h.zIndex = g.zIndex, r.push(u)) : u.geometry.type === "LineString" ? (h.lineStringColor = g.lineStringColor, h.lineStringWidth = g.lineStringWidth, n.push(u)) : u.geometry.type === "Polygon" && (h.polygonFillColor = g.polygonFillColor, h.polygonFillOpacity = g.polygonFillOpacity, h.polygonOutlineColor = g.polygonOutlineColor, h.polygonOutlineWidth = g.polygonOutlineWidth, s.push(u));
      }
      const a = this.changedIds.deletion || this.changedIds.styling, l = a || this.changedIds.linestrings, d = a || this.changedIds.polygons;
      (a || this.changedIds.points) && this._setGeoJSONLayerData("Point", r), l && this._setGeoJSONLayerData("LineString", n), d && this._setGeoJSONLayerData("Polygon", s), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(e) {
    var t;
    super.register(e);
    const i = this._addGeoJSONLayer("Polygon", []), r = this._addGeoJSONLayer("LineString", []), n = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(n, this._renderBeforeLayerId), this._map.moveLayer(r, n), this._map.moveLayer(i + "-outline", r), this._map.moveLayer(i, r)), (t = this._currentModeCallbacks) != null && t.onReady && this._currentModeCallbacks.onReady();
  }
}
const ji = Xi("routes", () => {
  const o = to(), e = R(() => o.routeCollection), t = R({ get: () => o.currentRouteId, set: (m) => o.setCurrentRouteId(m) }), i = O(0);
  Ae(t, (m) => {
    var _a, _b;
    m && (i.value = ((_b = (_a = o.getRouteById(m)) == null ? void 0 : _a.meta) == null ? void 0 : _b.record_timespan) ?? 0);
  });
  const r = O(false), n = O(-1), s = O(null);
  let a;
  const l = R(() => o.routes);
  function d(m) {
    s.value = m;
  }
  async function c() {
    await o.init();
  }
  async function u(m, C = {}) {
    return await o.addRoute(m, C);
  }
  async function h(m) {
    await o.deleteRoute(m);
  }
  async function g(m, C) {
    await o.addPointToRoute(m, C);
  }
  async function f(m, C) {
    await o.updateRoute(m, C);
  }
  async function v(m) {
    await o.clearRoutePoints(m);
  }
  function w(m) {
    return o.getRouteById(m);
  }
  function I(m) {
    o.setCurrentRouteId(m);
  }
  function P(m) {
    r.value || !s.value || (r.value = true, m && g(t.value, m), n.value = s.value.addListener((C) => {
      t.value && g(t.value, C);
    }), o.updateRoute(t.value, { meta: { modification_timestamp: Date.now() } }), a = setInterval(async () => {
      const C = o.getRouteById(t.value);
      C.recordTimespan !== void 0 && C.meta.modification_timestamp && (i.value = C.recordTimespan + (Date.now() - C.meta.modification_timestamp), await o.updateRoute(t.value, { meta: { record_timespan: i.value } }));
    }, 100));
  }
  function _() {
    !r.value || !s.value || (n.value !== -1 && (s.value.removeListener(n.value), n.value = -1), a && (clearTimeout(a), a = void 0), r.value = false);
  }
  async function x(m) {
    try {
      if (!s.value) throw new Error("Geolocation service not available");
      if (r.value) _();
      else if (t.value) P();
      else {
        const C = await u(m("trackerView.nameNewRoute"));
        I(C.id), P(s.value.present);
      }
    } catch (C) {
      throw console.error(C), C;
    }
  }
  function y() {
    n.value !== -1 && s.value && (s.value.removeListener(n.value), n.value = -1), r.value = false;
  }
  return { routeCollection: e, routes: l, currentRouteId: t, isRecording: r, watchingHandler: n, currentRouteRecordTimespan: i, setLocator: d, init: c, addRoute: u, deleteRoute: h, addPointToRoute: g, updateRoute: f, clearRoutePoints: v, getRouteById: w, setCurrentRouteId: I, startRecording: P, stopRecording: _, toggleRecording: x, cleanup: y };
}), On = { class: "upload-container" }, Tn = { class: "action-buttons" }, Ln = q({ __name: "TextFileUploaderDialog", props: xe({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: xe(["update:value", "confirm"], ["update:show"]), setup(o, { emit: e }) {
  const t = di(), i = o, r = e, n = Ge(o, "show");
  let s = [];
  const a = (c) => {
    s = [];
    for (const u of c) {
      const h = u.file;
      if (h) if (i.types.includes(h.type)) {
        const g = new FileReader();
        g.onload = (f) => {
          var _a;
          ((_a = f.target) == null ? void 0 : _a.result) && s.push(f.target.result), s.length === c.length && r("update:value", s);
        }, g.readAsText(h);
      } else t.warning(`Skipped file ${u.name} due to unsupported type ${h.type}`);
    }
  }, l = () => {
    r("confirm", s), n.value = false;
  }, d = (c) => {
    var _a, _b;
    return i.types.includes(((_a = c.file.file) == null ? void 0 : _a.type) ?? "") ? true : (t.error(`Unsupported file type ${((_b = c.file.file) == null ? void 0 : _b.type) ?? "unknown"}. Supported types: ['${i.types.join("', '")}']`), false);
  };
  return (c, u) => (A(), ce(k(ci), { show: n.value, "onUpdate:show": u[2] || (u[2] = (h) => n.value = h), preset: "dialog", title: "Dialog" }, { header: j(() => [...u[3] || (u[3] = [_e(" File Upload ", -1)])]), default: j(() => [B("div", On, [$(k(Nr), { multiple: i.multiple ?? false, onChange: u[0] || (u[0] = ({ fileList: h }) => a(h)), onBeforeUpload: d }, { default: j(() => [$(k(wi), null, { default: j(() => [$(k(Ue), { size: 36, name: "upload", class: "upload-icon" }, { default: j(() => [(A(), ce(vt(i.icon ?? k(io))))]), _: 1 }), B("div", null, le(i.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: j(() => [B("div", Tn, [$(k(he), { onClick: u[1] || (u[1] = (h) => n.value = false) }, { default: j(() => [...u[4] || (u[4] = [_e(" Cancel ", -1)])]), _: 1 }), $(k(he), { type: "primary", onClick: l }, { default: j(() => [...u[5] || (u[5] = [_e(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), jn = Xe(Ln, [["__scopeId", "data-v-14c5a0c1"]]), $n = q({ __name: "MglDrawer", props: xe({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: xe(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(o, { emit: e }) {
  at((h) => ({ a1b7bba2: k(r).modalColor, "305889d2": k(r).borderRadius, "60287bc6": c.value, "048a7f4c": d.value }));
  const t = o, i = e, r = ct(), n = Hi("route-drawer"), s = R(() => t.position || "left"), a = R(() => {
    var _a, _b, _c, _d;
    return Math.min(wt(Math.round((((_b = (_a = n.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = n.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), l = R(() => {
    var _a, _b, _c, _d;
    return Math.min(wt(Math.round((((_b = (_a = n.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = n.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), d = R(() => s.value === "left" ? `${-16 - a.value}px` : s.value === "right" ? `${16 + a.value}px` : s.value === "top" ? `${-16 - l.value}px` : s.value === "bottom" ? `${16 + l.value}px` : "0px"), c = R(() => s.value === "left" || s.value === "right" ? `${a.value}px` : `${l.value}px`), u = Ge(o, "show");
  return Ae(a, () => i("update:width", a.value)), Ae(l, () => i("update:height", l.value)), (h, g) => (A(), ce(Et, { name: `slide-${s.value}` }, { default: j(() => [Yi(B("div", { ref: "route-drawer", class: ze(["route-drawer", `route-drawer--${s.value}`]), onClick: g[0] || (g[0] = (f) => i("click", f)), onContextmenu: g[1] || (g[1] = (f) => i("contextmenu", f)) }, [Ft(h.$slots, "default", {}, void 0, true)], 34), [[Ki, u.value]])]), _: 3 }, 8, ["name"]));
} }), zn = Xe($n, [["__scopeId", "data-v-72b274a7"]]), Nn = { class: "menu-list" }, Un = ["onClick", "onContextmenu", "onTouchstart"], Wn = { class: "swipe-container" }, An = { style: { height: "fit-content", padding: "8px 12px" } }, Gn = ["onClick"], Vn = { style: { padding: "16px" } }, Xn = 120, Hn = 40, Yn = q({ __name: "SelectableSwipeableMenuList", props: xe({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: xe(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(o, { emit: e }) {
  at((x) => ({ af602246: k(s).hoverColor, "2c598f52": k(s).primaryColor, f032366a: k(s).bodyColor, "6ce963b2": a.value }));
  const t = o, i = Ge(o, "selection"), r = Ge(o, "multipleSelection"), n = e, s = ct(), a = O("0s"), l = O({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), d = O(false), c = O(0), u = O(0), h = O(null);
  function g(x, y) {
    l.value.activeId !== y && I();
    const m = x.touches[0];
    l.value = { startX: m.clientX, delta: l.value.delta ?? 0, currentX: m.clientX, containerWidth: x.currentTarget.offsetWidth, activeId: y, leftMax: Xn, rightMax: Hn };
  }
  function f(x) {
    l.value.activeId && (l.value.currentX = x.touches[0].clientX, l.value.delta += l.value.currentX - l.value.startX, l.value.delta = wt(l.value.delta, -l.value.leftMax, l.value.rightMax), l.value.startX = x.touches[0].clientX);
  }
  function v() {
    if (!l.value.activeId) return;
    a.value = `${Math.abs(l.value.delta) / l.value.containerWidth * 0.3}s`, setTimeout(() => {
      a.value = "0s";
    }, 300);
    const x = l.value.delta < 0 ? l.value.leftMax : l.value.rightMax;
    l.value.delta = Math.abs(l.value.delta) > x * 0.4 ? Math.sign(l.value.delta) * x : 0, l.value.delta === 0 && Math.abs(l.value.delta) < 5;
  }
  function w(x, y) {
    x.stopPropagation(), !(l.value.delta > 5) && (I(), i.value !== y.id && (i.value = y.id));
  }
  function I() {
    l.value.delta > 0 || (l.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function P(x, y) {
    if (x.stopPropagation(), x.preventDefault(), d.value) {
      d.value = false;
      return;
    }
    h.value = y, c.value = x.clientX, u.value = x.clientY, d.value = true, n("contextmenu", x, y);
  }
  function _(x) {
    const y = [...r.value];
    if (y.includes(x)) {
      const m = y.indexOf(x);
      y.splice(m, 1);
    } else y.push(x);
    r.value = y;
  }
  return (x, y) => (A(), oe(Ie, null, [B("div", Nn, [(A(true), oe(Ie, null, yt(t.items, (m) => (A(), oe("div", { key: m.id, class: ze(["menu-list-item", ...m.id === i.value ? ["active"] : []]), style: we({ "touch-action": l.value.activeId === m.id ? "pan-y" : "auto" }), onClick: (C) => w(C, m), onContextmenu: qi((C) => P(C, m), ["prevent"]), onTouchstart: (C) => g(C, m.id), onTouchmove: f, onTouchend: v }, [B("div", Wn, [B("div", { class: "content-col", style: we({ transform: `translateX(${l.value.activeId === m.id || l.value.delta > 0 ? l.value.delta : 0}px)`, willChange: l.value.activeId === m.id ? "transform" : "auto", flexDirection: l.value.delta >= 0 || l.value.activeId !== m.id ? "row" : "row-reverse" }) }, [Ft(x.$slots, "item", { item: m }, () => [B("div", An, [B("div", null, le(m.name ?? "Untitled"), 1)])], true)], 4), B("div", { class: "actions-col", style: we({ width: `${l.value.activeId === m.id && l.value.delta < 0 ? -l.value.delta : 0}px`, visibility: l.value.activeId === m.id && l.value.delta < 0 ? "visible" : "hidden", willChange: l.value.activeId === m.id ? "width" : "auto" }) }, [(A(true), oe(Ie, null, yt(t.swipeActions, (C) => (A(), oe("button", { key: C.name, class: "menu-action", style: we({ background: C.color || k(s).primaryColorSuppl }), onClick: () => {
    C.action(m.id), l.value.activeId = null;
  } }, le(C.label), 13, Gn))), 128))], 4), B("div", { class: "select-col", style: we({ width: `${l.value.delta > 0 ? l.value.delta : 0}px`, backgroundColor: i.value === m.id ? k(s).primaryColor : "transparent", visibility: l.value.delta > 0 ? "visible" : "hidden" }) }, [B("div", Vn, [$(k(lr), { checked: r.value.includes(m.id), style: we({ border: i.value === m.id ? `1px solid ${k(s).bodyColor}` : "none", BorderRadius: i.value === m.id ? k(s).borderRadiusSmall : "none" }), "onUpdate:checked": () => _(m.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, Un))), 128))]), $(k(xi), { show: d.value, x: c.value, y: u.value, options: t.menuOptions.map((m) => {
    var _a;
    return { ...m, label: ((_a = m.label) == null ? void 0 : _a.value) ?? m.label };
  }), placement: "bottom-start", trigger: "manual", onClick: y[0] || (y[0] = (m) => d.value = false), onClickoutside: y[1] || (y[1] = (m) => d.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), Kn = Xe(Yn, [["__scopeId", "data-v-b353d352"]]), qn = { class: "drawer-floating" }, Jn = { class: "drawer-container" }, Zn = { class: "drawer-header" }, Qn = { class: "drawer-title" }, es = { class: "drawer-content" }, ts = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, is = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, os = { key: 0 }, rs = q({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: xe(["update:width"], ["update:show"]), setup(o, { emit: e }) {
  at((D) => ({ "627d638a": k(l).borderRadius, "71a1839a": k(l).hoverColor, "8e0c4596": k(l).primaryColorPressed, "63c7eba6": k(l).primaryColor, "46d552b5": k(l).bodyColor }));
  const i = new li().isMobile, { t: r } = bt(), n = oo(), s = e, a = ji(), l = ct(), d = Ge(o, "show"), c = O(false), u = O(0), h = O(0), g = O(null), f = O(false), v = O(""), w = O(null), I = [{ label: R(() => r("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    c.value = false, a.addRoute(r("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], P = [{ label: R(() => r("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a;
    ((_a = g.value) == null ? void 0 : _a.id) && (v.value = g.value.name || "", f.value = true);
  } } }, { label: R(() => r("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    g.value && a.deleteRoute(g.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...I], _ = [{ label: R(() => r("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (D) => {
    const b = a.routes.find((M) => M.id === D);
    w.value = D, v.value = (b == null ? void 0 : b.name) || "", f.value = true;
  } }, { label: R(() => r("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (D) => a.deleteRoute(D), color: l.value.errorColorSuppl }];
  function x(D) {
    if (D.stopPropagation(), D.preventDefault(), w.value = a.currentRouteId, c.value) {
      c.value = false;
      return;
    }
    u.value = D.clientX, h.value = D.clientY, c.value = true;
  }
  async function y(D) {
    v.value.trim() && (await a.updateRoute(D, { name: v.value.trim() }), f.value = false);
  }
  const m = O([]);
  function C() {
    n.warning({ title: r("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: r("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: r("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: r("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      m.value.forEach((D) => {
        a.deleteRoute(D), m.value = m.value.filter((b) => b !== D);
      });
    } });
  }
  return (D, b) => (A(), oe(Ie, null, [$(zn, { show: d.value, "onUpdate:show": b[3] || (b[3] = (M) => d.value = M), position: k(i) ? "bottom" : "left", onClick: b[4] || (b[4] = () => k(a).currentRouteId = null), "onUpdate:width": b[5] || (b[5] = (M) => s("update:width", M)), onContextmenu: b[6] || (b[6] = (M) => x(M)) }, { default: j(() => [B("div", qn, [k(i) && d.value ? Ft(D.$slots, "bottom-floating", { key: 0 }, void 0, true) : be("", true)]), B("div", Jn, [B("div", Zn, [B("p", Qn, le(k(r)("components.trackerViewRouteDrawer.routes")), 1), m.value.length > 0 ? (A(), ce(k(he), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: C }, { icon: j(() => [$(k(Ue), { component: k(ro) }, null, 8, ["component"])]), _: 1 })) : be("", true)]), B("div", es, [$(Kn, { selection: k(a).currentRouteId, "onUpdate:selection": b[0] || (b[0] = (M) => k(a).currentRouteId = M), "multiple-selection": m.value, "onUpdate:multipleSelection": b[1] || (b[1] = (M) => m.value = M), items: k(a).routes, "menu-options": P, "swipe-actions": _, onContextmenu: b[2] || (b[2] = (M, E) => {
    w.value = (E == null ? void 0 : E.id) ?? null, g.value = E ?? null;
  }) }, { item: j(({ item: M }) => {
    var _a;
    return [B("div", ts, [B("div", null, le(M.name ?? k(r)("components.trackerViewRouteDrawer.nameNewRoute")), 1), B("div", is, [B("div", null, le(k(r)("components.trackerViewRouteDrawer.points", { num: M.points.length })), 1), M.points.length > 1 && ((_a = M.meta) == null ? void 0 : _a.distance) ? (A(), oe("div", os, le(k(r)("components.trackerViewRouteDrawer.distance", { distance: k(no)(M.meta.distance) })), 1)) : be("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), $(k(xi), { show: c.value, x: u.value, y: h.value, options: I.map((M) => ({ ...M, label: M.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: b[7] || (b[7] = (M) => c.value = false) }, null, 8, ["show", "x", "y", "options"]), $(k(ci), { show: f.value, "onUpdate:show": b[10] || (b[10] = (M) => f.value = M), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: b[11] || (b[11] = () => {
    w.value && y(w.value);
  }) }, { default: j(() => [$(k(so), { value: v.value, "onUpdate:value": b[8] || (b[8] = (M) => v.value = M), placeholder: "Enter new route name", onKeyup: b[9] || (b[9] = Ji(() => {
    w.value && y(w.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), ns = Xe(rs, [["__scopeId", "data-v-9e932b50"]]), ss = { class: "map-layout-container" }, as = { class: "map-layout" }, ls = { key: 0, style: { width: "100%", height: "100%" } }, ds = ["title", "onClick"], cs = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, us = { style: { "font-family": "monospace", "padding-left": "8px" } }, hs = q({ __name: "TrackerView", setup(o) {
  at((z) => {
    var _a, _b, _c;
    return { "4e05afbd": (_a = k(Te).Button.common) == null ? void 0 : _a.successColorSuppl, "9908bd02": k(i).boxShadow3, "0e0e10d5": k(i).borderRadius, b65f1280: k(i).borderColor, "60bf4afc": (_b = k(Te).Button.common) == null ? void 0 : _b.primaryColorSuppl, dc709f7c: (_c = k(Te).Button.common) == null ? void 0 : _c.errorColorSuppl };
  });
  const t = new li().isMobile, i = ct(), r = Lo(), n = di(), s = ge("geolocation"), { t: a } = bt(), l = bt(), d = O(7), u = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", h = O({ latitude: 0, longitude: 0 }), g = zt(null), f = zt(null), v = O("select"), w = ji();
  w.setLocator(s);
  const I = ge("noSleep"), P = R(() => {
    var _a;
    return w.currentRouteId ? ((_a = w.routes.find((G) => G.id === w.currentRouteId)) == null ? void 0 : _a.points) || [] : [];
  }), _ = O(false), x = new mo.Marker(), y = R(() => {
    if (P.value.length > 1 || P.value.length === 0) return x.remove(), { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: w.currentRouteId }, geometry: { type: "LineString", coordinates: P.value.map((z) => [z.longitude, z.latitude]) } }] };
    if (P.value.length === 1) {
      x.setLngLat([P.value[0].longitude, P.value[0].latitude]);
      const z = g.value;
      z && x.addTo(z);
    }
    return { type: "FeatureCollection", features: [] };
  }), m = [{ mode: new dn(), name: a("trackerView.terraDrawTools.point"), icon: vo }, { mode: new on(), name: a("trackerView.terraDrawTools.line"), icon: Vo }, { mode: new wn({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: a("trackerView.terraDrawTools.select"), icon: Ao }];
  Ae([() => r.settings.mapLanguage, () => l.locale.value], (z) => {
    z && g.value && C(g.value, z[0] === "interface" ? z[1] : z[0]);
  });
  const C = (z, G) => {
    const H = G === "zh-CN" ? "zh" : "en", me = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const Oe of me) z.setLayoutProperty(Oe, "text-field", ["get", `name:${H}`]);
  };
  function D(z) {
    var _a;
    g.value = z.map, g.value && C(g.value, l.locale.value), (_a = g.value) == null ? void 0 : _a.on("click", () => {
      U.value = false;
    }), f.value = new Fn({ adapter: new Bn({ map: g.value }), modes: m.map((G) => G.mode) }), f.value.start();
  }
  let b = true;
  async function M() {
    try {
      w.isRecording || (b = w.currentRouteId === null), await w.toggleRecording(a), !w.isRecording && b && (W.value = true, setTimeout(() => {
        W.value = false;
      }, 3e3)), w.isRecording ? I.enable() : I.disable();
    } catch (z) {
      console.error(z), I.disable();
    }
  }
  const E = O(async () => {
  });
  function F() {
    U.value = false, n.warning("Not implemented yet");
  }
  const V = O(0), U = O(false);
  Ae(U, (z) => {
    var _a;
    return (_a = g.value) == null ? void 0 : _a.easeTo({ padding: t ? { bottom: z ? V.value : 0 } : { left: z ? V.value : 0 }, duration: 500 });
  });
  const J = () => U.value = !U.value, W = O(false), Z = O(""), Q = O(false);
  Zi(async () => {
    var _a;
    await w.init();
    try {
      h.value = await s.refresh(), s.usingGPS || n.warning(a("trackerView.gpsWarning"), { duration: 5e3 });
    } catch (z) {
      Z.value = z.message ?? String(z);
    }
    Q.value = true, (_a = f.value) == null ? void 0 : _a.start();
  });
  const ae = false;
  function Be(z) {
    const G = z / 1e3, H = G / 60, me = H / 60, Oe = G % 60, Ke = H % 60, qe = me;
    let Ce = "";
    return Math.floor(qe) > 0 && (Ce += `${String(Math.floor(qe))}h `), Math.floor(Ke) > 0 && (Ce += `${String(Math.floor(Ke))}m `), Ce += `${String(Oe.toFixed(1)).padStart(4, "0")}s`, Ce;
  }
  return (z, G) => (A(), oe("div", ss, [B("div", as, [$(Et, { name: "map-load" }, { default: j(() => [Q.value && !Z.value ? (A(), oe("div", ls, [$(k(ao), { "map-style": u, center: [h.value.longitude, h.value.latitude], zoom: d.value, height: "100%", "onMap:load": D }, { default: j(() => [$(k(lo), { position: "top-left" }), k(s).usingGPS || ae ? (A(), ce(k(co), { key: 0, position: "top-left", "track-user-location": true })) : be("", true), $(k(uo), { position: "top-left" }), $(k(ho), { position: "bottom-left" }), !k(t) || ae ? (A(), ce(k(Nt), { key: 1, position: "top-right" }, { default: j(() => [(A(), oe(Ie, null, yt(m, (H) => B("button", { key: H.name, class: ze(["btn-control", "btn-draw-mode", { active: H.mode.mode === v.value }]), title: H.name, onClick: () => {
    var _a, _b, _c;
    console.log("activeDrawMethod", v.value), v.value === H.mode.mode ? ((_a = f.value) == null ? void 0 : _a.setMode("select"), v.value = "select") : (v.value = H.mode.mode, (_b = f.value) == null ? void 0 : _b.start(), (_c = f.value) == null ? void 0 : _c.setMode(H.mode.mode));
  } }, [$(k(Ue), { size: 20 }, { default: j(() => [(A(), ce(vt(H.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, ds)), 64))]), _: 1 })) : be("", true), $(k(Nt), { position: "bottom-left" }, { default: j(() => [$(k(_o), { trigger: "manual", show: W.value }, { trigger: j(() => [B("button", { class: "btn-control btn-route-toggle", onClick: J }, [$(k(Ue), { size: 24 }, { default: j(() => [$(k(po))]), _: 1 })])]), default: j(() => [B("span", null, le(k(a)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), $(k(go), { "source-id": "geojson", data: y.value }, { default: j(() => [$(k(fo), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-color": "#008800", "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"])]), _: 1 }, 8, ["center", "zoom"])])) : (A(), oe("div", cs, [Z.value ? (A(), ce(k(ir), { key: 1, title: k(a)("app.error"), type: "error" }, { default: j(() => [B("div", null, [G[3] || (G[3] = B("br", null, null, -1)), B("b", null, le(k(a)("app.error")) + ": ", 1), G[4] || (G[4] = B("br", null, null, -1)), B("code", null, le(Z.value), 1)])]), _: 1 }, 8, ["title"])) : (A(), ce(k(xr), { key: 0, size: "large" }, { description: j(() => [$(k(yo), null, { default: j(() => [_e(le(k(a)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 }))]))]), _: 1 })]), $(jn, { show: _.value, "onUpdate:show": G[0] || (G[0] = (H) => _.value = H), types: ["application/json", "text/plain"], onConfirm: E.value }, null, 8, ["show", "onConfirm"]), $(ns, { show: U.value, "onUpdate:show": G[1] || (G[1] = (H) => U.value = H), "onUpdate:width": G[2] || (G[2] = (H) => V.value = H) }, { "bottom-floating": j(() => [$(k(Wt), { theme: k(Te) }, { default: j(() => [P.value.length > 1 ? (A(), ce(k(he), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: F }, { default: j(() => [...G[5] || (G[5] = [_e(" Follow ", -1)])]), _: 1 })) : be("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), k(t) || ae ? (A(), oe("div", { key: 0, class: ze(["mobile-record-button-container", { "drawer-open": U.value }]) }, [$(k(Wt), { theme: k(Te) }, { default: j(() => [$(k(he), { type: k(w).isRecording ? "error" : "primary", size: "large", class: ze(["mobile-record-button", k(w).isRecording ? "recording" : "not-recording"]), onClick: M }, { icon: j(() => [$(k(Ue), { size: 20 }, { default: j(() => [(A(), ce(vt(k(w).isRecording ? k(Ko) : k(Ho)), { size: k(w).isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: j(() => [_e(" " + le(k(w).isRecording ? k(a)("trackerView.uiRecordingStatus.on") : k(a)("trackerView.uiRecordingStatus.off")) + " ", 1), B("p", us, le(k(w).currentRouteRecordTimespan ? `(${Be(k(w).currentRouteRecordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : be("", true)]));
} }), Rs = Xe(hs, [["__scopeId", "data-v-733e289a"]]);
export {
  Rs as default
};
