var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { d as z, c as Ye, o as Xe, a as Z, J as cn, h as g, b as R, q as x, i as A, j, F as dn, t as st, k as _t, a2 as Qe, w as lt, p as H, I as ge, Y as ut, G as qe, f as le, x as Pe, T as pn, a5 as fn, g as mn, a6 as V, L as hn, Z as vn, $ as F, a0 as O } from "./index-C78IAAjf.js";
import { i as gn, m as T, n as w, o as L, B as ve, l as D, aP as yn, K as ze, J as We, aF as bn, V as wn, w as ct, u as xn, q as St, aj as _n, E as Sn, C as dt, p as Cn, t as Ve, L as kn, v as Rn, P as pt, G as E, X as ft, T as Ct } from "./light-Cs_wBr-w.js";
import { w as zn, R as In, j as Mn, l as Tn } from "./text-DuK6zv_f.js";
import { N as mt, a as Bn } from "./Suffix-CdlwZ1rt.js";
import { u as An } from "./use-locale-CB4cpmAU.js";
import { u as En } from "./light-DQpWJLfV.js";
import { m as ne } from "./index-sk8ZSphq.js";
const Pn = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Cr = z({ name: "Route", render: function(t, o) {
  return Xe(), Ye("svg", Pn, o[0] || (o[0] = [Z("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Z("circle", { cx: "6", cy: "19", r: "2" }), Z("circle", { cx: "18", cy: "5", r: "2" }), Z("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), Fn = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, kr = z({ name: "Trash", render: function(t, o) {
  return Xe(), Ye("svg", Fn, o[0] || (o[0] = [cn('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), On = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Rr = z({ name: "Upload", render: function(t, o) {
  return Xe(), Ye("svg", On, o[0] || (o[0] = [Z("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Z("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), Z("path", { d: "M7 9l5-5l5 5" }), Z("path", { d: "M12 4v12" })], -1)]));
} }), zr = z({ name: "Add", render() {
  return g("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, g("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), jn = z({ name: "Eye", render() {
  return g("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, g("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), g("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), Dn = z({ name: "EyeOff", render() {
  return g("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, g("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), g("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), g("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), g("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), g("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), kt = gn("n-input"), Nn = T("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [w("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), w("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), w("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [D("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), D("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), D("&:-webkit-autofill ~", [w("placeholder", "display: none;")])]), L("round", [ve("textarea", "border-radius: calc(var(--n-height) / 2);")]), w("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [D("span", `
 width: 100%;
 display: inline-block;
 `)]), L("textarea", [w("placeholder", "overflow: visible;")]), ve("autosize", "width: 100%;"), L("autosize", [w("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), T("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), w("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), w("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [D("&[type=password]::-ms-reveal", "display: none;"), D("+", [w("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), ve("textarea", [w("placeholder", "white-space: nowrap;")]), w("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), L("textarea", "width: 100%;", [T("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), L("resizable", [T("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), w("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), w("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), L("pair", [w("input-el, placeholder", "text-align: center;"), w("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [T("icon", `
 color: var(--n-icon-color);
 `), T("base-icon", `
 color: var(--n-icon-color);
 `)])]), L("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [w("border", "border: var(--n-border-disabled);"), w("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), w("placeholder", "color: var(--n-placeholder-color-disabled);"), w("separator", "color: var(--n-text-color-disabled);", [T("icon", `
 color: var(--n-icon-color-disabled);
 `), T("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), T("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), w("suffix, prefix", "color: var(--n-text-color-disabled);", [T("icon", `
 color: var(--n-icon-color-disabled);
 `), T("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), ve("disabled", [w("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [D("&:hover", `
 color: var(--n-icon-color-hover);
 `), D("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), D("&:hover", [w("state-border", "border: var(--n-border-hover);")]), L("focus", "background-color: var(--n-color-focus);", [w("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), w("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), w("state-border", `
 border-color: #0000;
 z-index: 1;
 `), w("prefix", "margin-right: 4px;"), w("suffix", `
 margin-left: 4px;
 `), w("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [T("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), T("base-clear", `
 font-size: var(--n-icon-size);
 `, [w("placeholder", [T("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), D(">", [T("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), T("base-icon", `
 font-size: var(--n-icon-size);
 `)]), T("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((e) => L(`${e}-status`, [ve("disabled", [T("base-loading", `
 color: var(--n-loading-color-${e})
 `), w("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${e});
 `), w("state-border", `
 border: var(--n-border-${e});
 `), D("&:hover", [w("state-border", `
 border: var(--n-border-hover-${e});
 `)]), D("&:focus", `
 background-color: var(--n-color-focus-${e});
 `, [w("state-border", `
 box-shadow: var(--n-box-shadow-focus-${e});
 border: var(--n-border-focus-${e});
 `)]), L("focus", `
 background-color: var(--n-color-focus-${e});
 `, [w("state-border", `
 box-shadow: var(--n-box-shadow-focus-${e});
 border: var(--n-border-focus-${e});
 `)])])]))]), Ln = T("input", [L("disabled", [w("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function $n(e) {
  let t = 0;
  for (const o of e) t++;
  return t;
}
function Ie(e) {
  return e === "" || e == null;
}
function Wn(e) {
  const t = R(null);
  function o() {
    const { value: s } = e;
    if (!(s == null ? void 0 : s.focus)) {
      a();
      return;
    }
    const { selectionStart: f, selectionEnd: p, value: m } = s;
    if (f == null || p == null) {
      a();
      return;
    }
    t.value = { start: f, end: p, beforeText: m.slice(0, f), afterText: m.slice(p) };
  }
  function r() {
    var s;
    const { value: f } = t, { value: p } = e;
    if (!f || !p) return;
    const { value: m } = p, { start: v, beforeText: y, afterText: C } = f;
    let u = m.length;
    if (m.endsWith(C)) u = m.length - C.length;
    else if (m.startsWith(y)) u = y.length;
    else {
      const I = y[v - 1], P = m.indexOf(I, v - 1);
      P !== -1 && (u = P + 1);
    }
    (s = p.setSelectionRange) === null || s === void 0 || s.call(p, u, u);
  }
  function a() {
    t.value = null;
  }
  return x(e, a), { recordCursor: o, restoreCursor: r };
}
const ht = z({ name: "InputWordCount", setup(e, { slots: t }) {
  const { mergedValueRef: o, maxlengthRef: r, mergedClsPrefixRef: a, countGraphemesRef: s } = A(kt), f = j(() => {
    const { value: p } = o;
    return p === null || Array.isArray(p) ? 0 : (s.value || $n)(p);
  });
  return () => {
    const { value: p } = r, { value: m } = o;
    return g("span", { class: `${a.value}-input-word-count` }, yn(t.default, { value: m === null || Array.isArray(m) ? "" : m }, () => [p === void 0 ? f.value : `${f.value} / ${p}`]));
  };
} }), Vn = Object.assign(Object.assign({}, St.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), Ir = z({ name: "Input", props: Vn, slots: Object, setup(e) {
  const { mergedClsPrefixRef: t, mergedBorderedRef: o, inlineThemeDisabled: r, mergedRtlRef: a } = xn(e), s = St("Input", "-input", Nn, zn, e, t);
  In && _n("-input-safari", Ln, t);
  const f = R(null), p = R(null), m = R(null), v = R(null), y = R(null), C = R(null), u = R(null), I = Wn(u), P = R(null), { localeRef: re } = An("Input"), ae = R(e.defaultValue), Fe = st(e, "value"), N = Sn(Fe, ae), J = En(e), { mergedSizeRef: de, mergedDisabledRef: U, mergedStatusRef: Oe } = J, G = R(false), Y = R(false), d = R(false), l = R(false);
  let c = null;
  const b = j(() => {
    const { placeholder: n, pair: i } = e;
    return i ? Array.isArray(n) ? n : n === void 0 ? ["", ""] : [n, n] : n === void 0 ? [re.value.placeholder] : [n];
  }), pe = j(() => {
    const { value: n } = d, { value: i } = N, { value: h } = b;
    return !n && (Ie(i) || Array.isArray(i) && Ie(i[0])) && h[0];
  }), Pt = j(() => {
    const { value: n } = d, { value: i } = N, { value: h } = b;
    return !n && h[1] && (Ie(i) || Array.isArray(i) && Ie(i[1]));
  }), je = dt(() => e.internalForceFocus || G.value), Ft = dt(() => {
    if (U.value || e.readonly || !e.clearable || !je.value && !Y.value) return false;
    const { value: n } = N, { value: i } = je;
    return e.pair ? !!(Array.isArray(n) && (n[0] || n[1])) && (Y.value || i) : !!n && (Y.value || i);
  }), De = j(() => {
    const { showPasswordOn: n } = e;
    if (n) return n;
    if (e.showPasswordToggle) return "click";
  }), fe = R(false), Ot = j(() => {
    const { textDecoration: n } = e;
    return n ? Array.isArray(n) ? n.map((i) => ({ textDecoration: i })) : [{ textDecoration: n }] : ["", ""];
  }), ot = R(void 0), jt = () => {
    var n, i;
    if (e.type === "textarea") {
      const { autosize: h } = e;
      if (h && (ot.value = (i = (n = P.value) === null || n === void 0 ? void 0 : n.$el) === null || i === void 0 ? void 0 : i.offsetWidth), !p.value || typeof h == "boolean") return;
      const { paddingTop: k, paddingBottom: M, lineHeight: S } = window.getComputedStyle(p.value), X = Number(k.slice(0, -2)), Q = Number(M.slice(0, -2)), ee = Number(S.slice(0, -2)), { value: me } = m;
      if (!me) return;
      if (h.minRows) {
        const he = Math.max(h.minRows, 1), $e = `${X + Q + ee * he}px`;
        me.style.minHeight = $e;
      }
      if (h.maxRows) {
        const he = `${X + Q + ee * h.maxRows}px`;
        me.style.maxHeight = he;
      }
    }
  }, Dt = j(() => {
    const { maxlength: n } = e;
    return n === void 0 ? void 0 : Number(n);
  });
  _t(() => {
    const { value: n } = N;
    Array.isArray(n) || Le(n);
  });
  const Nt = Qe().proxy;
  function xe(n, i) {
    const { onUpdateValue: h, "onUpdate:value": k, onInput: M } = e, { nTriggerFormInput: S } = J;
    h && E(h, n, i), k && E(k, n, i), M && E(M, n, i), ae.value = n, S();
  }
  function _e(n, i) {
    const { onChange: h } = e, { nTriggerFormChange: k } = J;
    h && E(h, n, i), ae.value = n, k();
  }
  function Lt(n) {
    const { onBlur: i } = e, { nTriggerFormBlur: h } = J;
    i && E(i, n), h();
  }
  function $t(n) {
    const { onFocus: i } = e, { nTriggerFormFocus: h } = J;
    i && E(i, n), h();
  }
  function Wt(n) {
    const { onClear: i } = e;
    i && E(i, n);
  }
  function Vt(n) {
    const { onInputBlur: i } = e;
    i && E(i, n);
  }
  function Ut(n) {
    const { onInputFocus: i } = e;
    i && E(i, n);
  }
  function Gt() {
    const { onDeactivate: n } = e;
    n && E(n);
  }
  function Ht() {
    const { onActivate: n } = e;
    n && E(n);
  }
  function Zt(n) {
    const { onClick: i } = e;
    i && E(i, n);
  }
  function Kt(n) {
    const { onWrapperFocus: i } = e;
    i && E(i, n);
  }
  function qt(n) {
    const { onWrapperBlur: i } = e;
    i && E(i, n);
  }
  function Jt() {
    d.value = true;
  }
  function Yt(n) {
    d.value = false, n.target === C.value ? Se(n, 1) : Se(n, 0);
  }
  function Se(n, i = 0, h = "input") {
    const k = n.target.value;
    if (Le(k), n instanceof InputEvent && !n.isComposing && (d.value = false), e.type === "textarea") {
      const { value: S } = P;
      S && S.syncUnifiedContainer();
    }
    if (c = k, d.value) return;
    I.recordCursor();
    const M = Xt(k);
    if (M) if (!e.pair) h === "input" ? xe(k, { source: i }) : _e(k, { source: i });
    else {
      let { value: S } = N;
      Array.isArray(S) ? S = [S[0], S[1]] : S = ["", ""], S[i] = k, h === "input" ? xe(S, { source: i }) : _e(S, { source: i });
    }
    Nt.$forceUpdate(), M || ge(I.restoreCursor);
  }
  function Xt(n) {
    const { countGraphemes: i, maxlength: h, minlength: k } = e;
    if (i) {
      let S;
      if (h !== void 0 && (S === void 0 && (S = i(n)), S > Number(h)) || k !== void 0 && (S === void 0 && (S = i(n)), S < Number(h))) return false;
    }
    const { allowInput: M } = e;
    return typeof M == "function" ? M(n) : true;
  }
  function Qt(n) {
    Vt(n), n.relatedTarget === f.value && Gt(), n.relatedTarget !== null && (n.relatedTarget === y.value || n.relatedTarget === C.value || n.relatedTarget === p.value) || (l.value = false), Ce(n, "blur"), u.value = null;
  }
  function eo(n, i) {
    Ut(n), G.value = true, l.value = true, Ht(), Ce(n, "focus"), i === 0 ? u.value = y.value : i === 1 ? u.value = C.value : i === 2 && (u.value = p.value);
  }
  function to(n) {
    e.passivelyActivated && (qt(n), Ce(n, "blur"));
  }
  function oo(n) {
    e.passivelyActivated && (G.value = true, Kt(n), Ce(n, "focus"));
  }
  function Ce(n, i) {
    n.relatedTarget !== null && (n.relatedTarget === y.value || n.relatedTarget === C.value || n.relatedTarget === p.value || n.relatedTarget === f.value) || (i === "focus" ? ($t(n), G.value = true) : i === "blur" && (Lt(n), G.value = false));
  }
  function no(n, i) {
    Se(n, i, "change");
  }
  function ro(n) {
    Zt(n);
  }
  function ao(n) {
    Wt(n), nt();
  }
  function nt() {
    e.pair ? (xe(["", ""], { source: "clear" }), _e(["", ""], { source: "clear" })) : (xe("", { source: "clear" }), _e("", { source: "clear" }));
  }
  function io(n) {
    const { onMousedown: i } = e;
    i && i(n);
    const { tagName: h } = n.target;
    if (h !== "INPUT" && h !== "TEXTAREA") {
      if (e.resizable) {
        const { value: k } = f;
        if (k) {
          const { left: M, top: S, width: X, height: Q } = k.getBoundingClientRect(), ee = 14;
          if (M + X - ee < n.clientX && n.clientX < M + X && S + Q - ee < n.clientY && n.clientY < S + Q) return;
        }
      }
      n.preventDefault(), G.value || rt();
    }
  }
  function so() {
    var n;
    Y.value = true, e.type === "textarea" && ((n = P.value) === null || n === void 0 || n.handleMouseEnterWrapper());
  }
  function lo() {
    var n;
    Y.value = false, e.type === "textarea" && ((n = P.value) === null || n === void 0 || n.handleMouseLeaveWrapper());
  }
  function uo() {
    U.value || De.value === "click" && (fe.value = !fe.value);
  }
  function co(n) {
    if (U.value) return;
    n.preventDefault();
    const i = (k) => {
      k.preventDefault(), ft("mouseup", document, i);
    };
    if (pt("mouseup", document, i), De.value !== "mousedown") return;
    fe.value = true;
    const h = () => {
      fe.value = false, ft("mouseup", document, h);
    };
    pt("mouseup", document, h);
  }
  function po(n) {
    e.onKeyup && E(e.onKeyup, n);
  }
  function fo(n) {
    switch (e.onKeydown && E(e.onKeydown, n), n.key) {
      case "Escape":
        Ne();
        break;
      case "Enter":
        mo(n);
        break;
    }
  }
  function mo(n) {
    var i, h;
    if (e.passivelyActivated) {
      const { value: k } = l;
      if (k) {
        e.internalDeactivateOnEnter && Ne();
        return;
      }
      n.preventDefault(), e.type === "textarea" ? (i = p.value) === null || i === void 0 || i.focus() : (h = y.value) === null || h === void 0 || h.focus();
    }
  }
  function Ne() {
    e.passivelyActivated && (l.value = false, ge(() => {
      var n;
      (n = f.value) === null || n === void 0 || n.focus();
    }));
  }
  function rt() {
    var n, i, h;
    U.value || (e.passivelyActivated ? (n = f.value) === null || n === void 0 || n.focus() : ((i = p.value) === null || i === void 0 || i.focus(), (h = y.value) === null || h === void 0 || h.focus()));
  }
  function ho() {
    var n;
    !((n = f.value) === null || n === void 0) && n.contains(document.activeElement) && document.activeElement.blur();
  }
  function vo() {
    var n, i;
    (n = p.value) === null || n === void 0 || n.select(), (i = y.value) === null || i === void 0 || i.select();
  }
  function go() {
    U.value || (p.value ? p.value.focus() : y.value && y.value.focus());
  }
  function yo() {
    const { value: n } = f;
    (n == null ? void 0 : n.contains(document.activeElement)) && n !== document.activeElement && Ne();
  }
  function bo(n) {
    if (e.type === "textarea") {
      const { value: i } = p;
      i == null ? void 0 : i.scrollTo(n);
    } else {
      const { value: i } = y;
      i == null ? void 0 : i.scrollTo(n);
    }
  }
  function Le(n) {
    const { type: i, pair: h, autosize: k } = e;
    if (!h && k) if (i === "textarea") {
      const { value: M } = m;
      M && (M.textContent = `${n ?? ""}\r
`);
    } else {
      const { value: M } = v;
      M && (n ? M.textContent = n : M.innerHTML = "&nbsp;");
    }
  }
  function wo() {
    jt();
  }
  const at = R({ top: "0" });
  function xo(n) {
    var i;
    const { scrollTop: h } = n.target;
    at.value.top = `${-h}px`, (i = P.value) === null || i === void 0 || i.syncUnifiedContainer();
  }
  let ke = null;
  lt(() => {
    const { autosize: n, type: i } = e;
    n && i === "textarea" ? ke = x(N, (h) => {
      !Array.isArray(h) && h !== c && Le(h);
    }) : ke == null ? void 0 : ke();
  });
  let Re = null;
  lt(() => {
    e.type === "textarea" ? Re = x(N, (n) => {
      var i;
      !Array.isArray(n) && n !== c && ((i = P.value) === null || i === void 0 || i.syncUnifiedContainer());
    }) : Re == null ? void 0 : Re();
  }), H(kt, { mergedValueRef: N, maxlengthRef: Dt, mergedClsPrefixRef: t, countGraphemesRef: st(e, "countGraphemes") });
  const _o = { wrapperElRef: f, inputElRef: y, textareaElRef: p, isCompositing: d, clear: nt, focus: rt, blur: ho, select: vo, deactivate: yo, activate: go, scrollTo: bo }, So = Cn("Input", a, t), it = j(() => {
    const { value: n } = de, { common: { cubicBezierEaseInOut: i }, self: { color: h, borderRadius: k, textColor: M, caretColor: S, caretColorError: X, caretColorWarning: Q, textDecorationColor: ee, border: me, borderDisabled: he, borderHover: $e, borderFocus: Co, placeholderColor: ko, placeholderColorDisabled: Ro, lineHeightTextarea: zo, colorDisabled: Io, colorFocus: Mo, textColorDisabled: To, boxShadowFocus: Bo, iconSize: Ao, colorFocusWarning: Eo, boxShadowFocusWarning: Po, borderWarning: Fo, borderFocusWarning: Oo, borderHoverWarning: jo, colorFocusError: Do, boxShadowFocusError: No, borderError: Lo, borderFocusError: $o, borderHoverError: Wo, clearSize: Vo, clearColor: Uo, clearColorHover: Go, clearColorPressed: Ho, iconColor: Zo, iconColorDisabled: Ko, suffixTextColor: qo, countTextColor: Jo, countTextColorDisabled: Yo, iconColorHover: Xo, iconColorPressed: Qo, loadingColor: en, loadingColorError: tn, loadingColorWarning: on, fontWeight: nn, [Ve("padding", n)]: rn, [Ve("fontSize", n)]: an, [Ve("height", n)]: sn } } = s.value, { left: ln, right: un } = kn(rn);
    return { "--n-bezier": i, "--n-count-text-color": Jo, "--n-count-text-color-disabled": Yo, "--n-color": h, "--n-font-size": an, "--n-font-weight": nn, "--n-border-radius": k, "--n-height": sn, "--n-padding-left": ln, "--n-padding-right": un, "--n-text-color": M, "--n-caret-color": S, "--n-text-decoration-color": ee, "--n-border": me, "--n-border-disabled": he, "--n-border-hover": $e, "--n-border-focus": Co, "--n-placeholder-color": ko, "--n-placeholder-color-disabled": Ro, "--n-icon-size": Ao, "--n-line-height-textarea": zo, "--n-color-disabled": Io, "--n-color-focus": Mo, "--n-text-color-disabled": To, "--n-box-shadow-focus": Bo, "--n-loading-color": en, "--n-caret-color-warning": Q, "--n-color-focus-warning": Eo, "--n-box-shadow-focus-warning": Po, "--n-border-warning": Fo, "--n-border-focus-warning": Oo, "--n-border-hover-warning": jo, "--n-loading-color-warning": on, "--n-caret-color-error": X, "--n-color-focus-error": Do, "--n-box-shadow-focus-error": No, "--n-border-error": Lo, "--n-border-focus-error": $o, "--n-border-hover-error": Wo, "--n-loading-color-error": tn, "--n-clear-color": Uo, "--n-clear-size": Vo, "--n-clear-color-hover": Go, "--n-clear-color-pressed": Ho, "--n-icon-color": Zo, "--n-icon-color-hover": Xo, "--n-icon-color-pressed": Qo, "--n-icon-color-disabled": Ko, "--n-suffix-text-color": qo };
  }), ie = r ? Rn("input", j(() => {
    const { value: n } = de;
    return n[0];
  }), it, e) : void 0;
  return Object.assign(Object.assign({}, _o), { wrapperElRef: f, inputElRef: y, inputMirrorElRef: v, inputEl2Ref: C, textareaElRef: p, textareaMirrorElRef: m, textareaScrollbarInstRef: P, rtlEnabled: So, uncontrolledValue: ae, mergedValue: N, passwordVisible: fe, mergedPlaceholder: b, showPlaceholder1: pe, showPlaceholder2: Pt, mergedFocus: je, isComposing: d, activated: l, showClearButton: Ft, mergedSize: de, mergedDisabled: U, textDecorationStyle: Ot, mergedClsPrefix: t, mergedBordered: o, mergedShowPasswordOn: De, placeholderStyle: at, mergedStatus: Oe, textAreaScrollContainerWidth: ot, handleTextAreaScroll: xo, handleCompositionStart: Jt, handleCompositionEnd: Yt, handleInput: Se, handleInputBlur: Qt, handleInputFocus: eo, handleWrapperBlur: to, handleWrapperFocus: oo, handleMouseEnter: so, handleMouseLeave: lo, handleMouseDown: io, handleChange: no, handleClick: ro, handleClear: ao, handlePasswordToggleClick: uo, handlePasswordToggleMousedown: co, handleWrapperKeydown: fo, handleWrapperKeyup: po, handleTextAreaMirrorResize: wo, getTextareaScrollContainer: () => p.value, mergedTheme: s, cssVars: r ? void 0 : it, themeClass: ie == null ? void 0 : ie.themeClass, onRender: ie == null ? void 0 : ie.onRender });
}, render() {
  var e, t;
  const { mergedClsPrefix: o, mergedStatus: r, themeClass: a, type: s, countGraphemes: f, onRender: p } = this, m = this.$slots;
  return p == null ? void 0 : p(), g("div", { ref: "wrapperElRef", class: [`${o}-input`, a, r && `${o}-input--${r}-status`, { [`${o}-input--rtl`]: this.rtlEnabled, [`${o}-input--disabled`]: this.mergedDisabled, [`${o}-input--textarea`]: s === "textarea", [`${o}-input--resizable`]: this.resizable && !this.autosize, [`${o}-input--autosize`]: this.autosize, [`${o}-input--round`]: this.round && s !== "textarea", [`${o}-input--pair`]: this.pair, [`${o}-input--focus`]: this.mergedFocus, [`${o}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, g("div", { class: `${o}-input-wrapper` }, ze(m.prefix, (v) => v && g("div", { class: `${o}-input__prefix` }, v)), s === "textarea" ? g(bn, { ref: "textareaScrollbarInstRef", class: `${o}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var v, y;
    const { textAreaScrollContainerWidth: C } = this, u = { width: this.autosize && C && `${C}px` };
    return g(dn, null, g("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${o}-input__textarea-el`, (v = this.inputProps) === null || v === void 0 ? void 0 : v.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: f ? void 0 : this.maxlength, minlength: f ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (y = this.inputProps) === null || y === void 0 ? void 0 : y.style, u], onBlur: this.handleInputBlur, onFocus: (I) => {
      this.handleInputFocus(I, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? g("div", { class: `${o}-input__placeholder`, style: [this.placeholderStyle, u], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? g(wn, { onResize: this.handleTextAreaMirrorResize }, { default: () => g("div", { ref: "textareaMirrorElRef", class: `${o}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : g("div", { class: `${o}-input__input` }, g("input", Object.assign({ type: s === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : s }, this.inputProps, { ref: "inputElRef", class: [`${o}-input__input-el`, (e = this.inputProps) === null || e === void 0 ? void 0 : e.class], style: [this.textDecorationStyle[0], (t = this.inputProps) === null || t === void 0 ? void 0 : t.style], tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: f ? void 0 : this.maxlength, minlength: f ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (v) => {
    this.handleInputFocus(v, 0);
  }, onInput: (v) => {
    this.handleInput(v, 0);
  }, onChange: (v) => {
    this.handleChange(v, 0);
  } })), this.showPlaceholder1 ? g("div", { class: `${o}-input__placeholder` }, g("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? g("div", { class: `${o}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && ze(m.suffix, (v) => v || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? g("div", { class: `${o}-input__suffix` }, [ze(m["clear-icon-placeholder"], (y) => (this.clearable || y) && g(mt, { clsPrefix: o, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => y, icon: () => {
    var C, u;
    return (u = (C = this.$slots)["clear-icon"]) === null || u === void 0 ? void 0 : u.call(C);
  } })), this.internalLoadingBeforeSuffix ? null : v, this.loading !== void 0 ? g(Bn, { clsPrefix: o, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? v : null, this.showCount && this.type !== "textarea" ? g(ht, null, { default: (y) => {
    var C;
    const { renderCount: u } = this;
    return u ? u(y) : (C = m.count) === null || C === void 0 ? void 0 : C.call(m, y);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? g("div", { class: `${o}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? We(m["password-visible-icon"], () => [g(ct, { clsPrefix: o }, { default: () => g(jn, null) })]) : We(m["password-invisible-icon"], () => [g(ct, { clsPrefix: o }, { default: () => g(Dn, null) })])) : null]) : null)), this.pair ? g("span", { class: `${o}-input__separator` }, We(m.separator, () => [this.separator])) : null, this.pair ? g("div", { class: `${o}-input-wrapper` }, g("div", { class: `${o}-input__input` }, g("input", { ref: "inputEl2Ref", type: this.type, class: `${o}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: f ? void 0 : this.maxlength, minlength: f ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (v) => {
    this.handleInputFocus(v, 1);
  }, onInput: (v) => {
    this.handleInput(v, 1);
  }, onChange: (v) => {
    this.handleChange(v, 1);
  } }), this.showPlaceholder2 ? g("div", { class: `${o}-input__placeholder` }, g("span", null, this.mergedPlaceholder[1])) : null), ze(m.suffix, (v) => (this.clearable || v) && g("div", { class: `${o}-input__suffix` }, [this.clearable && g(mt, { clsPrefix: o, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var y;
    return (y = m["clear-icon"]) === null || y === void 0 ? void 0 : y.call(m);
  }, placeholder: () => {
    var y;
    return (y = m["clear-icon-placeholder"]) === null || y === void 0 ? void 0 : y.call(m);
  } }), v]))) : null, this.mergedBordered ? g("div", { class: `${o}-input__border` }) : null, this.mergedBordered ? g("div", { class: `${o}-input__state-border` }) : null, this.showCount && s === "textarea" ? g(ht, null, { default: (v) => {
    var y;
    const { renderCount: C } = this;
    return C ? C(v) : (y = m.count) === null || y === void 0 ? void 0 : y.call(m, v);
  } }) : null);
} });
function Mr() {
  const e = A(Mn, null);
  return e === null && Ct("use-dialog", "No outer <n-dialog-provider /> founded."), e;
}
function Tr() {
  const e = A(Tn, null);
  return e === null && Ct("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), e;
}
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Fran√ßois de Metz <francois@2metz.fr>
* @license MIT
*/
const Un = Symbol("map"), ue = Un, ye = Symbol("isLoaded"), Gn = Symbol("isInitialized"), Rt = Gn, et = Symbol("componentId"), tt = Symbol("sourceId"), zt = Symbol("sourceLayerRegistry"), Hn = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function Zn(e, t, o, r) {
  return (a) => o.emit(r, { type: a.type, map: t, component: e, event: a });
}
function Kn(e, t) {
  const o = ne.LngLat.convert(e), r = ne.LngLat.convert(t);
  return o.lng === r.lng && o.lat === r.lat;
}
var be = ((e) => (e.TOP_LEFT = "top-left", e.TOP_RIGHT = "top-right", e.BOTTOM_LEFT = "bottom-left", e.BOTTOM_RIGHT = "bottom-right", e))(be || {});
const ce = Object.values(be), vt = /* @__PURE__ */ new Map(), qn = Symbol("default");
function Jn(e, t, o = qn) {
  var _a;
  let r = vt.get(o);
  return r || (r = mn({ isLoaded: false, isMounted: false, language: null }), vt.set(o, r)), r.isLoaded = ((_a = t.value) == null ? void 0 : _a.loaded()) || false, r.isMounted = false, r.component = e, r.map = t.value, r;
}
const Br = z({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (e) => e in be }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(e, t) {
  const o = ut(Qe()), r = qe(), a = qe(), s = R(false), f = R(false), p = /* @__PURE__ */ new Map(), m = Jn(o, a, e.mapKey);
  H(ue, a), H(ye, f), H(Rt, s), H(et, o.uid), H(tt, ""), x(() => e.bearing, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setBearing(u));
  }), x(() => e.bounds, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.fitBounds(u, e.fitBoundsOptions));
  }), x(() => e.center, (u) => {
    var _a, _b;
    const I = (_a = a.value) == null ? void 0 : _a.getCenter();
    u && I && !Kn(u, I) && ((_b = a.value) == null ? void 0 : _b.setCenter(u));
  }), x(() => e.maxBounds, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxBounds(u));
  }), x(() => e.maxPitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxPitch(u));
  }), x(() => e.maxZoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxZoom(u));
  }), x(() => e.minPitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMinPitch(u));
  }), x(() => e.minZoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMinZoom(u));
  }), x(() => e.pitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setPitch(u));
  }), x(() => e.renderWorldCopies, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setRenderWorldCopies(u));
  }), x(() => e.mapStyle, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setStyle(u));
  }), x(() => e.transformRequest, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setTransformRequest(u));
  }), x(() => e.zoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setZoom(u));
  }), x(() => e.zoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setZoom(u));
  });
  function v() {
    m.isMounted = true;
    const u = { ...e, style: e.mapStyle, container: r.value };
    for (const I of Object.keys(u)) u[I] === void 0 && delete u[I];
    if (a.value = ut(new ne.Map(u)), m.map = a.value, s.value = true, p.set("__load", () => (f.value = true, m.isLoaded = true)), a.value.on("load", p.get("__load")), p.set("__moveend", () => t.emit("update:center", a.value.getCenter())), a.value.on("moveend", p.get("__moveend")), p.set("__zoomend", () => t.emit("update:zoom", a.value.getZoom())), a.value.on("zoomend", p.get("__zoomend")), p.set("__pitchend", () => t.emit("update:pitch", a.value.getPitch())), a.value.on("pitchend", p.get("__pitchend")), p.set("__rotateend", () => t.emit("update:bearing", a.value.getBearing())), a.value.on("rotateend", p.get("__rotateend")), o.vnode.props) {
      for (const I of Hn) if (o.vnode.props["onMap:" + I]) {
        const P = `map:${I}`, re = Zn(o, a.value, t, P);
        p.set(I, re), a.value.on(I, re);
      }
    }
    a.value.getCanvas().addEventListener("webglcontextlost", C);
  }
  async function y() {
    m.isMounted = false, m.isLoaded = false, f.value = false, a.value && (a.value.getCanvas().removeEventListener("webglcontextlost", C), s.value = false, p.forEach((u, I) => {
      a.value.off(I.startsWith("__") ? I.substring(2) : I, u);
    }), a.value.remove());
  }
  function C() {
    y(), ge(v);
  }
  return _t(v), le(y), t.expose({ map: a }), () => [g("div", { ref: r, style: { height: e.height, width: e.width } }), s.value && t.slots.default ? t.slots.default({}) : void 0];
}, render() {
  return null;
} });
function Yn(e, t, o) {
  x(e, (r) => {
    var _a, _b;
    r && ce.indexOf(r) === -1 || (((_a = t.value) == null ? void 0 : _a.hasControl(o)) && t.value.removeControl(o), (_b = t.value) == null ? void 0 : _b.addControl(o, r));
  }, { immediate: true });
}
function we(e, t) {
  const o = A(ue), r = A(Rt), a = qe();
  return a.value = e(), Yn(() => t.position, o, a.value), le(() => {
    var _a;
    return r.value && ((_a = o.value) == null ? void 0 : _a.removeControl(a.value));
  }), { control: a, map: o };
}
class Xn {
  constructor(t, o) {
    __publicField(this, "container");
    this.isAdded = t, this.container = document.createElement("div"), this.setClasses(o);
  }
  getDefaultPosition() {
    return be.TOP_LEFT;
  }
  onAdd() {
    return ge(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(t) {
    this.container.className = t;
  }
}
const Ar = z({ name: "MglCustomControl", props: { position: { type: String, validator: (e) => ce.indexOf(e) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(e, { slots: t }) {
  const o = R(false), { control: r } = we(() => new Xn(o, e.class), e);
  return x(() => e.class, () => r.value.setClasses(e.class)), () => {
    var _a;
    return o.value ? g(pn, { to: r.value.container }, (_a = t.default) == null ? void 0 : _a.call(t, {})) : Pe("custom-component");
  };
}, render() {
  return null;
} }), Er = z({ name: "MglFullscreenControl", props: { position: { type: String, validator: (e) => ce.indexOf(e) !== -1 }, container: { type: Object, default: null } }, setup(e) {
  const { control: t, map: o } = we(() => new ne.FullscreenControl({ container: e.container || void 0 }), e);
  function r() {
    ge(() => {
      var _a;
      return (_a = o.value) == null ? void 0 : _a.resize();
    });
  }
  t.value.on("fullscreenstart", r), t.value.on("fullscreenend", r), le(() => {
    t.value.off("fullscreenstart", r), t.value.off("fullscreenend", r);
  });
}, render() {
  return null;
} }), Pr = z({ name: "MglGeolocateControl", props: { position: { type: String, default: be.TOP_RIGHT, validator: (e) => ce.indexOf(e) !== -1 }, positionOptions: { type: Object, default: () => ({ enableHighAccuracy: false, timeout: 6e3 }) }, fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) }, trackUserLocation: { type: Boolean, default: false }, showAccuracyCircle: { type: Boolean, default: true }, showUserLocation: { type: Boolean, default: true } }, emits: ["trackuserlocationstart", "trackuserlocationend", "userlocationlostfocus", "userlocationfocus", "geolocate", "error", "outofmaxbounds"], setup(e, t) {
  const { control: o } = we(() => new ne.GeolocateControl({ positionOptions: e.positionOptions, fitBoundsOptions: e.fitBoundsOptions, trackUserLocation: e.trackUserLocation, showAccuracyCircle: e.showAccuracyCircle, showUserLocation: e.showUserLocation }), e);
  function r(a) {
    const s = (f) => {
      t.emit(a, f);
    };
    o.value.on(a, s), le(() => {
      o.value.off(a, s);
    });
  }
  r("trackuserlocationstart"), r("trackuserlocationend"), r("userlocationlostfocus"), r("userlocationfocus"), r("geolocate"), r("error"), r("outofmaxbounds");
}, render() {
  return null;
} }), Fr = z({ name: "MglNavigationControl", props: { position: { type: String, validator: (e) => ce.indexOf(e) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(e) {
  we(() => new ne.NavigationControl({ showCompass: e.showCompass, showZoom: e.showZoom, visualizePitch: e.visualizePitch }), e);
}, render() {
  return null;
} });
var It = ((e) => (e.IMPERIAL = "imperial", e.METRIC = "metric", e.NAUTICAL = "nautical", e))(It || {});
const Qn = Object.values(It), Or = z({ name: "MglScaleControl", props: { position: { type: String, validator: (e) => ce.indexOf(e) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (e) => Qn.indexOf(e) !== -1 } }, setup(e) {
  we(() => new ne.ScaleControl({ maxWidth: e.maxWidth, unit: e.unit }), e);
}, render() {
  return null;
} });
class er {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(t, o) {
    this.unmountHandlers.set(t, o);
  }
  unregisterUnmountHandler(t) {
    this.unmountHandlers.delete(t);
  }
  unmount() {
    this.unmountHandlers.forEach((t) => t());
  }
}
const _se = class _se {
  static genSourceOpts(t) {
    const o = { ...t };
    for (const r of Object.keys(o)) (o[r] === void 0 || r === "sourceId") && delete o[r];
    return o;
  }
  static getSourceRef(t, o) {
    const r = typeof o == "string", a = String(t) + (r ? o : "");
    let s = _se.REFS.get(a);
    return s || (s = R(r ? null : void 0), _se.REFS.set(a, s)), s;
  }
};
__publicField(_se, "REFS", /* @__PURE__ */ new Map());
let se = _se;
function tr(e, t, o) {
  const r = A(ue), a = A(ye);
  function s() {
    a.value && (r.value.addSource(t.sourceId, se.genSourceOpts(t)), e.value = r.value.getSource(t.sourceId));
  }
  return x(a, s, { immediate: true }), r.value.on("style.load", s), le(() => {
    a.value && (o.unmount(), r.value.removeSource(t.sourceId)), r.value.off("style.load", s);
  });
}
const jr = z({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(e, { slots: t }) {
  const o = A(et), r = se.getSourceRef(o, e.sourceId), a = new er(), s = { ...e, type: "geojson" };
  return H(tt, e.sourceId), H(zt, a), tr(r, s, a), x([fn(e.data) ? e.data : () => e.data, r], ([f, p]) => {
    p == null ? void 0 : p.setData(f || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [Pe("GeoJSON Source"), r.value && t.default ? t.default({}) : void 0];
} }), W = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function K() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function or(e, t, o, r) {
  const a = { id: e, type: t, source: o.source || r, metadata: o.metadata, minzoom: o.minzoom, maxzoom: o.maxzoom, "source-layer": o.sourceLayer, filter: o.filter, paint: o.paint, layout: o.layout };
  for (const s of Object.keys(a)) a[s] === void 0 && delete a[s];
  return a;
}
function nr(e, t, o) {
  if (o.props) for (const r of W) {
    const a = "on" + r.charAt(0).toUpperCase() + r.substr(1);
    o.props[a] && e.on(r, t, o.props[a]);
  }
}
function rr(e, t, o) {
  if (o.props) for (const r of W) {
    const a = "on" + r.charAt(0).toUpperCase() + r.substr(1);
    o.props[a] && e.off(r, t, o.props[a]);
  }
}
function Mt(e, t) {
  const o = A(ue), r = A(ye), a = A(zt);
  function s() {
    r.value && (t && rr(o.value, e, t.vnode), o.value.getLayer(e) && o.value.removeLayer(e));
  }
  a.registerUnmountHandler(e, s), le(() => {
    a.unregisterUnmountHandler(e), s();
  });
}
z({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...W], setup(e) {
  const t = A(ue), o = A(ye);
  return Mt(e.layerId), x(() => e.layout, (r) => {
    if (r) for (const [a, s] of Object.entries(r)) t.value.setLayoutProperty(e.layerId, a, s);
  }), x(() => e.paint, (r) => {
    if (r) for (const [a, s] of Object.entries(r)) t.value.setPaintProperty(e.layerId, a, s);
  }), x(o, (r) => {
    r && t.value.addLayer({ id: e.layerId, type: "background", metadata: e.metadata, minzoom: e.minzoom, maxzoom: e.maxzoom, layout: e.layout, paint: e.paint }, e.before || void 0);
  }, { immediate: true }), () => Pe("Background Layer");
} });
function q(e, t) {
  const o = A(tt);
  if (!o && !t.source) return;
  const r = Qe(), a = A(ue), s = A(ye), f = A(et), p = se.getSourceRef(f, t.source || o);
  return Mt(t.layerId, r), x(() => t.minzoom, () => a.value.setLayerZoomRange(t.layerId, t.minzoom || 0, t.maxzoom || 24)), x(() => t.maxzoom, () => a.value.setLayerZoomRange(t.layerId, t.minzoom || 0, t.maxzoom || 24)), x(() => t.layout, (m) => {
    if (m) for (const [v, y] of Object.entries(m)) a.value.setLayoutProperty(t.layerId, v, y);
  }, { deep: true }), x(() => t.paint, (m) => {
    if (m) for (const [v, y] of Object.entries(m)) a.value.setPaintProperty(t.layerId, v, y);
  }, { deep: true }), x(() => t.filter, (m) => a.value.setFilter(t.layerId, m), { deep: true }), x([s, p], ([m, v]) => {
    m && (v || v === void 0) && (a.value.addLayer(or(t.layerId, e, t, o), t.before || void 0), nr(a.value, t.layerId, r.vnode));
  }, { immediate: true }), () => Pe(`${e} Layer`);
}
z({ name: "MglCircleLayer", props: K(), emits: [...W], setup(e) {
  return q("circle", e);
} });
z({ name: "MglFillLayer", props: K(), emits: [...W], setup(e) {
  return q("fill", e);
} });
z({ name: "MglFillExtrusionLayer", props: K(), emits: [...W], setup(e) {
  return q("fill-extrusion", e);
} });
z({ name: "MglHeatmapLayer", props: K(), emits: [...W], setup(e) {
  return q("heatmap", e);
} });
z({ name: "MglHillshadeLayer", props: K(), emits: [...W], setup(e) {
  return q("hillshade", e);
} });
const Dr = z({ name: "MglLineLayer", props: K(), emits: [...W], setup(e) {
  return q("line", e);
} });
z({ name: "MglRasterLayer", props: K(), emits: [...W], setup(e) {
  return q("raster", e);
} });
z({ name: "MglSymbolLayer", props: K(), emits: [...W], setup(e) {
  return q("symbol", e);
} });
const B = [];
for (let e = 0; e < 256; ++e) B.push((e + 256).toString(16).slice(1));
function ar(e, t = 0) {
  return (B[e[t + 0]] + B[e[t + 1]] + B[e[t + 2]] + B[e[t + 3]] + "-" + B[e[t + 4]] + B[e[t + 5]] + "-" + B[e[t + 6]] + B[e[t + 7]] + "-" + B[e[t + 8]] + B[e[t + 9]] + "-" + B[e[t + 10]] + B[e[t + 11]] + B[e[t + 12]] + B[e[t + 13]] + B[e[t + 14]] + B[e[t + 15]]).toLowerCase();
}
let Ue;
const ir = new Uint8Array(16);
function sr() {
  if (!Ue) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Ue = crypto.getRandomValues.bind(crypto);
  }
  return Ue(ir);
}
const lr = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), gt = { randomUUID: lr };
function oe(e, t, o) {
  var _a;
  if (gt.randomUUID && !e) return gt.randomUUID();
  e = e || {};
  const r = e.random ?? ((_a = e.rng) == null ? void 0 : _a.call(e)) ?? sr();
  if (r.length < 16) throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, ar(r);
}
function $() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function ur() {
  return { ...$(), version: 1, signature: void 0 };
}
class te {
  constructor(t = oe(), o, r, a) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = t, this.routes = o || { id: oe(), meta: $(), routes: [] }, this.drafts = r || { id: oe(), meta: $(), drafts: [] }, this.meta = { ...ur(), ...a };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(t) {
    return new te(t.id, t.routes, t.drafts, t.meta);
  }
  clone() {
    return te.fromStorage(this.toStorage());
  }
  updateName(t) {
    this.meta.name = t, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(t) {
    this.meta.description = t, this.meta.modification_timestamp = Date.now();
  }
  addTag(t) {
    this.meta.tags.includes(t) || (this.meta.tags.push(t), this.meta.modification_timestamp = Date.now());
  }
  removeTag(t) {
    const o = this.meta.tags.indexOf(t);
    o > -1 && (this.meta.tags.splice(o, 1), this.meta.modification_timestamp = Date.now());
  }
}
class Tt {
  constructor(t = [], o = oe(), r = $()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = o, this.meta = r || $(), this.routesInternal = t;
  }
  get name() {
    return this.meta || (this.meta = $()), this.meta.name;
  }
  set name(t) {
    this.meta || (this.meta = $()), this.meta.name = t;
  }
  get routes() {
    return V(this.routesInternal);
  }
  set routes(t) {
    this.routesInternal = V(t);
  }
  findRoute(t) {
    return this.routesInternal.find((o) => o.id === t);
  }
  existRoute(t) {
    return this.routesInternal.some((o) => o.id === t);
  }
  addRoute(t) {
    if (this.existRoute(t.id)) throw new Error(`[CartoSketch.Route] Route ${t.id} already exist`);
    this.routesInternal.push(V(t)), this.updateModificationTime();
  }
  updateRoute(t) {
    const o = this.routesInternal.findIndex((r) => r.id === t.id);
    if (o === -1) throw new Error(`[CartoSketch.Route] Route ${t.id} not found`);
    this.routesInternal[o] = V(t), this.updateModificationTime();
  }
  removeRoute(t) {
    const o = this.routesInternal.findIndex((r) => r.id === t);
    o !== -1 && (this.routesInternal.splice(o, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((t) => t.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((t) => t.exportToStorage()) });
  }
}
class Te {
  constructor(t = oe(), o = [], r = {}, a) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = t, this.meta = { ...$(), record_timespan: 0, ...a }, this.properties = r, this.points = o;
  }
  get name() {
    return this.meta || (this.meta = $()), this.meta.name;
  }
  set name(t) {
    this.meta || (this.meta = $()), this.meta.name = t;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(t) {
    this.meta.distance = t;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(t) {
    this.meta.record_timespan = t;
  }
  setPoints(t) {
    this.points = V(t), this.updateModificationTime();
  }
  appendPoint(t) {
    this.points.push(V(t)), this.updateModificationTime();
  }
  getPoints() {
    return V(this.points);
  }
  setProperties(t) {
    const o = V(t);
    Object.assign(this.properties, o), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((t) => [t.longitude, t.latitude]) } };
  }
  exportToStorage() {
    return V({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
function cr(e) {
  if (!e) throw new Error("[importItemFromStorage] Invalid data provided");
  const t = new Te(e.id || oe(), e.points || [], e.properties || {}, e.meta);
  return e.meta && (t.meta = e.meta), t;
}
function dr(e) {
  if (!e) throw new Error("[readCollectionFromStorage] Invalid data provided");
  const t = (e.routes || []).map((r) => cr(r)), o = new Tt(t, e.id || oe(), e.meta);
  return e.meta && (o.meta = e.meta), o;
}
let _;
const Bt = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Bt.decode();
let Me = null;
function Be() {
  return (Me === null || Me.byteLength === 0) && (Me = new Uint8Array(_.memory.buffer)), Me;
}
function Ge(e, t) {
  return e = e >>> 0, Bt.decode(Be().subarray(e, e + t));
}
let Je = 0;
const Ae = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, pr = typeof Ae.encodeInto == "function" ? function(e, t) {
  return Ae.encodeInto(e, t);
} : function(e, t) {
  const o = Ae.encode(e);
  return t.set(o), { read: e.length, written: o.length };
};
function fr(e, t, o) {
  if (o === void 0) {
    const p = Ae.encode(e), m = t(p.length, 1) >>> 0;
    return Be().subarray(m, m + p.length).set(p), Je = p.length, m;
  }
  let r = e.length, a = t(r, 1) >>> 0;
  const s = Be();
  let f = 0;
  for (; f < r; f++) {
    const p = e.charCodeAt(f);
    if (p > 127) break;
    s[a + f] = p;
  }
  if (f !== r) {
    f !== 0 && (e = e.slice(f)), a = o(a, r, r = f + e.length * 3, 1) >>> 0;
    const p = Be().subarray(a + f, a + r), m = pr(e, p);
    f += m.written, a = o(a, r, f, 1) >>> 0;
  }
  return Je = f, a;
}
function At(e) {
  const t = _.__wbindgen_export_0.get(e);
  return _.__externref_table_dealloc(e), t;
}
function He(e, t) {
  if (!(e instanceof t)) throw new Error(`expected instance of ${t.name}`);
}
function mr(e, t, o) {
  He(e, Ee), He(t, Ee), He(o, Et);
  const r = _.transform(e.__wbg_ptr, t.__wbg_ptr, o.__wbg_ptr);
  if (r[1]) throw At(r[0]);
}
const yt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e) => _.__wbg_point_free(e >>> 0, 1));
class Et {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yt.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    _.__wbg_point_free(t, 0);
  }
  get x() {
    return _.__wbg_get_point_x(this.__wbg_ptr);
  }
  set x(t) {
    _.__wbg_set_point_x(this.__wbg_ptr, t);
  }
  get y() {
    return _.__wbg_get_point_y(this.__wbg_ptr);
  }
  set y(t) {
    _.__wbg_set_point_y(this.__wbg_ptr, t);
  }
  get z() {
    return _.__wbg_get_point_z(this.__wbg_ptr);
  }
  set z(t) {
    _.__wbg_set_point_z(this.__wbg_ptr, t);
  }
  constructor(t, o, r) {
    const a = _.point_new(t, o, r);
    return this.__wbg_ptr = a >>> 0, yt.register(this, this.__wbg_ptr, this), this;
  }
}
const bt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e) => _.__wbg_projection_free(e >>> 0, 1));
class Ee {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bt.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    _.__wbg_projection_free(t, 0);
  }
  constructor(t) {
    const o = fr(t, _.__wbindgen_malloc, _.__wbindgen_realloc), r = Je, a = _.projection_new(o, r);
    if (a[2]) throw At(a[1]);
    return this.__wbg_ptr = a[0] >>> 0, bt.register(this, this.__wbg_ptr, this), this;
  }
  get projName() {
    let t, o;
    try {
      const r = _.projection_projName(this.__wbg_ptr);
      return t = r[0], o = r[1], Ge(r[0], r[1]);
    } finally {
      _.__wbindgen_free(t, o, 1);
    }
  }
  get isLatlon() {
    return _.projection_isLatlon(this.__wbg_ptr) !== 0;
  }
  get isGeocentric() {
    return _.projection_isGeocentric(this.__wbg_ptr) !== 0;
  }
  get axis() {
    let t, o;
    try {
      const r = _.projection_axis(this.__wbg_ptr);
      return t = r[0], o = r[1], Ge(r[0], r[1]);
    } finally {
      _.__wbindgen_free(t, o, 1);
    }
  }
  get isNormalizedAxis() {
    return _.projection_isNormalizedAxis(this.__wbg_ptr) !== 0;
  }
  get to_meter() {
    return _.projection_to_meter(this.__wbg_ptr);
  }
  get units() {
    let t, o;
    try {
      const r = _.projection_units(this.__wbg_ptr);
      return t = r[0], o = r[1], Ge(r[0], r[1]);
    } finally {
      _.__wbindgen_free(t, o, 1);
    }
  }
}
const Ze = { WGS84: "+proj=longlat +datum=WGS84 +no_defs", GRS80: "+proj=latlong +ellps=GRS80 +no_defs", UTM_ZONE_50N: "+proj=utm +zone=50 +datum=WGS84 +units=m +no_defs", UTM_ZONE_51N: "+proj=utm +zone=51 +datum=WGS84 +units=m +no_defs", CGCS2000_3_DEGREE: "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs", BEIJING_1954: "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=krass +units=m +no_defs", WEB_MERCATOR: "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs" };
function wt(e, t, o) {
  try {
    const r = new Ee(e), a = new Ee(t), s = new Et(o[0], o[1], 0);
    mr(r, a, s);
    const f = [s.x, s.y];
    return r.free(), a.free(), s.free(), f;
  } catch (r) {
    throw new Error(`Failed to transform coordinate: ${r instanceof Error ? r.message : String(r)}`);
  }
}
function hr(e, t) {
  const o = t.x - e.x, r = t.y - e.y;
  return Math.sqrt(o * o + r * r);
}
function xt(e, t) {
  const r = e.latitude * Math.PI / 180, a = t.latitude * Math.PI / 180, s = (t.latitude - e.latitude) * Math.PI / 180, f = (t.longitude - e.longitude) * Math.PI / 180, p = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(r) * Math.cos(a) * Math.sin(f / 2) * Math.sin(f / 2);
  return 6371e3 * (2 * Math.atan2(Math.sqrt(p), Math.sqrt(1 - p)));
}
function vr(e, t, o = {}) {
  const { projection: r = Ze.CGCS2000_3_DEGREE, useHaversine: a = false } = o;
  if (a) return xt(e, t);
  try {
    const s = wt(Ze.WGS84, r, [e.longitude, e.latitude]), f = wt(Ze.WGS84, r, [t.longitude, t.latitude]);
    return hr({ x: s[0], y: s[1] }, { x: f[0], y: f[1] });
  } catch (s) {
    return console.warn("Failed to use proj4 distance calculation, falling back to haversine:", s), xt(e, t);
  }
}
function Ke(e, t = {}) {
  if (e.length < 2) return 0;
  let o = 0;
  for (let r = 1; r < e.length; r++) o += vr(e[r - 1], e[r], t);
  return o;
}
function Nr(e) {
  return e < 1e3 ? `${Math.round(e)} m` : e < 1e4 ? `${(e / 1e3).toFixed(1)} km` : `${Math.round(e / 1e3)} km`;
}
const Lr = hn("sketches", () => {
  const e = R([]), t = R(null), o = R(null), r = j(() => {
    if (!t.value) return null;
    const d = e.value.find((l) => l.id === t.value);
    return d ? new Tt(d.routes.routes.map((l) => new Te(l.id, l.points, l.properties, l.meta)), d.routes.id, d.routes.meta) : null;
  }), a = j(() => r.value ? r.value.routes.map((d) => ({ id: d.id, name: d.name, points: d.getPoints(), meta: d.meta })) : []), s = j(() => t.value && e.value.find((d) => d.id === t.value) || null), f = j(() => s.value ? s.value.drafts.drafts : []);
  async function p() {
    const d = await vn("sketches");
    d ? d && typeof d == "object" && "routes" in d && !("sketches" in d) ? (console.info("[SketchStore] Migrating old route data to new sketch format"), await m(d)) : Array.isArray(d) ? (e.value = d.map((l) => te.fromStorage(l)), e.value.forEach((l) => {
      l.routes.routes.forEach((c) => {
        c.points.length > 1 && !c.meta.distance && (c.meta.distance = Ke(c.points));
      });
    }), !t.value && e.value.length > 0 && (t.value = e.value[0].id)) : await v() : await v();
  }
  async function m(d) {
    try {
      const l = dr(d), c = new te();
      c.meta.name = l.meta.name || "Migrated Routes", c.routes = l.exportToStorage(), e.value = [c], t.value = c.id, await F("sketches", e.value.map((b) => b.toStorage())), await O(), console.info("[SketchStore] Route migration to sketch format complete");
    } catch (l) {
      console.error("[SketchStore] Failed to migrate route data:", l), await v();
    }
  }
  async function v() {
    const d = new te();
    d.meta.name = "Default Sketch", e.value = [d], t.value = d.id, await F("sketches", e.value.map((l) => l.toStorage())), await O();
  }
  async function y(d = "New Sketch") {
    const l = new te();
    return l.meta.name = d, e.value.push(l), await F("sketches", e.value.map((c) => c.toStorage())), await O(), l;
  }
  async function C(d, l) {
    const c = e.value.find((b) => b.id === d);
    c && (l.name !== void 0 && c.updateName(l.name), l.description !== void 0 && c.updateDescription(l.description), l.tags !== void 0 && (c.meta.tags.forEach((b) => c.removeTag(b)), l.tags.forEach((b) => c.addTag(b))), await F("sketches", e.value.map((b) => b.toStorage())), await O());
  }
  async function u(d) {
    const l = e.value.findIndex((c) => c.id === d);
    l !== -1 && (e.value.splice(l, 1), t.value === d && (t.value = e.value.length > 0 ? e.value[0].id : null), await F("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function I(d) {
    t.value = d, o.value = null;
  }
  async function P(d, l = {}, c = {}) {
    s.value || await v();
    const b = new Te(void 0, [], l, c);
    return b.meta.name = d, s.value && s.value.routes.routes.push(b.exportToStorage()), await F("sketches", e.value.map((pe) => pe.toStorage())), await O(), b;
  }
  async function re(d) {
    if (!s.value) return;
    const l = s.value.routes.routes.findIndex((c) => c.id === d);
    l !== -1 && (s.value.routes.routes.splice(l, 1), o.value === d && (o.value = null), await F("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  async function ae(d, l) {
    if (!s.value) return;
    const c = s.value.routes.routes.find((b) => b.id === d);
    if (c) {
      if (c.points.push(l), c.meta.modification_timestamp = Date.now(), c.points.length > 1) if (c.meta.distance) {
        const b = Ke([c.points[c.points.length - 2], l]);
        c.meta.distance += b;
      } else {
        const b = Ke(c.points);
        c.meta.distance = b;
      }
      await F("sketches", e.value.map((b) => b.toStorage())), await O();
    }
  }
  async function Fe(d, l) {
    if (!s.value) return;
    const c = s.value.routes.routes.find((b) => b.id === d);
    c && (l.meta !== void 0 && (c.meta = { ...c.meta, ...l.meta }), l.properties !== void 0 && (c.properties = { ...c.properties, ...l.properties }), c.meta.modification_timestamp = Date.now(), await F("sketches", e.value.map((b) => b.toStorage())), await O());
  }
  async function N(d) {
    if (!s.value) return;
    const l = s.value.routes.routes.find((c) => c.id === d);
    l && (l.points = [], l.meta.modification_timestamp = Date.now(), await F("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function J(d) {
    if (!s.value) return null;
    const l = s.value.routes.routes.find((c) => c.id === d);
    return l ? new Te(l.id, l.points, l.properties, l.meta) : null;
  }
  function de(d) {
    o.value = d;
  }
  async function U(d, l = {}, c = {}) {
    s.value || await v();
    const b = { id: crypto.randomUUID(), meta: { ...$(), ...c }, shape: d, properties: l };
    return s.value && s.value.drafts.drafts.push(b), await F("sketches", e.value.map((pe) => pe.toStorage())), await O(), b;
  }
  async function Oe(d, l) {
    if (!s.value) return;
    const c = s.value.drafts.drafts.find((b) => b.id === d);
    c && (l.shape !== void 0 && (c.shape = l.shape), l.properties !== void 0 && (c.properties = { ...c.properties, ...l.properties }), l.meta !== void 0 && (c.meta = { ...c.meta, ...l.meta }, c.meta.modification_timestamp = Date.now()), await F("sketches", e.value.map((b) => b.toStorage())), await O());
  }
  async function G(d) {
    if (!s.value) return;
    const l = s.value.drafts.drafts.findIndex((c) => c.id === d);
    l !== -1 && (s.value.drafts.drafts.splice(l, 1), await F("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function Y(d) {
    return s.value && s.value.drafts.drafts.find((l) => l.id === d) || null;
  }
  return { sketches: e, currentSketchId: t, currentRouteId: o, routeCollection: r, routes: a, currentSketch: s, currentDrafts: f, init: p, createSketch: y, updateSketch: C, deleteSketch: u, setCurrentSketchId: I, addRoute: P, deleteRoute: re, addPointToRoute: ae, updateRoute: Fe, clearRoutePoints: N, getRouteById: J, setCurrentRouteId: de, addDraft: U, updateDraft: Oe, deleteDraft: G, getDraftById: Y };
});
export {
  zr as A,
  Or as C,
  jn as E,
  Fr as L,
  Er as M,
  Ir as N,
  Cr as R,
  Ar as S,
  kr as T,
  Rr as U,
  Dr as V,
  jr as _,
  Tr as a,
  Mr as b,
  Nr as f,
  Pr as h,
  Lr as u,
  Br as y
};
