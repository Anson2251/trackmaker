var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import { E as Uf, G as Yw, H as Kw, I as Jw, d as ot, c as Xt, o as wt, a as Pt, J as zl, j as Me, b as Re, f as Sn, i as pr, L as Qd, q as Ht, k as ji, p as Zr, h as B, m as Cs, M as Qw, N as S_, t as Bt, O as Qa, B as Io, P as Vn, F as Hr, w as vo, Q as ga, R as e2, S as sg, U as t2, V as In, W as r2, T as k_, X as Xv, Y as Ss, x as jr, Z as i2, g as n2, $ as es, u as Fl, v as J, a0 as tc, n as qo, A as ur, _ as Qn, a1 as Ha, a2 as o2, a3 as a2, a4 as $i, a5 as Dr, a6 as $g, a7 as Mm, C as Tr, y as Ne, s as $e, z as Pr, D as rc, a8 as s2, a9 as jg, aa as fn, ab as $d, ac as l2, ad as P_, l as u2, ae as c2, af as d2, ag as yf, ah as _f } from "./index-BDOzEWAQ.js";
import { u as Eo } from "./vue-i18n-CkQPQCyI.js";
import { bq as h2, br as T_, bs as f2, b0 as yi, b3 as Pl, bt as I_, bu as zd, bv as M_, bw as en, bx as Nn, by as tp, bz as Em, aT as E_, a4 as ce, a7 as Ue, ac as Mr, bA as cc, b1 as jd, bB as va, a3 as Ge, a6 as Fe, a8 as Nd, a9 as rp, bC as Kn, aj as Wr, af as rr, B as p2, ag as Jt, ah as bi, aa as Cl, bD as Ng, a_ as pi, bE as ip, bF as Ii, ai as np, bG as eh, ae as Un, bH as m2, bI as g2, bJ as Zo, bK as Tl, bL as v2, ab as Vg, bM as y2, bN as Yv, b9 as jt, R as Rn, bO as _2, b7 as Kv, bi as Ug, bP as b2, bQ as R_, T as lg, bR as x2, bS as ug, bT as w2, bU as C2, b5 as Hi, bV as ya, bW as En, bX as Xn, bY as op, bZ as S2, b_ as A_, b$ as D_, c0 as k2, $ as Dl, a5 as cg, c1 as P2, ap as qg, c2 as T2, c3 as I2, c4 as M2, c5 as Xo, r as Go, c6 as Ka, c7 as Il, c8 as Bf, c9 as Ja, ca as _s, cb as ws, cc as Qu, cd as Ml, ce as z_, cf as dg, cg as hg, ch as fg, ci as Fd, cj as pg, ck as mg, cl as gg, cm as qf, cn as F_, co as L_, cp as B_, cq as ic, cr as Gf, cs as E2, ct as ap, cu as O_, bg as Nr, cv as R2, b6 as Wf, b4 as A2, cw as D2, cx as El, cy as z2, a$ as $_, cz as j_, cA as F2, a0 as L2, aq as B2, cB as O2, cC as $2, cD as Gg, cE as j2, cF as N2, cG as V2, cH as U2, c as th, cI as Zf, cJ as N_, cK as V_, cL as q2, cM as Wo, cN as G2, cO as W2, cP as Z2, cQ as U_, cR as H2, cS as X2, cT as q_, cU as G_, cV as Y2, cW as K2, cX as J2, cY as Jv, cZ as Q2, am as Wg, X as W_, c_ as eC, c$ as tC, d0 as rC, ao as Z_, al as H_, an as X_, d1 as iC, d2 as nC, d3 as oC, d4 as Rm, d5 as aC, d6 as sC, d7 as Y_, d8 as Qv, d9 as lC, aV as ey, da as K_, db as fo, dc as po, bh as Ci, U as Vd, b2 as J_, bd as Zg, bo as Cd, bc as uC, bm as Q_, bf as Za, bp as ty, bn as cC, dd as Xa, bk as dC, be as eb, de as hC, df as fC } from "./platform-Vc3gnJhU.js";
var pC = /\s/;
function mC(r) {
  for (var i = r.length; i-- && pC.test(r.charAt(i)); ) ;
  return i;
}
var gC = /^\s+/;
function vC(r) {
  return r && r.slice(0, mC(r) + 1).replace(gC, "");
}
var ry = NaN, yC = /^[-+]0x[0-9a-f]+$/i, _C = /^0b[01]+$/i, bC = /^0o[0-7]+$/i, xC = parseInt;
function Ld(r) {
  if (typeof r == "number") return r;
  if (h2(r)) return ry;
  if (Uf(r)) {
    var i = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Uf(i) ? i + "" : i;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = vC(r);
  var l = _C.test(r);
  return l || bC.test(r) ? xC(r.slice(2), l ? 2 : 8) : yC.test(r) ? ry : +r;
}
function wC(r, i, l, d) {
  for (var f = -1, g = r == null ? 0 : r.length; ++f < g; ) l = i(l, r[f], f, r);
  return l;
}
function CC(r) {
  return function(i) {
    return r == null ? void 0 : r[i];
  };
}
var SC = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, kC = CC(SC), PC = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, TC = "\\u0300-\\u036f", IC = "\\ufe20-\\ufe2f", MC = "\\u20d0-\\u20ff", EC = TC + IC + MC, RC = "[" + EC + "]", AC = RegExp(RC, "g");
function DC(r) {
  return r = T_(r), r && r.replace(PC, kC).replace(AC, "");
}
var zC = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function FC(r) {
  return r.match(zC) || [];
}
var LC = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function BC(r) {
  return LC.test(r);
}
var tb = "\\ud800-\\udfff", OC = "\\u0300-\\u036f", $C = "\\ufe20-\\ufe2f", jC = "\\u20d0-\\u20ff", NC = OC + $C + jC, rb = "\\u2700-\\u27bf", ib = "a-z\\xdf-\\xf6\\xf8-\\xff", VC = "\\xac\\xb1\\xd7\\xf7", UC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", qC = "\\u2000-\\u206f", GC = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", nb = "A-Z\\xc0-\\xd6\\xd8-\\xde", WC = "\\ufe0e\\ufe0f", ob = VC + UC + qC + GC, ab = "['\u2019]", iy = "[" + ob + "]", ZC = "[" + NC + "]", sb = "\\d+", HC = "[" + rb + "]", lb = "[" + ib + "]", ub = "[^" + tb + ob + sb + rb + ib + nb + "]", XC = "\\ud83c[\\udffb-\\udfff]", YC = "(?:" + ZC + "|" + XC + ")", KC = "[^" + tb + "]", cb = "(?:\\ud83c[\\udde6-\\uddff]){2}", db = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ku = "[" + nb + "]", JC = "\\u200d", ny = "(?:" + lb + "|" + ub + ")", QC = "(?:" + Ku + "|" + ub + ")", oy = "(?:" + ab + "(?:d|ll|m|re|s|t|ve))?", ay = "(?:" + ab + "(?:D|LL|M|RE|S|T|VE))?", hb = YC + "?", fb = "[" + WC + "]?", e3 = "(?:" + JC + "(?:" + [KC, cb, db].join("|") + ")" + fb + hb + ")*", t3 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", r3 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", i3 = fb + hb + e3, n3 = "(?:" + [HC, cb, db].join("|") + ")" + i3, o3 = RegExp([Ku + "?" + lb + "+" + oy + "(?=" + [iy, Ku, "$"].join("|") + ")", QC + "+" + ay + "(?=" + [iy, Ku + ny, "$"].join("|") + ")", Ku + "?" + ny + "+" + oy, Ku + "+" + ay, r3, t3, sb, n3].join("|"), "g");
function a3(r) {
  return r.match(o3) || [];
}
function s3(r, i, l) {
  return r = T_(r), i = i, i === void 0 ? BC(r) ? a3(r) : FC(r) : r.match(i) || [];
}
var l3 = "['\u2019]", u3 = RegExp(l3, "g");
function c3(r) {
  return function(i) {
    return wC(s3(DC(i).replace(u3, "")), r, "");
  };
}
function d3(r, i, l) {
  return r === r && (l !== void 0 && (r = r <= l ? r : l), i !== void 0 && (r = r >= i ? r : i)), r;
}
function vg(r, i, l) {
  return l === void 0 && (l = i, i = void 0), l !== void 0 && (l = Ld(l), l = l === l ? l : 0), i !== void 0 && (i = Ld(i), i = i === i ? i : 0), d3(Ld(r), i, l);
}
var Am = function() {
  return Yw.Date.now();
}, h3 = "Expected a function", f3 = Math.max, p3 = Math.min;
function m3(r, i, l) {
  var d, f, g, m, s, C, P = 0, M = false, F = false, D = true;
  if (typeof r != "function") throw new TypeError(h3);
  i = Ld(i) || 0, Uf(l) && (M = !!l.leading, F = "maxWait" in l, g = F ? f3(Ld(l.maxWait) || 0, i) : g, D = "trailing" in l ? !!l.trailing : D);
  function A(X) {
    var Se = d, pe = f;
    return d = f = void 0, P = X, m = r.apply(pe, Se), m;
  }
  function O(X) {
    return P = X, s = setTimeout(W, i), M ? A(X) : m;
  }
  function V(X) {
    var Se = X - C, pe = X - P, oe = i - Se;
    return F ? p3(oe, g - pe) : oe;
  }
  function Y(X) {
    var Se = X - C, pe = X - P;
    return C === void 0 || Se >= i || Se < 0 || F && pe >= g;
  }
  function W() {
    var X = Am();
    if (Y(X)) return ee(X);
    s = setTimeout(W, V(X));
  }
  function ee(X) {
    return s = void 0, D && d ? A(X) : (d = f = void 0, m);
  }
  function ie() {
    s !== void 0 && clearTimeout(s), P = 0, d = C = f = s = void 0;
  }
  function te() {
    return s === void 0 ? m : ee(Am());
  }
  function re() {
    var X = Am(), Se = Y(X);
    if (d = arguments, f = this, C = X, Se) {
      if (s === void 0) return O(C);
      if (F) return clearTimeout(s), s = setTimeout(W, i), A(C);
    }
    return s === void 0 && (s = setTimeout(W, i)), m;
  }
  return re.cancel = ie, re.flush = te, re;
}
var g3 = "[object Number]";
function v3(r) {
  return typeof r == "number" || Kw(r) && Jw(r) == g3;
}
var y3 = c3(function(r, i, l) {
  return r + (l ? "-" : "") + i.toLowerCase();
}), _3 = "Expected a function";
function b3(r, i, l) {
  var d = true, f = true;
  if (typeof r != "function") throw new TypeError(_3);
  return Uf(l) && (d = "leading" in l ? !!l.leading : d, f = "trailing" in l ? !!l.trailing : f), m3(r, i, { leading: d, maxWait: i, trailing: f });
}
const x3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, w3 = ot({ name: "BrandGithub", render: function(i, l) {
  return wt(), Xt("svg", x3, l[0] || (l[0] = [Pt("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), C3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, S3 = ot({ name: "BuildingCommunity", render: function(i, l) {
  return wt(), Xt("svg", C3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 9l5 5v7H8v-4m0 4H3v-7l5-5m1 1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v17h-8"></path><path d="M13 7v.01"></path><path d="M17 7v.01"></path><path d="M17 11v.01"></path><path d="M17 15v.01"></path></g>', 1)]));
} }), k3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, P3 = ot({ name: "Calendar", render: function(i, l) {
  return wt(), Xt("svg", k3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), T3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, I3 = ot({ name: "CurrentLocation", render: function(i, l) {
  return wt(), Xt("svg", T3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><circle cx="12" cy="12" r="8"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M20 12h2"></path><path d="M2 12h2"></path></g>', 1)]));
} }), M3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, E3 = ot({ name: "DeviceFloppy", render: function(i, l) {
  return wt(), Xt("svg", M3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), Pt("circle", { cx: "12", cy: "14", r: "2" }), Pt("path", { d: "M14 4v4H8V4" })], -1)]));
} }), R3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, A3 = ot({ name: "Edit", render: function(i, l) {
  return wt(), Xt("svg", R3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), Pt("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), Pt("path", { d: "M16 5l3 3" })], -1)]));
} }), D3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, pb = ot({ name: "FileText", render: function(i, l) {
  return wt(), Xt("svg", D3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), z3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, F3 = ot({ name: "Folder", render: function(i, l) {
  return wt(), Xt("svg", z3, l[0] || (l[0] = [Pt("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), L3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, B3 = ot({ name: "HandFinger", render: function(i, l) {
  return wt(), Xt("svg", L3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), O3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, $3 = ot({ name: "Line", render: function(i, l) {
  return wt(), Xt("svg", O3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("circle", { cx: "6", cy: "18", r: "2" }), Pt("circle", { cx: "18", cy: "6", r: "2" }), Pt("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), j3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, sy = ot({ name: "Link", render: function(i, l) {
  return wt(), Xt("svg", j3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), Pt("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), N3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, V3 = ot({ name: "Minus", render: function(i, l) {
  return wt(), Xt("svg", N3, l[0] || (l[0] = [Pt("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), U3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, q3 = ot({ name: "PlayerRecord", render: function(i, l) {
  return wt(), Xt("svg", U3, l[0] || (l[0] = [Pt("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), G3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ud = ot({ name: "Plus", render: function(i, l) {
  return wt(), Xt("svg", G3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("path", { d: "M12 5v14" }), Pt("path", { d: "M5 12h14" })], -1)]));
} }), W3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Hg = ot({ name: "Route", render: function(i, l) {
  return wt(), Xt("svg", W3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("circle", { cx: "6", cy: "19", r: "2" }), Pt("circle", { cx: "18", cy: "5", r: "2" }), Pt("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), Z3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, mb = ot({ name: "Shape", render: function(i, l) {
  return wt(), Xt("svg", Z3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), H3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, X3 = ot({ name: "Square", render: function(i, l) {
  return wt(), Xt("svg", H3, l[0] || (l[0] = [Pt("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Y3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, sp = ot({ name: "Trash", render: function(i, l) {
  return wt(), Xt("svg", Y3, l[0] || (l[0] = [zl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), K3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, gb = ot({ name: "Upload", render: function(i, l) {
  return wt(), Xt("svg", K3, l[0] || (l[0] = [Pt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Pt("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), Pt("path", { d: "M7 9l5-5l5 5" }), Pt("path", { d: "M12 4v12" })], -1)]));
} });
function vb(r) {
  return typeof r == "string" ? document.querySelector(r) : typeof r == "function" ? r() : r;
}
function J3(r) {
  if (typeof r == "number") return { "": r.toString() };
  const i = {};
  return r.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [d, f] = l.split(":");
    f === void 0 ? i[""] = d : i[d] = f;
  }), i;
}
function Uu(r, i) {
  var l;
  if (r == null) return;
  const d = J3(r);
  if (i === void 0) return d[""];
  if (typeof i == "string") return (l = d[i]) !== null && l !== void 0 ? l : d[""];
  if (Array.isArray(i)) {
    for (let f = i.length - 1; f >= 0; --f) {
      const g = i[f];
      if (g in d) return d[g];
    }
    return d[""];
  } else {
    let f, g = -1;
    return Object.keys(d).forEach((m) => {
      const s = Number(m);
      !Number.isNaN(s) && i >= s && s >= g && (g = s, f = d[m]);
    }), f;
  }
}
const Q3 = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function eS(r) {
  return `(min-width: ${r}px)`;
}
const Sd = {};
function tS(r = Q3) {
  if (!f2) return Me(() => []);
  if (typeof window.matchMedia != "function") return Me(() => []);
  const i = Re({}), l = Object.keys(r), d = (f, g) => {
    f.matches ? i.value[g] = true : i.value[g] = false;
  };
  return l.forEach((f) => {
    const g = r[f];
    let m, s;
    Sd[g] === void 0 ? (m = window.matchMedia(eS(g)), m.addEventListener ? m.addEventListener("change", (C) => {
      s.forEach((P) => {
        P(C, f);
      });
    }) : m.addListener && m.addListener((C) => {
      s.forEach((P) => {
        P(C, f);
      });
    }), s = /* @__PURE__ */ new Set(), Sd[g] = { mql: m, cbs: s }) : (m = Sd[g].mql, s = Sd[g].cbs), s.add(d), m.matches && s.forEach((C) => {
      C(m, f);
    });
  }), Sn(() => {
    l.forEach((f) => {
      const { cbs: g } = Sd[r[f]];
      g.has(d) && g.delete(d);
    });
  }), Me(() => {
    const { value: f } = i;
    return l.filter((g) => f[g]);
  });
}
function rS(r, i, l) {
  var d;
  const f = pr(r, null);
  if (f === null) return;
  const g = (d = Qd()) === null || d === void 0 ? void 0 : d.proxy;
  Ht(l, m), m(l.value), Sn(() => {
    m(void 0, l.value);
  });
  function m(P, M) {
    if (!f) return;
    const F = f[i];
    M !== void 0 && s(F, M), P !== void 0 && C(F, P);
  }
  function s(P, M) {
    P[M] || (P[M] = []), P[M].splice(P[M].findIndex((F) => F === g), 1);
  }
  function C(P, M) {
    P[M] || (P[M] = []), ~P[M].findIndex((F) => F === g) || P[M].push(g);
  }
}
function iS(r, i, l) {
  const d = pr(r, null);
  d !== null && (i in d || (d[i] = []), d[i].push(l.value), Ht(l, (f, g) => {
    const m = d[i], s = m.findIndex((C) => C === g);
    ~s && m.splice(s, 1), m.push(f);
  }), Sn(() => {
    const f = d[i], g = f.findIndex((m) => m === l.value);
    ~g && f.splice(g, 1);
  }));
}
function nS(r, i, l) {
  const d = pr(r, null);
  d !== null && (i in d || (d[i] = []), ji(() => {
    const f = l();
    f && d[i].push(f);
  }), Sn(() => {
    const f = d[i], g = l(), m = f.findIndex((s) => s === g);
    ~m && f.splice(m, 1);
  }));
}
function ly(r) {
  return r & -r;
}
class yb {
  constructor(i, l) {
    this.l = i, this.min = l;
    const d = new Array(i + 1);
    for (let f = 0; f < i + 1; ++f) d[f] = 0;
    this.ft = d;
  }
  add(i, l) {
    if (l === 0) return;
    const { l: d, ft: f } = this;
    for (i += 1; i <= d; ) f[i] += l, i += ly(i);
  }
  get(i) {
    return this.sum(i + 1) - this.sum(i);
  }
  sum(i) {
    if (i === void 0 && (i = this.l), i <= 0) return 0;
    const { ft: l, min: d, l: f } = this;
    if (i > f) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let g = i * d;
    for (; i > 0; ) g += l[i], i -= ly(i);
    return g;
  }
  getBound(i) {
    let l = 0, d = this.l;
    for (; d > l; ) {
      const f = Math.floor((l + d) / 2), g = this.sum(f);
      if (g > i) {
        d = f;
        continue;
      } else if (g < i) {
        if (l === f) return this.sum(l + 1) <= i ? l + 1 : f;
        l = f;
      } else return f;
    }
    return l;
  }
}
let bf;
function oS() {
  return typeof document > "u" ? false : (bf === void 0 && ("matchMedia" in window ? bf = window.matchMedia("(pointer:coarse)").matches : bf = false), bf);
}
let Dm;
function uy() {
  return typeof document > "u" ? 1 : (Dm === void 0 && (Dm = "chrome" in window ? window.devicePixelRatio : 1), Dm);
}
const _b = "VVirtualListXScroll";
function aS({ columnsRef: r, renderColRef: i, renderItemWithColsRef: l }) {
  const d = Re(0), f = Re(0), g = Me(() => {
    const P = r.value;
    if (P.length === 0) return null;
    const M = new yb(P.length, 0);
    return P.forEach((F, D) => {
      M.add(D, F.width);
    }), M;
  }), m = yi(() => {
    const P = g.value;
    return P !== null ? Math.max(P.getBound(f.value) - 1, 0) : 0;
  }), s = (P) => {
    const M = g.value;
    return M !== null ? M.sum(P) : 0;
  }, C = yi(() => {
    const P = g.value;
    return P !== null ? Math.min(P.getBound(f.value + d.value) + 1, r.value.length - 1) : 0;
  });
  return Zr(_b, { startIndexRef: m, endIndexRef: C, columnsRef: r, renderColRef: i, renderItemWithColsRef: l, getLeft: s }), { listWidthRef: d, scrollLeftRef: f };
}
const cy = ot({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: r, endIndexRef: i, columnsRef: l, getLeft: d, renderColRef: f, renderItemWithColsRef: g } = pr(_b);
  return { startIndex: r, endIndex: i, columns: l, renderCol: f, renderItemWithCols: g, getLeft: d };
}, render() {
  const { startIndex: r, endIndex: i, columns: l, renderCol: d, renderItemWithCols: f, getLeft: g, item: m } = this;
  if (f != null) return f({ itemIndex: this.index, startColIndex: r, endColIndex: i, allColumns: l, item: m, getLeft: g });
  if (d != null) {
    const s = [];
    for (let C = r; C <= i; ++C) {
      const P = l[C];
      s.push(d({ column: P, left: g(C), item: m }));
    }
    return s;
  }
  return null;
} }), sS = zd(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [zd("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [zd("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), lS = ot({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(r) {
  const i = I_();
  sS.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: M_, ssr: i }), ji(() => {
    const { defaultScrollIndex: Ve, defaultScrollKey: Qe } = r;
    Ve != null ? Y({ index: Ve }) : Qe != null && Y({ key: Qe });
  });
  let l = false, d = false;
  Qw(() => {
    if (l = false, !d) {
      d = true;
      return;
    }
    Y({ top: A.value, left: m.value });
  }), S_(() => {
    l = true, d || (d = true);
  });
  const f = yi(() => {
    if (r.renderCol == null && r.renderItemWithCols == null || r.columns.length === 0) return;
    let Ve = 0;
    return r.columns.forEach((Qe) => {
      Ve += Qe.width;
    }), Ve;
  }), g = Me(() => {
    const Ve = /* @__PURE__ */ new Map(), { keyField: Qe } = r;
    return r.items.forEach((ut, gt) => {
      Ve.set(ut[Qe], gt);
    }), Ve;
  }), { scrollLeftRef: m, listWidthRef: s } = aS({ columnsRef: Bt(r, "columns"), renderColRef: Bt(r, "renderCol"), renderItemWithColsRef: Bt(r, "renderItemWithCols") }), C = Re(null), P = Re(void 0), M = /* @__PURE__ */ new Map(), F = Me(() => {
    const { items: Ve, itemSize: Qe, keyField: ut } = r, gt = new yb(Ve.length, Qe);
    return Ve.forEach((yt, lt) => {
      const et = yt[ut], dt = M.get(et);
      dt !== void 0 && gt.add(lt, dt);
    }), gt;
  }), D = Re(0), A = Re(0), O = yi(() => Math.max(F.value.getBound(A.value - en(r.paddingTop)) - 1, 0)), V = Me(() => {
    const { value: Ve } = P;
    if (Ve === void 0) return [];
    const { items: Qe, itemSize: ut } = r, gt = O.value, yt = Math.min(gt + Math.ceil(Ve / ut + 1), Qe.length - 1), lt = [];
    for (let et = gt; et <= yt; ++et) lt.push(Qe[et]);
    return lt;
  }), Y = (Ve, Qe) => {
    if (typeof Ve == "number") {
      te(Ve, Qe, "auto");
      return;
    }
    const { left: ut, top: gt, index: yt, key: lt, position: et, behavior: dt, debounce: Ft = true } = Ve;
    if (ut !== void 0 || gt !== void 0) te(ut, gt, dt);
    else if (yt !== void 0) ie(yt, dt, Ft);
    else if (lt !== void 0) {
      const ft = g.value.get(lt);
      ft !== void 0 && ie(ft, dt, Ft);
    } else et === "bottom" ? te(0, Number.MAX_SAFE_INTEGER, dt) : et === "top" && te(0, 0, dt);
  };
  let W, ee = null;
  function ie(Ve, Qe, ut) {
    const { value: gt } = F, yt = gt.sum(Ve) + en(r.paddingTop);
    if (!ut) C.value.scrollTo({ left: 0, top: yt, behavior: Qe });
    else {
      W = Ve, ee !== null && window.clearTimeout(ee), ee = window.setTimeout(() => {
        W = void 0, ee = null;
      }, 16);
      const { scrollTop: lt, offsetHeight: et } = C.value;
      if (yt > lt) {
        const dt = gt.get(Ve);
        yt + dt <= lt + et || C.value.scrollTo({ left: 0, top: yt + dt - et, behavior: Qe });
      } else C.value.scrollTo({ left: 0, top: yt, behavior: Qe });
    }
  }
  function te(Ve, Qe, ut) {
    C.value.scrollTo({ left: Ve, top: Qe, behavior: ut });
  }
  function re(Ve, Qe) {
    var ut, gt, yt;
    if (l || r.ignoreItemResize || qe(Qe.target)) return;
    const { value: lt } = F, et = g.value.get(Ve), dt = lt.get(et), Ft = (yt = (gt = (ut = Qe.borderBoxSize) === null || ut === void 0 ? void 0 : ut[0]) === null || gt === void 0 ? void 0 : gt.blockSize) !== null && yt !== void 0 ? yt : Qe.contentRect.height;
    if (Ft === dt) return;
    Ft - r.itemSize === 0 ? M.delete(Ve) : M.set(Ve, Ft - r.itemSize);
    const _t = Ft - dt;
    if (_t === 0) return;
    lt.add(et, _t);
    const $t = C.value;
    if ($t != null) {
      if (W === void 0) {
        const Qt = lt.sum(et);
        $t.scrollTop > Qt && $t.scrollBy(0, _t);
      } else if (et < W) $t.scrollBy(0, _t);
      else if (et === W) {
        const Qt = lt.sum(et);
        Ft + Qt > $t.scrollTop + $t.offsetHeight && $t.scrollBy(0, _t);
      }
      _e();
    }
    D.value++;
  }
  const X = !oS();
  let Se = false;
  function pe(Ve) {
    var Qe;
    (Qe = r.onScroll) === null || Qe === void 0 || Qe.call(r, Ve), (!X || !Se) && _e();
  }
  function oe(Ve) {
    var Qe;
    if ((Qe = r.onWheel) === null || Qe === void 0 || Qe.call(r, Ve), X) {
      const ut = C.value;
      if (ut != null) {
        if (Ve.deltaX === 0 && (ut.scrollTop === 0 && Ve.deltaY <= 0 || ut.scrollTop + ut.offsetHeight >= ut.scrollHeight && Ve.deltaY >= 0)) return;
        Ve.preventDefault(), ut.scrollTop += Ve.deltaY / uy(), ut.scrollLeft += Ve.deltaX / uy(), _e(), Se = true, tp(() => {
          Se = false;
        });
      }
    }
  }
  function fe(Ve) {
    if (l || qe(Ve.target)) return;
    if (r.renderCol == null && r.renderItemWithCols == null) {
      if (Ve.contentRect.height === P.value) return;
    } else if (Ve.contentRect.height === P.value && Ve.contentRect.width === s.value) return;
    P.value = Ve.contentRect.height, s.value = Ve.contentRect.width;
    const { onResize: Qe } = r;
    Qe !== void 0 && Qe(Ve);
  }
  function _e() {
    const { value: Ve } = C;
    Ve != null && (A.value = Ve.scrollTop, m.value = Ve.scrollLeft);
  }
  function qe(Ve) {
    let Qe = Ve;
    for (; Qe !== null; ) {
      if (Qe.style.display === "none") return true;
      Qe = Qe.parentElement;
    }
    return false;
  }
  return { listHeight: P, listStyle: { overflow: "auto" }, keyToIndex: g, itemsStyle: Me(() => {
    const { itemResizable: Ve } = r, Qe = Nn(F.value.sum());
    return D.value, [r.itemsStyle, { boxSizing: "content-box", width: Nn(f.value), height: Ve ? "" : Qe, minHeight: Ve ? Qe : "", paddingTop: Nn(r.paddingTop), paddingBottom: Nn(r.paddingBottom) }];
  }), visibleItemsStyle: Me(() => (D.value, { transform: `translateY(${Nn(F.value.sum(O.value))})` })), viewportItems: V, listElRef: C, itemsElRef: Re(null), scrollTo: Y, handleListResize: fe, handleListScroll: pe, handleListWheel: oe, handleItemResize: re };
}, render() {
  const { itemResizable: r, keyField: i, keyToIndex: l, visibleItemsTag: d } = this;
  return B(Pl, { onResize: this.handleListResize }, { default: () => {
    var f, g;
    return B("div", Cs(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? B("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [B(d, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: m, renderItemWithCols: s } = this;
      return this.viewportItems.map((C) => {
        const P = C[i], M = l.get(P), F = m != null ? B(cy, { index: M, item: C }) : void 0, D = s != null ? B(cy, { index: M, item: C }) : void 0, A = this.$slots.default({ item: C, renderedCols: F, renderedItemWithCols: D, index: M })[0];
        return r ? B(Pl, { key: P, onResize: (O) => this.handleItemResize(P, O) }, { default: () => A }) : (A.key = P, A);
      });
    } })]) : (g = (f = this.$slots).empty) === null || g === void 0 ? void 0 : g.call(f)]);
  } });
} }), uS = zd(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [zd("&::-webkit-scrollbar", { width: 0, height: 0 })]), cS = ot({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const r = Re(null);
  function i(f) {
    !(f.currentTarget.offsetWidth < f.currentTarget.scrollWidth) || f.deltaY === 0 || (f.currentTarget.scrollLeft += f.deltaY + f.deltaX, f.preventDefault());
  }
  const l = I_();
  return uS.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: M_, ssr: l }), Object.assign({ selfRef: r, handleWheel: i }, { scrollTo(...f) {
    var g;
    (g = r.value) === null || g === void 0 || g.scrollTo(...f);
  } });
}, render() {
  return B("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function bb(r, i) {
  i && (ji(() => {
    const { value: l } = r;
    l && Em.registerHandler(l, i);
  }), Ht(r, (l, d) => {
    d && Em.unregisterHandler(d);
  }, { deep: false }), Sn(() => {
    const { value: l } = r;
    l && Em.unregisterHandler(l);
  }));
}
function xb(r, i) {
  if (!r) return;
  const l = document.createElement("a");
  l.href = r, i !== void 0 && (l.download = i), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function yg(r) {
  switch (typeof r) {
    case "string":
      return r || void 0;
    case "number":
      return String(r);
    default:
      return;
  }
}
const dS = { tiny: "mini", small: "tiny", medium: "small", large: "medium", huge: "large" };
function hS(r) {
  const i = dS[r];
  if (i === void 0) throw new Error(`${r} has no smaller size.`);
  return i;
}
function lp(r, i = "default", l = []) {
  const f = r.$slots[i];
  return f === void 0 ? l : f();
}
function fS(r) {
  var i;
  const l = (i = r.dirs) === null || i === void 0 ? void 0 : i.find(({ dir: d }) => d === Qa);
  return !!(l && l.value === false);
}
function zm(r) {
  const i = r.filter((l) => l !== void 0);
  if (i.length !== 0) return i.length === 1 ? i[0] : (l) => {
    r.forEach((d) => {
      d && d(l);
    });
  };
}
const pS = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (r) => `Please load all ${r}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (r) => `Total ${r} items`, selected: (r) => `${r} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" }, Heatmap: { less: "less", more: "more", monthFormat: "MMM", weekdayFormat: "eee" } };
function Fm(r) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : r.defaultWidth;
    return r.formats[l] || r.formats[r.defaultWidth];
  };
}
function kd(r) {
  return (i, l) => {
    const d = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let f;
    if (d === "formatting" && r.formattingValues) {
      const m = r.defaultFormattingWidth || r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : m;
      f = r.formattingValues[s] || r.formattingValues[m];
    } else {
      const m = r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : r.defaultWidth;
      f = r.values[s] || r.values[m];
    }
    const g = r.argumentCallback ? r.argumentCallback(i) : i;
    return f[g];
  };
}
function Pd(r) {
  return (i, l = {}) => {
    const d = l.width, f = d && r.matchPatterns[d] || r.matchPatterns[r.defaultMatchWidth], g = i.match(f);
    if (!g) return null;
    const m = g[0], s = d && r.parsePatterns[d] || r.parsePatterns[r.defaultParseWidth], C = Array.isArray(s) ? gS(s, (F) => F.test(m)) : mS(s, (F) => F.test(m));
    let P;
    P = r.valueCallback ? r.valueCallback(C) : C, P = l.valueCallback ? l.valueCallback(P) : P;
    const M = i.slice(m.length);
    return { value: P, rest: M };
  };
}
function mS(r, i) {
  for (const l in r) if (Object.prototype.hasOwnProperty.call(r, l) && i(r[l])) return l;
}
function gS(r, i) {
  for (let l = 0; l < r.length; l++) if (i(r[l])) return l;
}
function vS(r) {
  return (i, l = {}) => {
    const d = i.match(r.matchPattern);
    if (!d) return null;
    const f = d[0], g = i.match(r.parsePattern);
    if (!g) return null;
    let m = r.valueCallback ? r.valueCallback(g[0]) : g[0];
    m = l.valueCallback ? l.valueCallback(m) : m;
    const s = i.slice(f.length);
    return { value: m, rest: s };
  };
}
const yS = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, _S = (r, i, l) => {
  let d;
  const f = yS[r];
  return typeof f == "string" ? d = f : i === 1 ? d = f.one : d = f.other.replace("{{count}}", i.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + d : d + " ago" : d;
}, bS = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, xS = (r, i, l, d) => bS[r], wS = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, CS = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, SS = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, kS = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, PS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, TS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, IS = (r, i) => {
  const l = Number(r), d = l % 100;
  if (d > 20 || d < 10) switch (d % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, MS = { ordinalNumber: IS, era: kd({ values: wS, defaultWidth: "wide" }), quarter: kd({ values: CS, defaultWidth: "wide", argumentCallback: (r) => r - 1 }), month: kd({ values: SS, defaultWidth: "wide" }), day: kd({ values: kS, defaultWidth: "wide" }), dayPeriod: kd({ values: PS, defaultWidth: "wide", formattingValues: TS, defaultFormattingWidth: "wide" }) }, ES = /^(\d+)(th|st|nd|rd)?/i, RS = /\d+/i, AS = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, DS = { any: [/^b/i, /^(a|c)/i] }, zS = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, FS = { any: [/1/i, /2/i, /3/i, /4/i] }, LS = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, BS = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, OS = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, $S = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, jS = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, NS = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, VS = { ordinalNumber: vS({ matchPattern: ES, parsePattern: RS, valueCallback: (r) => parseInt(r, 10) }), era: Pd({ matchPatterns: AS, defaultMatchWidth: "wide", parsePatterns: DS, defaultParseWidth: "any" }), quarter: Pd({ matchPatterns: zS, defaultMatchWidth: "wide", parsePatterns: FS, defaultParseWidth: "any", valueCallback: (r) => r + 1 }), month: Pd({ matchPatterns: LS, defaultMatchWidth: "wide", parsePatterns: BS, defaultParseWidth: "any" }), day: Pd({ matchPatterns: OS, defaultMatchWidth: "wide", parsePatterns: $S, defaultParseWidth: "any" }), dayPeriod: Pd({ matchPatterns: jS, defaultMatchWidth: "any", parsePatterns: NS, defaultParseWidth: "any" }) }, US = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, qS = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, GS = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, WS = { date: Fm({ formats: US, defaultWidth: "full" }), time: Fm({ formats: qS, defaultWidth: "full" }), dateTime: Fm({ formats: GS, defaultWidth: "full" }) }, ZS = { code: "en-US", formatDistance: _S, formatLong: WS, formatRelative: xS, localize: MS, match: VS, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, HS = { name: "en-US", locale: ZS };
function ts(r) {
  const { mergedLocaleRef: i, mergedDateLocaleRef: l } = pr(E_, null) || {}, d = Me(() => {
    var g, m;
    return (m = (g = i == null ? void 0 : i.value) === null || g === void 0 ? void 0 : g[r]) !== null && m !== void 0 ? m : pS[r];
  });
  return { dateLocaleRef: Me(() => {
    var g;
    return (g = l == null ? void 0 : l.value) !== null && g !== void 0 ? g : HS;
  }), localeRef: d };
}
const XS = ce("affix", [Ue("affixed", { position: "fixed" }, [Ue("absolute-positioned", { position: "absolute" })])]);
function YS(r) {
  return r instanceof HTMLElement ? r.scrollTop : window.scrollY;
}
function KS(r) {
  return r instanceof HTMLElement ? r.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const Xg = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, JS = jd(Xg), QS = ot({ name: "Affix", props: Xg, setup(r) {
  const { mergedClsPrefixRef: i } = Mr(r);
  cc("-affix", XS, i);
  let l = null;
  const d = Re(false), f = Re(false), g = Re(null), m = Re(null), s = Me(() => f.value || d.value), C = Me(() => {
    var Y, W;
    return (W = (Y = r.triggerTop) !== null && Y !== void 0 ? Y : r.offsetTop) !== null && W !== void 0 ? W : r.top;
  }), P = Me(() => {
    var Y, W;
    return (W = (Y = r.top) !== null && Y !== void 0 ? Y : r.triggerTop) !== null && W !== void 0 ? W : r.offsetTop;
  }), M = Me(() => {
    var Y, W;
    return (W = (Y = r.bottom) !== null && Y !== void 0 ? Y : r.triggerBottom) !== null && W !== void 0 ? W : r.offsetBottom;
  }), F = Me(() => {
    var Y, W;
    return (W = (Y = r.triggerBottom) !== null && Y !== void 0 ? Y : r.offsetBottom) !== null && W !== void 0 ? W : r.bottom;
  }), D = Re(null), A = () => {
    const { target: Y, listenTo: W } = r;
    Y ? l = Y() : W ? l = vb(W) : l = document, l && (l.addEventListener("scroll", O), O());
  };
  function O() {
    tp(V);
  }
  function V() {
    const { value: Y } = D;
    if (!l || !Y) return;
    const W = YS(l);
    if (s.value) {
      m.value !== null && W < m.value && (d.value = false, m.value = null), g.value !== null && W > g.value && (f.value = false, g.value = null);
      return;
    }
    const ee = KS(l), ie = Y.getBoundingClientRect(), te = ie.top - ee.top, re = ee.bottom - ie.bottom, X = C.value, Se = F.value;
    X !== void 0 && te <= X ? (d.value = true, m.value = W - (X - te)) : (d.value = false, m.value = null), Se !== void 0 && re <= Se ? (f.value = true, g.value = W + Se - re) : (f.value = false, g.value = null);
  }
  return ji(() => {
    A();
  }), Sn(() => {
    l && l.removeEventListener("scroll", O);
  }), { selfRef: D, affixed: s, mergedClsPrefix: i, mergedstyle: Me(() => {
    const Y = {};
    return d.value && C.value !== void 0 && P.value !== void 0 && (Y.top = `${P.value}px`), f.value && F.value !== void 0 && M.value !== void 0 && (Y.bottom = `${M.value}px`), Y;
  }) };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { ref: "selfRef", class: [`${r}-affix`, { [`${r}-affix--affixed`]: this.affixed, [`${r}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), up = ot({ name: "Add", render() {
  return B("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), ek = va("attach", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), tk = va("cancel", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), rk = ot({ name: "Checkmark", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, B("g", { fill: "none" }, B("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), ik = ot({ name: "ChevronDown", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), nk = ot({ name: "ChevronLeft", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), ok = va("clear", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), wb = va("download", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), ak = ot({ name: "Empty", render() {
  return B("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), B("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), Cb = ot({ name: "Eye", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), B("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), sk = ot({ name: "EyeOff", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), B("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), B("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), B("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), B("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), lk = ot({ name: "Remove", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), uk = ot({ name: "ResizeSmall", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, B("g", { fill: "none" }, B("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), ck = va("retry", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), B("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), dk = va("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), B("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), hk = va("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), B("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), fk = va("trash", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), pk = va("zoomIn", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), B("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), mk = va("zoomOut", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), B("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), gk = ce("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [Ge(">", [Fe("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [Ge("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), Ge("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Fe("placeholder", `
 display: flex;
 `), Fe("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Nd({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), _g = ot({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(r) {
  return cc("-base-clear", gk, Bt(r, "clsPrefix")), { handleMouseDown(i) {
    i.preventDefault();
  } };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-base-clear` }, B(rp, null, { default: () => {
    var i, l;
    return this.show ? B("div", { key: "dismiss", class: `${r}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, Kn(this.$slots.icon, () => [B(Wr, { clsPrefix: r }, { default: () => B(ok, null) })])) : B("div", { key: "icon", class: `${r}-base-clear__placeholder` }, (l = (i = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(i));
  } }));
} }), vk = ot({ props: { onFocus: Function, onBlur: Function }, setup(r) {
  return () => B("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: r.onFocus, onBlur: r.onBlur });
} }), yk = ce("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Fe("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [Ge("+", [Fe("description", `
 margin-top: 8px;
 `)])]), Fe("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Fe("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), _k = Object.assign(Object.assign({}, rr.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), qd = ot({ name: "Empty", props: _k, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedComponentPropsRef: d } = Mr(r), f = rr("Empty", "-empty", yk, p2, r, i), { localeRef: g } = ts("Empty"), m = Me(() => {
    var M, F, D;
    return (M = r.description) !== null && M !== void 0 ? M : (D = (F = d == null ? void 0 : d.value) === null || F === void 0 ? void 0 : F.Empty) === null || D === void 0 ? void 0 : D.description;
  }), s = Me(() => {
    var M, F;
    return ((F = (M = d == null ? void 0 : d.value) === null || M === void 0 ? void 0 : M.Empty) === null || F === void 0 ? void 0 : F.renderIcon) || (() => B(ak, null));
  }), C = Me(() => {
    const { size: M } = r, { common: { cubicBezierEaseInOut: F }, self: { [Jt("iconSize", M)]: D, [Jt("fontSize", M)]: A, textColor: O, iconColor: V, extraTextColor: Y } } = f.value;
    return { "--n-icon-size": D, "--n-font-size": A, "--n-bezier": F, "--n-text-color": O, "--n-icon-color": V, "--n-extra-text-color": Y };
  }), P = l ? bi("empty", Me(() => {
    let M = "";
    const { size: F } = r;
    return M += F[0], M;
  }), C, r) : void 0;
  return { mergedClsPrefix: i, mergedRenderIcon: s, localizedDescription: Me(() => m.value || g.value.description), cssVars: l ? void 0 : C, themeClass: P == null ? void 0 : P.themeClass, onRender: P == null ? void 0 : P.onRender };
}, render() {
  const { $slots: r, mergedClsPrefix: i, onRender: l } = this;
  return l == null ? void 0 : l(), B("div", { class: [`${i}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? B("div", { class: `${i}-empty__icon` }, r.icon ? r.icon() : B(Wr, { clsPrefix: i }, { default: this.mergedRenderIcon })) : null, this.showDescription ? B("div", { class: `${i}-empty__description` }, r.default ? r.default() : this.localizedDescription) : null, r.extra ? B("div", { class: `${i}-empty__extra` }, r.extra()) : null);
} }), dy = ot({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: r, renderOptionRef: i, labelFieldRef: l, nodePropsRef: d } = pr(Ng);
  return { labelField: l, nodeProps: d, renderLabel: r, renderOption: i };
}, render() {
  const { clsPrefix: r, renderLabel: i, renderOption: l, nodeProps: d, tmNode: { rawNode: f } } = this, g = d == null ? void 0 : d(f), m = i ? i(f, false) : Cl(f[this.labelField], f, false), s = B("div", Object.assign({}, g, { class: [`${r}-base-select-group-header`, g == null ? void 0 : g.class] }), m);
  return f.render ? f.render({ node: s, option: f }) : l ? l({ node: s, option: f, selected: false }) : s;
} });
function bk(r, i) {
  return B(Io, { name: "fade-in-scale-up-transition" }, { default: () => r ? B(Wr, { clsPrefix: i, class: `${i}-base-select-option__check` }, { default: () => B(rk) }) : null });
}
const hy = ot({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(r) {
  const { valueRef: i, pendingTmNodeRef: l, multipleRef: d, valueSetRef: f, renderLabelRef: g, renderOptionRef: m, labelFieldRef: s, valueFieldRef: C, showCheckmarkRef: P, nodePropsRef: M, handleOptionClick: F, handleOptionMouseEnter: D } = pr(Ng), A = yi(() => {
    const { value: W } = l;
    return W ? r.tmNode.key === W.key : false;
  });
  function O(W) {
    const { tmNode: ee } = r;
    ee.disabled || F(W, ee);
  }
  function V(W) {
    const { tmNode: ee } = r;
    ee.disabled || D(W, ee);
  }
  function Y(W) {
    const { tmNode: ee } = r, { value: ie } = A;
    ee.disabled || ie || D(W, ee);
  }
  return { multiple: d, isGrouped: yi(() => {
    const { tmNode: W } = r, { parent: ee } = W;
    return ee && ee.rawNode.type === "group";
  }), showCheckmark: P, nodeProps: M, isPending: A, isSelected: yi(() => {
    const { value: W } = i, { value: ee } = d;
    if (W === null) return false;
    const ie = r.tmNode.rawNode[C.value];
    if (ee) {
      const { value: te } = f;
      return te.has(ie);
    } else return W === ie;
  }), labelField: s, renderLabel: g, renderOption: m, handleMouseMove: Y, handleMouseEnter: V, handleClick: O };
}, render() {
  const { clsPrefix: r, tmNode: { rawNode: i }, isSelected: l, isPending: d, isGrouped: f, showCheckmark: g, nodeProps: m, renderOption: s, renderLabel: C, handleClick: P, handleMouseEnter: M, handleMouseMove: F } = this, D = bk(l, r), A = C ? [C(i, l), g && D] : [Cl(i[this.labelField], i, l), g && D], O = m == null ? void 0 : m(i), V = B("div", Object.assign({}, O, { class: [`${r}-base-select-option`, i.class, O == null ? void 0 : O.class, { [`${r}-base-select-option--disabled`]: i.disabled, [`${r}-base-select-option--selected`]: l, [`${r}-base-select-option--grouped`]: f, [`${r}-base-select-option--pending`]: d, [`${r}-base-select-option--show-checkmark`]: g }], style: [(O == null ? void 0 : O.style) || "", i.style || ""], onClick: zm([P, O == null ? void 0 : O.onClick]), onMouseenter: zm([M, O == null ? void 0 : O.onMouseenter]), onMousemove: zm([F, O == null ? void 0 : O.onMousemove]) }), B("div", { class: `${r}-base-select-option__content` }, A));
  return i.render ? i.render({ node: V, option: i, selected: l }) : s ? s({ node: V, option: i, selected: l }) : V;
} }), xk = ce("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [ce("scrollbar", `
 max-height: var(--n-height);
 `), ce("virtual-list", `
 max-height: var(--n-height);
 `), ce("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Fe("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), ce("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), ce("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Fe("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Fe("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Fe("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Fe("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), ce("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), ce("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ue("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), Ge("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), Ge("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ue("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ue("selected", `
 color: var(--n-option-text-color-active);
 `, [Ge("&::before", `
 background-color: var(--n-option-color-active);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 `, [pi("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ue("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Fe("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [ip({ enterScale: "0.5" })])])]), wk = ot({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, rr.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Mr(r), d = Un("InternalSelectMenu", l, i), f = rr("InternalSelectMenu", "-internal-select-menu", xk, m2, r, Bt(r, "clsPrefix")), g = Re(null), m = Re(null), s = Re(null), C = Me(() => r.treeMate.getFlattenedNodes()), P = Me(() => g2(C.value)), M = Re(null);
  function F() {
    const { treeMate: ft } = r;
    let _t = null;
    const { value: $t } = r;
    $t === null ? _t = ft.getFirstAvailableNode() : (r.multiple ? _t = ft.getNode(($t || [])[($t || []).length - 1]) : _t = ft.getNode($t), (!_t || _t.disabled) && (_t = ft.getFirstAvailableNode())), Qe(_t || null);
  }
  function D() {
    const { value: ft } = M;
    ft && !r.treeMate.getNode(ft.key) && (M.value = null);
  }
  let A;
  Ht(() => r.show, (ft) => {
    ft ? A = Ht(() => r.treeMate, () => {
      r.resetMenuOnOptionsChange ? (r.autoPending ? F() : D(), Vn(ut)) : D();
    }, { immediate: true }) : A == null ? void 0 : A();
  }, { immediate: true }), Sn(() => {
    A == null ? void 0 : A();
  });
  const O = Me(() => en(f.value.self[Jt("optionHeight", r.size)])), V = Me(() => Zo(f.value.self[Jt("padding", r.size)])), Y = Me(() => r.multiple && Array.isArray(r.value) ? new Set(r.value) : /* @__PURE__ */ new Set()), W = Me(() => {
    const ft = C.value;
    return ft && ft.length === 0;
  });
  function ee(ft) {
    const { onToggle: _t } = r;
    _t && _t(ft);
  }
  function ie(ft) {
    const { onScroll: _t } = r;
    _t && _t(ft);
  }
  function te(ft) {
    var _t;
    (_t = s.value) === null || _t === void 0 || _t.sync(), ie(ft);
  }
  function re() {
    var ft;
    (ft = s.value) === null || ft === void 0 || ft.sync();
  }
  function X() {
    const { value: ft } = M;
    return ft || null;
  }
  function Se(ft, _t) {
    _t.disabled || Qe(_t, false);
  }
  function pe(ft, _t) {
    _t.disabled || ee(_t);
  }
  function oe(ft) {
    var _t;
    Tl(ft, "action") || (_t = r.onKeyup) === null || _t === void 0 || _t.call(r, ft);
  }
  function fe(ft) {
    var _t;
    Tl(ft, "action") || (_t = r.onKeydown) === null || _t === void 0 || _t.call(r, ft);
  }
  function _e(ft) {
    var _t;
    (_t = r.onMousedown) === null || _t === void 0 || _t.call(r, ft), !r.focusable && ft.preventDefault();
  }
  function qe() {
    const { value: ft } = M;
    ft && Qe(ft.getNext({ loop: true }), true);
  }
  function Ve() {
    const { value: ft } = M;
    ft && Qe(ft.getPrev({ loop: true }), true);
  }
  function Qe(ft, _t = false) {
    M.value = ft, _t && ut();
  }
  function ut() {
    var ft, _t;
    const $t = M.value;
    if (!$t) return;
    const Qt = P.value($t.key);
    Qt !== null && (r.virtualScroll ? (ft = m.value) === null || ft === void 0 || ft.scrollTo({ index: Qt }) : (_t = s.value) === null || _t === void 0 || _t.scrollTo({ index: Qt, elSize: O.value }));
  }
  function gt(ft) {
    var _t, $t;
    !((_t = g.value) === null || _t === void 0) && _t.contains(ft.target) && (($t = r.onFocus) === null || $t === void 0 || $t.call(r, ft));
  }
  function yt(ft) {
    var _t, $t;
    !((_t = g.value) === null || _t === void 0) && _t.contains(ft.relatedTarget) || ($t = r.onBlur) === null || $t === void 0 || $t.call(r, ft);
  }
  Zr(Ng, { handleOptionMouseEnter: Se, handleOptionClick: pe, valueSetRef: Y, pendingTmNodeRef: M, nodePropsRef: Bt(r, "nodeProps"), showCheckmarkRef: Bt(r, "showCheckmark"), multipleRef: Bt(r, "multiple"), valueRef: Bt(r, "value"), renderLabelRef: Bt(r, "renderLabel"), renderOptionRef: Bt(r, "renderOption"), labelFieldRef: Bt(r, "labelField"), valueFieldRef: Bt(r, "valueField") }), Zr(v2, g), ji(() => {
    const { value: ft } = s;
    ft && ft.sync();
  });
  const lt = Me(() => {
    const { size: ft } = r, { common: { cubicBezierEaseInOut: _t }, self: { height: $t, borderRadius: Qt, color: Lt, groupHeaderTextColor: zt, actionDividerColor: It, optionTextColorPressed: At, optionTextColor: mr, optionTextColorDisabled: gr, optionTextColorActive: ir, optionOpacityDisabled: nr, optionCheckColor: Ut, actionTextColor: Ar, optionColorPending: wr, optionColorActive: Ct, loadingColor: Ee, loadingSize: nt, optionColorActivePending: Be, [Jt("optionFontSize", ft)]: Ye, [Jt("optionHeight", ft)]: ht, [Jt("optionPadding", ft)]: bt } } = f.value;
    return { "--n-height": $t, "--n-action-divider-color": It, "--n-action-text-color": Ar, "--n-bezier": _t, "--n-border-radius": Qt, "--n-color": Lt, "--n-option-font-size": Ye, "--n-group-header-text-color": zt, "--n-option-check-color": Ut, "--n-option-color-pending": wr, "--n-option-color-active": Ct, "--n-option-color-active-pending": Be, "--n-option-height": ht, "--n-option-opacity-disabled": nr, "--n-option-text-color": mr, "--n-option-text-color-active": ir, "--n-option-text-color-disabled": gr, "--n-option-text-color-pressed": At, "--n-option-padding": bt, "--n-option-padding-left": Zo(bt, "left"), "--n-option-padding-right": Zo(bt, "right"), "--n-loading-color": Ee, "--n-loading-size": nt };
  }), { inlineThemeDisabled: et } = r, dt = et ? bi("internal-select-menu", Me(() => r.size[0]), lt, r) : void 0, Ft = { selfRef: g, next: qe, prev: Ve, getPendingTmNode: X };
  return bb(g, r.onResize), Object.assign({ mergedTheme: f, mergedClsPrefix: i, rtlEnabled: d, virtualListRef: m, scrollbarRef: s, itemSize: O, padding: V, flattenedNodes: C, empty: W, virtualListContainer() {
    const { value: ft } = m;
    return ft == null ? void 0 : ft.listElRef;
  }, virtualListContent() {
    const { value: ft } = m;
    return ft == null ? void 0 : ft.itemsElRef;
  }, doScroll: ie, handleFocusin: gt, handleFocusout: yt, handleKeyUp: oe, handleKeyDown: fe, handleMouseDown: _e, handleVirtualListResize: re, handleVirtualListScroll: te, cssVars: et ? void 0 : lt, themeClass: dt == null ? void 0 : dt.themeClass, onRender: dt == null ? void 0 : dt.onRender }, Ft);
}, render() {
  const { $slots: r, virtualScroll: i, clsPrefix: l, mergedTheme: d, themeClass: f, onRender: g } = this;
  return g == null ? void 0 : g(), B("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, f, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, Ii(r.header, (m) => m && B("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, m)), this.loading ? B("div", { class: `${l}-base-select-menu__loading` }, B(np, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? B("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, Kn(r.empty, () => [B(qd, { theme: d.peers.Empty, themeOverrides: d.peerOverrides.Empty, size: this.size })])) : B(eh, { ref: "scrollbarRef", theme: d.peers.Scrollbar, themeOverrides: d.peerOverrides.Scrollbar, scrollable: this.scrollable, container: i ? this.virtualListContainer : void 0, content: i ? this.virtualListContent : void 0, onScroll: i ? void 0 : this.doScroll }, { default: () => i ? B(lS, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: m }) => m.isGroup ? B(dy, { key: m.key, clsPrefix: l, tmNode: m }) : m.ignored ? null : B(hy, { clsPrefix: l, key: m.key, tmNode: m }) }) : B("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((m) => m.isGroup ? B(dy, { key: m.key, clsPrefix: l, tmNode: m }) : B(hy, { clsPrefix: l, key: m.key, tmNode: m }))) }), Ii(r.action, (m) => m && [B("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, m), B(vk, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), Sb = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, Ck = ce("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ue("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Fe("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Fe("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Fe("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Fe("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ue("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Fe("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Fe("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ue("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ue("icon, avatar", [Ue("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ue("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ue("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [pi("disabled", [Ge("&:hover", "background-color: var(--n-color-hover-checkable);", [pi("checked", "color: var(--n-text-color-hover-checkable);")]), Ge("&:active", "background-color: var(--n-color-pressed-checkable);", [pi("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ue("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [pi("disabled", [Ge("&:hover", "background-color: var(--n-color-checked-hover);"), Ge("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), Sk = Object.assign(Object.assign(Object.assign({}, rr.props), Sb), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), kk = Rn("n-tag"), Mo = ot({ name: "Tag", props: Sk, slots: Object, setup(r) {
  const i = Re(null), { mergedBorderedRef: l, mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Mr(r), m = rr("Tag", "-tag", Ck, y2, r, d);
  Zr(kk, { roundRef: Bt(r, "round") });
  function s() {
    if (!r.disabled && r.checkable) {
      const { checked: A, onCheckedChange: O, onUpdateChecked: V, "onUpdate:checked": Y } = r;
      V && V(!A), Y && Y(!A), O && O(!A);
    }
  }
  function C(A) {
    if (r.triggerClickOnClose || A.stopPropagation(), !r.disabled) {
      const { onClose: O } = r;
      O && jt(O, A);
    }
  }
  const P = { setTextContent(A) {
    const { value: O } = i;
    O && (O.textContent = A);
  } }, M = Un("Tag", g, d), F = Me(() => {
    const { type: A, size: O, color: { color: V, textColor: Y } = {} } = r, { common: { cubicBezierEaseInOut: W }, self: { padding: ee, closeMargin: ie, borderRadius: te, opacityDisabled: re, textColorCheckable: X, textColorHoverCheckable: Se, textColorPressedCheckable: pe, textColorChecked: oe, colorCheckable: fe, colorHoverCheckable: _e, colorPressedCheckable: qe, colorChecked: Ve, colorCheckedHover: Qe, colorCheckedPressed: ut, closeBorderRadius: gt, fontWeightStrong: yt, [Jt("colorBordered", A)]: lt, [Jt("closeSize", O)]: et, [Jt("closeIconSize", O)]: dt, [Jt("fontSize", O)]: Ft, [Jt("height", O)]: ft, [Jt("color", A)]: _t, [Jt("textColor", A)]: $t, [Jt("border", A)]: Qt, [Jt("closeIconColor", A)]: Lt, [Jt("closeIconColorHover", A)]: zt, [Jt("closeIconColorPressed", A)]: It, [Jt("closeColorHover", A)]: At, [Jt("closeColorPressed", A)]: mr } } = m.value, gr = Zo(ie);
    return { "--n-font-weight-strong": yt, "--n-avatar-size-override": `calc(${ft} - 8px)`, "--n-bezier": W, "--n-border-radius": te, "--n-border": Qt, "--n-close-icon-size": dt, "--n-close-color-pressed": mr, "--n-close-color-hover": At, "--n-close-border-radius": gt, "--n-close-icon-color": Lt, "--n-close-icon-color-hover": zt, "--n-close-icon-color-pressed": It, "--n-close-icon-color-disabled": Lt, "--n-close-margin-top": gr.top, "--n-close-margin-right": gr.right, "--n-close-margin-bottom": gr.bottom, "--n-close-margin-left": gr.left, "--n-close-size": et, "--n-color": V || (l.value ? lt : _t), "--n-color-checkable": fe, "--n-color-checked": Ve, "--n-color-checked-hover": Qe, "--n-color-checked-pressed": ut, "--n-color-hover-checkable": _e, "--n-color-pressed-checkable": qe, "--n-font-size": Ft, "--n-height": ft, "--n-opacity-disabled": re, "--n-padding": ee, "--n-text-color": Y || $t, "--n-text-color-checkable": X, "--n-text-color-checked": oe, "--n-text-color-hover-checkable": Se, "--n-text-color-pressed-checkable": pe };
  }), D = f ? bi("tag", Me(() => {
    let A = "";
    const { type: O, size: V, color: { color: Y, textColor: W } = {} } = r;
    return A += O[0], A += V[0], Y && (A += `a${Yv(Y)}`), W && (A += `b${Yv(W)}`), l.value && (A += "c"), A;
  }), F, r) : void 0;
  return Object.assign(Object.assign({}, P), { rtlEnabled: M, mergedClsPrefix: d, contentRef: i, mergedBordered: l, handleClick: s, handleCloseClick: C, cssVars: f ? void 0 : F, themeClass: D == null ? void 0 : D.themeClass, onRender: D == null ? void 0 : D.onRender });
}, render() {
  var r, i;
  const { mergedClsPrefix: l, rtlEnabled: d, closable: f, color: { borderColor: g } = {}, round: m, onRender: s, $slots: C } = this;
  s == null ? void 0 : s();
  const P = Ii(C.avatar, (F) => F && B("div", { class: `${l}-tag__avatar` }, F)), M = Ii(C.icon, (F) => F && B("div", { class: `${l}-tag__icon` }, F));
  return B("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: d, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: m, [`${l}-tag--avatar`]: P, [`${l}-tag--icon`]: M, [`${l}-tag--closable`]: f }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, M || P, B("span", { class: `${l}-tag__content`, ref: "contentRef" }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r)), !this.checkable && f ? B(Vg, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: m, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? B("div", { class: `${l}-tag__border`, style: { borderColor: g } }) : null);
} }), kb = ot({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(r, { slots: i }) {
  return () => {
    const { clsPrefix: l } = r;
    return B(np, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: r.loading }, { default: () => r.showArrow ? B(_g, { clsPrefix: l, show: r.showClear, onClear: r.onClear }, { placeholder: () => B(Wr, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => Kn(i.default, () => [B(ik, null)]) }) }) : null });
  };
} }), Pk = Ge([ce("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [ce("base-loading", `
 color: var(--n-loading-color);
 `), ce("base-selection-tags", "min-height: var(--n-height);"), Fe("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Fe("state-border", `
 z-index: 1;
 border-color: #0000;
 `), ce("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Fe("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), ce("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Fe("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), ce("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Fe("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), ce("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ce("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [ce("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Fe("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Fe("render-label", `
 color: var(--n-text-color);
 `)]), pi("disabled", [Ge("&:hover", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ue("focus", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ue("active", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), ce("base-selection-label", "background-color: var(--n-color-active);"), ce("base-selection-tags", "background-color: var(--n-color-active);")])]), Ue("disabled", "cursor: not-allowed;", [Fe("arrow", `
 color: var(--n-arrow-color-disabled);
 `), ce("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [ce("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Fe("render-label", `
 color: var(--n-text-color-disabled);
 `)]), ce("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), ce("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), ce("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Fe("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Fe("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((r) => Ue(`${r}-status`, [Fe("state-border", `border: var(--n-border-${r});`), pi("disabled", [Ge("&:hover", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-hover-${r});
 border: var(--n-border-hover-${r});
 `)]), Ue("active", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-active-${r});
 border: var(--n-border-active-${r});
 `), ce("base-selection-label", `background-color: var(--n-color-active-${r});`), ce("base-selection-tags", `background-color: var(--n-color-active-${r});`)]), Ue("focus", [Fe("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), ce("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), ce("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [Ge("&:last-child", "padding-right: 0;"), ce("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Fe("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), Tk = ot({ name: "InternalSelection", props: Object.assign(Object.assign({}, rr.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Mr(r), d = Un("InternalSelection", l, i), f = Re(null), g = Re(null), m = Re(null), s = Re(null), C = Re(null), P = Re(null), M = Re(null), F = Re(null), D = Re(null), A = Re(null), O = Re(false), V = Re(false), Y = Re(false), W = rr("InternalSelection", "-internal-selection", Pk, b2, r, Bt(r, "clsPrefix")), ee = Me(() => r.clearable && !r.disabled && (Y.value || r.active)), ie = Me(() => r.selectedOption ? r.renderTag ? r.renderTag({ option: r.selectedOption, handleClose: () => {
  } }) : r.renderLabel ? r.renderLabel(r.selectedOption, true) : Cl(r.selectedOption[r.labelField], r.selectedOption, true) : r.placeholder), te = Me(() => {
    const tt = r.selectedOption;
    if (tt) return tt[r.labelField];
  }), re = Me(() => r.multiple ? !!(Array.isArray(r.selectedOptions) && r.selectedOptions.length) : r.selectedOption !== null);
  function X() {
    var tt;
    const { value: mt } = f;
    if (mt) {
      const { value: Kt } = g;
      Kt && (Kt.style.width = `${mt.offsetWidth}px`, r.maxTagCount !== "responsive" && ((tt = D.value) === null || tt === void 0 || tt.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function Se() {
    const { value: tt } = A;
    tt && (tt.style.display = "none");
  }
  function pe() {
    const { value: tt } = A;
    tt && (tt.style.display = "inline-block");
  }
  Ht(Bt(r, "active"), (tt) => {
    tt || Se();
  }), Ht(Bt(r, "pattern"), () => {
    r.multiple && Vn(X);
  });
  function oe(tt) {
    const { onFocus: mt } = r;
    mt && mt(tt);
  }
  function fe(tt) {
    const { onBlur: mt } = r;
    mt && mt(tt);
  }
  function _e(tt) {
    const { onDeleteOption: mt } = r;
    mt && mt(tt);
  }
  function qe(tt) {
    const { onClear: mt } = r;
    mt && mt(tt);
  }
  function Ve(tt) {
    const { onPatternInput: mt } = r;
    mt && mt(tt);
  }
  function Qe(tt) {
    var mt;
    (!tt.relatedTarget || !(!((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget))) && oe(tt);
  }
  function ut(tt) {
    var mt;
    !((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget) || fe(tt);
  }
  function gt(tt) {
    qe(tt);
  }
  function yt() {
    Y.value = true;
  }
  function lt() {
    Y.value = false;
  }
  function et(tt) {
    !r.active || !r.filterable || tt.target !== g.value && tt.preventDefault();
  }
  function dt(tt) {
    _e(tt);
  }
  const Ft = Re(false);
  function ft(tt) {
    if (tt.key === "Backspace" && !Ft.value && !r.pattern.length) {
      const { selectedOptions: mt } = r;
      (mt == null ? void 0 : mt.length) && dt(mt[mt.length - 1]);
    }
  }
  let _t = null;
  function $t(tt) {
    const { value: mt } = f;
    if (mt) {
      const Kt = tt.target.value;
      mt.textContent = Kt, X();
    }
    r.ignoreComposition && Ft.value ? _t = tt : Ve(tt);
  }
  function Qt() {
    Ft.value = true;
  }
  function Lt() {
    Ft.value = false, r.ignoreComposition && Ve(_t), _t = null;
  }
  function zt(tt) {
    var mt;
    V.value = true, (mt = r.onPatternFocus) === null || mt === void 0 || mt.call(r, tt);
  }
  function It(tt) {
    var mt;
    V.value = false, (mt = r.onPatternBlur) === null || mt === void 0 || mt.call(r, tt);
  }
  function At() {
    var tt, mt;
    if (r.filterable) V.value = false, (tt = P.value) === null || tt === void 0 || tt.blur(), (mt = g.value) === null || mt === void 0 || mt.blur();
    else if (r.multiple) {
      const { value: Kt } = s;
      Kt == null ? void 0 : Kt.blur();
    } else {
      const { value: Kt } = C;
      Kt == null ? void 0 : Kt.blur();
    }
  }
  function mr() {
    var tt, mt, Kt;
    r.filterable ? (V.value = false, (tt = P.value) === null || tt === void 0 || tt.focus()) : r.multiple ? (mt = s.value) === null || mt === void 0 || mt.focus() : (Kt = C.value) === null || Kt === void 0 || Kt.focus();
  }
  function gr() {
    const { value: tt } = g;
    tt && (pe(), tt.focus());
  }
  function ir() {
    const { value: tt } = g;
    tt && tt.blur();
  }
  function nr(tt) {
    const { value: mt } = M;
    mt && mt.setTextContent(`+${tt}`);
  }
  function Ut() {
    const { value: tt } = F;
    return tt;
  }
  function Ar() {
    return g.value;
  }
  let wr = null;
  function Ct() {
    wr !== null && window.clearTimeout(wr);
  }
  function Ee() {
    r.active || (Ct(), wr = window.setTimeout(() => {
      re.value && (O.value = true);
    }, 100));
  }
  function nt() {
    Ct();
  }
  function Be(tt) {
    tt || (Ct(), O.value = false);
  }
  Ht(re, (tt) => {
    tt || (O.value = false);
  }), ji(() => {
    vo(() => {
      const tt = P.value;
      tt && (r.disabled ? tt.removeAttribute("tabindex") : tt.tabIndex = V.value ? -1 : 0);
    });
  }), bb(m, r.onResize);
  const { inlineThemeDisabled: Ye } = r, ht = Me(() => {
    const { size: tt } = r, { common: { cubicBezierEaseInOut: mt }, self: { fontWeight: Kt, borderRadius: Qr, color: ki, placeholderColor: ze, textColor: Z, paddingSingle: H, paddingMultiple: ne, caretColor: xe, colorDisabled: Pe, textColorDisabled: De, placeholderColorDisabled: he, colorActive: ve, boxShadowFocus: je, boxShadowActive: it, boxShadowHover: Xe, border: xt, borderFocus: Te, borderHover: Vt, borderActive: or, arrowColor: qt, arrowColorDisabled: dr, loadingColor: Br, colorActiveWarning: Vr, boxShadowFocusWarning: Kr, boxShadowActiveWarning: ci, boxShadowHoverWarning: di, borderWarning: Lr, borderFocusWarning: Ur, borderHoverWarning: de, borderActiveWarning: at, colorActiveError: Zt, boxShadowFocusError: Rr, boxShadowActiveError: Cr, boxShadowHoverError: st, borderError: ar, borderFocusError: cr, borderHoverError: ei, borderActiveError: pn, clearColor: rn, clearColorHover: hr, clearColorPressed: Jo, clearSize: qn, arrowSize: Qo, [Jt("height", tt)]: kn, [Jt("fontSize", tt)]: _o } } = W.value, Xr = Zo(H), to = Zo(ne);
    return { "--n-bezier": mt, "--n-border": xt, "--n-border-active": or, "--n-border-focus": Te, "--n-border-hover": Vt, "--n-border-radius": Qr, "--n-box-shadow-active": it, "--n-box-shadow-focus": je, "--n-box-shadow-hover": Xe, "--n-caret-color": xe, "--n-color": ki, "--n-color-active": ve, "--n-color-disabled": Pe, "--n-font-size": _o, "--n-height": kn, "--n-padding-single-top": Xr.top, "--n-padding-multiple-top": to.top, "--n-padding-single-right": Xr.right, "--n-padding-multiple-right": to.right, "--n-padding-single-left": Xr.left, "--n-padding-multiple-left": to.left, "--n-padding-single-bottom": Xr.bottom, "--n-padding-multiple-bottom": to.bottom, "--n-placeholder-color": ze, "--n-placeholder-color-disabled": he, "--n-text-color": Z, "--n-text-color-disabled": De, "--n-arrow-color": qt, "--n-arrow-color-disabled": dr, "--n-loading-color": Br, "--n-color-active-warning": Vr, "--n-box-shadow-focus-warning": Kr, "--n-box-shadow-active-warning": ci, "--n-box-shadow-hover-warning": di, "--n-border-warning": Lr, "--n-border-focus-warning": Ur, "--n-border-hover-warning": de, "--n-border-active-warning": at, "--n-color-active-error": Zt, "--n-box-shadow-focus-error": Rr, "--n-box-shadow-active-error": Cr, "--n-box-shadow-hover-error": st, "--n-border-error": ar, "--n-border-focus-error": cr, "--n-border-hover-error": ei, "--n-border-active-error": pn, "--n-clear-size": qn, "--n-clear-color": rn, "--n-clear-color-hover": hr, "--n-clear-color-pressed": Jo, "--n-arrow-size": Qo, "--n-font-weight": Kt };
  }), bt = Ye ? bi("internal-selection", Me(() => r.size[0]), ht, r) : void 0;
  return { mergedTheme: W, mergedClearable: ee, mergedClsPrefix: i, rtlEnabled: d, patternInputFocused: V, filterablePlaceholder: ie, label: te, selected: re, showTagsPanel: O, isComposing: Ft, counterRef: M, counterWrapperRef: F, patternInputMirrorRef: f, patternInputRef: g, selfRef: m, multipleElRef: s, singleElRef: C, patternInputWrapperRef: P, overflowRef: D, inputTagElRef: A, handleMouseDown: et, handleFocusin: Qe, handleClear: gt, handleMouseEnter: yt, handleMouseLeave: lt, handleDeleteOption: dt, handlePatternKeyDown: ft, handlePatternInputInput: $t, handlePatternInputBlur: It, handlePatternInputFocus: zt, handleMouseEnterCounter: Ee, handleMouseLeaveCounter: nt, handleFocusout: ut, handleCompositionEnd: Lt, handleCompositionStart: Qt, onPopoverUpdateShow: Be, focus: mr, focusInput: gr, blur: At, blurInput: ir, updateCounter: nr, getCounter: Ut, getTail: Ar, renderLabel: r.renderLabel, cssVars: Ye ? void 0 : ht, themeClass: bt == null ? void 0 : bt.themeClass, onRender: bt == null ? void 0 : bt.onRender };
}, render() {
  const { status: r, multiple: i, size: l, disabled: d, filterable: f, maxTagCount: g, bordered: m, clsPrefix: s, ellipsisTagPopoverProps: C, onRender: P, renderTag: M, renderLabel: F } = this;
  P == null ? void 0 : P();
  const D = g === "responsive", A = typeof g == "number", O = D || A, V = B(_2, null, { default: () => B(kb, { clsPrefix: s, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var W, ee;
    return (ee = (W = this.$slots).arrow) === null || ee === void 0 ? void 0 : ee.call(W);
  } }) });
  let Y;
  if (i) {
    const { labelField: W } = this, ee = (Ve) => B("div", { class: `${s}-base-selection-tag-wrapper`, key: Ve.value }, M ? M({ option: Ve, handleClose: () => {
      this.handleDeleteOption(Ve);
    } }) : B(Mo, { size: l, closable: !Ve.disabled, disabled: d, onClose: () => {
      this.handleDeleteOption(Ve);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => F ? F(Ve, true) : Cl(Ve[W], Ve, true) })), ie = () => (A ? this.selectedOptions.slice(0, g) : this.selectedOptions).map(ee), te = f ? B("div", { class: `${s}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: d, value: this.pattern, autofocus: this.autofocus, class: `${s}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), B("span", { ref: "patternInputMirrorRef", class: `${s}-base-selection-input-tag__mirror` }, this.pattern)) : null, re = D ? () => B("div", { class: `${s}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, B(Mo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: d })) : void 0;
    let X;
    if (A) {
      const Ve = this.selectedOptions.length - g;
      Ve > 0 && (X = B("div", { class: `${s}-base-selection-tag-wrapper`, key: "__counter__" }, B(Mo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: d }, { default: () => `+${Ve}` })));
    }
    const Se = D ? f ? B(Kv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re, tail: () => te }) : B(Kv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re }) : A && X ? ie().concat(X) : ie(), pe = O ? () => B("div", { class: `${s}-base-selection-popover` }, D ? ie() : this.selectedOptions.map(ee)) : void 0, oe = O ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, C) : null, _e = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay` }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)) : null, qe = f ? B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-tags` }, Se, D ? null : te, V) : B("div", { ref: "multipleElRef", class: `${s}-base-selection-tags`, tabindex: d ? void 0 : 0 }, Se, V);
    Y = B(Hr, null, O ? B(Ug, Object.assign({}, oe, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => qe, default: pe }) : qe, _e);
  } else if (f) {
    const W = this.pattern || this.isComposing, ee = this.active ? !W : !this.selected, ie = this.active ? false : this.selected;
    Y = B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-label`, title: this.patternInputFocused ? void 0 : yg(this.label) }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${s}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: d, disabled: d, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), ie ? B("div", { class: `${s}-base-selection-label__render-label ${s}-base-selection-overlay`, key: "input" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, M ? M({ option: this.selectedOption, handleClose: () => {
    } }) : F ? F(this.selectedOption, true) : Cl(this.label, this.selectedOption, true))) : null, ee ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, V);
  } else Y = B("div", { ref: "singleElRef", class: `${s}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? B("div", { class: `${s}-base-selection-input`, title: yg(this.label), key: "input" }, B("div", { class: `${s}-base-selection-input__content` }, M ? M({ option: this.selectedOption, handleClose: () => {
  } }) : F ? F(this.selectedOption, true) : Cl(this.label, this.selectedOption, true))) : B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)), V);
  return B("div", { ref: "selfRef", class: [`${s}-base-selection`, this.rtlEnabled && `${s}-base-selection--rtl`, this.themeClass, r && `${s}-base-selection--${r}-status`, { [`${s}-base-selection--active`]: this.active, [`${s}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${s}-base-selection--disabled`]: this.disabled, [`${s}-base-selection--multiple`]: this.multiple, [`${s}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, Y, m ? B("div", { class: `${s}-base-selection__border` }) : null, m ? B("div", { class: `${s}-base-selection__state-border` }) : null);
} }), Of = Rn("n-anchor"), Ik = { title: String, href: String }, $f = ot({ name: "AnchorLink", props: Ik, slots: Object, setup(r, { slots: i }) {
  const l = Re(null), d = pr(Of), f = Bt(r, "href"), g = yi(() => f.value && f.value === d.activeHref.value);
  iS(Of, "collectedLinkHrefs", f), nS(Of, "titleEls", () => l.value), Ht(g, (s) => {
    s && l.value && d.updateBarPosition(l.value);
  });
  function m() {
    r.href !== void 0 && d.setActiveHref(r.href);
  }
  return () => {
    var s;
    const { value: C } = d.mergedClsPrefix;
    return B("div", { class: [`${C}-anchor-link`, g.value && `${C}-anchor-link--active`] }, B("a", { ref: l, class: [`${C}-anchor-link__title`], href: r.href, title: yg(r.title), onClick: m }, { default: () => Kn(i.title, () => [r.title]) }), (s = i.default) === null || s === void 0 ? void 0 : s.call(i));
  };
} });
function Mk(r, i) {
  const { top: l, height: d } = r.getBoundingClientRect(), f = i instanceof HTMLElement ? i.getBoundingClientRect().top : 0;
  return { top: l - f, height: d };
}
const Yg = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, Ek = jd(Yg), Rk = ot({ name: "BaseAnchor", props: Object.assign(Object.assign({}, Yg), { mergedClsPrefix: { type: String, required: true } }), setup(r) {
  const i = [], l = [], d = Re(null), f = Re(null), g = Re(null), m = Re(null);
  let s = false;
  const C = Me(() => r.type === "block"), P = Me(() => !C.value && r.showRail);
  function M() {
    const { value: ee } = g, { value: ie } = f;
    ee && (ee.style.transition = "none"), ie && (ie.style.transition = "none"), l && l.forEach((te) => {
      te.style.transition = "none";
    }), Vn(() => {
      const { value: te } = g, { value: re } = f;
      te && (te.offsetWidth, te.style.transition = ""), re && (re.offsetWidth, re.style.transition = ""), l && l.forEach((X) => {
        X.offsetWidth, X.style.transition = "";
      });
    });
  }
  function F(ee, ie = true) {
    const { value: te } = g, { value: re } = f, { value: X } = m;
    if (!X || !te) return;
    ie || (te.style.transition = "none", re && (re.style.transition = "none"));
    const { offsetHeight: Se, offsetWidth: pe } = ee, { top: oe, left: fe } = ee.getBoundingClientRect(), { top: _e, left: qe } = X.getBoundingClientRect(), Ve = oe - _e, Qe = fe - qe;
    te.style.top = `${Ve}px`, te.style.height = `${Se}px`, re && (re.style.top = `${Ve}px`, re.style.height = `${Se}px`, re.style.maxWidth = `${pe + Qe}px`), te.offsetHeight, re && re.offsetHeight, ie || (te.style.transition = "", re && (re.style.transition = ""));
  }
  let D, A = false, O = false;
  const V = () => {
    if (O) A = true;
    else {
      if (s) return;
      W(true), O = true, clearTimeout(D), D = setTimeout(() => {
        O = false, A && (A = false, V());
      }, 128);
    }
  };
  function Y(ee, ie = true) {
    const te = /^#([^#]+)$/.exec(ee);
    if (!te) return;
    const re = document.getElementById(te[1]);
    re && (s = true, d.value = ee, re.scrollIntoView(), ie || M(), A = false, setTimeout(() => {
      s = false;
    }, 0));
  }
  function W(ee = true) {
    var ie;
    const te = [], re = vb((ie = r.offsetTarget) !== null && ie !== void 0 ? ie : document);
    i.forEach((fe) => {
      const _e = /#([^#]+)$/.exec(fe);
      if (!_e) return;
      const qe = document.getElementById(_e[1]);
      if (qe && re) {
        const { top: Ve, height: Qe } = Mk(qe, re);
        te.push({ top: Ve, height: Qe, href: fe });
      }
    }), te.sort((fe, _e) => fe.top > _e.top ? 1 : (fe.top === _e.top && fe.height < _e.height, -1));
    const X = d.value, { bound: Se, ignoreGap: pe } = r, oe = te.reduce((fe, _e) => _e.top + _e.height < 0 ? pe ? _e : fe : _e.top <= Se ? fe === null ? _e : _e.top === fe.top ? _e.href === X ? _e : fe : _e.top > fe.top ? _e : fe : fe, null);
    ee || M(), oe ? d.value = oe.href : d.value = null;
  }
  return Zr(Of, { activeHref: d, mergedClsPrefix: Bt(r, "mergedClsPrefix"), updateBarPosition: F, setActiveHref: Y, collectedLinkHrefs: i, titleEls: l }), ji(() => {
    document.addEventListener("scroll", V, true), Y(window.location.hash), W(false);
  }), R_(() => {
    Y(window.location.hash), W(false);
  }), Sn(() => {
    clearTimeout(D), document.removeEventListener("scroll", V, true);
  }), Ht(d, (ee) => {
    if (ee === null) {
      const { value: ie } = f;
      ie && !C.value && (ie.style.maxWidth = "0");
    }
  }), { selfRef: m, barRef: g, slotRef: f, setActiveHref: Y, activeHref: d, isBlockType: C, mergedShowRail: P };
}, render() {
  var r;
  const { mergedClsPrefix: i, mergedShowRail: l, isBlockType: d, $slots: f } = this, g = B("div", { class: [`${i}-anchor`, d && `${i}-anchor--block`, l && `${i}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? B("div", { ref: "slotRef", class: `${i}-anchor-link-background` }) : null, l ? B("div", { class: `${i}-anchor-rail` }, B("div", { ref: "barRef", class: [`${i}-anchor-rail__bar`, this.activeHref !== null && `${i}-anchor-rail__bar--active`] })) : null, (r = f.default) === null || r === void 0 ? void 0 : r.call(f));
  return this.internalScrollable ? B(eh, null, { default: () => g }) : g;
} }), Ak = ce("anchor", `
 position: relative;
`, [pi("block", `
 padding-left: var(--n-rail-width);
 `, [ce("anchor-link", [Ge("+, >", [ce("anchor-link", `
 margin-top: .5em;
 `)])]), ce("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), pi("show-rail", [Ge(">", [ce("anchor-link", "padding-left: 0;")])])]), Ue("block", [ce("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ue("active", `
 background-color: var(--n-link-color);
 `)])]), ce("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ce("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Fe("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ue("active", { backgroundColor: "var(--n-rail-color-active)" })])]), ce("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ue("active", [Ge(">", [Fe("title", `
 color: var(--n-link-text-color-active);
 `)])]), Fe("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [Ge("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), Ge("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), Dk = Object.assign(Object.assign(Object.assign(Object.assign({}, rr.props), { affix: Boolean }), Xg), Yg), Pb = ot({ name: "Anchor", props: Dk, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Mr(r), f = rr("Anchor", "-anchor", Ak, x2, r, l), g = Re(null), m = Me(() => {
    const { self: { railColor: C, linkColor: P, railColorActive: M, linkTextColor: F, linkTextColorHover: D, linkTextColorPressed: A, linkTextColorActive: O, linkFontSize: V, railWidth: Y, linkPadding: W, borderRadius: ee }, common: { cubicBezierEaseInOut: ie } } = f.value;
    return { "--n-link-border-radius": ee, "--n-link-color": P, "--n-link-font-size": V, "--n-link-text-color": F, "--n-link-text-color-hover": D, "--n-link-text-color-active": O, "--n-link-text-color-pressed": A, "--n-link-padding": W, "--n-bezier": ie, "--n-rail-color": C, "--n-rail-color-active": M, "--n-rail-width": Y };
  }), s = d ? bi("anchor", void 0, m, r) : void 0;
  return { scrollTo(C) {
    var P;
    (P = g.value) === null || P === void 0 || P.setActiveHref(C);
  }, renderAnchor: () => (s == null ? void 0 : s.onRender(), B(Rk, Object.assign({ ref: g, style: d ? void 0 : m.value, class: s == null ? void 0 : s.themeClass.value }, lg(r, Ek), { mergedClsPrefix: l.value }), i)) };
}, render() {
  return this.affix ? B(QS, Object.assign({}, lg(this, JS)), { default: this.renderAnchor }) : this.renderAnchor();
} }), Tb = Rn("n-input"), zk = ce("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Fe("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Fe("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Fe("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), Ge("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), Ge("&:-webkit-autofill ~", [Fe("placeholder", "display: none;")])]), Ue("round", [pi("textarea", "border-radius: calc(var(--n-height) / 2);")]), Fe("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [Ge("span", `
 width: 100%;
 display: inline-block;
 `)]), Ue("textarea", [Fe("placeholder", "overflow: visible;")]), pi("autosize", "width: 100%;"), Ue("autosize", [Fe("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), ce("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Fe("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Fe("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [Ge("&[type=password]::-ms-reveal", "display: none;"), Ge("+", [Fe("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), pi("textarea", [Fe("placeholder", "white-space: nowrap;")]), Fe("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ue("textarea", "width: 100%;", [ce("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ue("resizable", [ce("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Fe("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Fe("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ue("pair", [Fe("input-el, placeholder", "text-align: center;"), Fe("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [ce("icon", `
 color: var(--n-icon-color);
 `), ce("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Fe("border", "border: var(--n-border-disabled);"), Fe("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Fe("placeholder", "color: var(--n-placeholder-color-disabled);"), Fe("separator", "color: var(--n-text-color-disabled);", [ce("icon", `
 color: var(--n-icon-color-disabled);
 `), ce("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), ce("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Fe("suffix, prefix", "color: var(--n-text-color-disabled);", [ce("icon", `
 color: var(--n-icon-color-disabled);
 `), ce("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), pi("disabled", [Fe("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [Ge("&:hover", `
 color: var(--n-icon-color-hover);
 `), Ge("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), Ge("&:hover", [Fe("state-border", "border: var(--n-border-hover);")]), Ue("focus", "background-color: var(--n-color-focus);", [Fe("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Fe("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Fe("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Fe("prefix", "margin-right: 4px;"), Fe("suffix", `
 margin-left: 4px;
 `), Fe("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [ce("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), ce("base-clear", `
 font-size: var(--n-icon-size);
 `, [Fe("placeholder", [ce("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), Ge(">", [ce("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), ce("base-icon", `
 font-size: var(--n-icon-size);
 `)]), ce("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((r) => Ue(`${r}-status`, [pi("disabled", [ce("base-loading", `
 color: var(--n-loading-color-${r})
 `), Fe("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${r});
 `), Fe("state-border", `
 border: var(--n-border-${r});
 `), Ge("&:hover", [Fe("state-border", `
 border: var(--n-border-hover-${r});
 `)]), Ge("&:focus", `
 background-color: var(--n-color-focus-${r});
 `, [Fe("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)]), Ue("focus", `
 background-color: var(--n-color-focus-${r});
 `, [Fe("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), Fk = ce("input", [Ue("disabled", [Fe("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function Lk(r) {
  let i = 0;
  for (const l of r) i++;
  return i;
}
function xf(r) {
  return r === "" || r == null;
}
function Bk(r) {
  const i = Re(null);
  function l() {
    const { value: g } = r;
    if (!(g == null ? void 0 : g.focus)) {
      f();
      return;
    }
    const { selectionStart: m, selectionEnd: s, value: C } = g;
    if (m == null || s == null) {
      f();
      return;
    }
    i.value = { start: m, end: s, beforeText: C.slice(0, m), afterText: C.slice(s) };
  }
  function d() {
    var g;
    const { value: m } = i, { value: s } = r;
    if (!m || !s) return;
    const { value: C } = s, { start: P, beforeText: M, afterText: F } = m;
    let D = C.length;
    if (C.endsWith(F)) D = C.length - F.length;
    else if (C.startsWith(M)) D = M.length;
    else {
      const A = M[P - 1], O = C.indexOf(A, P - 1);
      O !== -1 && (D = O + 1);
    }
    (g = s.setSelectionRange) === null || g === void 0 || g.call(s, D, D);
  }
  function f() {
    i.value = null;
  }
  return Ht(r, f), { recordCursor: l, restoreCursor: d };
}
const fy = ot({ name: "InputWordCount", setup(r, { slots: i }) {
  const { mergedValueRef: l, maxlengthRef: d, mergedClsPrefixRef: f, countGraphemesRef: g } = pr(Tb), m = Me(() => {
    const { value: s } = l;
    return s === null || Array.isArray(s) ? 0 : (g.value || Lk)(s);
  });
  return () => {
    const { value: s } = d, { value: C } = l;
    return B("span", { class: `${f.value}-input-word-count` }, ug(i.default, { value: C === null || Array.isArray(C) ? "" : C }, () => [s === void 0 ? m.value : `${m.value} / ${s}`]));
  };
} }), Ok = Object.assign(Object.assign({}, rr.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), mo = ot({ name: "Input", props: Ok, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Mr(r), g = rr("Input", "-input", zk, w2, r, i);
  C2 && cc("-input-safari", Fk, i);
  const m = Re(null), s = Re(null), C = Re(null), P = Re(null), M = Re(null), F = Re(null), D = Re(null), A = Bk(D), O = Re(null), { localeRef: V } = ts("Input"), Y = Re(r.defaultValue), W = Bt(r, "value"), ee = Hi(W, Y), ie = ya(r), { mergedSizeRef: te, mergedDisabledRef: re, mergedStatusRef: X } = ie, Se = Re(false), pe = Re(false), oe = Re(false), fe = Re(false);
  let _e = null;
  const qe = Me(() => {
    const { placeholder: de, pair: at } = r;
    return at ? Array.isArray(de) ? de : de === void 0 ? ["", ""] : [de, de] : de === void 0 ? [V.value.placeholder] : [de];
  }), Ve = Me(() => {
    const { value: de } = oe, { value: at } = ee, { value: Zt } = qe;
    return !de && (xf(at) || Array.isArray(at) && xf(at[0])) && Zt[0];
  }), Qe = Me(() => {
    const { value: de } = oe, { value: at } = ee, { value: Zt } = qe;
    return !de && Zt[1] && (xf(at) || Array.isArray(at) && xf(at[1]));
  }), ut = yi(() => r.internalForceFocus || Se.value), gt = yi(() => {
    if (re.value || r.readonly || !r.clearable || !ut.value && !pe.value) return false;
    const { value: de } = ee, { value: at } = ut;
    return r.pair ? !!(Array.isArray(de) && (de[0] || de[1])) && (pe.value || at) : !!de && (pe.value || at);
  }), yt = Me(() => {
    const { showPasswordOn: de } = r;
    if (de) return de;
    if (r.showPasswordToggle) return "click";
  }), lt = Re(false), et = Me(() => {
    const { textDecoration: de } = r;
    return de ? Array.isArray(de) ? de.map((at) => ({ textDecoration: at })) : [{ textDecoration: de }] : ["", ""];
  }), dt = Re(void 0), Ft = () => {
    var de, at;
    if (r.type === "textarea") {
      const { autosize: Zt } = r;
      if (Zt && (dt.value = (at = (de = O.value) === null || de === void 0 ? void 0 : de.$el) === null || at === void 0 ? void 0 : at.offsetWidth), !s.value || typeof Zt == "boolean") return;
      const { paddingTop: Rr, paddingBottom: Cr, lineHeight: st } = window.getComputedStyle(s.value), ar = Number(Rr.slice(0, -2)), cr = Number(Cr.slice(0, -2)), ei = Number(st.slice(0, -2)), { value: pn } = C;
      if (!pn) return;
      if (Zt.minRows) {
        const rn = Math.max(Zt.minRows, 1), hr = `${ar + cr + ei * rn}px`;
        pn.style.minHeight = hr;
      }
      if (Zt.maxRows) {
        const rn = `${ar + cr + ei * Zt.maxRows}px`;
        pn.style.maxHeight = rn;
      }
    }
  }, ft = Me(() => {
    const { maxlength: de } = r;
    return de === void 0 ? void 0 : Number(de);
  });
  ji(() => {
    const { value: de } = ee;
    Array.isArray(de) || or(de);
  });
  const _t = Qd().proxy;
  function $t(de, at) {
    const { onUpdateValue: Zt, "onUpdate:value": Rr, onInput: Cr } = r, { nTriggerFormInput: st } = ie;
    Zt && jt(Zt, de, at), Rr && jt(Rr, de, at), Cr && jt(Cr, de, at), Y.value = de, st();
  }
  function Qt(de, at) {
    const { onChange: Zt } = r, { nTriggerFormChange: Rr } = ie;
    Zt && jt(Zt, de, at), Y.value = de, Rr();
  }
  function Lt(de) {
    const { onBlur: at } = r, { nTriggerFormBlur: Zt } = ie;
    at && jt(at, de), Zt();
  }
  function zt(de) {
    const { onFocus: at } = r, { nTriggerFormFocus: Zt } = ie;
    at && jt(at, de), Zt();
  }
  function It(de) {
    const { onClear: at } = r;
    at && jt(at, de);
  }
  function At(de) {
    const { onInputBlur: at } = r;
    at && jt(at, de);
  }
  function mr(de) {
    const { onInputFocus: at } = r;
    at && jt(at, de);
  }
  function gr() {
    const { onDeactivate: de } = r;
    de && jt(de);
  }
  function ir() {
    const { onActivate: de } = r;
    de && jt(de);
  }
  function nr(de) {
    const { onClick: at } = r;
    at && jt(at, de);
  }
  function Ut(de) {
    const { onWrapperFocus: at } = r;
    at && jt(at, de);
  }
  function Ar(de) {
    const { onWrapperBlur: at } = r;
    at && jt(at, de);
  }
  function wr() {
    oe.value = true;
  }
  function Ct(de) {
    oe.value = false, de.target === F.value ? Ee(de, 1) : Ee(de, 0);
  }
  function Ee(de, at = 0, Zt = "input") {
    const Rr = de.target.value;
    if (or(Rr), de instanceof InputEvent && !de.isComposing && (oe.value = false), r.type === "textarea") {
      const { value: st } = O;
      st && st.syncUnifiedContainer();
    }
    if (_e = Rr, oe.value) return;
    A.recordCursor();
    const Cr = nt(Rr);
    if (Cr) if (!r.pair) Zt === "input" ? $t(Rr, { source: at }) : Qt(Rr, { source: at });
    else {
      let { value: st } = ee;
      Array.isArray(st) ? st = [st[0], st[1]] : st = ["", ""], st[at] = Rr, Zt === "input" ? $t(st, { source: at }) : Qt(st, { source: at });
    }
    _t.$forceUpdate(), Cr || Vn(A.restoreCursor);
  }
  function nt(de) {
    const { countGraphemes: at, maxlength: Zt, minlength: Rr } = r;
    if (at) {
      let st;
      if (Zt !== void 0 && (st === void 0 && (st = at(de)), st > Number(Zt)) || Rr !== void 0 && (st === void 0 && (st = at(de)), st < Number(Zt))) return false;
    }
    const { allowInput: Cr } = r;
    return typeof Cr == "function" ? Cr(de) : true;
  }
  function Be(de) {
    At(de), de.relatedTarget === m.value && gr(), de.relatedTarget !== null && (de.relatedTarget === M.value || de.relatedTarget === F.value || de.relatedTarget === s.value) || (fe.value = false), tt(de, "blur"), D.value = null;
  }
  function Ye(de, at) {
    mr(de), Se.value = true, fe.value = true, ir(), tt(de, "focus"), at === 0 ? D.value = M.value : at === 1 ? D.value = F.value : at === 2 && (D.value = s.value);
  }
  function ht(de) {
    r.passivelyActivated && (Ar(de), tt(de, "blur"));
  }
  function bt(de) {
    r.passivelyActivated && (Se.value = true, Ut(de), tt(de, "focus"));
  }
  function tt(de, at) {
    de.relatedTarget !== null && (de.relatedTarget === M.value || de.relatedTarget === F.value || de.relatedTarget === s.value || de.relatedTarget === m.value) || (at === "focus" ? (zt(de), Se.value = true) : at === "blur" && (Lt(de), Se.value = false));
  }
  function mt(de, at) {
    Ee(de, at, "change");
  }
  function Kt(de) {
    nr(de);
  }
  function Qr(de) {
    It(de), ki();
  }
  function ki() {
    r.pair ? ($t(["", ""], { source: "clear" }), Qt(["", ""], { source: "clear" })) : ($t("", { source: "clear" }), Qt("", { source: "clear" }));
  }
  function ze(de) {
    const { onMousedown: at } = r;
    at && at(de);
    const { tagName: Zt } = de.target;
    if (Zt !== "INPUT" && Zt !== "TEXTAREA") {
      if (r.resizable) {
        const { value: Rr } = m;
        if (Rr) {
          const { left: Cr, top: st, width: ar, height: cr } = Rr.getBoundingClientRect(), ei = 14;
          if (Cr + ar - ei < de.clientX && de.clientX < Cr + ar && st + cr - ei < de.clientY && de.clientY < st + cr) return;
        }
      }
      de.preventDefault(), Se.value || je();
    }
  }
  function Z() {
    var de;
    pe.value = true, r.type === "textarea" && ((de = O.value) === null || de === void 0 || de.handleMouseEnterWrapper());
  }
  function H() {
    var de;
    pe.value = false, r.type === "textarea" && ((de = O.value) === null || de === void 0 || de.handleMouseLeaveWrapper());
  }
  function ne() {
    re.value || yt.value === "click" && (lt.value = !lt.value);
  }
  function xe(de) {
    if (re.value) return;
    de.preventDefault();
    const at = (Rr) => {
      Rr.preventDefault(), Xn("mouseup", document, at);
    };
    if (En("mouseup", document, at), yt.value !== "mousedown") return;
    lt.value = true;
    const Zt = () => {
      lt.value = false, Xn("mouseup", document, Zt);
    };
    En("mouseup", document, Zt);
  }
  function Pe(de) {
    r.onKeyup && jt(r.onKeyup, de);
  }
  function De(de) {
    switch (r.onKeydown && jt(r.onKeydown, de), de.key) {
      case "Escape":
        ve();
        break;
      case "Enter":
        he(de);
        break;
    }
  }
  function he(de) {
    var at, Zt;
    if (r.passivelyActivated) {
      const { value: Rr } = fe;
      if (Rr) {
        r.internalDeactivateOnEnter && ve();
        return;
      }
      de.preventDefault(), r.type === "textarea" ? (at = s.value) === null || at === void 0 || at.focus() : (Zt = M.value) === null || Zt === void 0 || Zt.focus();
    }
  }
  function ve() {
    r.passivelyActivated && (fe.value = false, Vn(() => {
      var de;
      (de = m.value) === null || de === void 0 || de.focus();
    }));
  }
  function je() {
    var de, at, Zt;
    re.value || (r.passivelyActivated ? (de = m.value) === null || de === void 0 || de.focus() : ((at = s.value) === null || at === void 0 || at.focus(), (Zt = M.value) === null || Zt === void 0 || Zt.focus()));
  }
  function it() {
    var de;
    !((de = m.value) === null || de === void 0) && de.contains(document.activeElement) && document.activeElement.blur();
  }
  function Xe() {
    var de, at;
    (de = s.value) === null || de === void 0 || de.select(), (at = M.value) === null || at === void 0 || at.select();
  }
  function xt() {
    re.value || (s.value ? s.value.focus() : M.value && M.value.focus());
  }
  function Te() {
    const { value: de } = m;
    (de == null ? void 0 : de.contains(document.activeElement)) && de !== document.activeElement && ve();
  }
  function Vt(de) {
    if (r.type === "textarea") {
      const { value: at } = s;
      at == null ? void 0 : at.scrollTo(de);
    } else {
      const { value: at } = M;
      at == null ? void 0 : at.scrollTo(de);
    }
  }
  function or(de) {
    const { type: at, pair: Zt, autosize: Rr } = r;
    if (!Zt && Rr) if (at === "textarea") {
      const { value: Cr } = C;
      Cr && (Cr.textContent = `${de ?? ""}\r
`);
    } else {
      const { value: Cr } = P;
      Cr && (de ? Cr.textContent = de : Cr.innerHTML = "&nbsp;");
    }
  }
  function qt() {
    Ft();
  }
  const dr = Re({ top: "0" });
  function Br(de) {
    var at;
    const { scrollTop: Zt } = de.target;
    dr.value.top = `${-Zt}px`, (at = O.value) === null || at === void 0 || at.syncUnifiedContainer();
  }
  let Vr = null;
  vo(() => {
    const { autosize: de, type: at } = r;
    de && at === "textarea" ? Vr = Ht(ee, (Zt) => {
      !Array.isArray(Zt) && Zt !== _e && or(Zt);
    }) : Vr == null ? void 0 : Vr();
  });
  let Kr = null;
  vo(() => {
    r.type === "textarea" ? Kr = Ht(ee, (de) => {
      var at;
      !Array.isArray(de) && de !== _e && ((at = O.value) === null || at === void 0 || at.syncUnifiedContainer());
    }) : Kr == null ? void 0 : Kr();
  }), Zr(Tb, { mergedValueRef: ee, maxlengthRef: ft, mergedClsPrefixRef: i, countGraphemesRef: Bt(r, "countGraphemes") });
  const ci = { wrapperElRef: m, inputElRef: M, textareaElRef: s, isCompositing: oe, clear: ki, focus: je, blur: it, select: Xe, deactivate: Te, activate: xt, scrollTo: Vt }, di = Un("Input", f, i), Lr = Me(() => {
    const { value: de } = te, { common: { cubicBezierEaseInOut: at }, self: { color: Zt, borderRadius: Rr, textColor: Cr, caretColor: st, caretColorError: ar, caretColorWarning: cr, textDecorationColor: ei, border: pn, borderDisabled: rn, borderHover: hr, borderFocus: Jo, placeholderColor: qn, placeholderColorDisabled: Qo, lineHeightTextarea: kn, colorDisabled: _o, colorFocus: Xr, textColorDisabled: to, boxShadowFocus: nn, iconSize: qr, colorFocusWarning: Bl, boxShadowFocusWarning: xa, borderWarning: Es, borderFocusWarning: bo, borderHoverWarning: xo, colorFocusError: Rs, boxShadowFocusError: Ol, borderError: $l, borderFocusError: ea, borderHoverError: jl, clearSize: fc, clearColor: pc, clearColorHover: mc, clearColorPressed: As, iconColor: ta, iconColorDisabled: Ds, suffixTextColor: zs, countTextColor: ra, countTextColorDisabled: Fs, iconColorHover: Ls, iconColorPressed: gc, loadingColor: ia, loadingColorError: wa, loadingColorWarning: An, fontWeight: _r, [Jt("padding", de)]: Ao, [Jt("fontSize", de)]: wo, [Jt("height", de)]: ro } } = g.value, { left: Do, right: br } = Zo(Ao);
    return { "--n-bezier": at, "--n-count-text-color": ra, "--n-count-text-color-disabled": Fs, "--n-color": Zt, "--n-font-size": wo, "--n-font-weight": _r, "--n-border-radius": Rr, "--n-height": ro, "--n-padding-left": Do, "--n-padding-right": br, "--n-text-color": Cr, "--n-caret-color": st, "--n-text-decoration-color": ei, "--n-border": pn, "--n-border-disabled": rn, "--n-border-hover": hr, "--n-border-focus": Jo, "--n-placeholder-color": qn, "--n-placeholder-color-disabled": Qo, "--n-icon-size": qr, "--n-line-height-textarea": kn, "--n-color-disabled": _o, "--n-color-focus": Xr, "--n-text-color-disabled": to, "--n-box-shadow-focus": nn, "--n-loading-color": ia, "--n-caret-color-warning": cr, "--n-color-focus-warning": Bl, "--n-box-shadow-focus-warning": xa, "--n-border-warning": Es, "--n-border-focus-warning": bo, "--n-border-hover-warning": xo, "--n-loading-color-warning": An, "--n-caret-color-error": ar, "--n-color-focus-error": Rs, "--n-box-shadow-focus-error": Ol, "--n-border-error": $l, "--n-border-focus-error": ea, "--n-border-hover-error": jl, "--n-loading-color-error": wa, "--n-clear-color": pc, "--n-clear-size": fc, "--n-clear-color-hover": mc, "--n-clear-color-pressed": As, "--n-icon-color": ta, "--n-icon-color-hover": Ls, "--n-icon-color-pressed": gc, "--n-icon-color-disabled": Ds, "--n-suffix-text-color": zs };
  }), Ur = d ? bi("input", Me(() => {
    const { value: de } = te;
    return de[0];
  }), Lr, r) : void 0;
  return Object.assign(Object.assign({}, ci), { wrapperElRef: m, inputElRef: M, inputMirrorElRef: P, inputEl2Ref: F, textareaElRef: s, textareaMirrorElRef: C, textareaScrollbarInstRef: O, rtlEnabled: di, uncontrolledValue: Y, mergedValue: ee, passwordVisible: lt, mergedPlaceholder: qe, showPlaceholder1: Ve, showPlaceholder2: Qe, mergedFocus: ut, isComposing: oe, activated: fe, showClearButton: gt, mergedSize: te, mergedDisabled: re, textDecorationStyle: et, mergedClsPrefix: i, mergedBordered: l, mergedShowPasswordOn: yt, placeholderStyle: dr, mergedStatus: X, textAreaScrollContainerWidth: dt, handleTextAreaScroll: Br, handleCompositionStart: wr, handleCompositionEnd: Ct, handleInput: Ee, handleInputBlur: Be, handleInputFocus: Ye, handleWrapperBlur: ht, handleWrapperFocus: bt, handleMouseEnter: Z, handleMouseLeave: H, handleMouseDown: ze, handleChange: mt, handleClick: Kt, handleClear: Qr, handlePasswordToggleClick: ne, handlePasswordToggleMousedown: xe, handleWrapperKeydown: De, handleWrapperKeyup: Pe, handleTextAreaMirrorResize: qt, getTextareaScrollContainer: () => s.value, mergedTheme: g, cssVars: d ? void 0 : Lr, themeClass: Ur == null ? void 0 : Ur.themeClass, onRender: Ur == null ? void 0 : Ur.onRender });
}, render() {
  var r, i, l, d, f, g, m;
  const { mergedClsPrefix: s, mergedStatus: C, themeClass: P, type: M, countGraphemes: F, onRender: D } = this, A = this.$slots;
  return D == null ? void 0 : D(), B("div", { ref: "wrapperElRef", class: [`${s}-input`, P, C && `${s}-input--${C}-status`, { [`${s}-input--rtl`]: this.rtlEnabled, [`${s}-input--disabled`]: this.mergedDisabled, [`${s}-input--textarea`]: M === "textarea", [`${s}-input--resizable`]: this.resizable && !this.autosize, [`${s}-input--autosize`]: this.autosize, [`${s}-input--round`]: this.round && M !== "textarea", [`${s}-input--pair`]: this.pair, [`${s}-input--focus`]: this.mergedFocus, [`${s}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, B("div", { class: `${s}-input-wrapper` }, Ii(A.prefix, (O) => O && B("div", { class: `${s}-input__prefix` }, O)), M === "textarea" ? B(eh, { ref: "textareaScrollbarInstRef", class: `${s}-input__textarea`, container: this.getTextareaScrollContainer, theme: (i = (r = this.theme) === null || r === void 0 ? void 0 : r.peers) === null || i === void 0 ? void 0 : i.Scrollbar, themeOverrides: (d = (l = this.themeOverrides) === null || l === void 0 ? void 0 : l.peers) === null || d === void 0 ? void 0 : d.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var O, V;
    const { textAreaScrollContainerWidth: Y } = this, W = { width: this.autosize && Y && `${Y}px` };
    return B(Hr, null, B("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${s}-input__textarea-el`, (O = this.inputProps) === null || O === void 0 ? void 0 : O.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: F ? void 0 : this.maxlength, minlength: F ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (V = this.inputProps) === null || V === void 0 ? void 0 : V.style, W], onBlur: this.handleInputBlur, onFocus: (ee) => {
      this.handleInputFocus(ee, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder`, style: [this.placeholderStyle, W], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? B(Pl, { onResize: this.handleTextAreaMirrorResize }, { default: () => B("div", { ref: "textareaMirrorElRef", class: `${s}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : B("div", { class: `${s}-input__input` }, B("input", Object.assign({ type: M === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : M }, this.inputProps, { ref: "inputElRef", class: [`${s}-input__input-el`, (f = this.inputProps) === null || f === void 0 ? void 0 : f.class], style: [this.textDecorationStyle[0], (g = this.inputProps) === null || g === void 0 ? void 0 : g.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (m = this.inputProps) === null || m === void 0 ? void 0 : m.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: F ? void 0 : this.maxlength, minlength: F ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 0);
  }, onInput: (O) => {
    this.handleInput(O, 0);
  }, onChange: (O) => {
    this.handleChange(O, 0);
  } })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? B("div", { class: `${s}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && Ii(A.suffix, (O) => O || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? B("div", { class: `${s}-input__suffix` }, [Ii(A["clear-icon-placeholder"], (V) => (this.clearable || V) && B(_g, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => V, icon: () => {
    var Y, W;
    return (W = (Y = this.$slots)["clear-icon"]) === null || W === void 0 ? void 0 : W.call(Y);
  } })), this.internalLoadingBeforeSuffix ? null : O, this.loading !== void 0 ? B(kb, { clsPrefix: s, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? O : null, this.showCount && this.type !== "textarea" ? B(fy, null, { default: (V) => {
    var Y;
    const { renderCount: W } = this;
    return W ? W(V) : (Y = A.count) === null || Y === void 0 ? void 0 : Y.call(A, V);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? B("div", { class: `${s}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Kn(A["password-visible-icon"], () => [B(Wr, { clsPrefix: s }, { default: () => B(Cb, null) })]) : Kn(A["password-invisible-icon"], () => [B(Wr, { clsPrefix: s }, { default: () => B(sk, null) })])) : null]) : null)), this.pair ? B("span", { class: `${s}-input__separator` }, Kn(A.separator, () => [this.separator])) : null, this.pair ? B("div", { class: `${s}-input-wrapper` }, B("div", { class: `${s}-input__input` }, B("input", { ref: "inputEl2Ref", type: this.type, class: `${s}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: F ? void 0 : this.maxlength, minlength: F ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 1);
  }, onInput: (O) => {
    this.handleInput(O, 1);
  }, onChange: (O) => {
    this.handleChange(O, 1);
  } }), this.showPlaceholder2 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[1])) : null), Ii(A.suffix, (O) => (this.clearable || O) && B("div", { class: `${s}-input__suffix` }, [this.clearable && B(_g, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var V;
    return (V = A["clear-icon"]) === null || V === void 0 ? void 0 : V.call(A);
  }, placeholder: () => {
    var V;
    return (V = A["clear-icon-placeholder"]) === null || V === void 0 ? void 0 : V.call(A);
  } }), O]))) : null, this.mergedBordered ? B("div", { class: `${s}-input__border` }) : null, this.mergedBordered ? B("div", { class: `${s}-input__state-border` }) : null, this.showCount && M === "textarea" ? B(fy, null, { default: (O) => {
    var V;
    const { renderCount: Y } = this;
    return Y ? Y(O) : (V = A.count) === null || V === void 0 ? void 0 : V.call(A, O);
  } }) : null);
} }), $k = ce("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [Ge(">", [ce("input", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), ce("button", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Fe("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Fe("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), Ge("*", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ge(">", [ce("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ce("base-selection", [ce("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ce("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Fe("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), Ge("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ge(">", [ce("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ce("base-selection", [ce("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ce("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Fe("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), jk = {}, Nk = ot({ name: "InputGroup", props: jk, setup(r) {
  const { mergedClsPrefixRef: i } = Mr(r);
  return cc("-input-group", $k, i), { mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: `${r}-input-group` }, this.$slots);
} });
function Hf(r) {
  return r.type === "group";
}
function Ib(r) {
  return r.type === "ignored";
}
function Lm(r, i) {
  try {
    return !!(1 + i.toString().toLowerCase().indexOf(r.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function Vk(r, i) {
  return { getIsGroup: Hf, getIgnored: Ib, getKey(d) {
    return Hf(d) ? d.name || d.key || "key-required" : d[r];
  }, getChildren(d) {
    return d[i];
  } };
}
function Uk(r, i, l, d) {
  if (!i) return r;
  function f(g) {
    if (!Array.isArray(g)) return [];
    const m = [];
    for (const s of g) if (Hf(s)) {
      const C = f(s[d]);
      C.length && m.push(Object.assign({}, s, { [d]: C }));
    } else {
      if (Ib(s)) continue;
      i(l, s) && m.push(s);
    }
    return m;
  }
  return f(r);
}
function qk(r, i, l) {
  const d = /* @__PURE__ */ new Map();
  return r.forEach((f) => {
    Hf(f) ? f[l].forEach((g) => {
      d.set(g[i], g);
    }) : d.set(f[i], f);
  }), d;
}
const Gk = op && "loading" in document.createElement("img");
function Wk(r = {}) {
  var i;
  const { root: l = null } = r;
  return { hash: `${r.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(r.threshold) ? r.threshold.join(",") : (i = r.threshold) !== null && i !== void 0 ? i : "0"}`, options: Object.assign(Object.assign({}, r), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const Bm = /* @__PURE__ */ new WeakMap(), Om = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), Zk = (r, i, l) => {
  if (!r) return () => {
  };
  const d = Wk(i), { root: f } = d.options;
  let g;
  const m = Bm.get(f);
  m ? g = m : (g = /* @__PURE__ */ new Map(), Bm.set(f, g));
  let s, C;
  g.has(d.hash) ? (C = g.get(d.hash), C[1].has(r) || (s = C[0], C[1].add(r), s.observe(r))) : (s = new IntersectionObserver((F) => {
    F.forEach((D) => {
      if (D.isIntersecting) {
        const A = Om.get(D.target), O = $m.get(D.target);
        A && A(), O && (O.value = true);
      }
    });
  }, d.options), s.observe(r), C = [s, /* @__PURE__ */ new Set([r])], g.set(d.hash, C));
  let P = false;
  const M = () => {
    P || (Om.delete(r), $m.delete(r), P = true, C[1].has(r) && (C[0].unobserve(r), C[1].delete(r)), C[1].size <= 0 && g.delete(d.hash), g.size || Bm.delete(f));
  };
  return Om.set(r, M), $m.set(r, l), M;
}, Ti = "0!important", Mb = "-1px!important";
function qu(r) {
  return Ue(`${r}-type`, [Ge("& +", [ce("button", {}, [Ue(`${r}-type`, [Fe("border", { borderLeftWidth: Ti }), Fe("state-border", { left: Mb })])])])]);
}
function Gu(r) {
  return Ue(`${r}-type`, [Ge("& +", [ce("button", [Ue(`${r}-type`, [Fe("border", { borderTopWidth: Ti }), Fe("state-border", { top: Mb })])])])]);
}
const Hk = ce("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [pi("vertical", { flexDirection: "row" }, [pi("rtl", [ce("button", [Ge("&:first-child:not(:last-child)", `
 margin-right: ${Ti};
 border-top-right-radius: ${Ti};
 border-bottom-right-radius: ${Ti};
 `), Ge("&:last-child:not(:first-child)", `
 margin-left: ${Ti};
 border-top-left-radius: ${Ti};
 border-bottom-left-radius: ${Ti};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-radius: ${Ti};
 `), qu("default"), Ue("ghost", [qu("primary"), qu("info"), qu("success"), qu("warning"), qu("error")])])])]), Ue("vertical", { flexDirection: "column" }, [ce("button", [Ge("&:first-child:not(:last-child)", `
 margin-bottom: ${Ti};
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-bottom-left-radius: ${Ti};
 border-bottom-right-radius: ${Ti};
 `), Ge("&:last-child:not(:first-child)", `
 margin-top: ${Ti};
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-top-left-radius: ${Ti};
 border-top-right-radius: ${Ti};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin: ${Ti};
 border-radius: ${Ti};
 `), Gu("default"), Ue("ghost", [Gu("primary"), Gu("info"), Gu("success"), Gu("warning"), Gu("error")])])])]), Xk = { size: { type: String, default: void 0 }, vertical: Boolean }, Yk = ot({ name: "ButtonGroup", props: Xk, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Mr(r);
  return cc("-button-group", Hk, i), Zr(S2, r), { rtlEnabled: Un("ButtonGroup", l, i), mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: [`${r}-button-group`, this.rtlEnabled && `${r}-button-group--rtl`, this.vertical && `${r}-button-group--vertical`], role: "group" }, this.$slots);
} }), Kk = Rn("n-checkbox-group"), Jk = () => B("svg", { viewBox: "0 0 64 64", class: "check-icon" }, B("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), Qk = () => B("svg", { viewBox: "0 0 100 100", class: "line-icon" }, B("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), eP = Ge([ce("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ue("show-label", "line-height: var(--n-label-line-height);"), Ge("&:hover", [ce("checkbox-box", [Fe("border", "border: var(--n-border-checked);")])]), Ge("&:focus:not(:active)", [ce("checkbox-box", [Fe("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ue("inside-table", [ce("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ue("checked", [ce("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [ce("checkbox-icon", [Ge(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("indeterminate", [ce("checkbox-box", [ce("checkbox-icon", [Ge(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), Ge(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("checked, indeterminate", [Ge("&:focus:not(:active)", [ce("checkbox-box", [Fe("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), ce("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Fe("border", { border: "var(--n-border-checked)" })])]), Ue("disabled", { cursor: "not-allowed" }, [Ue("checked", [ce("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Fe("border", { border: "var(--n-border-disabled-checked)" }), ce("checkbox-icon", [Ge(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), ce("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Fe("border", `
 border: var(--n-border-disabled);
 `), ce("checkbox-icon", [Ge(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Fe("label", `
 color: var(--n-text-color-disabled);
 `)]), ce("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), ce("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Fe("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), ce("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [Ge(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Nd({ left: "1px", top: "1px" })])]), Fe("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [Ge("&:empty", { display: "none" })])]), A_(ce("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), D_(ce("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), tP = Object.assign(Object.assign({}, rr.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), rP = ot({ name: "Checkbox", props: tP, setup(r) {
  const i = pr(Kk, null), l = Re(null), { mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Mr(r), m = Re(r.defaultChecked), s = Bt(r, "checked"), C = Hi(s, m), P = yi(() => {
    if (i) {
      const X = i.valueSetRef.value;
      return X && r.value !== void 0 ? X.has(r.value) : false;
    } else return C.value === r.checkedValue;
  }), M = ya(r, { mergedSize(X) {
    const { size: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      const { value: pe } = i.mergedSizeRef;
      if (pe !== void 0) return pe;
    }
    if (X) {
      const { mergedSize: pe } = X;
      if (pe !== void 0) return pe.value;
    }
    return "medium";
  }, mergedDisabled(X) {
    const { disabled: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      if (i.disabledRef.value) return true;
      const { maxRef: { value: pe }, checkedCountRef: oe } = i;
      if (pe !== void 0 && oe.value >= pe && !P.value) return true;
      const { minRef: { value: fe } } = i;
      if (fe !== void 0 && oe.value <= fe && P.value) return true;
    }
    return X ? X.disabled.value : false;
  } }), { mergedDisabledRef: F, mergedSizeRef: D } = M, A = rr("Checkbox", "-checkbox", eP, k2, r, d);
  function O(X) {
    if (i && r.value !== void 0) i.toggleCheckbox(!P.value, r.value);
    else {
      const { onChange: Se, "onUpdate:checked": pe, onUpdateChecked: oe } = r, { nTriggerFormInput: fe, nTriggerFormChange: _e } = M, qe = P.value ? r.uncheckedValue : r.checkedValue;
      pe && jt(pe, qe, X), oe && jt(oe, qe, X), Se && jt(Se, qe, X), fe(), _e(), m.value = qe;
    }
  }
  function V(X) {
    F.value || O(X);
  }
  function Y(X) {
    if (!F.value) switch (X.key) {
      case " ":
      case "Enter":
        O(X);
    }
  }
  function W(X) {
    switch (X.key) {
      case " ":
        X.preventDefault();
    }
  }
  const ee = { focus: () => {
    var X;
    (X = l.value) === null || X === void 0 || X.focus();
  }, blur: () => {
    var X;
    (X = l.value) === null || X === void 0 || X.blur();
  } }, ie = Un("Checkbox", g, d), te = Me(() => {
    const { value: X } = D, { common: { cubicBezierEaseInOut: Se }, self: { borderRadius: pe, color: oe, colorChecked: fe, colorDisabled: _e, colorTableHeader: qe, colorTableHeaderModal: Ve, colorTableHeaderPopover: Qe, checkMarkColor: ut, checkMarkColorDisabled: gt, border: yt, borderFocus: lt, borderDisabled: et, borderChecked: dt, boxShadowFocus: Ft, textColor: ft, textColorDisabled: _t, checkMarkColorDisabledChecked: $t, colorDisabledChecked: Qt, borderDisabledChecked: Lt, labelPadding: zt, labelLineHeight: It, labelFontWeight: At, [Jt("fontSize", X)]: mr, [Jt("size", X)]: gr } } = A.value;
    return { "--n-label-line-height": It, "--n-label-font-weight": At, "--n-size": gr, "--n-bezier": Se, "--n-border-radius": pe, "--n-border": yt, "--n-border-checked": dt, "--n-border-focus": lt, "--n-border-disabled": et, "--n-border-disabled-checked": Lt, "--n-box-shadow-focus": Ft, "--n-color": oe, "--n-color-checked": fe, "--n-color-table": qe, "--n-color-table-modal": Ve, "--n-color-table-popover": Qe, "--n-color-disabled": _e, "--n-color-disabled-checked": Qt, "--n-text-color": ft, "--n-text-color-disabled": _t, "--n-check-mark-color": ut, "--n-check-mark-color-disabled": gt, "--n-check-mark-color-disabled-checked": $t, "--n-font-size": mr, "--n-label-padding": zt };
  }), re = f ? bi("checkbox", Me(() => D.value[0]), te, r) : void 0;
  return Object.assign(M, ee, { rtlEnabled: ie, selfRef: l, mergedClsPrefix: d, mergedDisabled: F, renderedChecked: P, mergedTheme: A, labelId: Dl(), handleClick: V, handleKeyUp: Y, handleKeyDown: W, cssVars: f ? void 0 : te, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender });
}, render() {
  var r;
  const { $slots: i, renderedChecked: l, mergedDisabled: d, indeterminate: f, privateInsideTable: g, cssVars: m, labelId: s, label: C, mergedClsPrefix: P, focusable: M, handleKeyUp: F, handleKeyDown: D, handleClick: A } = this;
  (r = this.onRender) === null || r === void 0 || r.call(this);
  const O = Ii(i.default, (V) => C || V ? B("span", { class: `${P}-checkbox__label`, id: s }, C || V) : null);
  return B("div", { ref: "selfRef", class: [`${P}-checkbox`, this.themeClass, this.rtlEnabled && `${P}-checkbox--rtl`, l && `${P}-checkbox--checked`, d && `${P}-checkbox--disabled`, f && `${P}-checkbox--indeterminate`, g && `${P}-checkbox--inside-table`, O && `${P}-checkbox--show-label`], tabindex: d || !M ? void 0 : 0, role: "checkbox", "aria-checked": f ? "mixed" : l, "aria-labelledby": s, style: m, onKeyup: F, onKeydown: D, onClick: A, onMousedown: () => {
    En("selectstart", window, (V) => {
      V.preventDefault();
    }, { once: true });
  } }, B("div", { class: `${P}-checkbox-box-wrapper` }, "\xA0", B("div", { class: `${P}-checkbox-box` }, B(rp, null, { default: () => this.indeterminate ? B("div", { key: "indeterminate", class: `${P}-checkbox-icon` }, Qk()) : B("div", { key: "check", class: `${P}-checkbox-icon` }, Jk()) }), B("div", { class: `${P}-checkbox-box__border` }))), O);
} }), iP = ce("collapse", "width: 100%;", [ce("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ue("disabled", [Fe("header", "cursor: not-allowed;", [Fe("header-main", `
 color: var(--n-title-text-color-disabled);
 `), ce("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), ce("collapse-item", "margin-left: 32px;"), Ge("&:first-child", "margin-top: 0;"), Ge("&:first-child >", [Fe("header", "padding-top: 0;")]), Ue("left-arrow-placement", [Fe("header", [ce("collapse-item-arrow", "margin-right: 4px;")])]), Ue("right-arrow-placement", [Fe("header", [ce("collapse-item-arrow", "margin-left: 4px;")])]), Fe("content-wrapper", [Fe("content-inner", "padding-top: 16px;"), cg({ duration: "0.15s" })]), Ue("active", [Fe("header", [Ue("active", [ce("collapse-item-arrow", "transform: rotate(90deg);")])])]), Ge("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), pi("disabled", [Ue("trigger-area-main", [Fe("header", [Fe("header-main", "cursor: pointer;"), ce("collapse-item-arrow", "cursor: default;")])]), Ue("trigger-area-arrow", [Fe("header", [ce("collapse-item-arrow", "cursor: pointer;")])]), Ue("trigger-area-extra", [Fe("header", [Fe("header-extra", "cursor: pointer;")])])]), Fe("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Fe("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Fe("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), ce("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), nP = Object.assign(Object.assign({}, rr.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), Eb = Rn("n-collapse"), py = ot({ name: "Collapse", props: nP, slots: Object, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Mr(r), g = Re(r.defaultExpandedNames), m = Me(() => r.expandedNames), s = Hi(m, g), C = rr("Collapse", "-collapse", iP, P2, r, l);
  function P(V) {
    const { "onUpdate:expandedNames": Y, onUpdateExpandedNames: W, onExpandedNamesChange: ee } = r;
    W && jt(W, V), Y && jt(Y, V), ee && jt(ee, V), g.value = V;
  }
  function M(V) {
    const { onItemHeaderClick: Y } = r;
    Y && jt(Y, V);
  }
  function F(V, Y, W) {
    const { accordion: ee } = r, { value: ie } = s;
    if (ee) V ? (P([Y]), M({ name: Y, expanded: true, event: W })) : (P([]), M({ name: Y, expanded: false, event: W }));
    else if (!Array.isArray(ie)) P([Y]), M({ name: Y, expanded: true, event: W });
    else {
      const te = ie.slice(), re = te.findIndex((X) => Y === X);
      ~re ? (te.splice(re, 1), P(te), M({ name: Y, expanded: false, event: W })) : (te.push(Y), P(te), M({ name: Y, expanded: true, event: W }));
    }
  }
  Zr(Eb, { props: r, mergedClsPrefixRef: l, expandedNamesRef: s, slots: i, toggleItem: F });
  const D = Un("Collapse", f, l), A = Me(() => {
    const { common: { cubicBezierEaseInOut: V }, self: { titleFontWeight: Y, dividerColor: W, titlePadding: ee, titleTextColor: ie, titleTextColorDisabled: te, textColor: re, arrowColor: X, fontSize: Se, titleFontSize: pe, arrowColorDisabled: oe, itemMargin: fe } } = C.value;
    return { "--n-font-size": Se, "--n-bezier": V, "--n-text-color": re, "--n-divider-color": W, "--n-title-padding": ee, "--n-title-font-size": pe, "--n-title-text-color": ie, "--n-title-text-color-disabled": te, "--n-title-font-weight": Y, "--n-arrow-color": X, "--n-arrow-color-disabled": oe, "--n-item-margin": fe };
  }), O = d ? bi("collapse", void 0, A, r) : void 0;
  return { rtlEnabled: D, mergedTheme: C, mergedClsPrefix: l, cssVars: d ? void 0 : A, themeClass: O == null ? void 0 : O.themeClass, onRender: O == null ? void 0 : O.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), oP = ot({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(r) {
  return { onceTrue: T2(Bt(r, "show")) };
}, render() {
  return B(qg, null, { default: () => {
    const { show: r, displayDirective: i, onceTrue: l, clsPrefix: d } = this, f = i === "show" && l, g = B("div", { class: `${d}-collapse-item__content-wrapper` }, B("div", { class: `${d}-collapse-item__content-inner` }, this.$slots));
    return f ? ga(g, [[Qa, r]]) : r ? g : null;
  } });
} }), aP = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, my = ot({ name: "CollapseItem", props: aP, setup(r) {
  const { mergedRtlRef: i } = Mr(r), l = Dl(), d = yi(() => {
    var F;
    return (F = r.name) !== null && F !== void 0 ? F : l;
  }), f = pr(Eb);
  f || Xo("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: g, props: m, mergedClsPrefixRef: s, slots: C } = f, P = Me(() => {
    const { value: F } = g;
    if (Array.isArray(F)) {
      const { value: D } = d;
      return !~F.findIndex((A) => A === D);
    } else if (F) {
      const { value: D } = d;
      return D !== F;
    }
    return true;
  });
  return { rtlEnabled: Un("Collapse", i, s), collapseSlots: C, randomName: l, mergedClsPrefix: s, collapsed: P, triggerAreas: Bt(m, "triggerAreas"), mergedDisplayDirective: Me(() => {
    const { displayDirective: F } = r;
    return F || m.displayDirective;
  }), arrowPlacement: Me(() => m.arrowPlacement), handleClick(F) {
    let D = "main";
    Tl(F, "arrow") && (D = "arrow"), Tl(F, "extra") && (D = "extra"), m.triggerAreas.includes(D) && f && !r.disabled && f.toggleItem(P.value, d.value, F);
  } };
}, render() {
  const { collapseSlots: r, $slots: i, arrowPlacement: l, collapsed: d, mergedDisplayDirective: f, mergedClsPrefix: g, disabled: m, triggerAreas: s } = this, C = ug(i.header, { collapsed: d }, () => [this.title]), P = i["header-extra"] || r["header-extra"], M = i.arrow || r.arrow;
  return B("div", { class: [`${g}-collapse-item`, `${g}-collapse-item--${l}-arrow-placement`, m && `${g}-collapse-item--disabled`, !d && `${g}-collapse-item--active`, s.map((F) => `${g}-collapse-item--trigger-area-${F}`)] }, B("div", { class: [`${g}-collapse-item__header`, !d && `${g}-collapse-item__header--active`] }, B("div", { class: `${g}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && C, B("div", { class: `${g}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, ug(M, { collapsed: d }, () => [B(Wr, { clsPrefix: g }, { default: () => this.rtlEnabled ? B(nk, null) : B(I2, null) })])), l === "left" && C), M2(P, { collapsed: d }, (F) => B("div", { class: `${g}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, F))), B(oP, { clsPrefix: g, displayDirective: f, show: !d }, i));
} });
function sP(r, i) {
  switch (r[0]) {
    case "hex":
      return i ? "#000000FF" : "#000000";
    case "rgb":
      return i ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return i ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return i ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function Gd(r) {
  return r === null ? null : /^ *#/.test(r) ? "hex" : r.includes("rgb") ? "rgb" : r.includes("hsl") ? "hsl" : r.includes("hsv") ? "hsv" : null;
}
function lP(r, i = [255, 255, 255], l = "AA") {
  const [d, f, g, m] = Go(Ka(r));
  if (m === 1) {
    const A = wf([d, f, g]), O = wf(i);
    return (Math.max(A, O) + 0.05) / (Math.min(A, O) + 0.05) >= (l === "AA" ? 4.5 : 7);
  }
  const s = Math.round(d * m + i[0] * (1 - m)), C = Math.round(f * m + i[1] * (1 - m)), P = Math.round(g * m + i[2] * (1 - m)), M = wf([s, C, P]), F = wf(i);
  return (Math.max(M, F) + 0.05) / (Math.min(M, F) + 0.05) >= (l === "AA" ? 4.5 : 7);
}
function wf(r) {
  const [i, l, d] = r.map((f) => (f /= 255, f <= 0.03928 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4)));
  return 0.2126 * i + 0.7152 * l + 0.0722 * d;
}
function uP(r) {
  return r = Math.round(r), r >= 360 ? 359 : r < 0 ? 0 : r;
}
function cP(r) {
  return r = Math.round(r * 100) / 100, r > 1 ? 1 : r < 0 ? 0 : r;
}
const dP = { rgb: { hex(r) {
  return ws(Go(r));
}, hsl(r) {
  const [i, l, d, f] = Go(r);
  return Ka([...fg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Go(r);
  return Ml([...hg(i, l, d), f]);
} }, hex: { rgb(r) {
  return Ja(Go(r));
}, hsl(r) {
  const [i, l, d, f] = Go(r);
  return Ka([...fg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Go(r);
  return Ml([...hg(i, l, d), f]);
} }, hsl: { hex(r) {
  const [i, l, d, f] = Qu(r);
  return ws([...dg(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Qu(r);
  return Ja([...dg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Qu(r);
  return Ml([...z_(i, l, d), f]);
} }, hsv: { hex(r) {
  const [i, l, d, f] = Il(r);
  return ws([..._s(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Il(r);
  return Ja([..._s(i, l, d), f]);
}, hsl(r) {
  const [i, l, d, f] = Il(r);
  return Ka([...Bf(i, l, d), f]);
} } };
function Rb(r, i, l) {
  return l = l || Gd(r), l ? l === i ? r : dP[l][i](r) : null;
}
const Td = "12px", hP = 12, _l = "6px", fP = ot({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Re(null);
  function l(g) {
    !i.value || !r.rgba || (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), P = (g.clientX - C) / (s - hP);
    r.onUpdateAlpha(cP(P));
  }
  function f() {
    var g;
    Xn("mousemove", document, d), Xn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, railBackgroundImage: Me(() => {
    const { rgba: g } = r;
    return g ? `linear-gradient(to right, rgba(${g[0]}, ${g[1]}, ${g[2]}, 0) 0%, rgba(${g[0]}, ${g[1]}, ${g[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, ref: "railRef", style: { height: Td, borderRadius: _l }, onMousedown: this.handleMouseDown }, B("div", { style: { borderRadius: _l, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, B("div", { class: `${r}-color-picker-checkboard` }), B("div", { class: `${r}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && B("div", { style: { position: "absolute", left: _l, right: _l, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${_l})`, borderRadius: _l, width: Td, height: Td } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: Ja(this.rgba), borderRadius: _l, width: Td, height: Td } }))));
} }), Kg = Rn("n-color-picker");
function pP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 255)) : false;
}
function mP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 360)) : false;
}
function gP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 100)) : false;
}
function vP(r) {
  const i = r.trim();
  return /^#[0-9a-fA-F]+$/.test(i) ? [4, 5, 7, 9].includes(i.length) : false;
}
function yP(r) {
  return /^\d{1,3}\.?\d*%$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r) / 100, 100)) : false;
}
const _P = { paddingSmall: "0 4px" }, gy = ot({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(r) {
  const i = Re(""), { themeRef: l } = pr(Kg, null);
  vo(() => {
    i.value = d();
  });
  function d() {
    const { value: m } = r;
    if (m === null) return "";
    const { label: s } = r;
    return s === "HEX" ? m : s === "A" ? `${Math.floor(m * 100)}%` : String(Math.floor(m));
  }
  function f(m) {
    i.value = m;
  }
  function g(m) {
    let s, C;
    switch (r.label) {
      case "HEX":
        C = vP(m), C && r.onUpdateValue(m), i.value = d();
        break;
      case "H":
        s = mP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "S":
      case "L":
      case "V":
        s = gP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "A":
        s = yP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "R":
      case "G":
      case "B":
        s = pP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
    }
  }
  return { mergedTheme: l, inputValue: i, handleInputChange: g, handleInputUpdateValue: f };
}, render() {
  const { mergedTheme: r } = this;
  return B(mo, { size: "small", placeholder: this.label, theme: r.peers.Input, themeOverrides: r.peerOverrides.Input, builtinThemeOverrides: _P, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), bP = ot({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(r) {
  return { handleUnitUpdateValue(i, l) {
    const { showAlpha: d } = r;
    if (r.mode === "hex") {
      r.onUpdateValue((d ? ws : Fd)(l));
      return;
    }
    let f;
    switch (r.valueArr === null ? f = [0, 0, 0, 0] : f = Array.from(r.valueArr), r.mode) {
      case "hsv":
        f[i] = l, r.onUpdateValue((d ? Ml : gg)(f));
        break;
      case "rgb":
        f[i] = l, r.onUpdateValue((d ? Ja : mg)(f));
        break;
      case "hsl":
        f[i] = l, r.onUpdateValue((d ? Ka : pg)(f));
        break;
    }
  } };
}, render() {
  const { clsPrefix: r, modes: i } = this;
  return B("div", { class: `${r}-color-picker-input` }, B("div", { class: `${r}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: i.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), B(Nk, null, { default: () => {
    const { mode: l, valueArr: d, showAlpha: f } = this;
    if (l === "hex") {
      let g = null;
      try {
        g = d === null ? null : (f ? ws : Fd)(d);
      } catch {
      }
      return B(gy, { label: "HEX", showAlpha: f, value: g, onUpdateValue: (m) => {
        this.handleUnitUpdateValue(0, m);
      } });
    }
    return (l + (f ? "a" : "")).split("").map((g, m) => B(gy, { label: g.toUpperCase(), value: d === null ? null : d[m], onUpdateValue: (s) => {
      this.handleUnitUpdateValue(m, s);
    } }));
  } }));
} });
function xP(r, i) {
  if (i === "hsv") {
    const [l, d, f, g] = Il(r);
    return Ja([..._s(l, d, f), g]);
  }
  return r;
}
function wP(r) {
  const i = document.createElement("canvas").getContext("2d");
  return i ? (i.fillStyle = r, i.fillStyle) : "#000000";
}
const CP = ot({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  const i = Me(() => r.swatches.map((g) => {
    const m = Gd(g);
    return { value: g, mode: m, legalValue: xP(g, m) };
  }));
  function l(g) {
    const { mode: m } = r;
    let { value: s, mode: C } = g;
    return C || (C = "hex", /^[a-zA-Z]+$/.test(s) ? s = wP(s) : (qf("color-picker", `color ${s} in swatches is invalid.`), s = "#000000")), C === m ? s : Rb(s, m, C);
  }
  function d(g) {
    r.onUpdateColor(l(g));
  }
  function f(g, m) {
    g.key === "Enter" && d(m);
  }
  return { parsedSwatchesRef: i, handleSwatchSelect: d, handleSwatchKeyDown: f };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-swatches` }, this.parsedSwatchesRef.map((i) => B("div", { class: `${r}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(i);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, i);
  } }, B("div", { class: `${r}-color-picker-swatch__fill`, style: { background: i.legalValue } }))));
} }), SP = ot({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(r) {
  const { colorPickerSlots: i, renderLabelRef: l } = pr(Kg, null);
  return () => {
    const { hsla: d, value: f, clsPrefix: g, onClick: m, disabled: s } = r, C = i.label || l.value;
    return B("div", { class: [`${g}-color-picker-trigger`, s && `${g}-color-picker-trigger--disabled`], onClick: s ? void 0 : m }, B("div", { class: `${g}-color-picker-trigger__fill` }, B("div", { class: `${g}-color-picker-checkboard` }), B("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: d ? Ka(d) : "" } }), f && d ? B("div", { class: `${g}-color-picker-trigger__value`, style: { color: lP(d) ? "white" : "black" } }, C ? C(f) : f) : null));
  };
} }), kP = ot({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (r) => {
  const i = Gd(r);
  return !!(!r || i && i !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  function i(l) {
    var d;
    const f = l.target.value;
    (d = r.onUpdateColor) === null || d === void 0 || d.call(r, Rb(f.toUpperCase(), r.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: i };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-preview__preview` }, B("span", { class: `${r}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), B("input", { class: `${r}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), Wu = "12px", PP = 12, bl = "6px", TP = 6, IP = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", MP = ot({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Re(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), P = uP((g.clientX - C - TP) / (s - PP) * 360);
    r.onUpdateHue(P);
  }
  function f() {
    var g;
    Xn("mousemove", document, d), Xn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, style: { height: Wu, borderRadius: bl } }, B("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: IP, height: Wu, borderRadius: bl, position: "relative" }, onMousedown: this.handleMouseDown }, B("div", { style: { position: "absolute", left: bl, right: bl, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${bl})`, borderRadius: bl, width: Wu, height: Wu } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: bl, width: Wu, height: Wu } })))));
} }), Cf = "12px", Sf = "6px", EP = ot({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Re(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, height: C, left: P, bottom: M } = m.getBoundingClientRect(), F = (M - g.clientY) / C, D = (g.clientX - P) / s, A = 100 * (D > 1 ? 1 : D < 0 ? 0 : D), O = 100 * (F > 1 ? 1 : F < 0 ? 0 : F);
    r.onUpdateSV(A, O);
  }
  function f() {
    var g;
    Xn("mousemove", document, d), Xn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { palleteRef: i, handleColor: Me(() => {
    const { rgba: g } = r;
    return g ? `rgb(${g[0]}, ${g[1]}, ${g[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, B("div", { class: `${r}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), B("div", { class: `${r}-color-picker-pallete__layer ${r}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && B("div", { class: `${r}-color-picker-handle`, style: { width: Cf, height: Cf, borderRadius: Sf, left: `calc(${this.displayedSv[0]}% - ${Sf})`, bottom: `calc(${this.displayedSv[1]}% - ${Sf})` } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: Sf, width: Cf, height: Cf } })));
} }), RP = Ge([ce("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), ce("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [ip(), ce("input", `
 text-align: center;
 `)]), ce("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ge("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), ce("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Fe("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), Ge("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), ce("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Fe("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), ce("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Fe("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), ce("color-picker-preview", `
 display: flex;
 `, [Fe("sliders", `
 flex: 1 0 auto;
 `), Fe("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Fe("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Fe("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), ce("color-picker-input", `
 display: flex;
 align-items: center;
 `, [ce("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Fe("mode", `
 width: 72px;
 text-align: center;
 `)]), ce("color-picker-control", `
 padding: 12px;
 `), ce("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [ce("button", "margin-left: 8px;")]), ce("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Fe("value", `
 white-space: nowrap;
 position: relative;
 `), Fe("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ue("disabled", "cursor: not-allowed"), ce("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [Ge("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), ce("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [ce("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Fe("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), Ge("&:focus", `
 outline: none;
 `, [Fe("fill", [Ge("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), AP = Object.assign(Object.assign({}, rr.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: ic.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), jm = ot({ name: "ColorPicker", props: AP, slots: Object, setup(r, { slots: i }) {
  const l = Re(null);
  let d = null;
  const f = ya(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, { localeRef: s } = ts("global"), { mergedClsPrefixRef: C, namespaceRef: P, inlineThemeDisabled: M } = Mr(r), F = rr("ColorPicker", "-color-picker", RP, E2, r, C);
  Zr(Kg, { themeRef: F, renderLabelRef: Bt(r, "renderLabel"), colorPickerSlots: i });
  const D = Re(r.defaultShow), A = Hi(Bt(r, "show"), D);
  function O(Ee) {
    const { onUpdateShow: nt, "onUpdate:show": Be } = r;
    nt && jt(nt, Ee), Be && jt(Be, Ee), D.value = Ee;
  }
  const { defaultValue: V } = r, Y = Re(V === void 0 ? sP(r.modes, r.showAlpha) : V), W = Hi(Bt(r, "value"), Y), ee = Re([W.value]), ie = Re(0), te = Me(() => Gd(W.value)), { modes: re } = r, X = Re(Gd(W.value) || re[0] || "rgb");
  function Se() {
    const { modes: Ee } = r, { value: nt } = X, Be = Ee.findIndex((Ye) => Ye === nt);
    ~Be ? X.value = Ee[(Be + 1) % Ee.length] : X.value = "rgb";
  }
  let pe, oe, fe, _e, qe, Ve, Qe, ut;
  const gt = Me(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (te.value) {
      case "hsv":
        return Il(Ee);
      case "hsl":
        return [pe, oe, fe, ut] = Qu(Ee), [...z_(pe, oe, fe), ut];
      case "rgb":
      case "hex":
        return [qe, Ve, Qe, ut] = Go(Ee), [...hg(qe, Ve, Qe), ut];
    }
  }), yt = Me(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (te.value) {
      case "rgb":
      case "hex":
        return Go(Ee);
      case "hsv":
        return [pe, oe, _e, ut] = Il(Ee), [..._s(pe, oe, _e), ut];
      case "hsl":
        return [pe, oe, fe, ut] = Qu(Ee), [...dg(pe, oe, fe), ut];
    }
  }), lt = Me(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (te.value) {
      case "hsl":
        return Qu(Ee);
      case "hsv":
        return [pe, oe, _e, ut] = Il(Ee), [...Bf(pe, oe, _e), ut];
      case "rgb":
      case "hex":
        return [qe, Ve, Qe, ut] = Go(Ee), [...fg(qe, Ve, Qe), ut];
    }
  }), et = Me(() => {
    switch (X.value) {
      case "rgb":
      case "hex":
        return yt.value;
      case "hsv":
        return gt.value;
      case "hsl":
        return lt.value;
    }
  }), dt = Re(0), Ft = Re(1), ft = Re([0, 0]);
  function _t(Ee, nt) {
    const { value: Be } = gt, Ye = dt.value, ht = Be ? Be[3] : 1;
    ft.value = [Ee, nt];
    const { showAlpha: bt } = r;
    switch (X.value) {
      case "hsv":
        Lt((bt ? Ml : gg)([Ye, Ee, nt, ht]), "cursor");
        break;
      case "hsl":
        Lt((bt ? Ka : pg)([...Bf(Ye, Ee, nt), ht]), "cursor");
        break;
      case "rgb":
        Lt((bt ? Ja : mg)([..._s(Ye, Ee, nt), ht]), "cursor");
        break;
      case "hex":
        Lt((bt ? ws : Fd)([..._s(Ye, Ee, nt), ht]), "cursor");
        break;
    }
  }
  function $t(Ee) {
    dt.value = Ee;
    const { value: nt } = gt;
    if (!nt) return;
    const [, Be, Ye, ht] = nt, { showAlpha: bt } = r;
    switch (X.value) {
      case "hsv":
        Lt((bt ? Ml : gg)([Ee, Be, Ye, ht]), "cursor");
        break;
      case "rgb":
        Lt((bt ? Ja : mg)([..._s(Ee, Be, Ye), ht]), "cursor");
        break;
      case "hex":
        Lt((bt ? ws : Fd)([..._s(Ee, Be, Ye), ht]), "cursor");
        break;
      case "hsl":
        Lt((bt ? Ka : pg)([...Bf(Ee, Be, Ye), ht]), "cursor");
        break;
    }
  }
  function Qt(Ee) {
    switch (X.value) {
      case "hsv":
        [pe, oe, _e] = gt.value, Lt(Ml([pe, oe, _e, Ee]), "cursor");
        break;
      case "rgb":
        [qe, Ve, Qe] = yt.value, Lt(Ja([qe, Ve, Qe, Ee]), "cursor");
        break;
      case "hex":
        [qe, Ve, Qe] = yt.value, Lt(ws([qe, Ve, Qe, Ee]), "cursor");
        break;
      case "hsl":
        [pe, oe, fe] = lt.value, Lt(Ka([pe, oe, fe, Ee]), "cursor");
        break;
    }
    Ft.value = Ee;
  }
  function Lt(Ee, nt) {
    nt === "cursor" ? d = Ee : d = null;
    const { nTriggerFormChange: Be, nTriggerFormInput: Ye } = f, { onUpdateValue: ht, "onUpdate:value": bt } = r;
    ht && jt(ht, Ee), bt && jt(bt, Ee), Be(), Ye(), Y.value = Ee;
  }
  function zt(Ee) {
    Lt(Ee, "input"), Vn(It);
  }
  function It(Ee = true) {
    const { value: nt } = W;
    if (nt) {
      const { nTriggerFormChange: Be, nTriggerFormInput: Ye } = f, { onComplete: ht } = r;
      ht && ht(nt);
      const { value: bt } = ee, { value: tt } = ie;
      Ee && (bt.splice(tt + 1, bt.length, nt), ie.value = tt + 1), Be(), Ye();
    }
  }
  function At() {
    const { value: Ee } = ie;
    Ee - 1 < 0 || (Lt(ee.value[Ee - 1], "input"), It(false), ie.value = Ee - 1);
  }
  function mr() {
    const { value: Ee } = ie;
    Ee < 0 || Ee + 1 >= ee.value.length || (Lt(ee.value[Ee + 1], "input"), It(false), ie.value = Ee + 1);
  }
  function gr() {
    Lt(null, "input");
    const { onClear: Ee } = r;
    Ee && Ee(), O(false);
  }
  function ir() {
    const { value: Ee } = W, { onConfirm: nt } = r;
    nt && nt(Ee), O(false);
  }
  const nr = Me(() => ie.value >= 1), Ut = Me(() => {
    const { value: Ee } = ee;
    return Ee.length > 1 && ie.value < Ee.length - 1;
  });
  Ht(A, (Ee) => {
    Ee || (ee.value = [W.value], ie.value = 0);
  }), vo(() => {
    if (!(d && d === W.value)) {
      const { value: Ee } = gt;
      Ee && (dt.value = Ee[0], Ft.value = Ee[3], ft.value = [Ee[1], Ee[2]]);
    }
    d = null;
  });
  const Ar = Me(() => {
    const { value: Ee } = g, { common: { cubicBezierEaseInOut: nt }, self: { textColor: Be, color: Ye, panelFontSize: ht, boxShadow: bt, border: tt, borderRadius: mt, dividerColor: Kt, [Jt("height", Ee)]: Qr, [Jt("fontSize", Ee)]: ki } } = F.value;
    return { "--n-bezier": nt, "--n-text-color": Be, "--n-color": Ye, "--n-panel-font-size": ht, "--n-font-size": ki, "--n-box-shadow": bt, "--n-border": tt, "--n-border-radius": mt, "--n-height": Qr, "--n-divider-color": Kt };
  }), wr = M ? bi("color-picker", Me(() => g.value[0]), Ar, r) : void 0;
  function Ct() {
    var Ee;
    const { value: nt } = yt, { value: Be } = dt, { internalActions: Ye, modes: ht, actions: bt } = r, { value: tt } = F, { value: mt } = C;
    return B("div", { class: [`${mt}-color-picker-panel`, wr == null ? void 0 : wr.themeClass.value], onDragstart: (Kt) => {
      Kt.preventDefault();
    }, style: M ? void 0 : Ar.value }, B("div", { class: `${mt}-color-picker-control` }, B(EP, { clsPrefix: mt, rgba: nt, displayedHue: Be, displayedSv: ft.value, onUpdateSV: _t, onComplete: It }), B("div", { class: `${mt}-color-picker-preview` }, B("div", { class: `${mt}-color-picker-preview__sliders` }, B(MP, { clsPrefix: mt, hue: Be, onUpdateHue: $t, onComplete: It }), r.showAlpha ? B(fP, { clsPrefix: mt, rgba: nt, alpha: Ft.value, onUpdateAlpha: Qt, onComplete: It }) : null), r.showPreview ? B(kP, { clsPrefix: mt, mode: X.value, color: yt.value && Fd(yt.value), onUpdateColor: (Kt) => {
      Lt(Kt, "input");
    } }) : null), B(bP, { clsPrefix: mt, showAlpha: r.showAlpha, mode: X.value, modes: ht, onUpdateMode: Se, value: W.value, valueArr: et.value, onUpdateValue: zt }), ((Ee = r.swatches) === null || Ee === void 0 ? void 0 : Ee.length) && B(CP, { clsPrefix: mt, mode: X.value, swatches: r.swatches, onUpdateColor: (Kt) => {
      Lt(Kt, "input");
    } })), (bt == null ? void 0 : bt.length) ? B("div", { class: `${mt}-color-picker-action` }, bt.includes("confirm") && B(Nr, { size: "small", onClick: ir, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.confirm }), bt.includes("clear") && B(Nr, { size: "small", onClick: gr, disabled: !W.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.clear })) : null, i.action ? B("div", { class: `${mt}-color-picker-action` }, { default: i.action }) : Ye ? B("div", { class: `${mt}-color-picker-action` }, Ye.includes("undo") && B(Nr, { size: "small", onClick: At, disabled: !nr.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.undo }), Ye.includes("redo") && B(Nr, { size: "small", onClick: mr, disabled: !Ut.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.redo })) : null);
  }
  return { mergedClsPrefix: C, namespace: P, selfRef: l, hsla: lt, rgba: yt, mergedShow: A, mergedDisabled: m, isMounted: ap(), adjustedTo: ic(r), mergedValue: W, handleTriggerClick() {
    O(true);
  }, handleClickOutside(Ee) {
    var nt;
    !((nt = l.value) === null || nt === void 0) && nt.contains(O_(Ee)) || O(false);
  }, renderPanel: Ct, cssVars: M ? void 0 : Ar, themeClass: wr == null ? void 0 : wr.themeClass, onRender: wr == null ? void 0 : wr.onRender };
}, render() {
  const { mergedClsPrefix: r, onRender: i } = this;
  return i == null ? void 0 : i(), B("div", { class: [this.themeClass, `${r}-color-picker`], ref: "selfRef", style: this.cssVars }, B(F_, null, { default: () => [B(L_, null, { default: () => B(SP, { clsPrefix: r, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), B(B_, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === ic.tdkey, to: this.adjustedTo }, { default: () => B(Io, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? ga(this.renderPanel(), [[Gf, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), DP = Ge([ce("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), ce("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [ip({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), zP = Object.assign(Object.assign({}, rr.props), { to: ic.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), bg = ot({ name: "Select", props: zP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, namespaceRef: d, inlineThemeDisabled: f } = Mr(r), g = rr("Select", "-select", DP, R2, r, i), m = Re(r.defaultValue), s = Bt(r, "value"), C = Hi(s, m), P = Re(false), M = Re(""), F = Wf(r, ["items", "options"]), D = Re([]), A = Re([]), O = Me(() => A.value.concat(D.value).concat(F.value)), V = Me(() => {
    const { filter: he } = r;
    if (he) return he;
    const { labelField: ve, valueField: je } = r;
    return (it, Xe) => {
      if (!Xe) return false;
      const xt = Xe[ve];
      if (typeof xt == "string") return Lm(it, xt);
      const Te = Xe[je];
      return typeof Te == "string" ? Lm(it, Te) : typeof Te == "number" ? Lm(it, String(Te)) : false;
    };
  }), Y = Me(() => {
    if (r.remote) return F.value;
    {
      const { value: he } = O, { value: ve } = M;
      return !ve.length || !r.filterable ? he : Uk(he, V.value, ve, r.childrenField);
    }
  }), W = Me(() => {
    const { valueField: he, childrenField: ve } = r, je = Vk(he, ve);
    return A2(Y.value, je);
  }), ee = Me(() => qk(O.value, r.valueField, r.childrenField)), ie = Re(false), te = Hi(Bt(r, "show"), ie), re = Re(null), X = Re(null), Se = Re(null), { localeRef: pe } = ts("Select"), oe = Me(() => {
    var he;
    return (he = r.placeholder) !== null && he !== void 0 ? he : pe.value.placeholder;
  }), fe = [], _e = Re(/* @__PURE__ */ new Map()), qe = Me(() => {
    const { fallbackOption: he } = r;
    if (he === void 0) {
      const { labelField: ve, valueField: je } = r;
      return (it) => ({ [ve]: String(it), [je]: it });
    }
    return he === false ? false : (ve) => Object.assign(he(ve), { value: ve });
  });
  function Ve(he) {
    const ve = r.remote, { value: je } = _e, { value: it } = ee, { value: Xe } = qe, xt = [];
    return he.forEach((Te) => {
      if (it.has(Te)) xt.push(it.get(Te));
      else if (ve && je.has(Te)) xt.push(je.get(Te));
      else if (Xe) {
        const Vt = Xe(Te);
        Vt && xt.push(Vt);
      }
    }), xt;
  }
  const Qe = Me(() => {
    if (r.multiple) {
      const { value: he } = C;
      return Array.isArray(he) ? Ve(he) : [];
    }
    return null;
  }), ut = Me(() => {
    const { value: he } = C;
    return !r.multiple && !Array.isArray(he) ? he === null ? null : Ve([he])[0] || null : null;
  }), gt = ya(r), { mergedSizeRef: yt, mergedDisabledRef: lt, mergedStatusRef: et } = gt;
  function dt(he, ve) {
    const { onChange: je, "onUpdate:value": it, onUpdateValue: Xe } = r, { nTriggerFormChange: xt, nTriggerFormInput: Te } = gt;
    je && jt(je, he, ve), Xe && jt(Xe, he, ve), it && jt(it, he, ve), m.value = he, xt(), Te();
  }
  function Ft(he) {
    const { onBlur: ve } = r, { nTriggerFormBlur: je } = gt;
    ve && jt(ve, he), je();
  }
  function ft() {
    const { onClear: he } = r;
    he && jt(he);
  }
  function _t(he) {
    const { onFocus: ve, showOnFocus: je } = r, { nTriggerFormFocus: it } = gt;
    ve && jt(ve, he), it(), je && It();
  }
  function $t(he) {
    const { onSearch: ve } = r;
    ve && jt(ve, he);
  }
  function Qt(he) {
    const { onScroll: ve } = r;
    ve && jt(ve, he);
  }
  function Lt() {
    var he;
    const { remote: ve, multiple: je } = r;
    if (ve) {
      const { value: it } = _e;
      if (je) {
        const { valueField: Xe } = r;
        (he = Qe.value) === null || he === void 0 || he.forEach((xt) => {
          it.set(xt[Xe], xt);
        });
      } else {
        const Xe = ut.value;
        Xe && it.set(Xe[r.valueField], Xe);
      }
    }
  }
  function zt(he) {
    const { onUpdateShow: ve, "onUpdate:show": je } = r;
    ve && jt(ve, he), je && jt(je, he), ie.value = he;
  }
  function It() {
    lt.value || (zt(true), ie.value = true, r.filterable && H());
  }
  function At() {
    zt(false);
  }
  function mr() {
    M.value = "", A.value = fe;
  }
  const gr = Re(false);
  function ir() {
    r.filterable && (gr.value = true);
  }
  function nr() {
    r.filterable && (gr.value = false, te.value || mr());
  }
  function Ut() {
    lt.value || (te.value ? r.filterable ? H() : At() : It());
  }
  function Ar(he) {
    var ve, je;
    !((je = (ve = Se.value) === null || ve === void 0 ? void 0 : ve.selfRef) === null || je === void 0) && je.contains(he.relatedTarget) || (P.value = false, Ft(he), At());
  }
  function wr(he) {
    _t(he), P.value = true;
  }
  function Ct() {
    P.value = true;
  }
  function Ee(he) {
    var ve;
    !((ve = re.value) === null || ve === void 0) && ve.$el.contains(he.relatedTarget) || (P.value = false, Ft(he), At());
  }
  function nt() {
    var he;
    (he = re.value) === null || he === void 0 || he.focus(), At();
  }
  function Be(he) {
    var ve;
    te.value && (!((ve = re.value) === null || ve === void 0) && ve.$el.contains(O_(he)) || At());
  }
  function Ye(he) {
    if (!Array.isArray(he)) return [];
    if (qe.value) return Array.from(he);
    {
      const { remote: ve } = r, { value: je } = ee;
      if (ve) {
        const { value: it } = _e;
        return he.filter((Xe) => je.has(Xe) || it.has(Xe));
      } else return he.filter((it) => je.has(it));
    }
  }
  function ht(he) {
    bt(he.rawNode);
  }
  function bt(he) {
    if (lt.value) return;
    const { tag: ve, remote: je, clearFilterAfterSelect: it, valueField: Xe } = r;
    if (ve && !je) {
      const { value: xt } = A, Te = xt[0] || null;
      if (Te) {
        const Vt = D.value;
        Vt.length ? Vt.push(Te) : D.value = [Te], A.value = fe;
      }
    }
    if (je && _e.value.set(he[Xe], he), r.multiple) {
      const xt = Ye(C.value), Te = xt.findIndex((Vt) => Vt === he[Xe]);
      if (~Te) {
        if (xt.splice(Te, 1), ve && !je) {
          const Vt = tt(he[Xe]);
          ~Vt && (D.value.splice(Vt, 1), it && (M.value = ""));
        }
      } else xt.push(he[Xe]), it && (M.value = "");
      dt(xt, Ve(xt));
    } else {
      if (ve && !je) {
        const xt = tt(he[Xe]);
        ~xt ? D.value = [D.value[xt]] : D.value = fe;
      }
      Z(), At(), dt(he[Xe], he);
    }
  }
  function tt(he) {
    return D.value.findIndex((je) => je[r.valueField] === he);
  }
  function mt(he) {
    te.value || It();
    const { value: ve } = he.target;
    M.value = ve;
    const { tag: je, remote: it } = r;
    if ($t(ve), je && !it) {
      if (!ve) {
        A.value = fe;
        return;
      }
      const { onCreate: Xe } = r, xt = Xe ? Xe(ve) : { [r.labelField]: ve, [r.valueField]: ve }, { valueField: Te, labelField: Vt } = r;
      F.value.some((or) => or[Te] === xt[Te] || or[Vt] === xt[Vt]) || D.value.some((or) => or[Te] === xt[Te] || or[Vt] === xt[Vt]) ? A.value = fe : A.value = [xt];
    }
  }
  function Kt(he) {
    he.stopPropagation();
    const { multiple: ve } = r;
    !ve && r.filterable && At(), ft(), ve ? dt([], []) : dt(null, null);
  }
  function Qr(he) {
    !Tl(he, "action") && !Tl(he, "empty") && !Tl(he, "header") && he.preventDefault();
  }
  function ki(he) {
    Qt(he);
  }
  function ze(he) {
    var ve, je, it, Xe, xt;
    if (!r.keyboard) {
      he.preventDefault();
      return;
    }
    switch (he.key) {
      case " ":
        if (r.filterable) break;
        he.preventDefault();
      case "Enter":
        if (!(!((ve = re.value) === null || ve === void 0) && ve.isComposing)) {
          if (te.value) {
            const Te = (je = Se.value) === null || je === void 0 ? void 0 : je.getPendingTmNode();
            Te ? ht(Te) : r.filterable || (At(), Z());
          } else if (It(), r.tag && gr.value) {
            const Te = A.value[0];
            if (Te) {
              const Vt = Te[r.valueField], { value: or } = C;
              r.multiple && Array.isArray(or) && or.includes(Vt) || bt(Te);
            }
          }
        }
        he.preventDefault();
        break;
      case "ArrowUp":
        if (he.preventDefault(), r.loading) return;
        te.value && ((it = Se.value) === null || it === void 0 || it.prev());
        break;
      case "ArrowDown":
        if (he.preventDefault(), r.loading) return;
        te.value ? (Xe = Se.value) === null || Xe === void 0 || Xe.next() : It();
        break;
      case "Escape":
        te.value && (D2(he), At()), (xt = re.value) === null || xt === void 0 || xt.focus();
        break;
    }
  }
  function Z() {
    var he;
    (he = re.value) === null || he === void 0 || he.focus();
  }
  function H() {
    var he;
    (he = re.value) === null || he === void 0 || he.focusInput();
  }
  function ne() {
    var he;
    te.value && ((he = X.value) === null || he === void 0 || he.syncPosition());
  }
  Lt(), Ht(Bt(r, "options"), Lt);
  const xe = { focus: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.focus();
  }, focusInput: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.focusInput();
  }, blur: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.blur();
  }, blurInput: () => {
    var he;
    (he = re.value) === null || he === void 0 || he.blurInput();
  } }, Pe = Me(() => {
    const { self: { menuBoxShadow: he } } = g.value;
    return { "--n-menu-box-shadow": he };
  }), De = f ? bi("select", void 0, Pe, r) : void 0;
  return Object.assign(Object.assign({}, xe), { mergedStatus: et, mergedClsPrefix: i, mergedBordered: l, namespace: d, treeMate: W, isMounted: ap(), triggerRef: re, menuRef: Se, pattern: M, uncontrolledShow: ie, mergedShow: te, adjustedTo: ic(r), uncontrolledValue: m, mergedValue: C, followerRef: X, localizedPlaceholder: oe, selectedOption: ut, selectedOptions: Qe, mergedSize: yt, mergedDisabled: lt, focused: P, activeWithoutMenuOpen: gr, inlineThemeDisabled: f, onTriggerInputFocus: ir, onTriggerInputBlur: nr, handleTriggerOrMenuResize: ne, handleMenuFocus: Ct, handleMenuBlur: Ee, handleMenuTabOut: nt, handleTriggerClick: Ut, handleToggle: ht, handleDeleteOption: bt, handlePatternInput: mt, handleClear: Kt, handleTriggerBlur: Ar, handleTriggerFocus: wr, handleKeydown: ze, handleMenuAfterLeave: mr, handleMenuClickOutside: Be, handleMenuScroll: ki, handleMenuKeydown: ze, handleMenuMousedown: Qr, mergedTheme: g, cssVars: f ? void 0 : Pe, themeClass: De == null ? void 0 : De.themeClass, onRender: De == null ? void 0 : De.onRender });
}, render() {
  return B("div", { class: `${this.mergedClsPrefix}-select` }, B(F_, null, { default: () => [B(L_, null, { default: () => B(Tk, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var r, i;
    return [(i = (r = this.$slots).arrow) === null || i === void 0 ? void 0 : i.call(r)];
  } }) }), B(B_, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === ic.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => B(Io, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var r, i, l;
    return this.mergedShow || this.displayDirective === "show" ? ((r = this.onRender) === null || r === void 0 || r.call(this), ga(B(wk, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (i = this.menuProps) === null || i === void 0 ? void 0 : i.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var d, f;
      return [(f = (d = this.$slots).empty) === null || f === void 0 ? void 0 : f.call(d)];
    }, header: () => {
      var d, f;
      return [(f = (d = this.$slots).header) === null || f === void 0 ? void 0 : f.call(d)];
    }, action: () => {
      var d, f;
      return [(f = (d = this.$slots).action) === null || f === void 0 ? void 0 : f.call(d)];
    } }), this.displayDirective === "show" ? [[Qa, this.mergedShow], [Gf, this.handleMenuClickOutside, void 0, { capture: true }]] : [[Gf, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), FP = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, Ab = Rn("n-radio-group");
function LP(r) {
  const i = pr(Ab, null), l = ya(r, { mergedSize(ee) {
    const { size: ie } = r;
    if (ie !== void 0) return ie;
    if (i) {
      const { mergedSizeRef: { value: te } } = i;
      if (te !== void 0) return te;
    }
    return ee ? ee.mergedSize.value : "medium";
  }, mergedDisabled(ee) {
    return !!(r.disabled || (i == null ? void 0 : i.disabledRef.value) || (ee == null ? void 0 : ee.disabled.value));
  } }), { mergedSizeRef: d, mergedDisabledRef: f } = l, g = Re(null), m = Re(null), s = Re(r.defaultChecked), C = Bt(r, "checked"), P = Hi(C, s), M = yi(() => i ? i.valueRef.value === r.value : P.value), F = yi(() => {
    const { name: ee } = r;
    if (ee !== void 0) return ee;
    if (i) return i.nameRef.value;
  }), D = Re(false);
  function A() {
    if (i) {
      const { doUpdateValue: ee } = i, { value: ie } = r;
      jt(ee, ie);
    } else {
      const { onUpdateChecked: ee, "onUpdate:checked": ie } = r, { nTriggerFormInput: te, nTriggerFormChange: re } = l;
      ee && jt(ee, true), ie && jt(ie, true), te(), re(), s.value = true;
    }
  }
  function O() {
    f.value || M.value || A();
  }
  function V() {
    O(), g.value && (g.value.checked = M.value);
  }
  function Y() {
    D.value = false;
  }
  function W() {
    D.value = true;
  }
  return { mergedClsPrefix: i ? i.mergedClsPrefixRef : Mr(r).mergedClsPrefixRef, inputRef: g, labelRef: m, mergedName: F, mergedDisabled: f, renderSafeChecked: M, focus: D, mergedSize: d, handleRadioInputChange: V, handleRadioInputBlur: Y, handleRadioInputFocus: W };
}
const BP = ot({ name: "RadioButton", props: FP, setup: LP, render() {
  const { mergedClsPrefix: r } = this;
  return B("label", { class: [`${r}-radio-button`, this.mergedDisabled && `${r}-radio-button--disabled`, this.renderSafeChecked && `${r}-radio-button--checked`, this.focus && [`${r}-radio-button--focus`]] }, B("input", { ref: "inputRef", type: "radio", class: `${r}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), B("div", { class: `${r}-radio-button__state-border` }), Ii(this.$slots.default, (i) => !i && !this.label ? null : B("div", { ref: "labelRef", class: `${r}-radio__label` }, i || this.label)));
} }), OP = ce("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Fe("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ue("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ue("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ue("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [ce("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Fe("splitor", { height: "var(--n-height)" })]), ce("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [ce("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Fe("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), Ge("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Fe("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), Ge("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Fe("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), pi("disabled", `
 cursor: pointer;
 `, [Ge("&:hover", [Fe("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), pi("checked", { color: "var(--n-button-text-color-hover)" })]), Ue("focus", [Ge("&:not(:active)", [Fe("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ue("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ue("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function $P(r, i, l) {
  var d;
  const f = [];
  let g = false;
  for (let m = 0; m < r.length; ++m) {
    const s = r[m], C = (d = s.type) === null || d === void 0 ? void 0 : d.name;
    C === "RadioButton" && (g = true);
    const P = s.props;
    if (C !== "RadioButton") {
      f.push(s);
      continue;
    }
    if (m === 0) f.push(s);
    else {
      const M = f[f.length - 1].props, F = i === M.value, D = M.disabled, A = i === P.value, O = P.disabled, V = (F ? 2 : 0) + (D ? 0 : 1), Y = (A ? 2 : 0) + (O ? 0 : 1), W = { [`${l}-radio-group__splitor--disabled`]: D, [`${l}-radio-group__splitor--checked`]: F }, ee = { [`${l}-radio-group__splitor--disabled`]: O, [`${l}-radio-group__splitor--checked`]: A }, ie = V < Y ? ee : W;
      f.push(B("div", { class: [`${l}-radio-group__splitor`, ie] }), s);
    }
  }
  return { children: f, isButtonGroup: g };
}
const jP = Object.assign(Object.assign({}, rr.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), NP = ot({ name: "RadioGroup", props: jP, setup(r) {
  const i = Re(null), { mergedSizeRef: l, mergedDisabledRef: d, nTriggerFormChange: f, nTriggerFormInput: g, nTriggerFormBlur: m, nTriggerFormFocus: s } = ya(r), { mergedClsPrefixRef: C, inlineThemeDisabled: P, mergedRtlRef: M } = Mr(r), F = rr("Radio", "-radio-group", OP, z2, r, C), D = Re(r.defaultValue), A = Bt(r, "value"), O = Hi(A, D);
  function V(re) {
    const { onUpdateValue: X, "onUpdate:value": Se } = r;
    X && jt(X, re), Se && jt(Se, re), D.value = re, f(), g();
  }
  function Y(re) {
    const { value: X } = i;
    X && (X.contains(re.relatedTarget) || s());
  }
  function W(re) {
    const { value: X } = i;
    X && (X.contains(re.relatedTarget) || m());
  }
  Zr(Ab, { mergedClsPrefixRef: C, nameRef: Bt(r, "name"), valueRef: O, disabledRef: d, mergedSizeRef: l, doUpdateValue: V });
  const ee = Un("Radio", M, C), ie = Me(() => {
    const { value: re } = l, { common: { cubicBezierEaseInOut: X }, self: { buttonBorderColor: Se, buttonBorderColorActive: pe, buttonBorderRadius: oe, buttonBoxShadow: fe, buttonBoxShadowFocus: _e, buttonBoxShadowHover: qe, buttonColor: Ve, buttonColorActive: Qe, buttonTextColor: ut, buttonTextColorActive: gt, buttonTextColorHover: yt, opacityDisabled: lt, [Jt("buttonHeight", re)]: et, [Jt("fontSize", re)]: dt } } = F.value;
    return { "--n-font-size": dt, "--n-bezier": X, "--n-button-border-color": Se, "--n-button-border-color-active": pe, "--n-button-border-radius": oe, "--n-button-box-shadow": fe, "--n-button-box-shadow-focus": _e, "--n-button-box-shadow-hover": qe, "--n-button-color": Ve, "--n-button-color-active": Qe, "--n-button-text-color": ut, "--n-button-text-color-hover": yt, "--n-button-text-color-active": gt, "--n-height": et, "--n-opacity-disabled": lt };
  }), te = P ? bi("radio-group", Me(() => l.value[0]), ie, r) : void 0;
  return { selfElRef: i, rtlEnabled: ee, mergedClsPrefix: C, mergedValue: O, handleFocusout: W, handleFocusin: Y, cssVars: P ? void 0 : ie, themeClass: te == null ? void 0 : te.themeClass, onRender: te == null ? void 0 : te.onRender };
}, render() {
  var r;
  const { mergedValue: i, mergedClsPrefix: l, handleFocusin: d, handleFocusout: f } = this, { children: g, isButtonGroup: m } = $P(El(lp(this)), i, l);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { onFocusin: d, onFocusout: f, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, m && `${l}-radio-group--button-group`], style: this.cssVars }, g);
} }), Db = ce("ellipsis", { overflow: "hidden" }, [pi("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ue("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ue("cursor-pointer", `
 cursor: pointer;
 `)]);
function xg(r) {
  return `${r}-ellipsis--line-clamp`;
}
function wg(r, i) {
  return `${r}-ellipsis--cursor-${i}`;
}
const zb = Object.assign(Object.assign({}, rr.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), VP = ot({ name: "Ellipsis", inheritAttrs: false, props: zb, slots: Object, setup(r, { slots: i, attrs: l }) {
  const d = j_(), f = rr("Ellipsis", "-ellipsis", Db, F2, r, d), g = Re(null), m = Re(null), s = Re(null), C = Re(false), P = Me(() => {
    const { lineClamp: Y } = r, { value: W } = C;
    return Y !== void 0 ? { textOverflow: "", "-webkit-line-clamp": W ? "" : Y } : { textOverflow: W ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function M() {
    let Y = false;
    const { value: W } = C;
    if (W) return true;
    const { value: ee } = g;
    if (ee) {
      const { lineClamp: ie } = r;
      if (A(ee), ie !== void 0) Y = ee.scrollHeight <= ee.offsetHeight;
      else {
        const { value: te } = m;
        te && (Y = te.getBoundingClientRect().width <= ee.getBoundingClientRect().width);
      }
      O(ee, Y);
    }
    return Y;
  }
  const F = Me(() => r.expandTrigger === "click" ? () => {
    var Y;
    const { value: W } = C;
    W && ((Y = s.value) === null || Y === void 0 || Y.setShow(false)), C.value = !W;
  } : void 0);
  S_(() => {
    var Y;
    r.tooltip && ((Y = s.value) === null || Y === void 0 || Y.setShow(false));
  });
  const D = () => B("span", Object.assign({}, Cs(l, { class: [`${d.value}-ellipsis`, r.lineClamp !== void 0 ? xg(d.value) : void 0, r.expandTrigger === "click" ? wg(d.value, "pointer") : void 0], style: P.value }), { ref: "triggerRef", onClick: F.value, onMouseenter: r.expandTrigger === "click" ? M : void 0 }), r.lineClamp ? i : B("span", { ref: "triggerInnerRef" }, i));
  function A(Y) {
    if (!Y) return;
    const W = P.value, ee = xg(d.value);
    r.lineClamp !== void 0 ? V(Y, ee, "add") : V(Y, ee, "remove");
    for (const ie in W) Y.style[ie] !== W[ie] && (Y.style[ie] = W[ie]);
  }
  function O(Y, W) {
    const ee = wg(d.value, "pointer");
    r.expandTrigger === "click" && !W ? V(Y, ee, "add") : V(Y, ee, "remove");
  }
  function V(Y, W, ee) {
    ee === "add" ? Y.classList.contains(W) || Y.classList.add(W) : Y.classList.contains(W) && Y.classList.remove(W);
  }
  return { mergedTheme: f, triggerRef: g, triggerInnerRef: m, tooltipRef: s, handleClick: F, renderTrigger: D, getTooltipDisabled: M };
}, render() {
  var r;
  const { tooltip: i, renderTrigger: l, $slots: d } = this;
  if (i) {
    const { mergedTheme: f } = this;
    return B($_, Object.assign({ ref: "tooltipRef", placement: "top" }, i, { getDisabled: this.getTooltipDisabled, theme: f.peers.Tooltip, themeOverrides: f.peerOverrides.Tooltip }), { trigger: l, default: (r = d.tooltip) !== null && r !== void 0 ? r : d.default });
  } else return l();
} }), UP = ot({ name: "PerformantEllipsis", props: zb, inheritAttrs: false, setup(r, { attrs: i, slots: l }) {
  const d = Re(false), f = j_();
  return cc("-ellipsis", Db, f), { mouseEntered: d, renderTrigger: () => {
    const { lineClamp: m } = r, s = f.value;
    return B("span", Object.assign({}, Cs(i, { class: [`${s}-ellipsis`, m !== void 0 ? xg(s) : void 0, r.expandTrigger === "click" ? wg(s, "pointer") : void 0], style: m === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": m } }), { onMouseenter: () => {
      d.value = true;
    } }), m ? l : B("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? B(VP, Cs({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function Fb() {
  const r = pr(L2, null);
  return r === null && Xo("use-dialog", "No outer <n-dialog-provider /> founded."), r;
}
function cp() {
  const r = pr(B2, null);
  return r === null && Xo("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), r;
}
const qP = ce("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [pi("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [pi("no-title", `
 display: flex;
 align-items: center;
 `)]), Fe("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ue("title-position-left", [Fe("line", [Ue("left", { width: "28px" })])]), Ue("title-position-right", [Fe("line", [Ue("right", { width: "28px" })])]), Ue("dashed", [Fe("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ue("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Fe("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), pi("dashed", [Fe("line", { backgroundColor: "var(--n-color)" })]), Ue("dashed", [Fe("line", { borderColor: "var(--n-color)" })]), Ue("vertical", { backgroundColor: "var(--n-color)" })]), GP = Object.assign(Object.assign({}, rr.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), WP = ot({ name: "Divider", props: GP, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), d = rr("Divider", "-divider", qP, O2, r, i), f = Me(() => {
    const { common: { cubicBezierEaseInOut: m }, self: { color: s, textColor: C, fontWeight: P } } = d.value;
    return { "--n-bezier": m, "--n-color": s, "--n-text-color": C, "--n-font-weight": P };
  }), g = l ? bi("divider", void 0, f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  const { $slots: i, titlePlacement: l, vertical: d, dashed: f, cssVars: g, mergedClsPrefix: m } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { role: "separator", class: [`${m}-divider`, this.themeClass, { [`${m}-divider--vertical`]: d, [`${m}-divider--no-title`]: !i.default, [`${m}-divider--dashed`]: f, [`${m}-divider--title-position-${l}`]: i.default && l }], style: g }, d ? null : B("div", { class: `${m}-divider__line ${m}-divider__line--left` }), !d && i.default ? B(Hr, null, B("div", { class: `${m}-divider__title` }, this.$slots), B("div", { class: `${m}-divider__line ${m}-divider__line--right` })) : null);
} }), ZP = ot({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(r) {
  const i = Re(!!r.show), l = Re(null), d = pr(Gg);
  let f = 0, g = "", m = null;
  const s = Re(false), C = Re(false), P = Me(() => r.placement === "top" || r.placement === "bottom"), { mergedClsPrefixRef: M, mergedRtlRef: F } = Mr(r), D = Un("Drawer", F, M), A = X, O = (oe) => {
    C.value = true, f = P.value ? oe.clientY : oe.clientX, g = document.body.style.cursor, document.body.style.cursor = P.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", re), document.body.addEventListener("mouseleave", A), document.body.addEventListener("mouseup", X);
  }, V = () => {
    m !== null && (window.clearTimeout(m), m = null), C.value ? s.value = true : m = window.setTimeout(() => {
      s.value = true;
    }, 300);
  }, Y = () => {
    m !== null && (window.clearTimeout(m), m = null), s.value = false;
  }, { doUpdateHeight: W, doUpdateWidth: ee } = d, ie = (oe) => {
    const { maxWidth: fe } = r;
    if (fe && oe > fe) return fe;
    const { minWidth: _e } = r;
    return _e && oe < _e ? _e : oe;
  }, te = (oe) => {
    const { maxHeight: fe } = r;
    if (fe && oe > fe) return fe;
    const { minHeight: _e } = r;
    return _e && oe < _e ? _e : oe;
  };
  function re(oe) {
    var fe, _e;
    if (C.value) if (P.value) {
      let qe = ((fe = l.value) === null || fe === void 0 ? void 0 : fe.offsetHeight) || 0;
      const Ve = f - oe.clientY;
      qe += r.placement === "bottom" ? Ve : -Ve, qe = te(qe), W(qe), f = oe.clientY;
    } else {
      let qe = ((_e = l.value) === null || _e === void 0 ? void 0 : _e.offsetWidth) || 0;
      const Ve = f - oe.clientX;
      qe += r.placement === "right" ? Ve : -Ve, qe = ie(qe), ee(qe), f = oe.clientX;
    }
  }
  function X() {
    C.value && (f = 0, C.value = false, document.body.style.cursor = g, document.body.removeEventListener("mousemove", re), document.body.removeEventListener("mouseup", X), document.body.removeEventListener("mouseleave", A));
  }
  vo(() => {
    r.show && (i.value = true);
  }), Ht(() => r.show, (oe) => {
    oe || X();
  }), Sn(() => {
    X();
  });
  const Se = Me(() => {
    const { show: oe } = r, fe = [[Qa, oe]];
    return r.showMask || fe.push([Gf, r.onClickoutside, void 0, { capture: true }]), fe;
  });
  function pe() {
    var oe;
    i.value = false, (oe = r.onAfterLeave) === null || oe === void 0 || oe.call(r);
  }
  return j2(Me(() => r.blockScroll && i.value)), Zr(N2, l), Zr(V2, null), Zr(U2, null), { bodyRef: l, rtlEnabled: D, mergedClsPrefix: d.mergedClsPrefixRef, isMounted: d.isMountedRef, mergedTheme: d.mergedThemeRef, displayed: i, transitionName: Me(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[r.placement]), handleAfterLeave: pe, bodyDirectives: Se, handleMousedownResizeTrigger: O, handleMouseenterResizeTrigger: V, handleMouseleaveResizeTrigger: Y, isDragging: C, isHoverOnResizeTrigger: s };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? ga(B("div", { role: "none" }, B($2, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => B(Io, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => ga(B("div", Cs(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${i}-drawer`, this.rtlEnabled && `${i}-drawer--rtl`, `${i}-drawer--${this.placement}-placement`, this.isDragging && `${i}-drawer--unselectable`, this.nativeScrollbar && `${i}-drawer--native-scrollbar`] }), [this.resizable ? B("div", { class: [`${i}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${i}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? B("div", { class: [`${i}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, r) : B(eh, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${i}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), r)]), this.bodyDirectives) }) })), [[Qa, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: HP, cubicBezierEaseOut: XP } = th;
function YP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${HP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${XP}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: KP, cubicBezierEaseOut: JP } = th;
function QP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${KP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${JP}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: eT, cubicBezierEaseOut: tT } = th;
function rT({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${eT}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${tT}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: iT, cubicBezierEaseOut: nT } = th;
function oT({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${iT}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${nT}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const aT = Ge([ce("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [rT(), QP(), oT(), YP(), Ue("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ue("native-scrollbar", [ce("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Fe("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), ce("drawer-content-wrapper", `
 box-sizing: border-box;
 `), ce("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ue("native-scrollbar", [ce("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), ce("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), ce("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), ce("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Fe("main", `
 flex: 1;
 `), Fe("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), ce("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ue("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Fe("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ue("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Fe("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ue("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Fe("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ue("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Fe("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), Ge("body", [Ge(">", [ce("drawer-container", `
 position: fixed;
 `)])]), ce("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [Ge("> *", `
 pointer-events: all;
 `)]), ce("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), Zf({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), sT = Object.assign(Object.assign({}, rr.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), Lb = ot({ name: "Drawer", inheritAttrs: false, props: sT, setup(r) {
  const { mergedClsPrefixRef: i, namespaceRef: l, inlineThemeDisabled: d } = Mr(r), f = ap(), g = rr("Drawer", "-drawer", aT, q2, r, i), m = Re(r.defaultWidth), s = Re(r.defaultHeight), C = Hi(Bt(r, "width"), m), P = Hi(Bt(r, "height"), s), M = Me(() => {
    const { placement: X } = r;
    return X === "top" || X === "bottom" ? "" : Wo(C.value);
  }), F = Me(() => {
    const { placement: X } = r;
    return X === "left" || X === "right" ? "" : Wo(P.value);
  }), D = (X) => {
    const { onUpdateWidth: Se, "onUpdate:width": pe } = r;
    Se && jt(Se, X), pe && jt(pe, X), m.value = X;
  }, A = (X) => {
    const { onUpdateHeight: Se, "onUpdate:width": pe } = r;
    Se && jt(Se, X), pe && jt(pe, X), s.value = X;
  }, O = Me(() => [{ width: M.value, height: F.value }, r.drawerStyle || ""]);
  function V(X) {
    const { onMaskClick: Se, maskClosable: pe } = r;
    pe && ie(false), Se && Se(X);
  }
  function Y(X) {
    V(X);
  }
  const W = G2();
  function ee(X) {
    var Se;
    (Se = r.onEsc) === null || Se === void 0 || Se.call(r), r.show && r.closeOnEsc && W2(X) && (W.value || ie(false));
  }
  function ie(X) {
    const { onHide: Se, onUpdateShow: pe, "onUpdate:show": oe } = r;
    pe && jt(pe, X), oe && jt(oe, X), Se && !X && jt(Se, X);
  }
  Zr(Gg, { isMountedRef: f, mergedThemeRef: g, mergedClsPrefixRef: i, doUpdateShow: ie, doUpdateHeight: A, doUpdateWidth: D });
  const te = Me(() => {
    const { common: { cubicBezierEaseInOut: X, cubicBezierEaseIn: Se, cubicBezierEaseOut: pe }, self: { color: oe, textColor: fe, boxShadow: _e, lineHeight: qe, headerPadding: Ve, footerPadding: Qe, borderRadius: ut, bodyPadding: gt, titleFontSize: yt, titleTextColor: lt, titleFontWeight: et, headerBorderBottom: dt, footerBorderTop: Ft, closeIconColor: ft, closeIconColorHover: _t, closeIconColorPressed: $t, closeColorHover: Qt, closeColorPressed: Lt, closeIconSize: zt, closeSize: It, closeBorderRadius: At, resizableTriggerColorHover: mr } } = g.value;
    return { "--n-line-height": qe, "--n-color": oe, "--n-border-radius": ut, "--n-text-color": fe, "--n-box-shadow": _e, "--n-bezier": X, "--n-bezier-out": pe, "--n-bezier-in": Se, "--n-header-padding": Ve, "--n-body-padding": gt, "--n-footer-padding": Qe, "--n-title-text-color": lt, "--n-title-font-size": yt, "--n-title-font-weight": et, "--n-header-border-bottom": dt, "--n-footer-border-top": Ft, "--n-close-icon-color": ft, "--n-close-icon-color-hover": _t, "--n-close-icon-color-pressed": $t, "--n-close-size": It, "--n-close-color-hover": Qt, "--n-close-color-pressed": Lt, "--n-close-icon-size": zt, "--n-close-border-radius": At, "--n-resize-trigger-color-hover": mr };
  }), re = d ? bi("drawer", void 0, te, r) : void 0;
  return { mergedClsPrefix: i, namespace: l, mergedBodyStyle: O, handleOutsideClick: Y, handleMaskClick: V, handleEsc: ee, mergedTheme: g, cssVars: d ? void 0 : te, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender, isMounted: f };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B(V_, { to: this.to, show: this.show }, { default: () => {
    var i;
    return (i = this.onRender) === null || i === void 0 || i.call(this), ga(B("div", { class: [`${r}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? B(Io, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? B("div", { "aria-hidden": true, class: [`${r}-drawer-mask`, this.showMask === "transparent" && `${r}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, B(ZP, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[N_, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), lT = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, Bb = ot({ name: "DrawerContent", props: lT, slots: Object, setup() {
  const r = pr(Gg, null);
  r || Xo("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: i } = r;
  function l() {
    i(false);
  }
  return { handleCloseClick: l, mergedTheme: r.mergedThemeRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { title: r, mergedClsPrefix: i, nativeScrollbar: l, mergedTheme: d, bodyClass: f, bodyStyle: g, bodyContentClass: m, bodyContentStyle: s, headerClass: C, headerStyle: P, footerClass: M, footerStyle: F, scrollbarProps: D, closable: A, $slots: O } = this;
  return B("div", { role: "none", class: [`${i}-drawer-content`, l && `${i}-drawer-content--native-scrollbar`] }, O.header || r || A ? B("div", { class: [`${i}-drawer-header`, C], style: P, role: "none" }, B("div", { class: `${i}-drawer-header__main`, role: "heading", "aria-level": "1" }, O.header !== void 0 ? O.header() : r), A && B(Vg, { onClick: this.handleCloseClick, clsPrefix: i, class: `${i}-drawer-header__close`, absolute: true })) : null, l ? B("div", { class: [`${i}-drawer-body`, f], style: g, role: "none" }, B("div", { class: [`${i}-drawer-body-content-wrapper`, m], style: s, role: "none" }, O)) : B(eh, Object.assign({ themeOverrides: d.peerOverrides.Scrollbar, theme: d.peers.Scrollbar }, D, { class: `${i}-drawer-body`, contentClass: [`${i}-drawer-body-content-wrapper`, m], contentStyle: s }), O), O.footer ? B("div", { class: [`${i}-drawer-footer`, M], style: F, role: "none" }, O.footer()) : null);
} });
let Nm;
function uT() {
  if (!op) return true;
  if (Nm === void 0) {
    const r = document.createElement("div");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.rowGap = "1px", r.appendChild(document.createElement("div")), r.appendChild(document.createElement("div")), document.body.appendChild(r);
    const i = r.scrollHeight === 1;
    return document.body.removeChild(r), Nm = i;
  }
  return Nm;
}
const cT = Object.assign(Object.assign({}, rr.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), Sl = ot({ name: "Space", props: cT, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Mr(r), d = rr("Space", "-space", void 0, Z2, r, i), f = Un("Space", l, i);
  return { useGap: uT(), rtlEnabled: f, mergedClsPrefix: i, margin: Me(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [Jt("gap", g)]: m } } = d.value, { row: s, col: C } = U_(m);
    return { horizontal: en(C), vertical: en(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, itemClass: g, itemStyle: m, margin: s, wrap: C, mergedClsPrefix: P, rtlEnabled: M, useGap: F, wrapItem: D, internalUseGap: A } = this, O = El(lp(this), false);
  if (!O.length) return null;
  const V = `${s.horizontal}px`, Y = `${s.horizontal / 2}px`, W = `${s.vertical}px`, ee = `${s.vertical / 2}px`, ie = O.length - 1, te = f.startsWith("space-");
  return B("div", { role: "none", class: [`${P}-space`, M && `${P}-space--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(f) ? `flex-${f}` : f, flexWrap: !C || r ? "nowrap" : "wrap", marginTop: F || r ? "" : `-${ee}`, marginBottom: F || r ? "" : `-${ee}`, alignItems: l, gap: F ? `${s.vertical}px ${s.horizontal}px` : "" } }, !D && (F || A) ? O : O.map((re, X) => re.type === e2 ? re : B("div", { role: "none", class: g, style: [m, { maxWidth: "100%" }, F ? "" : r ? { marginBottom: X !== ie ? W : "" } : M ? { marginLeft: te ? f === "space-between" && X === ie ? "" : Y : X !== ie ? V : "", marginRight: te ? f === "space-between" && X === 0 ? "" : Y : "", paddingTop: ee, paddingBottom: ee } : { marginRight: te ? f === "space-between" && X === ie ? "" : Y : X !== ie ? V : "", marginLeft: te ? f === "space-between" && X === 0 ? "" : Y : "", paddingTop: ee, paddingBottom: ee }] }, re)));
} }), dT = ce("dynamic-tags", [ce("input", { minWidth: "var(--n-input-width)" })]), hT = Object.assign(Object.assign(Object.assign({}, rr.props), Sb), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (r) => r }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), fT = ot({ name: "DynamicTags", props: hT, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), { localeRef: d } = ts("DynamicTags"), f = ya(r), { mergedDisabledRef: g } = f, m = Re(""), s = Re(false), C = Re(true), P = Re(null), M = rr("DynamicTags", "-dynamic-tags", dT, H2, r, i), F = Re(r.defaultValue), D = Bt(r, "value"), A = Hi(D, F), O = Me(() => d.value.add), V = Me(() => hS(r.size)), Y = Me(() => g.value || !!r.max && A.value.length >= r.max);
  function W(oe) {
    const { onChange: fe, "onUpdate:value": _e, onUpdateValue: qe } = r, { nTriggerFormInput: Ve, nTriggerFormChange: Qe } = f;
    fe && jt(fe, oe), qe && jt(qe, oe), _e && jt(_e, oe), F.value = oe, Ve(), Qe();
  }
  function ee(oe) {
    const fe = A.value.slice(0);
    fe.splice(oe, 1), W(fe);
  }
  function ie(oe) {
    switch (oe.key) {
      case "Enter":
        te();
    }
  }
  function te(oe) {
    const fe = oe ?? m.value;
    if (fe) {
      const _e = A.value.slice(0);
      _e.push(r.onCreate(fe)), W(_e);
    }
    s.value = false, C.value = true, m.value = "";
  }
  function re() {
    te();
  }
  function X() {
    s.value = true, Vn(() => {
      var oe;
      (oe = P.value) === null || oe === void 0 || oe.focus(), C.value = false;
    });
  }
  const Se = Me(() => {
    const { self: { inputWidth: oe } } = M.value;
    return { "--n-input-width": oe };
  }), pe = l ? bi("dynamic-tags", void 0, Se, r) : void 0;
  return { mergedClsPrefix: i, inputInstRef: P, localizedAdd: O, inputSize: V, inputValue: m, showInput: s, inputForceFocused: C, mergedValue: A, mergedDisabled: g, triggerDisabled: Y, handleInputKeyDown: ie, handleAddClick: X, handleInputBlur: re, handleCloseClick: ee, handleInputConfirm: te, mergedTheme: M, cssVars: l ? void 0 : Se, themeClass: pe == null ? void 0 : pe.themeClass, onRender: pe == null ? void 0 : pe.onRender };
}, render() {
  const { mergedTheme: r, cssVars: i, mergedClsPrefix: l, onRender: d, renderTag: f } = this;
  return d == null ? void 0 : d(), B(Sl, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: i, theme: r.peers.Space, themeOverrides: r.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: g, tagClass: m, tagStyle: s, type: C, round: P, size: M, color: F, closable: D, mergedDisabled: A, showInput: O, inputValue: V, inputClass: Y, inputStyle: W, inputSize: ee, inputForceFocused: ie, triggerDisabled: te, handleInputKeyDown: re, handleInputBlur: X, handleAddClick: Se, handleCloseClick: pe, handleInputConfirm: oe, $slots: fe } = this;
    return this.mergedValue.map((_e, qe) => f ? f(_e, qe) : B(Mo, { key: qe, theme: g.peers.Tag, themeOverrides: g.peerOverrides.Tag, class: m, style: s, type: C, round: P, size: M, color: F, closable: D, disabled: A, onClose: () => {
      pe(qe);
    } }, { default: () => typeof _e == "string" ? _e : _e.label })).concat(O ? fe.input ? fe.input({ submit: oe, deactivate: X }) : B(mo, Object.assign({ placeholder: "", size: ee, style: W, class: Y, autosize: true }, this.inputProps, { ref: "inputInstRef", value: V, onUpdateValue: (_e) => {
      this.inputValue = _e;
    }, theme: g.peers.Input, themeOverrides: g.peerOverrides.Input, onKeydown: re, onBlur: X, internalForceFocus: ie })) : fe.trigger ? fe.trigger({ activate: Se, disabled: te }) : B(Nr, { dashed: true, disabled: te, theme: g.peers.Button, themeOverrides: g.peerOverrides.Button, size: ee, onClick: Se }, { icon: () => B(Wr, { clsPrefix: l }, { default: () => B(up, null) }) }));
  } });
} }), pT = Object.assign(Object.assign({}, rr.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), vy = ot({ name: "Flex", props: pT, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Mr(r), d = rr("Flex", "-flex", void 0, X2, r, i);
  return { rtlEnabled: Un("Flex", l, i), mergedClsPrefix: i, margin: Me(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [Jt("gap", g)]: m } } = d.value, { row: s, col: C } = U_(m);
    return { horizontal: en(C), vertical: en(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, margin: g, wrap: m, mergedClsPrefix: s, rtlEnabled: C } = this, P = El(lp(this), false);
  return P.length ? B("div", { role: "none", class: [`${s}-flex`, C && `${s}-flex--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: f, flexWrap: !m || r ? "nowrap" : "wrap", alignItems: l, gap: `${g.vertical}px ${g.horizontal}px` } }, P) : null;
} }), rh = Rn("n-form"), Ob = Rn("n-form-item-insts"), mT = ce("form", [Ue("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [ce("form-item", { width: "auto", marginRight: "18px" }, [Ge("&:last-child", { marginRight: 0 })])])]);
var gT = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (F) {
        m(F);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (F) {
        m(F);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const vT = Object.assign(Object.assign({}, rr.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (r) => {
  r.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), Wd = ot({ name: "Form", props: vT, setup(r) {
  const { mergedClsPrefixRef: i } = Mr(r);
  rr("Form", "-form", mT, q_, r, i);
  const l = {}, d = Re(void 0), f = (C) => {
    const P = d.value;
    (P === void 0 || C >= P) && (d.value = C);
  };
  function g(C) {
    return gT(this, arguments, void 0, function* (P, M = () => true) {
      return yield new Promise((F, D) => {
        const A = [];
        for (const O of jd(l)) {
          const V = l[O];
          for (const Y of V) Y.path && A.push(Y.internalValidate(null, M));
        }
        Promise.all(A).then((O) => {
          const V = O.some((ee) => !ee.valid), Y = [], W = [];
          O.forEach((ee) => {
            var ie, te;
            !((ie = ee.errors) === null || ie === void 0) && ie.length && Y.push(ee.errors), !((te = ee.warnings) === null || te === void 0) && te.length && W.push(ee.warnings);
          }), P && P(Y.length ? Y : void 0, { warnings: W.length ? W : void 0 }), V ? D(Y.length ? Y : void 0) : F({ warnings: W.length ? W : void 0 });
        });
      });
    });
  }
  function m() {
    for (const C of jd(l)) {
      const P = l[C];
      for (const M of P) M.restoreValidation();
    }
  }
  return Zr(rh, { props: r, maxChildLabelWidthRef: d, deriveMaxChildLabelWidth: f }), Zr(Ob, { formItems: l }), Object.assign({ validate: g, restoreValidation: m }, { mergedClsPrefix: i });
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("form", { class: [`${r}-form`, this.inline && `${r}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function kl() {
  return kl = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) Object.prototype.hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, kl.apply(this, arguments);
}
function yT(r, i) {
  r.prototype = Object.create(i.prototype), r.prototype.constructor = r, Zd(r, i);
}
function Cg(r) {
  return Cg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, Cg(r);
}
function Zd(r, i) {
  return Zd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, f) {
    return d.__proto__ = f, d;
  }, Zd(r, i);
}
function _T() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function jf(r, i, l) {
  return _T() ? jf = Reflect.construct.bind() : jf = function(f, g, m) {
    var s = [null];
    s.push.apply(s, g);
    var C = Function.bind.apply(f, s), P = new C();
    return m && Zd(P, m.prototype), P;
  }, jf.apply(null, arguments);
}
function bT(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function Sg(r) {
  var i = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Sg = function(d) {
    if (d === null || !bT(d)) return d;
    if (typeof d != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof i < "u") {
      if (i.has(d)) return i.get(d);
      i.set(d, f);
    }
    function f() {
      return jf(d, arguments, Cg(this).constructor);
    }
    return f.prototype = Object.create(d.prototype, { constructor: { value: f, enumerable: false, writable: true, configurable: true } }), Zd(f, d);
  }, Sg(r);
}
var xT = /%[sdj%]/g, wT = function() {
};
function kg(r) {
  if (!r || !r.length) return null;
  var i = {};
  return r.forEach(function(l) {
    var d = l.field;
    i[d] = i[d] || [], i[d].push(l);
  }), i;
}
function go(r) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), d = 1; d < i; d++) l[d - 1] = arguments[d];
  var f = 0, g = l.length;
  if (typeof r == "function") return r.apply(null, l);
  if (typeof r == "string") {
    var m = r.replace(xT, function(s) {
      if (s === "%%") return "%";
      if (f >= g) return s;
      switch (s) {
        case "%s":
          return String(l[f++]);
        case "%d":
          return Number(l[f++]);
        case "%j":
          try {
            return JSON.stringify(l[f++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return m;
  }
  return r;
}
function CT(r) {
  return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern";
}
function tn(r, i) {
  return !!(r == null || i === "array" && Array.isArray(r) && !r.length || CT(i) && typeof r == "string" && !r);
}
function ST(r, i, l) {
  var d = [], f = 0, g = r.length;
  function m(s) {
    d.push.apply(d, s || []), f++, f === g && l(d);
  }
  r.forEach(function(s) {
    i(s, m);
  });
}
function yy(r, i, l) {
  var d = 0, f = r.length;
  function g(m) {
    if (m && m.length) {
      l(m);
      return;
    }
    var s = d;
    d = d + 1, s < f ? i(r[s], g) : l([]);
  }
  g([]);
}
function kT(r) {
  var i = [];
  return Object.keys(r).forEach(function(l) {
    i.push.apply(i, r[l] || []);
  }), i;
}
var _y = (function(r) {
  yT(i, r);
  function i(l, d) {
    var f;
    return f = r.call(this, "Async Validation Error") || this, f.errors = l, f.fields = d, f;
  }
  return i;
})(Sg(Error));
function PT(r, i, l, d, f) {
  if (i.first) {
    var g = new Promise(function(D, A) {
      var O = function(W) {
        return d(W), W.length ? A(new _y(W, kg(W))) : D(f);
      }, V = kT(r);
      yy(V, l, O);
    });
    return g.catch(function(D) {
      return D;
    }), g;
  }
  var m = i.firstFields === true ? Object.keys(r) : i.firstFields || [], s = Object.keys(r), C = s.length, P = 0, M = [], F = new Promise(function(D, A) {
    var O = function(Y) {
      if (M.push.apply(M, Y), P++, P === C) return d(M), M.length ? A(new _y(M, kg(M))) : D(f);
    };
    s.length || (d(M), D(f)), s.forEach(function(V) {
      var Y = r[V];
      m.indexOf(V) !== -1 ? yy(Y, l, O) : ST(Y, l, O);
    });
  });
  return F.catch(function(D) {
    return D;
  }), F;
}
function TT(r) {
  return !!(r && r.message !== void 0);
}
function IT(r, i) {
  for (var l = r, d = 0; d < i.length; d++) {
    if (l == null) return l;
    l = l[i[d]];
  }
  return l;
}
function by(r, i) {
  return function(l) {
    var d;
    return r.fullFields ? d = IT(i, r.fullFields) : d = i[l.field || r.fullField], TT(l) ? (l.field = l.field || r.fullField, l.fieldValue = d, l) : { message: typeof l == "function" ? l() : l, fieldValue: d, field: l.field || r.fullField };
  };
}
function xy(r, i) {
  if (i) {
    for (var l in i) if (i.hasOwnProperty(l)) {
      var d = i[l];
      typeof d == "object" && typeof r[l] == "object" ? r[l] = kl({}, r[l], d) : r[l] = d;
    }
  }
  return r;
}
var $b = function(i, l, d, f, g, m) {
  i.required && (!d.hasOwnProperty(i.field) || tn(l, m || i.type)) && f.push(go(g.messages.required, i.fullField));
}, MT = function(i, l, d, f, g) {
  (/^\s+$/.test(l) || l === "") && f.push(go(g.messages.whitespace, i.fullField));
}, kf, ET = (function() {
  if (kf) return kf;
  var r = "[a-fA-F\\d:]", i = function(te) {
    return te && te.includeBoundaries ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", d = "[a-fA-F\\d]{1,4}", f = (`
(?:
(?:` + d + ":){7}(?:" + d + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + d + ":){6}(?:" + l + "|:" + d + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + d + ":){5}(?::" + l + "|(?::" + d + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + d + ":){4}(?:(?::" + d + "){0,1}:" + l + "|(?::" + d + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + d + ":){3}(?:(?::" + d + "){0,2}:" + l + "|(?::" + d + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + d + ":){2}(?:(?::" + d + "){0,3}:" + l + "|(?::" + d + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + d + ":){1}(?:(?::" + d + "){0,4}:" + l + "|(?::" + d + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + d + "){0,5}:" + l + "|(?::" + d + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), g = new RegExp("(?:^" + l + "$)|(?:^" + f + "$)"), m = new RegExp("^" + l + "$"), s = new RegExp("^" + f + "$"), C = function(te) {
    return te && te.exact ? g : new RegExp("(?:" + i(te) + l + i(te) + ")|(?:" + i(te) + f + i(te) + ")", "g");
  };
  C.v4 = function(ie) {
    return ie && ie.exact ? m : new RegExp("" + i(ie) + l + i(ie), "g");
  }, C.v6 = function(ie) {
    return ie && ie.exact ? s : new RegExp("" + i(ie) + f + i(ie), "g");
  };
  var P = "(?:(?:[a-z]+:)?//)", M = "(?:\\S+(?::\\S*)?@)?", F = C.v4().source, D = C.v6().source, A = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", O = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", V = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", Y = "(?::\\d{2,5})?", W = '(?:[/?#][^\\s"]*)?', ee = "(?:" + P + "|www\\.)" + M + "(?:localhost|" + F + "|" + D + "|" + A + O + V + ")" + Y + W;
  return kf = new RegExp("(?:^" + ee + "$)", "i"), kf;
}), wy = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, Rd = { integer: function(i) {
  return Rd.number(i) && parseInt(i, 10) === i;
}, float: function(i) {
  return Rd.number(i) && !Rd.integer(i);
}, array: function(i) {
  return Array.isArray(i);
}, regexp: function(i) {
  if (i instanceof RegExp) return true;
  try {
    return !!new RegExp(i);
  } catch {
    return false;
  }
}, date: function(i) {
  return typeof i.getTime == "function" && typeof i.getMonth == "function" && typeof i.getYear == "function" && !isNaN(i.getTime());
}, number: function(i) {
  return isNaN(i) ? false : typeof i == "number";
}, object: function(i) {
  return typeof i == "object" && !Rd.array(i);
}, method: function(i) {
  return typeof i == "function";
}, email: function(i) {
  return typeof i == "string" && i.length <= 320 && !!i.match(wy.email);
}, url: function(i) {
  return typeof i == "string" && i.length <= 2048 && !!i.match(ET());
}, hex: function(i) {
  return typeof i == "string" && !!i.match(wy.hex);
} }, RT = function(i, l, d, f, g) {
  if (i.required && l === void 0) {
    $b(i, l, d, f, g);
    return;
  }
  var m = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = i.type;
  m.indexOf(s) > -1 ? Rd[s](l) || f.push(go(g.messages.types[s], i.fullField, i.type)) : s && typeof l !== i.type && f.push(go(g.messages.types[s], i.fullField, i.type));
}, AT = function(i, l, d, f, g) {
  var m = typeof i.len == "number", s = typeof i.min == "number", C = typeof i.max == "number", P = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, M = l, F = null, D = typeof l == "number", A = typeof l == "string", O = Array.isArray(l);
  if (D ? F = "number" : A ? F = "string" : O && (F = "array"), !F) return false;
  O && (M = l.length), A && (M = l.replace(P, "_").length), m ? M !== i.len && f.push(go(g.messages[F].len, i.fullField, i.len)) : s && !C && M < i.min ? f.push(go(g.messages[F].min, i.fullField, i.min)) : C && !s && M > i.max ? f.push(go(g.messages[F].max, i.fullField, i.max)) : s && C && (M < i.min || M > i.max) && f.push(go(g.messages[F].range, i.fullField, i.min, i.max));
}, Zu = "enum", DT = function(i, l, d, f, g) {
  i[Zu] = Array.isArray(i[Zu]) ? i[Zu] : [], i[Zu].indexOf(l) === -1 && f.push(go(g.messages[Zu], i.fullField, i[Zu].join(", ")));
}, zT = function(i, l, d, f, g) {
  if (i.pattern) {
    if (i.pattern instanceof RegExp) i.pattern.lastIndex = 0, i.pattern.test(l) || f.push(go(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    else if (typeof i.pattern == "string") {
      var m = new RegExp(i.pattern);
      m.test(l) || f.push(go(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    }
  }
}, Fr = { required: $b, whitespace: MT, type: RT, range: AT, enum: DT, pattern: zT }, FT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l, "string") && !i.required) return d();
    Fr.required(i, l, f, m, g, "string"), tn(l, "string") || (Fr.type(i, l, f, m, g), Fr.range(i, l, f, m, g), Fr.pattern(i, l, f, m, g), i.whitespace === true && Fr.whitespace(i, l, f, m, g));
  }
  d(m);
}, LT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && Fr.type(i, l, f, m, g);
  }
  d(m);
}, BT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l === "" && (l = void 0), tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && (Fr.type(i, l, f, m, g), Fr.range(i, l, f, m, g));
  }
  d(m);
}, OT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && Fr.type(i, l, f, m, g);
  }
  d(m);
}, $T = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), tn(l) || Fr.type(i, l, f, m, g);
  }
  d(m);
}, jT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && (Fr.type(i, l, f, m, g), Fr.range(i, l, f, m, g));
  }
  d(m);
}, NT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && (Fr.type(i, l, f, m, g), Fr.range(i, l, f, m, g));
  }
  d(m);
}, VT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l == null && !i.required) return d();
    Fr.required(i, l, f, m, g, "array"), l != null && (Fr.type(i, l, f, m, g), Fr.range(i, l, f, m, g));
  }
  d(m);
}, UT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && Fr.type(i, l, f, m, g);
  }
  d(m);
}, qT = "enum", GT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g), l !== void 0 && Fr[qT](i, l, f, m, g);
  }
  d(m);
}, WT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l, "string") && !i.required) return d();
    Fr.required(i, l, f, m, g), tn(l, "string") || Fr.pattern(i, l, f, m, g);
  }
  d(m);
}, ZT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l, "date") && !i.required) return d();
    if (Fr.required(i, l, f, m, g), !tn(l, "date")) {
      var C;
      l instanceof Date ? C = l : C = new Date(l), Fr.type(i, C, f, m, g), C && Fr.range(i, C.getTime(), f, m, g);
    }
  }
  d(m);
}, HT = function(i, l, d, f, g) {
  var m = [], s = Array.isArray(l) ? "array" : typeof l;
  Fr.required(i, l, f, m, g, s), d(m);
}, Vm = function(i, l, d, f, g) {
  var m = i.type, s = [], C = i.required || !i.required && f.hasOwnProperty(i.field);
  if (C) {
    if (tn(l, m) && !i.required) return d();
    Fr.required(i, l, f, s, g, m), tn(l, m) || Fr.type(i, l, f, s, g);
  }
  d(s);
}, XT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (tn(l) && !i.required) return d();
    Fr.required(i, l, f, m, g);
  }
  d(m);
}, Bd = { string: FT, method: LT, number: BT, boolean: OT, regexp: $T, integer: jT, float: NT, array: VT, object: UT, enum: GT, pattern: WT, date: ZT, url: Vm, hex: Vm, email: Vm, required: HT, any: XT };
function Pg() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var i = JSON.parse(JSON.stringify(this));
    return i.clone = this.clone, i;
  } };
}
var Tg = Pg(), nc = (function() {
  function r(l) {
    this.rules = null, this._messages = Tg, this.define(l);
  }
  var i = r.prototype;
  return i.define = function(d) {
    var f = this;
    if (!d) throw new Error("Cannot configure a schema with no rules");
    if (typeof d != "object" || Array.isArray(d)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(d).forEach(function(g) {
      var m = d[g];
      f.rules[g] = Array.isArray(m) ? m : [m];
    });
  }, i.messages = function(d) {
    return d && (this._messages = xy(Pg(), d)), this._messages;
  }, i.validate = function(d, f, g) {
    var m = this;
    f === void 0 && (f = {}), g === void 0 && (g = function() {
    });
    var s = d, C = f, P = g;
    if (typeof C == "function" && (P = C, C = {}), !this.rules || Object.keys(this.rules).length === 0) return P && P(null, s), Promise.resolve(s);
    function M(V) {
      var Y = [], W = {};
      function ee(te) {
        if (Array.isArray(te)) {
          var re;
          Y = (re = Y).concat.apply(re, te);
        } else Y.push(te);
      }
      for (var ie = 0; ie < V.length; ie++) ee(V[ie]);
      Y.length ? (W = kg(Y), P(Y, W)) : P(null, s);
    }
    if (C.messages) {
      var F = this.messages();
      F === Tg && (F = Pg()), xy(F, C.messages), C.messages = F;
    } else C.messages = this.messages();
    var D = {}, A = C.keys || Object.keys(this.rules);
    A.forEach(function(V) {
      var Y = m.rules[V], W = s[V];
      Y.forEach(function(ee) {
        var ie = ee;
        typeof ie.transform == "function" && (s === d && (s = kl({}, s)), W = s[V] = ie.transform(W)), typeof ie == "function" ? ie = { validator: ie } : ie = kl({}, ie), ie.validator = m.getValidationMethod(ie), ie.validator && (ie.field = V, ie.fullField = ie.fullField || V, ie.type = m.getType(ie), D[V] = D[V] || [], D[V].push({ rule: ie, value: W, source: s, field: V }));
      });
    });
    var O = {};
    return PT(D, C, function(V, Y) {
      var _a3;
      var W = V.rule, ee = (W.type === "object" || W.type === "array") && (typeof W.fields == "object" || typeof W.defaultField == "object");
      ee = ee && (W.required || !W.required && V.value), W.field = V.field;
      function ie(X, Se) {
        return kl({}, Se, { fullField: W.fullField + "." + X, fullFields: W.fullFields ? [].concat(W.fullFields, [X]) : [X] });
      }
      function te(X) {
        X === void 0 && (X = []);
        var Se = Array.isArray(X) ? X : [X];
        !C.suppressWarning && Se.length && r.warning("async-validator:", Se), Se.length && W.message !== void 0 && (Se = [].concat(W.message));
        var pe = Se.map(by(W, s));
        if (C.first && pe.length) return O[W.field] = 1, Y(pe);
        if (!ee) Y(pe);
        else {
          if (W.required && !V.value) return W.message !== void 0 ? pe = [].concat(W.message).map(by(W, s)) : C.error && (pe = [C.error(W, go(C.messages.required, W.field))]), Y(pe);
          var oe = {};
          W.defaultField && Object.keys(V.value).map(function(qe) {
            oe[qe] = W.defaultField;
          }), oe = kl({}, oe, V.rule.fields);
          var fe = {};
          Object.keys(oe).forEach(function(qe) {
            var Ve = oe[qe], Qe = Array.isArray(Ve) ? Ve : [Ve];
            fe[qe] = Qe.map(ie.bind(null, qe));
          });
          var _e = new r(fe);
          _e.messages(C.messages), V.rule.options && (V.rule.options.messages = C.messages, V.rule.options.error = C.error), _e.validate(V.value, V.rule.options || C, function(qe) {
            var Ve = [];
            pe && pe.length && Ve.push.apply(Ve, pe), qe && qe.length && Ve.push.apply(Ve, qe), Y(Ve.length ? Ve : null);
          });
        }
      }
      var re;
      if (W.asyncValidator) re = W.asyncValidator(W, V.value, te, V.source, C);
      else if (W.validator) {
        try {
          re = W.validator(W, V.value, te, V.source, C);
        } catch (X) {
          (_a3 = console.error) == null ? void 0 : _a3.call(console, X), C.suppressValidatorError || setTimeout(function() {
            throw X;
          }, 0), te(X.message);
        }
        re === true ? te() : re === false ? te(typeof W.message == "function" ? W.message(W.fullField || W.field) : W.message || (W.fullField || W.field) + " fails") : re instanceof Array ? te(re) : re instanceof Error && te(re.message);
      }
      re && re.then && re.then(function() {
        return te();
      }, function(X) {
        return te(X);
      });
    }, function(V) {
      M(V);
    }, s);
  }, i.getType = function(d) {
    if (d.type === void 0 && d.pattern instanceof RegExp && (d.type = "pattern"), typeof d.validator != "function" && d.type && !Bd.hasOwnProperty(d.type)) throw new Error(go("Unknown rule type %s", d.type));
    return d.type || "string";
  }, i.getValidationMethod = function(d) {
    if (typeof d.validator == "function") return d.validator;
    var f = Object.keys(d), g = f.indexOf("message");
    return g !== -1 && f.splice(g, 1), f.length === 1 && f[0] === "required" ? Bd.required : Bd[this.getType(d)] || void 0;
  }, r;
})();
nc.register = function(i, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  Bd[i] = l;
};
nc.warning = wT;
nc.messages = Tg;
nc.validators = Bd;
const { cubicBezierEaseInOut: Cy } = th;
function YT({ name: r = "fade-down", fromOffset: i = "-4px", enterDuration: l = ".3s", leaveDuration: d = ".3s", enterCubicBezier: f = Cy, leaveCubicBezier: g = Cy } = {}) {
  return [Ge(`&.${r}-transition-enter-from, &.${r}-transition-leave-to`, { opacity: 0, transform: `translateY(${i})` }), Ge(`&.${r}-transition-enter-to, &.${r}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), Ge(`&.${r}-transition-leave-active`, { transition: `opacity ${d} ${g}, transform ${d} ${g}` }), Ge(`&.${r}-transition-enter-active`, { transition: `opacity ${l} ${f}, transform ${l} ${f}` })];
}
const KT = ce("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [ce("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Fe("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Fe("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), ce("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ue("auto-label-width", [ce("form-item-label", "white-space: nowrap;")]), Ue("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [ce("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ue("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ue("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ue("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ue("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Fe("text", `
 grid-area: text; 
 `), Fe("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ue("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ue("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), ce("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), ce("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), ce("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [Ge("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), ce("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ue("warning", { color: "var(--n-feedback-text-color-warning)" }), Ue("error", { color: "var(--n-feedback-text-color-error)" }), YT({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function JT(r) {
  const i = pr(rh, null);
  return { mergedSize: Me(() => r.size !== void 0 ? r.size : (i == null ? void 0 : i.props.size) !== void 0 ? i.props.size : "medium") };
}
function QT(r) {
  const i = pr(rh, null), l = Me(() => {
    const { labelPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.labelPlacement) ? i.props.labelPlacement : "top";
  }), d = Me(() => l.value === "left" && (r.labelWidth === "auto" || (i == null ? void 0 : i.props.labelWidth) === "auto")), f = Me(() => {
    if (l.value === "top") return;
    const { labelWidth: O } = r;
    if (O !== void 0 && O !== "auto") return Wo(O);
    if (d.value) {
      const V = i == null ? void 0 : i.maxChildLabelWidthRef.value;
      return V !== void 0 ? Wo(V) : void 0;
    }
    if ((i == null ? void 0 : i.props.labelWidth) !== void 0) return Wo(i.props.labelWidth);
  }), g = Me(() => {
    const { labelAlign: O } = r;
    if (O) return O;
    if (i == null ? void 0 : i.props.labelAlign) return i.props.labelAlign;
  }), m = Me(() => {
    var O;
    return [(O = r.labelProps) === null || O === void 0 ? void 0 : O.style, r.labelStyle, { width: f.value }];
  }), s = Me(() => {
    const { showRequireMark: O } = r;
    return O !== void 0 ? O : i == null ? void 0 : i.props.showRequireMark;
  }), C = Me(() => {
    const { requireMarkPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.requireMarkPlacement) || "right";
  }), P = Re(false), M = Re(false), F = Me(() => {
    const { validationStatus: O } = r;
    if (O !== void 0) return O;
    if (P.value) return "error";
    if (M.value) return "warning";
  }), D = Me(() => {
    const { showFeedback: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showFeedback) !== void 0 ? i.props.showFeedback : true;
  }), A = Me(() => {
    const { showLabel: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showLabel) !== void 0 ? i.props.showLabel : true;
  });
  return { validationErrored: P, validationWarned: M, mergedLabelStyle: m, mergedLabelPlacement: l, mergedLabelAlign: g, mergedShowRequireMark: s, mergedRequireMarkPlacement: C, mergedValidationStatus: F, mergedShowFeedback: D, mergedShowLabel: A, isAutoLabelWidth: d };
}
function e5(r) {
  const i = pr(rh, null), l = Me(() => {
    const { rulePath: m } = r;
    if (m !== void 0) return m;
    const { path: s } = r;
    if (s !== void 0) return s;
  }), d = Me(() => {
    const m = [], { rule: s } = r;
    if (s !== void 0 && (Array.isArray(s) ? m.push(...s) : m.push(s)), i) {
      const { rules: C } = i.props, { value: P } = l;
      if (C !== void 0 && P !== void 0) {
        const M = G_(C, P);
        M !== void 0 && (Array.isArray(M) ? m.push(...M) : m.push(M));
      }
    }
    return m;
  }), f = Me(() => d.value.some((m) => m.required)), g = Me(() => f.value || r.required);
  return { mergedRules: d, mergedRequired: g };
}
var Sy = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (F) {
        m(F);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (F) {
        m(F);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const t5 = Object.assign(Object.assign({}, rr.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object, contentClass: String, contentStyle: [String, Object] });
function ky(r, i) {
  return (...l) => {
    try {
      const d = r(...l);
      return !i && (typeof d == "boolean" || d instanceof Error || Array.isArray(d)) || (d == null ? void 0 : d.then) ? d : (d === void 0 || qf("form-item/validate", `You return a ${typeof d} typed value in the validator method, which is not recommended. Please use ${i ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (d) {
      qf("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(d);
      return;
    }
  };
}
const wn = ot({ name: "FormItem", props: t5, setup(r) {
  rS(Ob, "formItems", Bt(r, "path"));
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), d = pr(rh, null), f = JT(r), g = QT(r), { validationErrored: m, validationWarned: s } = g, { mergedRequired: C, mergedRules: P } = e5(r), { mergedSize: M } = f, { mergedLabelPlacement: F, mergedLabelAlign: D, mergedRequireMarkPlacement: A } = g, O = Re([]), V = Re(Dl()), Y = d ? Bt(d.props, "disabled") : Re(false), W = rr("Form", "-form-item", KT, q_, r, i);
  Ht(Bt(r, "path"), () => {
    r.ignorePathChange || ee();
  });
  function ee() {
    O.value = [], m.value = false, s.value = false, r.feedback && (V.value = Dl());
  }
  const ie = (...Qe) => Sy(this, [...Qe], void 0, function* (ut = null, gt = () => true, yt = { suppressWarning: true }) {
    const { path: lt } = r;
    yt ? yt.first || (yt.first = r.first) : yt = {};
    const { value: et } = P, dt = d ? G_(d.props.model, lt || "") : void 0, Ft = {}, ft = {}, _t = (ut ? et.filter((ir) => Array.isArray(ir.trigger) ? ir.trigger.includes(ut) : ir.trigger === ut) : et).filter(gt).map((ir, nr) => {
      const Ut = Object.assign({}, ir);
      if (Ut.validator && (Ut.validator = ky(Ut.validator, false)), Ut.asyncValidator && (Ut.asyncValidator = ky(Ut.asyncValidator, true)), Ut.renderMessage) {
        const Ar = `__renderMessage__${nr}`;
        ft[Ar] = Ut.message, Ut.message = Ar, Ft[Ar] = Ut.renderMessage;
      }
      return Ut;
    }), $t = _t.filter((ir) => ir.level !== "warning"), Qt = _t.filter((ir) => ir.level === "warning"), Lt = { valid: true, errors: void 0, warnings: void 0 };
    if (!_t.length) return Lt;
    const zt = lt ?? "__n_no_path__", It = new nc({ [zt]: $t }), At = new nc({ [zt]: Qt }), { validateMessages: mr } = (d == null ? void 0 : d.props) || {};
    mr && (It.messages(mr), At.messages(mr));
    const gr = (ir) => {
      O.value = ir.map((nr) => {
        const Ut = (nr == null ? void 0 : nr.message) || "";
        return { key: Ut, render: () => Ut.startsWith("__renderMessage__") ? Ft[Ut]() : Ut };
      }), ir.forEach((nr) => {
        var Ut;
        !((Ut = nr.message) === null || Ut === void 0) && Ut.startsWith("__renderMessage__") && (nr.message = ft[nr.message]);
      });
    };
    if ($t.length) {
      const ir = yield new Promise((nr) => {
        It.validate({ [zt]: dt }, yt, nr);
      });
      (ir == null ? void 0 : ir.length) && (Lt.valid = false, Lt.errors = ir, gr(ir));
    }
    if (Qt.length && !Lt.errors) {
      const ir = yield new Promise((nr) => {
        At.validate({ [zt]: dt }, yt, nr);
      });
      (ir == null ? void 0 : ir.length) && (gr(ir), Lt.warnings = ir);
    }
    return !Lt.errors && !Lt.warnings ? ee() : (m.value = !!Lt.errors, s.value = !!Lt.warnings), Lt;
  });
  function te() {
    ie("blur");
  }
  function re() {
    ie("change");
  }
  function X() {
    ie("focus");
  }
  function Se() {
    ie("input");
  }
  function pe(Qe, ut) {
    return Sy(this, void 0, void 0, function* () {
      let gt, yt, lt, et;
      return typeof Qe == "string" ? (gt = Qe, yt = ut) : Qe !== null && typeof Qe == "object" && (gt = Qe.trigger, yt = Qe.callback, lt = Qe.shouldRuleBeApplied, et = Qe.options), yield new Promise((dt, Ft) => {
        ie(gt, lt, et).then(({ valid: ft, errors: _t, warnings: $t }) => {
          ft ? (yt && yt(void 0, { warnings: $t }), dt({ warnings: $t })) : (yt && yt(_t, { warnings: $t }), Ft(_t));
        });
      });
    });
  }
  Zr(Y2, { path: Bt(r, "path"), disabled: Y, mergedSize: f.mergedSize, mergedValidationStatus: g.mergedValidationStatus, restoreValidation: ee, handleContentBlur: te, handleContentChange: re, handleContentFocus: X, handleContentInput: Se });
  const oe = { validate: pe, restoreValidation: ee, internalValidate: ie }, fe = Re(null);
  ji(() => {
    if (!g.isAutoLabelWidth.value) return;
    const Qe = fe.value;
    if (Qe !== null) {
      const ut = Qe.style.whiteSpace;
      Qe.style.whiteSpace = "nowrap", Qe.style.width = "", d == null ? void 0 : d.deriveMaxChildLabelWidth(Number(getComputedStyle(Qe).width.slice(0, -2))), Qe.style.whiteSpace = ut;
    }
  });
  const _e = Me(() => {
    var Qe;
    const { value: ut } = M, { value: gt } = F, yt = gt === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: lt }, self: { labelTextColor: et, asteriskColor: dt, lineHeight: Ft, feedbackTextColor: ft, feedbackTextColorWarning: _t, feedbackTextColorError: $t, feedbackPadding: Qt, labelFontWeight: Lt, [Jt("labelHeight", ut)]: zt, [Jt("blankHeight", ut)]: It, [Jt("feedbackFontSize", ut)]: At, [Jt("feedbackHeight", ut)]: mr, [Jt("labelPadding", yt)]: gr, [Jt("labelTextAlign", yt)]: ir, [Jt(Jt("labelFontSize", gt), ut)]: nr } } = W.value;
    let Ut = (Qe = D.value) !== null && Qe !== void 0 ? Qe : ir;
    return gt === "top" && (Ut = Ut === "right" ? "flex-end" : "flex-start"), { "--n-bezier": lt, "--n-line-height": Ft, "--n-blank-height": It, "--n-label-font-size": nr, "--n-label-text-align": Ut, "--n-label-height": zt, "--n-label-padding": gr, "--n-label-font-weight": Lt, "--n-asterisk-color": dt, "--n-label-text-color": et, "--n-feedback-padding": Qt, "--n-feedback-font-size": At, "--n-feedback-height": mr, "--n-feedback-text-color": ft, "--n-feedback-text-color-warning": _t, "--n-feedback-text-color-error": $t };
  }), qe = l ? bi("form-item", Me(() => {
    var Qe;
    return `${M.value[0]}${F.value[0]}${((Qe = D.value) === null || Qe === void 0 ? void 0 : Qe[0]) || ""}`;
  }), _e, r) : void 0, Ve = Me(() => F.value === "left" && A.value === "left" && D.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: fe, mergedClsPrefix: i, mergedRequired: C, feedbackId: V, renderExplains: O, reverseColSpace: Ve }, g), f), oe), { cssVars: l ? void 0 : _e, themeClass: qe == null ? void 0 : qe.themeClass, onRender: qe == null ? void 0 : qe.onRender });
}, render() {
  const { $slots: r, mergedClsPrefix: i, mergedShowLabel: l, mergedShowRequireMark: d, mergedRequireMarkPlacement: f, onRender: g } = this, m = d !== void 0 ? d : this.mergedRequired;
  g == null ? void 0 : g();
  const s = () => {
    const C = this.$slots.label ? this.$slots.label() : this.label;
    if (!C) return null;
    const P = B("span", { class: `${i}-form-item-label__text` }, C), M = m ? B("span", { class: `${i}-form-item-label__asterisk` }, f !== "left" ? "\xA0*" : "*\xA0") : f === "right-hanging" && B("span", { class: `${i}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: F } = this;
    return B("label", Object.assign({}, F, { class: [F == null ? void 0 : F.class, `${i}-form-item-label`, `${i}-form-item-label--${f}-mark`, this.reverseColSpace && `${i}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), f === "left" ? [M, P] : [P, M]);
  };
  return B("div", { class: [`${i}-form-item`, this.themeClass, `${i}-form-item--${this.mergedSize}-size`, `${i}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${i}-form-item--auto-label-width`, !l && `${i}-form-item--no-label`], style: this.cssVars }, l && s(), B("div", { class: [`${i}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${i}-form-item-blank--${this.mergedValidationStatus}`], style: this.contentStyle }, r), this.mergedShowFeedback ? B("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${i}-form-item-feedback-wrapper`, this.feedbackClass] }, B(Io, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: C } = this;
    return Ii(r.feedback, (P) => {
      var M;
      const { feedback: F } = this, D = P || F ? B("div", { key: "__feedback__", class: `${i}-form-item-feedback__line` }, P || F) : this.renderExplains.length ? (M = this.renderExplains) === null || M === void 0 ? void 0 : M.map(({ key: A, render: O }) => B("div", { key: A, class: `${i}-form-item-feedback__line` }, O())) : null;
      return D ? C === "warning" ? B("div", { key: "controlled-warning", class: `${i}-form-item-feedback ${i}-form-item-feedback--warning` }, D) : C === "error" ? B("div", { key: "controlled-error", class: `${i}-form-item-feedback ${i}-form-item-feedback--error` }, D) : C === "success" ? B("div", { key: "controlled-success", class: `${i}-form-item-feedback ${i}-form-item-feedback--success` }, D) : B("div", { key: "controlled-default", class: `${i}-form-item-feedback` }, D) : null;
    });
  } })) : null);
} }), Py = 1, jb = Rn("n-grid"), Nb = 1, r5 = { span: { type: [Number, String], default: Nb }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, i5 = ot({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: r5, setup() {
  const { isSsrRef: r, xGapRef: i, itemStyleRef: l, overflowRef: d, layoutShiftDisabledRef: f } = pr(jb), g = Qd();
  return { overflow: d, itemStyle: l, layoutShiftDisabled: f, mergedXGap: Me(() => Nn(i.value || 0)), deriveStyle: () => {
    r.value;
    const { privateSpan: m = Nb, privateShow: s = true, privateColStart: C = void 0, privateOffset: P = 0 } = g.vnode.props, { value: M } = i, F = Nn(M || 0);
    return { display: s ? "" : "none", gridColumn: `${C ?? `span ${m}`} / span ${m}`, marginLeft: P ? `calc((100% - (${m} - 1) * ${F}) / ${m} * ${P} + ${F} * ${P})` : "" };
  } };
}, render() {
  var r, i;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: d, mergedXGap: f } = this;
    return B("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: d ? `calc((100% - (${l} - 1) * ${f}) / ${l} * ${d} + ${f} * ${d})` : "" } }, this.$slots);
  }
  return B("div", { style: [this.itemStyle, this.deriveStyle()] }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r, { overflow: this.overflow }));
} }), n5 = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, Vb = 24, Um = "__ssr__", o5 = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: Vb }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, a5 = ot({ name: "Grid", inheritAttrs: false, props: o5, setup(r) {
  const { mergedClsPrefixRef: i, mergedBreakpointsRef: l } = Mr(r), d = /^\d+$/, f = Re(void 0), g = tS((l == null ? void 0 : l.value) || n5), m = yi(() => !!(r.itemResponsive || !d.test(r.cols.toString()) || !d.test(r.xGap.toString()) || !d.test(r.yGap.toString()))), s = Me(() => {
    if (m.value) return r.responsive === "self" ? f.value : g.value;
  }), C = yi(() => {
    var W;
    return (W = Number(Uu(r.cols.toString(), s.value))) !== null && W !== void 0 ? W : Vb;
  }), P = yi(() => Uu(r.xGap.toString(), s.value)), M = yi(() => Uu(r.yGap.toString(), s.value)), F = (W) => {
    f.value = W.contentRect.width;
  }, D = (W) => {
    tp(F, W);
  }, A = Re(false), O = Me(() => {
    if (r.responsive === "self") return D;
  }), V = Re(false), Y = Re();
  return ji(() => {
    const { value: W } = Y;
    W && W.hasAttribute(Um) && (W.removeAttribute(Um), V.value = true);
  }), Zr(jb, { layoutShiftDisabledRef: Bt(r, "layoutShiftDisabled"), isSsrRef: V, itemStyleRef: Bt(r, "itemStyle"), xGapRef: P, overflowRef: A }), { isSsr: !op, contentEl: Y, mergedClsPrefix: i, style: Me(() => r.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${r.cols}, minmax(0, 1fr))`, columnGap: Nn(r.xGap), rowGap: Nn(r.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${C.value}, minmax(0, 1fr))`, columnGap: Nn(P.value), rowGap: Nn(M.value) }), isResponsive: m, responsiveQuery: s, responsiveCols: C, handleResize: O, overflow: A };
}, render() {
  if (this.layoutShiftDisabled) return B("div", Cs({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const r = () => {
    var i, l, d, f, g, m, s;
    this.overflow = false;
    const C = El(lp(this)), P = [], { collapsed: M, collapsedRows: F, responsiveCols: D, responsiveQuery: A } = this;
    C.forEach((ee) => {
      var ie, te, re, X, Se;
      if (((ie = ee == null ? void 0 : ee.type) === null || ie === void 0 ? void 0 : ie.__GRID_ITEM__) !== true) return;
      if (fS(ee)) {
        const fe = sg(ee);
        fe.props ? fe.props.privateShow = false : fe.props = { privateShow: false }, P.push({ child: fe, rawChildSpan: 0 });
        return;
      }
      ee.dirs = ((te = ee.dirs) === null || te === void 0 ? void 0 : te.filter(({ dir: fe }) => fe !== Qa)) || null, ((re = ee.dirs) === null || re === void 0 ? void 0 : re.length) === 0 && (ee.dirs = null);
      const pe = sg(ee), oe = Number((Se = Uu((X = pe.props) === null || X === void 0 ? void 0 : X.span, A)) !== null && Se !== void 0 ? Se : Py);
      oe !== 0 && P.push({ child: pe, rawChildSpan: oe });
    });
    let O = 0;
    const V = (i = P[P.length - 1]) === null || i === void 0 ? void 0 : i.child;
    if (V == null ? void 0 : V.props) {
      const ee = (l = V.props) === null || l === void 0 ? void 0 : l.suffix;
      ee !== void 0 && ee !== false && (O = Number((f = Uu((d = V.props) === null || d === void 0 ? void 0 : d.span, A)) !== null && f !== void 0 ? f : Py), V.props.privateSpan = O, V.props.privateColStart = D + 1 - O, V.props.privateShow = (g = V.props.privateShow) !== null && g !== void 0 ? g : true);
    }
    let Y = 0, W = false;
    for (const { child: ee, rawChildSpan: ie } of P) {
      if (W && (this.overflow = true), !W) {
        const te = Number((s = Uu((m = ee.props) === null || m === void 0 ? void 0 : m.offset, A)) !== null && s !== void 0 ? s : 0), re = Math.min(ie + te, D);
        if (ee.props ? (ee.props.privateSpan = re, ee.props.privateOffset = te) : ee.props = { privateSpan: re, privateOffset: te }, M) {
          const X = Y % D;
          re + X > D && (Y += D - X), re + Y + O > F * D ? W = true : Y += re;
        }
      }
      W && (ee.props ? ee.props.privateShow !== true && (ee.props.privateShow = false) : ee.props = { privateShow: false });
    }
    return B("div", Cs({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [Um]: this.isSsr || void 0 }, this.$attrs), P.map(({ child: ee }) => ee));
  };
  return this.isResponsive && this.responsive === "self" ? B(Pl, { onResize: this.handleResize }, { default: r }) : r();
} });
function s5() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function l5() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function u5() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const Jg = Object.assign(Object.assign({}, rr.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), Ub = Rn("n-image"), c5 = Ge([Ge("body >", [ce("image-container", "position: fixed;")]), ce("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), ce("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [Zf()]), ce("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ce("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), Zf()]), ce("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [ip()]), ce("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), ce("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [pi("preview-disabled", `
 cursor: pointer;
 `), Ge("img", `
 border-radius: inherit;
 `)])]), Pf = 32, d5 = Object.assign(Object.assign({}, Jg), { src: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onNext: Function, onPrev: Function, onClose: [Function, Array] }), qb = ot({ name: "ImagePreview", props: d5, setup(r) {
  const { src: i } = t2(r), { mergedClsPrefixRef: l } = Mr(r), d = rr("Image", "-image", c5, K2, r, l);
  let f = null;
  const g = Re(null), m = Re(null), s = Re(false), { localeRef: C } = ts("Image"), P = Re(r.defaultShow), M = Bt(r, "show"), F = Hi(M, P);
  function D() {
    const { value: Ee } = m;
    if (!f || !Ee) return;
    const { style: nt } = Ee, Be = f.getBoundingClientRect(), Ye = Be.left + Be.width / 2, ht = Be.top + Be.height / 2;
    nt.transformOrigin = `${Ye}px ${ht}px`;
  }
  function A(Ee) {
    var nt, Be;
    switch (Ee.key) {
      case " ":
        Ee.preventDefault();
        break;
      case "ArrowLeft":
        (nt = r.onPrev) === null || nt === void 0 || nt.call(r);
        break;
      case "ArrowRight":
        (Be = r.onNext) === null || Be === void 0 || Be.call(r);
        break;
      case "ArrowUp":
        Ee.preventDefault(), Lt();
        break;
      case "ArrowDown":
        Ee.preventDefault(), zt();
        break;
      case "Escape":
        mr();
        break;
    }
  }
  function O(Ee) {
    const { onUpdateShow: nt, "onUpdate:show": Be } = r;
    nt && jt(nt, Ee), Be && jt(Be, Ee), P.value = Ee, s.value = true;
  }
  Ht(F, (Ee) => {
    Ee ? En("keydown", document, A) : Xn("keydown", document, A);
  }), Sn(() => {
    Xn("keydown", document, A);
  });
  let V = 0, Y = 0, W = 0, ee = 0, ie = 0, te = 0, re = 0, X = 0, Se = false;
  function pe(Ee) {
    const { clientX: nt, clientY: Be } = Ee;
    W = nt - V, ee = Be - Y, tp(At);
  }
  function oe(Ee) {
    const { mouseUpClientX: nt, mouseUpClientY: Be, mouseDownClientX: Ye, mouseDownClientY: ht } = Ee, bt = Ye - nt, tt = ht - Be, mt = `vertical${tt > 0 ? "Top" : "Bottom"}`, Kt = `horizontal${bt > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: mt, moveHorizontalDirection: Kt, deltaHorizontal: bt, deltaVertical: tt };
  }
  function fe(Ee) {
    const { value: nt } = g;
    if (!nt) return { offsetX: 0, offsetY: 0 };
    const Be = nt.getBoundingClientRect(), { moveVerticalDirection: Ye, moveHorizontalDirection: ht, deltaHorizontal: bt, deltaVertical: tt } = Ee || {};
    let mt = 0, Kt = 0;
    return Be.width <= window.innerWidth ? mt = 0 : Be.left > 0 ? mt = (Be.width - window.innerWidth) / 2 : Be.right < window.innerWidth ? mt = -(Be.width - window.innerWidth) / 2 : ht === "horizontalRight" ? mt = Math.min((Be.width - window.innerWidth) / 2, ie - (bt ?? 0)) : mt = Math.max(-((Be.width - window.innerWidth) / 2), ie - (bt ?? 0)), Be.height <= window.innerHeight ? Kt = 0 : Be.top > 0 ? Kt = (Be.height - window.innerHeight) / 2 : Be.bottom < window.innerHeight ? Kt = -(Be.height - window.innerHeight) / 2 : Ye === "verticalBottom" ? Kt = Math.min((Be.height - window.innerHeight) / 2, te - (tt ?? 0)) : Kt = Math.max(-((Be.height - window.innerHeight) / 2), te - (tt ?? 0)), { offsetX: mt, offsetY: Kt };
  }
  function _e(Ee) {
    Xn("mousemove", document, pe), Xn("mouseup", document, _e);
    const { clientX: nt, clientY: Be } = Ee;
    Se = false;
    const Ye = oe({ mouseUpClientX: nt, mouseUpClientY: Be, mouseDownClientX: re, mouseDownClientY: X }), ht = fe(Ye);
    W = ht.offsetX, ee = ht.offsetY, At();
  }
  const qe = pr(Ub, null);
  function Ve(Ee) {
    var nt, Be;
    if ((Be = (nt = qe == null ? void 0 : qe.previewedImgPropsRef.value) === null || nt === void 0 ? void 0 : nt.onMousedown) === null || Be === void 0 || Be.call(nt, Ee), Ee.button !== 0) return;
    const { clientX: Ye, clientY: ht } = Ee;
    Se = true, V = Ye - W, Y = ht - ee, ie = W, te = ee, re = Ye, X = ht, At(), En("mousemove", document, pe), En("mouseup", document, _e);
  }
  const Qe = 1.5;
  let ut = 0, gt = 1, yt = 0;
  function lt(Ee) {
    var nt, Be;
    (Be = (nt = qe == null ? void 0 : qe.previewedImgPropsRef.value) === null || nt === void 0 ? void 0 : nt.onDblclick) === null || Be === void 0 || Be.call(nt, Ee);
    const Ye = Qt();
    gt = gt === Ye ? 1 : Ye, At();
  }
  function et() {
    gt = 1, ut = 0;
  }
  function dt() {
    var Ee;
    et(), yt = 0, (Ee = r.onPrev) === null || Ee === void 0 || Ee.call(r);
  }
  function Ft() {
    var Ee;
    et(), yt = 0, (Ee = r.onNext) === null || Ee === void 0 || Ee.call(r);
  }
  function ft() {
    yt -= 90, At();
  }
  function _t() {
    yt += 90, At();
  }
  function $t() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: nt, innerHeight: Be } = window, Ye = Math.max(1, Ee.naturalHeight / (Be - Pf)), ht = Math.max(1, Ee.naturalWidth / (nt - Pf));
    return Math.max(3, Ye * 2, ht * 2);
  }
  function Qt() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: nt, innerHeight: Be } = window, Ye = Ee.naturalHeight / (Be - Pf), ht = Ee.naturalWidth / (nt - Pf);
    return Ye < 1 && ht < 1 ? 1 : Math.max(Ye, ht);
  }
  function Lt() {
    const Ee = $t();
    gt < Ee && (ut += 1, gt = Math.min(Ee, Math.pow(Qe, ut)), At());
  }
  function zt() {
    if (gt > 0.5) {
      const Ee = gt;
      ut -= 1, gt = Math.max(0.5, Math.pow(Qe, ut));
      const nt = Ee - gt;
      At(false);
      const Be = fe();
      gt += nt, At(false), gt -= nt, W = Be.offsetX, ee = Be.offsetY, At();
    }
  }
  function It() {
    const Ee = i.value;
    Ee && xb(Ee, void 0);
  }
  function At(Ee = true) {
    var nt;
    const { value: Be } = g;
    if (!Be) return;
    const { style: Ye } = Be, ht = In((nt = qe == null ? void 0 : qe.previewedImgPropsRef.value) === null || nt === void 0 ? void 0 : nt.style);
    let bt = "";
    if (typeof ht == "string") bt = `${ht};`;
    else for (const mt in ht) bt += `${y3(mt)}: ${ht[mt]};`;
    const tt = `transform-origin: center; transform: translateX(${W}px) translateY(${ee}px) rotate(${yt}deg) scale(${gt});`;
    Se ? Ye.cssText = `${bt}cursor: grabbing; transition: none;${tt}` : Ye.cssText = `${bt}cursor: grab;${tt}${Ee ? "" : "transition: none;"}`, Ee || Be.offsetHeight;
  }
  function mr() {
    if (F.value) {
      const { onClose: Ee } = r;
      Ee && jt(Ee), O(false), P.value = false;
    }
  }
  function gr() {
    gt = Qt(), ut = Math.ceil(Math.log(gt) / Math.log(Qe)), W = 0, ee = 0, At();
  }
  const ir = { setThumbnailEl: (Ee) => {
    f = Ee;
  } };
  function nr(Ee, nt) {
    if (r.showToolbarTooltip) {
      const { value: Be } = d;
      return B($_, { to: false, theme: Be.peers.Tooltip, themeOverrides: Be.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => C.value[nt], trigger: () => Ee });
    } else return Ee;
  }
  const Ut = Me(() => {
    const { common: { cubicBezierEaseInOut: Ee }, self: { toolbarIconColor: nt, toolbarBorderRadius: Be, toolbarBoxShadow: Ye, toolbarColor: ht } } = d.value;
    return { "--n-bezier": Ee, "--n-toolbar-icon-color": nt, "--n-toolbar-color": ht, "--n-toolbar-border-radius": Be, "--n-toolbar-box-shadow": Ye };
  }), { inlineThemeDisabled: Ar } = Mr(), wr = Ar ? bi("image-preview", void 0, Ut, r) : void 0;
  function Ct(Ee) {
    Ee.preventDefault();
  }
  return Object.assign({ clsPrefix: l, previewRef: g, previewWrapperRef: m, previewSrc: i, mergedShow: F, appear: ap(), displayed: s, previewedImgProps: qe == null ? void 0 : qe.previewedImgPropsRef, handleWheel: Ct, handlePreviewMousedown: Ve, handlePreviewDblclick: lt, syncTransformOrigin: D, handleAfterLeave: () => {
    et(), yt = 0, s.value = false;
  }, handleDragStart: (Ee) => {
    var nt, Be;
    (Be = (nt = qe == null ? void 0 : qe.previewedImgPropsRef.value) === null || nt === void 0 ? void 0 : nt.onDragstart) === null || Be === void 0 || Be.call(nt, Ee), Ee.preventDefault();
  }, zoomIn: Lt, zoomOut: zt, handleDownloadClick: It, rotateCounterclockwise: ft, rotateClockwise: _t, handleSwitchPrev: dt, handleSwitchNext: Ft, withTooltip: nr, resizeToOrignalImageSize: gr, cssVars: Ar ? void 0 : Ut, themeClass: wr == null ? void 0 : wr.themeClass, onRender: wr == null ? void 0 : wr.onRender, doUpdateShow: O, close: mr }, ir);
}, render() {
  var r, i;
  const { clsPrefix: l, renderToolbar: d, withTooltip: f } = this, g = f(B(Wr, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: s5 }), "tipPrevious"), m = f(B(Wr, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: l5 }), "tipNext"), s = f(B(Wr, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => B(hk, null) }), "tipCounterclockwise"), C = f(B(Wr, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => B(dk, null) }), "tipClockwise"), P = f(B(Wr, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => B(uk, null) }), "tipOriginalSize"), M = f(B(Wr, { clsPrefix: l, onClick: this.zoomOut }, { default: () => B(mk, null) }), "tipZoomOut"), F = f(B(Wr, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => B(wb, null) }), "tipDownload"), D = f(B(Wr, { clsPrefix: l, onClick: () => this.close() }, { default: u5 }), "tipClose"), A = f(B(Wr, { clsPrefix: l, onClick: this.zoomIn }, { default: () => B(pk, null) }), "tipZoomIn");
  return B(Hr, null, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r), B(V_, { show: this.mergedShow }, { default: () => {
    var O;
    return this.mergedShow || this.displayed ? ((O = this.onRender) === null || O === void 0 || O.call(this), ga(B("div", { ref: "containerRef", class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, B(Io, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-overlay`, onClick: () => this.close() }) : null }), this.showToolbar ? B(Io, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-toolbar` }, d ? d({ nodes: { prev: g, next: m, rotateCounterclockwise: s, rotateClockwise: C, resizeToOriginalSize: P, zoomOut: M, zoomIn: A, download: F, close: D } }) : B(Hr, null, this.onPrev ? B(Hr, null, g, m) : null, s, C, P, M, A, F, D)) : null }) : null, B(Io, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: V = {} } = this;
      return ga(B("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, B("img", Object.assign({}, V, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, V.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[Qa, this.mergedShow]]);
    } })), [[N_, { enabled: this.mergedShow }]])) : null;
  } }));
} }), Gb = Rn("n-image-group"), h5 = Object.assign(Object.assign({}, Jg), { srcList: Array, current: Number, defaultCurrent: { type: Number, default: 0 }, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], onUpdateCurrent: [Function, Array], "onUpdate:current": [Function, Array] }), f5 = ot({ name: "ImageGroup", props: h5, setup(r) {
  const { mergedClsPrefixRef: i } = Mr(r), l = `c${Dl()}`, d = Re(null), f = Re(r.defaultShow), g = Bt(r, "show"), m = Hi(g, f), s = Re(/* @__PURE__ */ new Map()), C = Me(() => {
    if (r.srcList) {
      const pe = /* @__PURE__ */ new Map();
      return r.srcList.forEach((oe, fe) => {
        pe.set(`p${fe}`, oe);
      }), pe;
    }
    return s.value;
  }), P = Me(() => Array.from(C.value.keys())), M = () => P.value.length;
  function F(pe, oe) {
    r.srcList && Xo("image-group", "`n-image` can't be placed inside `n-image-group` when image group's `src-list` prop is set.");
    const fe = `r${pe}`;
    return s.value.has(`r${fe}`) || s.value.set(fe, oe), function() {
      s.value.has(fe) || s.value.delete(fe);
    };
  }
  const D = Re(r.defaultCurrent), A = Bt(r, "current"), O = Hi(A, D), V = (pe) => {
    if (pe !== O.value) {
      const { onUpdateCurrent: oe, "onUpdate:current": fe } = r;
      oe && jt(oe, pe), fe && jt(fe, pe), D.value = pe;
    }
  }, Y = Me(() => P.value[O.value]), W = (pe) => {
    const oe = P.value.indexOf(pe);
    oe !== O.value && V(oe);
  }, ee = Me(() => C.value.get(Y.value));
  function ie(pe) {
    const { onUpdateShow: oe, "onUpdate:show": fe } = r;
    oe && jt(oe, pe), fe && jt(fe, pe), f.value = pe;
  }
  function te() {
    ie(false);
  }
  const re = Me(() => {
    const pe = (fe, _e) => {
      for (let qe = fe; qe <= _e; qe++) {
        const Ve = P.value[qe];
        if (C.value.get(Ve)) return qe;
      }
    }, oe = pe(O.value + 1, M() - 1);
    return oe === void 0 ? pe(0, O.value - 1) : oe;
  }), X = Me(() => {
    const pe = (fe, _e) => {
      for (let qe = fe; qe >= _e; qe--) {
        const Ve = P.value[qe];
        if (C.value.get(Ve)) return qe;
      }
    }, oe = pe(O.value - 1, 0);
    return oe === void 0 ? pe(M() - 1, O.value + 1) : oe;
  });
  function Se(pe) {
    var oe, fe;
    pe === 1 ? (X.value !== void 0 && V(re.value), (oe = r.onPreviewNext) === null || oe === void 0 || oe.call(r)) : (re.value !== void 0 && V(X.value), (fe = r.onPreviewPrev) === null || fe === void 0 || fe.call(r));
  }
  return Zr(Gb, { mergedClsPrefixRef: i, registerImageUrl: F, setThumbnailEl: (pe) => {
    var oe;
    (oe = d.value) === null || oe === void 0 || oe.setThumbnailEl(pe);
  }, toggleShow: (pe) => {
    ie(true), W(pe);
  }, groupId: l, renderToolbarRef: Bt(r, "renderToolbar") }), { mergedClsPrefix: i, previewInstRef: d, mergedShow: m, src: ee, onClose: te, next: () => {
    Se(1);
  }, prev: () => {
    Se(-1);
  } };
}, render() {
  return B(qb, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, src: this.src, show: this.mergedShow, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, onClose: this.onClose }, this.$slots);
} }), p5 = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, Jg);
let m5 = 0;
const Wb = ot({ name: "Image", props: p5, slots: Object, inheritAttrs: false, setup(r) {
  const i = Re(null), l = Re(false), d = Re(null), f = pr(Gb, null), { mergedClsPrefixRef: g } = f || Mr(r), m = Me(() => r.previewSrc || r.src), s = Re(false), C = m5++, P = () => {
    if (r.previewDisabled || l.value) return;
    if (f) {
      f.setThumbnailEl(i.value), f.toggleShow(`r${C}`);
      return;
    }
    const { value: V } = d;
    V && (V.setThumbnailEl(i.value), s.value = true);
  }, M = { click: () => {
    P();
  }, showPreview: P }, F = Re(!r.lazy);
  ji(() => {
    var V;
    (V = i.value) === null || V === void 0 || V.setAttribute("data-group-id", (f == null ? void 0 : f.groupId) || "");
  }), ji(() => {
    if (r.lazy && r.intersectionObserverOptions) {
      let V;
      const Y = vo(() => {
        V == null ? void 0 : V(), V = void 0, V = Zk(i.value, r.intersectionObserverOptions, F);
      });
      Sn(() => {
        Y(), V == null ? void 0 : V();
      });
    }
  }), vo(() => {
    var V;
    r.src || ((V = r.imgProps) === null || V === void 0 || V.src), l.value = false;
  }), vo((V) => {
    var Y;
    const W = (Y = f == null ? void 0 : f.registerImageUrl) === null || Y === void 0 ? void 0 : Y.call(f, C, m.value || "");
    V(() => {
      W == null ? void 0 : W();
    });
  });
  function D(V) {
    var Y, W;
    M.showPreview(), (W = (Y = r.imgProps) === null || Y === void 0 ? void 0 : Y.onClick) === null || W === void 0 || W.call(Y, V);
  }
  function A() {
    s.value = false;
  }
  const O = Re(false);
  return Zr(Ub, { previewedImgPropsRef: Bt(r, "previewedImgProps") }), Object.assign({ mergedClsPrefix: g, groupId: f == null ? void 0 : f.groupId, previewInstRef: d, imageRef: i, mergedPreviewSrc: m, showError: l, shouldStartLoading: F, loaded: O, mergedOnClick: (V) => {
    D(V);
  }, onPreviewClose: A, mergedOnError: (V) => {
    if (!F.value) return;
    l.value = true;
    const { onError: Y, imgProps: { onError: W } = {} } = r;
    Y == null ? void 0 : Y(V), W == null ? void 0 : W(V);
  }, mergedOnLoad: (V) => {
    const { onLoad: Y, imgProps: { onLoad: W } = {} } = r;
    Y == null ? void 0 : Y(V), W == null ? void 0 : W(V), O.value = true;
  }, previewShow: s }, M);
}, render() {
  var r, i;
  const { mergedClsPrefix: l, imgProps: d = {}, loaded: f, $attrs: g, lazy: m } = this, s = Kn(this.$slots.error, () => []), C = (i = (r = this.$slots).placeholder) === null || i === void 0 ? void 0 : i.call(r), P = this.src || d.src, M = this.showError && s.length ? s : B("img", Object.assign(Object.assign({}, d), { ref: "imageRef", width: this.width || d.width, height: this.height || d.height, src: this.showError ? this.fallbackSrc : m && this.intersectionObserverOptions ? this.shouldStartLoading ? P : void 0 : P, alt: this.alt || d.alt, "aria-label": this.alt || d.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: Gk && m && !this.intersectionObserverOptions ? "lazy" : "eager", style: [d.style || "", C && !f ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return B("div", Object.assign({}, g, { role: "none", class: [g.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? M : B(qb, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, src: this.mergedPreviewSrc, show: !this.previewDisabled && this.previewShow, onClose: this.onPreviewClose }, { default: () => M }), !f && C);
} }), g5 = Ge([ce("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), ce("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function v5(r) {
  return r == null || typeof r == "string" && r.trim() === "" ? null : Number(r);
}
function y5(r) {
  return r.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(r) || /^-?\d*$/.test(r)) || r === "-" || r === "-0";
}
function qm(r) {
  return r == null ? true : !Number.isNaN(r);
}
function Ty(r, i) {
  return typeof r != "number" ? "" : i === void 0 ? String(r) : r.toFixed(i);
}
function Gm(r) {
  if (r === null) return null;
  if (typeof r == "number") return r;
  {
    const i = Number(r);
    return Number.isNaN(i) ? null : i;
  }
}
const Iy = 800, My = 100, _5 = Object.assign(Object.assign({}, rr.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), Ey = ot({ name: "InputNumber", props: _5, slots: Object, setup(r) {
  const { mergedBorderedRef: i, mergedClsPrefixRef: l, mergedRtlRef: d } = Mr(r), f = rr("InputNumber", "-input-number", g5, J2, r, l), { localeRef: g } = ts("InputNumber"), m = ya(r), { mergedSizeRef: s, mergedDisabledRef: C, mergedStatusRef: P } = m, M = Re(null), F = Re(null), D = Re(null), A = Re(r.defaultValue), O = Bt(r, "value"), V = Hi(O, A), Y = Re(""), W = (Ct) => {
    const Ee = String(Ct).split(".")[1];
    return Ee ? Ee.length : 0;
  }, ee = (Ct) => {
    const Ee = [r.min, r.max, r.step, Ct].map((nt) => nt === void 0 ? 0 : W(nt));
    return Math.max(...Ee);
  }, ie = yi(() => {
    const { placeholder: Ct } = r;
    return Ct !== void 0 ? Ct : g.value.placeholder;
  }), te = yi(() => {
    const Ct = Gm(r.step);
    return Ct !== null ? Ct === 0 ? 1 : Math.abs(Ct) : 1;
  }), re = yi(() => {
    const Ct = Gm(r.min);
    return Ct !== null ? Ct : null;
  }), X = yi(() => {
    const Ct = Gm(r.max);
    return Ct !== null ? Ct : null;
  }), Se = () => {
    const { value: Ct } = V;
    if (qm(Ct)) {
      const { format: Ee, precision: nt } = r;
      Ee ? Y.value = Ee(Ct) : Ct === null || nt === void 0 || W(Ct) > nt ? Y.value = Ty(Ct, void 0) : Y.value = Ty(Ct, nt);
    } else Y.value = String(Ct);
  };
  Se();
  const pe = (Ct) => {
    const { value: Ee } = V;
    if (Ct === Ee) {
      Se();
      return;
    }
    const { "onUpdate:value": nt, onUpdateValue: Be, onChange: Ye } = r, { nTriggerFormInput: ht, nTriggerFormChange: bt } = m;
    Ye && jt(Ye, Ct), Be && jt(Be, Ct), nt && jt(nt, Ct), A.value = Ct, ht(), bt();
  }, oe = ({ offset: Ct, doUpdateIfValid: Ee, fixPrecision: nt, isInputing: Be }) => {
    const { value: Ye } = Y;
    if (Be && y5(Ye)) return false;
    const ht = (r.parse || v5)(Ye);
    if (ht === null) return Ee && pe(null), null;
    if (qm(ht)) {
      const bt = W(ht), { precision: tt } = r;
      if (tt !== void 0 && tt < bt && !nt) return false;
      let mt = Number.parseFloat((ht + Ct).toFixed(tt ?? ee(ht)));
      if (qm(mt)) {
        const { value: Kt } = X, { value: Qr } = re;
        if (Kt !== null && mt > Kt) {
          if (!Ee || Be) return false;
          mt = Kt;
        }
        if (Qr !== null && mt < Qr) {
          if (!Ee || Be) return false;
          mt = Qr;
        }
        return r.validator && !r.validator(mt) ? false : (Ee && pe(mt), mt);
      }
    }
    return false;
  }, fe = yi(() => oe({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), _e = yi(() => {
    const { value: Ct } = V;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = te;
    return oe({ offset: -Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), qe = yi(() => {
    const { value: Ct } = V;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = te;
    return oe({ offset: +Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function Ve(Ct) {
    const { onFocus: Ee } = r, { nTriggerFormFocus: nt } = m;
    Ee && jt(Ee, Ct), nt();
  }
  function Qe(Ct) {
    var Ee, nt;
    if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
    const Be = oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if (Be !== false) {
      const bt = (nt = M.value) === null || nt === void 0 ? void 0 : nt.inputElRef;
      bt && (bt.value = String(Be || "")), V.value === Be && Se();
    } else Se();
    const { onBlur: Ye } = r, { nTriggerFormBlur: ht } = m;
    Ye && jt(Ye, Ct), ht(), Vn(() => {
      Se();
    });
  }
  function ut(Ct) {
    const { onClear: Ee } = r;
    Ee && jt(Ee, Ct);
  }
  function gt() {
    const { value: Ct } = qe;
    if (!Ct) {
      It();
      return;
    }
    const { value: Ee } = V;
    if (Ee === null) r.validator || pe(dt());
    else {
      const { value: nt } = te;
      oe({ offset: nt, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function yt() {
    const { value: Ct } = _e;
    if (!Ct) {
      Lt();
      return;
    }
    const { value: Ee } = V;
    if (Ee === null) r.validator || pe(dt());
    else {
      const { value: nt } = te;
      oe({ offset: -nt, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const lt = Ve, et = Qe;
  function dt() {
    if (r.validator) return null;
    const { value: Ct } = re, { value: Ee } = X;
    return Ct !== null ? Math.max(0, Ct) : Ee !== null ? Math.min(0, Ee) : 0;
  }
  function Ft(Ct) {
    ut(Ct), pe(null);
  }
  function ft(Ct) {
    var Ee, nt, Be;
    !((Ee = D.value) === null || Ee === void 0) && Ee.$el.contains(Ct.target) && Ct.preventDefault(), !((nt = F.value) === null || nt === void 0) && nt.$el.contains(Ct.target) && Ct.preventDefault(), (Be = M.value) === null || Be === void 0 || Be.activate();
  }
  let _t = null, $t = null, Qt = null;
  function Lt() {
    Qt && (window.clearTimeout(Qt), Qt = null), _t && (window.clearInterval(_t), _t = null);
  }
  let zt = null;
  function It() {
    zt && (window.clearTimeout(zt), zt = null), $t && (window.clearInterval($t), $t = null);
  }
  function At() {
    Lt(), Qt = window.setTimeout(() => {
      _t = window.setInterval(() => {
        yt();
      }, My);
    }, Iy), En("mouseup", document, Lt, { once: true });
  }
  function mr() {
    It(), zt = window.setTimeout(() => {
      $t = window.setInterval(() => {
        gt();
      }, My);
    }, Iy), En("mouseup", document, It, { once: true });
  }
  const gr = () => {
    $t || gt();
  }, ir = () => {
    _t || yt();
  };
  function nr(Ct) {
    var Ee, nt;
    if (Ct.key === "Enter") {
      if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
      oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((nt = M.value) === null || nt === void 0 || nt.deactivate());
    } else if (Ct.key === "ArrowUp") {
      if (!qe.value || r.keyboard.ArrowUp === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && gt();
    } else if (Ct.key === "ArrowDown") {
      if (!_e.value || r.keyboard.ArrowDown === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && yt();
    }
  }
  function Ut(Ct) {
    Y.value = Ct, r.updateValueOnInput && !r.format && !r.parse && r.precision === void 0 && oe({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  Ht(V, () => {
    Se();
  });
  const Ar = { focus: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.focus();
  }, blur: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.blur();
  }, select: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.select();
  } }, wr = Un("InputNumber", d, l);
  return Object.assign(Object.assign({}, Ar), { rtlEnabled: wr, inputInstRef: M, minusButtonInstRef: F, addButtonInstRef: D, mergedClsPrefix: l, mergedBordered: i, uncontrolledValue: A, mergedValue: V, mergedPlaceholder: ie, displayedValueInvalid: fe, mergedSize: s, mergedDisabled: C, displayedValue: Y, addable: qe, minusable: _e, mergedStatus: P, handleFocus: lt, handleBlur: et, handleClear: Ft, handleMouseDown: ft, handleAddClick: gr, handleMinusClick: ir, handleAddMousedown: mr, handleMinusMousedown: At, handleKeyDown: nr, handleUpdateDisplayedValue: Ut, mergedTheme: f, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: Me(() => {
    const { self: { iconColorDisabled: Ct } } = f.value, [Ee, nt, Be, Ye] = Go(Ct);
    return { textColorTextDisabled: `rgb(${Ee}, ${nt}, ${Be})`, opacityDisabled: `${Ye}` };
  }) });
}, render() {
  const { mergedClsPrefix: r, $slots: i } = this, l = () => B(Jv, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => Kn(i["minus-icon"], () => [B(Wr, { clsPrefix: r }, { default: () => B(lk, null) })]) }), d = () => B(Jv, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => Kn(i["add-icon"], () => [B(Wr, { clsPrefix: r }, { default: () => B(up, null) })]) });
  return B("div", { class: [`${r}-input-number`, this.rtlEnabled && `${r}-input-number--rtl`] }, B(mo, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var f;
    return this.showButton && this.buttonPlacement === "both" ? [l(), Ii(i.prefix, (g) => g ? B("span", { class: `${r}-input-number-prefix` }, g) : null)] : (f = i.prefix) === null || f === void 0 ? void 0 : f.call(i);
  }, suffix: () => {
    var f;
    return this.showButton ? [Ii(i.suffix, (g) => g ? B("span", { class: `${r}-input-number-suffix` }, g) : null), this.buttonPlacement === "right" ? l() : null, d()] : (f = i.suffix) === null || f === void 0 ? void 0 : f.call(i);
  } }));
} }), b5 = Ge([ce("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ue("show-divider", [ce("list-item", [Ge("&:not(:last-child)", [Fe("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ue("clickable", [ce("list-item", `
 cursor: pointer;
 `)]), Ue("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ue("hoverable", [ce("list-item", `
 border-radius: var(--n-border-radius);
 `, [Ge("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Fe("divider", `
 background-color: transparent;
 `)])])]), Ue("bordered, hoverable", [ce("list-item", `
 padding: 12px 20px;
 `), Fe("header, footer", `
 padding: 12px 20px;
 `)]), Fe("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [Ge("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), ce("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Fe("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Fe("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Fe("main", `
 flex: 1;
 `), Fe("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), A_(ce("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), D_(ce("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), x5 = Object.assign(Object.assign({}, rr.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), Zb = Rn("n-list"), dp = ot({ name: "List", props: x5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Mr(r), f = Un("List", d, i), g = rr("List", "-list", b5, Q2, r, i);
  Zr(Zb, { showDividerRef: Bt(r, "showDivider"), mergedClsPrefixRef: i });
  const m = Me(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: P, textColor: M, color: F, colorModal: D, colorPopover: A, borderColor: O, borderColorModal: V, borderColorPopover: Y, borderRadius: W, colorHover: ee, colorHoverModal: ie, colorHoverPopover: te } } = g.value;
    return { "--n-font-size": P, "--n-bezier": C, "--n-text-color": M, "--n-color": F, "--n-border-radius": W, "--n-border-color": O, "--n-border-color-modal": V, "--n-border-color-popover": Y, "--n-color-modal": D, "--n-color-popover": A, "--n-color-hover": ee, "--n-color-hover-modal": ie, "--n-color-hover-popover": te };
  }), s = l ? bi("list", void 0, m, r) : void 0;
  return { mergedClsPrefix: i, rtlEnabled: f, cssVars: l ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { $slots: i, mergedClsPrefix: l, onRender: d } = this;
  return d == null ? void 0 : d(), B("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, i.header ? B("div", { class: `${l}-list__header` }, i.header()) : null, (r = i.default) === null || r === void 0 ? void 0 : r.call(i), i.footer ? B("div", { class: `${l}-list__footer` }, i.footer()) : null);
} }), hp = ot({ name: "ListItem", slots: Object, setup() {
  const r = pr(Zb, null);
  return r || Xo("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: r.showDividerRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return B("li", { class: `${i}-list-item` }, r.prefix ? B("div", { class: `${i}-list-item__prefix` }, r.prefix()) : null, r.default ? B("div", { class: `${i}-list-item__main` }, r) : null, r.suffix ? B("div", { class: `${i}-list-item__suffix` }, r.suffix()) : null, this.showDivider && B("div", { class: `${i}-list-item__divider` }));
} }), Hb = Rn("n-popconfirm"), Xb = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, Ry = jd(Xb), w5 = ot({ name: "NPopconfirmPanel", props: Xb, setup(r) {
  const { localeRef: i } = ts("Popconfirm"), { inlineThemeDisabled: l } = Mr(), { mergedClsPrefixRef: d, mergedThemeRef: f, props: g } = pr(Hb), m = Me(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: P, iconSize: M, iconColor: F } } = f.value;
    return { "--n-bezier": C, "--n-font-size": P, "--n-icon-size": M, "--n-icon-color": F };
  }), s = l ? bi("popconfirm-panel", void 0, m, g) : void 0;
  return Object.assign(Object.assign({}, ts("Popconfirm")), { mergedClsPrefix: d, cssVars: l ? void 0 : m, localizedPositiveText: Me(() => r.positiveText || i.value.positiveText), localizedNegativeText: Me(() => r.negativeText || i.value.negativeText), positiveButtonProps: Bt(g, "positiveButtonProps"), negativeButtonProps: Bt(g, "negativeButtonProps"), handlePositiveClick(C) {
    r.onPositiveClick(C);
  }, handleNegativeClick(C) {
    r.onNegativeClick(C);
  }, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender });
}, render() {
  var r;
  const { mergedClsPrefix: i, showIcon: l, $slots: d } = this, f = Kn(d.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && B(Nr, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && B(Nr, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${i}-popconfirm__panel`, this.themeClass], style: this.cssVars }, Ii(d.default, (g) => l || g ? B("div", { class: `${i}-popconfirm__body` }, l ? B("div", { class: `${i}-popconfirm__icon` }, Kn(d.icon, () => [B(Wr, { clsPrefix: i }, { default: () => B(Wg, null) })])) : null, g) : null), f ? B("div", { class: [`${i}-popconfirm__action`] }, f) : null);
} }), C5 = ce("popconfirm", [Fe("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Fe("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Fe("action", `
 display: flex;
 justify-content: flex-end;
 `, [Ge("&:not(:first-child)", "margin-top: 8px"), ce("button", [Ge("&:not(:last-child)", "margin-right: 8px;")])])]), S5 = Object.assign(Object.assign(Object.assign({}, rr.props), tC), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), k5 = ot({ name: "Popconfirm", props: S5, slots: Object, __popover__: true, setup(r) {
  const { mergedClsPrefixRef: i } = Mr(), l = rr("Popconfirm", "-popconfirm", C5, eC, r, i), d = Re(null);
  function f(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onPositiveClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((F) => {
      var D;
      F !== false && ((D = d.value) === null || D === void 0 || D.setShow(false), M && jt(M, false));
    });
  }
  function g(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onNegativeClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((F) => {
      var D;
      F !== false && ((D = d.value) === null || D === void 0 || D.setShow(false), M && jt(M, false));
    });
  }
  return Zr(Hb, { mergedThemeRef: l, mergedClsPrefixRef: i, props: r }), { setShow(s) {
    var C;
    (C = d.value) === null || C === void 0 || C.setShow(s);
  }, syncPosition() {
    var s;
    (s = d.value) === null || s === void 0 || s.syncPosition();
  }, mergedTheme: l, popoverInstRef: d, handlePositiveClick: f, handleNegativeClick: g };
}, render() {
  const { $slots: r, $props: i, mergedTheme: l } = this;
  return B(Ug, Object.assign({}, W_(i, Ry), { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: r.trigger, default: () => {
    const d = lg(i, Ry);
    return B(w5, Object.assign({}, d, { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), r);
  } });
} }), P5 = { success: B(X_, null), error: B(H_, null), warning: B(Wg, null), info: B(Z_, null) }, T5 = ot({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(r, { slots: i }) {
  const l = Me(() => {
    const g = "gradient", { fillColor: m } = r;
    return typeof m == "object" ? `${g}-${rC(JSON.stringify(m))}` : g;
  });
  function d(g, m, s, C) {
    const { gapDegree: P, viewBoxWidth: M, strokeWidth: F } = r, D = 50, A = 0, O = D, V = 0, Y = 2 * D, W = 50 + F / 2, ee = `M ${W},${W} m ${A},${O}
      a ${D},${D} 0 1 1 ${V},${-Y}
      a ${D},${D} 0 1 1 ${-V},${Y}`, ie = Math.PI * 2 * D, te = { stroke: C === "rail" ? s : typeof r.fillColor == "object" ? `url(#${l.value})` : s, strokeDasharray: `${g / 100 * (ie - P)}px ${M * 8}px`, strokeDashoffset: `-${P / 2}px`, transformOrigin: m ? "center" : void 0, transform: m ? `rotate(${m}deg)` : void 0 };
    return { pathString: ee, pathStyle: te };
  }
  const f = () => {
    const g = typeof r.fillColor == "object", m = g ? r.fillColor.stops[0] : "", s = g ? r.fillColor.stops[1] : "";
    return g && B("defs", null, B("linearGradient", { id: l.value, x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, B("stop", { offset: "0%", "stop-color": m }), B("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: g, railColor: m, strokeWidth: s, offsetDegree: C, status: P, percentage: M, showIndicator: F, indicatorTextColor: D, unit: A, gapOffsetDegree: O, clsPrefix: V } = r, { pathString: Y, pathStyle: W } = d(100, 0, m, "rail"), { pathString: ee, pathStyle: ie } = d(M, C, g, "fill"), te = 100 + s;
    return B("div", { class: `${V}-progress-content`, role: "none" }, B("div", { class: `${V}-progress-graph`, "aria-hidden": true }, B("div", { class: `${V}-progress-graph-circle`, style: { transform: O ? `rotate(${O}deg)` : void 0 } }, B("svg", { viewBox: `0 0 ${te} ${te}` }, f(), B("g", null, B("path", { class: `${V}-progress-graph-circle-rail`, d: Y, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: W })), B("g", null, B("path", { class: [`${V}-progress-graph-circle-fill`, M === 0 && `${V}-progress-graph-circle-fill--empty`], d: ee, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: ie }))))), F ? B("div", null, i.default ? B("div", { class: `${V}-progress-custom-content`, role: "none" }, i.default()) : P !== "default" ? B("div", { class: `${V}-progress-icon`, "aria-hidden": true }, B(Wr, { clsPrefix: V }, { default: () => P5[P] })) : B("div", { class: `${V}-progress-text`, style: { color: D }, role: "none" }, B("span", { class: `${V}-progress-text__percentage` }, M), B("span", { class: `${V}-progress-text__unit` }, A))) : null);
  };
} }), I5 = { success: B(X_, null), error: B(H_, null), warning: B(Wg, null), info: B(Z_, null) }, M5 = ot({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(r, { slots: i }) {
  const l = Me(() => Wo(r.height)), d = Me(() => {
    var m, s;
    return typeof r.fillColor == "object" ? `linear-gradient(to right, ${(m = r.fillColor) === null || m === void 0 ? void 0 : m.stops[0]} , ${(s = r.fillColor) === null || s === void 0 ? void 0 : s.stops[1]})` : r.fillColor;
  }), f = Me(() => r.railBorderRadius !== void 0 ? Wo(r.railBorderRadius) : r.height !== void 0 ? Wo(r.height, { c: 0.5 }) : ""), g = Me(() => r.fillBorderRadius !== void 0 ? Wo(r.fillBorderRadius) : r.railBorderRadius !== void 0 ? Wo(r.railBorderRadius) : r.height !== void 0 ? Wo(r.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: m, railColor: s, railStyle: C, percentage: P, unit: M, indicatorTextColor: F, status: D, showIndicator: A, processing: O, clsPrefix: V } = r;
    return B("div", { class: `${V}-progress-content`, role: "none" }, B("div", { class: `${V}-progress-graph`, "aria-hidden": true }, B("div", { class: [`${V}-progress-graph-line`, { [`${V}-progress-graph-line--indicator-${m}`]: true }] }, B("div", { class: `${V}-progress-graph-line-rail`, style: [{ backgroundColor: s, height: l.value, borderRadius: f.value }, C] }, B("div", { class: [`${V}-progress-graph-line-fill`, O && `${V}-progress-graph-line-fill--processing`], style: { maxWidth: `${r.percentage}%`, background: d.value, height: l.value, lineHeight: l.value, borderRadius: g.value } }, m === "inside" ? B("div", { class: `${V}-progress-graph-line-indicator`, style: { color: F } }, i.default ? i.default() : `${P}${M}`) : null)))), A && m === "outside" ? B("div", null, i.default ? B("div", { class: `${V}-progress-custom-content`, style: { color: F }, role: "none" }, i.default()) : D === "default" ? B("div", { role: "none", class: `${V}-progress-icon ${V}-progress-icon--as-text`, style: { color: F } }, P, M) : B("div", { class: `${V}-progress-icon`, "aria-hidden": true }, B(Wr, { clsPrefix: V }, { default: () => I5[D] }))) : null);
  };
} });
function Ay(r, i, l = 100) {
  return `m ${l / 2} ${l / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
}
const E5 = ot({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(r, { slots: i }) {
  const l = Me(() => r.percentage.map((g, m) => `${Math.PI * g / 100 * (r.viewBoxWidth / 2 - r.strokeWidth / 2 * (1 + 2 * m) - r.circleGap * m) * 2}, ${r.viewBoxWidth * 8}`)), d = (f, g) => {
    const m = r.fillColor[g], s = typeof m == "object" ? m.stops[0] : "", C = typeof m == "object" ? m.stops[1] : "";
    return typeof r.fillColor[g] == "object" && B("linearGradient", { id: `gradient-${g}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, B("stop", { offset: "0%", "stop-color": s }), B("stop", { offset: "100%", "stop-color": C }));
  };
  return () => {
    const { viewBoxWidth: f, strokeWidth: g, circleGap: m, showIndicator: s, fillColor: C, railColor: P, railStyle: M, percentage: F, clsPrefix: D } = r;
    return B("div", { class: `${D}-progress-content`, role: "none" }, B("div", { class: `${D}-progress-graph`, "aria-hidden": true }, B("div", { class: `${D}-progress-graph-circle` }, B("svg", { viewBox: `0 0 ${f} ${f}` }, B("defs", null, F.map((A, O) => d(A, O))), F.map((A, O) => B("g", { key: O }, B("path", { class: `${D}-progress-graph-circle-rail`, d: Ay(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: P[O] }, M[O]] }), B("path", { class: [`${D}-progress-graph-circle-fill`, A === 0 && `${D}-progress-graph-circle-fill--empty`], d: Ay(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[O], strokeDashoffset: 0, stroke: typeof C[O] == "object" ? `url(#gradient-${O})` : C[O] } })))))), s && i.default ? B("div", null, B("div", { class: `${D}-progress-text` }, i.default())) : null);
  };
} }), R5 = Ge([ce("progress", { display: "inline-block" }, [ce("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ue("line", `
 width: 100%;
 display: block;
 `, [ce("progress-content", `
 display: flex;
 align-items: center;
 `, [ce("progress-graph", { flex: 1 })]), ce("progress-custom-content", { marginLeft: "14px" }), ce("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ue("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ue("circle, dashboard", { width: "120px" }, [ce("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), ce("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), ce("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ue("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [ce("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), ce("progress-content", { position: "relative" }), ce("progress-graph", { position: "relative" }, [ce("progress-graph-circle", [Ge("svg", { verticalAlign: "bottom" }), ce("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ue("empty", { opacity: 0 })]), ce("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), ce("progress-graph-line", [Ue("indicator-inside", [ce("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [ce("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), ce("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ue("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [ce("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), ce("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ce("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [ce("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ue("processing", [Ge("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), Ge("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), A5 = Object.assign(Object.assign({}, rr.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), D5 = ot({ name: "Progress", props: A5, setup(r) {
  const i = Me(() => r.indicatorPlacement || r.indicatorPosition), l = Me(() => {
    if (r.gapDegree || r.gapDegree === 0) return r.gapDegree;
    if (r.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: d, inlineThemeDisabled: f } = Mr(r), g = rr("Progress", "-progress", R5, iC, r, d), m = Me(() => {
    const { status: C } = r, { common: { cubicBezierEaseInOut: P }, self: { fontSize: M, fontSizeCircle: F, railColor: D, railHeight: A, iconSizeCircle: O, iconSizeLine: V, textColorCircle: Y, textColorLineInner: W, textColorLineOuter: ee, lineBgProcessing: ie, fontWeightCircle: te, [Jt("iconColor", C)]: re, [Jt("fillColor", C)]: X } } = g.value;
    return { "--n-bezier": P, "--n-fill-color": X, "--n-font-size": M, "--n-font-size-circle": F, "--n-font-weight-circle": te, "--n-icon-color": re, "--n-icon-size-circle": O, "--n-icon-size-line": V, "--n-line-bg-processing": ie, "--n-rail-color": D, "--n-rail-height": A, "--n-text-color-circle": Y, "--n-text-color-line-inner": W, "--n-text-color-line-outer": ee };
  }), s = f ? bi("progress", Me(() => r.status[0]), m, r) : void 0;
  return { mergedClsPrefix: d, mergedIndicatorPlacement: i, gapDeg: l, cssVars: f ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  const { type: r, cssVars: i, indicatorTextColor: l, showIndicator: d, status: f, railColor: g, railStyle: m, color: s, percentage: C, viewBoxWidth: P, strokeWidth: M, mergedIndicatorPlacement: F, unit: D, borderRadius: A, fillBorderRadius: O, height: V, processing: Y, circleGap: W, mergedClsPrefix: ee, gapDeg: ie, gapOffsetDegree: te, themeClass: re, $slots: X, onRender: Se } = this;
  return Se == null ? void 0 : Se(), B("div", { class: [re, `${ee}-progress`, `${ee}-progress--${r}`, `${ee}-progress--${f}`], style: i, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": C, role: r === "circle" || r === "line" || r === "dashboard" ? "progressbar" : "none" }, r === "circle" || r === "dashboard" ? B(T5, { clsPrefix: ee, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, offsetDegree: this.offsetDegree, percentage: C, viewBoxWidth: P, strokeWidth: M, gapDegree: ie === void 0 ? r === "dashboard" ? 75 : 0 : ie, gapOffsetDegree: te, unit: D }, X) : r === "line" ? B(M5, { clsPrefix: ee, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, percentage: C, processing: Y, indicatorPlacement: F, unit: D, fillBorderRadius: O, railBorderRadius: A, height: V }, X) : r === "multiple-circle" ? B(E5, { clsPrefix: ee, strokeWidth: M, railColor: g, fillColor: s, railStyle: m, viewBoxWidth: P, percentage: C, showIndicator: d, circleGap: W }, X) : null);
} }), z5 = Ge([Ge("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), ce("spin-container", `
 position: relative;
 `, [ce("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Zf()])]), ce("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), ce("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ue("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), ce("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), ce("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ue("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), F5 = { small: 20, medium: 18, large: 16 }, L5 = Object.assign(Object.assign({}, rr.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), B5 = ot({ name: "Spin", props: L5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), d = rr("Spin", "-spin", z5, nC, r, i), f = Me(() => {
    const { size: C } = r, { common: { cubicBezierEaseInOut: P }, self: M } = d.value, { opacitySpinning: F, color: D, textColor: A } = M, O = typeof C == "number" ? Nn(C) : M[Jt("size", C)];
    return { "--n-bezier": P, "--n-opacity-spinning": F, "--n-size": O, "--n-color": D, "--n-text-color": A };
  }), g = l ? bi("spin", Me(() => {
    const { size: C } = r;
    return typeof C == "number" ? String(C) : C[0];
  }), f, r) : void 0, m = Wf(r, ["spinning", "show"]), s = Re(false);
  return vo((C) => {
    let P;
    if (m.value) {
      const { delay: M } = r;
      if (M) {
        P = window.setTimeout(() => {
          s.value = true;
        }, M), C(() => {
          clearTimeout(P);
        });
        return;
      }
    }
    s.value = m.value;
  }), { mergedClsPrefix: i, active: s, mergedStrokeWidth: Me(() => {
    const { strokeWidth: C } = r;
    if (C !== void 0) return C;
    const { size: P } = r;
    return F5[typeof P == "number" ? "medium" : P];
  }), cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r, i;
  const { $slots: l, mergedClsPrefix: d, description: f } = this, g = l.icon && this.rotate, m = (f || l.description) && B("div", { class: `${d}-spin-description` }, f || ((r = l.description) === null || r === void 0 ? void 0 : r.call(l))), s = l.icon ? B("div", { class: [`${d}-spin-body`, this.themeClass] }, B("div", { class: [`${d}-spin`, g && `${d}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), m) : B("div", { class: [`${d}-spin-body`, this.themeClass] }, B(np, { clsPrefix: d, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${d}-spin` }), m);
  return (i = this.onRender) === null || i === void 0 || i.call(this), l.default ? B("div", { class: [`${d}-spin-container`, this.themeClass], style: this.cssVars }, B("div", { class: [`${d}-spin-content`, this.active && `${d}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), B(Io, { name: "fade-in-transition" }, { default: () => this.active ? s : null })) : s;
} }), O5 = ce("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ue("horizontal", `
 flex-direction: row;
 `), Ue("vertical", `
 flex-direction: column;
 `), ce("split-pane-1", `
 overflow: hidden;
 `), ce("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Fe("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), Ge("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), $5 = Object.assign(Object.assign({}, rr.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), Dy = ot({ name: "Split", props: $5, slots: Object, setup(r) {
  var i;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Mr(r), f = rr("Split", "-split", O5, oC, r, l), g = Me(() => {
    const { common: { cubicBezierEaseInOut: ie }, self: { resizableTriggerColor: te, resizableTriggerColorHover: re } } = f.value;
    return { "--n-bezier": ie, "--n-resize-trigger-color": te, "--n-resize-trigger-color-hover": re };
  }), m = Re(null), s = Re(false), C = Bt(r, "size"), P = Re(r.defaultSize);
  !((i = r.watchProps) === null || i === void 0) && i.includes("defaultSize") && vo(() => P.value = r.defaultSize);
  const M = (ie) => {
    const te = r["onUpdate:size"];
    r.onUpdateSize && jt(r.onUpdateSize, ie), te && jt(te, ie), P.value = ie;
  }, F = Hi(C, P), D = Me(() => {
    const ie = F.value;
    if (typeof ie == "string") return { flex: `0 0 ${ie}` };
    if (typeof ie == "number") {
      const te = ie * 100;
      return { flex: `0 0 calc(${te}% - ${r.resizeTriggerSize * te / 100}px)` };
    }
  }), A = Me(() => r.direction === "horizontal" ? { width: `${r.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${r.resizeTriggerSize}px` }), O = Me(() => {
    const ie = r.direction === "horizontal";
    return { width: ie ? `${r.resizeTriggerSize}px` : "", height: ie ? "" : `${r.resizeTriggerSize}px`, cursor: r.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let V = 0;
  const Y = (ie) => {
    ie.preventDefault(), s.value = true, r.onDragStart && r.onDragStart(ie);
    const te = "mousemove", re = "mouseup", X = (oe) => {
      W(oe), r.onDragMove && r.onDragMove(oe);
    }, Se = () => {
      Xn(te, document, X), Xn(re, document, Se), s.value = false, r.onDragEnd && r.onDragEnd(ie), document.body.style.cursor = "";
    };
    document.body.style.cursor = O.value.cursor, En(te, document, X), En(re, document, Se);
    const pe = m.value;
    if (pe) {
      const oe = pe.getBoundingClientRect();
      r.direction === "horizontal" ? V = ie.clientX - oe.left : V = oe.top - ie.clientY;
    }
    W(ie);
  };
  function W(ie) {
    var te, re;
    const X = (re = (te = m.value) === null || te === void 0 ? void 0 : te.parentElement) === null || re === void 0 ? void 0 : re.getBoundingClientRect();
    if (!X) return;
    const { direction: Se } = r, pe = X.width - r.resizeTriggerSize, oe = X.height - r.resizeTriggerSize, fe = Se === "horizontal" ? pe : oe, _e = Se === "horizontal" ? ie.clientX - X.left - V : ie.clientY - X.top + V, { min: qe, max: Ve } = r, Qe = typeof qe == "string" ? en(qe) : qe * fe, ut = typeof Ve == "string" ? en(Ve) : Ve * fe;
    let gt = _e;
    gt = Math.max(gt, Qe), gt = Math.min(gt, ut, fe), typeof F.value == "string" ? M(`${gt}px`) : M(gt / fe);
  }
  const ee = d ? bi("split", void 0, g, r) : void 0;
  return { themeClass: ee == null ? void 0 : ee.themeClass, onRender: ee == null ? void 0 : ee.onRender, cssVars: d ? void 0 : g, resizeTriggerElRef: m, isDragging: s, mergedClsPrefix: l, resizeTriggerWrapperStyle: O, resizeTriggerStyle: A, handleMouseDown: Y, firstPaneStyle: D };
}, render() {
  var r, i, l, d, f;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, B("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (i = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(i)), !this.disabled && B("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, Kn(this.$slots["resize-trigger"], () => [B("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), B("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (f = (d = this.$slots)[2]) === null || f === void 0 ? void 0 : f.call(d)));
} }), j5 = ce("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Fe("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Fe("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Fe("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), ce("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Nd({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Fe("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Fe("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Fe("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ge("&:focus", [Fe("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ue("round", [Fe("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Fe("button", "border-radius: calc(var(--n-button-height) / 2);")])]), pi("disabled", [pi("icon", [Ue("rubber-band", [Ue("pressed", [Fe("rail", [Fe("button", "max-width: var(--n-button-width-pressed);")])]), Fe("rail", [Ge("&:active", [Fe("button", "max-width: var(--n-button-width-pressed);")])]), Ue("active", [Ue("pressed", [Fe("rail", [Fe("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Fe("rail", [Ge("&:active", [Fe("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ue("active", [Fe("rail", [Fe("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Fe("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Fe("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Nd()]), Fe("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ue("active", [Fe("rail", "background-color: var(--n-rail-color-active);")]), Ue("loading", [Fe("rail", `
 cursor: wait;
 `)]), Ue("disabled", [Fe("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), N5 = Object.assign(Object.assign({}, rr.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let Id;
const Yb = ot({ name: "Switch", props: N5, slots: Object, setup(r) {
  Id === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? Id = CSS.supports("width", "max(1px)") : Id = false : Id = true);
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), d = rr("Switch", "-switch", j5, aC, r, i), f = ya(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, s = Re(r.defaultValue), C = Bt(r, "value"), P = Hi(C, s), M = Me(() => P.value === r.checkedValue), F = Re(false), D = Re(false), A = Me(() => {
    const { railStyle: pe } = r;
    if (pe) return pe({ focused: D.value, checked: M.value });
  });
  function O(pe) {
    const { "onUpdate:value": oe, onChange: fe, onUpdateValue: _e } = r, { nTriggerFormInput: qe, nTriggerFormChange: Ve } = f;
    oe && jt(oe, pe), _e && jt(_e, pe), fe && jt(fe, pe), s.value = pe, qe(), Ve();
  }
  function V() {
    const { nTriggerFormFocus: pe } = f;
    pe();
  }
  function Y() {
    const { nTriggerFormBlur: pe } = f;
    pe();
  }
  function W() {
    r.loading || m.value || (P.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue));
  }
  function ee() {
    D.value = true, V();
  }
  function ie() {
    D.value = false, Y(), F.value = false;
  }
  function te(pe) {
    r.loading || m.value || pe.key === " " && (P.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue), F.value = false);
  }
  function re(pe) {
    r.loading || m.value || pe.key === " " && (pe.preventDefault(), F.value = true);
  }
  const X = Me(() => {
    const { value: pe } = g, { self: { opacityDisabled: oe, railColor: fe, railColorActive: _e, buttonBoxShadow: qe, buttonColor: Ve, boxShadowFocus: Qe, loadingColor: ut, textColor: gt, iconColor: yt, [Jt("buttonHeight", pe)]: lt, [Jt("buttonWidth", pe)]: et, [Jt("buttonWidthPressed", pe)]: dt, [Jt("railHeight", pe)]: Ft, [Jt("railWidth", pe)]: ft, [Jt("railBorderRadius", pe)]: _t, [Jt("buttonBorderRadius", pe)]: $t }, common: { cubicBezierEaseInOut: Qt } } = d.value;
    let Lt, zt, It;
    return Id ? (Lt = `calc((${Ft} - ${lt}) / 2)`, zt = `max(${Ft}, ${lt})`, It = `max(${ft}, calc(${ft} + ${lt} - ${Ft}))`) : (Lt = Nn((en(Ft) - en(lt)) / 2), zt = Nn(Math.max(en(Ft), en(lt))), It = en(Ft) > en(lt) ? ft : Nn(en(ft) + en(lt) - en(Ft))), { "--n-bezier": Qt, "--n-button-border-radius": $t, "--n-button-box-shadow": qe, "--n-button-color": Ve, "--n-button-width": et, "--n-button-width-pressed": dt, "--n-button-height": lt, "--n-height": zt, "--n-offset": Lt, "--n-opacity-disabled": oe, "--n-rail-border-radius": _t, "--n-rail-color": fe, "--n-rail-color-active": _e, "--n-rail-height": Ft, "--n-rail-width": ft, "--n-width": It, "--n-box-shadow-focus": Qe, "--n-loading-color": ut, "--n-text-color": gt, "--n-icon-color": yt };
  }), Se = l ? bi("switch", Me(() => g.value[0]), X, r) : void 0;
  return { handleClick: W, handleBlur: ie, handleFocus: ee, handleKeyup: te, handleKeydown: re, mergedRailStyle: A, pressed: F, mergedClsPrefix: i, mergedValue: P, checked: M, mergedDisabled: m, cssVars: l ? void 0 : X, themeClass: Se == null ? void 0 : Se.themeClass, onRender: Se == null ? void 0 : Se.onRender };
}, render() {
  const { mergedClsPrefix: r, mergedDisabled: i, checked: l, mergedRailStyle: d, onRender: f, $slots: g } = this;
  f == null ? void 0 : f();
  const { checked: m, unchecked: s, icon: C, "checked-icon": P, "unchecked-icon": M } = g, F = !(Rm(C) && Rm(P) && Rm(M));
  return B("div", { role: "switch", "aria-checked": l, class: [`${r}-switch`, this.themeClass, F && `${r}-switch--icon`, l && `${r}-switch--active`, i && `${r}-switch--disabled`, this.round && `${r}-switch--round`, this.loading && `${r}-switch--loading`, this.pressed && `${r}-switch--pressed`, this.rubberBand && `${r}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, B("div", { class: `${r}-switch__rail`, "aria-hidden": "true", style: d }, Ii(m, (D) => Ii(s, (A) => D || A ? B("div", { "aria-hidden": true, class: `${r}-switch__children-placeholder` }, B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), D), B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), A)) : null)), B("div", { class: `${r}-switch__button` }, Ii(C, (D) => Ii(P, (A) => Ii(M, (O) => B(rp, null, { default: () => this.loading ? B(np, { key: "loading", clsPrefix: r, strokeWidth: 20 }) : this.checked && (A || D) ? B("div", { class: `${r}-switch__button-icon`, key: A ? "checked-icon" : "icon" }, A || D) : !this.checked && (O || D) ? B("div", { class: `${r}-switch__button-icon`, key: O ? "unchecked-icon" : "icon" }, O || D) : null })))), Ii(m, (D) => D && B("div", { key: "checked", class: `${r}-switch__checked` }, D)), Ii(s, (D) => D && B("div", { key: "unchecked", class: `${r}-switch__unchecked` }, D)))));
} }), Qg = Rn("n-tabs"), Kb = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, zy = ot({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: Kb, slots: Object, setup(r) {
  const i = pr(Qg, null);
  return i || Xo("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: i.paneStyleRef, class: i.paneClassRef, mergedClsPrefix: i.mergedClsPrefixRef };
}, render() {
  return B("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), V5 = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, W_(Kb, ["displayDirective"])), Ig = ot({ __TAB__: true, inheritAttrs: false, name: "Tab", props: V5, setup(r) {
  const { mergedClsPrefixRef: i, valueRef: l, typeRef: d, closableRef: f, tabStyleRef: g, addTabStyleRef: m, tabClassRef: s, addTabClassRef: C, tabChangeIdRef: P, onBeforeLeaveRef: M, triggerRef: F, handleAdd: D, activateTab: A, handleClose: O } = pr(Qg);
  return { trigger: F, mergedClosable: Me(() => {
    if (r.internalAddable) return false;
    const { closable: V } = r;
    return V === void 0 ? f.value : V;
  }), style: g, addStyle: m, tabClass: s, addTabClass: C, clsPrefix: i, value: l, type: d, handleClose(V) {
    V.stopPropagation(), !r.disabled && O(r.name);
  }, activateTab() {
    if (r.disabled) return;
    if (r.internalAddable) {
      D();
      return;
    }
    const { name: V } = r, Y = ++P.id;
    if (V !== l.value) {
      const { value: W } = M;
      W ? Promise.resolve(W(r.name, l.value)).then((ee) => {
        ee && P.id === Y && A(V);
      }) : A(V);
    }
  } };
}, render() {
  const { internalAddable: r, clsPrefix: i, name: l, disabled: d, label: f, tab: g, value: m, mergedClosable: s, trigger: C, $slots: { default: P } } = this, M = f ?? g;
  return B("div", { class: `${i}-tabs-tab-wrapper` }, this.internalLeftPadded ? B("div", { class: `${i}-tabs-tab-pad` }) : null, B("div", Object.assign({ key: l, "data-name": l, "data-disabled": d ? true : void 0 }, Cs({ class: [`${i}-tabs-tab`, m === l && `${i}-tabs-tab--active`, d && `${i}-tabs-tab--disabled`, s && `${i}-tabs-tab--closable`, r && `${i}-tabs-tab--addable`, r ? this.addTabClass : this.tabClass], onClick: C === "click" ? this.activateTab : void 0, onMouseenter: C === "hover" ? this.activateTab : void 0, style: r ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), B("span", { class: `${i}-tabs-tab__label` }, r ? B(Hr, null, B("div", { class: `${i}-tabs-tab__height-placeholder` }, "\xA0"), B(Wr, { clsPrefix: i }, { default: () => B(up, null) })) : P ? P() : typeof M == "object" ? M : Cl(M ?? l)), s && this.type === "card" ? B(Vg, { clsPrefix: i, class: `${i}-tabs-tab__close`, onClick: this.handleClose, disabled: d }) : null));
} }), U5 = ce("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ue("segment-type", [ce("tabs-rail", [Ge("&.transition-disabled", [ce("tabs-capsule", `
 transition: none;
 `)])])]), Ue("top", [ce("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ue("left", [ce("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ue("left, right", `
 flex-direction: row;
 `, [ce("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ce("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ue("right", `
 flex-direction: row-reverse;
 `, [ce("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), ce("tabs-bar", `
 left: 0;
 `)]), Ue("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [ce("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), ce("tabs-bar", `
 top: 0;
 `)]), ce("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ce("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), ce("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [ce("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ue("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ue("flex", [ce("tabs-nav", `
 width: 100%;
 position: relative;
 `, [ce("tabs-wrapper", `
 width: 100%;
 `, [ce("tabs-tab", `
 margin-right: 0;
 `)])])]), ce("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Fe("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Fe("prefix", "padding-right: 16px;"), Fe("suffix", "padding-left: 16px;")]), Ue("top, bottom", [Ge(">", [ce("tabs-nav", [ce("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), Ge("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), Ue("left, right", [ce("tabs-nav-scroll-content", `
 flex-direction: column;
 `), Ge(">", [ce("tabs-nav", [ce("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ge("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), ce("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [ce("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), Ge("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), ce("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), ce("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), ce("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), ce("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ue("disabled", { cursor: "not-allowed" }), Fe("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Fe("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), ce("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ge("&.transition-disabled", `
 transition: none;
 `), Ue("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), ce("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), ce("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [Ge("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), Ge("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), Ge("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), ce("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ue("line-type, bar-type", [ce("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [Ge("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ue("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ue("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), ce("tabs-nav", [Ue("line-type", [Ue("top", [Fe("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ce("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ce("tabs-bar", `
 bottom: -1px;
 `)]), Ue("left", [Fe("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ce("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ce("tabs-bar", `
 right: -1px;
 `)]), Ue("right", [Fe("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ce("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ce("tabs-bar", `
 left: -1px;
 `)]), Ue("bottom", [Fe("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ce("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ce("tabs-bar", `
 top: -1px;
 `)]), Fe("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ce("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), ce("tabs-bar", `
 border-radius: 0;
 `)]), Ue("card-type", [Fe("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ce("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), ce("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), ce("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ue("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Fe("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), pi("disabled", [Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ue("closable", "padding-right: 8px;"), Ue("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ue("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ue("left, right", `
 flex-direction: column; 
 `, [Fe("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), ce("tabs-wrapper", `
 flex-direction: column;
 `), ce("tabs-tab-wrapper", `
 flex-direction: column;
 `, [ce("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ue("top", [Ue("card-type", [ce("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Fe("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ce("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-bottom: 1px solid #0000;
 `)]), ce("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ce("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ue("left", [Ue("card-type", [ce("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Fe("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ce("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-right: 1px solid #0000;
 `)]), ce("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ce("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ue("right", [Ue("card-type", [ce("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Fe("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ce("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-left: 1px solid #0000;
 `)]), ce("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ce("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ue("bottom", [Ue("card-type", [ce("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Fe("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ce("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-top: 1px solid #0000;
 `)]), ce("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ce("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), Wm = b3, q5 = Object.assign(Object.assign({}, rr.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), G5 = ot({ name: "Tabs", props: q5, slots: Object, setup(r, { slots: i }) {
  var l, d, f, g;
  const { mergedClsPrefixRef: m, inlineThemeDisabled: s } = Mr(r), C = rr("Tabs", "-tabs", U5, sC, r, m), P = Re(null), M = Re(null), F = Re(null), D = Re(null), A = Re(null), O = Re(null), V = Re(true), Y = Re(true), W = Wf(r, ["labelSize", "size"]), ee = Wf(r, ["activeName", "value"]), ie = Re((d = (l = ee.value) !== null && l !== void 0 ? l : r.defaultValue) !== null && d !== void 0 ? d : i.default ? (g = (f = El(i.default())[0]) === null || f === void 0 ? void 0 : f.props) === null || g === void 0 ? void 0 : g.name : null), te = Hi(ee, ie), re = { id: 0 }, X = Me(() => {
    if (!(!r.justifyContent || r.type === "card")) return { display: "flex", justifyContent: r.justifyContent };
  });
  Ht(te, () => {
    re.id = 0, _e(), qe();
  });
  function Se() {
    var Be;
    const { value: Ye } = te;
    return Ye === null ? null : (Be = P.value) === null || Be === void 0 ? void 0 : Be.querySelector(`[data-name="${Ye}"]`);
  }
  function pe(Be) {
    if (r.type === "card") return;
    const { value: Ye } = M;
    if (!Ye) return;
    const ht = Ye.style.opacity === "0";
    if (Be) {
      const bt = `${m.value}-tabs-bar--disabled`, { barWidth: tt, placement: mt } = r;
      if (Be.dataset.disabled === "true" ? Ye.classList.add(bt) : Ye.classList.remove(bt), ["top", "bottom"].includes(mt)) {
        if (fe(["top", "maxHeight", "height"]), typeof tt == "number" && Be.offsetWidth >= tt) {
          const Kt = Math.floor((Be.offsetWidth - tt) / 2) + Be.offsetLeft;
          Ye.style.left = `${Kt}px`, Ye.style.maxWidth = `${tt}px`;
        } else Ye.style.left = `${Be.offsetLeft}px`, Ye.style.maxWidth = `${Be.offsetWidth}px`;
        Ye.style.width = "8192px", ht && (Ye.style.transition = "none"), Ye.offsetWidth, ht && (Ye.style.transition = "", Ye.style.opacity = "1");
      } else {
        if (fe(["left", "maxWidth", "width"]), typeof tt == "number" && Be.offsetHeight >= tt) {
          const Kt = Math.floor((Be.offsetHeight - tt) / 2) + Be.offsetTop;
          Ye.style.top = `${Kt}px`, Ye.style.maxHeight = `${tt}px`;
        } else Ye.style.top = `${Be.offsetTop}px`, Ye.style.maxHeight = `${Be.offsetHeight}px`;
        Ye.style.height = "8192px", ht && (Ye.style.transition = "none"), Ye.offsetHeight, ht && (Ye.style.transition = "", Ye.style.opacity = "1");
      }
    }
  }
  function oe() {
    if (r.type === "card") return;
    const { value: Be } = M;
    Be && (Be.style.opacity = "0");
  }
  function fe(Be) {
    const { value: Ye } = M;
    if (Ye) for (const ht of Be) Ye.style[ht] = "";
  }
  function _e() {
    if (r.type === "card") return;
    const Be = Se();
    Be ? pe(Be) : oe();
  }
  function qe() {
    var Be;
    const Ye = (Be = A.value) === null || Be === void 0 ? void 0 : Be.$el;
    if (!Ye) return;
    const ht = Se();
    if (!ht) return;
    const { scrollLeft: bt, offsetWidth: tt } = Ye, { offsetLeft: mt, offsetWidth: Kt } = ht;
    bt > mt ? Ye.scrollTo({ top: 0, left: mt, behavior: "smooth" }) : mt + Kt > bt + tt && Ye.scrollTo({ top: 0, left: mt + Kt - tt, behavior: "smooth" });
  }
  const Ve = Re(null);
  let Qe = 0, ut = null;
  function gt(Be) {
    const Ye = Ve.value;
    if (Ye) {
      Qe = Be.getBoundingClientRect().height;
      const ht = `${Qe}px`, bt = () => {
        Ye.style.height = ht, Ye.style.maxHeight = ht;
      };
      ut ? (bt(), ut(), ut = null) : ut = bt;
    }
  }
  function yt(Be) {
    const Ye = Ve.value;
    if (Ye) {
      const ht = Be.getBoundingClientRect().height, bt = () => {
        document.body.offsetHeight, Ye.style.maxHeight = `${ht}px`, Ye.style.height = `${Math.max(Qe, ht)}px`;
      };
      ut ? (ut(), ut = null, bt()) : ut = bt;
    }
  }
  function lt() {
    const Be = Ve.value;
    if (Be) {
      Be.style.maxHeight = "", Be.style.height = "";
      const { paneWrapperStyle: Ye } = r;
      if (typeof Ye == "string") Be.style.cssText = Ye;
      else if (Ye) {
        const { maxHeight: ht, height: bt } = Ye;
        ht !== void 0 && (Be.style.maxHeight = ht), bt !== void 0 && (Be.style.height = bt);
      }
    }
  }
  const et = { value: [] }, dt = Re("next");
  function Ft(Be) {
    const Ye = te.value;
    let ht = "next";
    for (const bt of et.value) {
      if (bt === Ye) break;
      if (bt === Be) {
        ht = "prev";
        break;
      }
    }
    dt.value = ht, ft(Be);
  }
  function ft(Be) {
    const { onActiveNameChange: Ye, onUpdateValue: ht, "onUpdate:value": bt } = r;
    Ye && jt(Ye, Be), ht && jt(ht, Be), bt && jt(bt, Be), ie.value = Be;
  }
  function _t(Be) {
    const { onClose: Ye } = r;
    Ye && jt(Ye, Be);
  }
  function $t() {
    const { value: Be } = M;
    if (!Be) return;
    const Ye = "transition-disabled";
    Be.classList.add(Ye), _e(), Be.classList.remove(Ye);
  }
  const Qt = Re(null);
  function Lt({ transitionDisabled: Be }) {
    const Ye = P.value;
    if (!Ye) return;
    Be && Ye.classList.add("transition-disabled");
    const ht = Se();
    ht && Qt.value && (Qt.value.style.width = `${ht.offsetWidth}px`, Qt.value.style.height = `${ht.offsetHeight}px`, Qt.value.style.transform = `translateX(${ht.offsetLeft - en(getComputedStyle(Ye).paddingLeft)}px)`, Be && Qt.value.offsetWidth), Be && Ye.classList.remove("transition-disabled");
  }
  Ht([te], () => {
    r.type === "segment" && Vn(() => {
      Lt({ transitionDisabled: false });
    });
  }), ji(() => {
    r.type === "segment" && Lt({ transitionDisabled: true });
  });
  let zt = 0;
  function It(Be) {
    var Ye;
    if (Be.contentRect.width === 0 && Be.contentRect.height === 0 || zt === Be.contentRect.width) return;
    zt = Be.contentRect.width;
    const { type: ht } = r;
    if ((ht === "line" || ht === "bar") && $t(), ht !== "segment") {
      const { placement: bt } = r;
      Ut((bt === "top" || bt === "bottom" ? (Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el : O.value) || null);
    }
  }
  const At = Wm(It, 64);
  Ht([() => r.justifyContent, () => r.size], () => {
    Vn(() => {
      const { type: Be } = r;
      (Be === "line" || Be === "bar") && $t();
    });
  });
  const mr = Re(false);
  function gr(Be) {
    var Ye;
    const { target: ht, contentRect: { width: bt, height: tt } } = Be, mt = ht.parentElement.parentElement.offsetWidth, Kt = ht.parentElement.parentElement.offsetHeight, { placement: Qr } = r;
    if (!mr.value) Qr === "top" || Qr === "bottom" ? mt < bt && (mr.value = true) : Kt < tt && (mr.value = true);
    else {
      const { value: ki } = D;
      if (!ki) return;
      Qr === "top" || Qr === "bottom" ? mt - bt > ki.$el.offsetWidth && (mr.value = false) : Kt - tt > ki.$el.offsetHeight && (mr.value = false);
    }
    Ut(((Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el) || null);
  }
  const ir = Wm(gr, 64);
  function nr() {
    const { onAdd: Be } = r;
    Be && Be(), Vn(() => {
      const Ye = Se(), { value: ht } = A;
      !Ye || !ht || ht.scrollTo({ left: Ye.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function Ut(Be) {
    if (!Be) return;
    const { placement: Ye } = r;
    if (Ye === "top" || Ye === "bottom") {
      const { scrollLeft: ht, scrollWidth: bt, offsetWidth: tt } = Be;
      V.value = ht <= 0, Y.value = ht + tt >= bt;
    } else {
      const { scrollTop: ht, scrollHeight: bt, offsetHeight: tt } = Be;
      V.value = ht <= 0, Y.value = ht + tt >= bt;
    }
  }
  const Ar = Wm((Be) => {
    Ut(Be.target);
  }, 64);
  Zr(Qg, { triggerRef: Bt(r, "trigger"), tabStyleRef: Bt(r, "tabStyle"), tabClassRef: Bt(r, "tabClass"), addTabStyleRef: Bt(r, "addTabStyle"), addTabClassRef: Bt(r, "addTabClass"), paneClassRef: Bt(r, "paneClass"), paneStyleRef: Bt(r, "paneStyle"), mergedClsPrefixRef: m, typeRef: Bt(r, "type"), closableRef: Bt(r, "closable"), valueRef: te, tabChangeIdRef: re, onBeforeLeaveRef: Bt(r, "onBeforeLeave"), activateTab: Ft, handleClose: _t, handleAdd: nr }), R_(() => {
    _e(), qe();
  }), vo(() => {
    const { value: Be } = F;
    if (!Be) return;
    const { value: Ye } = m, ht = `${Ye}-tabs-nav-scroll-wrapper--shadow-start`, bt = `${Ye}-tabs-nav-scroll-wrapper--shadow-end`;
    V.value ? Be.classList.remove(ht) : Be.classList.add(ht), Y.value ? Be.classList.remove(bt) : Be.classList.add(bt);
  });
  const wr = { syncBarPosition: () => {
    _e();
  } }, Ct = () => {
    Lt({ transitionDisabled: true });
  }, Ee = Me(() => {
    const { value: Be } = W, { type: Ye } = r, ht = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[Ye], bt = `${Be}${ht}`, { self: { barColor: tt, closeIconColor: mt, closeIconColorHover: Kt, closeIconColorPressed: Qr, tabColor: ki, tabBorderColor: ze, paneTextColor: Z, tabFontWeight: H, tabBorderRadius: ne, tabFontWeightActive: xe, colorSegment: Pe, fontWeightStrong: De, tabColorSegment: he, closeSize: ve, closeIconSize: je, closeColorHover: it, closeColorPressed: Xe, closeBorderRadius: xt, [Jt("panePadding", Be)]: Te, [Jt("tabPadding", bt)]: Vt, [Jt("tabPaddingVertical", bt)]: or, [Jt("tabGap", bt)]: qt, [Jt("tabGap", `${bt}Vertical`)]: dr, [Jt("tabTextColor", Ye)]: Br, [Jt("tabTextColorActive", Ye)]: Vr, [Jt("tabTextColorHover", Ye)]: Kr, [Jt("tabTextColorDisabled", Ye)]: ci, [Jt("tabFontSize", Be)]: di }, common: { cubicBezierEaseInOut: Lr } } = C.value;
    return { "--n-bezier": Lr, "--n-color-segment": Pe, "--n-bar-color": tt, "--n-tab-font-size": di, "--n-tab-text-color": Br, "--n-tab-text-color-active": Vr, "--n-tab-text-color-disabled": ci, "--n-tab-text-color-hover": Kr, "--n-pane-text-color": Z, "--n-tab-border-color": ze, "--n-tab-border-radius": ne, "--n-close-size": ve, "--n-close-icon-size": je, "--n-close-color-hover": it, "--n-close-color-pressed": Xe, "--n-close-border-radius": xt, "--n-close-icon-color": mt, "--n-close-icon-color-hover": Kt, "--n-close-icon-color-pressed": Qr, "--n-tab-color": ki, "--n-tab-font-weight": H, "--n-tab-font-weight-active": xe, "--n-tab-padding": Vt, "--n-tab-padding-vertical": or, "--n-tab-gap": qt, "--n-tab-gap-vertical": dr, "--n-pane-padding-left": Zo(Te, "left"), "--n-pane-padding-right": Zo(Te, "right"), "--n-pane-padding-top": Zo(Te, "top"), "--n-pane-padding-bottom": Zo(Te, "bottom"), "--n-font-weight-strong": De, "--n-tab-color-segment": he };
  }), nt = s ? bi("tabs", Me(() => `${W.value[0]}${r.type[0]}`), Ee, r) : void 0;
  return Object.assign({ mergedClsPrefix: m, mergedValue: te, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: Qt, tabsPaneWrapperRef: Ve, tabsElRef: P, barElRef: M, addTabInstRef: D, xScrollInstRef: A, scrollWrapperElRef: F, addTabFixed: mr, tabWrapperStyle: X, handleNavResize: At, mergedSize: W, handleScroll: Ar, handleTabsResize: ir, cssVars: s ? void 0 : Ee, themeClass: nt == null ? void 0 : nt.themeClass, animationDirection: dt, renderNameListRef: et, yScrollElRef: O, handleSegmentResize: Ct, onAnimationBeforeLeave: gt, onAnimationEnter: yt, onAnimationAfterEnter: lt, onRender: nt == null ? void 0 : nt.onRender }, wr);
}, render() {
  const { mergedClsPrefix: r, type: i, placement: l, addTabFixed: d, addable: f, mergedSize: g, renderNameListRef: m, onRender: s, paneWrapperClass: C, paneWrapperStyle: P, $slots: { default: M, prefix: F, suffix: D } } = this;
  s == null ? void 0 : s();
  const A = M ? El(M()).filter((re) => re.type.__TAB_PANE__ === true) : [], O = M ? El(M()).filter((re) => re.type.__TAB__ === true) : [], V = !O.length, Y = i === "card", W = i === "segment", ee = !Y && !W && this.justifyContent;
  m.value = [];
  const ie = () => {
    const re = B("div", { style: this.tabWrapperStyle, class: `${r}-tabs-wrapper` }, ee ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), V ? A.map((X, Se) => (m.value.push(X.props.name), Zm(B(Ig, Object.assign({}, X.props, { internalCreatedByPane: true, internalLeftPadded: Se !== 0 && (!ee || ee === "center" || ee === "start" || ee === "end") }), X.children ? { default: X.children.tab } : void 0)))) : O.map((X, Se) => (m.value.push(X.props.name), Zm(Se !== 0 && !ee ? By(X) : X))), !d && f && Y ? Ly(f, (V ? A.length : O.length) !== 0) : null, ee ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return B("div", { ref: "tabsElRef", class: `${r}-tabs-nav-scroll-content` }, Y && f ? B(Pl, { onResize: this.handleTabsResize }, { default: () => re }) : re, Y ? B("div", { class: `${r}-tabs-pad` }) : null, Y ? null : B("div", { ref: "barElRef", class: `${r}-tabs-bar` }));
  }, te = W ? "top" : l;
  return B("div", { class: [`${r}-tabs`, this.themeClass, `${r}-tabs--${i}-type`, `${r}-tabs--${g}-size`, ee && `${r}-tabs--flex`, `${r}-tabs--${te}`], style: this.cssVars }, B("div", { class: [`${r}-tabs-nav--${i}-type`, `${r}-tabs-nav--${te}`, `${r}-tabs-nav`] }, Ii(F, (re) => re && B("div", { class: `${r}-tabs-nav__prefix` }, re)), W ? B(Pl, { onResize: this.handleSegmentResize }, { default: () => B("div", { class: `${r}-tabs-rail`, ref: "tabsElRef" }, B("div", { class: `${r}-tabs-capsule`, ref: "segmentCapsuleElRef" }, B("div", { class: `${r}-tabs-wrapper` }, B("div", { class: `${r}-tabs-tab` }))), V ? A.map((re, X) => (m.value.push(re.props.name), B(Ig, Object.assign({}, re.props, { internalCreatedByPane: true, internalLeftPadded: X !== 0 }), re.children ? { default: re.children.tab } : void 0))) : O.map((re, X) => (m.value.push(re.props.name), X === 0 ? re : By(re)))) }) : B(Pl, { onResize: this.handleNavResize }, { default: () => B("div", { class: `${r}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(te) ? B(cS, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: ie }) : B("div", { class: `${r}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, ie())) }), d && f && Y ? Ly(f, true) : null, Ii(D, (re) => re && B("div", { class: `${r}-tabs-nav__suffix` }, re))), V && (this.animated && (te === "top" || te === "bottom") ? B("div", { ref: "tabsPaneWrapperRef", style: P, class: [`${r}-tabs-pane-wrapper`, C] }, Fy(A, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : Fy(A, this.mergedValue, this.renderedNames)));
} });
function Fy(r, i, l, d, f, g, m) {
  const s = [];
  return r.forEach((C) => {
    const { name: P, displayDirective: M, "display-directive": F } = C.props, D = (O) => M === O || F === O, A = i === P;
    if (C.key !== void 0 && (C.key = P), A || D("show") || D("show:lazy") && l.has(P)) {
      l.has(P) || l.add(P);
      const O = !D("if");
      s.push(O ? ga(C, [[Qa, A]]) : C);
    }
  }), m ? B(r2, { name: `${m}-transition`, onBeforeLeave: d, onEnter: f, onAfterEnter: g }, { default: () => s }) : s;
}
function Ly(r, i) {
  return B(Ig, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: i, disabled: typeof r == "object" && r.disabled });
}
function By(r) {
  const i = sg(r);
  return i.props ? i.props.internalLeftPadded = true : i.props = { internalLeftPadded: true }, i;
}
function Zm(r) {
  return Array.isArray(r.dynamicProps) ? r.dynamicProps.includes("internalLeftPadded") || r.dynamicProps.push("internalLeftPadded") : r.dynamicProps = ["internalLeftPadded"], r;
}
const W5 = ce("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [Ge("&:first-child", { marginTop: 0 }), Ue("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ue("align-text", { paddingLeft: 0 }, [Ge("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), Ge("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), Ge("&::before", { backgroundColor: "var(--n-bar-color)" })])]), Z5 = Object.assign(Object.assign({}, rr.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), H5 = (r) => ot({ name: `H${r}`, props: Z5, setup(i) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Mr(i), f = rr("Typography", "-h", W5, Y_, i, l), g = Me(() => {
    const { type: s } = i, { common: { cubicBezierEaseInOut: C }, self: { headerFontWeight: P, headerTextColor: M, [Jt("headerPrefixWidth", r)]: F, [Jt("headerFontSize", r)]: D, [Jt("headerMargin", r)]: A, [Jt("headerBarWidth", r)]: O, [Jt("headerBarColor", s)]: V } } = f.value;
    return { "--n-bezier": C, "--n-font-size": D, "--n-margin": A, "--n-bar-color": V, "--n-bar-width": O, "--n-font-weight": P, "--n-text-color": M, "--n-prefix-width": F };
  }), m = d ? bi(`h${r}`, Me(() => i.type[0]), g, i) : void 0;
  return { mergedClsPrefix: l, cssVars: d ? void 0 : g, themeClass: m == null ? void 0 : m.themeClass, onRender: m == null ? void 0 : m.onRender };
}, render() {
  var i;
  const { prefix: l, alignText: d, mergedClsPrefix: f, cssVars: g, $slots: m } = this;
  return (i = this.onRender) === null || i === void 0 || i.call(this), B(`h${r}`, { class: [`${f}-h`, `${f}-h${r}`, this.themeClass, { [`${f}-h--prefix-bar`]: l, [`${f}-h--align-text`]: d }], style: g }, m);
} }), X5 = H5("1"), Y5 = ce("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [Ge("&:first-child", "margin-top: 0;"), Ge("&:last-child", "margin-bottom: 0;")]), K5 = Object.assign(Object.assign({}, rr.props), { depth: [String, Number] }), Tf = ot({ name: "P", props: K5, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Mr(r), d = rr("Typography", "-p", Y5, Y_, r, i), f = Me(() => {
    const { depth: m } = r, s = m || "1", { common: { cubicBezierEaseInOut: C }, self: { pFontSize: P, pLineHeight: M, pMargin: F, pTextColor: D, [`pTextColor${s}Depth`]: A } } = d.value;
    return { "--n-bezier": C, "--n-font-size": P, "--n-line-height": M, "--n-margin": F, "--n-text-color": m === void 0 ? D : A };
  }), g = l ? bi("p", Me(() => `${r.depth || ""}`), f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), dc = Rn("n-upload"), J5 = Ge([ce("upload", "width: 100%;", [Ue("dragger-inside", [ce("upload-trigger", `
 display: block;
 `)]), Ue("drag-over", [ce("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), ce("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [Ge("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ue("disabled", `
 cursor: not-allowed;
 `)]), ce("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("+", [ce("upload-file-list", "margin-top: 8px;")]), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ue("image-card", `
 width: 96px;
 height: 96px;
 `, [ce("base-icon", `
 font-size: 24px;
 `), ce("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), ce("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("a, img", "outline: none;"), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [ce("upload-file", "cursor: not-allowed;")]), Ue("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), ce("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [cg(), ce("progress", [cg({ foldPadding: true })]), Ge("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [ce("upload-file-info", [Fe("action", `
 opacity: 1;
 `)])]), Ue("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [ce("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [ce("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Fe("name", `
 padding: 0 8px;
 `), Fe("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [Ge("img", `
 width: 100%;
 `)])])]), Ue("text-type", [ce("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ue("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [ce("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), ce("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Fe("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [Ge("img", `
 width: 100%;
 `)])]), Ge("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), Ge("&:hover", [Ge("&::before", "opacity: 1;"), ce("upload-file-info", [Fe("thumbnail", "opacity: .12;")])])]), Ue("error-status", [Ge("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), ce("upload-file-info", [Fe("name", "color: var(--n-item-text-color-error);"), Fe("thumbnail", "color: var(--n-item-text-color-error);")]), Ue("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ue("with-url", `
 cursor: pointer;
 `, [ce("upload-file-info", [Fe("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [Ge("a", `
 text-decoration: underline;
 `)])])]), ce("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Fe("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [ce("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Fe("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [ce("button", [Ge("&:not(:last-child)", { marginRight: "4px" }), ce("base-icon", [Ge("svg", [Nd()])])]), Ue("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ue("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Fe("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [Ge("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), ce("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), Jb = "__UPLOAD_DRAGGER__", Qb = ot({ name: "UploadDragger", [Jb]: true, setup(r, { slots: i }) {
  const l = pr(dc, null);
  return l || Xo("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: d }, mergedDisabledRef: { value: f }, maxReachedRef: { value: g } } = l;
    return B("div", { class: [`${d}-upload-dragger`, (f || g) && `${d}-upload-dragger--disabled`] }, i);
  };
} });
function Q5() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })));
}
function e6() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })));
}
const t6 = ot({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: pr(dc).mergedThemeRef };
}, render() {
  return B(qg, null, { default: () => this.show ? B(D5, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var Mg = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (F) {
        m(F);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (F) {
        m(F);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
function e1(r) {
  return r.includes("image/");
}
function Oy(r = "") {
  const i = r.split("/"), d = i[i.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(d) || [""])[0];
}
const $y = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, t1 = (r) => {
  if (r.type) return e1(r.type);
  const i = Oy(r.name || "");
  if ($y.test(i)) return true;
  const l = r.thumbnailUrl || r.url || "", d = Oy(l);
  return !!(/^data:image\//.test(l) || $y.test(d));
};
function r6(r) {
  return Mg(this, void 0, void 0, function* () {
    return yield new Promise((i) => {
      if (!r.type || !e1(r.type)) {
        i("");
        return;
      }
      i(window.URL.createObjectURL(r));
    });
  });
}
const i6 = op && window.FileReader && window.File;
function n6(r) {
  return r.isDirectory;
}
function o6(r) {
  return r.isFile;
}
function a6(r, i) {
  return Mg(this, void 0, void 0, function* () {
    const l = [];
    function d(f) {
      return Mg(this, void 0, void 0, function* () {
        for (const g of f) if (g) {
          if (i && n6(g)) {
            const m = g.createReader();
            let s = [], C;
            try {
              do
                C = yield new Promise((P, M) => {
                  m.readEntries(P, M);
                }), s = s.concat(C);
              while (C.length > 0);
            } catch (P) {
              Qv("upload", "error happens when handling directory upload", P);
            }
            yield d(s);
          } else if (o6(g)) try {
            const m = yield new Promise((s, C) => {
              g.file(s, C);
            });
            l.push({ file: m, entry: g, source: "dnd" });
          } catch (m) {
            Qv("upload", "error happens when handling file upload", m);
          }
        }
      });
    }
    return yield d(r), l;
  });
}
function Hd(r) {
  const { id: i, name: l, percentage: d, status: f, url: g, file: m, thumbnailUrl: s, type: C, fullPath: P, batchId: M } = r;
  return { id: i, name: l, percentage: d ?? null, status: f, url: g ?? null, file: m ?? null, thumbnailUrl: s ?? null, type: C ?? null, fullPath: P ?? null, batchId: M ?? null };
}
function s6(r, i, l) {
  return r = r.toLowerCase(), i = i.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((f) => f.trim()).filter(Boolean).some((f) => {
    if (f.startsWith(".")) {
      if (r.endsWith(f)) return true;
    } else if (f.includes("/")) {
      const [g, m] = i.split("/"), [s, C] = f.split("/");
      if ((s === "*" || g && s && s === g) && (C === "*" || m && C && C === m)) return true;
    } else return true;
    return false;
  });
}
var jy = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (F) {
        m(F);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (F) {
        m(F);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const If = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, l6 = ot({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(r) {
  const i = pr(dc), l = Re(null), d = Re(""), f = Me(() => {
    const { file: re } = r;
    return re.status === "finished" ? "success" : re.status === "error" ? "error" : "info";
  }), g = Me(() => {
    const { file: re } = r;
    if (re.status === "error") return "error";
  }), m = Me(() => {
    const { file: re } = r;
    return re.status === "uploading";
  }), s = Me(() => {
    if (!i.showCancelButtonRef.value) return false;
    const { file: re } = r;
    return ["uploading", "pending", "error"].includes(re.status);
  }), C = Me(() => {
    if (!i.showRemoveButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), P = Me(() => {
    if (!i.showDownloadButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), M = Me(() => {
    if (!i.showRetryButtonRef.value) return false;
    const { file: re } = r;
    return ["error"].includes(re.status);
  }), F = yi(() => d.value || r.file.thumbnailUrl || r.file.url), D = Me(() => {
    if (!i.showPreviewButtonRef.value) return false;
    const { file: { status: re }, listType: X } = r;
    return ["finished"].includes(re) && F.value && X === "image-card";
  });
  function A() {
    return jy(this, void 0, void 0, function* () {
      const re = i.onRetryRef.value;
      re && (yield re({ file: r.file })) === false || i.submit(r.file.id);
    });
  }
  function O(re) {
    re.preventDefault();
    const { file: X } = r;
    ["finished", "pending", "error"].includes(X.status) ? Y(X) : ["uploading"].includes(X.status) ? ee(X) : qf("upload", "The button clicked type is unknown.");
  }
  function V(re) {
    re.preventDefault(), W(r.file);
  }
  function Y(re) {
    const { xhrMap: X, doChange: Se, onRemoveRef: { value: pe }, mergedFileListRef: { value: oe } } = i;
    Promise.resolve(pe ? pe({ file: Object.assign({}, re), fileList: oe, index: r.index }) : true).then((fe) => {
      if (fe === false) return;
      const _e = Object.assign({}, re, { status: "removed" });
      X.delete(re.id), Se(_e, void 0, { remove: true });
    });
  }
  function W(re) {
    const { onDownloadRef: { value: X }, customDownloadRef: { value: Se } } = i;
    Promise.resolve(X ? X(Object.assign({}, re)) : true).then((pe) => {
      pe !== false && (Se ? Se(Object.assign({}, re)) : xb(re.url, re.name));
    });
  }
  function ee(re) {
    const { xhrMap: X } = i, Se = X.get(re.id);
    Se == null ? void 0 : Se.abort(), Y(Object.assign({}, re));
  }
  function ie(re) {
    const { onPreviewRef: { value: X } } = i;
    if (X) X(r.file, { event: re });
    else if (r.listType === "image-card") {
      const { value: Se } = l;
      if (!Se) return;
      Se.showPreview();
    }
  }
  const te = () => jy(this, void 0, void 0, function* () {
    const { listType: re } = r;
    re !== "image" && re !== "image-card" || i.shouldUseThumbnailUrlRef.value(r.file) && (d.value = yield i.getFileThumbnailUrlResolver(r.file));
  });
  return vo(() => {
    te();
  }), { mergedTheme: i.mergedThemeRef, progressStatus: f, buttonType: g, showProgress: m, disabled: i.mergedDisabledRef, showCancelButton: s, showRemoveButton: C, showDownloadButton: P, showRetryButton: M, showPreviewButton: D, mergedThumbnailUrl: F, shouldUseThumbnailUrl: i.shouldUseThumbnailUrlRef, renderIcon: i.renderIconRef, imageRef: l, handleRemoveOrCancelClick: O, handleDownloadClick: V, handleRetryClick: A, handlePreviewClick: ie };
}, render() {
  const { clsPrefix: r, mergedTheme: i, listType: l, file: d, renderIcon: f } = this;
  let g;
  const m = l === "image";
  m || l === "image-card" ? g = !this.shouldUseThumbnailUrl(d) || !this.mergedThumbnailUrl ? B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : t1(d) ? B(Wr, { clsPrefix: r }, { default: Q5 }) : B(Wr, { clsPrefix: r }, { default: e6 })) : B("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, class: `${r}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? B(Wb, { src: this.mergedThumbnailUrl || void 0, previewSrc: d.url || void 0, alt: d.name, ref: "imageRef" }) : B("img", { src: this.mergedThumbnailUrl || void 0, alt: d.name })) : g = B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : B(Wr, { clsPrefix: r }, { default: () => B(ek, null) }));
  const C = B(t6, { show: this.showProgress, percentage: d.percentage || 0, status: this.progressStatus }), P = l === "text" || l === "image";
  return B("div", { class: [`${r}-upload-file`, `${r}-upload-file--${this.progressStatus}-status`, d.url && d.status !== "error" && l !== "image-card" && `${r}-upload-file--with-url`, `${r}-upload-file--${l}-type`] }, B("div", { class: `${r}-upload-file-info` }, g, B("div", { class: `${r}-upload-file-info__name` }, P && (d.url && d.status !== "error" ? B("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, onClick: this.handlePreviewClick }, d.name) : B("span", { onClick: this.handlePreviewClick }, d.name)), m && C), B("div", { class: [`${r}-upload-file-info__action`, `${r}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? B(Nr, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: If }, { icon: () => B(Wr, { clsPrefix: r }, { default: () => B(Cb, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && B(Nr, { key: "cancelOrTrash", theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, quaternary: true, builtinThemeOverrides: If, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => B(rp, null, { default: () => this.showRemoveButton ? B(Wr, { clsPrefix: r, key: "trash" }, { default: () => B(fk, null) }) : B(Wr, { clsPrefix: r, key: "cancel" }, { default: () => B(tk, null) }) }) }), this.showRetryButton && !this.disabled && B(Nr, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: If }, { icon: () => B(Wr, { clsPrefix: r }, { default: () => B(ck, null) }) }), this.showDownloadButton ? B(Nr, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: If }, { icon: () => B(Wr, { clsPrefix: r }, { default: () => B(wb, null) }) }) : null)), !m && C);
} }), r1 = ot({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(r, { slots: i }) {
  const l = pr(dc, null);
  l || Xo("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: d, mergedDisabledRef: f, maxReachedRef: g, listTypeRef: m, dragOverRef: s, openOpenFileDialog: C, draggerInsideRef: P, handleFileAddition: M, mergedDirectoryDndRef: F, triggerClassRef: D, triggerStyleRef: A } = l, O = Me(() => m.value === "image-card");
  function V() {
    f.value || g.value || C();
  }
  function Y(te) {
    te.preventDefault(), s.value = true;
  }
  function W(te) {
    te.preventDefault(), s.value = true;
  }
  function ee(te) {
    te.preventDefault(), s.value = false;
  }
  function ie(te) {
    var re;
    if (te.preventDefault(), !P.value || f.value || g.value) {
      s.value = false;
      return;
    }
    const X = (re = te.dataTransfer) === null || re === void 0 ? void 0 : re.items;
    (X == null ? void 0 : X.length) ? a6(Array.from(X).map((Se) => Se.webkitGetAsEntry()), F.value).then((Se) => {
      M(Se);
    }).finally(() => {
      s.value = false;
    }) : s.value = false;
  }
  return () => {
    var te;
    const { value: re } = d;
    return r.abstract ? (te = i.default) === null || te === void 0 ? void 0 : te.call(i, { handleClick: V, handleDrop: ie, handleDragOver: Y, handleDragEnter: W, handleDragLeave: ee }) : B("div", { class: [`${re}-upload-trigger`, (f.value || g.value) && `${re}-upload-trigger--disabled`, O.value && `${re}-upload-trigger--image-card`, D.value], style: A.value, onClick: V, onDrop: ie, onDragover: Y, onDragenter: W, onDragleave: ee }, O.value ? B(Qb, null, { default: () => Kn(i.default, () => [B(Wr, { clsPrefix: re }, { default: () => B(up, null) })]) }) : i);
  };
} }), u6 = ot({ name: "UploadFileList", setup(r, { slots: i }) {
  const l = pr(dc, null);
  l || Xo("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: d, mergedClsPrefixRef: f, listTypeRef: g, mergedFileListRef: m, fileListClassRef: s, fileListStyleRef: C, cssVarsRef: P, themeClassRef: M, maxReachedRef: F, showTriggerRef: D, imageGroupPropsRef: A } = l, O = Me(() => g.value === "image-card"), V = () => m.value.map((W, ee) => B(l6, { clsPrefix: f.value, key: W.id, file: W, index: ee, listType: g.value })), Y = () => O.value ? B(f5, Object.assign({}, A.value), { default: V }) : B(qg, { group: true }, { default: V });
  return () => {
    const { value: W } = f, { value: ee } = d;
    return B("div", { class: [`${W}-upload-file-list`, O.value && `${W}-upload-file-list--grid`, ee ? M == null ? void 0 : M.value : void 0, s.value], style: [ee && P ? P.value : "", C.value] }, Y(), D.value && !F.value && O.value && B(r1, null, i));
  };
} });
var Ny = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (F) {
        m(F);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (F) {
        m(F);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
function c6(r, i, l) {
  const { doChange: d, xhrMap: f } = r;
  let g = 0;
  function m(C) {
    var P;
    let M = Object.assign({}, i, { status: "error", percentage: g });
    f.delete(i.id), M = Hd(((P = r.onError) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: C })) || M), d(M, C);
  }
  function s(C) {
    var P;
    if (r.isErrorState) {
      if (r.isErrorState(l)) {
        m(C);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      m(C);
      return;
    }
    let M = Object.assign({}, i, { status: "finished", percentage: g });
    f.delete(i.id), M = Hd(((P = r.onFinish) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: C })) || M), d(M, C);
  }
  return { handleXHRLoad: s, handleXHRError: m, handleXHRAbort(C) {
    const P = Object.assign({}, i, { status: "removed", file: null, percentage: g });
    f.delete(i.id), d(P, C);
  }, handleXHRProgress(C) {
    const P = Object.assign({}, i, { status: "uploading" });
    if (C.lengthComputable) {
      const M = Math.ceil(C.loaded / C.total * 100);
      P.percentage = M, g = M;
    }
    d(P, C);
  } };
}
function d6(r) {
  const { inst: i, file: l, data: d, headers: f, withCredentials: g, action: m, customRequest: s } = r, { doChange: C } = r.inst;
  let P = 0;
  s({ file: l, data: d, headers: f, withCredentials: g, action: m, onProgress(M) {
    const F = Object.assign({}, l, { status: "uploading" }), D = M.percent;
    F.percentage = D, P = D, C(F);
  }, onFinish() {
    var M;
    let F = Object.assign({}, l, { status: "finished", percentage: P });
    F = Hd(((M = i.onFinish) === null || M === void 0 ? void 0 : M.call(i, { file: F })) || F), C(F);
  }, onError() {
    var M;
    let F = Object.assign({}, l, { status: "error", percentage: P });
    F = Hd(((M = i.onError) === null || M === void 0 ? void 0 : M.call(i, { file: F })) || F), C(F);
  } });
}
function h6(r, i, l) {
  const d = c6(r, i, l);
  l.onabort = d.handleXHRAbort, l.onerror = d.handleXHRError, l.onload = d.handleXHRLoad, l.upload && (l.upload.onprogress = d.handleXHRProgress);
}
function i1(r, i) {
  return typeof r == "function" ? r({ file: i }) : r || {};
}
function f6(r, i, l) {
  const d = i1(i, l);
  d && Object.keys(d).forEach((f) => {
    r.setRequestHeader(f, d[f]);
  });
}
function p6(r, i, l) {
  const d = i1(i, l);
  d && Object.keys(d).forEach((f) => {
    r.append(f, d[f]);
  });
}
function m6(r, i, l, { method: d, action: f, withCredentials: g, responseType: m, headers: s, data: C }) {
  const P = new XMLHttpRequest();
  P.responseType = m, r.xhrMap.set(l.id, P), P.withCredentials = g;
  const M = new FormData();
  if (p6(M, C, l), l.file !== null && M.append(i, l.file), h6(r, l, P), f !== void 0) {
    P.open(d.toUpperCase(), f), f6(P, s, l), P.send(M);
    const F = Object.assign({}, l, { status: "uploading" });
    r.doChange(F);
  }
}
const g6 = Object.assign(Object.assign({}, rr.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (r) => i6 ? t1(r) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), v6 = ot({ name: "Upload", props: g6, setup(r) {
  r.abstract && r.listType === "image-card" && Xo("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Mr(r), f = rr("Upload", "-upload", J5, lC, r, i), g = Un("Upload", d, i), m = ya(r), s = Re(r.defaultFileList), C = Bt(r, "fileList"), P = Re(null), M = { value: false }, F = Re(false), D = /* @__PURE__ */ new Map(), A = Hi(C, s), O = Me(() => A.value.map(Hd)), V = Me(() => {
    const { max: _e } = r;
    return _e !== void 0 ? O.value.length >= _e : false;
  });
  function Y() {
    var _e;
    (_e = P.value) === null || _e === void 0 || _e.click();
  }
  function W(_e) {
    const qe = _e.target;
    re(qe.files ? Array.from(qe.files).map((Ve) => ({ file: Ve, entry: null, source: "input" })) : null, _e), qe.value = "";
  }
  function ee(_e) {
    const { "onUpdate:fileList": qe, onUpdateFileList: Ve } = r;
    qe && jt(qe, _e), Ve && jt(Ve, _e), s.value = _e;
  }
  const ie = Me(() => r.multiple || r.directory), te = (_e, qe, Ve = { append: false, remove: false }) => {
    const { append: Qe, remove: ut } = Ve, gt = Array.from(O.value), yt = gt.findIndex((lt) => lt.id === _e.id);
    if (Qe || ut || ~yt) {
      Qe ? gt.push(_e) : ut ? gt.splice(yt, 1) : gt.splice(yt, 1, _e);
      const { onChange: lt } = r;
      lt && lt({ file: _e, fileList: gt, event: qe }), ee(gt);
    }
  };
  function re(_e, qe) {
    if (!_e || _e.length === 0) return;
    const { onBeforeUpload: Ve } = r;
    _e = ie.value ? _e : [_e[0]];
    const { max: Qe, accept: ut } = r;
    _e = _e.filter(({ file: yt, source: lt }) => lt === "dnd" && (ut == null ? void 0 : ut.trim()) ? s6(yt.name, yt.type, ut) : true), Qe && (_e = _e.slice(0, Qe - O.value.length));
    const gt = Dl();
    Promise.all(_e.map((yt) => Ny(this, [yt], void 0, function* ({ file: lt, entry: et }) {
      var dt;
      const Ft = { id: Dl(), batchId: gt, name: lt.name, status: "pending", percentage: 0, file: lt, url: null, type: lt.type, thumbnailUrl: null, fullPath: (dt = et == null ? void 0 : et.fullPath) !== null && dt !== void 0 ? dt : `/${lt.webkitRelativePath || lt.name}` };
      return !Ve || (yield Ve({ file: Ft, fileList: O.value })) !== false ? Ft : null;
    }))).then((yt) => Ny(this, void 0, void 0, function* () {
      let lt = Promise.resolve();
      yt.forEach((et) => {
        lt = lt.then(Vn).then(() => {
          et && te(et, qe, { append: true });
        });
      }), yield lt;
    })).then(() => {
      r.defaultUpload && X();
    });
  }
  function X(_e) {
    const { method: qe, action: Ve, withCredentials: Qe, headers: ut, data: gt, name: yt } = r, lt = _e !== void 0 ? O.value.filter((dt) => dt.id === _e) : O.value, et = _e !== void 0;
    lt.forEach((dt) => {
      const { status: Ft } = dt;
      (Ft === "pending" || Ft === "error" && et) && (r.customRequest ? d6({ inst: { doChange: te, xhrMap: D, onFinish: r.onFinish, onError: r.onError }, file: dt, action: Ve, withCredentials: Qe, headers: ut, data: gt, customRequest: r.customRequest }) : m6({ doChange: te, xhrMap: D, onFinish: r.onFinish, onError: r.onError, isErrorState: r.isErrorState }, yt, dt, { method: qe, action: Ve, withCredentials: Qe, responseType: r.responseType, headers: ut, data: gt }));
    });
  }
  function Se(_e) {
    var qe;
    if (_e.thumbnailUrl) return _e.thumbnailUrl;
    const { createThumbnailUrl: Ve } = r;
    return Ve ? (qe = Ve(_e.file, _e)) !== null && qe !== void 0 ? qe : _e.url || "" : _e.url ? _e.url : _e.file ? r6(_e.file) : "";
  }
  const pe = Me(() => {
    const { common: { cubicBezierEaseInOut: _e }, self: { draggerColor: qe, draggerBorder: Ve, draggerBorderHover: Qe, itemColorHover: ut, itemColorHoverError: gt, itemTextColorError: yt, itemTextColorSuccess: lt, itemTextColor: et, itemIconColor: dt, itemDisabledOpacity: Ft, lineHeight: ft, borderRadius: _t, fontSize: $t, itemBorderImageCardError: Qt, itemBorderImageCard: Lt } } = f.value;
    return { "--n-bezier": _e, "--n-border-radius": _t, "--n-dragger-border": Ve, "--n-dragger-border-hover": Qe, "--n-dragger-color": qe, "--n-font-size": $t, "--n-item-color-hover": ut, "--n-item-color-hover-error": gt, "--n-item-disabled-opacity": Ft, "--n-item-icon-color": dt, "--n-item-text-color": et, "--n-item-text-color-error": yt, "--n-item-text-color-success": lt, "--n-line-height": ft, "--n-item-border-image-card-error": Qt, "--n-item-border-image-card": Lt };
  }), oe = l ? bi("upload", void 0, pe, r) : void 0;
  Zr(dc, { mergedClsPrefixRef: i, mergedThemeRef: f, showCancelButtonRef: Bt(r, "showCancelButton"), showDownloadButtonRef: Bt(r, "showDownloadButton"), showRemoveButtonRef: Bt(r, "showRemoveButton"), showRetryButtonRef: Bt(r, "showRetryButton"), onRemoveRef: Bt(r, "onRemove"), onDownloadRef: Bt(r, "onDownload"), customDownloadRef: Bt(r, "customDownload"), mergedFileListRef: O, triggerClassRef: Bt(r, "triggerClass"), triggerStyleRef: Bt(r, "triggerStyle"), shouldUseThumbnailUrlRef: Bt(r, "shouldUseThumbnailUrl"), renderIconRef: Bt(r, "renderIcon"), xhrMap: D, submit: X, doChange: te, showPreviewButtonRef: Bt(r, "showPreviewButton"), onPreviewRef: Bt(r, "onPreview"), getFileThumbnailUrlResolver: Se, listTypeRef: Bt(r, "listType"), dragOverRef: F, openOpenFileDialog: Y, draggerInsideRef: M, handleFileAddition: re, mergedDisabledRef: m.mergedDisabledRef, maxReachedRef: V, fileListClassRef: Bt(r, "fileListClass"), fileListStyleRef: Bt(r, "fileListStyle"), abstractRef: Bt(r, "abstract"), acceptRef: Bt(r, "accept"), cssVarsRef: l ? void 0 : pe, themeClassRef: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, showTriggerRef: Bt(r, "showTrigger"), imageGroupPropsRef: Bt(r, "imageGroupProps"), mergedDirectoryDndRef: Me(() => {
    var _e;
    return (_e = r.directoryDnd) !== null && _e !== void 0 ? _e : r.directory;
  }), onRetryRef: Bt(r, "onRetry") });
  const fe = { clear: () => {
    s.value = [];
  }, submit: X, openOpenFileDialog: Y };
  return Object.assign({ mergedClsPrefix: i, draggerInsideRef: M, rtlEnabled: g, inputElRef: P, mergedTheme: f, dragOver: F, mergedMultiple: ie, cssVars: l ? void 0 : pe, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, handleFileInputChange: W }, fe);
}, render() {
  var r, i;
  const { draggerInsideRef: l, mergedClsPrefix: d, $slots: f, directory: g, onRender: m } = this;
  if (f.default && !this.abstract) {
    const C = f.default()[0];
    !((r = C == null ? void 0 : C.type) === null || r === void 0) && r[Jb] && (l.value = true);
  }
  const s = B("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${d}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: g || void 0, directory: g || void 0 }));
  return this.abstract ? B(Hr, null, (i = f.default) === null || i === void 0 ? void 0 : i.call(f), B(k_, { to: "body" }, s)) : (m == null ? void 0 : m(), B("div", { class: [`${d}-upload`, this.rtlEnabled && `${d}-upload--rtl`, l.value && `${d}-upload--dragger-inside`, this.dragOver && `${d}-upload--drag-over`, this.themeClass], style: this.cssVars }, s, this.showTrigger && this.listType !== "image-card" && B(r1, null, f), this.showFileList && B(u6, null, f)));
} });
function ks() {
  const r = pr(E_, null);
  return Me(() => {
    if (r === null) return ey;
    const { mergedThemeRef: { value: i }, mergedThemeOverridesRef: { value: l } } = r, d = (i == null ? void 0 : i.common) || ey;
    return (l == null ? void 0 : l.common) ? Object.assign({}, d, l.common) : d;
  });
}
var Nf = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.8.0/LICENSE.txt
*/
var y6 = Nf.exports, Vy;
function _6() {
  return Vy || (Vy = 1, (function(r, i) {
    (function(l, d) {
      r.exports = d();
    })(y6, (function() {
      var l = {}, d = {};
      function f(m, s, C) {
        if (d[m] = C, m === "index") {
          var P = "var sharedModule = {}; (" + d.shared + ")(sharedModule); (" + d.worker + ")(sharedModule);", M = {};
          return d.shared(M), d.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([P], { type: "text/javascript" }))), l;
        }
      }
      f("shared", ["exports"], (function(m) {
        function s(o, t, n, u) {
          return new (n || (n = Promise))((function(h, v) {
            function b(I) {
              try {
                S(u.next(I));
              } catch (E) {
                v(E);
              }
            }
            function w(I) {
              try {
                S(u.throw(I));
              } catch (E) {
                v(E);
              }
            }
            function S(I) {
              var E;
              I.done ? h(I.value) : (E = I.value, E instanceof n ? E : new n((function(L) {
                L(E);
              }))).then(b, w);
            }
            S((u = u.apply(o, t || [])).next());
          }));
        }
        function C(o, t) {
          this.x = o, this.y = t;
        }
        function P(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var M, F;
        typeof SuppressedError == "function" && SuppressedError, C.prototype = { clone() {
          return new C(this.x, this.y);
        }, add(o) {
          return this.clone()._add(o);
        }, sub(o) {
          return this.clone()._sub(o);
        }, multByPoint(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint(o) {
          return this.clone()._divByPoint(o);
        }, mult(o) {
          return this.clone()._mult(o);
        }, div(o) {
          return this.clone()._div(o);
        }, rotate(o) {
          return this.clone()._rotate(o);
        }, rotateAround(o, t) {
          return this.clone()._rotateAround(o, t);
        }, matMult(o) {
          return this.clone()._matMult(o);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(o) {
          return this.x === o.x && this.y === o.y;
        }, dist(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr(o) {
          const t = o.x - this.x, n = o.y - this.y;
          return t * t + n * n;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep(o, t) {
          return Math.atan2(this.x * t - this.y * o, this.x * o + this.y * t);
        }, _matMult(o) {
          const t = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = t, this;
        }, _add(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult(o) {
          return this.x *= o, this.y *= o, this;
        }, _div(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate(o) {
          const t = Math.cos(o), n = Math.sin(o), u = n * this.x + t * this.y;
          return this.x = t * this.x - n * this.y, this.y = u, this;
        }, _rotateAround(o, t) {
          const n = Math.cos(o), u = Math.sin(o), h = t.y + u * (this.x - t.x) + n * (this.y - t.y);
          return this.x = t.x + n * (this.x - t.x) - u * (this.y - t.y), this.y = h, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: C }, C.convert = function(o) {
          if (o instanceof C) return o;
          if (Array.isArray(o)) return new C(+o[0], +o[1]);
          if (o.x !== void 0 && o.y !== void 0) return new C(+o.x, +o.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var D = (function() {
          if (F) return M;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return F = 1, M = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var v = this.sampleCurveX(u) - t;
              if (Math.abs(v) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= v / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (v = this.sampleCurveX(u), !(Math.abs(v - t) < n)); h++) t > v ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, M;
        })(), A = P(D);
        let O, V;
        function Y() {
          return O == null && (O = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), O;
        }
        function W() {
          if (V == null && (V = false, Y())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (t) {
              for (let u = 0; u < 25; u++) {
                const h = 4 * u;
                t.fillStyle = `rgb(${h},${h + 1},${h + 2})`, t.fillRect(u % 5, Math.floor(u / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let u = 0; u < 100; u++) if (u % 4 != 3 && n[u] !== u) {
                V = true;
                break;
              }
            }
          }
          return V || false;
        }
        var ee = 1e-6, ie = typeof Float32Array < "u" ? Float32Array : Array;
        function te() {
          var o = new ie(9);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
        }
        function re(o) {
          return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }
        function X() {
          var o = new ie(3);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o;
        }
        function Se(o) {
          var t = o[0], n = o[1], u = o[2];
          return Math.sqrt(t * t + n * n + u * u);
        }
        function pe(o, t, n) {
          var u = new ie(3);
          return u[0] = o, u[1] = t, u[2] = n, u;
        }
        function oe(o, t, n) {
          return o[0] = t[0] + n[0], o[1] = t[1] + n[1], o[2] = t[2] + n[2], o;
        }
        function fe(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o;
        }
        function _e(o, t, n) {
          var u = t[0], h = t[1], v = t[2], b = n[0], w = n[1], S = n[2];
          return o[0] = h * S - v * w, o[1] = v * b - u * S, o[2] = u * w - h * b, o;
        }
        var qe, Ve = Se;
        function Qe(o, t, n) {
          var u = t[0], h = t[1], v = t[2], b = t[3];
          return o[0] = n[0] * u + n[4] * h + n[8] * v + n[12] * b, o[1] = n[1] * u + n[5] * h + n[9] * v + n[13] * b, o[2] = n[2] * u + n[6] * h + n[10] * v + n[14] * b, o[3] = n[3] * u + n[7] * h + n[11] * v + n[15] * b, o;
        }
        function ut() {
          var o = new ie(4);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o[3] = 1, o;
        }
        function gt(o, t, n, u) {
          var h = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", v = Math.PI / 360;
          t *= v, u *= v, n *= v;
          var b = Math.sin(t), w = Math.cos(t), S = Math.sin(n), I = Math.cos(n), E = Math.sin(u), L = Math.cos(u);
          switch (h) {
            case "xyz":
              o[0] = b * I * L + w * S * E, o[1] = w * S * L - b * I * E, o[2] = w * I * E + b * S * L, o[3] = w * I * L - b * S * E;
              break;
            case "xzy":
              o[0] = b * I * L - w * S * E, o[1] = w * S * L - b * I * E, o[2] = w * I * E + b * S * L, o[3] = w * I * L + b * S * E;
              break;
            case "yxz":
              o[0] = b * I * L + w * S * E, o[1] = w * S * L - b * I * E, o[2] = w * I * E - b * S * L, o[3] = w * I * L + b * S * E;
              break;
            case "yzx":
              o[0] = b * I * L + w * S * E, o[1] = w * S * L + b * I * E, o[2] = w * I * E - b * S * L, o[3] = w * I * L - b * S * E;
              break;
            case "zxy":
              o[0] = b * I * L - w * S * E, o[1] = w * S * L + b * I * E, o[2] = w * I * E + b * S * L, o[3] = w * I * L - b * S * E;
              break;
            case "zyx":
              o[0] = b * I * L - w * S * E, o[1] = w * S * L + b * I * E, o[2] = w * I * E - b * S * L, o[3] = w * I * L + b * S * E;
              break;
            default:
              throw new Error("Unknown angle order " + h);
          }
          return o;
        }
        function yt() {
          var o = new ie(2);
          return ie != Float32Array && (o[0] = 0, o[1] = 0), o;
        }
        function lt(o, t) {
          var n = new ie(2);
          return n[0] = o, n[1] = t, n;
        }
        X(), qe = new ie(4), ie != Float32Array && (qe[0] = 0, qe[1] = 0, qe[2] = 0, qe[3] = 0), X(), pe(1, 0, 0), pe(0, 1, 0), ut(), ut(), te(), yt();
        const et = 8192;
        function dt(o, t, n) {
          return t * (et / (o.tileSize * Math.pow(2, n - o.tileID.overscaledZ)));
        }
        function Ft(o, t) {
          return (o % t + t) % t;
        }
        function ft(o, t, n) {
          return o * (1 - n) + t * n;
        }
        function _t(o) {
          if (o <= 0) return 0;
          if (o >= 1) return 1;
          const t = o * o, n = t * o;
          return 4 * (o < 0.5 ? n : 3 * (o - t) + n - 0.75);
        }
        function $t(o, t, n, u) {
          const h = new A(o, t, n, u);
          return (v) => h.solve(v);
        }
        const Qt = $t(0.25, 0.1, 0.25, 1);
        function Lt(o, t, n) {
          return Math.min(n, Math.max(t, o));
        }
        function zt(o, t, n) {
          const u = n - t, h = ((o - t) % u + u) % u + t;
          return h === t ? n : h;
        }
        function It(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        let At = 1;
        function mr(o, t, n) {
          const u = {};
          for (const h in o) u[h] = t.call(this, o[h], h, o);
          return u;
        }
        function gr(o, t, n) {
          const u = {};
          for (const h in o) t.call(this, o[h], h, o) && (u[h] = o[h]);
          return u;
        }
        function ir(o) {
          return Array.isArray(o) ? o.map(ir) : typeof o == "object" && o ? mr(o, ir) : o;
        }
        const nr = {};
        function Ut(o) {
          nr[o] || (typeof console < "u" && console.warn(o), nr[o] = true);
        }
        function Ar(o, t, n) {
          return (n.y - o.y) * (t.x - o.x) > (t.y - o.y) * (n.x - o.x);
        }
        function wr(o) {
          return typeof WorkerGlobalScope < "u" && o !== void 0 && o instanceof WorkerGlobalScope;
        }
        let Ct = null;
        function Ee(o) {
          return typeof ImageBitmap < "u" && o instanceof ImageBitmap;
        }
        const nt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Be(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const v = new VideoFrame(o, { timestamp: 0 });
            try {
              const b = v == null ? void 0 : v.format;
              if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
              const w = b.startsWith("BGR"), S = new Uint8ClampedArray(u * h * 4);
              if (yield v.copyTo(S, (function(I, E, L, N, q) {
                const G = 4 * Math.max(-E, 0), K = (Math.max(0, L) - L) * N * 4 + G, ae = 4 * N, me = Math.max(0, E), Oe = Math.max(0, L);
                return { rect: { x: me, y: Oe, width: Math.min(I.width, E + N) - me, height: Math.min(I.height, L + q) - Oe }, layout: [{ offset: K, stride: ae }] };
              })(o, t, n, u, h)), w) for (let I = 0; I < S.length; I += 4) {
                const E = S[I];
                S[I] = S[I + 2], S[I + 2] = E;
              }
              return S;
            } finally {
              v.close();
            }
          }));
        }
        let Ye, ht;
        function bt(o, t, n, u) {
          return o.addEventListener(t, n, u), { unsubscribe: () => {
            o.removeEventListener(t, n, u);
          } };
        }
        function tt(o) {
          return o * Math.PI / 180;
        }
        function mt(o) {
          return o / Math.PI * 180;
        }
        const Kt = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, Qr = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, ki = "AbortError";
        function ze() {
          return new Error(ki);
        }
        const Z = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function H(o) {
          return Z.REGISTERED_PROTOCOLS[o.substring(0, o.indexOf("://"))];
        }
        const ne = "global-dispatcher";
        class xe extends Error {
          constructor(t, n, u, h) {
            super(`AJAXError: ${n} (${t}): ${u}`), this.status = t, this.statusText = n, this.url = u, this.body = h;
          }
        }
        const Pe = () => wr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, De = function(o, t) {
          if (/:\/\//.test(o.url) && !/^https?:|^file:/.test(o.url)) {
            const u = H(o.url);
            if (u) return u(o, t);
            if (wr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, targetMapId: ne }, t);
          }
          if (!(/^file:/.test(n = o.url) || /^file:/.test(Pe()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(u, h) {
              return s(this, void 0, void 0, (function* () {
                const v = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: Pe(), signal: h.signal });
                let b, w;
                u.type !== "json" || v.headers.has("Accept") || v.headers.set("Accept", "application/json");
                try {
                  b = yield fetch(v);
                } catch (I) {
                  throw new xe(0, I.message, u.url, new Blob());
                }
                if (!b.ok) {
                  const I = yield b.blob();
                  throw new xe(b.status, b.statusText, u.url, I);
                }
                w = u.type === "arrayBuffer" || u.type === "image" ? b.arrayBuffer() : u.type === "json" ? b.json() : b.text();
                const S = yield w;
                if (h.signal.aborted) throw ze();
                return { data: S, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
              }));
            })(o, t);
            if (wr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, mustQueue: true, targetMapId: ne }, t);
          }
          var n;
          return (function(u, h) {
            return new Promise(((v, b) => {
              var w;
              const S = new XMLHttpRequest();
              S.open(u.method || "GET", u.url, true), u.type !== "arrayBuffer" && u.type !== "image" || (S.responseType = "arraybuffer");
              for (const I in u.headers) S.setRequestHeader(I, u.headers[I]);
              u.type === "json" && (S.responseType = "text", !((w = u.headers) === null || w === void 0) && w.Accept || S.setRequestHeader("Accept", "application/json")), S.withCredentials = u.credentials === "include", S.onerror = () => {
                b(new Error(S.statusText));
              }, S.onload = () => {
                if (!h.signal.aborted) if ((S.status >= 200 && S.status < 300 || S.status === 0) && S.response !== null) {
                  let I = S.response;
                  if (u.type === "json") try {
                    I = JSON.parse(S.response);
                  } catch (E) {
                    return void b(E);
                  }
                  v({ data: I, cacheControl: S.getResponseHeader("Cache-Control"), expires: S.getResponseHeader("Expires") });
                } else {
                  const I = new Blob([S.response], { type: S.getResponseHeader("Content-Type") });
                  b(new xe(S.status, S.statusText, u.url, I));
                }
              }, h.signal.addEventListener("abort", (() => {
                S.abort(), b(ze());
              })), S.send(u.body);
            }));
          })(o, t);
        };
        function he(o) {
          if (!o || o.indexOf("://") <= 0 || o.indexOf("data:image/") === 0 || o.indexOf("blob:") === 0) return true;
          const t = new URL(o), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function ve(o, t, n) {
          n[o] && n[o].indexOf(t) !== -1 || (n[o] = n[o] || [], n[o].push(t));
        }
        function je(o, t, n) {
          if (n && n[o]) {
            const u = n[o].indexOf(t);
            u !== -1 && n[o].splice(u, 1);
          }
        }
        class it {
          constructor(t, n = {}) {
            It(this, n), this.type = t;
          }
        }
        class Xe extends it {
          constructor(t, n = {}) {
            super("error", It({ error: t }, n));
          }
        }
        class xt {
          on(t, n) {
            return this._listeners = this._listeners || {}, ve(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return je(t, n, this._listeners), je(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ve(t, n, this._oneTimeListeners), this) : new Promise(((u) => this.once(t, u)));
          }
          fire(t, n) {
            typeof t == "string" && (t = new it(t, n || {}));
            const u = t.type;
            if (this.listens(u)) {
              t.target = this;
              const h = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
              for (const w of h) w.call(this, t);
              const v = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
              for (const w of v) je(u, w, this._oneTimeListeners), w.call(this, t);
              const b = this._eventedParent;
              b && (It(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
            } else t instanceof Xe && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var Te = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const Vt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function or(o, t) {
          const n = {};
          for (const u in o) u !== "ref" && (n[u] = o[u]);
          return Vt.forEach(((u) => {
            u in t && (n[u] = t[u]);
          })), n;
        }
        function qt(o, t) {
          if (Array.isArray(o)) {
            if (!Array.isArray(t) || o.length !== t.length) return false;
            for (let n = 0; n < o.length; n++) if (!qt(o[n], t[n])) return false;
            return true;
          }
          if (typeof o == "object" && o !== null && t !== null) {
            if (typeof t != "object" || Object.keys(o).length !== Object.keys(t).length) return false;
            for (const n in o) if (!qt(o[n], t[n])) return false;
            return true;
          }
          return o === t;
        }
        function dr(o, t) {
          o.push(t);
        }
        function Br(o, t, n) {
          dr(n, { command: "addSource", args: [o, t[o]] });
        }
        function Vr(o, t, n) {
          dr(t, { command: "removeSource", args: [o] }), n[o] = true;
        }
        function Kr(o, t, n, u) {
          Vr(o, n, u), Br(o, t, n);
        }
        function ci(o, t, n) {
          let u;
          for (u in o[n]) if (Object.prototype.hasOwnProperty.call(o[n], u) && u !== "data" && !qt(o[n][u], t[n][u])) return false;
          for (u in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], u) && u !== "data" && !qt(o[n][u], t[n][u])) return false;
          return true;
        }
        function di(o, t, n, u, h, v) {
          o = o || {}, t = t || {};
          for (const b in o) Object.prototype.hasOwnProperty.call(o, b) && (qt(o[b], t[b]) || n.push({ command: v, args: [u, b, t[b], h] }));
          for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(o, b) && (qt(o[b], t[b]) || n.push({ command: v, args: [u, b, t[b], h] }));
        }
        function Lr(o) {
          return o.id;
        }
        function Ur(o, t) {
          return o[t.id] = t, o;
        }
        class de {
          constructor(t, n, u, h) {
            this.message = (t ? `${t}: ` : "") + u, h && (this.identifier = h), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function at(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        class Zt extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class Rr {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [u, h] of n) this.bindings[u] = h;
          }
          concat(t) {
            return new Rr(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const Cr = { kind: "null" }, st = { kind: "number" }, ar = { kind: "string" }, cr = { kind: "boolean" }, ei = { kind: "color" }, pn = { kind: "projectionDefinition" }, rn = { kind: "object" }, hr = { kind: "value" }, Jo = { kind: "collator" }, qn = { kind: "formatted" }, Qo = { kind: "padding" }, kn = { kind: "colorArray" }, _o = { kind: "numberArray" }, Xr = { kind: "resolvedImage" }, to = { kind: "variableAnchorOffsetCollection" };
        function nn(o, t) {
          return { kind: "array", itemType: o, N: t };
        }
        function qr(o) {
          if (o.kind === "array") {
            const t = qr(o.itemType);
            return typeof o.N == "number" ? `array<${t}, ${o.N}>` : o.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return o.kind;
        }
        const Bl = [Cr, st, ar, cr, ei, pn, qn, rn, nn(hr), Qo, _o, kn, Xr, to];
        function xa(o, t) {
          if (t.kind === "error") return null;
          if (o.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !xa(o.itemType, t.itemType)) && (typeof o.N != "number" || o.N === t.N)) return null;
          } else {
            if (o.kind === t.kind) return null;
            if (o.kind === "value") {
              for (const n of Bl) if (!xa(n, t)) return null;
            }
          }
          return `Expected ${qr(o)} but found ${qr(t)} instead.`;
        }
        function Es(o, t) {
          return t.some(((n) => n.kind === o.kind));
        }
        function bo(o, t) {
          return t.some(((n) => n === "null" ? o === null : n === "array" ? Array.isArray(o) : n === "object" ? o && !Array.isArray(o) && typeof o == "object" : n === typeof o));
        }
        function xo(o, t) {
          return o.kind === "array" && t.kind === "array" ? o.itemType.kind === t.itemType.kind && typeof o.N == "number" : o.kind === t.kind;
        }
        const Rs = 0.96422, Ol = 0.82521, $l = 4 / 29, ea = 6 / 29, jl = 3 * ea * ea, fc = ea * ea * ea, pc = Math.PI / 180, mc = 180 / Math.PI;
        function As(o) {
          return (o %= 360) < 0 && (o += 360), o;
        }
        function ta([o, t, n, u]) {
          let h, v;
          const b = zs((0.2225045 * (o = Ds(o)) + 0.7168786 * (t = Ds(t)) + 0.0606169 * (n = Ds(n))) / 1);
          o === t && t === n ? h = v = b : (h = zs((0.4360747 * o + 0.3850649 * t + 0.1430804 * n) / Rs), v = zs((0.0139322 * o + 0.0971045 * t + 0.7141733 * n) / Ol));
          const w = 116 * b - 16;
          return [w < 0 ? 0 : w, 500 * (h - b), 200 * (b - v), u];
        }
        function Ds(o) {
          return o <= 0.04045 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
        }
        function zs(o) {
          return o > fc ? Math.pow(o, 1 / 3) : o / jl + $l;
        }
        function ra([o, t, n, u]) {
          let h = (o + 16) / 116, v = isNaN(t) ? h : h + t / 500, b = isNaN(n) ? h : h - n / 200;
          return h = 1 * Ls(h), v = Rs * Ls(v), b = Ol * Ls(b), [Fs(3.1338561 * v - 1.6168667 * h - 0.4906146 * b), Fs(-0.9787684 * v + 1.9161415 * h + 0.033454 * b), Fs(0.0719453 * v - 0.2289914 * h + 1.4052427 * b), u];
        }
        function Fs(o) {
          return (o = o <= 304e-5 ? 12.92 * o : 1.055 * Math.pow(o, 1 / 2.4) - 0.055) < 0 ? 0 : o > 1 ? 1 : o;
        }
        function Ls(o) {
          return o > ea ? o * o * o : jl * (o - $l);
        }
        const gc = Object.hasOwn || function(o, t) {
          return Object.prototype.hasOwnProperty.call(o, t);
        };
        function ia(o, t) {
          return gc(o, t) ? o[t] : void 0;
        }
        function wa(o) {
          return parseInt(o.padEnd(2, o), 16) / 255;
        }
        function An(o, t) {
          return _r(t ? o / 100 : o, 0, 1);
        }
        function _r(o, t, n) {
          return Math.min(Math.max(t, o), n);
        }
        function Ao(o) {
          return !o.some(Number.isNaN);
        }
        const wo = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function ro(o, t, n) {
          return o + n * (t - o);
        }
        function Do(o, t, n) {
          return o.map(((u, h) => ro(u, t[h], n)));
        }
        class br {
          constructor(t, n, u, h = 1, v = true) {
            this.r = t, this.g = n, this.b = u, this.a = h, v || (this.r *= h, this.g *= h, this.b *= h, h || this.overwriteGetter("rgb", [t, n, u, h]));
          }
          static parse(t) {
            if (t instanceof br) return t;
            if (typeof t != "string") return;
            const n = (function(u) {
              if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const h = ia(wo, u);
              if (h) {
                const [b, w, S] = h;
                return [b / 255, w / 255, S / 255, 1];
              }
              if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
                const b = u.length < 6 ? 1 : 2;
                let w = 1;
                return [wa(u.slice(w, w += b)), wa(u.slice(w, w += b)), wa(u.slice(w, w += b)), wa(u.slice(w, w + b) || "ff")];
              }
              if (u.startsWith("rgb")) {
                const b = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (b) {
                  const [w, S, I, E, L, N, q, G, K, ae, me, Oe] = b, Ce = [E || " ", q || " ", ae].join("");
                  if (Ce === "  " || Ce === "  /" || Ce === ",," || Ce === ",,,") {
                    const Ie = [I, N, K].join(""), Ze = Ie === "%%%" ? 100 : Ie === "" ? 255 : 0;
                    if (Ze) {
                      const rt = [_r(+S / Ze, 0, 1), _r(+L / Ze, 0, 1), _r(+G / Ze, 0, 1), me ? An(+me, Oe) : 1];
                      if (Ao(rt)) return rt;
                    }
                  }
                  return;
                }
              }
              const v = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (v) {
                const [b, w, S, I, E, L, N, q, G] = v, K = [S || " ", E || " ", N].join("");
                if (K === "  " || K === "  /" || K === ",," || K === ",,,") {
                  const ae = [+w, _r(+I, 0, 100), _r(+L, 0, 100), q ? An(+q, G) : 1];
                  if (Ao(ae)) return (function([me, Oe, Ce, Ie]) {
                    function Ze(rt) {
                      const vt = (rt + me / 30) % 12, Dt = Oe * Math.min(Ce, 1 - Ce);
                      return Ce - Dt * Math.max(-1, Math.min(vt - 3, 9 - vt, 1));
                    }
                    return me = As(me), Oe /= 100, Ce /= 100, [Ze(0), Ze(8), Ze(4), Ie];
                  })(ae);
                }
              }
            })(t);
            return n ? new br(...n, false) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: u, a: h } = this, v = h || 1 / 0;
            return this.overwriteGetter("rgb", [t / v, n / v, u / v, h]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, u, h, v] = ta(t), b = Math.sqrt(u * u + h * h);
              return [Math.round(1e4 * b) ? As(Math.atan2(h, u) * mc) : NaN, b, n, v];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ta(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, u, h] = this.rgb;
            return `rgba(${[t, n, u].map(((v) => Math.round(255 * v))).join(",")},${h})`;
          }
          static interpolate(t, n, u, h = "rgb") {
            switch (h) {
              case "rgb": {
                const [v, b, w, S] = Do(t.rgb, n.rgb, u);
                return new br(v, b, w, S, false);
              }
              case "hcl": {
                const [v, b, w, S] = t.hcl, [I, E, L, N] = n.hcl;
                let q, G;
                if (isNaN(v) || isNaN(I)) isNaN(v) ? isNaN(I) ? q = NaN : (q = I, w !== 1 && w !== 0 || (G = E)) : (q = v, L !== 1 && L !== 0 || (G = b));
                else {
                  let Ce = I - v;
                  I > v && Ce > 180 ? Ce -= 360 : I < v && v - I > 180 && (Ce += 360), q = v + u * Ce;
                }
                const [K, ae, me, Oe] = (function([Ce, Ie, Ze, rt]) {
                  return Ce = isNaN(Ce) ? 0 : Ce * pc, ra([Ze, Math.cos(Ce) * Ie, Math.sin(Ce) * Ie, rt]);
                })([q, G ?? ro(b, E, u), ro(w, L, u), ro(S, N, u)]);
                return new br(K, ae, me, Oe, false);
              }
              case "lab": {
                const [v, b, w, S] = ra(Do(t.lab, n.lab, u));
                return new br(v, b, w, S, false);
              }
            }
          }
        }
        br.black = new br(0, 0, 0, 1), br.white = new br(1, 1, 1, 1), br.transparent = new br(0, 0, 0, 0), br.red = new br(1, 0, 0, 1);
        class Ca {
          constructor(t, n, u) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Nl = ["bottom", "center", "top"];
        class Vl {
          constructor(t, n, u, h, v, b) {
            this.text = t, this.image = n, this.scale = u, this.fontStack = h, this.textColor = v, this.verticalAlign = b;
          }
        }
        class mn {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new mn([new Vl(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof mn ? t : mn.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class Ni {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Ni) return t;
            if (typeof t == "number") return new Ni([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new Ni(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new Ni(Do(t.values, n.values, u));
          }
        }
        class gn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof gn) return t;
            if (typeof t == "number") return new gn([t]);
            if (Array.isArray(t)) {
              for (const n of t) if (typeof n != "number") return;
              return new gn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new gn(Do(t.values, n.values, u));
          }
        }
        class Mi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Mi) return t;
            if (typeof t == "string") {
              const u = br.parse(t);
              return u ? new Mi([u]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const u of t) {
              if (typeof u != "string") return;
              const h = br.parse(u);
              if (!h) return;
              n.push(h);
            }
            return new Mi(n);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u, h = "rgb") {
            const v = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let b = 0; b < t.values.length; b++) v.push(br.interpolate(t.values[b], n.values[b], u, h));
            return new Mi(v);
          }
        }
        class Jr extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const lh = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class vn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof vn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const u = t[n], h = t[n + 1];
                if (typeof u != "string" || !lh.has(u) || !Array.isArray(h) || h.length !== 2 || typeof h[0] != "number" || typeof h[1] != "number") return;
              }
              return new vn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            const h = t.values, v = n.values;
            if (h.length !== v.length) throw new Jr(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const b = [];
            for (let w = 0; w < h.length; w += 2) {
              if (h[w] !== v[w]) throw new Jr(`Cannot interpolate values containing mismatched anchors. from[${w}]: ${h[w]}, to[${w}]: ${v[w]}`);
              b.push(h[w]);
              const [S, I] = h[w + 1], [E, L] = v[w + 1];
              b.push([ro(S, E, u), ro(I, L, u)]);
            }
            return new vn(b);
          }
        }
        class Dn {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new Dn({ name: t, available: false }) : null;
          }
        }
        class on {
          constructor(t, n, u) {
            this.from = t, this.to = n, this.transition = u;
          }
          static interpolate(t, n, u) {
            return new on(t, n, u);
          }
          static parse(t) {
            return t instanceof on ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new on(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new on(t.from, t.to, t.transition) : typeof t == "string" ? new on(t, t, 1) : void 0;
          }
        }
        function ii(o, t, n, u) {
          return typeof o == "number" && o >= 0 && o <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[o, t, n, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [o, t, n, u] : [o, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Sa(o) {
          if (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number" || o instanceof on || o instanceof br || o instanceof Ca || o instanceof mn || o instanceof Ni || o instanceof gn || o instanceof Mi || o instanceof vn || o instanceof Dn) return true;
          if (Array.isArray(o)) {
            for (const t of o) if (!Sa(t)) return false;
            return true;
          }
          if (typeof o == "object") {
            for (const t in o) if (!Sa(o[t])) return false;
            return true;
          }
          return false;
        }
        function sr(o) {
          if (o === null) return Cr;
          if (typeof o == "string") return ar;
          if (typeof o == "boolean") return cr;
          if (typeof o == "number") return st;
          if (o instanceof br) return ei;
          if (o instanceof on) return pn;
          if (o instanceof Ca) return Jo;
          if (o instanceof mn) return qn;
          if (o instanceof Ni) return Qo;
          if (o instanceof gn) return _o;
          if (o instanceof Mi) return kn;
          if (o instanceof vn) return to;
          if (o instanceof Dn) return Xr;
          if (Array.isArray(o)) {
            const t = o.length;
            let n;
            for (const u of o) {
              const h = sr(u);
              if (n) {
                if (n === h) continue;
                n = hr;
                break;
              }
              n = h;
            }
            return nn(n || hr, t);
          }
          return rn;
        }
        function vr(o) {
          const t = typeof o;
          return o === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(o) : o instanceof br || o instanceof on || o instanceof mn || o instanceof Ni || o instanceof gn || o instanceof Mi || o instanceof vn || o instanceof Dn ? o.toString() : JSON.stringify(o);
        }
        class zo {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!Sa(t[1])) return n.error("invalid value");
            const u = t[1];
            let h = sr(u);
            const v = n.expectedType;
            return h.kind !== "array" || h.N !== 0 || !v || v.kind !== "array" || typeof v.N == "number" && v.N !== 0 || (h = v), new zo(h, u);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Er = { string: ar, number: st, boolean: cr, object: rn };
        class zn {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u, h = 1;
            const v = t[0];
            if (v === "array") {
              let w, S;
              if (t.length > 2) {
                const I = t[1];
                if (typeof I != "string" || !(I in Er) || I === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                w = Er[I], h++;
              } else w = hr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                S = t[2], h++;
              }
              u = nn(w, S);
            } else {
              if (!Er[v]) throw new Error(`Types doesn't contain name = ${v}`);
              u = Er[v];
            }
            const b = [];
            for (; h < t.length; h++) {
              const w = n.parse(t[h], h, hr);
              if (!w) return null;
              b.push(w);
            }
            return new zn(u, b);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const u = this.args[n].evaluate(t);
              if (!xa(this.type, sr(u))) return u;
              if (n === this.args.length - 1) throw new Jr(`Expected value to be of type ${qr(this.type)}, but found ${qr(sr(u))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Co = { "to-boolean": cr, "to-color": ei, "to-number": st, "to-string": ar };
        class So {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[0];
            if (!Co[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
            if ((u === "to-boolean" || u === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const h = Co[u], v = [];
            for (let b = 1; b < t.length; b++) {
              const w = n.parse(t[b], b, hr);
              if (!w) return null;
              v.push(w);
            }
            return new So(h, v);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, u;
                for (const h of this.args) {
                  if (n = h.evaluate(t), u = null, n instanceof br) return n;
                  if (typeof n == "string") {
                    const v = t.parseColor(n);
                    if (v) return v;
                  } else if (Array.isArray(n) && (u = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : ii(n[0], n[1], n[2], n[3]), !u)) return new br(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new Jr(u || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Ni.parse(n);
                  if (h) return h;
                }
                throw new Jr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "numberArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = gn.parse(n);
                  if (h) return h;
                }
                throw new Jr(`Could not parse numberArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "colorArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Mi.parse(n);
                  if (h) return h;
                }
                throw new Jr(`Could not parse colorArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = vn.parse(n);
                  if (h) return h;
                }
                throw new Jr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const u of this.args) {
                  if (n = u.evaluate(t), n === null) return 0;
                  const h = Number(n);
                  if (!isNaN(h)) return h;
                }
                throw new Jr(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return mn.fromString(vr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Dn.fromString(vr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return vr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Ul = ["Unknown", "Point", "LineString", "Polygon"];
        class vc {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Ul[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = br.parse(t), this._parseColorCache.set(t, n)), n;
          }
        }
        class is {
          constructor(t, n, u = [], h, v = new Rr(), b = []) {
            this.registry = t, this.path = u, this.key = u.map(((w) => `[${w}]`)).join(""), this.scope = v, this.errors = b, this.expectedType = h, this._isConstant = n;
          }
          parse(t, n, u, h, v = {}) {
            return n ? this.concat(n, u, h)._parse(t, v) : this._parse(t, v);
          }
          _parse(t, n) {
            function u(h, v, b) {
              return b === "assert" ? new zn(v, [h]) : b === "coerce" ? new So(v, [h]) : h;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const h = t[0];
              if (typeof h != "string") return this.error(`Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const v = this.registry[h];
              if (v) {
                let b = v.parse(t, this);
                if (!b) return null;
                if (this.expectedType) {
                  const w = this.expectedType, S = b.type;
                  if (w.kind !== "string" && w.kind !== "number" && w.kind !== "boolean" && w.kind !== "object" && w.kind !== "array" || S.kind !== "value") {
                    if (w.kind === "projectionDefinition" && ["string", "array"].includes(S.kind) || ["color", "formatted", "resolvedImage"].includes(w.kind) && ["value", "string"].includes(S.kind) || ["padding", "numberArray"].includes(w.kind) && ["value", "number", "array"].includes(S.kind) || w.kind === "colorArray" && ["value", "string", "array"].includes(S.kind) || w.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(S.kind)) b = u(b, w, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(w, S)) return null;
                  } else b = u(b, w, n.typeAnnotation || "assert");
                }
                if (!(b instanceof zo) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                  const w = new vc();
                  try {
                    b = new zo(b.type, b.evaluate(w));
                  } catch (S) {
                    return this.error(S.message), null;
                  }
                }
                return b;
              }
              return this.error(`Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, u) {
            const h = typeof t == "number" ? this.path.concat(t) : this.path, v = u ? this.scope.concat(u) : this.scope;
            return new is(this.registry, this._isConstant, h, n || null, v, this.errors);
          }
          error(t, ...n) {
            const u = `${this.key}${n.map(((h) => `[${h}]`)).join("")}`;
            this.errors.push(new Zt(u, t));
          }
          checkSubtype(t, n) {
            const u = xa(t, n);
            return u && this.error(u), u;
          }
        }
        class Bs {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const u = [];
            for (let v = 1; v < t.length - 1; v += 2) {
              const b = t[v];
              if (typeof b != "string") return n.error(`Expected string, but found ${typeof b} instead.`, v);
              if (/[^a-zA-Z0-9_]/.test(b)) return n.error("Variable names must contain only alphanumeric characters or '_'.", v);
              const w = n.parse(t[v + 1], v + 1);
              if (!w) return null;
              u.push([b, w]);
            }
            const h = n.parse(t[t.length - 1], t.length - 1, n.expectedType, u);
            return h ? new Bs(u, h) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class ql {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const u = t[1];
            return n.scope.has(u) ? new ql(u, n.scope.get(u)) : n.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Gl {
          constructor(t, n, u) {
            this.type = t, this.index = n, this.input = u;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, st), h = n.parse(t[2], 2, nn(n.expectedType || hr));
            return u && h ? new Gl(h.type.itemType, u, h) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), u = this.input.evaluate(t);
            if (n < 0) throw new Jr(`Array index out of bounds: ${n} < 0.`);
            if (n >= u.length) throw new Jr(`Array index out of bounds: ${n} > ${u.length - 1}.`);
            if (n !== Math.floor(n)) throw new Jr(`Array index must be an integer, but found ${n} instead.`);
            return u[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Wl {
          constructor(t, n) {
            this.type = cr, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, hr);
            return u && h ? Es(u.type, [cr, ar, st, Cr, hr]) ? new Wl(u, h) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${qr(u.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!u) return false;
            if (!bo(n, ["boolean", "string", "number", "null"])) throw new Jr(`Expected first argument to be of type boolean, string, number or null, but found ${qr(sr(n))} instead.`);
            if (!bo(u, ["string", "array"])) throw new Jr(`Expected second argument to be of type array or string, but found ${qr(sr(u))} instead.`);
            return u.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class io {
          constructor(t, n, u) {
            this.type = st, this.needle = t, this.haystack = n, this.fromIndex = u;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, hr);
            if (!u || !h) return null;
            if (!Es(u.type, [cr, ar, st, Cr, hr])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${qr(u.type)} instead`);
            if (t.length === 4) {
              const v = n.parse(t[3], 3, st);
              return v ? new io(u, h, v) : null;
            }
            return new io(u, h);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!bo(n, ["boolean", "string", "number", "null"])) throw new Jr(`Expected first argument to be of type boolean, string, number or null, but found ${qr(sr(n))} instead.`);
            let h;
            if (this.fromIndex && (h = this.fromIndex.evaluate(t)), bo(u, ["string"])) {
              const v = u.indexOf(n, h);
              return v === -1 ? -1 : [...u.slice(0, v)].length;
            }
            if (bo(u, ["array"])) return u.indexOf(n, h);
            throw new Jr(`Expected second argument to be of type array or string, but found ${qr(sr(u))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Vi {
          constructor(t, n, u, h, v, b) {
            this.inputType = t, this.type = n, this.input = u, this.cases = h, this.outputs = v, this.otherwise = b;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let u, h;
            n.expectedType && n.expectedType.kind !== "value" && (h = n.expectedType);
            const v = {}, b = [];
            for (let I = 2; I < t.length - 1; I += 2) {
              let E = t[I];
              const L = t[I + 1];
              Array.isArray(E) || (E = [E]);
              const N = n.concat(I);
              if (E.length === 0) return N.error("Expected at least one branch label.");
              for (const G of E) {
                if (typeof G != "number" && typeof G != "string") return N.error("Branch labels must be numbers or strings.");
                if (typeof G == "number" && Math.abs(G) > Number.MAX_SAFE_INTEGER) return N.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof G == "number" && Math.floor(G) !== G) return N.error("Numeric branch labels must be integer values.");
                if (u) {
                  if (N.checkSubtype(u, sr(G))) return null;
                } else u = sr(G);
                if (v[String(G)] !== void 0) return N.error("Branch labels must be unique.");
                v[String(G)] = b.length;
              }
              const q = n.parse(L, I, h);
              if (!q) return null;
              h = h || q.type, b.push(q);
            }
            const w = n.parse(t[1], 1, hr);
            if (!w) return null;
            const S = n.parse(t[t.length - 1], t.length - 1, h);
            return S ? w.type.kind !== "value" && n.concat(1).checkSubtype(u, w.type) ? null : new Vi(u, h, w, v, b, S) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (sr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class ns {
          constructor(t, n, u) {
            this.type = t, this.branches = n, this.otherwise = u;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const h = [];
            for (let b = 1; b < t.length - 1; b += 2) {
              const w = n.parse(t[b], b, cr);
              if (!w) return null;
              const S = n.parse(t[b + 1], b + 1, u);
              if (!S) return null;
              h.push([w, S]), u = u || S.type;
            }
            const v = n.parse(t[t.length - 1], t.length - 1, u);
            if (!v) return null;
            if (!u) throw new Error("Can't infer output type");
            return new ns(u, h, v);
          }
          evaluate(t) {
            for (const [n, u] of this.branches) if (n.evaluate(t)) return u.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, u] of this.branches) t(n), t(u);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Os {
          constructor(t, n, u, h) {
            this.type = t, this.input = n, this.beginIndex = u, this.endIndex = h;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, st);
            if (!u || !h) return null;
            if (!Es(u.type, [nn(hr), ar, hr])) return n.error(`Expected first argument to be of type array or string, but found ${qr(u.type)} instead`);
            if (t.length === 4) {
              const v = n.parse(t[3], 3, st);
              return v ? new Os(u.type, u, h, v) : null;
            }
            return new Os(u.type, u, h);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = this.beginIndex.evaluate(t);
            let h;
            if (this.endIndex && (h = this.endIndex.evaluate(t)), bo(n, ["string"])) return [...n].slice(u, h).join("");
            if (bo(n, ["array"])) return n.slice(u, h);
            throw new Jr(`Expected first argument to be of type array or string, but found ${qr(sr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function ka(o, t) {
          const n = o.length - 1;
          let u, h, v = 0, b = n, w = 0;
          for (; v <= b; ) if (w = Math.floor((v + b) / 2), u = o[w], h = o[w + 1], u <= t) {
            if (w === n || t < h) return w;
            v = w + 1;
          } else {
            if (!(u > t)) throw new Jr("Input is not a number.");
            b = w - 1;
          }
          return 0;
        }
        class Si {
          constructor(t, n, u) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [h, v] of u) this.labels.push(h), this.outputs.push(v);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const u = n.parse(t[1], 1, st);
            if (!u) return null;
            const h = [];
            let v = null;
            n.expectedType && n.expectedType.kind !== "value" && (v = n.expectedType);
            for (let b = 1; b < t.length; b += 2) {
              const w = b === 1 ? -1 / 0 : t[b], S = t[b + 1], I = b, E = b + 1;
              if (typeof w != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (h.length && h[h.length - 1][0] >= w) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', I);
              const L = n.parse(S, E, v);
              if (!L) return null;
              v = v || L.type, h.push([w, L]);
            }
            return new Si(v, u, h);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const v = n.length;
            return h >= n[v - 1] ? u[v - 1].evaluate(t) : u[ka(n, h)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function uh(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var $s, yc, bp = (function() {
          if (yc) return $s;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return yc = 1, $s = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var v = this.sampleCurveX(u) - t;
              if (Math.abs(v) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= v / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (v = this.sampleCurveX(u), !(Math.abs(v - t) < n)); h++) t > v ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, $s;
        })(), os = uh(bp);
        class Xi {
          constructor(t, n, u, h, v) {
            this.type = t, this.operator = n, this.interpolation = u, this.input = h, this.labels = [], this.outputs = [];
            for (const [b, w] of v) this.labels.push(b), this.outputs.push(w);
          }
          static interpolationFactor(t, n, u, h) {
            let v = 0;
            if (t.name === "exponential") v = js(n, t.base, u, h);
            else if (t.name === "linear") v = js(n, 1, u, h);
            else if (t.name === "cubic-bezier") {
              const b = t.controlPoints;
              v = new os(b[0], b[1], b[2], b[3]).solve(js(n, 1, u, h));
            }
            return v;
          }
          static parse(t, n) {
            let [u, h, v, ...b] = t;
            if (!Array.isArray(h) || h.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (h[0] === "linear") h = { name: "linear" };
            else if (h[0] === "exponential") {
              const I = h[1];
              if (typeof I != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              h = { name: "exponential", base: I };
            } else {
              if (h[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
              {
                const I = h.slice(1);
                if (I.length !== 4 || I.some(((E) => typeof E != "number" || E < 0 || E > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                h = { name: "cubic-bezier", controlPoints: I };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (v = n.parse(v, 2, st), !v) return null;
            const w = [];
            let S = null;
            u !== "interpolate-hcl" && u !== "interpolate-lab" || n.expectedType == kn ? n.expectedType && n.expectedType.kind !== "value" && (S = n.expectedType) : S = ei;
            for (let I = 0; I < b.length; I += 2) {
              const E = b[I], L = b[I + 1], N = I + 3, q = I + 4;
              if (typeof E != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (w.length && w[w.length - 1][0] >= E) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', N);
              const G = n.parse(L, q, S);
              if (!G) return null;
              S = S || G.type, w.push([E, G]);
            }
            return xo(S, st) || xo(S, pn) || xo(S, ei) || xo(S, Qo) || xo(S, _o) || xo(S, kn) || xo(S, to) || xo(S, nn(st)) ? new Xi(S, u, h, v, w) : n.error(`Type ${qr(S)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const v = n.length;
            if (h >= n[v - 1]) return u[v - 1].evaluate(t);
            const b = ka(n, h), w = Xi.interpolationFactor(this.interpolation, h, n[b], n[b + 1]), S = u[b].evaluate(t), I = u[b + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return ro(S, I, w);
                  case "color":
                    return br.interpolate(S, I, w);
                  case "padding":
                    return Ni.interpolate(S, I, w);
                  case "colorArray":
                    return Mi.interpolate(S, I, w);
                  case "numberArray":
                    return gn.interpolate(S, I, w);
                  case "variableAnchorOffsetCollection":
                    return vn.interpolate(S, I, w);
                  case "array":
                    return Do(S, I, w);
                  case "projectionDefinition":
                    return on.interpolate(S, I, w);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(S, I, w, "hcl");
                  case "colorArray":
                    return Mi.interpolate(S, I, w, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(S, I, w, "lab");
                  case "colorArray":
                    return Mi.interpolate(S, I, w, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function js(o, t, n, u) {
          const h = u - n, v = o - n;
          return h === 0 ? 0 : t === 1 ? v / h : (Math.pow(t, v) - 1) / (Math.pow(t, h) - 1);
        }
        const ko = { color: br.interpolate, number: ro, padding: Ni.interpolate, numberArray: gn.interpolate, colorArray: Mi.interpolate, variableAnchorOffsetCollection: vn.interpolate, array: Do };
        class Ns {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u = null;
            const h = n.expectedType;
            h && h.kind !== "value" && (u = h);
            const v = [];
            for (const w of t.slice(1)) {
              const S = n.parse(w, 1 + v.length, u, void 0, { typeAnnotation: "omit" });
              if (!S) return null;
              u = u || S.type, v.push(S);
            }
            if (!u) throw new Error("No output type");
            const b = h && v.some(((w) => xa(h, w.type)));
            return new Ns(b ? hr : u, v);
          }
          evaluate(t) {
            let n, u = null, h = 0;
            for (const v of this.args) if (h++, u = v.evaluate(t), u && u instanceof Dn && !u.available && (n || (n = u.name), u = null, h === this.args.length && (u = n)), u !== null) break;
            return u;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function Vs(o, t) {
          return o === "==" || o === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function Us(o, t, n, u) {
          return u.compare(t, n) === 0;
        }
        function an(o, t, n) {
          const u = o !== "==" && o !== "!=";
          return class n1 {
            constructor(v, b, w) {
              this.type = cr, this.lhs = v, this.rhs = b, this.collator = w, this.hasUntypedArgument = v.type.kind === "value" || b.type.kind === "value";
            }
            static parse(v, b) {
              if (v.length !== 3 && v.length !== 4) return b.error("Expected two or three arguments.");
              const w = v[0];
              let S = b.parse(v[1], 1, hr);
              if (!S) return null;
              if (!Vs(w, S.type)) return b.concat(1).error(`"${w}" comparisons are not supported for type '${qr(S.type)}'.`);
              let I = b.parse(v[2], 2, hr);
              if (!I) return null;
              if (!Vs(w, I.type)) return b.concat(2).error(`"${w}" comparisons are not supported for type '${qr(I.type)}'.`);
              if (S.type.kind !== I.type.kind && S.type.kind !== "value" && I.type.kind !== "value") return b.error(`Cannot compare types '${qr(S.type)}' and '${qr(I.type)}'.`);
              u && (S.type.kind === "value" && I.type.kind !== "value" ? S = new zn(I.type, [S]) : S.type.kind !== "value" && I.type.kind === "value" && (I = new zn(S.type, [I])));
              let E = null;
              if (v.length === 4) {
                if (S.type.kind !== "string" && I.type.kind !== "string" && S.type.kind !== "value" && I.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
                if (E = b.parse(v[3], 3, Jo), !E) return null;
              }
              return new n1(S, I, E);
            }
            evaluate(v) {
              const b = this.lhs.evaluate(v), w = this.rhs.evaluate(v);
              if (u && this.hasUntypedArgument) {
                const S = sr(b), I = sr(w);
                if (S.kind !== I.kind || S.kind !== "string" && S.kind !== "number") throw new Jr(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${S.kind}, ${I.kind}) instead.`);
              }
              if (this.collator && !u && this.hasUntypedArgument) {
                const S = sr(b), I = sr(w);
                if (S.kind !== "string" || I.kind !== "string") return t(v, b, w);
              }
              return this.collator ? n(v, b, w, this.collator.evaluate(v)) : t(v, b, w);
            }
            eachChild(v) {
              v(this.lhs), v(this.rhs), this.collator && v(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const ch = an("==", (function(o, t, n) {
          return t === n;
        }), Us), Zl = an("!=", (function(o, t, n) {
          return t !== n;
        }), (function(o, t, n, u) {
          return !Us(0, t, n, u);
        })), xp = an("<", (function(o, t, n) {
          return t < n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) < 0;
        })), _c = an(">", (function(o, t, n) {
          return t > n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) > 0;
        })), wp = an("<=", (function(o, t, n) {
          return t <= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) <= 0;
        })), Cp = an(">=", (function(o, t, n) {
          return t >= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) >= 0;
        }));
        class Hl {
          constructor(t, n, u) {
            this.type = Jo, this.locale = u, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const u = t[1];
            if (typeof u != "object" || Array.isArray(u)) return n.error("Collator options argument must be an object.");
            const h = n.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, cr);
            if (!h) return null;
            const v = n.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, cr);
            if (!v) return null;
            let b = null;
            return u.locale && (b = n.parse(u.locale, 1, ar), !b) ? null : new Hl(h, v, b);
          }
          evaluate(t) {
            return new Ca(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class bc {
          constructor(t, n, u, h, v) {
            this.type = ar, this.number = t, this.locale = n, this.currency = u, this.minFractionDigits = h, this.maxFractionDigits = v;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, st);
            if (!u) return null;
            const h = t[2];
            if (typeof h != "object" || Array.isArray(h)) return n.error("NumberFormat options argument must be an object.");
            let v = null;
            if (h.locale && (v = n.parse(h.locale, 1, ar), !v)) return null;
            let b = null;
            if (h.currency && (b = n.parse(h.currency, 1, ar), !b)) return null;
            let w = null;
            if (h["min-fraction-digits"] && (w = n.parse(h["min-fraction-digits"], 1, st), !w)) return null;
            let S = null;
            return h["max-fraction-digits"] && (S = n.parse(h["max-fraction-digits"], 1, st), !S) ? null : new bc(u, v, b, w, S);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Pa {
          constructor(t) {
            this.type = qn, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[1];
            if (!Array.isArray(u) && typeof u == "object") return n.error("First argument must be an image or text section.");
            const h = [];
            let v = false;
            for (let b = 1; b <= t.length - 1; ++b) {
              const w = t[b];
              if (v && typeof w == "object" && !Array.isArray(w)) {
                v = false;
                let S = null;
                if (w["font-scale"] && (S = n.parse(w["font-scale"], 1, st), !S)) return null;
                let I = null;
                if (w["text-font"] && (I = n.parse(w["text-font"], 1, nn(ar)), !I)) return null;
                let E = null;
                if (w["text-color"] && (E = n.parse(w["text-color"], 1, ei), !E)) return null;
                let L = null;
                if (w["vertical-align"]) {
                  if (typeof w["vertical-align"] == "string" && !Nl.includes(w["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${w["vertical-align"]}' instead.`);
                  if (L = n.parse(w["vertical-align"], 1, ar), !L) return null;
                }
                const N = h[h.length - 1];
                N.scale = S, N.font = I, N.textColor = E, N.verticalAlign = L;
              } else {
                const S = n.parse(t[b], 1, hr);
                if (!S) return null;
                const I = S.type.kind;
                if (I !== "string" && I !== "value" && I !== "null" && I !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                v = true, h.push({ content: S, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Pa(h);
          }
          evaluate(t) {
            return new mn(this.sections.map(((n) => {
              const u = n.content.evaluate(t);
              return sr(u) === Xr ? new Vl("", u, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Vl(vr(u), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class xc {
          constructor(t) {
            this.type = Xr, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, ar);
            return u ? new xc(u) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = Dn.fromString(n);
            return u && t.availableImages && (u.available = t.availableImages.indexOf(n) > -1), u;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Xl {
          constructor(t) {
            this.type = st, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1);
            return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${qr(u.type)} instead.`) : new Xl(u) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new Jr(`Expected value to be of type string or array, but found ${qr(sr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const no = 8192;
        function Sp(o, t) {
          const n = (180 + o[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o[1] * Math.PI / 360))) / 360, h = Math.pow(2, t.z);
          return [Math.round(n * h * no), Math.round(u * h * no)];
        }
        function Yl(o, t) {
          const n = Math.pow(2, t.z);
          return [(h = (o[0] / no + t.x) / n, 360 * h - 180), (u = (o[1] / no + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
          var u, h;
        }
        function qs(o, t) {
          o[0] = Math.min(o[0], t[0]), o[1] = Math.min(o[1], t[1]), o[2] = Math.max(o[2], t[0]), o[3] = Math.max(o[3], t[1]);
        }
        function Gs(o, t) {
          return !(o[0] <= t[0] || o[2] >= t[2] || o[1] <= t[1] || o[3] >= t[3]);
        }
        function kp(o, t, n) {
          const u = o[0] - t[0], h = o[1] - t[1], v = o[0] - n[0], b = o[1] - n[1];
          return u * b - v * h == 0 && u * v <= 0 && h * b <= 0;
        }
        function Kl(o, t, n, u) {
          return (h = [u[0] - n[0], u[1] - n[1]])[0] * (v = [t[0] - o[0], t[1] - o[1]])[1] - h[1] * v[0] != 0 && !(!hh(o, t, n, u) || !hh(n, u, o, t));
          var h, v;
        }
        function Pp(o, t, n) {
          for (const u of n) for (let h = 0; h < u.length - 1; ++h) if (Kl(o, t, u[h], u[h + 1])) return true;
          return false;
        }
        function Ta(o, t, n = false) {
          let u = false;
          for (const w of t) for (let S = 0; S < w.length - 1; S++) {
            if (kp(o, w[S], w[S + 1])) return n;
            (v = w[S])[1] > (h = o)[1] != (b = w[S + 1])[1] > h[1] && h[0] < (b[0] - v[0]) * (h[1] - v[1]) / (b[1] - v[1]) + v[0] && (u = !u);
          }
          var h, v, b;
          return u;
        }
        function dh(o, t) {
          for (const n of t) if (Ta(o, n)) return true;
          return false;
        }
        function wc(o, t) {
          for (const n of o) if (!Ta(n, t)) return false;
          for (let n = 0; n < o.length - 1; ++n) if (Pp(o[n], o[n + 1], t)) return false;
          return true;
        }
        function Tp(o, t) {
          for (const n of t) if (wc(o, n)) return true;
          return false;
        }
        function hh(o, t, n, u) {
          const h = u[0] - n[0], v = u[1] - n[1], b = (o[0] - n[0]) * v - h * (o[1] - n[1]), w = (t[0] - n[0]) * v - h * (t[1] - n[1]);
          return b > 0 && w < 0 || b < 0 && w > 0;
        }
        function Cc(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const v = [];
            for (let b = 0; b < o[h].length; b++) {
              const w = Sp(o[h][b], n);
              qs(t, w), v.push(w);
            }
            u.push(v);
          }
          return u;
        }
        function fh(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const v = Cc(o[h], t, n);
            u.push(v);
          }
          return u;
        }
        function Jl(o, t, n, u) {
          if (o[0] < n[0] || o[0] > n[2]) {
            const h = 0.5 * u;
            let v = o[0] - n[0] > h ? -u : n[0] - o[0] > h ? u : 0;
            v === 0 && (v = o[0] - n[2] > h ? -u : n[2] - o[0] > h ? u : 0), o[0] += v;
          }
          qs(t, o);
        }
        function ph(o, t, n, u) {
          const h = Math.pow(2, u.z) * no, v = [u.x * no, u.y * no], b = [];
          for (const w of o) for (const S of w) {
            const I = [S.x + v[0], S.y + v[1]];
            Jl(I, t, n, h), b.push(I);
          }
          return b;
        }
        function mh(o, t, n, u) {
          const h = Math.pow(2, u.z) * no, v = [u.x * no, u.y * no], b = [];
          for (const S of o) {
            const I = [];
            for (const E of S) {
              const L = [E.x + v[0], E.y + v[1]];
              qs(t, L), I.push(L);
            }
            b.push(I);
          }
          if (t[2] - t[0] <= h / 2) {
            (w = t)[0] = w[1] = 1 / 0, w[2] = w[3] = -1 / 0;
            for (const S of b) for (const I of S) Jl(I, t, n, h);
          }
          var w;
          return b;
        }
        class Ia {
          constructor(t, n) {
            this.type = cr, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Sa(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") {
                const h = [];
                for (const v of u.features) {
                  const { type: b, coordinates: w } = v.geometry;
                  b === "Polygon" && h.push(w), b === "MultiPolygon" && h.push(...w);
                }
                if (h.length) return new Ia(u, { type: "MultiPolygon", coordinates: h });
              } else if (u.type === "Feature") {
                const h = u.geometry.type;
                if (h === "Polygon" || h === "MultiPolygon") return new Ia(u, u.geometry);
              } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new Ia(u, u);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = Cc(u.coordinates, v, b), S = ph(n.geometry(), h, v, b);
                  if (!Gs(h, v)) return false;
                  for (const I of S) if (!Ta(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = fh(u.coordinates, v, b), S = ph(n.geometry(), h, v, b);
                  if (!Gs(h, v)) return false;
                  for (const I of S) if (!dh(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = Cc(u.coordinates, v, b), S = mh(n.geometry(), h, v, b);
                  if (!Gs(h, v)) return false;
                  for (const I of S) if (!wc(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = fh(u.coordinates, v, b), S = mh(n.geometry(), h, v, b);
                  if (!Gs(h, v)) return false;
                  for (const I of S) if (!Tp(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let Sc = class {
          constructor(o = [], t = (n, u) => n < u ? -1 : n > u ? 1 : 0) {
            if (this.data = o, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(o) {
            this.data.push(o), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const o = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), o;
          }
          peek() {
            return this.data[0];
          }
          _up(o) {
            const { data: t, compare: n } = this, u = t[o];
            for (; o > 0; ) {
              const h = o - 1 >> 1, v = t[h];
              if (n(u, v) >= 0) break;
              t[o] = v, o = h;
            }
            t[o] = u;
          }
          _down(o) {
            const { data: t, compare: n } = this, u = this.length >> 1, h = t[o];
            for (; o < u; ) {
              let v = 1 + (o << 1);
              const b = v + 1;
              if (b < this.length && n(t[b], t[v]) < 0 && (v = b), n(t[v], h) >= 0) break;
              t[o] = t[v], o = v;
            }
            t[o] = h;
          }
        };
        function kc(o, t, n = 0, u = o.length - 1, h = Ip) {
          for (; u > n; ) {
            if (u - n > 600) {
              const S = u - n + 1, I = t - n + 1, E = Math.log(S), L = 0.5 * Math.exp(2 * E / 3), N = 0.5 * Math.sqrt(E * L * (S - L) / S) * (I - S / 2 < 0 ? -1 : 1);
              kc(o, t, Math.max(n, Math.floor(t - I * L / S + N)), Math.min(u, Math.floor(t + (S - I) * L / S + N)), h);
            }
            const v = o[t];
            let b = n, w = u;
            for (Ws(o, n, t), h(o[u], v) > 0 && Ws(o, n, u); b < w; ) {
              for (Ws(o, b, w), b++, w--; h(o[b], v) < 0; ) b++;
              for (; h(o[w], v) > 0; ) w--;
            }
            h(o[n], v) === 0 ? Ws(o, n, w) : (w++, Ws(o, w, u)), w <= t && (n = w + 1), t <= w && (u = w - 1);
          }
        }
        function Ws(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Ip(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function Zs(o, t) {
          if (o.length <= 1) return [o];
          const n = [];
          let u, h;
          for (const v of o) {
            const b = Mp(v);
            b !== 0 && (v.area = Math.abs(b), h === void 0 && (h = b < 0), h === b < 0 ? (u && n.push(u), u = [v]) : u.push(v));
          }
          if (u && n.push(u), t > 1) for (let v = 0; v < n.length; v++) n[v].length <= t || (kc(n[v], t, 1, n[v].length - 1, gh), n[v] = n[v].slice(0, t));
          return n;
        }
        function gh(o, t) {
          return t.area - o.area;
        }
        function Mp(o) {
          let t = 0;
          for (let n, u, h = 0, v = o.length, b = v - 1; h < v; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        const vh = 1 / 298.257223563, yh = vh * (2 - vh), Pc = Math.PI / 180;
        class Tc {
          constructor(t) {
            const n = 6378.137 * Pc * 1e3, u = Math.cos(t * Pc), h = 1 / (1 - yh * (1 - u * u)), v = Math.sqrt(h);
            this.kx = n * v * u, this.ky = n * v * h * (1 - yh);
          }
          distance(t, n) {
            const u = this.wrap(t[0] - n[0]) * this.kx, h = (t[1] - n[1]) * this.ky;
            return Math.sqrt(u * u + h * h);
          }
          pointOnLine(t, n) {
            let u, h, v, b, w = 1 / 0;
            for (let S = 0; S < t.length - 1; S++) {
              let I = t[S][0], E = t[S][1], L = this.wrap(t[S + 1][0] - I) * this.kx, N = (t[S + 1][1] - E) * this.ky, q = 0;
              L === 0 && N === 0 || (q = (this.wrap(n[0] - I) * this.kx * L + (n[1] - E) * this.ky * N) / (L * L + N * N), q > 1 ? (I = t[S + 1][0], E = t[S + 1][1]) : q > 0 && (I += L / this.kx * q, E += N / this.ky * q)), L = this.wrap(n[0] - I) * this.kx, N = (n[1] - E) * this.ky;
              const G = L * L + N * N;
              G < w && (w = G, u = I, h = E, v = S, b = q);
            }
            return { point: [u, h], index: v, t: Math.max(0, Math.min(1, b)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function _h(o, t) {
          return t[0] - o[0];
        }
        function Ql(o) {
          return o[1] - o[0] + 1;
        }
        function Fo(o, t) {
          return o[1] >= o[0] && o[1] < t;
        }
        function zr(o, t) {
          if (o[0] > o[1]) return [null, null];
          const n = Ql(o);
          if (t) {
            if (n === 2) return [o, null];
            const h = Math.floor(n / 2);
            return [[o[0], o[0] + h], [o[0] + h, o[1]]];
          }
          if (n === 1) return [o, null];
          const u = Math.floor(n / 2) - 1;
          return [[o[0], o[0] + u], [o[0] + u + 1, o[1]]];
        }
        function Ic(o, t) {
          if (!Fo(t, o.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let u = t[0]; u <= t[1]; ++u) qs(n, o[u]);
          return n;
        }
        function Mc(o) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of o) for (const u of n) qs(t, u);
          return t;
        }
        function bh(o) {
          return o[0] !== -1 / 0 && o[1] !== -1 / 0 && o[2] !== 1 / 0 && o[3] !== 1 / 0;
        }
        function Ec(o, t, n) {
          if (!bh(o) || !bh(t)) return NaN;
          let u = 0, h = 0;
          return o[2] < t[0] && (u = t[0] - o[2]), o[0] > t[2] && (u = o[0] - t[2]), o[1] > t[3] && (h = o[1] - t[3]), o[3] < t[1] && (h = t[1] - o[3]), n.distance([0, 0], [u, h]);
        }
        function Ma(o, t, n) {
          const u = n.pointOnLine(t, o);
          return n.distance(o, u.point);
        }
        function Rc(o, t, n, u, h) {
          const v = Math.min(Ma(o, [n, u], h), Ma(t, [n, u], h)), b = Math.min(Ma(n, [o, t], h), Ma(u, [o, t], h));
          return Math.min(v, b);
        }
        function Ep(o, t, n, u, h) {
          if (!Fo(t, o.length) || !Fo(u, n.length)) return 1 / 0;
          let v = 1 / 0;
          for (let b = t[0]; b < t[1]; ++b) {
            const w = o[b], S = o[b + 1];
            for (let I = u[0]; I < u[1]; ++I) {
              const E = n[I], L = n[I + 1];
              if (Kl(w, S, E, L)) return 0;
              v = Math.min(v, Rc(w, S, E, L, h));
            }
          }
          return v;
        }
        function Rp(o, t, n, u, h) {
          if (!Fo(t, o.length) || !Fo(u, n.length)) return NaN;
          let v = 1 / 0;
          for (let b = t[0]; b <= t[1]; ++b) for (let w = u[0]; w <= u[1]; ++w) if (v = Math.min(v, h.distance(o[b], n[w])), v === 0) return v;
          return v;
        }
        function Ap(o, t, n) {
          if (Ta(o, t, true)) return 0;
          let u = 1 / 0;
          for (const h of t) {
            const v = h[0], b = h[h.length - 1];
            if (v !== b && (u = Math.min(u, Ma(o, [b, v], n)), u === 0)) return u;
            const w = n.pointOnLine(h, o);
            if (u = Math.min(u, n.distance(o, w.point)), u === 0) return u;
          }
          return u;
        }
        function Dp(o, t, n, u) {
          if (!Fo(t, o.length)) return NaN;
          for (let v = t[0]; v <= t[1]; ++v) if (Ta(o[v], n, true)) return 0;
          let h = 1 / 0;
          for (let v = t[0]; v < t[1]; ++v) {
            const b = o[v], w = o[v + 1];
            for (const S of n) for (let I = 0, E = S.length, L = E - 1; I < E; L = I++) {
              const N = S[L], q = S[I];
              if (Kl(b, w, N, q)) return 0;
              h = Math.min(h, Rc(b, w, N, q, u));
            }
          }
          return h;
        }
        function xh(o, t) {
          for (const n of o) for (const u of n) if (Ta(u, t, true)) return true;
          return false;
        }
        function zp(o, t, n, u = 1 / 0) {
          const h = Mc(o), v = Mc(t);
          if (u !== 1 / 0 && Ec(h, v, n) >= u) return u;
          if (Gs(h, v)) {
            if (xh(o, t)) return 0;
          } else if (xh(t, o)) return 0;
          let b = 1 / 0;
          for (const w of o) for (let S = 0, I = w.length, E = I - 1; S < I; E = S++) {
            const L = w[E], N = w[S];
            for (const q of t) for (let G = 0, K = q.length, ae = K - 1; G < K; ae = G++) {
              const me = q[ae], Oe = q[G];
              if (Kl(L, N, me, Oe)) return 0;
              b = Math.min(b, Rc(L, N, me, Oe, n));
            }
          }
          return b;
        }
        function wh(o, t, n, u, h, v) {
          if (!v) return;
          const b = Ec(Ic(u, v), h, n);
          b < t && o.push([b, v, [0, 0]]);
        }
        function eu(o, t, n, u, h, v, b) {
          if (!v || !b) return;
          const w = Ec(Ic(u, v), Ic(h, b), n);
          w < t && o.push([w, v, b]);
        }
        function tu(o, t, n, u, h = 1 / 0) {
          let v = Math.min(u.distance(o[0], n[0][0]), h);
          if (v === 0) return v;
          const b = new Sc([[0, [0, o.length - 1], [0, 0]]], _h), w = Mc(n);
          for (; b.length > 0; ) {
            const S = b.pop();
            if (S[0] >= v) continue;
            const I = S[1], E = t ? 50 : 100;
            if (Ql(I) <= E) {
              if (!Fo(I, o.length)) return NaN;
              if (t) {
                const L = Dp(o, I, n, u);
                if (isNaN(L) || L === 0) return L;
                v = Math.min(v, L);
              } else for (let L = I[0]; L <= I[1]; ++L) {
                const N = Ap(o[L], n, u);
                if (v = Math.min(v, N), v === 0) return 0;
              }
            } else {
              const L = zr(I, t);
              wh(b, v, u, o, w, L[0]), wh(b, v, u, o, w, L[1]);
            }
          }
          return v;
        }
        function ru(o, t, n, u, h, v = 1 / 0) {
          let b = Math.min(v, h.distance(o[0], n[0]));
          if (b === 0) return b;
          const w = new Sc([[0, [0, o.length - 1], [0, n.length - 1]]], _h);
          for (; w.length > 0; ) {
            const S = w.pop();
            if (S[0] >= b) continue;
            const I = S[1], E = S[2], L = t ? 50 : 100, N = u ? 50 : 100;
            if (Ql(I) <= L && Ql(E) <= N) {
              if (!Fo(I, o.length) && Fo(E, n.length)) return NaN;
              let q;
              if (t && u) q = Ep(o, I, n, E, h), b = Math.min(b, q);
              else if (t && !u) {
                const G = o.slice(I[0], I[1] + 1);
                for (let K = E[0]; K <= E[1]; ++K) if (q = Ma(n[K], G, h), b = Math.min(b, q), b === 0) return b;
              } else if (!t && u) {
                const G = n.slice(E[0], E[1] + 1);
                for (let K = I[0]; K <= I[1]; ++K) if (q = Ma(o[K], G, h), b = Math.min(b, q), b === 0) return b;
              } else q = Rp(o, I, n, E, h), b = Math.min(b, q);
            } else {
              const q = zr(I, t), G = zr(E, u);
              eu(w, b, h, o, n, q[0], G[0]), eu(w, b, h, o, n, q[0], G[1]), eu(w, b, h, o, n, q[1], G[0]), eu(w, b, h, o, n, q[1], G[1]);
            }
          }
          return b;
        }
        function Ac(o) {
          return o.type === "MultiPolygon" ? o.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : o.type === "MultiLineString" ? o.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : o.type === "MultiPoint" ? o.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [o];
        }
        class Ea {
          constructor(t, n) {
            this.type = st, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Sa(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") return new Ea(u, u.features.map(((h) => Ac(h.geometry))).flat());
              if (u.type === "Feature") return new Ea(u, Ac(u.geometry));
              if ("type" in u && "coordinates" in u) return new Ea(u, Ac(u));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = n.geometry(), v = h.flat().map(((S) => Yl([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new Tc(v[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, ru(v, false, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, ru(v, false, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, tu(v, false, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = n.geometry(), v = h.flat().map(((S) => Yl([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new Tc(v[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, ru(v, true, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, ru(v, true, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, tu(v, true, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, u) {
                const h = n.geometry();
                if (h.length === 0 || h[0].length === 0) return NaN;
                const v = Zs(h, 0).map(((S) => S.map(((I) => I.map(((E) => Yl([E.x, E.y], n.canonical))))))), b = new Tc(v[0][0][0][1]);
                let w = 1 / 0;
                for (const S of u) for (const I of v) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, tu([S.coordinates], false, I, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, tu(S.coordinates, true, I, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, zp(I, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Hs {
          constructor(t) {
            this.type = hr, this.key = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = t[1];
            return u == null ? n.error("Global state property must be defined.") : typeof u != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Hs(u);
          }
          evaluate(t) {
            var n;
            const u = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return u && Object.keys(u).length !== 0 ? ia(u, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const as = { "==": ch, "!=": Zl, ">": _c, "<": xp, ">=": Cp, "<=": wp, array: zn, at: Gl, boolean: zn, case: ns, coalesce: Ns, collator: Hl, format: Pa, image: xc, in: Wl, "index-of": io, interpolate: Xi, "interpolate-hcl": Xi, "interpolate-lab": Xi, length: Xl, let: Bs, literal: zo, match: Vi, number: zn, "number-format": bc, object: zn, slice: Os, step: Si, string: zn, "to-boolean": So, "to-color": So, "to-number": So, "to-string": So, var: ql, within: Ia, distance: Ea, "global-state": Hs };
        class Gn {
          constructor(t, n, u, h) {
            this.name = t, this.type = n, this._evaluate = u, this.args = h;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return false;
          }
          static parse(t, n) {
            const u = t[0], h = Gn.definitions[u];
            if (!h) return n.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const v = Array.isArray(h) ? h[0] : h.type, b = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, w = b.filter((([I]) => !Array.isArray(I) || I.length === t.length - 1));
            let S = null;
            for (const [I, E] of w) {
              S = new is(n.registry, iu, n.path, null, n.scope);
              const L = [];
              let N = false;
              for (let q = 1; q < t.length; q++) {
                const G = t[q], K = Array.isArray(I) ? I[q - 1] : I.type, ae = S.parse(G, 1 + L.length, K);
                if (!ae) {
                  N = true;
                  break;
                }
                L.push(ae);
              }
              if (!N) if (Array.isArray(I) && I.length !== L.length) S.error(`Expected ${I.length} arguments, but found ${L.length} instead.`);
              else {
                for (let q = 0; q < L.length; q++) {
                  const G = Array.isArray(I) ? I[q] : I.type, K = L[q];
                  S.concat(q + 1).checkSubtype(G, K.type);
                }
                if (S.errors.length === 0) return new Gn(u, v, E, L);
              }
            }
            if (w.length === 1) n.errors.push(...S.errors);
            else {
              const I = (w.length ? w : b).map((([L]) => {
                return N = L, Array.isArray(N) ? `(${N.map(qr).join(", ")})` : `(${qr(N.type)}...)`;
                var N;
              })).join(" | "), E = [];
              for (let L = 1; L < t.length; L++) {
                const N = n.parse(t[L], 1 + E.length);
                if (!N) return null;
                E.push(qr(N.type));
              }
              n.error(`Expected arguments of type ${I}, but found (${E.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Gn.definitions = n;
            for (const u in n) t[u] = Gn;
          }
        }
        function Ch(o, [t, n, u, h]) {
          t = t.evaluate(o), n = n.evaluate(o), u = u.evaluate(o);
          const v = h ? h.evaluate(o) : 1, b = ii(t, n, u, v);
          if (b) throw new Jr(b);
          return new br(t / 255, n / 255, u / 255, v, false);
        }
        function Sh(o, t) {
          return o in t;
        }
        function Dc(o, t) {
          const n = t[o];
          return n === void 0 ? null : n;
        }
        function Ra(o) {
          return { type: o };
        }
        function iu(o) {
          if (o instanceof ql) return iu(o.boundExpression);
          if (o instanceof Gn && o.name === "error" || o instanceof Hl || o instanceof Ia || o instanceof Ea || o instanceof Hs) return false;
          const t = o instanceof So || o instanceof zn;
          let n = true;
          return o.eachChild(((u) => {
            n = t ? n && iu(u) : n && u instanceof zo;
          })), !!n && nu(o) && ou(o, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function nu(o) {
          if (o instanceof Gn && (o.name === "get" && o.args.length === 1 || o.name === "feature-state" || o.name === "has" && o.args.length === 1 || o.name === "properties" || o.name === "geometry-type" || o.name === "id" || /^filter-/.test(o.name)) || o instanceof Ia || o instanceof Ea) return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !nu(n) && (t = false);
          })), t;
        }
        function Xs(o) {
          if (o instanceof Gn && o.name === "feature-state") return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !Xs(n) && (t = false);
          })), t;
        }
        function ou(o, t) {
          if (o instanceof Gn && t.indexOf(o.name) >= 0) return false;
          let n = true;
          return o.eachChild(((u) => {
            n && !ou(u, t) && (n = false);
          })), n;
        }
        function kh(o) {
          return { result: "success", value: o };
        }
        function ss(o) {
          return { result: "error", value: o };
        }
        function na(o) {
          return o["property-type"] === "data-driven" || o["property-type"] === "cross-faded-data-driven";
        }
        function Ph(o) {
          return !!o.expression && o.expression.parameters.indexOf("zoom") > -1;
        }
        function zc(o) {
          return !!o.expression && o.expression.interpolated;
        }
        function Sr(o) {
          return o instanceof Number ? "number" : o instanceof String ? "string" : o instanceof Boolean ? "boolean" : Array.isArray(o) ? "array" : o === null ? "null" : typeof o;
        }
        function Ys(o) {
          return typeof o == "object" && o !== null && !Array.isArray(o) && sr(o) === rn;
        }
        function Fp(o) {
          return o;
        }
        function Th(o, t) {
          const n = o.stops && typeof o.stops[0][0] == "object", u = n || !(n || o.property !== void 0), h = o.type || (zc(t) ? "exponential" : "interval"), v = (function(E) {
            switch (E.type) {
              case "color":
                return br.parse;
              case "padding":
                return Ni.parse;
              case "numberArray":
                return gn.parse;
              case "colorArray":
                return Mi.parse;
              default:
                return null;
            }
          })(t);
          if (v && ((o = at({}, o)).stops && (o.stops = o.stops.map(((E) => [E[0], v(E[1])]))), o.default = v(o.default ? o.default : t.default)), o.colorSpace && (b = o.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${o.colorSpace}"`);
          var b;
          const w = (function(E) {
            switch (E) {
              case "exponential":
                return Mh;
              case "interval":
                return Lp;
              case "categorical":
                return Ih;
              case "identity":
                return Bp;
              default:
                throw new Error(`Unknown function type "${E}"`);
            }
          })(h);
          let S, I;
          if (h === "categorical") {
            S = /* @__PURE__ */ Object.create(null);
            for (const E of o.stops) S[E[0]] = E[1];
            I = typeof o.stops[0][0];
          }
          if (n) {
            const E = {}, L = [];
            for (let G = 0; G < o.stops.length; G++) {
              const K = o.stops[G], ae = K[0].zoom;
              E[ae] === void 0 && (E[ae] = { zoom: ae, type: o.type, property: o.property, default: o.default, stops: [] }, L.push(ae)), E[ae].stops.push([K[0].value, K[1]]);
            }
            const N = [];
            for (const G of L) N.push([E[G].zoom, Th(E[G], t)]);
            const q = { name: "linear" };
            return { kind: "composite", interpolationType: q, interpolationFactor: Xi.interpolationFactor.bind(void 0, q), zoomStops: N.map(((G) => G[0])), evaluate: ({ zoom: G }, K) => Mh({ stops: N, base: o.base }, t, G).evaluate(G, K) };
          }
          if (u) {
            const E = h === "exponential" ? { name: "exponential", base: o.base !== void 0 ? o.base : 1 } : null;
            return { kind: "camera", interpolationType: E, interpolationFactor: Xi.interpolationFactor.bind(void 0, E), zoomStops: o.stops.map(((L) => L[0])), evaluate: ({ zoom: L }) => w(o, t, L, S, I) };
          }
          return { kind: "source", evaluate(E, L) {
            const N = L && L.properties ? L.properties[o.property] : void 0;
            return N === void 0 ? oa(o.default, t.default) : w(o, t, N, S, I);
          } };
        }
        function oa(o, t, n) {
          return o !== void 0 ? o : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function Ih(o, t, n, u, h) {
          return oa(typeof n === h ? u[n] : void 0, o.default, t.default);
        }
        function Lp(o, t, n) {
          if (Sr(n) !== "number") return oa(o.default, t.default);
          const u = o.stops.length;
          if (u === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[u - 1][0]) return o.stops[u - 1][1];
          const h = ka(o.stops.map(((v) => v[0])), n);
          return o.stops[h][1];
        }
        function Mh(o, t, n) {
          const u = o.base !== void 0 ? o.base : 1;
          if (Sr(n) !== "number") return oa(o.default, t.default);
          const h = o.stops.length;
          if (h === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[h - 1][0]) return o.stops[h - 1][1];
          const v = ka(o.stops.map(((E) => E[0])), n), b = (function(E, L, N, q) {
            const G = q - N, K = E - N;
            return G === 0 ? 0 : L === 1 ? K / G : (Math.pow(L, K) - 1) / (Math.pow(L, G) - 1);
          })(n, u, o.stops[v][0], o.stops[v + 1][0]), w = o.stops[v][1], S = o.stops[v + 1][1], I = ko[t.type] || Fp;
          return typeof w.evaluate == "function" ? { evaluate(...E) {
            const L = w.evaluate.apply(void 0, E), N = S.evaluate.apply(void 0, E);
            if (L !== void 0 && N !== void 0) return I(L, N, b, o.colorSpace);
          } } : I(w, S, b, o.colorSpace);
        }
        function Bp(o, t, n) {
          switch (t.type) {
            case "color":
              n = br.parse(n);
              break;
            case "formatted":
              n = mn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = Dn.fromString(n.toString());
              break;
            case "padding":
              n = Ni.parse(n);
              break;
            case "colorArray":
              n = Mi.parse(n);
              break;
            case "numberArray":
              n = gn.parse(n);
              break;
            default:
              Sr(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return oa(n, o.default, t.default);
        }
        Gn.register(as, { error: [{ kind: "error" }, [ar], (o, [t]) => {
          throw new Jr(t.evaluate(o));
        }], typeof: [ar, [hr], (o, [t]) => qr(sr(t.evaluate(o)))], "to-rgba": [nn(st, 4), [ei], (o, [t]) => {
          const [n, u, h, v] = t.evaluate(o).rgb;
          return [255 * n, 255 * u, 255 * h, v];
        }], rgb: [ei, [st, st, st], Ch], rgba: [ei, [st, st, st, st], Ch], has: { type: cr, overloads: [[[ar], (o, [t]) => Sh(t.evaluate(o), o.properties())], [[ar, rn], (o, [t, n]) => Sh(t.evaluate(o), n.evaluate(o))]] }, get: { type: hr, overloads: [[[ar], (o, [t]) => Dc(t.evaluate(o), o.properties())], [[ar, rn], (o, [t, n]) => Dc(t.evaluate(o), n.evaluate(o))]] }, "feature-state": [hr, [ar], (o, [t]) => Dc(t.evaluate(o), o.featureState || {})], properties: [rn, [], (o) => o.properties()], "geometry-type": [ar, [], (o) => o.geometryType()], id: [hr, [], (o) => o.id()], zoom: [st, [], (o) => o.globals.zoom], "heatmap-density": [st, [], (o) => o.globals.heatmapDensity || 0], elevation: [st, [], (o) => o.globals.elevation || 0], "line-progress": [st, [], (o) => o.globals.lineProgress || 0], accumulated: [hr, [], (o) => o.globals.accumulated === void 0 ? null : o.globals.accumulated], "+": [st, Ra(st), (o, t) => {
          let n = 0;
          for (const u of t) n += u.evaluate(o);
          return n;
        }], "*": [st, Ra(st), (o, t) => {
          let n = 1;
          for (const u of t) n *= u.evaluate(o);
          return n;
        }], "-": { type: st, overloads: [[[st, st], (o, [t, n]) => t.evaluate(o) - n.evaluate(o)], [[st], (o, [t]) => -t.evaluate(o)]] }, "/": [st, [st, st], (o, [t, n]) => t.evaluate(o) / n.evaluate(o)], "%": [st, [st, st], (o, [t, n]) => t.evaluate(o) % n.evaluate(o)], ln2: [st, [], () => Math.LN2], pi: [st, [], () => Math.PI], e: [st, [], () => Math.E], "^": [st, [st, st], (o, [t, n]) => Math.pow(t.evaluate(o), n.evaluate(o))], sqrt: [st, [st], (o, [t]) => Math.sqrt(t.evaluate(o))], log10: [st, [st], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN10], ln: [st, [st], (o, [t]) => Math.log(t.evaluate(o))], log2: [st, [st], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN2], sin: [st, [st], (o, [t]) => Math.sin(t.evaluate(o))], cos: [st, [st], (o, [t]) => Math.cos(t.evaluate(o))], tan: [st, [st], (o, [t]) => Math.tan(t.evaluate(o))], asin: [st, [st], (o, [t]) => Math.asin(t.evaluate(o))], acos: [st, [st], (o, [t]) => Math.acos(t.evaluate(o))], atan: [st, [st], (o, [t]) => Math.atan(t.evaluate(o))], min: [st, Ra(st), (o, t) => Math.min(...t.map(((n) => n.evaluate(o))))], max: [st, Ra(st), (o, t) => Math.max(...t.map(((n) => n.evaluate(o))))], abs: [st, [st], (o, [t]) => Math.abs(t.evaluate(o))], round: [st, [st], (o, [t]) => {
          const n = t.evaluate(o);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [st, [st], (o, [t]) => Math.floor(t.evaluate(o))], ceil: [st, [st], (o, [t]) => Math.ceil(t.evaluate(o))], "filter-==": [cr, [ar, hr], (o, [t, n]) => o.properties()[t.value] === n.value], "filter-id-==": [cr, [hr], (o, [t]) => o.id() === t.value], "filter-type-==": [cr, [ar], (o, [t]) => o.geometryType() === t.value], "filter-<": [cr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u < h;
        }], "filter-id-<": [cr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n < u;
        }], "filter->": [cr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u > h;
        }], "filter-id->": [cr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n > u;
        }], "filter-<=": [cr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u <= h;
        }], "filter-id-<=": [cr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n <= u;
        }], "filter->=": [cr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u >= h;
        }], "filter-id->=": [cr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n >= u;
        }], "filter-has": [cr, [hr], (o, [t]) => t.value in o.properties()], "filter-has-id": [cr, [], (o) => o.id() !== null && o.id() !== void 0], "filter-type-in": [cr, [nn(ar)], (o, [t]) => t.value.indexOf(o.geometryType()) >= 0], "filter-id-in": [cr, [nn(hr)], (o, [t]) => t.value.indexOf(o.id()) >= 0], "filter-in-small": [cr, [ar, nn(hr)], (o, [t, n]) => n.value.indexOf(o.properties()[t.value]) >= 0], "filter-in-large": [cr, [ar, nn(hr)], (o, [t, n]) => (function(u, h, v, b) {
          for (; v <= b; ) {
            const w = v + b >> 1;
            if (h[w] === u) return true;
            h[w] > u ? b = w - 1 : v = w + 1;
          }
          return false;
        })(o.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: cr, overloads: [[[cr, cr], (o, [t, n]) => t.evaluate(o) && n.evaluate(o)], [Ra(cr), (o, t) => {
          for (const n of t) if (!n.evaluate(o)) return false;
          return true;
        }]] }, any: { type: cr, overloads: [[[cr, cr], (o, [t, n]) => t.evaluate(o) || n.evaluate(o)], [Ra(cr), (o, t) => {
          for (const n of t) if (n.evaluate(o)) return true;
          return false;
        }]] }, "!": [cr, [cr], (o, [t]) => !t.evaluate(o)], "is-supported-script": [cr, [ar], (o, [t]) => {
          const n = o.globals && o.globals.isSupportedScript;
          return !n || n(t.evaluate(o));
        }], upcase: [ar, [ar], (o, [t]) => t.evaluate(o).toUpperCase()], downcase: [ar, [ar], (o, [t]) => t.evaluate(o).toLowerCase()], concat: [ar, Ra(hr), (o, t) => t.map(((n) => vr(n.evaluate(o)))).join("")], "resolved-locale": [ar, [Jo], (o, [t]) => t.evaluate(o).resolvedLocale()] });
        class Fc {
          constructor(t, n, u) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new vc(), this._defaultValue = n ? (function(h) {
              if (h.type === "color" && Ys(h.default)) return new br(0, 0, 0, 0);
              switch (h.type) {
                case "color":
                  return br.parse(h.default) || null;
                case "padding":
                  return Ni.parse(h.default) || null;
                case "numberArray":
                  return gn.parse(h.default) || null;
                case "colorArray":
                  return Mi.parse(h.default) || null;
                case "variableAnchorOffsetCollection":
                  return vn.parse(h.default) || null;
                case "projectionDefinition":
                  return on.parse(h.default) || null;
                default:
                  return h.default === void 0 ? null : h.default;
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, v, b) {
            return this._globalState && (t = Aa(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = u, this._evaluator.canonical = h, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, u, h, v, b) {
            this._globalState && (t = Aa(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = u || null, this._evaluator.canonical = h, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = b || null;
            try {
              const w = this.expression.evaluate(this._evaluator);
              if (w == null || typeof w == "number" && w != w) return this._defaultValue;
              if (this._enumValues && !(w in this._enumValues)) throw new Jr(`Expected value to be one of ${Object.keys(this._enumValues).map(((S) => JSON.stringify(S))).join(", ")}, but found ${JSON.stringify(w)} instead.`);
              return w;
            } catch (w) {
              return this._warningHistory[w.message] || (this._warningHistory[w.message] = true, typeof console < "u" && console.warn(w.message)), this._defaultValue;
            }
          }
        }
        function au(o) {
          return Array.isArray(o) && o.length > 0 && typeof o[0] == "string" && o[0] in as;
        }
        function Ks(o, t, n) {
          const u = new is(as, iu, [], t ? (function(v) {
            const b = { color: ei, string: ar, number: st, enum: ar, boolean: cr, formatted: qn, padding: Qo, numberArray: _o, colorArray: kn, projectionDefinition: pn, resolvedImage: Xr, variableAnchorOffsetCollection: to };
            return v.type === "array" ? nn(b[v.value] || hr, v.length) : b[v.type];
          })(t) : void 0), h = u.parse(o, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return h ? kh(new Fc(h, t, n)) : ss(u.errors);
        }
        class Js {
          constructor(t, n, u) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !Xs(n.expression), this.globalStateRefs = tl(n.expression), this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, v, b) {
            return this._globalState && (t = Aa(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, v, b);
          }
          evaluate(t, n, u, h, v, b) {
            return this._globalState && (t = Aa(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, v, b);
          }
        }
        class Lc {
          constructor(t, n, u, h, v) {
            this.kind = t, this.zoomStops = u, this._styleExpression = n, this.isStateDependent = t !== "camera" && !Xs(n.expression), this.globalStateRefs = tl(n.expression), this.interpolationType = h, this._globalState = v;
          }
          evaluateWithoutErrorHandling(t, n, u, h, v, b) {
            return this._globalState && (t = Aa(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, v, b);
          }
          evaluate(t, n, u, h, v, b) {
            return this._globalState && (t = Aa(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, v, b);
          }
          interpolationFactor(t, n, u) {
            return this.interpolationType ? Xi.interpolationFactor(this.interpolationType, t, n, u) : 0;
          }
        }
        function Eh(o, t, n) {
          const u = Ks(o, t, n);
          if (u.result === "error") return u;
          const h = u.value.expression, v = nu(h);
          if (!v && !na(t)) return ss([new Zt("", "data expressions not supported")]);
          const b = ou(h, ["zoom"]);
          if (!b && !Ph(t)) return ss([new Zt("", "zoom expressions not supported")]);
          const w = el(h);
          return w || b ? w instanceof Zt ? ss([w]) : w instanceof Xi && !zc(t) ? ss([new Zt("", '"interpolate" expressions cannot be used with this property')]) : kh(w ? new Lc(v ? "camera" : "composite", u.value, w.labels, w instanceof Xi ? w.interpolation : void 0, n) : new Js(v ? "constant" : "source", u.value, n)) : ss([new Zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Qs {
          constructor(t, n) {
            this._parameters = t, this._specification = n, at(this, Th(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new Qs(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function el(o) {
          let t = null;
          if (o instanceof Bs) t = el(o.result);
          else if (o instanceof Ns) {
            for (const n of o.args) if (t = el(n), t) break;
          } else (o instanceof Si || o instanceof Xi) && o.input instanceof Gn && o.input.name === "zoom" && (t = o);
          return t instanceof Zt || o.eachChild(((n) => {
            const u = el(n);
            u instanceof Zt ? t = u : !t && u ? t = new Zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && u && t !== u && (t = new Zt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function tl(o, t = /* @__PURE__ */ new Set()) {
          return o instanceof Hs && t.add(o.key), o.eachChild(((n) => {
            tl(n, t);
          })), t;
        }
        function Aa(o, t) {
          const { zoom: n, heatmapDensity: u, elevation: h, lineProgress: v, isSupportedScript: b, accumulated: w } = o ?? {};
          return { zoom: n, heatmapDensity: u, elevation: h, lineProgress: v, isSupportedScript: b, accumulated: w, globalState: t };
        }
        function rl(o) {
          if (o === true || o === false) return true;
          if (!Array.isArray(o) || o.length === 0) return false;
          switch (o[0]) {
            case "has":
              return o.length >= 2 && o[1] !== "$id" && o[1] !== "$type";
            case "in":
              return o.length >= 3 && (typeof o[1] != "string" || Array.isArray(o[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return o.length !== 3 || Array.isArray(o[1]) || Array.isArray(o[2]);
            case "any":
            case "all":
              for (const t of o.slice(1)) if (!rl(t) && typeof t != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const Bc = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Da(o, t) {
          if (o == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          rl(o) || (o = su(o));
          const n = Ks(o, Bc, t);
          if (n.result === "error") throw new Error(n.value.map(((u) => `${u.key}: ${u.message}`)).join(", "));
          return { filter: (u, h, v) => n.value.evaluate(u, h, {}, v), needGeometry: il(o), getGlobalStateRefs: () => tl(n.value.expression) };
        }
        function Oc(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function il(o) {
          if (!Array.isArray(o)) return false;
          if (o[0] === "within" || o[0] === "distance") return true;
          for (let t = 1; t < o.length; t++) if (il(o[t])) return true;
          return false;
        }
        function su(o) {
          if (!o) return true;
          const t = o[0];
          return o.length <= 1 ? t !== "any" : t === "==" ? $c(o[1], o[2], "==") : t === "!=" ? lu($c(o[1], o[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? $c(o[1], o[2], t) : t === "any" ? (n = o.slice(1), ["any"].concat(n.map(su))) : t === "all" ? ["all"].concat(o.slice(1).map(su)) : t === "none" ? ["all"].concat(o.slice(1).map(su).map(lu)) : t === "in" ? Rh(o[1], o.slice(2)) : t === "!in" ? lu(Rh(o[1], o.slice(2))) : t === "has" ? Ah(o[1]) : t !== "!has" || lu(Ah(o[1]));
          var n;
        }
        function $c(o, t, n) {
          switch (o) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, o, t];
          }
        }
        function Rh(o, t) {
          if (t.length === 0) return false;
          switch (o) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((n) => typeof n != typeof t[0])) ? ["filter-in-large", o, ["literal", t.sort(Oc)]] : ["filter-in-small", o, ["literal", t]];
          }
        }
        function Ah(o) {
          switch (o) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", o];
          }
        }
        function lu(o) {
          return ["!", o];
        }
        function jc(o) {
          const t = typeof o;
          if (t === "number" || t === "boolean" || t === "string" || o == null) return JSON.stringify(o);
          if (Array.isArray(o)) {
            let h = "[";
            for (const v of o) h += `${jc(v)},`;
            return `${h}]`;
          }
          const n = Object.keys(o).sort();
          let u = "{";
          for (let h = 0; h < n.length; h++) u += `${JSON.stringify(n[h])}:${jc(o[n[h]])},`;
          return `${u}}`;
        }
        function Dh(o) {
          let t = "";
          for (const n of Vt) t += `/${jc(o[n])}`;
          return t;
        }
        function Nc(o) {
          const t = o.value;
          return t ? [new de(o.key, t, "constants have been deprecated as of v8")] : [];
        }
        function hi(o) {
          return o instanceof Number || o instanceof String || o instanceof Boolean ? o.valueOf() : o;
        }
        function za(o) {
          if (Array.isArray(o)) return o.map(za);
          if (o instanceof Object && !(o instanceof Number || o instanceof String || o instanceof Boolean)) {
            const t = {};
            for (const n in o) t[n] = za(o[n]);
            return t;
          }
          return hi(o);
        }
        function Fn(o) {
          const t = o.key, n = o.value, u = o.valueSpec || {}, h = o.objectElementValidators || {}, v = o.style, b = o.styleSpec, w = o.validateSpec;
          let S = [];
          const I = Sr(n);
          if (I !== "object") return [new de(t, n, `object expected, ${I} found`)];
          for (const E in n) {
            const L = E.split(".")[0], N = ia(u, L) || u["*"];
            let q;
            if (ia(h, L)) q = h[L];
            else if (ia(u, L)) q = w;
            else if (h["*"]) q = h["*"];
            else {
              if (!u["*"]) {
                S.push(new de(t, n[E], `unknown property "${E}"`));
                continue;
              }
              q = w;
            }
            S = S.concat(q({ key: (t && `${t}.`) + E, value: n[E], valueSpec: N, style: v, styleSpec: b, object: n, objectKey: E, validateSpec: w }, n));
          }
          for (const E in u) h[E] || u[E].required && u[E].default === void 0 && n[E] === void 0 && S.push(new de(t, n, `missing required property "${E}"`));
          return S;
        }
        function uu(o) {
          const t = o.value, n = o.valueSpec, u = o.style, h = o.styleSpec, v = o.key, b = o.arrayElementValidator || o.validateSpec;
          if (Sr(t) !== "array") return [new de(v, t, `array expected, ${Sr(t)} found`)];
          if (n.length && t.length !== n.length) return [new de(v, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new de(v, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let w = { type: n.value, values: n.values };
          h.$version < 7 && (w.function = n.function), Sr(n.value) === "object" && (w = n.value);
          let S = [];
          for (let I = 0; I < t.length; I++) S = S.concat(b({ array: t, arrayIndex: I, value: t[I], valueSpec: w, validateSpec: o.validateSpec, style: u, styleSpec: h, key: `${v}[${I}]` }));
          return S;
        }
        function cu(o) {
          const t = o.key, n = o.value, u = o.valueSpec;
          let h = Sr(n);
          return h === "number" && n != n && (h = "NaN"), h !== "number" ? [new de(t, n, `number expected, ${h} found`)] : "minimum" in u && n < u.minimum ? [new de(t, n, `${n} is less than the minimum value ${u.minimum}`)] : "maximum" in u && n > u.maximum ? [new de(t, n, `${n} is greater than the maximum value ${u.maximum}`)] : [];
        }
        function Vc(o) {
          const t = o.valueSpec, n = hi(o.value.type);
          let u, h, v, b = {};
          const w = n !== "categorical" && o.value.property === void 0, S = !w, I = Sr(o.value.stops) === "array" && Sr(o.value.stops[0]) === "array" && Sr(o.value.stops[0][0]) === "object", E = Fn({ key: o.key, value: o.value, valueSpec: o.styleSpec.function, validateSpec: o.validateSpec, style: o.style, styleSpec: o.styleSpec, objectElementValidators: { stops: function(q) {
            if (n === "identity") return [new de(q.key, q.value, 'identity function may not have a "stops" property')];
            let G = [];
            const K = q.value;
            return G = G.concat(uu({ key: q.key, value: K, valueSpec: q.valueSpec, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec, arrayElementValidator: L })), Sr(K) === "array" && K.length === 0 && G.push(new de(q.key, K, "array must have at least one stop")), G;
          }, default: function(q) {
            return q.validateSpec({ key: q.key, value: q.value, valueSpec: t, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec });
          } } });
          return n === "identity" && w && E.push(new de(o.key, o.value, 'missing required property "property"')), n === "identity" || o.value.stops || E.push(new de(o.key, o.value, 'missing required property "stops"')), n === "exponential" && o.valueSpec.expression && !zc(o.valueSpec) && E.push(new de(o.key, o.value, "exponential functions not supported")), o.styleSpec.$version >= 8 && (S && !na(o.valueSpec) ? E.push(new de(o.key, o.value, "property functions not supported")) : w && !Ph(o.valueSpec) && E.push(new de(o.key, o.value, "zoom functions not supported"))), n !== "categorical" && !I || o.value.property !== void 0 || E.push(new de(o.key, o.value, '"property" property is required')), E;
          function L(q) {
            let G = [];
            const K = q.value, ae = q.key;
            if (Sr(K) !== "array") return [new de(ae, K, `array expected, ${Sr(K)} found`)];
            if (K.length !== 2) return [new de(ae, K, `array length 2 expected, length ${K.length} found`)];
            if (I) {
              if (Sr(K[0]) !== "object") return [new de(ae, K, `object expected, ${Sr(K[0])} found`)];
              if (K[0].zoom === void 0) return [new de(ae, K, "object stop key must have zoom")];
              if (K[0].value === void 0) return [new de(ae, K, "object stop key must have value")];
              if (v && v > hi(K[0].zoom)) return [new de(ae, K[0].zoom, "stop zoom values must appear in ascending order")];
              hi(K[0].zoom) !== v && (v = hi(K[0].zoom), h = void 0, b = {}), G = G.concat(Fn({ key: `${ae}[0]`, value: K[0], valueSpec: { zoom: {} }, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec, objectElementValidators: { zoom: cu, value: N } }));
            } else G = G.concat(N({ key: `${ae}[0]`, value: K[0], validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec }, K));
            return au(za(K[1])) ? G.concat([new de(`${ae}[1]`, K[1], "expressions are not allowed in function stops.")]) : G.concat(q.validateSpec({ key: `${ae}[1]`, value: K[1], valueSpec: t, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec }));
          }
          function N(q, G) {
            const K = Sr(q.value), ae = hi(q.value), me = q.value !== null ? q.value : G;
            if (u) {
              if (K !== u) return [new de(q.key, me, `${K} stop domain type must match previous stop domain type ${u}`)];
            } else u = K;
            if (K !== "number" && K !== "string" && K !== "boolean") return [new de(q.key, me, "stop domain value must be a number, string, or boolean")];
            if (K !== "number" && n !== "categorical") {
              let Oe = `number expected, ${K} found`;
              return na(t) && n === void 0 && (Oe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new de(q.key, me, Oe)];
            }
            return n !== "categorical" || K !== "number" || isFinite(ae) && Math.floor(ae) === ae ? n !== "categorical" && K === "number" && h !== void 0 && ae < h ? [new de(q.key, me, "stop domain values must appear in ascending order")] : (h = ae, n === "categorical" && ae in b ? [new de(q.key, me, "stop domain values must be unique")] : (b[ae] = true, [])) : [new de(q.key, me, `integer expected, found ${ae}`)];
          }
        }
        function Fa(o) {
          const t = (o.expressionContext === "property" ? Eh : Ks)(za(o.value), o.valueSpec);
          if (t.result === "error") return t.value.map(((u) => new de(`${o.key}${u.key}`, o.value, u.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (o.expressionContext === "property" && o.propertyKey === "text-font" && !n.outputDefined()) return [new de(o.key, o.value, `Invalid data expression for "${o.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (o.expressionContext === "property" && o.propertyType === "layout" && !Xs(n)) return [new de(o.key, o.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (o.expressionContext === "filter" && !Xs(n)) return [new de(o.key, o.value, '"feature-state" data expressions are not supported with filters.')];
          if (o.expressionContext && o.expressionContext.indexOf("cluster") === 0) {
            if (!ou(n, ["zoom", "feature-state"])) return [new de(o.key, o.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (o.expressionContext === "cluster-initial" && !nu(n)) return [new de(o.key, o.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function La(o) {
          const t = o.key, n = o.value, u = Sr(n);
          return u !== "string" ? [new de(t, n, `color expected, ${u} found`)] : br.parse(String(n)) ? [] : [new de(t, n, `color expected, "${n}" found`)];
        }
        function nl(o) {
          const t = o.key, n = o.value, u = o.valueSpec, h = [];
          return Array.isArray(u.values) ? u.values.indexOf(hi(n)) === -1 && h.push(new de(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(hi(n)) === -1 && h.push(new de(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), h;
        }
        function Uc(o) {
          return rl(za(o.value)) ? Fa(at({}, o, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : zh(o);
        }
        function zh(o) {
          const t = o.value, n = o.key;
          if (Sr(t) !== "array") return [new de(n, t, `array expected, ${Sr(t)} found`)];
          const u = o.styleSpec;
          let h, v = [];
          if (t.length < 1) return [new de(n, t, "filter array must have at least 1 element")];
          switch (v = v.concat(nl({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: o.style, styleSpec: o.styleSpec })), hi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && hi(t[1]) === "$type" && v.push(new de(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && v.push(new de(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (h = Sr(t[1]), h !== "string" && v.push(new de(`${n}[1]`, t[1], `string expected, ${h} found`)));
              for (let b = 2; b < t.length; b++) h = Sr(t[b]), hi(t[1]) === "$type" ? v = v.concat(nl({ key: `${n}[${b}]`, value: t[b], valueSpec: u.geometry_type, style: o.style, styleSpec: o.styleSpec })) : h !== "string" && h !== "number" && h !== "boolean" && v.push(new de(`${n}[${b}]`, t[b], `string, number, or boolean expected, ${h} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let b = 1; b < t.length; b++) v = v.concat(zh({ key: `${n}[${b}]`, value: t[b], style: o.style, styleSpec: o.styleSpec }));
              break;
            case "has":
            case "!has":
              h = Sr(t[1]), t.length !== 2 ? v.push(new de(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : h !== "string" && v.push(new de(`${n}[1]`, t[1], `string expected, ${h} found`));
          }
          return v;
        }
        function Fh(o, t) {
          const n = o.key, u = o.validateSpec, h = o.style, v = o.styleSpec, b = o.value, w = o.objectKey, S = v[`${t}_${o.layerType}`];
          if (!S) return [];
          const I = w.match(/^(.*)-transition$/);
          if (t === "paint" && I && S[I[1]] && S[I[1]].transition) return u({ key: n, value: b, valueSpec: v.transition, style: h, styleSpec: v });
          const E = o.valueSpec || S[w];
          if (!E) return [new de(n, b, `unknown property "${w}"`)];
          let L;
          if (Sr(b) === "string" && na(E) && !E.tokens && (L = /^{([^}]+)}$/.exec(b))) return [new de(n, b, `"${w}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(L[1])} }\`.`)];
          const N = [];
          return o.layerType === "symbol" && (w === "text-field" && h && !h.glyphs && N.push(new de(n, b, 'use of "text-field" requires a style "glyphs" property')), w === "text-font" && Ys(za(b)) && hi(b.type) === "identity" && N.push(new de(n, b, '"text-font" does not support identity functions'))), N.concat(u({ key: o.key, value: b, valueSpec: E, style: h, styleSpec: v, expressionContext: "property", propertyType: t, propertyKey: w }));
        }
        function Lh(o) {
          return Fh(o, "paint");
        }
        function Bh(o) {
          return Fh(o, "layout");
        }
        function ls(o) {
          let t = [];
          const n = o.value, u = o.key, h = o.style, v = o.styleSpec;
          if (Sr(n) !== "object") return [new de(u, n, `object expected, ${Sr(n)} found`)];
          n.type || n.ref || t.push(new de(u, n, 'either "type" or "ref" is required'));
          let b = hi(n.type);
          const w = hi(n.ref);
          if (n.id) {
            const S = hi(n.id);
            for (let I = 0; I < o.arrayIndex; I++) {
              const E = h.layers[I];
              hi(E.id) === S && t.push(new de(u, n.id, `duplicate layer id "${n.id}", previously used at line ${E.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let S;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((I) => {
              I in n && t.push(new de(u, n[I], `"${I}" is prohibited for ref layers`));
            })), h.layers.forEach(((I) => {
              hi(I.id) === w && (S = I);
            })), S ? S.ref ? t.push(new de(u, n.ref, "ref cannot reference another ref layer")) : b = hi(S.type) : t.push(new de(u, n.ref, `ref layer "${w}" not found`));
          } else if (b !== "background") if (n.source) {
            const S = h.sources && h.sources[n.source], I = S && hi(S.type);
            S ? I === "vector" && b === "raster" ? t.push(new de(u, n.source, `layer "${n.id}" requires a raster source`)) : I !== "raster-dem" && b === "hillshade" || I !== "raster-dem" && b === "color-relief" ? t.push(new de(u, n.source, `layer "${n.id}" requires a raster-dem source`)) : I === "raster" && b !== "raster" ? t.push(new de(u, n.source, `layer "${n.id}" requires a vector source`)) : I !== "vector" || n["source-layer"] ? I === "raster-dem" && b !== "hillshade" && b !== "color-relief" ? t.push(new de(u, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : b !== "line" || !n.paint || !n.paint["line-gradient"] || I === "geojson" && S.lineMetrics || t.push(new de(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new de(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new de(u, n.source, `source "${n.source}" not found`));
          } else t.push(new de(u, n, 'missing required property "source"'));
          return t = t.concat(Fn({ key: u, value: n, valueSpec: v.layer, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, objectElementValidators: { "*": () => [], type: () => o.validateSpec({ key: `${u}.type`, value: n.type, valueSpec: v.layer.type, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, object: n, objectKey: "type" }), filter: Uc, layout: (S) => Fn({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => Bh(at({ layerType: b }, I)) } }), paint: (S) => Fn({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => Lh(at({ layerType: b }, I)) } }) } })), t;
        }
        function oo(o) {
          const t = o.value, n = o.key, u = Sr(t);
          return u !== "string" ? [new de(n, t, `string expected, ${u} found`)] : [];
        }
        const Pn = { promoteId: function({ key: o, value: t }) {
          if (Sr(t) === "string") return oo({ key: o, value: t });
          {
            const n = [];
            for (const u in t) n.push(...oo({ key: `${o}.${u}`, value: t[u] }));
            return n;
          }
        } };
        function us(o) {
          const t = o.value, n = o.key, u = o.styleSpec, h = o.style, v = o.validateSpec;
          if (!t.type) return [new de(n, t, '"type" is required')];
          const b = hi(t.type);
          let w;
          switch (b) {
            case "vector":
            case "raster":
              return w = Fn({ key: n, value: t, valueSpec: u[`source_${b.replace("-", "_")}`], style: o.style, styleSpec: u, objectElementValidators: Pn, validateSpec: v }), w;
            case "raster-dem":
              return w = (function(S) {
                var I;
                const E = (I = S.sourceName) !== null && I !== void 0 ? I : "", L = S.value, N = S.styleSpec, q = N.source_raster_dem, G = S.style;
                let K = [];
                const ae = Sr(L);
                if (L === void 0) return K;
                if (ae !== "object") return K.push(new de("source_raster_dem", L, `object expected, ${ae} found`)), K;
                const me = hi(L.encoding) === "custom", Oe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Ce = S.value.encoding ? `"${S.value.encoding}"` : "Default";
                for (const Ie in L) !me && Oe.includes(Ie) ? K.push(new de(Ie, L[Ie], `In "${E}": "${Ie}" is only valid when "encoding" is set to "custom". ${Ce} encoding found`)) : q[Ie] ? K = K.concat(S.validateSpec({ key: Ie, value: L[Ie], valueSpec: q[Ie], validateSpec: S.validateSpec, style: G, styleSpec: N })) : K.push(new de(Ie, L[Ie], `unknown property "${Ie}"`));
                return K;
              })({ sourceName: n, value: t, style: o.style, styleSpec: u, validateSpec: v }), w;
            case "geojson":
              if (w = Fn({ key: n, value: t, valueSpec: u.source_geojson, style: h, styleSpec: u, validateSpec: v, objectElementValidators: Pn }), t.cluster) for (const S in t.clusterProperties) {
                const [I, E] = t.clusterProperties[S], L = typeof I == "string" ? [I, ["accumulated"], ["get", S]] : I;
                w.push(...Fa({ key: `${n}.${S}.map`, value: E, expressionContext: "cluster-map" })), w.push(...Fa({ key: `${n}.${S}.reduce`, value: L, expressionContext: "cluster-reduce" }));
              }
              return w;
            case "video":
              return Fn({ key: n, value: t, valueSpec: u.source_video, style: h, validateSpec: v, styleSpec: u });
            case "image":
              return Fn({ key: n, value: t, valueSpec: u.source_image, style: h, validateSpec: v, styleSpec: u });
            case "canvas":
              return [new de(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return nl({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function qc(o) {
          const t = o.value, n = o.styleSpec, u = n.light, h = o.style;
          let v = [];
          const b = Sr(t);
          if (t === void 0) return v;
          if (b !== "object") return v = v.concat([new de("light", t, `object expected, ${b} found`)]), v;
          for (const w in t) {
            const S = w.match(/^(.*)-transition$/);
            v = v.concat(S && u[S[1]] && u[S[1]].transition ? o.validateSpec({ key: w, value: t[w], valueSpec: n.transition, validateSpec: o.validateSpec, style: h, styleSpec: n }) : u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new de(w, t[w], `unknown property "${w}"`)]);
          }
          return v;
        }
        function Oh(o) {
          const t = o.value, n = o.styleSpec, u = n.sky, h = o.style, v = Sr(t);
          if (t === void 0) return [];
          if (v !== "object") return [new de("sky", t, `object expected, ${v} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new de(w, t[w], `unknown property "${w}"`)]);
          return b;
        }
        function $h(o) {
          const t = o.value, n = o.styleSpec, u = n.terrain, h = o.style;
          let v = [];
          const b = Sr(t);
          if (t === void 0) return v;
          if (b !== "object") return v = v.concat([new de("terrain", t, `object expected, ${b} found`)]), v;
          for (const w in t) v = v.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new de(w, t[w], `unknown property "${w}"`)]);
          return v;
        }
        function cs(o) {
          let t = [];
          const n = o.value, u = o.key;
          if (Array.isArray(n)) {
            const h = [], v = [];
            for (const b in n) n[b].id && h.includes(n[b].id) && t.push(new de(u, n, `all the sprites' ids must be unique, but ${n[b].id} is duplicated`)), h.push(n[b].id), n[b].url && v.includes(n[b].url) && t.push(new de(u, n, `all the sprites' URLs must be unique, but ${n[b].url} is duplicated`)), v.push(n[b].url), t = t.concat(Fn({ key: `${u}[${b}]`, value: n[b], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: o.validateSpec }));
            return t;
          }
          return oo({ key: u, value: n });
        }
        function Gc(o) {
          return t = o.value, t && t.constructor === Object ? [] : [new de(o.key, o.value, `object expected, ${Sr(o.value)} found`)];
          var t;
        }
        const du = { "*": () => [], array: uu, boolean: function(o) {
          const t = o.value, n = o.key, u = Sr(t);
          return u !== "boolean" ? [new de(n, t, `boolean expected, ${u} found`)] : [];
        }, number: cu, color: La, constants: Nc, enum: nl, filter: Uc, function: Vc, layer: ls, object: Fn, source: us, light: qc, sky: Oh, terrain: $h, projection: function(o) {
          const t = o.value, n = o.styleSpec, u = n.projection, h = o.style, v = Sr(t);
          if (t === void 0) return [];
          if (v !== "object") return [new de("projection", t, `object expected, ${v} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new de(w, t[w], `unknown property "${w}"`)]);
          return b;
        }, projectionDefinition: function(o) {
          const t = o.key;
          let n = o.value;
          n = n instanceof String ? n.valueOf() : n;
          const u = Sr(n);
          return u !== "array" || (function(h) {
            return Array.isArray(h) && h.length === 3 && typeof h[0] == "string" && typeof h[1] == "string" && typeof h[2] == "number";
          })(n) || (function(h) {
            return !!["interpolate", "step", "literal"].includes(h[0]);
          })(n) ? ["array", "string"].includes(u) ? [] : [new de(t, n, `projection expected, invalid type "${u}" found`)] : [new de(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: oo, formatted: function(o) {
          return oo(o).length === 0 ? [] : Fa(o);
        }, resolvedImage: function(o) {
          return oo(o).length === 0 ? [] : Fa(o);
        }, padding: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new de(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const u = { type: "number" };
            let h = [];
            for (let v = 0; v < n.length; v++) h = h.concat(o.validateSpec({ key: `${t}[${v}]`, value: n[v], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return cu({ key: t, value: n, valueSpec: {} });
        }, numberArray: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            const u = { type: "number" };
            if (n.length < 1) return [new de(t, n, "array length at least 1 expected, length 0 found")];
            let h = [];
            for (let v = 0; v < n.length; v++) h = h.concat(o.validateSpec({ key: `${t}[${v}]`, value: n[v], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return cu({ key: t, value: n, valueSpec: {} });
        }, colorArray: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            if (n.length < 1) return [new de(t, n, "array length at least 1 expected, length 0 found")];
            let u = [];
            for (let h = 0; h < n.length; h++) u = u.concat(La({ key: `${t}[${h}]`, value: n[h] }));
            return u;
          }
          return La({ key: t, value: n });
        }, variableAnchorOffsetCollection: function(o) {
          const t = o.key, n = o.value, u = Sr(n), h = o.styleSpec;
          if (u !== "array" || n.length < 1 || n.length % 2 != 0) return [new de(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let v = [];
          for (let b = 0; b < n.length; b += 2) v = v.concat(nl({ key: `${t}[${b}]`, value: n[b], valueSpec: h.layout_symbol["text-anchor"] })), v = v.concat(uu({ key: `${t}[${b + 1}]`, value: n[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: o.validateSpec, style: o.style, styleSpec: h }));
          return v;
        }, sprite: cs, state: Gc };
        function hu(o) {
          const t = o.value, n = o.valueSpec, u = o.styleSpec;
          return o.validateSpec = hu, n.expression && Ys(hi(t)) ? Vc(o) : n.expression && au(za(t)) ? Fa(o) : n.type && du[n.type] ? du[n.type](o) : Fn(at({}, o, { valueSpec: n.type ? u[n.type] : n }));
        }
        function fu(o) {
          const t = o.value, n = o.key, u = oo(o);
          return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new de(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new de(n, t, '"glyphs" url must include a "{range}" token'))), u;
        }
        function Wn(o, t = Te) {
          let n = [];
          return n = n.concat(hu({ key: "", value: o, valueSpec: t.$root, styleSpec: t, style: o, validateSpec: hu, objectElementValidators: { glyphs: fu, "*": () => [] } })), o.constants && (n = n.concat(Nc({ key: "constants", value: o.constants }))), jh(n);
        }
        function yn(o) {
          return function(t) {
            return o(Object.assign({}, t, { validateSpec: hu }));
          };
        }
        function jh(o) {
          return [].concat(o).sort(((t, n) => t.line - n.line));
        }
        function ao(o) {
          return function(...t) {
            return jh(o.apply(this, t));
          };
        }
        Wn.source = ao(yn(us)), Wn.sprite = ao(yn(cs)), Wn.glyphs = ao(yn(fu)), Wn.light = ao(yn(qc)), Wn.sky = ao(yn(Oh)), Wn.terrain = ao(yn($h)), Wn.state = ao(yn(Gc)), Wn.layer = ao(yn(ls)), Wn.filter = ao(yn(Uc)), Wn.paintProperty = ao(yn(Lh)), Wn.layoutProperty = ao(yn(Bh));
        const ds = Wn, ol = ds.light, Op = ds.sky, $p = ds.paintProperty, pu = ds.layoutProperty;
        function Nh(o, t) {
          let n = false;
          if (t && t.length) for (const u of t) o.fire(new Xe(new Error(u.message))), n = true;
          return n;
        }
        class Ba {
          constructor(t, n, u) {
            const h = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const b = new Int32Array(this.arrayBuffer);
              t = b[0], this.d = (n = b[1]) + 2 * (u = b[2]);
              for (let S = 0; S < this.d * this.d; S++) {
                const I = b[3 + S], E = b[3 + S + 1];
                h.push(I === E ? null : b.subarray(I, E));
              }
              const w = b[3 + h.length + 1];
              this.keys = b.subarray(b[3 + h.length], w), this.bboxes = b.subarray(w), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * u;
              for (let b = 0; b < this.d * this.d; b++) h.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = u, this.scale = n / t, this.uid = 0;
            const v = u / n * t;
            this.min = -v, this.max = t + v;
          }
          insert(t, n, u, h, v) {
            this._forEachCell(n, u, h, v, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(h), this.bboxes.push(v);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, u, h, v, b) {
            this.cells[v].push(b);
          }
          query(t, n, u, h, v) {
            const b = this.min, w = this.max;
            if (t <= b && n <= b && w <= u && w <= h && !v) return Array.prototype.slice.call(this.keys);
            {
              const S = [];
              return this._forEachCell(t, n, u, h, this._queryCell, S, {}, v), S;
            }
          }
          _queryCell(t, n, u, h, v, b, w, S) {
            const I = this.cells[v];
            if (I !== null) {
              const E = this.keys, L = this.bboxes;
              for (let N = 0; N < I.length; N++) {
                const q = I[N];
                if (w[q] === void 0) {
                  const G = 4 * q;
                  (S ? S(L[G + 0], L[G + 1], L[G + 2], L[G + 3]) : t <= L[G + 2] && n <= L[G + 3] && u >= L[G + 0] && h >= L[G + 1]) ? (w[q] = true, b.push(E[q])) : w[q] = false;
                }
              }
            }
          }
          _forEachCell(t, n, u, h, v, b, w, S) {
            const I = this._convertToCellCoord(t), E = this._convertToCellCoord(n), L = this._convertToCellCoord(u), N = this._convertToCellCoord(h);
            for (let q = I; q <= L; q++) for (let G = E; G <= N; G++) {
              const K = this.d * G + q;
              if ((!S || S(this._convertFromCellCoord(q), this._convertFromCellCoord(G), this._convertFromCellCoord(q + 1), this._convertFromCellCoord(G + 1))) && v.call(this, t, n, u, h, K, b, w, S)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let u = 0;
            for (let b = 0; b < this.cells.length; b++) u += this.cells[b].length;
            const h = new Int32Array(n + u + this.keys.length + this.bboxes.length);
            h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
            let v = n;
            for (let b = 0; b < t.length; b++) {
              const w = t[b];
              h[3 + b] = v, h.set(w, v), v += w.length;
            }
            return h[3 + t.length] = v, h.set(this.keys, v), v += this.keys.length, h[3 + t.length + 1] = v, h.set(this.bboxes, v), v += this.bboxes.length, h.buffer;
          }
          static serialize(t, n) {
            const u = t.toArrayBuffer();
            return n && n.push(u), { buffer: u };
          }
          static deserialize(t) {
            return new Ba(t.buffer);
          }
        }
        const Zn = {};
        function Ot(o, t, n = {}) {
          if (Zn[o]) throw new Error(`${o} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: o, writeable: false }), Zn[o] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        Ot("Object", Object), Ot("Set", Set), Ot("TransferableGridIndex", Ba), Ot("Color", br), Ot("Error", Error), Ot("AJAXError", xe), Ot("ResolvedImage", Dn), Ot("StylePropertyFunction", Qs), Ot("StyleExpression", Fc, { omit: ["_evaluator"] }), Ot("ZoomDependentExpression", Lc), Ot("ZoomConstantExpression", Js), Ot("CompoundExpression", Gn, { omit: ["_evaluate"] });
        for (const o in as) as[o]._classRegistryKey || Ot(`Expression_${o}`, as[o]);
        function Wc(o) {
          return o && typeof ArrayBuffer < "u" && (o instanceof ArrayBuffer || o.constructor && o.constructor.name === "ArrayBuffer");
        }
        function mu(o) {
          return o.$name || o.constructor._classRegistryKey;
        }
        function Zc(o) {
          return !(function(t) {
            if (t === null || typeof t != "object") return false;
            const n = mu(t);
            return !(!n || n === "Object");
          })(o) && (o == null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || o instanceof Boolean || o instanceof Number || o instanceof String || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof Error || Wc(o) || Ee(o) || ArrayBuffer.isView(o) || o instanceof ImageData);
        }
        function Oa(o, t) {
          if (Zc(o)) return (Wc(o) || Ee(o)) && t && t.push(o), ArrayBuffer.isView(o) && t && t.push(o.buffer), o instanceof ImageData && t && t.push(o.data.buffer), o;
          if (Array.isArray(o)) {
            const v = [];
            for (const b of o) v.push(Oa(b, t));
            return v;
          }
          if (typeof o != "object") throw new Error("can't serialize object of type " + typeof o);
          const n = mu(o);
          if (!n) throw new Error(`can't serialize object of unregistered class ${o.constructor.name}`);
          if (!Zn[n]) throw new Error(`${n} is not registered.`);
          const { klass: u } = Zn[n], h = u.serialize ? u.serialize(o, t) : {};
          if (u.serialize) {
            if (t && h === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const v in o) {
              if (!o.hasOwnProperty(v) || Zn[n].omit.indexOf(v) >= 0) continue;
              const b = o[v];
              h[v] = Zn[n].shallow.indexOf(v) >= 0 ? b : Oa(b, t);
            }
            o instanceof Error && (h.message = o.message);
          }
          if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (h.$name = n), h;
        }
        function hs(o) {
          if (Zc(o)) return o;
          if (Array.isArray(o)) return o.map(hs);
          if (typeof o != "object") throw new Error("can't deserialize object of type " + typeof o);
          const t = mu(o) || "Object";
          if (!Zn[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = Zn[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(o);
          const u = Object.create(n.prototype);
          for (const h of Object.keys(o)) {
            if (h === "$name") continue;
            const v = o[h];
            u[h] = Zn[t].shallow.indexOf(h) >= 0 ? v : hs(v);
          }
          return u;
        }
        class Hc {
          constructor() {
            this.first = true;
          }
          update(t, n) {
            const u = Math.floor(t);
            return this.first ? (this.first = false, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = u, true) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = u, true));
          }
        }
        const kr = { "Latin-1 Supplement": (o) => o >= 128 && o <= 255, "Hangul Jamo": (o) => o >= 4352 && o <= 4607, Khmer: (o) => o >= 6016 && o <= 6143, "General Punctuation": (o) => o >= 8192 && o <= 8303, "Letterlike Symbols": (o) => o >= 8448 && o <= 8527, "Number Forms": (o) => o >= 8528 && o <= 8591, "Miscellaneous Technical": (o) => o >= 8960 && o <= 9215, "Control Pictures": (o) => o >= 9216 && o <= 9279, "Optical Character Recognition": (o) => o >= 9280 && o <= 9311, "Enclosed Alphanumerics": (o) => o >= 9312 && o <= 9471, "Geometric Shapes": (o) => o >= 9632 && o <= 9727, "Miscellaneous Symbols": (o) => o >= 9728 && o <= 9983, "Miscellaneous Symbols and Arrows": (o) => o >= 11008 && o <= 11263, "Ideographic Description Characters": (o) => o >= 12272 && o <= 12287, "CJK Symbols and Punctuation": (o) => o >= 12288 && o <= 12351, Hiragana: (o) => o >= 12352 && o <= 12447, Katakana: (o) => o >= 12448 && o <= 12543, Kanbun: (o) => o >= 12688 && o <= 12703, "CJK Strokes": (o) => o >= 12736 && o <= 12783, "Enclosed CJK Letters and Months": (o) => o >= 12800 && o <= 13055, "CJK Compatibility": (o) => o >= 13056 && o <= 13311, "Yijing Hexagram Symbols": (o) => o >= 19904 && o <= 19967, "CJK Unified Ideographs": (o) => o >= 19968 && o <= 40959, "Hangul Syllables": (o) => o >= 44032 && o <= 55215, "Private Use Area": (o) => o >= 57344 && o <= 63743, "Vertical Forms": (o) => o >= 65040 && o <= 65055, "CJK Compatibility Forms": (o) => o >= 65072 && o <= 65103, "Small Form Variants": (o) => o >= 65104 && o <= 65135, "Halfwidth and Fullwidth Forms": (o) => o >= 65280 && o <= 65519 };
        function Xc(o) {
          for (const t of o) if (Kc(t.charCodeAt(0))) return true;
          return false;
        }
        function Vh(o) {
          for (const t of o) if (!qh(t.charCodeAt(0))) return false;
          return true;
        }
        function Yc(o) {
          const t = o.map(((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((n) => n));
          return new RegExp(t.join("|"), "u");
        }
        const Uh = Yc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function qh(o) {
          return !Uh.test(String.fromCodePoint(o));
        }
        const Gh = Yc(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Kc(o) {
          return !(o !== 746 && o !== 747 && (o < 4352 || !(kr["CJK Compatibility Forms"](o) && !(o >= 65097 && o <= 65103) || kr["CJK Compatibility"](o) || kr["CJK Strokes"](o) || !(!kr["CJK Symbols and Punctuation"](o) || o >= 12296 && o <= 12305 || o >= 12308 && o <= 12319 || o === 12336) || kr["Enclosed CJK Letters and Months"](o) || kr["Ideographic Description Characters"](o) || kr.Kanbun(o) || kr.Katakana(o) && o !== 12540 || !(!kr["Halfwidth and Fullwidth Forms"](o) || o === 65288 || o === 65289 || o === 65293 || o >= 65306 && o <= 65310 || o === 65339 || o === 65341 || o === 65343 || o >= 65371 && o <= 65503 || o === 65507 || o >= 65512 && o <= 65519) || !(!kr["Small Form Variants"](o) || o >= 65112 && o <= 65118 || o >= 65123 && o <= 65126) || kr["Vertical Forms"](o) || kr["Yijing Hexagram Symbols"](o) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(o)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(o)) || Gh.test(String.fromCodePoint(o)))));
        }
        function Jc(o) {
          return !(Kc(o) || (function(t) {
            return !!(kr["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || kr["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || kr["Letterlike Symbols"](t) || kr["Number Forms"](t) || kr["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || kr["Control Pictures"](t) && t !== 9251 || kr["Optical Character Recognition"](t) || kr["Enclosed Alphanumerics"](t) || kr["Geometric Shapes"](t) || kr["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || kr["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || kr["CJK Symbols and Punctuation"](t) || kr.Katakana(t) || kr["Private Use Area"](t) || kr["CJK Compatibility Forms"](t) || kr["Small Form Variants"](t) || kr["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(o));
        }
        const Wh = Yc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Qc(o) {
          return Wh.test(String.fromCodePoint(o));
        }
        function Zh(o, t) {
          return !(!t && Qc(o) || o >= 2304 && o <= 3583 || o >= 3840 && o <= 4255 || kr.Khmer(o));
        }
        function gu(o) {
          for (const t of o) if (Qc(t.charCodeAt(0))) return true;
          return false;
        }
        const aa = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(o) {
            this.pluginStatus = o.pluginStatus, this.pluginURL = o.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(o) {
            if (aa.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = o.applyArabicShaping, this.processBidirectionalText = o.processBidirectionalText, this.processStyledBidirectionalText = o.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (o.pluginStatus !== "loading") return this.setState(o), o;
              const n = o.pluginURL, u = new Promise(((v) => {
                this.loadScriptResolve = v;
              }));
              t(n);
              const h = new Promise(((v) => setTimeout((() => v()), this.TIMEOUT)));
              if (yield Promise.race([u, h]), this.isParsed()) {
                const v = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(v), v;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            }));
          }
        }();
        class Gr {
          constructor(t, n) {
            this.isSupportedScript = jp, this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new Hc(), this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Hc(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), u = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * n };
          }
        }
        function jp(o) {
          return (function(t, n) {
            for (const u of t) if (!Zh(u.charCodeAt(0), n)) return false;
            return true;
          })(o, aa.getRTLTextPluginStatus() === "loaded");
        }
        class vu {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.expression = (function(h, v, b) {
              if (Ys(h)) return new Qs(h, v);
              if (au(h)) {
                const w = Eh(h, v, b);
                if (w.result === "error") throw new Error(w.value.map(((S) => `${S.key}: ${S.message}`)).join(", "));
                return w.value;
              }
              {
                let w = h;
                return v.type === "color" && typeof h == "string" ? w = br.parse(h) : v.type !== "padding" || typeof h != "number" && !Array.isArray(h) ? v.type !== "numberArray" || typeof h != "number" && !Array.isArray(h) ? v.type !== "colorArray" || typeof h != "string" && !Array.isArray(h) ? v.type === "variableAnchorOffsetCollection" && Array.isArray(h) ? w = vn.parse(h) : v.type === "projectionDefinition" && typeof h == "string" && (w = on.parse(h)) : w = Mi.parse(h) : w = gn.parse(h) : w = Ni.parse(h), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => w };
              }
            })(n === void 0 ? t.specification.default : n, t.specification, u);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, n, u) {
            return this.property.possiblyEvaluate(this, t, n, u);
          }
        }
        class yu {
          constructor(t, n) {
            this.property = t, this.value = new vu(t, void 0, n);
          }
          transitioned(t, n) {
            return new td(this.property, this.value, n, It({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new td(this.property, this.value, null, {}, 0);
          }
        }
        class ed {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = n;
          }
          getValue(t) {
            return ir(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new yu(this._values[t].property, this._globalState)), this._values[t].value = new vu(this._values[t].property, n === null ? void 0 : ir(n), this._globalState);
          }
          getTransition(t) {
            return ir(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new yu(this._values[t].property, this._globalState)), this._values[t].transition = ir(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
              const h = this.getTransition(n);
              h !== void 0 && (t[`${n}-transition`] = h);
            }
            return t;
          }
          transitioned(t, n) {
            const u = new Hh(this._properties);
            for (const h of Object.keys(this._values)) u._values[h] = this._values[h].transitioned(t, n._values[h]);
            return u;
          }
          untransitioned() {
            const t = new Hh(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class td {
          constructor(t, n, u, h, v) {
            this.property = t, this.value = n, this.begin = v + h.delay || 0, this.end = this.begin + h.duration || 0, t.specification.transition && (h.delay || h.duration) && (this.prior = u);
          }
          possiblyEvaluate(t, n, u) {
            const h = t.now || 0, v = this.value.possiblyEvaluate(t, n, u), b = this.prior;
            if (b) {
              if (h > this.end) return this.prior = null, v;
              if (this.value.isDataDriven()) return this.prior = null, v;
              if (h < this.begin) return b.possiblyEvaluate(t, n, u);
              {
                const w = (h - this.begin) / (this.end - this.begin);
                return this.property.interpolate(b.possiblyEvaluate(t, n, u), v, _t(w));
              }
            }
            return v;
          }
        }
        class Hh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, u) {
            const h = new _u(this._properties);
            for (const v of Object.keys(this._values)) h._values[v] = this._values[v].possiblyEvaluate(t, n, u);
            return h;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return true;
            return false;
          }
        }
        class Np {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = n;
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return ir(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new vu(this._values[t].property, n === null ? void 0 : ir(n), this._globalState);
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
            }
            return t;
          }
          possiblyEvaluate(t, n, u) {
            const h = new _u(this._properties);
            for (const v of Object.keys(this._values)) h._values[v] = this._values[v].possiblyEvaluate(t, n, u);
            return h;
          }
        }
        class Po {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.parameters = u;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, u, h) {
            return this.property.evaluate(this.value, this.parameters, t, n, u, h);
          }
        }
        class _u {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Wt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, u) {
            const h = ko[this.specification.type];
            return h ? h(t, n, u) : t;
          }
        }
        class er {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, u, h) {
            return new Po(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, u, h) } : t.expression, n);
          }
          interpolate(t, n, u) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Po(this, { kind: "constant", value: void 0 }, t.parameters);
            const h = ko[this.specification.type];
            if (h) {
              const v = h(t.value.value, n.value.value, u);
              return new Po(this, { kind: "constant", value: v }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, u, h, v, b) {
            return t.kind === "constant" ? t.value : t.evaluate(n, u, h, v, b);
          }
        }
        class al extends er {
          possiblyEvaluate(t, n, u, h) {
            if (t.value === void 0) return new Po(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const v = t.expression.evaluate(n, null, {}, u, h), b = t.property.specification.type === "resolvedImage" && typeof v != "string" ? v.name : v, w = this._calculate(b, b, b, n);
              return new Po(this, { kind: "constant", value: w }, n);
            }
            if (t.expression.kind === "camera") {
              const v = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new Po(this, { kind: "constant", value: v }, n);
            }
            return new Po(this, t.expression, n);
          }
          evaluate(t, n, u, h, v, b) {
            if (t.kind === "source") {
              const w = t.evaluate(n, u, h, v, b);
              return this._calculate(w, w, w, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, u, h), n) : t.value;
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class Xh {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const v = t.expression.evaluate(n, null, {}, u, h);
                return this._calculate(v, v, v, n);
              }
              return this._calculate(t.expression.evaluate(new Gr(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Gr(Math.floor(n.zoom), n)), t.expression.evaluate(new Gr(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class bu {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            return !!t.expression.evaluate(n, null, {}, u, h);
          }
          interpolate() {
            return false;
          }
        }
        class sn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const u = t[n];
              u.specification.overridable && this.overridableProperties.push(n);
              const h = this.defaultPropertyValues[n] = new vu(u, void 0, void 0), v = this.defaultTransitionablePropertyValues[n] = new yu(u, void 0);
              this.defaultTransitioningPropertyValues[n] = v.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = h.possiblyEvaluate({});
            }
          }
        }
        Ot("DataDrivenProperty", er), Ot("DataConstantProperty", Wt), Ot("CrossFadedDataDrivenProperty", al), Ot("CrossFadedProperty", Xh), Ot("ColorRampProperty", bu);
        const Yh = "-transition";
        class so extends xt {
          constructor(t, n, u) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = u, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Da(t.filter, u)), n.layout && (this._unevaluatedLayout = new Np(n.layout, u)), n.paint)) {
              this._transitionablePaint = new ed(n.paint, u);
              for (const h in t.paint) this.setPaintProperty(h, t.paint[h], { validate: false });
              for (const h in t.layout) this.setLayoutProperty(h, t.layout[h], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new _u(n.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Da(t, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const n in this._unevaluatedLayout._values) {
              const u = this._unevaluatedLayout._values[n];
              for (const h of u.getGlobalStateRefs()) t.add(h);
            }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map();
            if (this._transitionablePaint) for (const u in this._transitionablePaint._values) {
              const h = this._transitionablePaint._values[u].value;
              for (const v of h.getGlobalStateRefs()) {
                const b = (t = n.get(v)) !== null && t !== void 0 ? t : [];
                b.push({ name: u, value: h.value }), n.set(v, b);
              }
            }
            return n;
          }
          setLayoutProperty(t, n, u = {}) {
            n != null && this._validate(pu, `layers.${this.id}.layout.${t}`, t, n, u) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(Yh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, u = {}) {
            if (n != null && this._validate($p, `layers.${this.id}.paint.${t}`, t, n, u)) return false;
            if (t.endsWith(Yh)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), false;
            {
              const h = this._transitionablePaint._values[t], v = h.property.specification["property-type"] === "cross-faded-data-driven", b = h.value.isDataDriven(), w = h.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const S = this._transitionablePaint._values[t].value;
              return S.isDataDriven() || b || v || this._handleOverridablePaintPropertyUpdate(t, w, S);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return false;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), gr(t, ((n, u) => !(n === void 0 || u === "layout" && !Object.keys(n).length || u === "paint" && !Object.keys(n).length)));
          }
          _validate(t, n, u, h, v = {}) {
            return (!v || v.validate !== false) && Nh(this, t.call(ds, { key: n, layerType: this.type, objectKey: u, value: h, styleSpec: Te, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Po && na(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const $a = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class fs {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ni {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = true, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function xi(o, t = 1) {
          let n = 0, u = 0;
          return { members: o.map(((h) => {
            const v = $a[h.type].BYTES_PER_ELEMENT, b = n = xu(n, Math.max(t, v)), w = h.components || 1;
            return u = Math.max(u, v), n += v * w, { name: h.name, type: h.type, components: w, offset: b };
          })), size: xu(n, Math.max(u, t)), alignment: t };
        }
        function xu(o, t) {
          return Math.ceil(o / t) * t;
        }
        class sl extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.int16[h + 0] = n, this.int16[h + 1] = u, t;
          }
        }
        sl.prototype.bytesPerElement = 4, Ot("StructArrayLayout2i4", sl);
        class ja extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const v = 3 * t;
            return this.int16[v + 0] = n, this.int16[v + 1] = u, this.int16[v + 2] = h, t;
          }
        }
        ja.prototype.bytesPerElement = 6, Ot("StructArrayLayout3i6", ja);
        class Na extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, n, u, h);
          }
          emplace(t, n, u, h, v) {
            const b = 4 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = u, this.int16[b + 2] = h, this.int16[b + 3] = v, t;
          }
        }
        Na.prototype.bytesPerElement = 8, Ot("StructArrayLayout4i8", Na);
        class rd extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, v, b);
          }
          emplace(t, n, u, h, v, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = v, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        rd.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i4i12", rd);
        class wu extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, v, b);
          }
          emplace(t, n, u, h, v, b, w) {
            const S = 4 * t, I = 8 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.uint8[I + 4] = h, this.uint8[I + 5] = v, this.uint8[I + 6] = b, this.uint8[I + 7] = w, t;
          }
        }
        wu.prototype.bytesPerElement = 8, Ot("StructArrayLayout2i4ub8", wu);
        class Lo extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.float32[h + 0] = n, this.float32[h + 1] = u, t;
          }
        }
        Lo.prototype.bytesPerElement = 8, Ot("StructArrayLayout2f8", Lo);
        class id extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S, I, E) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, n, u, h, v, b, w, S, I, E);
          }
          emplace(t, n, u, h, v, b, w, S, I, E, L) {
            const N = 10 * t;
            return this.uint16[N + 0] = n, this.uint16[N + 1] = u, this.uint16[N + 2] = h, this.uint16[N + 3] = v, this.uint16[N + 4] = b, this.uint16[N + 5] = w, this.uint16[N + 6] = S, this.uint16[N + 7] = I, this.uint16[N + 8] = E, this.uint16[N + 9] = L, t;
          }
        }
        id.prototype.bytesPerElement = 20, Ot("StructArrayLayout10ui20", id);
        class nd extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, n, u, h, v, b, w, S);
          }
          emplace(t, n, u, h, v, b, w, S, I) {
            const E = 8 * t;
            return this.uint16[E + 0] = n, this.uint16[E + 1] = u, this.uint16[E + 2] = h, this.uint16[E + 3] = v, this.uint16[E + 4] = b, this.uint16[E + 5] = w, this.uint16[E + 6] = S, this.uint16[E + 7] = I, t;
          }
        }
        nd.prototype.bytesPerElement = 16, Ot("StructArrayLayout8ui16", nd);
        class Cu extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S, I, E, L, N) {
            const q = this.length;
            return this.resize(q + 1), this.emplace(q, t, n, u, h, v, b, w, S, I, E, L, N);
          }
          emplace(t, n, u, h, v, b, w, S, I, E, L, N, q) {
            const G = 12 * t;
            return this.int16[G + 0] = n, this.int16[G + 1] = u, this.int16[G + 2] = h, this.int16[G + 3] = v, this.uint16[G + 4] = b, this.uint16[G + 5] = w, this.uint16[G + 6] = S, this.uint16[G + 7] = I, this.int16[G + 8] = E, this.int16[G + 9] = L, this.int16[G + 10] = N, this.int16[G + 11] = q, t;
          }
        }
        Cu.prototype.bytesPerElement = 24, Ot("StructArrayLayout4i4ui4i24", Cu);
        class od extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const v = 3 * t;
            return this.float32[v + 0] = n, this.float32[v + 1] = u, this.float32[v + 2] = h, t;
          }
        }
        od.prototype.bytesPerElement = 12, Ot("StructArrayLayout3f12", od);
        class y extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        y.prototype.bytesPerElement = 4, Ot("StructArrayLayout1ul4", y);
        class e extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S, I) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, t, n, u, h, v, b, w, S, I);
          }
          emplace(t, n, u, h, v, b, w, S, I, E) {
            const L = 10 * t, N = 5 * t;
            return this.int16[L + 0] = n, this.int16[L + 1] = u, this.int16[L + 2] = h, this.int16[L + 3] = v, this.int16[L + 4] = b, this.int16[L + 5] = w, this.uint32[N + 3] = S, this.uint16[L + 8] = I, this.uint16[L + 9] = E, t;
          }
        }
        e.prototype.bytesPerElement = 20, Ot("StructArrayLayout6i1ul2ui20", e);
        class a extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, v, b);
          }
          emplace(t, n, u, h, v, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = v, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        a.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i2i2i12", a);
        class c extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, n, u, h, v);
          }
          emplace(t, n, u, h, v, b) {
            const w = 4 * t, S = 8 * t;
            return this.float32[w + 0] = n, this.float32[w + 1] = u, this.float32[w + 2] = h, this.int16[S + 6] = v, this.int16[S + 7] = b, t;
          }
        }
        c.prototype.bytesPerElement = 16, Ot("StructArrayLayout2f1f2i16", c);
        class p extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, v, b);
          }
          emplace(t, n, u, h, v, b, w) {
            const S = 16 * t, I = 4 * t, E = 8 * t;
            return this.uint8[S + 0] = n, this.uint8[S + 1] = u, this.float32[I + 1] = h, this.float32[I + 2] = v, this.int16[E + 6] = b, this.int16[E + 7] = w, t;
          }
        }
        p.prototype.bytesPerElement = 16, Ot("StructArrayLayout2ub2f2i16", p);
        class _ extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const v = 3 * t;
            return this.uint16[v + 0] = n, this.uint16[v + 1] = u, this.uint16[v + 2] = h, t;
          }
        }
        _.prototype.bytesPerElement = 6, Ot("StructArrayLayout3ui6", _);
        class x extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me) {
            const Oe = this.length;
            return this.resize(Oe + 1), this.emplace(Oe, t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me);
          }
          emplace(t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me, Oe) {
            const Ce = 24 * t, Ie = 12 * t, Ze = 48 * t;
            return this.int16[Ce + 0] = n, this.int16[Ce + 1] = u, this.uint16[Ce + 2] = h, this.uint16[Ce + 3] = v, this.uint32[Ie + 2] = b, this.uint32[Ie + 3] = w, this.uint32[Ie + 4] = S, this.uint16[Ce + 10] = I, this.uint16[Ce + 11] = E, this.uint16[Ce + 12] = L, this.float32[Ie + 7] = N, this.float32[Ie + 8] = q, this.uint8[Ze + 36] = G, this.uint8[Ze + 37] = K, this.uint8[Ze + 38] = ae, this.uint32[Ie + 10] = me, this.int16[Ce + 22] = Oe, t;
          }
        }
        x.prototype.bytesPerElement = 48, Ot("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", x);
        class k extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me, Oe, Ce, Ie, Ze, rt, vt, Dt, Tt, Et, Yt, Mt) {
            const Rt = this.length;
            return this.resize(Rt + 1), this.emplace(Rt, t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me, Oe, Ce, Ie, Ze, rt, vt, Dt, Tt, Et, Yt, Mt);
          }
          emplace(t, n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me, Oe, Ce, Ie, Ze, rt, vt, Dt, Tt, Et, Yt, Mt, Rt) {
            const ct = 32 * t, lr = 16 * t;
            return this.int16[ct + 0] = n, this.int16[ct + 1] = u, this.int16[ct + 2] = h, this.int16[ct + 3] = v, this.int16[ct + 4] = b, this.int16[ct + 5] = w, this.int16[ct + 6] = S, this.int16[ct + 7] = I, this.uint16[ct + 8] = E, this.uint16[ct + 9] = L, this.uint16[ct + 10] = N, this.uint16[ct + 11] = q, this.uint16[ct + 12] = G, this.uint16[ct + 13] = K, this.uint16[ct + 14] = ae, this.uint16[ct + 15] = me, this.uint16[ct + 16] = Oe, this.uint16[ct + 17] = Ce, this.uint16[ct + 18] = Ie, this.uint16[ct + 19] = Ze, this.uint16[ct + 20] = rt, this.uint16[ct + 21] = vt, this.uint16[ct + 22] = Dt, this.uint32[lr + 12] = Tt, this.float32[lr + 13] = Et, this.float32[lr + 14] = Yt, this.uint16[ct + 30] = Mt, this.uint16[ct + 31] = Rt, t;
          }
        }
        k.prototype.bytesPerElement = 64, Ot("StructArrayLayout8i15ui1ul2f2ui64", k);
        class T extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        T.prototype.bytesPerElement = 4, Ot("StructArrayLayout1f4", T);
        class R extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const v = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[v + 1] = u, this.float32[v + 2] = h, t;
          }
        }
        R.prototype.bytesPerElement = 12, Ot("StructArrayLayout1ui2f12", R);
        class z extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const v = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[v + 2] = u, this.uint16[v + 3] = h, t;
          }
        }
        z.prototype.bytesPerElement = 8, Ot("StructArrayLayout1ul2ui8", z);
        class j extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.uint16[h + 0] = n, this.uint16[h + 1] = u, t;
          }
        }
        j.prototype.bytesPerElement = 4, Ot("StructArrayLayout2ui4", j);
        class $ extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        $.prototype.bytesPerElement = 2, Ot("StructArrayLayout1ui2", $);
        class U extends ni {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, n, u, h);
          }
          emplace(t, n, u, h, v) {
            const b = 4 * t;
            return this.float32[b + 0] = n, this.float32[b + 1] = u, this.float32[b + 2] = h, this.float32[b + 3] = v, t;
          }
        }
        U.prototype.bytesPerElement = 16, Ot("StructArrayLayout4f16", U);
        class Q extends fs {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new C(this.anchorPointX, this.anchorPointY);
          }
        }
        Q.prototype.size = 20;
        class se extends e {
          get(t) {
            return new Q(this, t);
          }
        }
        Ot("CollisionBoxArray", se);
        class le extends fs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        le.prototype.size = 48;
        class ue extends x {
          get(t) {
            return new le(this, t);
          }
        }
        Ot("PlacedSymbolArray", ue);
        class ge extends fs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        ge.prototype.size = 64;
        class we extends k {
          get(t) {
            return new ge(this, t);
          }
        }
        Ot("SymbolInstanceArray", we);
        class ye extends T {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Ot("GlyphOffsetArray", ye);
        class ke extends ja {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Ot("SymbolLineVertexArray", ke);
        class Ae extends fs {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Ae.prototype.size = 12;
        class be extends R {
          get(t) {
            return new Ae(this, t);
          }
        }
        Ot("TextAnchorOffsetArray", be);
        class Le extends fs {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        Le.prototype.size = 8;
        class Ke extends z {
          get(t) {
            return new Le(this, t);
          }
        }
        Ot("FeatureIndexArray", Ke);
        class We extends sl {
        }
        class He extends sl {
        }
        class Je extends sl {
        }
        class kt extends rd {
        }
        class St extends wu {
        }
        class pt extends Lo {
        }
        class Nt extends id {
        }
        class yr extends nd {
        }
        class Or extends Cu {
        }
        class oi extends od {
        }
        class ti extends y {
        }
        class fi extends a {
        }
        class ai extends p {
        }
        class Li extends _ {
        }
        class si extends j {
        }
        const Yr = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: mi } = Yr;
        class xr {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t;
          }
          prepareSegment(t, n, u, h) {
            const v = this.segments[this.segments.length - 1];
            return t > xr.MAX_VERTEX_ARRAY_LENGTH && Ut(`Max vertices per segment is ${xr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${xr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !v || v.vertexLength + t > xr.MAX_VERTEX_ARRAY_LENGTH || v.sortKey !== h ? this.createNewSegment(n, u, h) : v;
          }
          createNewSegment(t, n, u) {
            const h = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return u !== void 0 && (h.sortKey = u), this._forceNewSegmentOnNextPrepare = false, this.segments.push(h), h;
          }
          getOrCreateLatestSegment(t, n, u) {
            return this.prepareSegment(0, t, n, u);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, u, h) {
            return new xr([{ vertexOffset: t, primitiveOffset: n, vertexLength: u, primitiveLength: h, vaos: {}, sortKey: 0 }]);
          }
        }
        function Yi(o, t) {
          return 256 * (o = Lt(Math.floor(o), 0, 255)) + Lt(Math.floor(t), 0, 255);
        }
        xr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ot("SegmentVector", xr);
        const Bo = xi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), Va = xi([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var sa, Ua, ll, la = { exports: {} }, qa = { exports: {} }, Ln = { exports: {} }, ua = (function() {
          if (ll) return la.exports;
          ll = 1;
          var o = (sa || (sa = 1, qa.exports = function(n, u) {
            var h, v, b, w, S, I, E, L;
            for (v = n.length - (h = 3 & n.length), b = u, S = 3432918353, I = 461845907, L = 0; L < v; ) E = 255 & n.charCodeAt(L) | (255 & n.charCodeAt(++L)) << 8 | (255 & n.charCodeAt(++L)) << 16 | (255 & n.charCodeAt(++L)) << 24, ++L, b = 27492 + (65535 & (w = 5 * (65535 & (b = (b ^= E = (65535 & (E = (E = (65535 & E) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295) << 13 | b >>> 19)) + ((5 * (b >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (w >>> 16) & 65535) << 16);
            switch (E = 0, h) {
              case 3:
                E ^= (255 & n.charCodeAt(L + 2)) << 16;
              case 2:
                E ^= (255 & n.charCodeAt(L + 1)) << 8;
              case 1:
                b ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & n.charCodeAt(L))) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295;
            }
            return b ^= n.length, b = 2246822507 * (65535 & (b ^= b >>> 16)) + ((2246822507 * (b >>> 16) & 65535) << 16) & 4294967295, b = 3266489909 * (65535 & (b ^= b >>> 13)) + ((3266489909 * (b >>> 16) & 65535) << 16) & 4294967295, (b ^= b >>> 16) >>> 0;
          }), qa.exports), t = (Ua || (Ua = 1, Ln.exports = function(n, u) {
            for (var h, v = n.length, b = u ^ v, w = 0; v >= 4; ) h = 1540483477 * (65535 & (h = 255 & n.charCodeAt(w) | (255 & n.charCodeAt(++w)) << 8 | (255 & n.charCodeAt(++w)) << 16 | (255 & n.charCodeAt(++w)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), v -= 4, ++w;
            switch (v) {
              case 3:
                b ^= (255 & n.charCodeAt(w + 2)) << 16;
              case 2:
                b ^= (255 & n.charCodeAt(w + 1)) << 8;
              case 1:
                b = 1540483477 * (65535 & (b ^= 255 & n.charCodeAt(w))) + ((1540483477 * (b >>> 16) & 65535) << 16);
            }
            return b = 1540483477 * (65535 & (b ^= b >>> 13)) + ((1540483477 * (b >>> 16) & 65535) << 16), (b ^= b >>> 15) >>> 0;
          }), Ln.exports);
          return la.exports = o, la.exports.murmur3 = o, la.exports.murmur2 = t, la.exports;
        })(), Oo = P(ua);
        class ca {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t, n, u, h) {
            this.ids.push(Ei(t)), this.positions.push(n, u, h);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = Ei(t);
            let u = 0, h = this.ids.length - 1;
            for (; u < h; ) {
              const b = u + h >> 1;
              this.ids[b] >= n ? h = b : u = b + 1;
            }
            const v = [];
            for (; this.ids[u] === n; ) v.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
            return v;
          }
          static serialize(t, n) {
            const u = new Float64Array(t.ids), h = new Uint32Array(t.positions);
            return Ri(u, h, 0, u.length - 1), n && n.push(u.buffer, h.buffer), { ids: u, positions: h };
          }
          static deserialize(t) {
            const n = new ca();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = true, n;
          }
        }
        function Ei(o) {
          const t = +o;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Oo(String(o));
        }
        function Ri(o, t, n, u) {
          for (; n < u; ) {
            const h = o[n + u >> 1];
            let v = n - 1, b = u + 1;
            for (; ; ) {
              do
                v++;
              while (o[v] < h);
              do
                b--;
              while (o[b] > h);
              if (v >= b) break;
              _n(o, v, b), _n(t, 3 * v, 3 * b), _n(t, 3 * v + 1, 3 * b + 1), _n(t, 3 * v + 2, 3 * b + 2);
            }
            b - n < u - b ? (Ri(o, t, n, b), n = b + 1) : (Ri(o, t, b + 1, u), u = b);
          }
        }
        function _n(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        Ot("FeaturePositionMap", ca);
        class li {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class Su extends li {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Kh extends li {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class Jh extends li {
          constructor(t, n) {
            super(t, n), this.current = br.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Vp = new Float32Array(16);
        function ad(o) {
          return [Yi(255 * o.r, 255 * o.g), Yi(255 * o.b, 255 * o.a)];
        }
        class ul {
          constructor(t, n, u) {
            this.value = t, this.uniformNames = n.map(((h) => `u_${h}`)), this.type = u;
          }
          setUniform(t, n, u) {
            t.set(u.constantOr(this.value));
          }
          getBinding(t, n, u) {
            return this.type === "color" ? new Jh(t, n) : new Su(t, n);
          }
        }
        class Bn {
          constructor(t, n) {
            this.uniformNames = n.map(((u) => `u_${u}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setConstantDashPositions(t, n) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, n.y, n.height, n.width];
          }
          setUniform(t, n, u, h) {
            let v = null;
            h === "u_pattern_to" ? v = this.patternTo : h === "u_pattern_from" ? v = this.patternFrom : h === "u_dasharray_to" ? v = this.dashTo : h === "u_dasharray_from" ? v = this.dashFrom : h === "u_pixel_ratio_to" ? v = this.pixelRatioTo : h === "u_pixel_ratio_from" && (v = this.pixelRatioFrom), v !== null && t.set(v);
          }
          getBinding(t, n, u) {
            return u.substr(0, 9) === "u_pattern" || u.substr(0, 12) === "u_dasharray_" ? new Kh(t, n) : new Su(t, n);
          }
        }
        class To {
          constructor(t, n, u, h) {
            this.expression = t, this.type = u, this.maxValue = 0, this.paintVertexAttributes = n.map(((v) => ({ name: `a_${v}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new h();
          }
          populatePaintArray(t, n, u) {
            const h = this.paintVertexArray.length, v = this.expression.evaluate(new Gr(0, u), n, {}, u.canonical, [], u.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(h, t, v);
          }
          updatePaintArray(t, n, u, h, v) {
            const b = this.expression.evaluate(new Gr(0, v), u, h);
            this._setPaintValue(t, n, b);
          }
          _setPaintValue(t, n, u) {
            if (this.type === "color") {
              const h = ad(u);
              for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, h[0], h[1]);
            } else {
              for (let h = t; h < n; h++) this.paintVertexArray.emplace(h, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(u));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Hn {
          constructor(t, n, u, h, v, b) {
            this.expression = t, this.uniformNames = n.map(((w) => `u_${w}_t`)), this.type = u, this.useIntegerZoom = h, this.zoom = v, this.maxValue = 0, this.paintVertexAttributes = n.map(((w) => ({ name: `a_${w}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new b();
          }
          populatePaintArray(t, n, u) {
            const h = this.expression.evaluate(new Gr(this.zoom, u), n, {}, u.canonical, [], u.formattedSection), v = this.expression.evaluate(new Gr(this.zoom + 1, u), n, {}, u.canonical, [], u.formattedSection), b = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(b, t, h, v);
          }
          updatePaintArray(t, n, u, h, v) {
            const b = this.expression.evaluate(new Gr(this.zoom, v), u, h), w = this.expression.evaluate(new Gr(this.zoom + 1, v), u, h);
            this._setPaintValue(t, n, b, w);
          }
          _setPaintValue(t, n, u, h) {
            if (this.type === "color") {
              const v = ad(u), b = ad(h);
              for (let w = t; w < n; w++) this.paintVertexArray.emplace(w, v[0], v[1], b[0], b[1]);
            } else {
              for (let v = t; v < n; v++) this.paintVertexArray.emplace(v, u, h);
              this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(h));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const u = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, h = Lt(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
            t.set(h);
          }
          getBinding(t, n, u) {
            return new Su(t, n);
          }
        }
        class $o {
          constructor(t, n, u, h, v, b) {
            this.expression = t, this.type = n, this.useIntegerZoom = u, this.zoom = h, this.layerId = b, this.zoomInPaintVertexArray = new v(), this.zoomOutPaintVertexArray = new v();
          }
          populatePaintArray(t, n, u) {
            const h = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(h, t, this.getPositionIds(n), u);
          }
          updatePaintArray(t, n, u, h, v) {
            this._setPaintValues(t, n, this.getPositionIds(u), v);
          }
          _setPaintValues(t, n, u, h) {
            const v = this.getPositions(h);
            if (!v || !u) return;
            const b = v[u.min], w = v[u.mid], S = v[u.max];
            if (b && w && S) for (let I = t; I < n; I++) this.emplace(this.zoomInPaintVertexArray, I, w, b), this.emplace(this.zoomOutPaintVertexArray, I, w, S);
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const n = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, n, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, n, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class ku extends $o {
          getPositions(t) {
            return t.imagePositions;
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId];
          }
          getVertexAttributes() {
            return Bo.members;
          }
          emplace(t, n, u, h) {
            t.emplace(n, u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], h.tlbr[0], h.tlbr[1], h.tlbr[2], h.tlbr[3], u.pixelRatio, h.pixelRatio);
          }
        }
        class sd extends $o {
          getPositions(t) {
            return t.dashPositions;
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId];
          }
          getVertexAttributes() {
            return Va.members;
          }
          emplace(t, n, u, h) {
            t.emplace(n, 0, u.y, u.height, u.width, 0, h.y, h.height, h.width);
          }
        }
        class Pu {
          constructor(t, n, u) {
            this.binders = {}, this._buffers = [];
            const h = [];
            for (const v in t.paint._values) {
              if (!u(v)) continue;
              const b = t.paint.get(v);
              if (!(b instanceof Po && na(b.property.specification))) continue;
              const w = J1(v, t.type), S = b.value, I = b.property.specification.type, E = b.property.useIntegerZoom, L = b.property.specification["property-type"], N = L === "cross-faded" || L === "cross-faded-data-driven";
              if (S.kind === "constant") this.binders[v] = N ? new Bn(S.value, w) : new ul(S.value, w, I), h.push(`/u_${v}`);
              else if (S.kind === "source" || N) {
                const q = f0(v, I, "source");
                this.binders[v] = N ? v === "line-dasharray" ? new sd(S, I, E, n, q, t.id) : new ku(S, I, E, n, q, t.id) : new To(S, w, I, q), h.push(`/a_${v}`);
              } else {
                const q = f0(v, I, "composite");
                this.binders[v] = new Hn(S, w, I, E, n, q), h.push(`/z_${v}`);
              }
            }
            this.cacheKey = h.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof To || n instanceof Hn ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, u) {
            for (const h in this.binders) {
              const v = this.binders[h];
              (v instanceof To || v instanceof Hn || v instanceof $o) && v.populatePaintArray(t, n, u);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof Bn && h.setConstantPatternPositions(t, n);
            }
          }
          setConstantDashPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof Bn && h.setConstantDashPositions(t, n);
            }
          }
          updatePaintArrays(t, n, u, h, v) {
            let b = false;
            for (const w in t) {
              const S = n.getPositions(w);
              for (const I of S) {
                const E = u.feature(I.index);
                for (const L in this.binders) {
                  const N = this.binders[L];
                  if ((N instanceof To || N instanceof Hn || N instanceof $o) && N.expression.isStateDependent === true) {
                    const q = h.paint.get(L);
                    N.expression = q.value, N.updatePaintArray(I.start, I.end, E, t[w], v), b = true;
                  }
                }
              }
            }
            return b;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof ul || u instanceof Bn) && t.push(...u.uniformNames.map(((h) => `#define HAS_UNIFORM_${h}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof To || u instanceof Hn) for (let h = 0; h < u.paintVertexAttributes.length; h++) t.push(u.paintVertexAttributes[h].name);
              else if (u instanceof $o) {
                const h = u.getVertexAttributes();
                for (const v of h) t.push(v.name);
              }
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof ul || u instanceof Bn || u instanceof Hn) for (const h of u.uniformNames) t.push(h);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const u = [];
            for (const h in this.binders) {
              const v = this.binders[h];
              if (v instanceof ul || v instanceof Bn || v instanceof Hn) {
                for (const b of v.uniformNames) if (n[b]) {
                  const w = v.getBinding(t, n[b], b);
                  u.push({ name: b, property: h, binding: w });
                }
              }
            }
            return u;
          }
          setUniforms(t, n, u, h) {
            for (const { name: v, property: b, binding: w } of n) this.binders[b].setUniform(w, h, u.get(b), v);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (t && u instanceof $o) {
                const h = t.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
                h && this._buffers.push(h);
              } else (u instanceof To || u instanceof Hn) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof To || u instanceof Hn || u instanceof $o) && u.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof To || n instanceof Hn || n instanceof $o) && n.destroy();
            }
          }
        }
        class cl {
          constructor(t, n, u = () => true) {
            this.programConfigurations = {};
            for (const h of t) this.programConfigurations[h.id] = new Pu(h, n, u);
            this.needsUpload = false, this._featureMap = new ca(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, u, h) {
            for (const v in this.programConfigurations) this.programConfigurations[v].populatePaintArrays(t, n, h);
            n.id !== void 0 && this._featureMap.add(n.id, u, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = true;
          }
          updatePaintArrays(t, n, u, h) {
            for (const v of u) this.needsUpload = this.programConfigurations[v.id].updatePaintArrays(t, this._featureMap, n, v, h) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function J1(o, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[o] || [o.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function f0(o, t, n) {
          const u = { color: { source: Lo, composite: U }, number: { source: T, composite: Lo } }, h = (function(v) {
            return { "line-pattern": { source: Nt, composite: Nt }, "fill-pattern": { source: Nt, composite: Nt }, "fill-extrusion-pattern": { source: Nt, composite: Nt }, "line-dasharray": { source: yr, composite: yr } }[v];
          })(o);
          return h && h[n] || u[t][n];
        }
        Ot("ConstantBinder", ul), Ot("CrossFadedConstantBinder", Bn), Ot("SourceExpressionBinder", To), Ot("CrossFadedPatternBinder", ku), Ot("CrossFadedDasharrayBinder", sd), Ot("CompositeExpressionBinder", Hn), Ot("ProgramConfiguration", Pu, { omit: ["_buffers"] }), Ot("ProgramConfigurationSet", cl);
        const Up = Math.pow(2, 14) - 1, p0 = -Up - 1;
        function dl(o) {
          const t = et / o.extent, n = o.loadGeometry();
          for (let u = 0; u < n.length; u++) {
            const h = n[u];
            for (let v = 0; v < h.length; v++) {
              const b = h[v], w = Math.round(b.x * t), S = Math.round(b.y * t);
              b.x = Lt(w, p0, Up), b.y = Lt(S, p0, Up), (w < b.x || w > b.x + 1 || S < b.y || S > b.y + 1) && Ut("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function hl(o, t) {
          return { type: o.type, id: o.id, properties: o.properties, geometry: t ? dl(o) : [] };
        }
        const m0 = -32768;
        function Q1(o, t, n, u, h) {
          o.emplaceBack(m0 + 8 * t + u, m0 + 8 * n + h);
        }
        class qp {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.layoutVertexArray = new He(), this.indexArray = new Li(), this.segments = new xr(), this.programConfigurations = new cl(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            const h = this.layers[0], v = [];
            let b = null, w = false, S = h.type === "heatmap";
            if (h.type === "circle") {
              const E = h;
              b = E.layout.get("circle-sort-key"), w = !b.isConstant(), S = S || E.paint.get("circle-pitch-alignment") === "map";
            }
            const I = S ? n.subdivisionGranularity.circle : 1;
            for (const { feature: E, id: L, index: N, sourceLayerIndex: q } of t) {
              const G = this.layers[0]._featureFilter.needGeometry, K = hl(E, G);
              if (!this.layers[0]._featureFilter.filter(new Gr(this.zoom), K, u)) continue;
              const ae = w ? b.evaluate(K, {}, u) : void 0, me = { id: L, properties: E.properties, type: E.type, sourceLayerIndex: q, index: N, geometry: G ? K.geometry : dl(E), patterns: {}, sortKey: ae };
              v.push(me);
            }
            w && v.sort(((E, L) => E.sortKey - L.sortKey));
            for (const E of v) {
              const { geometry: L, index: N, sourceLayerIndex: q } = E, G = t[N].feature;
              this.addFeature(E, L, N, u, I), n.featureIndex.insert(G, L, N, q, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, mi), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, u, h, v = 1) {
            let b;
            switch (v) {
              case 1:
                b = [0, 7];
                break;
              case 3:
                b = [0, 2, 5, 7];
                break;
              case 5:
                b = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                b = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${v}; valid values are 1, 3, 5, 7.`);
            }
            const w = b.length;
            for (const S of n) for (const I of S) {
              const E = I.x, L = I.y;
              if (E < 0 || E >= et || L < 0 || L >= et) continue;
              const N = this.segments.prepareSegment(w * w, this.layoutVertexArray, this.indexArray, t.sortKey), q = N.vertexLength;
              for (let G = 0; G < w; G++) for (let K = 0; K < w; K++) Q1(this.layoutVertexArray, E, L, b[K], b[G]);
              for (let G = 0; G < w - 1; G++) for (let K = 0; K < w - 1; K++) {
                const ae = q + G * w + K, me = q + (G + 1) * w + K;
                this.indexArray.emplaceBack(ae, me + 1, ae + 1), this.indexArray.emplaceBack(ae, me, me + 1);
              }
              N.vertexLength += w * w, N.primitiveLength += (w - 1) * (w - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: {}, canonical: h });
          }
        }
        function g0(o, t) {
          for (let n = 0; n < o.length; n++) if (Tu(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (Tu(o, t[n])) return true;
          return !!Gp(o, t);
        }
        function Qh(o, t, n) {
          return !!Tu(o, t) || !!Wp(t, o, n);
        }
        function v0(o, t) {
          if (o.length === 1) return _0(t, o[0]);
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            for (let h = 0; h < u.length; h++) if (Tu(o, u[h])) return true;
          }
          for (let n = 0; n < o.length; n++) if (_0(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (Gp(o, t[n])) return true;
          return false;
        }
        function ex(o, t, n) {
          if (o.length > 1) {
            if (Gp(o, t)) return true;
            for (let u = 0; u < t.length; u++) if (Wp(t[u], o, n)) return true;
          }
          for (let u = 0; u < o.length; u++) if (Wp(o[u], t, n)) return true;
          return false;
        }
        function Gp(o, t) {
          if (o.length === 0 || t.length === 0) return false;
          for (let n = 0; n < o.length - 1; n++) {
            const u = o[n], h = o[n + 1];
            for (let v = 0; v < t.length - 1; v++) if (tx(u, h, t[v], t[v + 1])) return true;
          }
          return false;
        }
        function tx(o, t, n, u) {
          return Ar(o, n, u) !== Ar(t, n, u) && Ar(o, t, n) !== Ar(o, t, u);
        }
        function Wp(o, t, n) {
          const u = n * n;
          if (t.length === 1) return o.distSqr(t[0]) < u;
          for (let h = 1; h < t.length; h++) if (y0(o, t[h - 1], t[h]) < u) return true;
          return false;
        }
        function y0(o, t, n) {
          const u = t.distSqr(n);
          if (u === 0) return o.distSqr(t);
          const h = ((o.x - t.x) * (n.x - t.x) + (o.y - t.y) * (n.y - t.y)) / u;
          return o.distSqr(h < 0 ? t : h > 1 ? n : n.sub(t)._mult(h)._add(t));
        }
        function _0(o, t) {
          let n, u, h, v = false;
          for (let b = 0; b < o.length; b++) {
            n = o[b];
            for (let w = 0, S = n.length - 1; w < n.length; S = w++) u = n[w], h = n[S], u.y > t.y != h.y > t.y && t.x < (h.x - u.x) * (t.y - u.y) / (h.y - u.y) + u.x && (v = !v);
          }
          return v;
        }
        function Tu(o, t) {
          let n = false;
          for (let u = 0, h = o.length - 1; u < o.length; h = u++) {
            const v = o[u], b = o[h];
            v.y > t.y != b.y > t.y && t.x < (b.x - v.x) * (t.y - v.y) / (b.y - v.y) + v.x && (n = !n);
          }
          return n;
        }
        function rx(o, t, n) {
          const u = n[0], h = n[2];
          if (o.x < u.x && t.x < u.x || o.x > h.x && t.x > h.x || o.y < u.y && t.y < u.y || o.y > h.y && t.y > h.y) return false;
          const v = Ar(o, t, n[0]);
          return v !== Ar(o, t, n[1]) || v !== Ar(o, t, n[2]) || v !== Ar(o, t, n[3]);
        }
        function Iu(o, t, n) {
          const u = t.paint.get(o).value;
          return u.kind === "constant" ? u.value : n.programConfigurations.get(t.id).getMaxValue(o);
        }
        function ef(o) {
          return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
        }
        function tf(o, t, n, u, h) {
          if (!t[0] && !t[1]) return o;
          const v = C.convert(t)._mult(h);
          n === "viewport" && v._rotate(-u);
          const b = [];
          for (let w = 0; w < o.length; w++) b.push(o[w].sub(v));
          return b;
        }
        function ix({ queryGeometry: o, size: t }, n) {
          return Qh(o, n, t);
        }
        function nx({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, v) {
          return Qh(o, v, t * (n.projectTileCoordinates(v.x, v.y, u, h).signedDistanceFromCamera / n.cameraToCenterDistance));
        }
        function ox({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, v) {
          const b = n.projectTileCoordinates(v.x, v.y, u, h).signedDistanceFromCamera, w = t * (n.cameraToCenterDistance / b);
          return Qh(o, Zp(v, n, u, h), w);
        }
        function ax({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, v) {
          return Qh(o, Zp(v, n, u, h), t);
        }
        function b0({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h, pitchAlignment: v = "map", pitchScale: b = "map" }, w) {
          const S = v === "map" ? b === "map" ? ix : nx : b === "map" ? ox : ax, I = { queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h };
          for (const E of w) for (const L of E) if (S(I, L)) return true;
          return false;
        }
        function Zp(o, t, n, u) {
          const h = t.projectTileCoordinates(o.x, o.y, n, u).point;
          return new C((0.5 * h.x + 0.5) * t.width, (0.5 * -h.y + 0.5) * t.height);
        }
        let x0, w0;
        Ot("CircleBucket", qp, { omit: ["layers"] });
        var sx = { get paint() {
          return w0 = w0 || new sn({ "circle-radius": new er(Te.paint_circle["circle-radius"]), "circle-color": new er(Te.paint_circle["circle-color"]), "circle-blur": new er(Te.paint_circle["circle-blur"]), "circle-opacity": new er(Te.paint_circle["circle-opacity"]), "circle-translate": new Wt(Te.paint_circle["circle-translate"]), "circle-translate-anchor": new Wt(Te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Wt(Te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Wt(Te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new er(Te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new er(Te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new er(Te.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return x0 = x0 || new sn({ "circle-sort-key": new er(Te.layout_circle["circle-sort-key"]) });
        } };
        class lx extends so {
          constructor(t, n) {
            super(t, sx, n);
          }
          createBucket(t) {
            return new qp(t);
          }
          queryRadius(t) {
            const n = t;
            return Iu("circle-radius", this, n) + Iu("circle-stroke-width", this, n) + ef(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: v, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            const I = tf(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -v.bearingInRadians, b), E = this.paint.get("circle-radius").evaluate(n, u) + this.paint.get("circle-stroke-width").evaluate(n, u), L = this.paint.get("circle-pitch-scale"), N = this.paint.get("circle-pitch-alignment");
            let q, G;
            return N === "map" ? (q = I, G = E * b) : (q = (function(K, ae, me, Oe) {
              return K.map(((Ce) => Zp(Ce, ae, me, Oe)));
            })(I, v, w, S), G = E), b0({ queryGeometry: q, size: G, transform: v, unwrappedTileID: w, getElevation: S, pitchAlignment: N, pitchScale: L }, h);
          }
        }
        class C0 extends qp {
        }
        let S0;
        Ot("HeatmapBucket", C0, { omit: ["layers"] });
        var ux = { get paint() {
          return S0 = S0 || new sn({ "heatmap-radius": new er(Te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new er(Te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Wt(Te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new bu(Te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Wt(Te.paint_heatmap["heatmap-opacity"]) });
        } };
        function Hp(o, { width: t, height: n }, u, h) {
          if (h) {
            if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
            else if (h.length !== t * n * u) throw new RangeError(`mismatched image size. expected: ${h.length} but got: ${t * n * u}`);
          } else h = new Uint8Array(t * n * u);
          return o.width = t, o.height = n, o.data = h, o;
        }
        function k0(o, { width: t, height: n }, u) {
          if (t === o.width && n === o.height) return;
          const h = Hp({}, { width: t, height: n }, u);
          Xp(o, h, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(o.width, t), height: Math.min(o.height, n) }, u), o.width = t, o.height = n, o.data = h.data;
        }
        function Xp(o, t, n, u, h, v) {
          if (h.width === 0 || h.height === 0) return t;
          if (h.width > o.width || h.height > o.height || n.x > o.width - h.width || n.y > o.height - h.height) throw new RangeError("out of range source coordinates for image copy");
          if (h.width > t.width || h.height > t.height || u.x > t.width - h.width || u.y > t.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
          const b = o.data, w = t.data;
          if (b === w) throw new Error("srcData equals dstData, so image is already copied");
          for (let S = 0; S < h.height; S++) {
            const I = ((n.y + S) * o.width + n.x) * v, E = ((u.y + S) * t.width + u.x) * v;
            for (let L = 0; L < h.width * v; L++) w[E + L] = b[I + L];
          }
          return t;
        }
        class ld {
          constructor(t, n) {
            Hp(this, t, 1, n);
          }
          resize(t) {
            k0(this, t, 1);
          }
          clone() {
            return new ld({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, v) {
            Xp(t, n, u, h, v, 1);
          }
        }
        class On {
          constructor(t, n) {
            Hp(this, t, 4, n);
          }
          resize(t) {
            k0(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new On({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, v) {
            Xp(t, n, u, h, v, 4);
          }
          setPixel(t, n, u) {
            const h = 4 * (t * this.width + n);
            this.data[h + 0] = Math.round(255 * u.r / u.a), this.data[h + 1] = Math.round(255 * u.g / u.a), this.data[h + 2] = Math.round(255 * u.b / u.a), this.data[h + 3] = Math.round(255 * u.a);
          }
        }
        function P0(o) {
          const t = {}, n = o.resolution || 256, u = o.clips ? o.clips.length : 1, h = o.image || new On({ width: n, height: u });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const v = (b, w, S) => {
            t[o.evaluationKey] = S;
            const I = o.expression.evaluate(t);
            h.setPixel(b / 4 / n, w / 4, I);
          };
          if (o.clips) for (let b = 0, w = 0; b < u; ++b, w += 4 * n) for (let S = 0, I = 0; S < n; S++, I += 4) {
            const E = S / (n - 1), { start: L, end: N } = o.clips[b];
            v(w, I, L * (1 - E) + N * E);
          }
          else for (let b = 0, w = 0; b < n; b++, w += 4) v(0, w, b / (n - 1));
          return h;
        }
        Ot("AlphaImage", ld), Ot("RGBAImage", On);
        const Yp = "big-fb";
        class cx extends so {
          createBucket(t) {
            return new C0(t);
          }
          constructor(t, n) {
            super(t, ux, n), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = P0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(Yp) && this.heatmapFbos.delete(Yp);
          }
          queryRadius(t) {
            return Iu("heatmap-radius", this, t);
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: v, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            return b0({ queryGeometry: t, size: this.paint.get("heatmap-radius").evaluate(n, u) * b, transform: v, unwrappedTileID: w, getElevation: S }, h);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let T0;
        var dx = { get paint() {
          return T0 = T0 || new sn({ "hillshade-illumination-direction": new Wt(Te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Wt(Te.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Wt(Te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Wt(Te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Wt(Te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Wt(Te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Wt(Te.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Wt(Te.paint_hillshade["hillshade-method"]) });
        } };
        class hx extends so {
          constructor(t, n) {
            super(t, dx, n), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, n = this.paint.get("hillshade-illumination-altitude").values, u = this.paint.get("hillshade-highlight-color").values, h = this.paint.get("hillshade-shadow-color").values;
            const v = Math.max(t.length, n.length, u.length, h.length);
            t = t.concat(Array(v - t.length).fill(t.at(-1))), n = n.concat(Array(v - n.length).fill(n.at(-1))), u = u.concat(Array(v - u.length).fill(u.at(-1))), h = h.concat(Array(v - h.length).fill(h.at(-1)));
            const b = n.map(tt);
            return { directionRadians: t.map(tt), altitudeRadians: b, shadowColor: h, highlightColor: u };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let I0;
        var fx = { get paint() {
          return I0 = I0 || new sn({ "color-relief-opacity": new Wt(Te["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new bu(Te["paint_color-relief"]["color-relief-color"]) });
        } };
        class Kp {
          constructor(t, n, u, h) {
            this.context = t, this.format = u, this.texture = t.gl.createTexture(), this.update(n, h);
          }
          update(t, n, u) {
            const { width: h, height: v } = t, b = !(this.size && this.size[0] === h && this.size[1] === v || u), { context: w } = this, { gl: S } = w;
            if (this.useMipmap = !!(n && n.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), w.pixelStoreUnpackFlipY.set(false), w.pixelStoreUnpack.set(1), w.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!n || n.premultiply !== false)), b) this.size = [h, v], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, t) : S.texImage2D(S.TEXTURE_2D, 0, this.format, h, v, 0, this.format, S.UNSIGNED_BYTE, t.data);
            else {
              const { x: I, y: E } = u || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texSubImage2D(S.TEXTURE_2D, 0, I, E, S.RGBA, S.UNSIGNED_BYTE, t) : S.texSubImage2D(S.TEXTURE_2D, 0, I, E, h, v, S.RGBA, S.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D), w.pixelStoreUnpackFlipY.setDefault(), w.pixelStoreUnpack.setDefault(), w.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, n, u) {
            const { context: h } = this, { gl: v } = h;
            v.bindTexture(v.TEXTURE_2D, this.texture), u !== v.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = v.LINEAR), t !== this.filter && (v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, t), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, u || t), this.filter = t), n !== this.wrap && (v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, n), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, n), this.wrap = n);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class M0 {
          constructor(t, n, u, h = 1, v = 1, b = 1, w = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void Ut(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const S = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), u) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = h, this.greenFactor = v, this.blueFactor = b, this.baseShift = w;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let I = 0; I < S; I++) this.data[this._idx(-1, I)] = this.data[this._idx(0, I)], this.data[this._idx(S, I)] = this.data[this._idx(S - 1, I)], this.data[this._idx(I, -1)] = this.data[this._idx(I, 0)], this.data[this._idx(I, S)] = this.data[this._idx(I, S - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(S, -1)] = this.data[this._idx(S - 1, 0)], this.data[this._idx(-1, S)] = this.data[this._idx(0, S - 1)], this.data[this._idx(S, S)] = this.data[this._idx(S - 1, S - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let I = 0; I < S; I++) for (let E = 0; E < S; E++) {
              const L = this.get(I, E);
              L > this.max && (this.max = L), L < this.min && (this.min = L);
            }
          }
          get(t, n) {
            const u = new Uint8Array(this.data.buffer), h = 4 * this._idx(t, n);
            return this.unpack(u[h], u[h + 1], u[h + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, u) {
            return t * this.redFactor + n * this.greenFactor + u * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return E0(t, this.getUnpackVector());
          }
          getPixels() {
            return new On({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, u) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let h = n * this.dim, v = n * this.dim + this.dim, b = u * this.dim, w = u * this.dim + this.dim;
            switch (n) {
              case -1:
                h = v - 1;
                break;
              case 1:
                v = h + 1;
            }
            switch (u) {
              case -1:
                b = w - 1;
                break;
              case 1:
                w = b + 1;
            }
            const S = -n * this.dim, I = -u * this.dim;
            for (let E = b; E < w; E++) for (let L = h; L < v; L++) this.data[this._idx(L, E)] = t.data[this._idx(L + S, E + I)];
          }
        }
        function E0(o, t) {
          const n = t[0], u = t[1], h = t[2], v = t[3], b = Math.min(n, u, h), w = Math.round((o + v) / b);
          return { r: Math.floor(w * b / n) % 256, g: Math.floor(w * b / u) % 256, b: Math.floor(w * b / h) % 256 };
        }
        Ot("DEMData", M0);
        class px extends so {
          constructor(t, n) {
            super(t, fx, n);
          }
          _createColorRamp(t) {
            const n = { elevationStops: [], colorStops: [] }, u = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (u instanceof Js && u._styleExpression.expression instanceof Xi) {
              this.colorRampExpression = u;
              const b = u._styleExpression.expression;
              n.elevationStops = b.labels, n.colorStops = [];
              for (const w of n.elevationStops) n.colorStops.push(b.evaluate({ globals: { elevation: w } }));
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [br.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const h = { elevationStops: [], colorStops: [] }, v = (n.elevationStops.length - 1) / (t - 1);
            for (let b = 0; b < n.elevationStops.length - 0.5; b += v) h.elevationStops.push(n.elevationStops[Math.round(b)]), h.colorStops.push(n.colorStops[Math.round(b)]);
            return Ut(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), h;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, n, u) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const h = this._createColorRamp(n), v = new On({ width: h.colorStops.length, height: 1 }), b = new On({ width: h.colorStops.length, height: 1 });
            for (let w = 0; w < h.elevationStops.length; w++) {
              const S = E0(h.elevationStops[w], u);
              b.setPixel(0, w, new br(S.r / 255, S.g / 255, S.b / 255, 1)), v.setPixel(0, w, h.colorStops[w]);
            }
            return this.colorRampTextures = { elevationTexture: new Kp(t, b, t.gl.RGBA), colorTexture: new Kp(t, v, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const mx = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: gx } = mx;
        function rf(o, t, n) {
          const u = n.patternDependencies;
          let h = false;
          for (const v of t) {
            const b = v.paint.get(`${o}-pattern`);
            b.isConstant() || (h = true);
            const w = b.constantOr(null);
            w && (h = true, u[w.to] = true, u[w.from] = true);
          }
          return h;
        }
        function Jp(o, t, n, u, h) {
          const { zoom: v } = u, b = h.patternDependencies;
          for (const w of t) {
            const S = w.paint.get(`${o}-pattern`).value;
            if (S.kind !== "constant") {
              let I = S.evaluate({ zoom: v - 1 }, n, {}, h.availableImages), E = S.evaluate({ zoom: v }, n, {}, h.availableImages), L = S.evaluate({ zoom: v + 1 }, n, {}, h.availableImages);
              I = I && I.name ? I.name : I, E = E && E.name ? E.name : E, L = L && L.name ? L.name : L, b[I] = true, b[E] = true, b[L] = true, n.patterns[w.id] = { min: I, mid: E, max: L };
            }
          }
          return n;
        }
        function R0(o, t, n, u, h) {
          let v;
          if (h === (function(b, w, S, I) {
            let E = 0;
            for (let L = w, N = S - I; L < S; L += I) E += (b[N] - b[L]) * (b[L + 1] + b[N + 1]), N = L;
            return E;
          })(o, t, n, u) > 0) for (let b = t; b < n; b += u) v = F0(b / u | 0, o[b], o[b + 1], v);
          else for (let b = n - u; b >= t; b -= u) v = F0(b / u | 0, o[b], o[b + 1], v);
          return v && Mu(v, v.next) && (hd(v), v = v.next), v;
        }
        function fl(o, t) {
          if (!o) return o;
          t || (t = o);
          let n, u = o;
          do
            if (n = false, u.steiner || !Mu(u, u.next) && Pi(u.prev, u, u.next) !== 0) u = u.next;
            else {
              if (hd(u), u = t = u.prev, u === u.next) break;
              n = true;
            }
          while (n || u !== t);
          return t;
        }
        function ud(o, t, n, u, h, v, b) {
          if (!o) return;
          !b && v && (function(S, I, E, L) {
            let N = S;
            do
              N.z === 0 && (N.z = Qp(N.x, N.y, I, E, L)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next;
            while (N !== S);
            N.prevZ.nextZ = null, N.prevZ = null, (function(q) {
              let G, K = 1;
              do {
                let ae, me = q;
                q = null;
                let Oe = null;
                for (G = 0; me; ) {
                  G++;
                  let Ce = me, Ie = 0;
                  for (let rt = 0; rt < K && (Ie++, Ce = Ce.nextZ, Ce); rt++) ;
                  let Ze = K;
                  for (; Ie > 0 || Ze > 0 && Ce; ) Ie !== 0 && (Ze === 0 || !Ce || me.z <= Ce.z) ? (ae = me, me = me.nextZ, Ie--) : (ae = Ce, Ce = Ce.nextZ, Ze--), Oe ? Oe.nextZ = ae : q = ae, ae.prevZ = Oe, Oe = ae;
                  me = Ce;
                }
                Oe.nextZ = null, K *= 2;
              } while (G > 1);
            })(N);
          })(o, u, h, v);
          let w = o;
          for (; o.prev !== o.next; ) {
            const S = o.prev, I = o.next;
            if (v ? yx(o, u, h, v) : vx(o)) t.push(S.i, o.i, I.i), hd(o), o = I.next, w = I.next;
            else if ((o = I) === w) {
              b ? b === 1 ? ud(o = _x(fl(o), t), t, n, u, h, v, 2) : b === 2 && bx(o, t, n, u, h, v) : ud(fl(o), t, n, u, h, v, 1);
              break;
            }
          }
        }
        function vx(o) {
          const t = o.prev, n = o, u = o.next;
          if (Pi(t, n, u) >= 0) return false;
          const h = t.x, v = n.x, b = u.x, w = t.y, S = n.y, I = u.y, E = Math.min(h, v, b), L = Math.min(w, S, I), N = Math.max(h, v, b), q = Math.max(w, S, I);
          let G = u.next;
          for (; G !== t; ) {
            if (G.x >= E && G.x <= N && G.y >= L && G.y <= q && cd(h, w, v, S, b, I, G.x, G.y) && Pi(G.prev, G, G.next) >= 0) return false;
            G = G.next;
          }
          return true;
        }
        function yx(o, t, n, u) {
          const h = o.prev, v = o, b = o.next;
          if (Pi(h, v, b) >= 0) return false;
          const w = h.x, S = v.x, I = b.x, E = h.y, L = v.y, N = b.y, q = Math.min(w, S, I), G = Math.min(E, L, N), K = Math.max(w, S, I), ae = Math.max(E, L, N), me = Qp(q, G, t, n, u), Oe = Qp(K, ae, t, n, u);
          let Ce = o.prevZ, Ie = o.nextZ;
          for (; Ce && Ce.z >= me && Ie && Ie.z <= Oe; ) {
            if (Ce.x >= q && Ce.x <= K && Ce.y >= G && Ce.y <= ae && Ce !== h && Ce !== b && cd(w, E, S, L, I, N, Ce.x, Ce.y) && Pi(Ce.prev, Ce, Ce.next) >= 0 || (Ce = Ce.prevZ, Ie.x >= q && Ie.x <= K && Ie.y >= G && Ie.y <= ae && Ie !== h && Ie !== b && cd(w, E, S, L, I, N, Ie.x, Ie.y) && Pi(Ie.prev, Ie, Ie.next) >= 0)) return false;
            Ie = Ie.nextZ;
          }
          for (; Ce && Ce.z >= me; ) {
            if (Ce.x >= q && Ce.x <= K && Ce.y >= G && Ce.y <= ae && Ce !== h && Ce !== b && cd(w, E, S, L, I, N, Ce.x, Ce.y) && Pi(Ce.prev, Ce, Ce.next) >= 0) return false;
            Ce = Ce.prevZ;
          }
          for (; Ie && Ie.z <= Oe; ) {
            if (Ie.x >= q && Ie.x <= K && Ie.y >= G && Ie.y <= ae && Ie !== h && Ie !== b && cd(w, E, S, L, I, N, Ie.x, Ie.y) && Pi(Ie.prev, Ie, Ie.next) >= 0) return false;
            Ie = Ie.nextZ;
          }
          return true;
        }
        function _x(o, t) {
          let n = o;
          do {
            const u = n.prev, h = n.next.next;
            !Mu(u, h) && D0(u, n, n.next, h) && dd(u, h) && dd(h, u) && (t.push(u.i, n.i, h.i), hd(n), hd(n.next), n = o = h), n = n.next;
          } while (n !== o);
          return fl(n);
        }
        function bx(o, t, n, u, h, v) {
          let b = o;
          do {
            let w = b.next.next;
            for (; w !== b.prev; ) {
              if (b.i !== w.i && kx(b, w)) {
                let S = z0(b, w);
                return b = fl(b, b.next), S = fl(S, S.next), ud(b, t, n, u, h, v, 0), void ud(S, t, n, u, h, v, 0);
              }
              w = w.next;
            }
            b = b.next;
          } while (b !== o);
        }
        function xx(o, t) {
          let n = o.x - t.x;
          return n === 0 && (n = o.y - t.y, n === 0) && (n = (o.next.y - o.y) / (o.next.x - o.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function wx(o, t) {
          const n = (function(h, v) {
            let b = v;
            const w = h.x, S = h.y;
            let I, E = -1 / 0;
            if (Mu(h, b)) return b;
            do {
              if (Mu(h, b.next)) return b.next;
              if (S <= b.y && S >= b.next.y && b.next.y !== b.y) {
                const K = b.x + (S - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
                if (K <= w && K > E && (E = K, I = b.x < b.next.x ? b : b.next, K === w)) return I;
              }
              b = b.next;
            } while (b !== v);
            if (!I) return null;
            const L = I, N = I.x, q = I.y;
            let G = 1 / 0;
            b = I;
            do {
              if (w >= b.x && b.x >= N && w !== b.x && A0(S < q ? w : E, S, N, q, S < q ? E : w, S, b.x, b.y)) {
                const K = Math.abs(S - b.y) / (w - b.x);
                dd(b, h) && (K < G || K === G && (b.x > I.x || b.x === I.x && Cx(I, b))) && (I = b, G = K);
              }
              b = b.next;
            } while (b !== L);
            return I;
          })(o, t);
          if (!n) return t;
          const u = z0(n, o);
          return fl(u, u.next), fl(n, n.next);
        }
        function Cx(o, t) {
          return Pi(o.prev, o, t.prev) < 0 && Pi(t.next, o, o.next) < 0;
        }
        function Qp(o, t, n, u, h) {
          return (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - n) * h | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - u) * h | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function Sx(o) {
          let t = o, n = o;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== o);
          return n;
        }
        function A0(o, t, n, u, h, v, b, w) {
          return (h - b) * (t - w) >= (o - b) * (v - w) && (o - b) * (u - w) >= (n - b) * (t - w) && (n - b) * (v - w) >= (h - b) * (u - w);
        }
        function cd(o, t, n, u, h, v, b, w) {
          return !(o === b && t === w) && A0(o, t, n, u, h, v, b, w);
        }
        function kx(o, t) {
          return o.next.i !== t.i && o.prev.i !== t.i && !(function(n, u) {
            let h = n;
            do {
              if (h.i !== n.i && h.next.i !== n.i && h.i !== u.i && h.next.i !== u.i && D0(h, h.next, n, u)) return true;
              h = h.next;
            } while (h !== n);
            return false;
          })(o, t) && (dd(o, t) && dd(t, o) && (function(n, u) {
            let h = n, v = false;
            const b = (n.x + u.x) / 2, w = (n.y + u.y) / 2;
            do
              h.y > w != h.next.y > w && h.next.y !== h.y && b < (h.next.x - h.x) * (w - h.y) / (h.next.y - h.y) + h.x && (v = !v), h = h.next;
            while (h !== n);
            return v;
          })(o, t) && (Pi(o.prev, o, t.prev) || Pi(o, t.prev, t)) || Mu(o, t) && Pi(o.prev, o, o.next) > 0 && Pi(t.prev, t, t.next) > 0);
        }
        function Pi(o, t, n) {
          return (t.y - o.y) * (n.x - t.x) - (t.x - o.x) * (n.y - t.y);
        }
        function Mu(o, t) {
          return o.x === t.x && o.y === t.y;
        }
        function D0(o, t, n, u) {
          const h = of(Pi(o, t, n)), v = of(Pi(o, t, u)), b = of(Pi(n, u, o)), w = of(Pi(n, u, t));
          return h !== v && b !== w || !(h !== 0 || !nf(o, n, t)) || !(v !== 0 || !nf(o, u, t)) || !(b !== 0 || !nf(n, o, u)) || !(w !== 0 || !nf(n, t, u));
        }
        function nf(o, t, n) {
          return t.x <= Math.max(o.x, n.x) && t.x >= Math.min(o.x, n.x) && t.y <= Math.max(o.y, n.y) && t.y >= Math.min(o.y, n.y);
        }
        function of(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        }
        function dd(o, t) {
          return Pi(o.prev, o, o.next) < 0 ? Pi(o, t, o.next) >= 0 && Pi(o, o.prev, t) >= 0 : Pi(o, t, o.prev) < 0 || Pi(o, o.next, t) < 0;
        }
        function z0(o, t) {
          const n = em(o.i, o.x, o.y), u = em(t.i, t.x, t.y), h = o.next, v = t.prev;
          return o.next = t, t.prev = o, n.next = h, h.prev = n, u.next = n, n.prev = u, v.next = u, u.prev = v, u;
        }
        function F0(o, t, n, u) {
          const h = em(o, t, n);
          return u ? (h.next = u.next, h.prev = u, u.next.prev = h, u.next = h) : (h.prev = h, h.next = h), h;
        }
        function hd(o) {
          o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
        }
        function em(o, t, n) {
          return { i: o, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class Eu {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class af {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        af.noSubdivision = new af({ fill: new Eu(0, 0), line: new Eu(0, 0), tile: new Eu(0, 0), stencil: new Eu(0, 0), circle: 1 }), Ot("SubdivisionGranularityExpression", Eu), Ot("SubdivisionGranularitySetting", af);
        const Ru = -32768, fd = 32767;
        class Px {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t, this._granularityCellSize = et / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const u = 0 | Math.round(t), h = 0 | Math.round(n), v = this._getKey(u, h);
            if (this._vertexDictionary.has(v)) return this._vertexDictionary.get(v);
            const b = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(v, b), this._vertexBuffer.push(u, h), b;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(h, v) {
              const b = [];
              for (let w = 0; w < v.length; w += 3) {
                const S = v[w], I = v[w + 1], E = v[w + 2], L = h[2 * S], N = h[2 * S + 1];
                (h[2 * I] - L) * (h[2 * E + 1] - N) - (h[2 * I + 1] - N) * (h[2 * E] - L) > 0 ? (b.push(S), b.push(E), b.push(I)) : (b.push(S), b.push(I), b.push(E));
              }
              return b;
            })(this._vertexBuffer, t);
            const n = [], u = t.length;
            for (let h = 0; h < u; h += 3) {
              const v = [t[h + 0], t[h + 1], t[h + 2]], b = [this._vertexBuffer[2 * t[h + 0] + 0], this._vertexBuffer[2 * t[h + 0] + 1], this._vertexBuffer[2 * t[h + 1] + 0], this._vertexBuffer[2 * t[h + 1] + 1], this._vertexBuffer[2 * t[h + 2] + 0], this._vertexBuffer[2 * t[h + 2] + 1]];
              let w = 1 / 0, S = 1 / 0, I = -1 / 0, E = -1 / 0;
              for (let K = 0; K < 3; K++) {
                const ae = b[2 * K], me = b[2 * K + 1];
                w = Math.min(w, ae), I = Math.max(I, ae), S = Math.min(S, me), E = Math.max(E, me);
              }
              if (w === I || S === E) continue;
              const L = Math.floor(w / this._granularityCellSize), N = Math.ceil(I / this._granularityCellSize), q = Math.floor(S / this._granularityCellSize), G = Math.ceil(E / this._granularityCellSize);
              if (L !== N || q !== G) for (let K = q; K < G; K++) {
                const ae = this._scanlineGenerateVertexRingForCellRow(K, b, v);
                Tx(this._vertexBuffer, ae, n);
              }
              else n.push(...v);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, u) {
            const h = t * this._granularityCellSize, v = h + this._granularityCellSize, b = [];
            for (let w = 0; w < 3; w++) {
              const S = n[2 * w], I = n[2 * w + 1], E = n[2 * (w + 1) % 6], L = n[(2 * (w + 1) + 1) % 6], N = n[2 * (w + 2) % 6], q = n[(2 * (w + 2) + 1) % 6], G = E - S, K = L - I, ae = G === 0, me = K === 0, Oe = (h - I) / K, Ce = (v - I) / K, Ie = Math.min(Oe, Ce), Ze = Math.max(Oe, Ce);
              if (!me && (Ie >= 1 || Ze <= 0) || me && (I < h || I > v)) {
                L >= h && L <= v && b.push(u[(w + 1) % 3]);
                continue;
              }
              !me && Ie > 0 && b.push(this._vertexToIndex(S + G * Ie, I + K * Ie));
              const rt = S + G * Math.max(Ie, 0), vt = S + G * Math.min(Ze, 1);
              ae || this._generateIntraEdgeVertices(b, S, I, E, L, rt, vt), !me && Ze < 1 && b.push(this._vertexToIndex(S + G * Ze, I + K * Ze)), (me || L >= h && L <= v) && b.push(u[(w + 1) % 3]), !me && (L <= h || L >= v) && this._generateInterEdgeVertices(b, S, I, E, L, N, q, vt, h, v);
            }
            return b;
          }
          _generateIntraEdgeVertices(t, n, u, h, v, b, w) {
            const S = h - n, I = v - u, E = I === 0, L = E ? Math.min(n, h) : Math.min(b, w), N = E ? Math.max(n, h) : Math.max(b, w), q = Math.floor(L / this._granularityCellSize) + 1, G = Math.ceil(N / this._granularityCellSize) - 1;
            if (E ? n < h : b < w) for (let K = q; K <= G; K++) {
              const ae = K * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
            else for (let K = G; K >= q; K--) {
              const ae = K * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
          }
          _generateInterEdgeVertices(t, n, u, h, v, b, w, S, I, E) {
            const L = v - u, N = b - h, q = w - v, G = (I - v) / q, K = (E - v) / q, ae = Math.min(G, K), me = Math.max(G, K), Oe = h + N * ae;
            let Ce = Math.floor(Math.min(Oe, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(Oe, S) / this._granularityCellSize) - 1, Ze = S < Oe;
            const rt = q === 0;
            if (rt && (w === I || w === E)) return;
            if (rt || ae >= 1 || me <= 0) {
              const Dt = u - w, Tt = b + (n - b) * Math.min((I - w) / Dt, (E - w) / Dt);
              Ce = Math.floor(Math.min(Tt, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(Tt, S) / this._granularityCellSize) - 1, Ze = S < Tt;
            }
            const vt = L > 0 ? E : I;
            if (Ze) for (let Dt = Ce; Dt <= Ie; Dt++) t.push(this._vertexToIndex(Dt * this._granularityCellSize, vt));
            else for (let Dt = Ie; Dt >= Ce; Dt--) t.push(this._vertexToIndex(Dt * this._granularityCellSize, vt));
          }
          _generateOutline(t) {
            const n = [];
            for (const u of t) {
              const h = pl(u, this._granularity, true), v = this._pointArrayToIndices(h), b = [];
              for (let w = 1; w < v.length; w++) b.push(v[w - 1]), b.push(v[w]);
              n.push(b);
            }
            return n;
          }
          _handlePoles(t) {
            let n = false, u = false;
            this._canonical && (this._canonical.y === 0 && (n = true), this._canonical.y === (1 << this._canonical.z) - 1 && (u = true)), (n || u) && this._fillPoles(t, n, u);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const u = t[n + 1];
              u === Ru && (t[n + 1] = -32767), u === fd && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, u, h, v, b) {
            h > v != (b === Ru) ? (t.push(n), t.push(u), t.push(this._vertexToIndex(h, b)), t.push(u), t.push(this._vertexToIndex(v, b)), t.push(this._vertexToIndex(h, b))) : (t.push(u), t.push(n), t.push(this._vertexToIndex(h, b)), t.push(this._vertexToIndex(v, b)), t.push(u), t.push(this._vertexToIndex(h, b)));
          }
          _fillPoles(t, n, u) {
            const h = this._vertexBuffer, v = et, b = t.length;
            for (let w = 2; w < b; w += 3) {
              const S = t[w - 2], I = t[w - 1], E = t[w], L = h[2 * S], N = h[2 * S + 1], q = h[2 * I], G = h[2 * I + 1], K = h[2 * E], ae = h[2 * E + 1];
              n && (N === 0 && G === 0 && this._generatePoleQuad(t, S, I, L, q, Ru), G === 0 && ae === 0 && this._generatePoleQuad(t, I, E, q, K, Ru), ae === 0 && N === 0 && this._generatePoleQuad(t, E, S, K, L, Ru)), u && (N === v && G === v && this._generatePoleQuad(t, S, I, L, q, fd), G === v && ae === v && this._generatePoleQuad(t, I, E, q, K, fd), ae === v && N === v && this._generatePoleQuad(t, E, S, K, L, fd));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: u, holeIndices: h } = (function(w) {
              const S = [], I = [];
              for (const E of w) if (E.length !== 0) {
                E !== w[0] && S.push(I.length / 2);
                for (let L = 0; L < E.length; L++) I.push(E[L].x), I.push(E[L].y);
              }
              return { flattened: I, holeIndices: S };
            })(t);
            let v;
            this._initializeVertices(u);
            try {
              const w = (function(I, E, L = 2) {
                const N = E && E.length, q = N ? E[0] * L : I.length;
                let G = R0(I, 0, q, L, true);
                const K = [];
                if (!G || G.next === G.prev) return K;
                let ae, me, Oe;
                if (N && (G = (function(Ce, Ie, Ze, rt) {
                  const vt = [];
                  for (let Dt = 0, Tt = Ie.length; Dt < Tt; Dt++) {
                    const Et = R0(Ce, Ie[Dt] * rt, Dt < Tt - 1 ? Ie[Dt + 1] * rt : Ce.length, rt, false);
                    Et === Et.next && (Et.steiner = true), vt.push(Sx(Et));
                  }
                  vt.sort(xx);
                  for (let Dt = 0; Dt < vt.length; Dt++) Ze = wx(vt[Dt], Ze);
                  return Ze;
                })(I, E, G, L)), I.length > 80 * L) {
                  ae = I[0], me = I[1];
                  let Ce = ae, Ie = me;
                  for (let Ze = L; Ze < q; Ze += L) {
                    const rt = I[Ze], vt = I[Ze + 1];
                    rt < ae && (ae = rt), vt < me && (me = vt), rt > Ce && (Ce = rt), vt > Ie && (Ie = vt);
                  }
                  Oe = Math.max(Ce - ae, Ie - me), Oe = Oe !== 0 ? 32767 / Oe : 0;
                }
                return ud(G, K, L, ae, me, Oe, 0), K;
              })(u, h), S = this._convertIndices(u, w);
              v = this._subdivideTrianglesScanline(S);
            } catch (w) {
              console.error(w);
            }
            let b = [];
            return n && (b = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(v), { verticesFlattened: this._vertexBuffer, indicesTriangles: v, indicesLineList: b };
          }
          _convertIndices(t, n) {
            const u = [];
            for (let h = 0; h < n.length; h++) u.push(this._vertexToIndex(t[2 * n[h]], t[2 * n[h] + 1]));
            return u;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let u = 0; u < t.length; u++) {
              const h = t[u];
              n.push(this._vertexToIndex(h.x, h.y));
            }
            return n;
          }
        }
        function L0(o, t, n, u = true) {
          return new Px(n, t).subdividePolygonInternal(o, u);
        }
        function pl(o, t, n = false) {
          if (!o || o.length < 1) return [];
          if (o.length < 2) return [];
          const u = o[0], h = o[o.length - 1], v = n && (u.x !== h.x || u.y !== h.y);
          if (t < 2) return v ? [...o, o[0]] : [...o];
          const b = Math.floor(et / t), w = [];
          w.push(new C(o[0].x, o[0].y));
          const S = o.length, I = v ? S : S - 1;
          for (let E = 0; E < I; E++) {
            const L = o[E], N = E < S - 1 ? o[E + 1] : o[0], q = L.x, G = L.y, K = N.x, ae = N.y, me = q !== K, Oe = G !== ae;
            if (!me && !Oe) continue;
            const Ce = K - q, Ie = ae - G, Ze = Math.abs(Ce), rt = Math.abs(Ie);
            let vt = q, Dt = G;
            for (; ; ) {
              const Et = Ce > 0 ? (Math.floor(vt / b) + 1) * b : (Math.ceil(vt / b) - 1) * b, Yt = Ie > 0 ? (Math.floor(Dt / b) + 1) * b : (Math.ceil(Dt / b) - 1) * b, Mt = Math.abs(vt - Et), Rt = Math.abs(Dt - Yt), ct = Math.abs(vt - K), lr = Math.abs(Dt - ae), fr = me ? Mt / Ze : Number.POSITIVE_INFINITY, tr = Oe ? Rt / rt : Number.POSITIVE_INFINITY;
              if ((ct <= Mt || !me) && (lr <= Rt || !Oe)) break;
              if (fr < tr && me || !Oe) {
                vt = Et, Dt += Ie * fr;
                const Gt = new C(vt, Math.round(Dt));
                w[w.length - 1].x === Gt.x && w[w.length - 1].y === Gt.y || w.push(Gt);
              } else {
                vt += Ce * tr, Dt = Yt;
                const Gt = new C(Math.round(vt), Dt);
                w[w.length - 1].x === Gt.x && w[w.length - 1].y === Gt.y || w.push(Gt);
              }
            }
            const Tt = new C(K, ae);
            w[w.length - 1].x === Tt.x && w[w.length - 1].y === Tt.y || w.push(Tt);
          }
          return w;
        }
        function Tx(o, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let u = 0, h = o[2 * t[0]];
          for (let S = 1; S < t.length; S++) {
            const I = o[2 * t[S]];
            I < h && (h = I, u = S);
          }
          const v = t.length;
          let b = u, w = (b + 1) % v;
          for (; ; ) {
            const S = b - 1 >= 0 ? b - 1 : v - 1, I = (w + 1) % v, E = o[2 * t[S]], L = o[2 * t[I]], N = o[2 * t[b]], q = o[2 * t[b] + 1], G = o[2 * t[w] + 1];
            let K = false;
            if (E < L) K = true;
            else if (E > L) K = false;
            else {
              const ae = G - q, me = -(o[2 * t[w]] - N), Oe = q < G ? 1 : -1;
              ((E - N) * ae + (o[2 * t[S] + 1] - q) * me) * Oe > ((L - N) * ae + (o[2 * t[I] + 1] - q) * me) * Oe && (K = true);
            }
            if (K) {
              const ae = t[S], me = t[b], Oe = t[w];
              ae !== me && ae !== Oe && me !== Oe && n.push(Oe, me, ae), b--, b < 0 && (b = v - 1);
            } else {
              const ae = t[I], me = t[b], Oe = t[w];
              ae !== me && ae !== Oe && me !== Oe && n.push(Oe, me, ae), w++, w >= v && (w = 0);
            }
            if (S === I) break;
          }
        }
        function B0(o, t, n, u, h, v, b, w, S) {
          const I = h.length / 2, E = b && w && S;
          if (I < xr.MAX_VERTEX_ARRAY_LENGTH) {
            const L = t.prepareSegment(I, n, u), N = L.vertexLength;
            for (let K = 0; K < v.length; K += 3) u.emplaceBack(N + v[K], N + v[K + 1], N + v[K + 2]);
            let q, G;
            L.vertexLength += I, L.primitiveLength += v.length / 3, E && (G = b.prepareSegment(I, n, w), q = G.vertexLength, G.vertexLength += I);
            for (let K = 0; K < h.length; K += 2) o(h[K], h[K + 1]);
            if (E) for (let K = 0; K < S.length; K++) {
              const ae = S[K];
              for (let me = 1; me < ae.length; me += 2) w.emplaceBack(q + ae[me - 1], q + ae[me]);
              G.primitiveLength += ae.length / 2;
            }
          } else (function(L, N, q, G, K, ae) {
            const me = [];
            for (let rt = 0; rt < G.length / 2; rt++) me.push(-1);
            const Oe = { count: 0 };
            let Ce = 0, Ie = L.getOrCreateLatestSegment(N, q), Ze = Ie.vertexLength;
            for (let rt = 2; rt < K.length; rt += 3) {
              const vt = K[rt - 2], Dt = K[rt - 1], Tt = K[rt];
              let Et = me[vt] < Ce, Yt = me[Dt] < Ce, Mt = me[Tt] < Ce;
              Ie.vertexLength + ((Et ? 1 : 0) + (Yt ? 1 : 0) + (Mt ? 1 : 0)) > xr.MAX_VERTEX_ARRAY_LENGTH && (Ie = L.createNewSegment(N, q), Ce = Oe.count, Et = true, Yt = true, Mt = true, Ze = 0);
              const Rt = pd(me, G, ae, Oe, vt, Et, Ie), ct = pd(me, G, ae, Oe, Dt, Yt, Ie), lr = pd(me, G, ae, Oe, Tt, Mt, Ie);
              q.emplaceBack(Ze + Rt - Ce, Ze + ct - Ce, Ze + lr - Ce), Ie.primitiveLength++;
            }
          })(t, n, u, h, v, o), E && (function(L, N, q, G, K, ae) {
            const me = [];
            for (let rt = 0; rt < G.length / 2; rt++) me.push(-1);
            const Oe = { count: 0 };
            let Ce = 0, Ie = L.getOrCreateLatestSegment(N, q), Ze = Ie.vertexLength;
            for (let rt = 0; rt < K.length; rt++) {
              const vt = K[rt];
              for (let Dt = 1; Dt < K[rt].length; Dt += 2) {
                const Tt = vt[Dt - 1], Et = vt[Dt];
                let Yt = me[Tt] < Ce, Mt = me[Et] < Ce;
                Ie.vertexLength + ((Yt ? 1 : 0) + (Mt ? 1 : 0)) > xr.MAX_VERTEX_ARRAY_LENGTH && (Ie = L.createNewSegment(N, q), Ce = Oe.count, Yt = true, Mt = true, Ze = 0);
                const Rt = pd(me, G, ae, Oe, Tt, Yt, Ie), ct = pd(me, G, ae, Oe, Et, Mt, Ie);
                q.emplaceBack(Ze + Rt - Ce, Ze + ct - Ce), Ie.primitiveLength++;
              }
            }
          })(b, n, w, h, S, o), t.forceNewSegmentOnNextPrepare(), b == null ? void 0 : b.forceNewSegmentOnNextPrepare();
        }
        function pd(o, t, n, u, h, v, b) {
          if (v) {
            const w = u.count;
            return n(t[2 * h], t[2 * h + 1]), o[h] = u.count, u.count++, b.vertexLength++, w;
          }
          return o[h];
        }
        class tm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new Je(), this.indexArray = new Li(), this.indexArray2 = new si(), this.programConfigurations = new cl(t.layers, t.zoom), this.segments = new xr(), this.segments2 = new xr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasDependencies = rf("fill", this.layers, n);
            const h = this.layers[0].layout.get("fill-sort-key"), v = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const L = this.layers[0]._featureFilter.needGeometry, N = hl(w, L);
              if (!this.layers[0]._featureFilter.filter(new Gr(this.zoom), N, u)) continue;
              const q = v ? h.evaluate(N, {}, u, n.availableImages) : void 0, G = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: L ? N.geometry : dl(w), patterns: {}, sortKey: q };
              b.push(G);
            }
            v && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              if (this.hasDependencies) {
                const L = Jp("fill", this.layers, w, { zoom: this.zoom }, n);
                this.patternFeatures.push(L);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, gx), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, u, h, v, b) {
            for (const w of Zs(n, 500)) {
              const S = L0(w, h, b.fill.getGranularityForZoomLevel(h.z)), I = this.layoutVertexArray;
              B0(((E, L) => {
                I.emplaceBack(E, L);
              }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles, this.segments2, this.indexArray2, S.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: v, canonical: h });
          }
        }
        let O0, $0;
        Ot("FillBucket", tm, { omit: ["layers", "patternFeatures"] });
        var Ix = { get paint() {
          return $0 = $0 || new sn({ "fill-antialias": new Wt(Te.paint_fill["fill-antialias"]), "fill-opacity": new er(Te.paint_fill["fill-opacity"]), "fill-color": new er(Te.paint_fill["fill-color"]), "fill-outline-color": new er(Te.paint_fill["fill-outline-color"]), "fill-translate": new Wt(Te.paint_fill["fill-translate"]), "fill-translate-anchor": new Wt(Te.paint_fill["fill-translate-anchor"]), "fill-pattern": new al(Te.paint_fill["fill-pattern"]) });
        }, get layout() {
          return O0 = O0 || new sn({ "fill-sort-key": new er(Te.layout_fill["fill-sort-key"]) });
        } };
        class Mx extends so {
          constructor(t, n) {
            super(t, Ix, n);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const u = this.paint._values["fill-outline-color"];
            u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new tm(t);
          }
          queryRadius() {
            return ef(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: u, pixelsToTileUnits: h }) {
            return v0(tf(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -u.bearingInRadians, h), n);
          }
          isTileClipped() {
            return true;
          }
        }
        const Ex = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Rx = xi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Ax } = Ex;
        class Au {
          constructor(t, n, u, h, v) {
            this.properties = {}, this.extent = u, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = h, this._values = v, t.readFields(Dx, this, n);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos, u = [];
            let h, v = 1, b = 0, w = 0, S = 0;
            for (; t.pos < n; ) {
              if (b <= 0) {
                const I = t.readVarint();
                v = 7 & I, b = I >> 3;
              }
              if (b--, v === 1 || v === 2) w += t.readSVarint(), S += t.readSVarint(), v === 1 && (h && u.push(h), h = []), h && h.push(new C(w, S));
              else {
                if (v !== 7) throw new Error(`unknown command ${v}`);
                h && h.push(h[0].clone());
              }
            }
            return h && u.push(h), u;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let u = 1, h = 0, v = 0, b = 0, w = 1 / 0, S = -1 / 0, I = 1 / 0, E = -1 / 0;
            for (; t.pos < n; ) {
              if (h <= 0) {
                const L = t.readVarint();
                u = 7 & L, h = L >> 3;
              }
              if (h--, u === 1 || u === 2) v += t.readSVarint(), b += t.readSVarint(), v < w && (w = v), v > S && (S = v), b < I && (I = b), b > E && (E = b);
              else if (u !== 7) throw new Error(`unknown command ${u}`);
            }
            return [w, I, S, E];
          }
          toGeoJSON(t, n, u) {
            const h = this.extent * Math.pow(2, u), v = this.extent * t, b = this.extent * n, w = this.loadGeometry();
            function S(N) {
              return [360 * (N.x + v) / h - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (N.y + b) / h) * Math.PI)) - 90];
            }
            function I(N) {
              return N.map(S);
            }
            let E;
            if (this.type === 1) {
              const N = [];
              for (const G of w) N.push(G[0]);
              const q = I(N);
              E = N.length === 1 ? { type: "Point", coordinates: q[0] } : { type: "MultiPoint", coordinates: q };
            } else if (this.type === 2) {
              const N = w.map(I);
              E = N.length === 1 ? { type: "LineString", coordinates: N[0] } : { type: "MultiLineString", coordinates: N };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const N = (function(G) {
                  const K = G.length;
                  if (K <= 1) return [G];
                  const ae = [];
                  let me, Oe;
                  for (let Ce = 0; Ce < K; Ce++) {
                    const Ie = zx(G[Ce]);
                    Ie !== 0 && (Oe === void 0 && (Oe = Ie < 0), Oe === Ie < 0 ? (me && ae.push(me), me = [G[Ce]]) : me && me.push(G[Ce]));
                  }
                  return me && ae.push(me), ae;
                })(w), q = [];
                for (const G of N) q.push(G.map(I));
                E = q.length === 1 ? { type: "Polygon", coordinates: q[0] } : { type: "MultiPolygon", coordinates: q };
              }
            }
            const L = { type: "Feature", geometry: E, properties: this.properties };
            return this.id != null && (L.id = this.id), L;
          }
        }
        function Dx(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? (function(u, h) {
            const v = u.readVarint() + u.pos;
            for (; u.pos < v; ) {
              const b = h._keys[u.readVarint()], w = h._values[u.readVarint()];
              h.properties[b] = w;
            }
          })(n, t) : o === 3 ? t.type = n.readVarint() : o === 4 && (t._geometry = n.pos);
        }
        function zx(o) {
          let t = 0;
          for (let n, u, h = 0, v = o.length, b = v - 1; h < v; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        Au.types = ["Unknown", "Point", "LineString", "Polygon"];
        class j0 {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Fx, this, n), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new Au(this._pbf, n, this.extent, this._keys, this._values);
          }
        }
        function Fx(o, t, n) {
          o === 15 ? t.version = n.readVarint() : o === 1 ? t.name = n.readString() : o === 5 ? t.extent = n.readVarint() : o === 2 ? t._features.push(n.pos) : o === 3 ? t._keys.push(n.readString()) : o === 4 && t._values.push((function(u) {
            let h = null;
            const v = u.readVarint() + u.pos;
            for (; u.pos < v; ) {
              const b = u.readVarint() >> 3;
              h = b === 1 ? u.readString() : b === 2 ? u.readFloat() : b === 3 ? u.readDouble() : b === 4 ? u.readVarint64() : b === 5 ? u.readVarint() : b === 6 ? u.readSVarint() : b === 7 ? u.readBoolean() : null;
            }
            if (h == null) throw new Error("unknown feature value");
            return h;
          })(n));
        }
        class N0 {
          constructor(t, n) {
            this.layers = t.readFields(Lx, {}, n);
          }
        }
        function Lx(o, t, n) {
          if (o === 3) {
            const u = new j0(n, n.readVarint() + n.pos);
            u.length && (t[u.name] = u);
          }
        }
        const rm = Math.pow(2, 13);
        function md(o, t, n, u, h, v, b, w) {
          o.emplaceBack(t, n, 2 * Math.floor(u * rm) + b, h * rm * 2, v * rm * 2, Math.round(w));
        }
        class im {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.layoutVertexArray = new kt(), this.centroidVertexArray = new We(), this.indexArray = new Li(), this.programConfigurations = new cl(t.layers, t.zoom), this.segments = new xr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.features = [], this.hasDependencies = rf("fill-extrusion", this.layers, n);
            for (const { feature: h, id: v, index: b, sourceLayerIndex: w } of t) {
              const S = this.layers[0]._featureFilter.needGeometry, I = hl(h, S);
              if (!this.layers[0]._featureFilter.filter(new Gr(this.zoom), I, u)) continue;
              const E = { id: v, sourceLayerIndex: w, index: b, geometry: S ? I.geometry : dl(h), properties: h.properties, type: h.type, patterns: {} };
              this.hasDependencies ? this.features.push(Jp("fill-extrusion", this.layers, E, { zoom: this.zoom }, n)) : this.addFeature(E, E.geometry, b, u, {}, n.subdivisionGranularity), n.featureIndex.insert(h, E.geometry, b, w, this.index, true);
            }
          }
          addFeatures(t, n, u) {
            for (const h of this.features) {
              const { geometry: v } = h;
              this.addFeature(h, v, h.index, n, u, t.subdivisionGranularity);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ax), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Rx.members, true), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, u, h, v, b) {
            for (const w of Zs(n, 500)) {
              const S = { x: 0, y: 0, sampleCount: 0 }, I = this.layoutVertexArray.length;
              this.processPolygon(S, h, t, w, b);
              const E = this.layoutVertexArray.length - I, L = Math.floor(S.x / S.sampleCount), N = Math.floor(S.y / S.sampleCount);
              for (let q = 0; q < E; q++) this.centroidVertexArray.emplaceBack(L, N);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: v, canonical: h });
          }
          processPolygon(t, n, u, h, v) {
            if (h.length < 1 || V0(h[0])) return;
            for (const L of h) L.length !== 0 && Bx(t, L);
            const b = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, w = v.fill.getGranularityForZoomLevel(n.z), S = Au.types[u.type] === "Polygon";
            for (const L of h) {
              if (L.length === 0 || V0(L)) continue;
              const N = pl(L, w, S);
              this._generateSideFaces(N, b);
            }
            if (!S) return;
            const I = L0(h, n, w, false), E = this.layoutVertexArray;
            B0(((L, N) => {
              md(E, L, N, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, I.verticesFlattened, I.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let u = 0;
            for (let h = 1; h < t.length; h++) {
              const v = t[h], b = t[h - 1];
              if (Ox(v, b)) continue;
              n.segment.vertexLength + 4 > xr.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const w = v.sub(b)._perp()._unit(), S = b.dist(v);
              u + S > 32768 && (u = 0), md(this.layoutVertexArray, v.x, v.y, w.x, w.y, 0, 0, u), md(this.layoutVertexArray, v.x, v.y, w.x, w.y, 0, 1, u), u += S, md(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 0, u), md(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 1, u);
              const I = n.segment.vertexLength;
              this.indexArray.emplaceBack(I, I + 2, I + 1), this.indexArray.emplaceBack(I + 1, I + 2, I + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function Bx(o, t) {
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            n === t.length - 1 && t[0].x === u.x && t[0].y === u.y || (o.x += u.x, o.y += u.y, o.sampleCount++);
          }
        }
        function Ox(o, t) {
          return o.x === t.x && (o.x < 0 || o.x > et) || o.y === t.y && (o.y < 0 || o.y > et);
        }
        function V0(o) {
          return o.every(((t) => t.x < 0)) || o.every(((t) => t.x > et)) || o.every(((t) => t.y < 0)) || o.every(((t) => t.y > et));
        }
        let U0;
        Ot("FillExtrusionBucket", im, { omit: ["layers", "features"] });
        var $x = { get paint() {
          return U0 = U0 || new sn({ "fill-extrusion-opacity": new Wt(Te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new er(Te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Wt(Te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Wt(Te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new al(Te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new er(Te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new er(Te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Wt(Te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class jx extends so {
          constructor(t, n) {
            super(t, $x, n);
          }
          createBucket(t) {
            return new im(t);
          }
          queryRadius() {
            return ef(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: v, pixelsToTileUnits: b, pixelPosMatrix: w }) {
            const S = tf(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -v.bearingInRadians, b), I = this.paint.get("fill-extrusion-height").evaluate(n, u), E = this.paint.get("fill-extrusion-base").evaluate(n, u), L = (function(q, G) {
              const K = [];
              for (const ae of q) {
                const me = [ae.x, ae.y, 0, 1];
                Qe(me, me, G), K.push(new C(me[0] / me[3], me[1] / me[3]));
              }
              return K;
            })(S, w), N = (function(q, G, K, ae) {
              const me = [], Oe = [], Ce = ae[8] * G, Ie = ae[9] * G, Ze = ae[10] * G, rt = ae[11] * G, vt = ae[8] * K, Dt = ae[9] * K, Tt = ae[10] * K, Et = ae[11] * K;
              for (const Yt of q) {
                const Mt = [], Rt = [];
                for (const ct of Yt) {
                  const lr = ct.x, fr = ct.y, tr = ae[0] * lr + ae[4] * fr + ae[12], Gt = ae[1] * lr + ae[5] * fr + ae[13], Ir = ae[2] * lr + ae[6] * fr + ae[14], wi = ae[3] * lr + ae[7] * fr + ae[15], Bi = Ir + Ze, un = wi + rt, uo = tr + vt, $n = Gt + Dt, Ki = Ir + Tt, gi = wi + Et, qi = new C((tr + Ce) / un, (Gt + Ie) / un);
                  qi.z = Bi / un, Mt.push(qi);
                  const Ji = new C(uo / gi, $n / gi);
                  Ji.z = Ki / gi, Rt.push(Ji);
                }
                me.push(Mt), Oe.push(Rt);
              }
              return [me, Oe];
            })(h, E, I, w);
            return (function(q, G, K) {
              let ae = 1 / 0;
              v0(K, G) && (ae = q0(K, G[0]));
              for (let me = 0; me < G.length; me++) {
                const Oe = G[me], Ce = q[me];
                for (let Ie = 0; Ie < Oe.length - 1; Ie++) {
                  const Ze = Oe[Ie], rt = [Ze, Oe[Ie + 1], Ce[Ie + 1], Ce[Ie], Ze];
                  g0(K, rt) && (ae = Math.min(ae, q0(K, rt)));
                }
              }
              return ae !== 1 / 0 && ae;
            })(N[0], N[1], L);
          }
        }
        function gd(o, t) {
          return o.x * t.x + o.y * t.y;
        }
        function q0(o, t) {
          if (o.length === 1) {
            let n = 0;
            const u = t[n++];
            let h;
            for (; !h || u.equals(h); ) if (h = t[n++], !h) return 1 / 0;
            for (; n < t.length; n++) {
              const v = t[n], b = o[0], w = h.sub(u), S = v.sub(u), I = b.sub(u), E = gd(w, w), L = gd(w, S), N = gd(S, S), q = gd(I, w), G = gd(I, S), K = E * N - L * L, ae = (N * q - L * G) / K, me = (E * G - L * q) / K, Oe = u.z * (1 - ae - me) + h.z * ae + v.z * me;
              if (isFinite(Oe)) return Oe;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const u of t) n = Math.min(n, u.z);
            return n;
          }
        }
        const Nx = xi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Vx } = Nx, Ux = xi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: qx } = Ux, Gx = Math.cos(Math.PI / 180 * 37.5), G0 = Math.pow(2, 14) / 0.5;
        class nm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((n) => {
              this.gradients[n.id] = {};
            })), this.layoutVertexArray = new St(), this.layoutVertexArray2 = new pt(), this.indexArray = new Li(), this.programConfigurations = new cl(t.layers, t.zoom), this.segments = new xr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasDependencies = rf("line", this.layers, n) || this.hasLineDasharray(this.layers);
            const h = this.layers[0].layout.get("line-sort-key"), v = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const L = this.layers[0]._featureFilter.needGeometry, N = hl(w, L);
              if (!this.layers[0]._featureFilter.filter(new Gr(this.zoom), N, u)) continue;
              const q = v ? h.evaluate(N, {}, u) : void 0, G = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: L ? N.geometry : dl(w), patterns: {}, dashes: {}, sortKey: q };
              b.push(G);
            }
            v && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              this.hasDependencies ? (rf("line", this.layers, n) ? Jp("line", this.layers, w, { zoom: this.zoom }, n) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, w, this.zoom, n), this.patternFeatures.push(w)) : this.addFeature(w, S, I, u, {}, {}, n.subdivisionGranularity), n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u, h) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, dashPositions: h });
          }
          addFeatures(t, n, u, h) {
            for (const v of this.patternFeatures) this.addFeature(v, v.geometry, v.index, n, u, h, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, qx)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Vx), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, u, h, v, b, w) {
            const S = this.layers[0].layout, I = S.get("line-join").evaluate(t, {}), E = S.get("line-cap"), L = S.get("line-miter-limit"), N = S.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const q of n) this.addLine(q, t, I, E, L, N, h, w);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: v, dashPositions: b, canonical: h });
          }
          addLine(t, n, u, h, v, b, w, S) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = pl(t, w ? S.line.getGranularityForZoomLevel(w.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Ce = 0; Ce < t.length - 1; Ce++) this.totalDistance += t[Ce].dist(t[Ce + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const I = Au.types[n.type] === "Polygon";
            let E = t.length;
            for (; E >= 2 && t[E - 1].equals(t[E - 2]); ) E--;
            let L = 0;
            for (; L < E - 1 && t[L].equals(t[L + 1]); ) L++;
            if (E < (I ? 3 : 2)) return;
            u === "bevel" && (v = 1.05);
            const N = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, q = this.segments.prepareSegment(10 * E, this.layoutVertexArray, this.indexArray);
            let G, K, ae, me, Oe;
            this.e1 = this.e2 = -1, I && (G = t[E - 2], Oe = t[L].sub(G)._unit()._perp());
            for (let Ce = L; Ce < E; Ce++) {
              if (ae = Ce === E - 1 ? I ? t[L + 1] : void 0 : t[Ce + 1], ae && t[Ce].equals(ae)) continue;
              Oe && (me = Oe), G && (K = G), G = t[Ce], Oe = ae ? ae.sub(G)._unit()._perp() : me, me = me || Oe;
              let Ie = me.add(Oe);
              Ie.x === 0 && Ie.y === 0 || Ie._unit();
              const Ze = me.x * Oe.x + me.y * Oe.y, rt = Ie.x * Oe.x + Ie.y * Oe.y, vt = rt !== 0 ? 1 / rt : 1 / 0, Dt = 2 * Math.sqrt(2 - 2 * rt), Tt = rt < Gx && K && ae, Et = me.x * Oe.y - me.y * Oe.x > 0;
              if (Tt && Ce > L) {
                const Rt = G.dist(K);
                if (Rt > 2 * N) {
                  const ct = G.sub(G.sub(K)._mult(N / Rt)._round());
                  this.updateDistance(K, ct), this.addCurrentVertex(ct, me, 0, 0, q), K = ct;
                }
              }
              const Yt = K && ae;
              let Mt = Yt ? u : I ? "butt" : h;
              if (Yt && Mt === "round" && (vt < b ? Mt = "miter" : vt <= 2 && (Mt = "fakeround")), Mt === "miter" && vt > v && (Mt = "bevel"), Mt === "bevel" && (vt > 2 && (Mt = "flipbevel"), vt < v && (Mt = "miter")), K && this.updateDistance(K, G), Mt === "miter") Ie._mult(vt), this.addCurrentVertex(G, Ie, 0, 0, q);
              else if (Mt === "flipbevel") {
                if (vt > 100) Ie = Oe.mult(-1);
                else {
                  const Rt = vt * me.add(Oe).mag() / me.sub(Oe).mag();
                  Ie._perp()._mult(Rt * (Et ? -1 : 1));
                }
                this.addCurrentVertex(G, Ie, 0, 0, q), this.addCurrentVertex(G, Ie.mult(-1), 0, 0, q);
              } else if (Mt === "bevel" || Mt === "fakeround") {
                const Rt = -Math.sqrt(vt * vt - 1), ct = Et ? Rt : 0, lr = Et ? 0 : Rt;
                if (K && this.addCurrentVertex(G, me, ct, lr, q), Mt === "fakeround") {
                  const fr = Math.round(180 * Dt / Math.PI / 20);
                  for (let tr = 1; tr < fr; tr++) {
                    let Gt = tr / fr;
                    if (Gt !== 0.5) {
                      const wi = Gt - 0.5;
                      Gt += Gt * wi * (Gt - 1) * ((1.0904 + Ze * (Ze * (3.55645 - 1.43519 * Ze) - 3.2452)) * wi * wi + (0.848013 + Ze * (0.215638 * Ze - 1.06021)));
                    }
                    const Ir = Oe.sub(me)._mult(Gt)._add(me)._unit()._mult(Et ? -1 : 1);
                    this.addHalfVertex(G, Ir.x, Ir.y, false, Et, 0, q);
                  }
                }
                ae && this.addCurrentVertex(G, Oe, -ct, -lr, q);
              } else if (Mt === "butt") this.addCurrentVertex(G, Ie, 0, 0, q);
              else if (Mt === "square") {
                const Rt = K ? 1 : -1;
                this.addCurrentVertex(G, Ie, Rt, Rt, q);
              } else Mt === "round" && (K && (this.addCurrentVertex(G, me, 0, 0, q), this.addCurrentVertex(G, me, 1, 1, q, true)), ae && (this.addCurrentVertex(G, Oe, -1, -1, q, true), this.addCurrentVertex(G, Oe, 0, 0, q)));
              if (Tt && Ce < E - 1) {
                const Rt = G.dist(ae);
                if (Rt > 2 * N) {
                  const ct = G.add(ae.sub(G)._mult(N / Rt)._round());
                  this.updateDistance(G, ct), this.addCurrentVertex(ct, Oe, 0, 0, q), G = ct;
                }
              }
            }
          }
          addCurrentVertex(t, n, u, h, v, b = false) {
            const w = n.y * h - n.x, S = -n.y - n.x * h;
            this.addHalfVertex(t, n.x + n.y * u, n.y - n.x * u, b, false, u, v), this.addHalfVertex(t, w, S, b, true, -h, v), this.distance > G0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, u, h, v, b));
          }
          addHalfVertex({ x: t, y: n }, u, h, v, b, w, S) {
            const I = 0.5 * (this.lineClips ? this.scaledDistance * (G0 - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (v ? 1 : 0), (n << 1) + (b ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * h) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1) | (63 & I) << 2, I >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const E = S.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, E, this.e2), S.primitiveLength++), b ? this.e2 = E : this.e1 = E;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
          hasLineDasharray(t) {
            for (const n of t) {
              const u = n.paint.get("line-dasharray");
              if (u && !u.isConstant()) return true;
            }
            return false;
          }
          addLineDashDependencies(t, n, u, h) {
            for (const v of t) {
              const b = v.paint.get("line-dasharray");
              if (!b || b.value.kind === "constant") continue;
              const w = v.layout.get("line-cap") === "round", S = { dasharray: b.value.evaluate({ zoom: u - 1 }, n, {}), round: w }, I = { dasharray: b.value.evaluate({ zoom: u }, n, {}), round: w }, E = { dasharray: b.value.evaluate({ zoom: u + 1 }, n, {}), round: w }, L = `${S.dasharray.join(",")},${S.round}`, N = `${I.dasharray.join(",")},${I.round}`, q = `${E.dasharray.join(",")},${E.round}`;
              h.dashDependencies[L] = S, h.dashDependencies[N] = I, h.dashDependencies[q] = E, n.dashes[v.id] = { min: L, mid: N, max: q };
            }
          }
        }
        let W0, Z0;
        Ot("LineBucket", nm, { omit: ["layers", "patternFeatures"] });
        var H0 = { get paint() {
          return Z0 = Z0 || new sn({ "line-opacity": new er(Te.paint_line["line-opacity"]), "line-color": new er(Te.paint_line["line-color"]), "line-translate": new Wt(Te.paint_line["line-translate"]), "line-translate-anchor": new Wt(Te.paint_line["line-translate-anchor"]), "line-width": new er(Te.paint_line["line-width"]), "line-gap-width": new er(Te.paint_line["line-gap-width"]), "line-offset": new er(Te.paint_line["line-offset"]), "line-blur": new er(Te.paint_line["line-blur"]), "line-dasharray": new al(Te.paint_line["line-dasharray"]), "line-pattern": new al(Te.paint_line["line-pattern"]), "line-gradient": new bu(Te.paint_line["line-gradient"]) });
        }, get layout() {
          return W0 = W0 || new sn({ "line-cap": new Wt(Te.layout_line["line-cap"]), "line-join": new er(Te.layout_line["line-join"]), "line-miter-limit": new Wt(Te.layout_line["line-miter-limit"]), "line-round-limit": new Wt(Te.layout_line["line-round-limit"]), "line-sort-key": new er(Te.layout_line["line-sort-key"]) });
        } };
        class Wx extends er {
          possiblyEvaluate(t, n) {
            return n = new Gr(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, u, h) {
            return n = It({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, u, h);
          }
        }
        let sf;
        class Zx extends so {
          constructor(t, n) {
            super(t, H0, n), this.gradientVersion = 0, sf || (sf = new Wx(H0.paint.properties["line-width"].specification), sf.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(u) {
                return u._styleExpression !== void 0;
              })(n) && n._styleExpression.expression instanceof Si, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = sf.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new nm(t);
          }
          queryRadius(t) {
            const n = t, u = X0(Iu("line-width", this, n), Iu("line-gap-width", this, n)), h = Iu("line-offset", this, n);
            return u / 2 + Math.abs(h) + ef(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: v, pixelsToTileUnits: b }) {
            const w = tf(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -v.bearingInRadians, b), S = b / 2 * X0(this.paint.get("line-width").evaluate(n, u), this.paint.get("line-gap-width").evaluate(n, u)), I = this.paint.get("line-offset").evaluate(n, u);
            return I && (h = (function(E, L) {
              const N = [];
              for (let q = 0; q < E.length; q++) {
                const G = E[q], K = [];
                for (let ae = 0; ae < G.length; ae++) {
                  const me = G[ae - 1], Oe = G[ae], Ce = G[ae + 1], Ie = ae === 0 ? new C(0, 0) : Oe.sub(me)._unit()._perp(), Ze = ae === G.length - 1 ? new C(0, 0) : Ce.sub(Oe)._unit()._perp(), rt = Ie._add(Ze)._unit(), vt = rt.x * Ze.x + rt.y * Ze.y;
                  vt !== 0 && rt._mult(1 / vt), K.push(rt._mult(L)._add(Oe));
                }
                N.push(K);
              }
              return N;
            })(h, I * b)), (function(E, L, N) {
              for (let q = 0; q < L.length; q++) {
                const G = L[q];
                if (E.length >= 3) {
                  for (let K = 0; K < G.length; K++) if (Tu(E, G[K])) return true;
                }
                if (ex(E, G, N)) return true;
              }
              return false;
            })(w, h, S);
          }
          isTileClipped() {
            return true;
          }
        }
        function X0(o, t) {
          return t > 0 ? t + 2 * o : o;
        }
        const Hx = xi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Xx = xi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        xi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Yx = xi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        xi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Y0 = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Kx = xi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Jx(o, t, n) {
          return o.sections.forEach(((u) => {
            u.text = (function(h, v, b) {
              const w = v.layout.get("text-transform").evaluate(b, {});
              return w === "uppercase" ? h = h.toLocaleUpperCase() : w === "lowercase" && (h = h.toLocaleLowerCase()), aa.applyArabicShaping && (h = aa.applyArabicShaping(h)), h;
            })(u.text, t, n);
          })), o;
        }
        xi([{ name: "triangle", components: 3, type: "Uint16" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), xi([{ type: "Float32", name: "offsetX" }]), xi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), xi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const vd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Ui = 24;
        const om = 4294967296, K0 = 1 / om, J0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class am {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, n, u = this.length) {
            for (; this.pos < u; ) {
              const h = this.readVarint(), v = h >> 3, b = this.pos;
              this.type = 7 & h, t(v, n, this), this.pos === b && this.skip(h);
            }
            return n;
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * om;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * om;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const n = this.buf;
            let u, h;
            return h = n[this.pos++], u = 127 & h, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 7, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 14, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 21, h < 128 ? u : (h = n[this.pos], u |= (15 & h) << 28, (function(v, b, w) {
              const S = w.buf;
              let I, E;
              if (E = S[w.pos++], I = (112 & E) >> 4, E < 128 || (E = S[w.pos++], I |= (127 & E) << 3, E < 128) || (E = S[w.pos++], I |= (127 & E) << 10, E < 128) || (E = S[w.pos++], I |= (127 & E) << 17, E < 128) || (E = S[w.pos++], I |= (127 & E) << 24, E < 128) || (E = S[w.pos++], I |= (1 & E) << 31, E < 128)) return Du(v, I, b);
              throw new Error("Expected varint not more than 10 bytes");
            })(u, t, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, n = this.pos;
            return this.pos = t, t - n >= 12 && J0 ? J0.decode(this.buf.subarray(n, t)) : (function(u, h, v) {
              let b = "", w = h;
              for (; w < v; ) {
                const S = u[w];
                let I, E, L, N = null, q = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
                if (w + q > v) break;
                q === 1 ? S < 128 && (N = S) : q === 2 ? (I = u[w + 1], (192 & I) == 128 && (N = (31 & S) << 6 | 63 & I, N <= 127 && (N = null))) : q === 3 ? (I = u[w + 1], E = u[w + 2], (192 & I) == 128 && (192 & E) == 128 && (N = (15 & S) << 12 | (63 & I) << 6 | 63 & E, (N <= 2047 || N >= 55296 && N <= 57343) && (N = null))) : q === 4 && (I = u[w + 1], E = u[w + 2], L = u[w + 3], (192 & I) == 128 && (192 & E) == 128 && (192 & L) == 128 && (N = (15 & S) << 18 | (63 & I) << 12 | (63 & E) << 6 | 63 & L, (N <= 65535 || N >= 1114112) && (N = null))), N === null ? (N = 65533, q = 1) : N > 65535 && (N -= 65536, b += String.fromCharCode(N >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), b += String.fromCharCode(N), w += q;
              }
              return b;
            })(this.buf, n, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, t);
            return this.pos = t, n;
          }
          readPackedVarint(t = [], n) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) t.push(this.readVarint(n));
            return t;
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8;
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n);
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t; ) n *= 2;
            if (n !== this.length) {
              const u = new Uint8Array(n);
              u.set(this.buf), this.buf = u, this.dataView = new DataView(u.buffer), this.length = n;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * K0), true), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * K0), true), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, u) {
              let h, v;
              if (n >= 0 ? (h = n % 4294967296 | 0, v = n / 4294967296 | 0) : (h = ~(-n % 4294967296), v = ~(-n / 4294967296), 4294967295 ^ h ? h = h + 1 | 0 : (h = 0, v = v + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              u.realloc(10), (function(b, w, S) {
                S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, S.buf[S.pos] = 127 & (b >>>= 7);
              })(h, 0, u), (function(b, w) {
                const S = (7 & b) << 4;
                w.buf[w.pos++] |= S | ((b >>>= 3) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b)))));
              })(v, u);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(h, v, b) {
              for (let w, S, I = 0; I < v.length; I++) {
                if (w = v.charCodeAt(I), w > 55295 && w < 57344) {
                  if (!S) {
                    w > 56319 || I + 1 === v.length ? (h[b++] = 239, h[b++] = 191, h[b++] = 189) : S = w;
                    continue;
                  }
                  if (w < 56320) {
                    h[b++] = 239, h[b++] = 191, h[b++] = 189, S = w;
                    continue;
                  }
                  w = S - 55296 << 10 | w - 56320 | 65536, S = null;
                } else S && (h[b++] = 239, h[b++] = 191, h[b++] = 189, S = null);
                w < 128 ? h[b++] = w : (w < 2048 ? h[b++] = w >> 6 | 192 : (w < 65536 ? h[b++] = w >> 12 | 224 : (h[b++] = w >> 18 | 240, h[b++] = w >> 12 & 63 | 128), h[b++] = w >> 6 & 63 | 128), h[b++] = 63 & w | 128);
              }
              return b;
            })(this.buf, t, this.pos);
            const u = this.pos - n;
            u >= 128 && Q0(n, u, this), this.pos = n - 1, this.writeVarint(u), this.pos += u;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let u = 0; u < n; u++) this.buf[this.pos++] = t[u];
          }
          writeRawMessage(t, n) {
            this.pos++;
            const u = this.pos;
            t(n, this);
            const h = this.pos - u;
            h >= 128 && Q0(u, h, this), this.pos = u - 1, this.writeVarint(h), this.pos += h;
          }
          writeMessage(t, n, u) {
            this.writeTag(t, 2), this.writeRawMessage(n, u);
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, Qx, n);
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, ew, n);
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, iw, n);
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, tw, n);
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, rw, n);
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, nw, n);
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, ow, n);
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, aw, n);
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, sw, n);
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n);
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n);
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n);
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n);
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n);
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n);
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n);
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n);
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n);
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n);
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n);
          }
        }
        function Du(o, t, n) {
          return n ? 4294967296 * t + (o >>> 0) : 4294967296 * (t >>> 0) + (o >>> 0);
        }
        function Q0(o, t, n) {
          const u = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(u);
          for (let h = n.pos - 1; h >= o; h--) n.buf[h + u] = n.buf[h];
        }
        function Qx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeVarint(o[n]);
        }
        function ew(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSVarint(o[n]);
        }
        function tw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFloat(o[n]);
        }
        function rw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeDouble(o[n]);
        }
        function iw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeBoolean(o[n]);
        }
        function nw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed32(o[n]);
        }
        function ow(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed32(o[n]);
        }
        function aw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed64(o[n]);
        }
        function sw(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed64(o[n]);
        }
        function lw(o, t, n) {
          o === 1 && n.readMessage(uw, t);
        }
        function uw(o, t, n) {
          if (o === 3) {
            const { id: u, bitmap: h, width: v, height: b, left: w, top: S, advance: I } = n.readMessage(cw, {});
            t.push({ id: u, bitmap: new ld({ width: v + 6, height: b + 6 }, h), metrics: { width: v, height: b, left: w, top: S, advance: I } });
          }
        }
        function cw(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? t.bitmap = n.readBytes() : o === 3 ? t.width = n.readVarint() : o === 4 ? t.height = n.readVarint() : o === 5 ? t.left = n.readSVarint() : o === 6 ? t.top = n.readSVarint() : o === 7 && (t.advance = n.readVarint());
        }
        function ev(o) {
          let t = 0, n = 0;
          for (const b of o) t += b.w * b.h, n = Math.max(n, b.w);
          o.sort(((b, w) => w.h - b.h));
          const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let h = 0, v = 0;
          for (const b of o) for (let w = u.length - 1; w >= 0; w--) {
            const S = u[w];
            if (!(b.w > S.w || b.h > S.h)) {
              if (b.x = S.x, b.y = S.y, v = Math.max(v, b.y + b.h), h = Math.max(h, b.x + b.w), b.w === S.w && b.h === S.h) {
                const I = u.pop();
                I && w < u.length && (u[w] = I);
              } else b.h === S.h ? (S.x += b.w, S.w -= b.w) : b.w === S.w ? (S.y += b.h, S.h -= b.h) : (u.push({ x: S.x + b.w, y: S.y, w: S.w - b.w, h: b.h }), S.y += b.h, S.h -= b.h);
              break;
            }
          }
          return { w: h, h: v, fill: t / (h * v) || 0 };
        }
        class sm {
          constructor(t, { pixelRatio: n, version: u, stretchX: h, stretchY: v, content: b, textFitWidth: w, textFitHeight: S }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = h, this.stretchY = v, this.content = b, this.version = u, this.textFitWidth = w, this.textFitHeight = S;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class tv {
          constructor(t, n) {
            const u = {}, h = {};
            this.haveRenderCallbacks = [];
            const v = [];
            this.addImages(t, u, v), this.addImages(n, h, v);
            const { w: b, h: w } = ev(v), S = new On({ width: b || 1, height: w || 1 });
            for (const I in t) {
              const E = t[I], L = u[I].paddedRect;
              On.copy(E.data, S, { x: 0, y: 0 }, { x: L.x + 1, y: L.y + 1 }, E.data);
            }
            for (const I in n) {
              const E = n[I], L = h[I].paddedRect, N = L.x + 1, q = L.y + 1, G = E.data.width, K = E.data.height;
              On.copy(E.data, S, { x: 0, y: 0 }, { x: N, y: q }, E.data), On.copy(E.data, S, { x: 0, y: K - 1 }, { x: N, y: q - 1 }, { width: G, height: 1 }), On.copy(E.data, S, { x: 0, y: 0 }, { x: N, y: q + K }, { width: G, height: 1 }), On.copy(E.data, S, { x: G - 1, y: 0 }, { x: N - 1, y: q }, { width: 1, height: K }), On.copy(E.data, S, { x: 0, y: 0 }, { x: N + G, y: q }, { width: 1, height: K });
            }
            this.image = S, this.iconPositions = u, this.patternPositions = h;
          }
          addImages(t, n, u) {
            for (const h in t) {
              const v = t[h], b = { x: 0, y: 0, w: v.data.width + 2, h: v.data.height + 2 };
              u.push(b), n[h] = new sm(b, v), v.hasRenderCallback && this.haveRenderCallbacks.push(h);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const u in t.updatedImages) this.patchUpdatedImage(this.iconPositions[u], t.getImage(u), n), this.patchUpdatedImage(this.patternPositions[u], t.getImage(u), n);
          }
          patchUpdatedImage(t, n, u) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [h, v] = t.tl;
            u.update(n.data, void 0, { x: h, y: v });
          }
        }
        var ps;
        Ot("ImagePosition", sm), Ot("ImageAtlas", tv), m.ao = void 0, (ps = m.ao || (m.ao = {}))[ps.none = 0] = "none", ps[ps.horizontal = 1] = "horizontal", ps[ps.vertical = 2] = "vertical", ps[ps.horizontalOnly = 3] = "horizontalOnly";
        class yd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, u) {
            const h = new yd();
            return h.scale = t || 1, h.fontStack = n, h.verticalAlign = u || "bottom", h;
          }
          static forImage(t, n) {
            const u = new yd();
            return u.imageName = t, u.verticalAlign = n || "bottom", u;
          }
        }
        class zu {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const u = new zu();
            for (let h = 0; h < t.sections.length; h++) {
              const v = t.sections[h];
              v.image ? u.addImageSection(v) : u.addTextSection(v, n);
            }
            return u;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let u = 0; u < t.length; u++) {
                const h = t.charCodeAt(u + 1) || null, v = t.charCodeAt(u - 1) || null;
                n += h && Jc(h) && !vd[t[u + 1]] || v && Jc(v) && !vd[t[u - 1]] || !vd[t[u]] ? t[u] : vd[t[u]];
              }
              return n;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let u = 0; u < this.text.length && uf[this.text.charCodeAt(u)]; u++) t++;
            let n = this.text.length;
            for (let u = this.text.length - 1; u >= 0 && u >= t && uf[this.text.charCodeAt(u)]; u--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const u = new zu();
            return u.text = this.text.substring(t, n), u.sectionIndex = this.sectionIndex.slice(t, n), u.sections = this.sections, u;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0);
          }
          getMaxImageSize(t) {
            let n = 0, u = 0;
            for (let h = 0; h < this.length(); h++) {
              const v = this.getSection(h);
              if (v.imageName) {
                const b = t[v.imageName];
                if (!b) continue;
                const w = b.displaySize;
                n = Math.max(n, w[0]), u = Math.max(u, w[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: u };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(yd.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const u = this.sections.length - 1;
            for (let h = 0; h < t.text.length; ++h) this.sectionIndex.push(u);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void Ut("Can't add FormattedSection with an empty image.");
            const u = this.getNextImageSectionCharCode();
            u ? (this.text += String.fromCharCode(u), this.sections.push(yd.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Ut("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function lf(o, t, n, u, h, v, b, w, S, I, E, L, N, q, G) {
          const K = zu.fromFeature(o, h);
          let ae;
          L === m.ao.vertical && K.verticalizePunctuation();
          const { processBidirectionalText: me, processStyledBidirectionalText: Oe } = aa;
          if (me && K.sections.length === 1) {
            ae = [];
            const Ze = me(K.toString(), lm(K, I, v, t, u, q));
            for (const rt of Ze) {
              const vt = new zu();
              vt.text = rt, vt.sections = K.sections;
              for (let Dt = 0; Dt < rt.length; Dt++) vt.sectionIndex.push(0);
              ae.push(vt);
            }
          } else if (Oe) {
            ae = [];
            const Ze = Oe(K.text, K.sectionIndex, lm(K, I, v, t, u, q));
            for (const rt of Ze) {
              const vt = new zu();
              vt.text = rt[0], vt.sectionIndex = rt[1], vt.sections = K.sections, ae.push(vt);
            }
          } else ae = (function(Ze, rt) {
            const vt = [], Dt = Ze.text;
            let Tt = 0;
            for (const Et of rt) vt.push(Ze.substring(Tt, Et)), Tt = Et;
            return Tt < Dt.length && vt.push(Ze.substring(Tt, Dt.length)), vt;
          })(K, lm(K, I, v, t, u, q));
          const Ce = [], Ie = { positionedLines: Ce, text: K.toString(), top: E[1], bottom: E[1], left: E[0], right: E[0], writingMode: L, iconsInText: false, verticalizable: false };
          return (function(Ze, rt, vt, Dt, Tt, Et, Yt, Mt, Rt, ct, lr, fr) {
            let tr = 0, Gt = 0, Ir = 0, wi = 0;
            const Bi = Mt === "right" ? 1 : Mt === "left" ? 0 : 0.5, un = Ui / fr;
            let uo = 0;
            for (const gi of Tt) {
              gi.trim();
              const qi = gi.getMaxScale(), Ji = { positionedGlyphs: [], lineOffset: 0 };
              Ze.positionedLines[uo] = Ji;
              const Qi = Ji.positionedGlyphs;
              let Tn = 0;
              if (!gi.length()) {
                Gt += Et, ++uo;
                continue;
              }
              const co = pw(Dt, gi, un);
              for (let jn = 0; jn < gi.length(); jn++) {
                const Oi = gi.getSection(jn), Wi = gi.getSectionIndex(jn), Zi = gi.getCharCode(jn), Ai = mw(Rt, lr, Zi);
                let ui;
                if (Oi.imageName) {
                  if (Ze.iconsInText = true, Oi.scale = Oi.scale * un, ui = vw(Oi, Ai, qi, co, Dt), !ui) continue;
                  Tn = Math.max(Tn, ui.imageOffset);
                } else if (ui = gw(Oi, Zi, Ai, co, rt, vt), !ui) continue;
                const { rect: jo, metrics: Ou, baselineOffset: No } = ui;
                Qi.push({ glyph: Zi, imageName: Oi.imageName, x: tr, y: Gt + No + -17, vertical: Ai, scale: Oi.scale, fontStack: Oi.fontStack, sectionIndex: Wi, metrics: Ou, rect: jo }), Ai ? (Ze.verticalizable = true, tr += (Oi.imageName ? Ou.advance : Ui) * Oi.scale + ct) : tr += Ou.advance * Oi.scale + ct;
              }
              Qi.length !== 0 && (Ir = Math.max(tr - ct, Ir), yw(Qi, 0, Qi.length - 1, Bi)), tr = 0, Ji.lineOffset = Math.max(Tn, (qi - 1) * Ui);
              const Gi = Et * qi + Tn;
              Gt += Gi, wi = Math.max(Gi, wi), ++uo;
            }
            const { horizontalAlign: $n, verticalAlign: Ki } = um(Yt);
            (function(gi, qi, Ji, Qi, Tn, co, Gi, jn, Oi) {
              const Wi = (qi - Ji) * Tn;
              let Zi = 0;
              Zi = co !== Gi ? -jn * Qi - -17 : -Qi * Oi * Gi + 0.5 * Gi;
              for (const Ai of gi) for (const ui of Ai.positionedGlyphs) ui.x += Wi, ui.y += Zi;
            })(Ze.positionedLines, Bi, $n, Ki, Ir, wi, Et, Gt, Tt.length), Ze.top += -Ki * Gt, Ze.bottom = Ze.top + Gt, Ze.left += -$n * Ir, Ze.right = Ze.left + Ir;
          })(Ie, t, n, u, ae, b, w, S, L, I, N, G), !(function(Ze) {
            for (const rt of Ze) if (rt.positionedGlyphs.length !== 0) return false;
            return true;
          })(Ce) && Ie;
        }
        const uf = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, dw = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, hw = { 40: true };
        function rv(o, t, n, u, h, v) {
          if (t.imageName) {
            const b = u[t.imageName];
            return b ? b.displaySize[0] * t.scale * Ui / v + h : 0;
          }
          {
            const b = n[t.fontStack], w = b && b[o];
            return w ? w.metrics.advance * t.scale + h : 0;
          }
        }
        function iv(o, t, n, u) {
          const h = Math.pow(o - t, 2);
          return u ? o < t ? h / 2 : 2 * h : h + Math.abs(n) * n;
        }
        function fw(o, t, n) {
          let u = 0;
          return o === 10 && (u -= 1e4), n && (u += 150), o !== 40 && o !== 65288 || (u += 50), t !== 41 && t !== 65289 || (u += 50), u;
        }
        function nv(o, t, n, u, h, v) {
          let b = null, w = iv(t, n, h, v);
          for (const S of u) {
            const I = iv(t - S.x, n, h, v) + S.badness;
            I <= w && (b = S, w = I);
          }
          return { index: o, x: t, priorBreak: b, badness: w };
        }
        function ov(o) {
          return o ? ov(o.priorBreak).concat(o.index) : [];
        }
        function lm(o, t, n, u, h, v) {
          if (!o) return [];
          const b = [], w = (function(L, N, q, G, K, ae) {
            let me = 0;
            for (let Oe = 0; Oe < L.length(); Oe++) {
              const Ce = L.getSection(Oe);
              me += rv(L.getCharCode(Oe), Ce, G, K, N, ae);
            }
            return me / Math.max(1, Math.ceil(me / q));
          })(o, t, n, u, h, v), S = o.text.indexOf("\u200B") >= 0;
          let I = 0;
          for (let L = 0; L < o.length(); L++) {
            const N = o.getSection(L), q = o.getCharCode(L);
            if (uf[q] || (I += rv(q, N, u, h, t, v)), L < o.length() - 1) {
              const G = !((E = q) < 11904) && (!!kr["CJK Compatibility Forms"](E) || !!kr["CJK Compatibility"](E) || !!kr["CJK Strokes"](E) || !!kr["CJK Symbols and Punctuation"](E) || !!kr["Enclosed CJK Letters and Months"](E) || !!kr["Halfwidth and Fullwidth Forms"](E) || !!kr["Ideographic Description Characters"](E) || !!kr["Vertical Forms"](E) || Gh.test(String.fromCodePoint(E)));
              (dw[q] || G || N.imageName || L !== o.length() - 2 && hw[o.getCharCode(L + 1)]) && b.push(nv(L + 1, I, w, b, fw(q, o.getCharCode(L + 1), G && S), false));
            }
          }
          var E;
          return ov(nv(o.length(), I, w, b, 0, true));
        }
        function um(o) {
          let t = 0.5, n = 0.5;
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (o) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function pw(o, t, n) {
          const u = t.getMaxScale() * Ui, { maxImageWidth: h, maxImageHeight: v } = t.getMaxImageSize(o), b = Math.max(u, v * n);
          return { verticalLineContentWidth: Math.max(u, h * n), horizontalLineContentHeight: b };
        }
        function av(o) {
          switch (o) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function mw(o, t, n) {
          return !(o === m.ao.horizontal || !t && !Kc(n) || t && (uf[n] || (u = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(u)))));
          var u;
        }
        function gw(o, t, n, u, h, v) {
          const b = v[o.fontStack], w = (function(I, E, L, N) {
            if (I && I.rect) return I;
            const q = E[L.fontStack], G = q && q[N];
            return G ? { rect: null, metrics: G.metrics } : null;
          })(b && b[t], h, o, t);
          if (w === null) return null;
          let S;
          if (n) S = u.verticalLineContentWidth - o.scale * Ui;
          else {
            const I = av(o.verticalAlign);
            S = (u.horizontalLineContentHeight - o.scale * Ui) * I;
          }
          return { rect: w.rect, metrics: w.metrics, baselineOffset: S };
        }
        function vw(o, t, n, u, h) {
          const v = h[o.imageName];
          if (!v) return null;
          const b = v.paddedRect, w = v.displaySize, S = { width: w[0], height: w[1], left: 1, top: -3, advance: t ? w[1] : w[0] };
          let I;
          if (t) I = u.verticalLineContentWidth - w[1] * o.scale;
          else {
            const E = av(o.verticalAlign);
            I = (u.horizontalLineContentHeight - w[1] * o.scale) * E;
          }
          return { rect: b, metrics: S, baselineOffset: I, imageOffset: (t ? w[0] : w[1]) * o.scale - Ui * n };
        }
        function yw(o, t, n, u) {
          if (u === 0) return;
          const h = o[n], v = (o[n].x + h.metrics.advance * h.scale) * u;
          for (let b = t; b <= n; b++) o[b].x -= v;
        }
        function _w(o, t, n) {
          const { horizontalAlign: u, verticalAlign: h } = um(n), v = t[0] - o.displaySize[0] * u, b = t[1] - o.displaySize[1] * h;
          return { image: o, top: b, bottom: b + o.displaySize[1], left: v, right: v + o.displaySize[0] };
        }
        function sv(o) {
          var t, n;
          let u = o.left, h = o.top, v = o.right - u, b = o.bottom - h;
          const w = (t = o.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", S = (n = o.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", I = (o.image.content[2] - o.image.content[0]) / (o.image.content[3] - o.image.content[1]);
          if (S === "proportional") {
            if (w === "stretchOnly" && v / b < I || w === "proportional") {
              const E = Math.ceil(b * I);
              u *= E / v, v = E;
            }
          } else if (w === "proportional" && S === "stretchOnly" && I !== 0 && v / b > I) {
            const E = Math.ceil(v / I);
            h *= E / b, b = E;
          }
          return { x1: u, y1: h, x2: u + v, y2: h + b };
        }
        function lv(o, t, n, u, h, v) {
          const b = o.image;
          let w;
          if (b.content) {
            const ae = b.content, me = b.pixelRatio || 1;
            w = [ae[0] / me, ae[1] / me, b.displaySize[0] - ae[2] / me, b.displaySize[1] - ae[3] / me];
          }
          const S = t.left * v, I = t.right * v;
          let E, L, N, q;
          n === "width" || n === "both" ? (q = h[0] + S - u[3], L = h[0] + I + u[1]) : (q = h[0] + (S + I - b.displaySize[0]) / 2, L = q + b.displaySize[0]);
          const G = t.top * v, K = t.bottom * v;
          return n === "height" || n === "both" ? (E = h[1] + G - u[0], N = h[1] + K + u[2]) : (E = h[1] + (G + K - b.displaySize[1]) / 2, N = E + b.displaySize[1]), { image: b, top: E, right: L, bottom: N, left: q, collisionPadding: w };
        }
        const Ga = 128, ms = 32640;
        function uv(o, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Gr(o + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: u, interpolationType: h } = n;
            let v = 0;
            for (; v < u.length && u[v] <= o; ) v++;
            v = Math.max(0, v - 1);
            let b = v;
            for (; b < u.length && u[b] < o + 1; ) b++;
            b = Math.min(u.length - 1, b);
            const w = u[v], S = u[b];
            return n.kind === "composite" ? { kind: "composite", minZoom: w, maxZoom: S, interpolationType: h } : { kind: "camera", minZoom: w, maxZoom: S, minSize: n.evaluate(new Gr(w)), maxSize: n.evaluate(new Gr(S)), interpolationType: h };
          }
        }
        function cm(o, t, n) {
          let u = "never";
          const h = o.get(t);
          return h ? u = h : o.get(n) && (u = "always"), u;
        }
        const bw = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function cf(o, t, n, u, h, v, b, w, S, I, E, L, N) {
          const q = w ? Math.min(ms, Math.round(w[0])) : 0, G = w ? Math.min(ms, Math.round(w[1])) : 0;
          o.emplaceBack(t, n, Math.round(32 * u), Math.round(32 * h), v, b, (q << 1) + (S ? 1 : 0), G, 16 * I, 16 * E, 256 * L, 256 * N);
        }
        function dm(o, t, n) {
          o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n);
        }
        function xw(o) {
          for (const t of o.sections) if (gu(t.text)) return true;
          return false;
        }
        class hm {
          constructor(t) {
            this.layoutVertexArray = new Or(), this.indexArray = new Li(), this.programConfigurations = t, this.segments = new xr(), this.dynamicLayoutVertexArray = new oi(), this.opacityVertexArray = new ti(), this.hasVisibleVertices = false, this.placedSymbolArray = new ue();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, u, h) {
            this.isEmpty() || (u && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Hx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Xx.members, true), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, bw, true), this.opacityVertexBuffer.itemSize = 1), (u || h) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Ot("SymbolBuffers", hm);
        class fm {
          constructor(t, n, u) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new u(), this.segments = new xr(), this.collisionVertexArray = new ai();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Yx.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Ot("CollisionBuffers", fm);
        class Fu {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((b) => b.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = uv(this.zoom, n["text-size"]), this.iconSizeData = uv(this.zoom, n["icon-size"]);
            const u = this.layers[0].layout, h = u.get("symbol-sort-key"), v = u.get("symbol-z-order");
            this.canOverlap = cm(u, "text-overlap", "text-allow-overlap") !== "never" || cm(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = v !== "viewport-y" && !h.isConstant(), this.sortFeaturesByY = (v === "viewport-y" || v === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map(((b) => m.ao[b]))), this.stateDependentLayerIds = this.layers.filter(((b) => b.isStateDependent())).map(((b) => b.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new hm(new cl(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new hm(new cl(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new ye(), this.lineVertexArray = new ke(), this.symbolInstances = new we(), this.textAnchorOffsets = new be();
          }
          calculateGlyphDependencies(t, n, u, h, v) {
            for (let b = 0; b < t.length; b++) if (n[t.charCodeAt(b)] = true, (u || h) && v) {
              const w = vd[t.charAt(b)];
              w && (n[w.charCodeAt(0)] = true);
            }
          }
          populate(t, n, u) {
            const h = this.layers[0], v = h.layout, b = v.get("text-font"), w = v.get("text-field"), S = v.get("icon-image"), I = (w.value.kind !== "constant" || w.value.value instanceof mn && !w.value.value.isEmpty() || w.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), E = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, L = v.get("symbol-sort-key");
            if (this.features = [], !I && !E) return;
            const N = n.iconDependencies, q = n.glyphDependencies, G = n.availableImages, K = new Gr(this.zoom);
            for (const { feature: ae, id: me, index: Oe, sourceLayerIndex: Ce } of t) {
              const Ie = h._featureFilter.needGeometry, Ze = hl(ae, Ie);
              if (!h._featureFilter.filter(K, Ze, u)) continue;
              let rt, vt;
              if (Ie || (Ze.geometry = dl(ae)), I) {
                const Tt = h.getValueAndResolveTokens("text-field", Ze, u, G), Et = mn.factory(Tt), Yt = this.hasRTLText = this.hasRTLText || xw(Et);
                (!Yt || aa.getRTLTextPluginStatus() === "unavailable" || Yt && aa.isParsed()) && (rt = Jx(Et, h, Ze));
              }
              if (E) {
                const Tt = h.getValueAndResolveTokens("icon-image", Ze, u, G);
                vt = Tt instanceof Dn ? Tt : Dn.fromString(Tt);
              }
              if (!rt && !vt) continue;
              const Dt = this.sortFeaturesByKey ? L.evaluate(Ze, {}, u) : void 0;
              if (this.features.push({ id: me, text: rt, icon: vt, index: Oe, sourceLayerIndex: Ce, geometry: Ze.geometry, properties: ae.properties, type: Au.types[ae.type], sortKey: Dt }), vt && (N[vt.name] = true), rt) {
                const Tt = b.evaluate(Ze, {}, u).join(","), Et = v.get("text-rotation-alignment") !== "viewport" && v.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(m.ao.vertical) >= 0;
                for (const Yt of rt.sections) if (Yt.image) N[Yt.image.name] = true;
                else {
                  const Mt = Xc(rt.toString()), Rt = Yt.fontStack || Tt, ct = q[Rt] = q[Rt] || {};
                  this.calculateGlyphDependencies(Yt.text, ct, Et, this.allowVerticalPlacement, Mt);
                }
              }
            }
            v.get("symbol-placement") === "line" && (this.features = (function(ae) {
              const me = {}, Oe = {}, Ce = [];
              let Ie = 0;
              function Ze(Tt) {
                Ce.push(ae[Tt]), Ie++;
              }
              function rt(Tt, Et, Yt) {
                const Mt = Oe[Tt];
                return delete Oe[Tt], Oe[Et] = Mt, Ce[Mt].geometry[0].pop(), Ce[Mt].geometry[0] = Ce[Mt].geometry[0].concat(Yt[0]), Mt;
              }
              function vt(Tt, Et, Yt) {
                const Mt = me[Et];
                return delete me[Et], me[Tt] = Mt, Ce[Mt].geometry[0].shift(), Ce[Mt].geometry[0] = Yt[0].concat(Ce[Mt].geometry[0]), Mt;
              }
              function Dt(Tt, Et, Yt) {
                const Mt = Yt ? Et[0][Et[0].length - 1] : Et[0][0];
                return `${Tt}:${Mt.x}:${Mt.y}`;
              }
              for (let Tt = 0; Tt < ae.length; Tt++) {
                const Et = ae[Tt], Yt = Et.geometry, Mt = Et.text ? Et.text.toString() : null;
                if (!Mt) {
                  Ze(Tt);
                  continue;
                }
                const Rt = Dt(Mt, Yt), ct = Dt(Mt, Yt, true);
                if (Rt in Oe && ct in me && Oe[Rt] !== me[ct]) {
                  const lr = vt(Rt, ct, Yt), fr = rt(Rt, ct, Ce[lr].geometry);
                  delete me[Rt], delete Oe[ct], Oe[Dt(Mt, Ce[fr].geometry, true)] = fr, Ce[lr].geometry = null;
                } else Rt in Oe ? rt(Rt, ct, Yt) : ct in me ? vt(Rt, ct, Yt) : (Ze(Tt), me[Rt] = Ie - 1, Oe[ct] = Ie - 1);
              }
              return Ce.filter(((Tt) => Tt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ae, me) => ae.sortKey - me.sortKey));
          }
          update(t, n, u) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const u = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let h = t.dist(n[t.segment + 1]), v = t.dist(n[t.segment]);
              const b = {};
              for (let w = t.segment + 1; w < n.length; w++) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: h }, w < n.length - 1 && (h += n[w + 1].dist(n[w]));
              for (let w = t.segment || 0; w >= 0; w--) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: v }, w > 0 && (v += n[w - 1].dist(n[w]));
              for (let w = 0; w < n.length; w++) {
                const S = b[w];
                this.lineVertexArray.emplaceBack(S.x, S.y, S.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
          }
          addSymbols(t, n, u, h, v, b, w, S, I, E, L, N) {
            const q = t.indexArray, G = t.layoutVertexArray, K = t.segments.prepareSegment(4 * n.length, G, q, this.canOverlap ? b.sortKey : void 0), ae = this.glyphOffsetArray.length, me = K.vertexLength, Oe = this.allowVerticalPlacement && w === m.ao.vertical ? Math.PI / 2 : 0, Ce = b.text && b.text.sections;
            for (let Ie = 0; Ie < n.length; Ie++) {
              const { tl: Ze, tr: rt, bl: vt, br: Dt, tex: Tt, pixelOffsetTL: Et, pixelOffsetBR: Yt, minFontScaleX: Mt, minFontScaleY: Rt, glyphOffset: ct, isSDF: lr, sectionIndex: fr } = n[Ie], tr = K.vertexLength, Gt = ct[1];
              cf(G, S.x, S.y, Ze.x, Gt + Ze.y, Tt.x, Tt.y, u, lr, Et.x, Et.y, Mt, Rt), cf(G, S.x, S.y, rt.x, Gt + rt.y, Tt.x + Tt.w, Tt.y, u, lr, Yt.x, Et.y, Mt, Rt), cf(G, S.x, S.y, vt.x, Gt + vt.y, Tt.x, Tt.y + Tt.h, u, lr, Et.x, Yt.y, Mt, Rt), cf(G, S.x, S.y, Dt.x, Gt + Dt.y, Tt.x + Tt.w, Tt.y + Tt.h, u, lr, Yt.x, Yt.y, Mt, Rt), dm(t.dynamicLayoutVertexArray, S, Oe), q.emplaceBack(tr, tr + 2, tr + 1), q.emplaceBack(tr + 1, tr + 2, tr + 3), K.vertexLength += 4, K.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ct[0]), Ie !== n.length - 1 && fr === n[Ie + 1].sectionIndex || t.programConfigurations.populatePaintArrays(G.length, b, b.index, { imagePositions: {}, canonical: N, formattedSection: Ce && Ce[fr] });
            }
            t.placedSymbolArray.emplaceBack(S.x, S.y, ae, this.glyphOffsetArray.length - ae, me, I, E, S.segment, u ? u[0] : 0, u ? u[1] : 0, h[0], h[1], w, 0, false, 0, L);
          }
          _addCollisionDebugVertex(t, n, u, h, v, b) {
            return n.emplaceBack(0, 0), t.emplaceBack(u.x, u.y, h, v, Math.round(b.x), Math.round(b.y));
          }
          addCollisionDebugVertices(t, n, u, h, v, b, w) {
            const S = v.segments.prepareSegment(4, v.layoutVertexArray, v.indexArray), I = S.vertexLength, E = v.layoutVertexArray, L = v.collisionVertexArray, N = w.anchorX, q = w.anchorY;
            this._addCollisionDebugVertex(E, L, b, N, q, new C(t, n)), this._addCollisionDebugVertex(E, L, b, N, q, new C(u, n)), this._addCollisionDebugVertex(E, L, b, N, q, new C(u, h)), this._addCollisionDebugVertex(E, L, b, N, q, new C(t, h)), S.vertexLength += 4;
            const G = v.indexArray;
            G.emplaceBack(I, I + 1), G.emplaceBack(I + 1, I + 2), G.emplaceBack(I + 2, I + 3), G.emplaceBack(I + 3, I), S.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, u, h) {
            for (let v = t; v < n; v++) {
              const b = this.collisionBoxArray.get(v);
              this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, h ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, u);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fm(fi, Y0.members, si), this.iconCollisionBox = new fm(fi, Y0.members, si);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, false), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, u, h, v, b, w, S, I) {
            const E = {};
            for (let L = n; L < u; L++) {
              const N = t.get(L);
              E.textBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.textFeatureIndex = N.featureIndex;
              break;
            }
            for (let L = h; L < v; L++) {
              const N = t.get(L);
              E.verticalTextBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.verticalTextFeatureIndex = N.featureIndex;
              break;
            }
            for (let L = b; L < w; L++) {
              const N = t.get(L);
              E.iconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.iconFeatureIndex = N.featureIndex;
              break;
            }
            for (let L = S; L < I; L++) {
              const N = t.get(L);
              E.verticalIconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, E.verticalIconFeatureIndex = N.featureIndex;
              break;
            }
            return E;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const u = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const u = t.placedSymbolArray.get(n), h = u.vertexStartIndex + 4 * u.numGlyphs;
            for (let v = u.vertexStartIndex; v < h; v += 4) t.indexArray.emplaceBack(v, v + 2, v + 1), t.indexArray.emplaceBack(v + 1, v + 2, v + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), u = Math.cos(t), h = [], v = [], b = [];
            for (let w = 0; w < this.symbolInstances.length; ++w) {
              b.push(w);
              const S = this.symbolInstances.get(w);
              h.push(0 | Math.round(n * S.anchorX + u * S.anchorY)), v.push(S.featureIndex);
            }
            return b.sort(((w, S) => h[w] - h[S] || v[S] - v[w])), b;
          }
          addToSortKeyRanges(t, n) {
            const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            u && u.sortKey === n ? u.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const u = this.symbolInstances.get(n);
                this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach(((h, v, b) => {
                  h >= 0 && b.indexOf(h) === v && this.addIndicesForPlacedSymbol(this.text, h);
                })), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let cv, dv;
        Ot("SymbolBucket", Fu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Fu.MAX_GLYPHS = 65535, Fu.addDynamicAttributes = dm;
        var pm = { get paint() {
          return dv = dv || new sn({ "icon-opacity": new er(Te.paint_symbol["icon-opacity"]), "icon-color": new er(Te.paint_symbol["icon-color"]), "icon-halo-color": new er(Te.paint_symbol["icon-halo-color"]), "icon-halo-width": new er(Te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new er(Te.paint_symbol["icon-halo-blur"]), "icon-translate": new Wt(Te.paint_symbol["icon-translate"]), "icon-translate-anchor": new Wt(Te.paint_symbol["icon-translate-anchor"]), "text-opacity": new er(Te.paint_symbol["text-opacity"]), "text-color": new er(Te.paint_symbol["text-color"], { runtimeType: ei, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }), "text-halo-color": new er(Te.paint_symbol["text-halo-color"]), "text-halo-width": new er(Te.paint_symbol["text-halo-width"]), "text-halo-blur": new er(Te.paint_symbol["text-halo-blur"]), "text-translate": new Wt(Te.paint_symbol["text-translate"]), "text-translate-anchor": new Wt(Te.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return cv = cv || new sn({ "symbol-placement": new Wt(Te.layout_symbol["symbol-placement"]), "symbol-spacing": new Wt(Te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Wt(Te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new er(Te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Wt(Te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Wt(Te.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Wt(Te.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Wt(Te.layout_symbol["icon-ignore-placement"]), "icon-optional": new Wt(Te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Wt(Te.layout_symbol["icon-rotation-alignment"]), "icon-size": new er(Te.layout_symbol["icon-size"]), "icon-text-fit": new Wt(Te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Wt(Te.layout_symbol["icon-text-fit-padding"]), "icon-image": new er(Te.layout_symbol["icon-image"]), "icon-rotate": new er(Te.layout_symbol["icon-rotate"]), "icon-padding": new er(Te.layout_symbol["icon-padding"]), "icon-keep-upright": new Wt(Te.layout_symbol["icon-keep-upright"]), "icon-offset": new er(Te.layout_symbol["icon-offset"]), "icon-anchor": new er(Te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Wt(Te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Wt(Te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Wt(Te.layout_symbol["text-rotation-alignment"]), "text-field": new er(Te.layout_symbol["text-field"]), "text-font": new er(Te.layout_symbol["text-font"]), "text-size": new er(Te.layout_symbol["text-size"]), "text-max-width": new er(Te.layout_symbol["text-max-width"]), "text-line-height": new Wt(Te.layout_symbol["text-line-height"]), "text-letter-spacing": new er(Te.layout_symbol["text-letter-spacing"]), "text-justify": new er(Te.layout_symbol["text-justify"]), "text-radial-offset": new er(Te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Wt(Te.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new er(Te.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new er(Te.layout_symbol["text-anchor"]), "text-max-angle": new Wt(Te.layout_symbol["text-max-angle"]), "text-writing-mode": new Wt(Te.layout_symbol["text-writing-mode"]), "text-rotate": new er(Te.layout_symbol["text-rotate"]), "text-padding": new Wt(Te.layout_symbol["text-padding"]), "text-keep-upright": new Wt(Te.layout_symbol["text-keep-upright"]), "text-transform": new er(Te.layout_symbol["text-transform"]), "text-offset": new er(Te.layout_symbol["text-offset"]), "text-allow-overlap": new Wt(Te.layout_symbol["text-allow-overlap"]), "text-overlap": new Wt(Te.layout_symbol["text-overlap"]), "text-ignore-placement": new Wt(Te.layout_symbol["text-ignore-placement"]), "text-optional": new Wt(Te.layout_symbol["text-optional"]) });
        } };
        class hv {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : Cr, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Ot("FormatSectionOverride", hv, { omit: ["defaultValue"] });
        class df extends so {
          constructor(t, n) {
            super(t, pm, n);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const u = this.layout.get("text-writing-mode");
              if (u) {
                const h = [];
                for (const v of u) h.indexOf(v) < 0 && h.push(v);
                this.layout._values["text-writing-mode"] = h;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, u, h) {
            const v = this.layout.get(t).evaluate(n, {}, u, h), b = this._unevaluatedLayout._values[t];
            return b.isDataDriven() || au(b.value) || !v ? v : (function(w, S) {
              return S.replace(/{([^{}]+)}/g, ((I, E) => w && E in w ? String(w[E]) : ""));
            })(n.properties, v);
          }
          createBucket(t) {
            return new Fu(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of pm.paint.overridableProperties) {
              if (!df.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), u = new hv(n), h = new Fc(u, n.property.specification);
              let v = null;
              v = n.value.kind === "constant" || n.value.kind === "source" ? new Js("source", h) : new Lc("composite", h, n.value.zoomStops), this.paint._values[t] = new Po(n.property, v, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return !(!this.layout || n.isDataDriven() || u.isDataDriven()) && df.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const u = t.get("text-field"), h = pm.paint.properties[n];
            let v = false;
            const b = (w) => {
              for (const S of w) if (h.overrides && h.overrides.hasOverride(S)) return void (v = true);
            };
            if (u.value.kind === "constant" && u.value.value instanceof mn) b(u.value.value.sections);
            else if (u.value.kind === "source" || u.value.kind === "composite") {
              const w = (I) => {
                v || (I instanceof zo && sr(I.value) === qn ? b(I.value.sections) : I instanceof Pa ? b(I.sections) : I.eachChild(w));
              }, S = u.value;
              S._styleExpression && w(S._styleExpression.expression);
            }
            return v;
          }
        }
        let fv;
        var ww = { get paint() {
          return fv = fv || new sn({ "background-color": new Wt(Te.paint_background["background-color"]), "background-pattern": new Xh(Te.paint_background["background-pattern"]), "background-opacity": new Wt(Te.paint_background["background-opacity"]) });
        } };
        class Cw extends so {
          constructor(t, n) {
            super(t, ww, n);
          }
        }
        let pv;
        var Sw = { get paint() {
          return pv = pv || new sn({ "raster-opacity": new Wt(Te.paint_raster["raster-opacity"]), "raster-hue-rotate": new Wt(Te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Wt(Te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Wt(Te.paint_raster["raster-brightness-max"]), "raster-saturation": new Wt(Te.paint_raster["raster-saturation"]), "raster-contrast": new Wt(Te.paint_raster["raster-contrast"]), "raster-resampling": new Wt(Te.paint_raster["raster-resampling"]), "raster-fade-duration": new Wt(Te.paint_raster["raster-fade-duration"]) });
        } };
        class kw extends so {
          constructor(t, n) {
            super(t, Sw, n);
          }
        }
        class Pw extends so {
          constructor(t, n) {
            super(t, {}, n), this.onAdd = (u) => {
              this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
            }, this.onRemove = (u) => {
              this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Tw {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Iw = { once: true }, mm = 63710088e-1;
        class gs {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new gs(zt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, u = this.lat * n, h = t.lat * n, v = Math.sin(u) * Math.sin(h) + Math.cos(u) * Math.cos(h) * Math.cos((t.lng - this.lng) * n);
            return mm * Math.acos(Math.min(v, 1));
          }
          static convert(t) {
            if (t instanceof gs) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new gs(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new gs(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const mv = 2 * Math.PI * mm;
        function gv(o) {
          return mv * Math.cos(o * Math.PI / 180);
        }
        function vv(o) {
          return (180 + o) / 360;
        }
        function yv(o) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o * Math.PI / 360))) / 360;
        }
        function _v(o, t) {
          return o / gv(t);
        }
        function gm(o) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90;
        }
        function bv(o, t) {
          return o * gv(gm(t));
        }
        class _d {
          constructor(t, n, u = 0) {
            this.x = +t, this.y = +n, this.z = +u;
          }
          static fromLngLat(t, n = 0) {
            const u = gs.convert(t);
            return new _d(vv(u.lng), yv(u.lat), _v(n, u.lat));
          }
          toLngLat() {
            return new gs(360 * this.x - 180, gm(this.y));
          }
          toAltitude() {
            return bv(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / mv * (t = gm(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function xv(o, t, n) {
          var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [o * u - 2 * Math.PI * 6378137 / 2, t * u - 2 * Math.PI * 6378137 / 2];
        }
        class vm {
          constructor(t, n, u) {
            if (!(function(h, v, b) {
              return !(h < 0 || h > 25 || b < 0 || b >= Math.pow(2, h) || v < 0 || v >= Math.pow(2, h));
            })(t, n, u)) throw new Error(`x=${n}, y=${u}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = u, this.key = Lu(0, t, t, n, u);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, u) {
            const h = (b = this.y, w = this.z, S = xv(256 * (v = this.x), 256 * (b = Math.pow(2, w) - b - 1), w), I = xv(256 * (v + 1), 256 * (b + 1), w), S[0] + "," + S[1] + "," + I[0] + "," + I[1]);
            var v, b, w, S, I;
            const E = (function(L, N, q) {
              let G, K = "";
              for (let ae = L; ae > 0; ae--) G = 1 << ae - 1, K += (N & G ? 1 : 0) + (q & G ? 2 : 0);
              return K;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, E).replace(/{bbox-epsg-3857}/g, h);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new C((t.x * n - this.x) * et, (t.y * n - this.y) * et);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class wv {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Lu(t, n.z, n.z, n.x, n.y);
          }
        }
        class lo {
          constructor(t, n, u, h, v) {
            if (this.terrainRttPosMatrix32f = null, t < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${u}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new vm(u, +h, +v), this.key = Lu(n, t, u, h, v);
          }
          clone() {
            return new lo(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new lo(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new lo(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - t;
            return t > this.canonical.z ? Lu(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Lu(this.wrap * +n, t, t, this.canonical.x >> u, this.canonical.y >> u);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return false;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - t.canonical.z;
            return !(n < 0) && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new lo(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, u = 2 * this.canonical.x, h = 2 * this.canonical.y;
            return [new lo(n, this.wrap, n, u, h), new lo(n, this.wrap, n, u + 1, h), new lo(n, this.wrap, n, u, h + 1), new lo(n, this.wrap, n, u + 1, h + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new lo(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new lo(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new wv(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new _d(t.x - this.wrap, t.y));
          }
        }
        function Lu(o, t, n, u, h) {
          (o *= 2) < 0 && (o = -1 * o - 1);
          const v = 1 << n;
          return (v * v * o + v * h + u).toString(36) + n.toString(36) + t.toString(36);
        }
        function bd(o, t) {
          return t ? o.properties[t] : o.id;
        }
        Ot("CanonicalTileID", vm), Ot("OverscaledTileID", lo, { omit: ["terrainRttPosMatrix32f"] });
        class ml {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const n = new ml();
            return n.extend(t(new C(this.minX, this.minY))), n.extend(t(new C(this.maxX, this.minY))), n.extend(t(new C(this.minX, this.maxY))), n.extend(t(new C(this.maxX, this.maxY))), n;
          }
          static fromPoints(t) {
            const n = new ml();
            for (const u of t) n.extend(u);
            return n;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class Cv {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const u = t[n];
              this._stringToNumber[u] = n, this._numberToString[n] = u;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class Sv {
          constructor(t, n, u, h, v) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = u, t._y = h, this.properties = t.properties, this.id = v;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class kv {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ba(et, 16, 0), this.grid3D = new Ba(et, 16, 0), this.featureIndexArray = new Ke(), this.promoteId = n;
          }
          insert(t, n, u, h, v, b) {
            const w = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(u, h, v);
            const S = b ? this.grid3D : this.grid;
            for (let I = 0; I < n.length; I++) {
              const E = n[I], L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let N = 0; N < E.length; N++) {
                const q = E[N];
                L[0] = Math.min(L[0], q.x), L[1] = Math.min(L[1], q.y), L[2] = Math.max(L[2], q.x), L[3] = Math.max(L[3], q.y);
              }
              L[0] < et && L[1] < et && L[2] >= 0 && L[3] >= 0 && S.insert(w, L[0], L[1], L[2], L[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new N0(new am(this.rawTileData)).layers, this.sourceLayerCoder = new Cv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, u, h) {
            this.loadVTLayers();
            const v = t.params, b = et / t.tileSize / t.scale, w = Da(v.filter, v.globalState), S = t.queryGeometry, I = t.queryPadding * b, E = ml.fromPoints(S), L = this.grid.query(E.minX - I, E.minY - I, E.maxX + I, E.maxY + I), N = ml.fromPoints(t.cameraQueryGeometry).expandBy(I), q = this.grid3D.query(N.minX, N.minY, N.maxX, N.maxY, ((ae, me, Oe, Ce) => (function(Ie, Ze, rt, vt, Dt) {
              for (const Et of Ie) if (Ze <= Et.x && rt <= Et.y && vt >= Et.x && Dt >= Et.y) return true;
              const Tt = [new C(Ze, rt), new C(Ze, Dt), new C(vt, Dt), new C(vt, rt)];
              if (Ie.length > 2) {
                for (const Et of Tt) if (Tu(Ie, Et)) return true;
              }
              for (let Et = 0; Et < Ie.length - 1; Et++) if (rx(Ie[Et], Ie[Et + 1], Tt)) return true;
              return false;
            })(t.cameraQueryGeometry, ae - I, me - I, Oe + I, Ce + I)));
            for (const ae of q) L.push(ae);
            L.sort(Mw);
            const G = {};
            let K;
            for (let ae = 0; ae < L.length; ae++) {
              const me = L[ae];
              if (me === K) continue;
              K = me;
              const Oe = this.featureIndexArray.get(me);
              let Ce = null;
              this.loadMatchingFeature(G, Oe.bucketIndex, Oe.sourceLayerIndex, Oe.featureIndex, w, v.layers, v.availableImages, n, u, h, ((Ie, Ze, rt) => (Ce || (Ce = dl(Ie)), Ze.queryIntersectsFeature({ queryGeometry: S, feature: Ie, featureState: rt, geometry: Ce, zoom: this.z, transform: t.transform, pixelsToTileUnits: b, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return G;
          }
          loadMatchingFeature(t, n, u, h, v, b, w, S, I, E, L) {
            const N = this.bucketLayerIDs[n];
            if (b && !N.some(((ae) => b.has(ae)))) return;
            const q = this.sourceLayerCoder.decode(u), G = this.vtLayers[q].feature(h);
            if (v.needGeometry) {
              const ae = hl(G, true);
              if (!v.filter(new Gr(this.tileID.overscaledZ), ae, this.tileID.canonical)) return;
            } else if (!v.filter(new Gr(this.tileID.overscaledZ), G)) return;
            const K = this.getId(G, q);
            for (let ae = 0; ae < N.length; ae++) {
              const me = N[ae];
              if (b && !b.has(me)) continue;
              const Oe = S[me];
              if (!Oe) continue;
              let Ce = {};
              K && E && (Ce = E.getState(Oe.sourceLayer || "_geojsonTileLayer", K));
              const Ie = It({}, I[me]);
              Ie.paint = Pv(Ie.paint, Oe.paint, G, Ce, w), Ie.layout = Pv(Ie.layout, Oe.layout, G, Ce, w);
              const Ze = !L || L(G, Oe, Ce);
              if (!Ze) continue;
              const rt = new Sv(G, this.z, this.x, this.y, K);
              rt.layer = Ie;
              let vt = t[me];
              vt === void 0 && (vt = t[me] = []), vt.push({ featureIndex: h, feature: rt, intersectionZ: Ze });
            }
          }
          lookupSymbolFeatures(t, n, u, h, v, b, w, S) {
            const I = {};
            this.loadVTLayers();
            const E = Da(v.filterSpec, v.globalState);
            for (const L of t) this.loadMatchingFeature(I, u, h, L, E, b, w, S, n);
            return I;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const u of n) if (t === u) return true;
            return false;
          }
          getId(t, n) {
            var u;
            let h = t.id;
            return this.promoteId && (h = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof h == "boolean" && (h = Number(h)), h === void 0 && (!((u = t.properties) === null || u === void 0) && u.cluster) && this.promoteId && (h = Number(t.properties.cluster_id))), h;
          }
        }
        function Pv(o, t, n, u, h) {
          return mr(o, ((v, b) => {
            const w = t instanceof _u ? t.get(b) : null;
            return w && w.evaluate ? w.evaluate(n, u, h) : w;
          }));
        }
        function Mw(o, t) {
          return t - o;
        }
        function Tv(o, t, n, u, h) {
          const v = [];
          for (let b = 0; b < o.length; b++) {
            const w = o[b];
            let S;
            for (let I = 0; I < w.length - 1; I++) {
              let E = w[I], L = w[I + 1];
              E.x < t && L.x < t || (E.x < t ? E = new C(t, E.y + (t - E.x) / (L.x - E.x) * (L.y - E.y))._round() : L.x < t && (L = new C(t, E.y + (t - E.x) / (L.x - E.x) * (L.y - E.y))._round()), E.y < n && L.y < n || (E.y < n ? E = new C(E.x + (n - E.y) / (L.y - E.y) * (L.x - E.x), n)._round() : L.y < n && (L = new C(E.x + (n - E.y) / (L.y - E.y) * (L.x - E.x), n)._round()), E.x >= u && L.x >= u || (E.x >= u ? E = new C(u, E.y + (u - E.x) / (L.x - E.x) * (L.y - E.y))._round() : L.x >= u && (L = new C(u, E.y + (u - E.x) / (L.x - E.x) * (L.y - E.y))._round()), E.y >= h && L.y >= h || (E.y >= h ? E = new C(E.x + (h - E.y) / (L.y - E.y) * (L.x - E.x), h)._round() : L.y >= h && (L = new C(E.x + (h - E.y) / (L.y - E.y) * (L.x - E.x), h)._round()), S && E.equals(S[S.length - 1]) || (S = [E], v.push(S)), S.push(L)))));
            }
          }
          return v;
        }
        Ot("FeatureIndex", kv, { omit: ["rawTileData", "sourceLayerCoder"] });
        class vs extends C {
          constructor(t, n, u, h) {
            super(t, n), this.angle = u, h !== void 0 && (this.segment = h);
          }
          clone() {
            return new vs(this.x, this.y, this.angle, this.segment);
          }
        }
        function Iv(o, t, n, u, h) {
          if (t.segment === void 0 || n === 0) return true;
          let v = t, b = t.segment + 1, w = 0;
          for (; w > -n / 2; ) {
            if (b--, b < 0) return false;
            w -= o[b].dist(v), v = o[b];
          }
          w += o[b].dist(o[b + 1]), b++;
          const S = [];
          let I = 0;
          for (; w < n / 2; ) {
            const E = o[b], L = o[b + 1];
            if (!L) return false;
            let N = o[b - 1].angleTo(E) - E.angleTo(L);
            for (N = Math.abs((N + 3 * Math.PI) % (2 * Math.PI) - Math.PI), S.push({ distance: w, angleDelta: N }), I += N; w - S[0].distance > u; ) I -= S.shift().angleDelta;
            if (I > h) return false;
            b++, w += E.dist(L);
          }
          return true;
        }
        function Mv(o) {
          let t = 0;
          for (let n = 0; n < o.length - 1; n++) t += o[n].dist(o[n + 1]);
          return t;
        }
        function Ev(o, t, n) {
          return o ? 0.6 * t * n : 0;
        }
        function Rv(o, t) {
          return Math.max(o ? o.right - o.left : 0, t ? t.right - t.left : 0);
        }
        function Ew(o, t, n, u, h, v) {
          const b = Ev(n, h, v), w = Rv(n, u) * v;
          let S = 0;
          const I = Mv(o) / 2;
          for (let E = 0; E < o.length - 1; E++) {
            const L = o[E], N = o[E + 1], q = L.dist(N);
            if (S + q > I) {
              const G = (I - S) / q, K = ko.number(L.x, N.x, G), ae = ko.number(L.y, N.y, G), me = new vs(K, ae, N.angleTo(L), E);
              return me._round(), !b || Iv(o, me, w, b, t) ? me : void 0;
            }
            S += q;
          }
        }
        function Rw(o, t, n, u, h, v, b, w, S) {
          const I = Ev(u, v, b), E = Rv(u, h), L = E * b, N = o[0].x === 0 || o[0].x === S || o[0].y === 0 || o[0].y === S;
          return t - L < t / 4 && (t = L + t / 4), Av(o, N ? t / 2 * w % t : (E / 2 + 2 * v) * b * w % t, t, I, n, L, N, false, S);
        }
        function Av(o, t, n, u, h, v, b, w, S) {
          const I = v / 2, E = Mv(o);
          let L = 0, N = t - n, q = [];
          for (let G = 0; G < o.length - 1; G++) {
            const K = o[G], ae = o[G + 1], me = K.dist(ae), Oe = ae.angleTo(K);
            for (; N + n < L + me; ) {
              N += n;
              const Ce = (N - L) / me, Ie = ko.number(K.x, ae.x, Ce), Ze = ko.number(K.y, ae.y, Ce);
              if (Ie >= 0 && Ie < S && Ze >= 0 && Ze < S && N - I >= 0 && N + I <= E) {
                const rt = new vs(Ie, Ze, Oe, G);
                rt._round(), u && !Iv(o, rt, v, u, h) || q.push(rt);
              }
            }
            L += me;
          }
          return w || q.length || b || (q = Av(o, L / 2, n, u, h, v, b, true, S)), q;
        }
        function Dv(o, t, n, u) {
          const h = [], v = o.image, b = v.pixelRatio, w = v.paddedRect.w - 2, S = v.paddedRect.h - 2;
          let I = { x1: o.left, y1: o.top, x2: o.right, y2: o.bottom };
          const E = v.stretchX || [[0, w]], L = v.stretchY || [[0, S]], N = (ct, lr) => ct + lr[1] - lr[0], q = E.reduce(N, 0), G = L.reduce(N, 0), K = w - q, ae = S - G;
          let me = 0, Oe = q, Ce = 0, Ie = G, Ze = 0, rt = K, vt = 0, Dt = ae;
          if (v.content && u) {
            const ct = v.content, lr = ct[2] - ct[0], fr = ct[3] - ct[1];
            (v.textFitWidth || v.textFitHeight) && (I = sv(o)), me = hf(E, 0, ct[0]), Ce = hf(L, 0, ct[1]), Oe = hf(E, ct[0], ct[2]), Ie = hf(L, ct[1], ct[3]), Ze = ct[0] - me, vt = ct[1] - Ce, rt = lr - Oe, Dt = fr - Ie;
          }
          const Tt = I.x1, Et = I.y1, Yt = I.x2 - Tt, Mt = I.y2 - Et, Rt = (ct, lr, fr, tr) => {
            const Gt = ff(ct.stretch - me, Oe, Yt, Tt), Ir = pf(ct.fixed - Ze, rt, ct.stretch, q), wi = ff(lr.stretch - Ce, Ie, Mt, Et), Bi = pf(lr.fixed - vt, Dt, lr.stretch, G), un = ff(fr.stretch - me, Oe, Yt, Tt), uo = pf(fr.fixed - Ze, rt, fr.stretch, q), $n = ff(tr.stretch - Ce, Ie, Mt, Et), Ki = pf(tr.fixed - vt, Dt, tr.stretch, G), gi = new C(Gt, wi), qi = new C(un, wi), Ji = new C(un, $n), Qi = new C(Gt, $n), Tn = new C(Ir / b, Bi / b), co = new C(uo / b, Ki / b), Gi = t * Math.PI / 180;
            if (Gi) {
              const Wi = Math.sin(Gi), Zi = Math.cos(Gi), Ai = [Zi, -Wi, Wi, Zi];
              gi._matMult(Ai), qi._matMult(Ai), Qi._matMult(Ai), Ji._matMult(Ai);
            }
            const jn = ct.stretch + ct.fixed, Oi = lr.stretch + lr.fixed;
            return { tl: gi, tr: qi, bl: Qi, br: Ji, tex: { x: v.paddedRect.x + 1 + jn, y: v.paddedRect.y + 1 + Oi, w: fr.stretch + fr.fixed - jn, h: tr.stretch + tr.fixed - Oi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Tn, pixelOffsetBR: co, minFontScaleX: rt / b / Yt, minFontScaleY: Dt / b / Mt, isSDF: n };
          };
          if (u && (v.stretchX || v.stretchY)) {
            const ct = zv(E, K, q), lr = zv(L, ae, G);
            for (let fr = 0; fr < ct.length - 1; fr++) {
              const tr = ct[fr], Gt = ct[fr + 1];
              for (let Ir = 0; Ir < lr.length - 1; Ir++) h.push(Rt(tr, lr[Ir], Gt, lr[Ir + 1]));
            }
          } else h.push(Rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: w + 1 }, { fixed: 0, stretch: S + 1 }));
          return h;
        }
        function hf(o, t, n) {
          let u = 0;
          for (const h of o) u += Math.max(t, Math.min(n, h[1])) - Math.max(t, Math.min(n, h[0]));
          return u;
        }
        function zv(o, t, n) {
          const u = [{ fixed: -1, stretch: 0 }];
          for (const [h, v] of o) {
            const b = u[u.length - 1];
            u.push({ fixed: h - b.stretch, stretch: b.stretch }), u.push({ fixed: h - b.stretch, stretch: b.stretch + (v - h) });
          }
          return u.push({ fixed: t + 1, stretch: n }), u;
        }
        function ff(o, t, n, u) {
          return o / t * n + u;
        }
        function pf(o, t, n, u) {
          return o - t * n / u;
        }
        Ot("Anchor", vs);
        class mf {
          constructor(t, n, u, h, v, b, w, S, I, E) {
            var L;
            if (this.boxStartIndex = t.length, I) {
              let N = b.top, q = b.bottom;
              const G = b.collisionPadding;
              G && (N -= G[1], q += G[3]);
              let K = q - N;
              K > 0 && (K = Math.max(10, K), this.circleDiameter = K);
            } else {
              const N = !((L = b.image) === null || L === void 0) && L.content && (b.image.textFitWidth || b.image.textFitHeight) ? sv(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
              N.y1 = N.y1 * w - S[0], N.y2 = N.y2 * w + S[2], N.x1 = N.x1 * w - S[3], N.x2 = N.x2 * w + S[1];
              const q = b.collisionPadding;
              if (q && (N.x1 -= q[0] * w, N.y1 -= q[1] * w, N.x2 += q[2] * w, N.y2 += q[3] * w), E) {
                const G = new C(N.x1, N.y1), K = new C(N.x2, N.y1), ae = new C(N.x1, N.y2), me = new C(N.x2, N.y2), Oe = E * Math.PI / 180;
                G._rotate(Oe), K._rotate(Oe), ae._rotate(Oe), me._rotate(Oe), N.x1 = Math.min(G.x, K.x, ae.x, me.x), N.x2 = Math.max(G.x, K.x, ae.x, me.x), N.y1 = Math.min(G.y, K.y, ae.y, me.y), N.y2 = Math.max(G.y, K.y, ae.y, me.y);
              }
              t.emplaceBack(n.x, n.y, N.x1, N.y1, N.x2, N.y2, u, h, v);
            }
            this.boxEndIndex = t.length;
          }
        }
        class Aw {
          constructor(t = [], n = (u, h) => u < h ? -1 : u > h ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: u } = this, h = n[t];
            for (; t > 0; ) {
              const v = t - 1 >> 1, b = n[v];
              if (u(h, b) >= 0) break;
              n[t] = b, t = v;
            }
            n[t] = h;
          }
          _down(t) {
            const { data: n, compare: u } = this, h = this.length >> 1, v = n[t];
            for (; t < h; ) {
              let b = 1 + (t << 1);
              const w = b + 1;
              if (w < this.length && u(n[w], n[b]) < 0 && (b = w), u(n[b], v) >= 0) break;
              n[t] = n[b], t = b;
            }
            n[t] = v;
          }
        }
        function Dw(o, t = 1, n = false) {
          const u = ml.fromPoints(o[0]), h = Math.min(u.width(), u.height());
          let v = h / 2;
          const b = new Aw([], zw), { minX: w, minY: S, maxX: I, maxY: E } = u;
          if (h === 0) return new C(w, S);
          for (let q = w; q < I; q += h) for (let G = S; G < E; G += h) b.push(new Bu(q + v, G + v, v, o));
          let L = (function(q) {
            let G = 0, K = 0, ae = 0;
            const me = q[0];
            for (let Oe = 0, Ce = me.length, Ie = Ce - 1; Oe < Ce; Ie = Oe++) {
              const Ze = me[Oe], rt = me[Ie], vt = Ze.x * rt.y - rt.x * Ze.y;
              K += (Ze.x + rt.x) * vt, ae += (Ze.y + rt.y) * vt, G += 3 * vt;
            }
            return new Bu(K / G, ae / G, 0, q);
          })(o), N = b.length;
          for (; b.length; ) {
            const q = b.pop();
            (q.d > L.d || !L.d) && (L = q, n && console.log("found best %d after %d probes", Math.round(1e4 * q.d) / 1e4, N)), q.max - L.d <= t || (v = q.h / 2, b.push(new Bu(q.p.x - v, q.p.y - v, v, o)), b.push(new Bu(q.p.x + v, q.p.y - v, v, o)), b.push(new Bu(q.p.x - v, q.p.y + v, v, o)), b.push(new Bu(q.p.x + v, q.p.y + v, v, o)), N += 4);
          }
          return n && (console.log(`num probes: ${N}`), console.log(`best distance: ${L.d}`)), L.p;
        }
        function zw(o, t) {
          return t.max - o.max;
        }
        function Bu(o, t, n, u) {
          this.p = new C(o, t), this.h = n, this.d = (function(h, v) {
            let b = false, w = 1 / 0;
            for (let S = 0; S < v.length; S++) {
              const I = v[S];
              for (let E = 0, L = I.length, N = L - 1; E < L; N = E++) {
                const q = I[E], G = I[N];
                q.y > h.y != G.y > h.y && h.x < (G.x - q.x) * (h.y - q.y) / (G.y - q.y) + q.x && (b = !b), w = Math.min(w, y0(h, q, G));
              }
            }
            return (b ? 1 : -1) * Math.sqrt(w);
          })(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
        var ln;
        m.aE = void 0, (ln = m.aE || (m.aE = {}))[ln.center = 1] = "center", ln[ln.left = 2] = "left", ln[ln.right = 3] = "right", ln[ln.top = 4] = "top", ln[ln.bottom = 5] = "bottom", ln[ln["top-left"] = 6] = "top-left", ln[ln["top-right"] = 7] = "top-right", ln[ln["bottom-left"] = 8] = "bottom-left", ln[ln["bottom-right"] = 9] = "bottom-right";
        const ym = Number.POSITIVE_INFINITY;
        function Fv(o, t) {
          return t[1] !== ym ? (function(n, u, h) {
            let v = 0, b = 0;
            switch (u = Math.abs(u), h = Math.abs(h), n) {
              case "top-right":
              case "top-left":
              case "top":
                b = h - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                b = 7 - h;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                v = -u;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                v = u;
            }
            return [v, b];
          })(o, t[0], t[1]) : (function(n, u) {
            let h = 0, v = 0;
            u < 0 && (u = 0);
            const b = u / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                v = b - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                v = 7 - b;
                break;
              case "bottom":
                v = 7 - u;
                break;
              case "top":
                v = u - 7;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                h = -b;
                break;
              case "top-left":
              case "bottom-left":
                h = b;
                break;
              case "left":
                h = u;
                break;
              case "right":
                h = -u;
            }
            return [h, v];
          })(o, t[0]);
        }
        function Lv(o, t, n) {
          var u;
          const h = o.layout, v = (u = h.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(t, {}, n);
          if (v) {
            const w = v.values, S = [];
            for (let I = 0; I < w.length; I += 2) {
              const E = S[I] = w[I], L = w[I + 1].map(((N) => N * Ui));
              E.startsWith("top") ? L[1] -= 7 : E.startsWith("bottom") && (L[1] += 7), S[I + 1] = L;
            }
            return new vn(S);
          }
          const b = h.get("text-variable-anchor");
          if (b) {
            let w;
            w = o._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [h.get("text-radial-offset").evaluate(t, {}, n) * Ui, ym] : h.get("text-offset").evaluate(t, {}, n).map(((I) => I * Ui));
            const S = [];
            for (const I of b) S.push(I, Fv(I, w));
            return new vn(S);
          }
          return null;
        }
        function _m(o) {
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Fw(o, t, n, u, h, v, b, w, S, I, E, L) {
          let N = v.textMaxSize.evaluate(t, {});
          N === void 0 && (N = b);
          const q = o.layers[0].layout, G = q.get("icon-offset").evaluate(t, {}, E), K = Ov(n.horizontal), ae = b / 24, me = o.tilePixelRatio * ae, Oe = o.tilePixelRatio * N / 24, Ce = o.tilePixelRatio * w, Ie = o.tilePixelRatio * q.get("symbol-spacing"), Ze = q.get("text-padding") * o.tilePixelRatio, rt = (function(fr, tr, Gt, Ir = 1) {
            const wi = fr.get("icon-padding").evaluate(tr, {}, Gt), Bi = wi && wi.values;
            return [Bi[0] * Ir, Bi[1] * Ir, Bi[2] * Ir, Bi[3] * Ir];
          })(q, t, E, o.tilePixelRatio), vt = q.get("text-max-angle") / 180 * Math.PI, Dt = q.get("text-rotation-alignment") !== "viewport" && q.get("symbol-placement") !== "point", Tt = q.get("icon-rotation-alignment") === "map" && q.get("symbol-placement") !== "point", Et = q.get("symbol-placement"), Yt = Ie / 2, Mt = q.get("icon-text-fit");
          let Rt;
          u && Mt !== "none" && (o.allowVerticalPlacement && n.vertical && (Rt = lv(u, n.vertical, Mt, q.get("icon-text-fit-padding"), G, ae)), K && (u = lv(u, K, Mt, q.get("icon-text-fit-padding"), G, ae)));
          const ct = E ? L.line.getGranularityForZoomLevel(E.z) : 1, lr = (fr, tr) => {
            tr.x < 0 || tr.x >= et || tr.y < 0 || tr.y >= et || (function(Gt, Ir, wi, Bi, un, uo, $n, Ki, gi, qi, Ji, Qi, Tn, co, Gi, jn, Oi, Wi, Zi, Ai, ui, jo, Ou, No, Ow) {
              const $u = Gt.addToLineVertexArray(Ir, wi);
              let gl, ju, Nu, Vu, Vv = 0, Uv = 0, qv = 0, Gv = 0, Tm = -1, Im = -1;
              const Wa = {};
              let Wv = Oo("");
              if (Gt.allowVerticalPlacement && Bi.vertical) {
                const bn = Ki.layout.get("text-rotate").evaluate(ui, {}, No) + 90;
                Nu = new mf(gi, Ir, qi, Ji, Qi, Bi.vertical, Tn, co, Gi, bn), $n && (Vu = new mf(gi, Ir, qi, Ji, Qi, $n, Oi, Wi, Gi, bn));
              }
              if (un) {
                const bn = Ki.layout.get("icon-rotate").evaluate(ui, {}), ho = Ki.layout.get("icon-text-fit") !== "none", vl = Dv(un, bn, Ou, ho), Uo = $n ? Dv($n, bn, Ou, ho) : void 0;
                ju = new mf(gi, Ir, qi, Ji, Qi, un, Oi, Wi, false, bn), Vv = 4 * vl.length;
                const yl = Gt.iconSizeData;
                let da = null;
                yl.kind === "source" ? (da = [Ga * Ki.layout.get("icon-size").evaluate(ui, {})], da[0] > ms && Ut(`${Gt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : yl.kind === "composite" && (da = [Ga * jo.compositeIconSizes[0].evaluate(ui, {}, No), Ga * jo.compositeIconSizes[1].evaluate(ui, {}, No)], (da[0] > ms || da[1] > ms) && Ut(`${Gt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Gt.addSymbols(Gt.icon, vl, da, Ai, Zi, ui, m.ao.none, Ir, $u.lineStartIndex, $u.lineLength, -1, No), Tm = Gt.icon.placedSymbolArray.length - 1, Uo && (Uv = 4 * Uo.length, Gt.addSymbols(Gt.icon, Uo, da, Ai, Zi, ui, m.ao.vertical, Ir, $u.lineStartIndex, $u.lineLength, -1, No), Im = Gt.icon.placedSymbolArray.length - 1);
              }
              const Zv = Object.keys(Bi.horizontal);
              for (const bn of Zv) {
                const ho = Bi.horizontal[bn];
                if (!gl) {
                  Wv = Oo(ho.text);
                  const Uo = Ki.layout.get("text-rotate").evaluate(ui, {}, No);
                  gl = new mf(gi, Ir, qi, Ji, Qi, ho, Tn, co, Gi, Uo);
                }
                const vl = ho.positionedLines.length === 1;
                if (qv += Bv(Gt, Ir, ho, uo, Ki, Gi, ui, jn, $u, Bi.vertical ? m.ao.horizontal : m.ao.horizontalOnly, vl ? Zv : [bn], Wa, Tm, jo, No), vl) break;
              }
              Bi.vertical && (Gv += Bv(Gt, Ir, Bi.vertical, uo, Ki, Gi, ui, jn, $u, m.ao.vertical, ["vertical"], Wa, Im, jo, No));
              const $w = gl ? gl.boxStartIndex : Gt.collisionBoxArray.length, jw = gl ? gl.boxEndIndex : Gt.collisionBoxArray.length, Nw = Nu ? Nu.boxStartIndex : Gt.collisionBoxArray.length, Vw = Nu ? Nu.boxEndIndex : Gt.collisionBoxArray.length, Uw = ju ? ju.boxStartIndex : Gt.collisionBoxArray.length, qw = ju ? ju.boxEndIndex : Gt.collisionBoxArray.length, Gw = Vu ? Vu.boxStartIndex : Gt.collisionBoxArray.length, Ww = Vu ? Vu.boxEndIndex : Gt.collisionBoxArray.length;
              let Vo = -1;
              const vf = (bn, ho) => bn && bn.circleDiameter ? Math.max(bn.circleDiameter, ho) : ho;
              Vo = vf(gl, Vo), Vo = vf(Nu, Vo), Vo = vf(ju, Vo), Vo = vf(Vu, Vo);
              const Hv = Vo > -1 ? 1 : 0;
              Hv && (Vo *= Ow / Ui), Gt.glyphOffsetArray.length >= Fu.MAX_GLYPHS && Ut("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ui.sortKey !== void 0 && Gt.addToSortKeyRanges(Gt.symbolInstances.length, ui.sortKey);
              const Zw = Lv(Ki, ui, No), [Hw, Xw] = (function(bn, ho) {
                const vl = bn.length, Uo = ho == null ? void 0 : ho.values;
                if ((Uo == null ? void 0 : Uo.length) > 0) for (let yl = 0; yl < Uo.length; yl += 2) {
                  const da = Uo[yl + 1];
                  bn.emplaceBack(m.aE[Uo[yl]], da[0], da[1]);
                }
                return [vl, bn.length];
              })(Gt.textAnchorOffsets, Zw);
              Gt.symbolInstances.emplaceBack(Ir.x, Ir.y, Wa.right >= 0 ? Wa.right : -1, Wa.center >= 0 ? Wa.center : -1, Wa.left >= 0 ? Wa.left : -1, Wa.vertical || -1, Tm, Im, Wv, $w, jw, Nw, Vw, Uw, qw, Gw, Ww, qi, qv, Gv, Vv, Uv, Hv, 0, Tn, Vo, Hw, Xw);
            })(o, tr, fr, n, u, h, Rt, o.layers[0], o.collisionBoxArray, t.index, t.sourceLayerIndex, o.index, me, [Ze, Ze, Ze, Ze], Dt, S, Ce, rt, Tt, G, t, v, I, E, b);
          };
          if (Et === "line") for (const fr of Tv(t.geometry, 0, 0, et, et)) {
            const tr = pl(fr, ct), Gt = Rw(tr, Ie, vt, n.vertical || K, u, 24, Oe, o.overscaling, et);
            for (const Ir of Gt) K && Lw(o, K.text, Yt, Ir) || lr(tr, Ir);
          }
          else if (Et === "line-center") {
            for (const fr of t.geometry) if (fr.length > 1) {
              const tr = pl(fr, ct), Gt = Ew(tr, vt, n.vertical || K, u, 24, Oe);
              Gt && lr(tr, Gt);
            }
          } else if (t.type === "Polygon") for (const fr of Zs(t.geometry, 0)) {
            const tr = Dw(fr, 16);
            lr(pl(fr[0], ct, true), new vs(tr.x, tr.y, 0));
          }
          else if (t.type === "LineString") for (const fr of t.geometry) {
            const tr = pl(fr, ct);
            lr(tr, new vs(tr[0].x, tr[0].y, 0));
          }
          else if (t.type === "Point") for (const fr of t.geometry) for (const tr of fr) lr([tr], new vs(tr.x, tr.y, 0));
        }
        function Bv(o, t, n, u, h, v, b, w, S, I, E, L, N, q, G) {
          const K = (function(Oe, Ce, Ie, Ze, rt, vt, Dt, Tt) {
            const Et = Ze.layout.get("text-rotate").evaluate(vt, {}) * Math.PI / 180, Yt = [];
            for (const Mt of Ce.positionedLines) for (const Rt of Mt.positionedGlyphs) {
              if (!Rt.rect) continue;
              const ct = Rt.rect || {};
              let lr = 4, fr = true, tr = 1, Gt = 0;
              const Ir = (rt || Tt) && Rt.vertical, wi = Rt.metrics.advance * Rt.scale / 2;
              if (Tt && Ce.verticalizable && (Gt = Mt.lineOffset / 2 - (Rt.imageName ? -(Ui - Rt.metrics.width * Rt.scale) / 2 : (Rt.scale - 1) * Ui)), Rt.imageName) {
                const Wi = Dt[Rt.imageName];
                fr = Wi.sdf, tr = Wi.pixelRatio, lr = 1 / tr;
              }
              const Bi = rt ? [Rt.x + wi, Rt.y] : [0, 0];
              let un = rt ? [0, 0] : [Rt.x + wi + Ie[0], Rt.y + Ie[1] - Gt], uo = [0, 0];
              Ir && (uo = un, un = [0, 0]);
              const $n = Rt.metrics.isDoubleResolution ? 2 : 1, Ki = (Rt.metrics.left - lr) * Rt.scale - wi + un[0], gi = (-Rt.metrics.top - lr) * Rt.scale + un[1], qi = Ki + ct.w / $n * Rt.scale / tr, Ji = gi + ct.h / $n * Rt.scale / tr, Qi = new C(Ki, gi), Tn = new C(qi, gi), co = new C(Ki, Ji), Gi = new C(qi, Ji);
              if (Ir) {
                const Wi = new C(-wi, wi - -17), Zi = -Math.PI / 2, Ai = 12 - wi, ui = new C(22 - Ai, -(Rt.imageName ? Ai : 0)), jo = new C(...uo);
                Qi._rotateAround(Zi, Wi)._add(ui)._add(jo), Tn._rotateAround(Zi, Wi)._add(ui)._add(jo), co._rotateAround(Zi, Wi)._add(ui)._add(jo), Gi._rotateAround(Zi, Wi)._add(ui)._add(jo);
              }
              if (Et) {
                const Wi = Math.sin(Et), Zi = Math.cos(Et), Ai = [Zi, -Wi, Wi, Zi];
                Qi._matMult(Ai), Tn._matMult(Ai), co._matMult(Ai), Gi._matMult(Ai);
              }
              const jn = new C(0, 0), Oi = new C(0, 0);
              Yt.push({ tl: Qi, tr: Tn, bl: co, br: Gi, tex: ct, writingMode: Ce.writingMode, glyphOffset: Bi, sectionIndex: Rt.sectionIndex, isSDF: fr, pixelOffsetTL: jn, pixelOffsetBR: Oi, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Yt;
          })(0, n, w, h, v, b, u, o.allowVerticalPlacement), ae = o.textSizeData;
          let me = null;
          ae.kind === "source" ? (me = [Ga * h.layout.get("text-size").evaluate(b, {})], me[0] > ms && Ut(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ae.kind === "composite" && (me = [Ga * q.compositeTextSizes[0].evaluate(b, {}, G), Ga * q.compositeTextSizes[1].evaluate(b, {}, G)], (me[0] > ms || me[1] > ms) && Ut(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), o.addSymbols(o.text, K, me, w, v, b, I, t, S.lineStartIndex, S.lineLength, N, G);
          for (const Oe of E) L[Oe] = o.text.placedSymbolArray.length - 1;
          return 4 * K.length;
        }
        function Ov(o) {
          for (const t in o) return o[t];
          return null;
        }
        function Lw(o, t, n, u) {
          const h = o.compareText;
          if (t in h) {
            const v = h[t];
            for (let b = v.length - 1; b >= 0; b--) if (u.dist(v[b]) < n) return true;
          } else h[t] = [];
          return h[t].push(u), false;
        }
        const $v = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class bm {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, u] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const h = u >> 4;
            if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
            const v = $v[15 & u];
            if (!v) throw new Error("Unrecognized array type.");
            const [b] = new Uint16Array(t, 2, 1), [w] = new Uint32Array(t, 4, 1);
            return new bm(w, b, v, t);
          }
          constructor(t, n = 64, u = Float64Array, h) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = u, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const v = $v.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, w = t * this.IndexArrayType.BYTES_PER_ELEMENT, S = (8 - w % 8) % 8;
            if (v < 0) throw new Error(`Unexpected typed array class: ${u}.`);
            h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 2 * t, this._finished = true) : (this.data = new ArrayBuffer(8 + b + w + S), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + v]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const u = this._pos >> 1;
            return this.ids[u] = u, this.coords[this._pos++] = t, this.coords[this._pos++] = n, u;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return xm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t, n, u, h) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: v, coords: b, nodeSize: w } = this, S = [0, v.length - 1, 0], I = [];
            for (; S.length; ) {
              const E = S.pop() || 0, L = S.pop() || 0, N = S.pop() || 0;
              if (L - N <= w) {
                for (let ae = N; ae <= L; ae++) {
                  const me = b[2 * ae], Oe = b[2 * ae + 1];
                  me >= t && me <= u && Oe >= n && Oe <= h && I.push(v[ae]);
                }
                continue;
              }
              const q = N + L >> 1, G = b[2 * q], K = b[2 * q + 1];
              G >= t && G <= u && K >= n && K <= h && I.push(v[q]), (E === 0 ? t <= G : n <= K) && (S.push(N), S.push(q - 1), S.push(1 - E)), (E === 0 ? u >= G : h >= K) && (S.push(q + 1), S.push(L), S.push(1 - E));
            }
            return I;
          }
          within(t, n, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: h, coords: v, nodeSize: b } = this, w = [0, h.length - 1, 0], S = [], I = u * u;
            for (; w.length; ) {
              const E = w.pop() || 0, L = w.pop() || 0, N = w.pop() || 0;
              if (L - N <= b) {
                for (let ae = N; ae <= L; ae++) Nv(v[2 * ae], v[2 * ae + 1], t, n) <= I && S.push(h[ae]);
                continue;
              }
              const q = N + L >> 1, G = v[2 * q], K = v[2 * q + 1];
              Nv(G, K, t, n) <= I && S.push(h[q]), (E === 0 ? t - u <= G : n - u <= K) && (w.push(N), w.push(q - 1), w.push(1 - E)), (E === 0 ? t + u >= G : n + u >= K) && (w.push(q + 1), w.push(L), w.push(1 - E));
            }
            return S;
          }
        }
        function xm(o, t, n, u, h, v) {
          if (h - u <= n) return;
          const b = u + h >> 1;
          jv(o, t, b, u, h, v), xm(o, t, n, u, b - 1, 1 - v), xm(o, t, n, b + 1, h, 1 - v);
        }
        function jv(o, t, n, u, h, v) {
          for (; h > u; ) {
            if (h - u > 600) {
              const I = h - u + 1, E = n - u + 1, L = Math.log(I), N = 0.5 * Math.exp(2 * L / 3), q = 0.5 * Math.sqrt(L * N * (I - N) / I) * (E - I / 2 < 0 ? -1 : 1);
              jv(o, t, n, Math.max(u, Math.floor(n - E * N / I + q)), Math.min(h, Math.floor(n + (I - E) * N / I + q)), v);
            }
            const b = t[2 * n + v];
            let w = u, S = h;
            for (xd(o, t, u, n), t[2 * h + v] > b && xd(o, t, u, h); w < S; ) {
              for (xd(o, t, w, S), w++, S--; t[2 * w + v] < b; ) w++;
              for (; t[2 * S + v] > b; ) S--;
            }
            t[2 * u + v] === b ? xd(o, t, u, S) : (S++, xd(o, t, S, h)), S <= n && (u = S + 1), n <= S && (h = S - 1);
          }
        }
        function xd(o, t, n, u) {
          wm(o, n, u), wm(t, 2 * n, 2 * u), wm(t, 2 * n + 1, 2 * u + 1);
        }
        function wm(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Nv(o, t, n, u) {
          const h = o - n, v = t - u;
          return h * h + v * v;
        }
        var Cm;
        m.cx = void 0, (Cm = m.cx || (m.cx = {})).create = "create", Cm.load = "load", Cm.fullLoad = "fullLoad";
        let gf = null, wd = [];
        const Sm = 1e3 / 60, km = "loadTime", Pm = "fullLoadTime", Bw = { mark(o) {
          performance.mark(o);
        }, frame(o) {
          const t = o;
          gf != null && wd.push(t - gf), gf = t;
        }, clearMetrics() {
          gf = null, wd = [], performance.clearMeasures(km), performance.clearMeasures(Pm);
          for (const o in m.cx) performance.clearMarks(m.cx[o]);
        }, getPerformanceMetrics() {
          performance.measure(km, m.cx.create, m.cx.load), performance.measure(Pm, m.cx.create, m.cx.fullLoad);
          const o = performance.getEntriesByName(km)[0].duration, t = performance.getEntriesByName(Pm)[0].duration, n = wd.length, u = 1 / (wd.reduce(((v, b) => v + b), 0) / n / 1e3), h = wd.filter(((v) => v > Sm)).reduce(((v, b) => v + (b - Sm) / Sm), 0);
          return { loadTime: o, fullLoadTime: t, fps: u, percentDroppedFrames: h / (n + h) * 100, totalFrames: n };
        } };
        m.$ = et, m.A = ie, m.B = function([o, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: o * Math.cos(t) * Math.sin(n), y: o * Math.sin(t) * Math.sin(n), z: o * Math.cos(n) };
        }, m.C = ko, m.D = Wt, m.E = xt, m.F = Gr, m.G = Op, m.H = function(o) {
          if (Ct == null) {
            const t = o.navigator ? o.navigator.userAgent : null;
            Ct = !!o.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Ct;
        }, m.I = sm, m.J = class {
          constructor(o, t) {
            this.target = o, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Tw((() => this.process())), this.subscription = bt(this.target, "message", ((n) => this.receive(n)), false), this.globalScope = wr(self) ? o : window;
          }
          registerMessageHandler(o, t) {
            this.messageHandlers[o] = t;
          }
          sendAsync(o, t) {
            return new Promise(((n, u) => {
              const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), v = t ? bt(t.signal, "abort", (() => {
                v == null ? void 0 : v.unsubscribe(), delete this.resolveRejects[h];
                const S = { id: h, type: "<cancel>", origin: location.origin, targetMapId: o.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(S);
              }), Iw) : null;
              this.resolveRejects[h] = { resolve: (S) => {
                v == null ? void 0 : v.unsubscribe(), n(S);
              }, reject: (S) => {
                v == null ? void 0 : v.unsubscribe(), u(S);
              } };
              const b = [], w = Object.assign(Object.assign({}, o), { id: h, sourceMapId: this.mapId, origin: location.origin, data: Oa(o.data, b) });
              this.target.postMessage(w, { transfer: b });
            }));
          }
          receive(o) {
            const t = o.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const u = this.abortControllers[n];
                return delete this.abortControllers[n], void (u && u.abort());
              }
              if (wr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const o = this.taskQueue.shift(), t = this.tasks[o];
            delete this.tasks[o], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(o, t);
          }
          processTask(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const h = this.resolveRejects[o];
                return delete this.resolveRejects[o], h ? void (t.error ? h.reject(hs(t.error)) : h.resolve(hs(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(o, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = hs(t.data), u = new AbortController();
              this.abortControllers[o] = u;
              try {
                const h = yield this.messageHandlers[t.type](t.sourceMapId, n, u);
                this.completeTask(o, null, h);
              } catch (h) {
                this.completeTask(o, h);
              }
            }));
          }
          completeTask(o, t, n) {
            const u = [];
            delete this.abortControllers[o];
            const h = { id: o, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Oa(t) : null, data: Oa(n, u) };
            this.target.postMessage(h, { transfer: u });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, m.K = ne, m.L = function() {
          var o = new ie(16);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
        }, m.M = function(o, t, n) {
          var u, h, v, b, w, S, I, E, L, N, q, G, K = n[0], ae = n[1], me = n[2];
          return t === o ? (o[12] = t[0] * K + t[4] * ae + t[8] * me + t[12], o[13] = t[1] * K + t[5] * ae + t[9] * me + t[13], o[14] = t[2] * K + t[6] * ae + t[10] * me + t[14], o[15] = t[3] * K + t[7] * ae + t[11] * me + t[15]) : (h = t[1], v = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], L = t[8], N = t[9], q = t[10], G = t[11], o[0] = u = t[0], o[1] = h, o[2] = v, o[3] = b, o[4] = w, o[5] = S, o[6] = I, o[7] = E, o[8] = L, o[9] = N, o[10] = q, o[11] = G, o[12] = u * K + w * ae + L * me + t[12], o[13] = h * K + S * ae + N * me + t[13], o[14] = v * K + I * ae + q * me + t[14], o[15] = b * K + E * ae + G * me + t[15]), o;
        }, m.N = function(o, t, n) {
          var u = n[0], h = n[1], v = n[2];
          return o[0] = t[0] * u, o[1] = t[1] * u, o[2] = t[2] * u, o[3] = t[3] * u, o[4] = t[4] * h, o[5] = t[5] * h, o[6] = t[6] * h, o[7] = t[7] * h, o[8] = t[8] * v, o[9] = t[9] * v, o[10] = t[10] * v, o[11] = t[11] * v, o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.O = function(o, t, n) {
          var u = t[0], h = t[1], v = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], L = t[8], N = t[9], q = t[10], G = t[11], K = t[12], ae = t[13], me = t[14], Oe = t[15], Ce = n[0], Ie = n[1], Ze = n[2], rt = n[3];
          return o[0] = Ce * u + Ie * w + Ze * L + rt * K, o[1] = Ce * h + Ie * S + Ze * N + rt * ae, o[2] = Ce * v + Ie * I + Ze * q + rt * me, o[3] = Ce * b + Ie * E + Ze * G + rt * Oe, o[4] = (Ce = n[4]) * u + (Ie = n[5]) * w + (Ze = n[6]) * L + (rt = n[7]) * K, o[5] = Ce * h + Ie * S + Ze * N + rt * ae, o[6] = Ce * v + Ie * I + Ze * q + rt * me, o[7] = Ce * b + Ie * E + Ze * G + rt * Oe, o[8] = (Ce = n[8]) * u + (Ie = n[9]) * w + (Ze = n[10]) * L + (rt = n[11]) * K, o[9] = Ce * h + Ie * S + Ze * N + rt * ae, o[10] = Ce * v + Ie * I + Ze * q + rt * me, o[11] = Ce * b + Ie * E + Ze * G + rt * Oe, o[12] = (Ce = n[12]) * u + (Ie = n[13]) * w + (Ze = n[14]) * L + (rt = n[15]) * K, o[13] = Ce * h + Ie * S + Ze * N + rt * ae, o[14] = Ce * v + Ie * I + Ze * q + rt * me, o[15] = Ce * b + Ie * E + Ze * G + rt * Oe, o;
        }, m.P = C, m.Q = function(o, t) {
          const n = {};
          for (let u = 0; u < t.length; u++) {
            const h = t[u];
            h in o && (n[h] = o[h]);
          }
          return n;
        }, m.R = On, m.S = gs, m.T = Kp, m.U = yv, m.V = vv, m.W = Y, m.X = W, m.Y = Be, m.Z = lo, m._ = s, m.a = Z, m.a$ = Ve, m.a0 = function(o, t) {
          var n, u, h, v, b;
          if (!o) return t ?? {};
          if (!t) return o;
          let w = Object.assign({}, o);
          if (t.removeAll && (w = { removeAll: true }), t.remove) {
            const S = new Set(t.remove);
            w.add && (w.add = w.add.filter(((E) => !S.has(E.id)))), w.update && (w.update = w.update.filter(((E) => !S.has(E.id))));
            const I = new Set(((n = o.add) !== null && n !== void 0 ? n : []).map(((E) => E.id)));
            t.remove = t.remove.filter(((E) => !I.has(E)));
          }
          if (t.remove) {
            const S = new Set(w.remove ? w.remove.concat(t.remove) : t.remove);
            w.remove = Array.from(S.values());
          }
          if (t.add) {
            const S = w.add ? w.add.concat(t.add) : t.add, I = new Map(S.map(((E) => [E.id, E])));
            w.add = Array.from(I.values());
          }
          if (t.update) {
            const S = new Map((u = w.update) === null || u === void 0 ? void 0 : u.map(((I) => [I.id, I])));
            for (const I of t.update) {
              const E = (h = S.get(I.id)) !== null && h !== void 0 ? h : { id: I.id };
              I.newGeometry && (E.newGeometry = I.newGeometry), I.addOrUpdateProperties && (E.addOrUpdateProperties = ((v = E.addOrUpdateProperties) !== null && v !== void 0 ? v : []).concat(I.addOrUpdateProperties)), I.removeProperties && (E.removeProperties = ((b = E.removeProperties) !== null && b !== void 0 ? b : []).concat(I.removeProperties)), I.removeAllProperties && (E.removeAllProperties = true), S.set(I.id, E);
            }
            w.update = Array.from(S.values());
          }
          return w.remove && w.add && (w.remove = w.remove.filter(((S) => w.add.findIndex(((I) => I.id === S)) === -1))), w;
        }, m.a1 = _d, m.a2 = ml, m.a3 = 25, m.a4 = vm, m.a5 = (o) => {
          const t = window.document.createElement("video");
          return t.muted = true, new Promise(((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const u of o) {
              const h = window.document.createElement("source");
              he(u) || (t.crossOrigin = "Anonymous"), h.src = u, t.appendChild(h);
            }
          }));
        }, m.a6 = de, m.a7 = function() {
          return At++;
        }, m.a8 = se, m.a9 = Fu, m.aA = function(o) {
          let t = 1 / 0, n = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (const v of o) t = Math.min(t, v.x), n = Math.min(n, v.y), u = Math.max(u, v.x), h = Math.max(h, v.y);
          return [t, n, u, h];
        }, m.aB = Ui, m.aC = dt, m.aD = function(o, t, n, u, h = false) {
          if (!n[0] && !n[1]) return [0, 0];
          const v = h ? u === "map" ? -o.bearingInRadians : 0 : u === "viewport" ? o.bearingInRadians : 0;
          if (v) {
            const b = Math.sin(v), w = Math.cos(v);
            n = [n[0] * w - n[1] * b, n[0] * b + n[1] * w];
          }
          return [h ? n[0] : dt(t, n[0], o.zoom), h ? n[1] : dt(t, n[1], o.zoom)];
        }, m.aF = cm, m.aG = _m, m.aH = um, m.aI = bm, m.aJ = xi, m.aK = af, m.aL = We, m.aM = xr, m.aN = Li, m.aO = zt, m.aP = mt, m.aQ = bv, m.aR = fe, m.aS = oe, m.aT = function(o) {
          var t = new ie(3);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t;
        }, m.aU = function(o, t, n) {
          return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], o;
        }, m.aV = function(o, t) {
          var n = t[0], u = t[1], h = t[2], v = n * n + u * u + h * h;
          return v > 0 && (v = 1 / Math.sqrt(v)), o[0] = t[0] * v, o[1] = t[1] * v, o[2] = t[2] * v, o;
        }, m.aW = _e, m.aX = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2];
        }, m.aY = function(o, t, n) {
          return o[0] = t[0] * n[0], o[1] = t[1] * n[1], o[2] = t[2] * n[2], o[3] = t[3] * n[3], o;
        }, m.aZ = Se, m.a_ = function(o, t, n) {
          const u = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return u === 0 ? null : (-(o[0] * n[0] + o[1] * n[1] + o[2] * n[2]) - n[3]) / u;
        }, m.aa = Da, m.ab = hl, m.ac = Sv, m.ad = function(o) {
          const t = {};
          if (o.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, u, h, v) => {
            const b = h || v;
            return t[u] = !b || b.toLowerCase(), "";
          })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, m.ae = tt, m.af = function(o) {
          return Math.pow(2, o);
        }, m.ag = re, m.ah = Lt, m.ai = 85.051129, m.aj = _v, m.ak = function(o) {
          return Math.log(o) / Math.LN2;
        }, m.al = function(o) {
          var t = o[0], n = o[1];
          return t * t + n * n;
        }, m.am = function(o, t) {
          const n = [];
          for (const u in o) u in t || n.push(u);
          return n;
        }, m.an = function(o, t) {
          let n = 0, u = 0;
          if (o.kind === "constant") u = o.layoutSize;
          else if (o.kind !== "source") {
            const { interpolationType: h, minZoom: v, maxZoom: b } = o, w = h ? Lt(Xi.interpolationFactor(h, t, v, b), 0, 1) : 0;
            o.kind === "camera" ? u = ko.number(o.minSize, o.maxSize, w) : n = w;
          }
          return { uSizeT: n, uSize: u };
        }, m.ap = function(o, { uSize: t, uSizeT: n }, { lowerSize: u, upperSize: h }) {
          return o.kind === "source" ? u / Ga : o.kind === "composite" ? ko.number(u / Ga, h / Ga, n) : t;
        }, m.aq = function(o, t) {
          var n = t[0], u = t[1], h = t[2], v = t[3], b = t[4], w = t[5], S = t[6], I = t[7], E = t[8], L = t[9], N = t[10], q = t[11], G = t[12], K = t[13], ae = t[14], me = t[15], Oe = n * w - u * b, Ce = n * S - h * b, Ie = n * I - v * b, Ze = u * S - h * w, rt = u * I - v * w, vt = h * I - v * S, Dt = E * K - L * G, Tt = E * ae - N * G, Et = E * me - q * G, Yt = L * ae - N * K, Mt = L * me - q * K, Rt = N * me - q * ae, ct = Oe * Rt - Ce * Mt + Ie * Yt + Ze * Et - rt * Tt + vt * Dt;
          return ct ? (o[0] = (w * Rt - S * Mt + I * Yt) * (ct = 1 / ct), o[1] = (h * Mt - u * Rt - v * Yt) * ct, o[2] = (K * vt - ae * rt + me * Ze) * ct, o[3] = (N * rt - L * vt - q * Ze) * ct, o[4] = (S * Et - b * Rt - I * Tt) * ct, o[5] = (n * Rt - h * Et + v * Tt) * ct, o[6] = (ae * Ie - G * vt - me * Ce) * ct, o[7] = (E * vt - N * Ie + q * Ce) * ct, o[8] = (b * Mt - w * Et + I * Dt) * ct, o[9] = (u * Et - n * Mt - v * Dt) * ct, o[10] = (G * rt - K * Ie + me * Oe) * ct, o[11] = (L * Ie - E * rt - q * Oe) * ct, o[12] = (w * Tt - b * Yt - S * Dt) * ct, o[13] = (n * Yt - u * Tt + h * Dt) * ct, o[14] = (K * Ce - G * Ze - ae * Oe) * ct, o[15] = (E * Ze - L * Ce + N * Oe) * ct, o) : null;
        }, m.ar = yt, m.as = function(o) {
          var t = o[0], n = o[1];
          return Math.sqrt(t * t + n * n);
        }, m.at = function(o) {
          return o[0] = 0, o[1] = 0, o;
        }, m.au = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o;
        }, m.av = dm, m.aw = Qe, m.ax = function(o, t, n, u) {
          const h = t.y - o.y, v = t.x - o.x, b = u.y - n.y, w = u.x - n.x, S = b * v - w * h;
          if (S === 0) return null;
          const I = (w * (o.y - n.y) - b * (o.x - n.x)) / S;
          return new C(o.x + I * v, o.y + I * h);
        }, m.ay = Tv, m.az = g0, m.b = Ee, m.b$ = class extends c {
        }, m.b0 = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o[3] = t[3] * n, o;
        }, m.b1 = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2] + o[3];
        }, m.b2 = wv, m.b3 = Lu, m.b4 = function(o, t, n, u, h) {
          var v = 1 / Math.tan(t / 2);
          if (o[0] = v / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = v, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, h != null && h !== 1 / 0) {
            var b = 1 / (u - h);
            o[10] = (h + u) * b, o[14] = 2 * h * u * b;
          } else o[10] = -1, o[14] = -2 * u;
          return o;
        }, m.b5 = function(o) {
          var t = new ie(16);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t[3] = o[3], t[4] = o[4], t[5] = o[5], t[6] = o[6], t[7] = o[7], t[8] = o[8], t[9] = o[9], t[10] = o[10], t[11] = o[11], t[12] = o[12], t[13] = o[13], t[14] = o[14], t[15] = o[15], t;
        }, m.b6 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), v = t[0], b = t[1], w = t[2], S = t[3], I = t[4], E = t[5], L = t[6], N = t[7];
          return t !== o && (o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = v * h + I * u, o[1] = b * h + E * u, o[2] = w * h + L * u, o[3] = S * h + N * u, o[4] = I * h - v * u, o[5] = E * h - b * u, o[6] = L * h - w * u, o[7] = N * h - S * u, o;
        }, m.b7 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), v = t[4], b = t[5], w = t[6], S = t[7], I = t[8], E = t[9], L = t[10], N = t[11];
          return t !== o && (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[4] = v * h + I * u, o[5] = b * h + E * u, o[6] = w * h + L * u, o[7] = S * h + N * u, o[8] = I * h - v * u, o[9] = E * h - b * u, o[10] = L * h - w * u, o[11] = N * h - S * u, o;
        }, m.b8 = function() {
          const o = new Float32Array(16);
          return re(o), o;
        }, m.b9 = function() {
          const o = new Float64Array(16);
          return re(o), o;
        }, m.bA = function(o, t) {
          const n = Ft(o, 360), u = Ft(t, 360), h = u - n, v = u > n ? h - 360 : h + 360;
          return Math.abs(h) < Math.abs(v) ? h : v;
        }, m.bB = function(o) {
          return o[0] = 0, o[1] = 0, o[2] = 0, o;
        }, m.bC = function(o, t, n, u) {
          const h = Math.sqrt(o * o + t * t), v = Math.sqrt(n * n + u * u);
          o /= h, t /= h, n /= v, u /= v;
          const b = Math.acos(o * n + t * u);
          return -t * n + o * u > 0 ? b : -b;
        }, m.bD = function(o, t) {
          const n = Ft(o, 2 * Math.PI), u = Ft(t, 2 * Math.PI);
          return Math.min(Math.abs(n - u), Math.abs(n - u + 2 * Math.PI), Math.abs(n - u - 2 * Math.PI));
        }, m.bE = function() {
          const o = {}, t = Te.$version;
          for (const n in Te.$root) {
            const u = Te.$root[n];
            if (u.required) {
              let h = null;
              h = n === "version" ? t : u.type === "array" ? [] : {}, h != null && (o[n] = h);
            }
          }
          return o;
        }, m.bF = Hc, m.bG = Pe, m.bH = function o(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return false;
            for (let u = 0; u < t.length; u++) if (!o(t[u], n[u])) return false;
            return true;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return false;
            for (const u in t) if (!o(t[u], n[u])) return false;
            return true;
          }
          return t === n;
        }, m.bI = function(o) {
          o = o.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < o.length; n++) t[o[n].id] = o[n];
          for (let n = 0; n < o.length; n++) "ref" in o[n] && (o[n] = or(o[n], t[o[n].ref]));
          return o;
        }, m.bJ = function(o, t) {
          if (o.type === "custom") return new Pw(o, t);
          switch (o.type) {
            case "background":
              return new Cw(o, t);
            case "circle":
              return new lx(o, t);
            case "color-relief":
              return new px(o, t);
            case "fill":
              return new Mx(o, t);
            case "fill-extrusion":
              return new jx(o, t);
            case "heatmap":
              return new cx(o, t);
            case "hillshade":
              return new hx(o, t);
            case "line":
              return new Zx(o, t);
            case "raster":
              return new kw(o, t);
            case "symbol":
              return new df(o, t);
          }
        }, m.bK = ir, m.bL = function(o, t) {
          if (!o) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!qt(o.version, t.version)) return [{ command: "setStyle", args: [t] }];
            qt(o.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), qt(o.state, t.state) || n.push({ command: "setGlobalState", args: [t.state] }), qt(o.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), qt(o.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), qt(o.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), qt(o.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), qt(o.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), qt(o.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), qt(o.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), qt(o.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), qt(o.light, t.light) || n.push({ command: "setLight", args: [t.light] }), qt(o.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), qt(o.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), qt(o.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const u = {}, h = [];
            (function(b, w, S, I) {
              let E;
              for (E in w = w || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, E) && (Object.prototype.hasOwnProperty.call(w, E) || Vr(E, S, I));
              for (E in w) Object.prototype.hasOwnProperty.call(w, E) && (Object.prototype.hasOwnProperty.call(b, E) ? qt(b[E], w[E]) || (b[E].type === "geojson" && w[E].type === "geojson" && ci(b, w, E) ? dr(S, { command: "setGeoJSONSourceData", args: [E, w[E].data] }) : Kr(E, w, S, I)) : Br(E, w, S));
            })(o.sources, t.sources, h, u);
            const v = [];
            o.layers && o.layers.forEach(((b) => {
              "source" in b && u[b.source] ? n.push({ command: "removeLayer", args: [b.id] }) : v.push(b);
            })), n = n.concat(h), (function(b, w, S) {
              w = w || [];
              const I = (b = b || []).map(Lr), E = w.map(Lr), L = b.reduce(Ur, {}), N = w.reduce(Ur, {}), q = I.slice(), G = /* @__PURE__ */ Object.create(null);
              let K, ae, me, Oe, Ce;
              for (let Ie = 0, Ze = 0; Ie < I.length; Ie++) K = I[Ie], Object.prototype.hasOwnProperty.call(N, K) ? Ze++ : (dr(S, { command: "removeLayer", args: [K] }), q.splice(q.indexOf(K, Ze), 1));
              for (let Ie = 0, Ze = 0; Ie < E.length; Ie++) K = E[E.length - 1 - Ie], q[q.length - 1 - Ie] !== K && (Object.prototype.hasOwnProperty.call(L, K) ? (dr(S, { command: "removeLayer", args: [K] }), q.splice(q.lastIndexOf(K, q.length - Ze), 1)) : Ze++, Oe = q[q.length - Ie], dr(S, { command: "addLayer", args: [N[K], Oe] }), q.splice(q.length - Ie, 0, K), G[K] = true);
              for (let Ie = 0; Ie < E.length; Ie++) if (K = E[Ie], ae = L[K], me = N[K], !G[K] && !qt(ae, me)) if (qt(ae.source, me.source) && qt(ae["source-layer"], me["source-layer"]) && qt(ae.type, me.type)) {
                for (Ce in di(ae.layout, me.layout, S, K, null, "setLayoutProperty"), di(ae.paint, me.paint, S, K, null, "setPaintProperty"), qt(ae.filter, me.filter) || dr(S, { command: "setFilter", args: [K, me.filter] }), qt(ae.minzoom, me.minzoom) && qt(ae.maxzoom, me.maxzoom) || dr(S, { command: "setLayerZoomRange", args: [K, me.minzoom, me.maxzoom] }), ae) Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? di(ae[Ce], me[Ce], S, K, Ce.slice(6), "setPaintProperty") : qt(ae[Ce], me[Ce]) || dr(S, { command: "setLayerProperty", args: [K, Ce, me[Ce]] }));
                for (Ce in me) Object.prototype.hasOwnProperty.call(me, Ce) && !Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? di(ae[Ce], me[Ce], S, K, Ce.slice(6), "setPaintProperty") : qt(ae[Ce], me[Ce]) || dr(S, { command: "setLayerProperty", args: [K, Ce, me[Ce]] }));
              } else dr(S, { command: "removeLayer", args: [K] }), Oe = q[q.lastIndexOf(K) + 1], dr(S, { command: "addLayer", args: [me, Oe] });
            })(v, t.layers, n);
          } catch (u) {
            console.warn("Unable to compute style diff:", u), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, m.bM = function(o) {
          const t = [], n = o.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), o.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), o.renderingMode && o.renderingMode !== "2d" && o.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, m.bN = mr, m.bO = gr, m.bP = class extends li {
          constructor(o, t) {
            super(o, t), this.current = 0;
          }
          set(o) {
            this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }, m.bQ = Jh, m.bR = class extends li {
          constructor(o, t) {
            super(o, t), this.current = Vp;
          }
          set(o) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, false, o);
            for (let t = 1; t < 16; t++) if (o[t] !== this.current[t]) {
              this.current = o, this.gl.uniformMatrix4fv(this.location, false, o);
              break;
            }
          }
        }, m.bS = Kh, m.bT = class extends li {
          constructor(o, t) {
            super(o, t), this.current = [0, 0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2]));
          }
        }, m.bU = class extends li {
          constructor(o, t) {
            super(o, t), this.current = [0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1]));
          }
        }, m.bV = te, m.bW = function(o, t) {
          var n = Math.sin(t), u = Math.cos(t);
          return o[0] = u, o[1] = n, o[2] = 0, o[3] = -n, o[4] = u, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
        }, m.bX = function(o, t, n) {
          var u = t[0], h = t[1], v = t[2];
          return o[0] = u * n[0] + h * n[3] + v * n[6], o[1] = u * n[1] + h * n[4] + v * n[7], o[2] = u * n[2] + h * n[5] + v * n[8], o;
        }, m.bY = function(o, t, n, u, h, v, b) {
          var w = 1 / (t - n), S = 1 / (u - h), I = 1 / (v - b);
          return o[0] = -2 * w, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * S, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * I, o[11] = 0, o[12] = (t + n) * w, o[13] = (h + u) * S, o[14] = (b + v) * I, o[15] = 1, o;
        }, m.bZ = class extends li {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(4 * o.length);
              for (let n = 0; n < o.length; n++) t[4 * n] = o[n].r, t[4 * n + 1] = o[n].g, t[4 * n + 2] = o[n].b, t[4 * n + 3] = o[n].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, m.b_ = class extends li {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(o);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, m.ba = function() {
          return new Float64Array(16);
        }, m.bb = function(o, t, n) {
          const u = new Float64Array(4);
          return gt(u, o, t - 90, n), u;
        }, m.bc = function(o, t, n, u) {
          var h, v, b, w, S, I = t[0], E = t[1], L = t[2], N = t[3], q = n[0], G = n[1], K = n[2], ae = n[3];
          return (v = I * q + E * G + L * K + N * ae) < 0 && (v = -v, q = -q, G = -G, K = -K, ae = -ae), 1 - v > ee ? (h = Math.acos(v), b = Math.sin(h), w = Math.sin((1 - u) * h) / b, S = Math.sin(u * h) / b) : (w = 1 - u, S = u), o[0] = w * I + S * q, o[1] = w * E + S * G, o[2] = w * L + S * K, o[3] = w * N + S * ae, o;
        }, m.bd = function(o) {
          const t = new Float64Array(9);
          var n, u, h, v, b, w, S, I, E, L, N, q, G, K, ae, me, Oe, Ce;
          L = (h = (u = o)[0]) * (S = h + h), N = (v = u[1]) * S, G = (b = u[2]) * S, K = b * (I = v + v), me = (w = u[3]) * S, Oe = w * I, Ce = w * (E = b + b), (n = t)[0] = 1 - (q = v * I) - (ae = b * E), n[3] = N - Ce, n[6] = G + Oe, n[1] = N + Ce, n[4] = 1 - L - ae, n[7] = K - me, n[2] = G - Oe, n[5] = K + me, n[8] = 1 - L - q;
          const Ie = mt(-Math.asin(Lt(t[2], -1, 1)));
          let Ze, rt;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (Ze = 0, rt = -mt(Math.atan2(t[3], t[4]))) : (Ze = mt(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), rt = mt(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: Ze, pitch: Ie + 90, bearing: rt };
        }, m.be = function(o, t) {
          return o.roll == t.roll && o.pitch == t.pitch && o.bearing == t.bearing;
        }, m.bf = br, m.bg = Su, m.bh = Ru, m.bi = fd, m.bj = Eu, m.bk = ft, m.bl = _t, m.bm = on, m.bn = function(o, t, n, u, h) {
          return ft(u, h, Lt((o - t) / (n - t), 0, 1));
        }, m.bo = Ft, m.bp = function() {
          return new Float64Array(3);
        }, m.bq = function(o, t, n, u) {
          return o[0] = t[0] + n[0] * u, o[1] = t[1] + n[1] * u, o[2] = t[2] + n[2] * u, o;
        }, m.br = gt, m.bs = function(o, t, n) {
          var u = n[0], h = n[1], v = n[2], b = n[3], w = t[0], S = t[1], I = t[2], E = h * I - v * S, L = v * w - u * I, N = u * S - h * w;
          return o[0] = w + b * (E += E) + h * (N += N) - v * (L += L), o[1] = S + b * L + v * E - u * N, o[2] = I + b * N + u * L - h * E, o;
        }, m.bt = function(o, t, n) {
          const u = (h = [o[0], o[1], o[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((E = h[8]) * (b = h[4]) - (w = h[5]) * (I = h[7])) + h[1] * (-E * (v = h[3]) + w * (S = h[6])) + h[2] * (I * v - b * S);
          var h, v, b, w, S, I, E;
          if (u === 0) return null;
          const L = _e([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]), N = _e([], [n[0], n[1], n[2]], [o[0], o[1], o[2]]), q = _e([], [o[0], o[1], o[2]], [t[0], t[1], t[2]]), G = fe([], L, -o[3]);
          return oe(G, G, fe([], N, -t[3])), oe(G, G, fe([], q, -n[3])), fe(G, G, 1 / u), G;
        }, m.bu = mm, m.bv = function() {
          return new Float64Array(4);
        }, m.bw = function(o, t, n, u) {
          var h = [], v = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], v[0] = h[0] * Math.cos(u) - h[1] * Math.sin(u), v[1] = h[0] * Math.sin(u) + h[1] * Math.cos(u), v[2] = h[2], o[0] = v[0] + n[0], o[1] = v[1] + n[1], o[2] = v[2] + n[2], o;
        }, m.bx = function(o, t, n, u) {
          var h = [], v = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], v[0] = h[0], v[1] = h[1] * Math.cos(u) - h[2] * Math.sin(u), v[2] = h[1] * Math.sin(u) + h[2] * Math.cos(u), o[0] = v[0] + n[0], o[1] = v[1] + n[1], o[2] = v[2] + n[2], o;
        }, m.by = function(o, t, n, u) {
          var h = [], v = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], v[0] = h[2] * Math.sin(u) + h[0] * Math.cos(u), v[1] = h[1], v[2] = h[2] * Math.cos(u) - h[0] * Math.sin(u), o[0] = v[0] + n[0], o[1] = v[1] + n[1], o[2] = v[2] + n[2], o;
        }, m.bz = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), v = t[0], b = t[1], w = t[2], S = t[3], I = t[8], E = t[9], L = t[10], N = t[11];
          return t !== o && (o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = v * h - I * u, o[1] = b * h - E * u, o[2] = w * h - L * u, o[3] = S * h - N * u, o[8] = v * u + I * h, o[9] = b * u + E * h, o[10] = w * u + L * h, o[11] = S * u + N * h, o;
        }, m.c = ze, m.c0 = Kx, m.c1 = class extends _ {
        }, m.c2 = Yp, m.c3 = function(o) {
          return o <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
        }, m.c4 = P0, m.c5 = function(o, t, n) {
          var u = t[0], h = t[1], v = t[2], b = n[3] * u + n[7] * h + n[11] * v + n[15];
          return o[0] = (n[0] * u + n[4] * h + n[8] * v + n[12]) / (b = b || 1), o[1] = (n[1] * u + n[5] * h + n[9] * v + n[13]) / b, o[2] = (n[2] * u + n[6] * h + n[10] * v + n[14]) / b, o;
        }, m.c6 = class extends Na {
        }, m.c7 = class extends $ {
        }, m.c8 = function(o, t) {
          return o[0] === t[0] && o[1] === t[1] && o[2] === t[2] && o[3] === t[3] && o[4] === t[4] && o[5] === t[5] && o[6] === t[6] && o[7] === t[7] && o[8] === t[8] && o[9] === t[9] && o[10] === t[10] && o[11] === t[11] && o[12] === t[12] && o[13] === t[13] && o[14] === t[14] && o[15] === t[15];
        }, m.c9 = function(o, t) {
          var n = o[0], u = o[1], h = o[2], v = o[3], b = o[4], w = o[5], S = o[6], I = o[7], E = o[8], L = o[9], N = o[10], q = o[11], G = o[12], K = o[13], ae = o[14], me = o[15], Oe = t[0], Ce = t[1], Ie = t[2], Ze = t[3], rt = t[4], vt = t[5], Dt = t[6], Tt = t[7], Et = t[8], Yt = t[9], Mt = t[10], Rt = t[11], ct = t[12], lr = t[13], fr = t[14], tr = t[15];
          return Math.abs(n - Oe) <= ee * Math.max(1, Math.abs(n), Math.abs(Oe)) && Math.abs(u - Ce) <= ee * Math.max(1, Math.abs(u), Math.abs(Ce)) && Math.abs(h - Ie) <= ee * Math.max(1, Math.abs(h), Math.abs(Ie)) && Math.abs(v - Ze) <= ee * Math.max(1, Math.abs(v), Math.abs(Ze)) && Math.abs(b - rt) <= ee * Math.max(1, Math.abs(b), Math.abs(rt)) && Math.abs(w - vt) <= ee * Math.max(1, Math.abs(w), Math.abs(vt)) && Math.abs(S - Dt) <= ee * Math.max(1, Math.abs(S), Math.abs(Dt)) && Math.abs(I - Tt) <= ee * Math.max(1, Math.abs(I), Math.abs(Tt)) && Math.abs(E - Et) <= ee * Math.max(1, Math.abs(E), Math.abs(Et)) && Math.abs(L - Yt) <= ee * Math.max(1, Math.abs(L), Math.abs(Yt)) && Math.abs(N - Mt) <= ee * Math.max(1, Math.abs(N), Math.abs(Mt)) && Math.abs(q - Rt) <= ee * Math.max(1, Math.abs(q), Math.abs(Rt)) && Math.abs(G - ct) <= ee * Math.max(1, Math.abs(G), Math.abs(ct)) && Math.abs(K - lr) <= ee * Math.max(1, Math.abs(K), Math.abs(lr)) && Math.abs(ae - fr) <= ee * Math.max(1, Math.abs(ae), Math.abs(fr)) && Math.abs(me - tr) <= ee * Math.max(1, Math.abs(me), Math.abs(tr));
        }, m.cA = function(o, t) {
          Z.REGISTERED_PROTOCOLS[o] = t;
        }, m.cB = function(o) {
          delete Z.REGISTERED_PROTOCOLS[o];
        }, m.cC = function(o, t) {
          const n = {};
          for (let h = 0; h < o.length; h++) {
            const v = t && t[o[h].id] || Dh(o[h]);
            t && (t[o[h].id] = v);
            let b = n[v];
            b || (b = n[v] = []), b.push(o[h]);
          }
          const u = [];
          for (const h in n) u.push(n[h]);
          return u;
        }, m.cD = Ot, m.cE = Cv, m.cF = kv, m.cG = tv, m.cH = function(o) {
          o.bucket.createArrays(), o.bucket.tilePixelRatio = et / (512 * o.bucket.overscaling), o.bucket.compareText = {}, o.bucket.iconsNeedLinear = false;
          const t = o.bucket.layers[0], n = t.layout, u = t._unevaluatedLayout._values, h = { layoutIconSize: u["icon-size"].possiblyEvaluate(new Gr(o.bucket.zoom + 1), o.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new Gr(o.bucket.zoom + 1), o.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new Gr(18)) };
          if (o.bucket.textSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.textSizeData;
            h.compositeTextSizes = [u["text-size"].possiblyEvaluate(new Gr(I), o.canonical), u["text-size"].possiblyEvaluate(new Gr(E), o.canonical)];
          }
          if (o.bucket.iconSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.iconSizeData;
            h.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new Gr(I), o.canonical), u["icon-size"].possiblyEvaluate(new Gr(E), o.canonical)];
          }
          const v = n.get("text-line-height") * Ui, b = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", w = n.get("text-keep-upright"), S = n.get("text-size");
          for (const I of o.bucket.features) {
            const E = n.get("text-font").evaluate(I, {}, o.canonical).join(","), L = S.evaluate(I, {}, o.canonical), N = h.layoutTextSize.evaluate(I, {}, o.canonical), q = h.layoutIconSize.evaluate(I, {}, o.canonical), G = { horizontal: {}, vertical: void 0 }, K = I.text;
            let ae, me = [0, 0];
            if (K) {
              const Ie = K.toString(), Ze = n.get("text-letter-spacing").evaluate(I, {}, o.canonical) * Ui, rt = Vh(Ie) ? Ze : 0, vt = n.get("text-anchor").evaluate(I, {}, o.canonical), Dt = Lv(t, I, o.canonical);
              if (!Dt) {
                const Mt = n.get("text-radial-offset").evaluate(I, {}, o.canonical);
                me = Mt ? Fv(vt, [Mt * Ui, ym]) : n.get("text-offset").evaluate(I, {}, o.canonical).map(((Rt) => Rt * Ui));
              }
              let Tt = b ? "center" : n.get("text-justify").evaluate(I, {}, o.canonical);
              const Et = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(I, {}, o.canonical) * Ui : 1 / 0, Yt = () => {
                o.bucket.allowVerticalPlacement && Xc(Ie) && (G.vertical = lf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, v, vt, "left", rt, me, m.ao.vertical, true, N, L));
              };
              if (!b && Dt) {
                const Mt = /* @__PURE__ */ new Set();
                if (Tt === "auto") for (let ct = 0; ct < Dt.values.length; ct += 2) Mt.add(_m(Dt.values[ct]));
                else Mt.add(Tt);
                let Rt = false;
                for (const ct of Mt) if (!G.horizontal[ct]) if (Rt) G.horizontal[ct] = G.horizontal[0];
                else {
                  const lr = lf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, v, "center", ct, rt, me, m.ao.horizontal, false, N, L);
                  lr && (G.horizontal[ct] = lr, Rt = lr.positionedLines.length === 1);
                }
                Yt();
              } else {
                Tt === "auto" && (Tt = _m(vt));
                const Mt = lf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, v, vt, Tt, rt, me, m.ao.horizontal, false, N, L);
                Mt && (G.horizontal[Tt] = Mt), Yt(), Xc(Ie) && b && w && (G.vertical = lf(K, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, v, vt, Tt, rt, me, m.ao.vertical, false, N, L));
              }
            }
            let Oe = false;
            if (I.icon && I.icon.name) {
              const Ie = o.imageMap[I.icon.name];
              Ie && (ae = _w(o.imagePositions[I.icon.name], n.get("icon-offset").evaluate(I, {}, o.canonical), n.get("icon-anchor").evaluate(I, {}, o.canonical)), Oe = !!Ie.sdf, o.bucket.sdfIcons === void 0 ? o.bucket.sdfIcons = Oe : o.bucket.sdfIcons !== Oe && Ut("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ie.pixelRatio !== o.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (o.bucket.iconsNeedLinear = true));
            }
            const Ce = Ov(G.horizontal) || G.vertical;
            o.bucket.iconsInText = !!Ce && Ce.iconsInText, (Ce || ae) && Fw(o.bucket, I, G, ae, o.imageMap, h, N, q, me, Oe, o.canonical, o.subdivisionGranularity);
          }
          o.showCollisionBoxes && o.bucket.generateCollisionDebugBuffers();
        }, m.cI = tm, m.cJ = im, m.cK = nm, m.cL = N0, m.cM = am, m.cN = class {
          constructor(o) {
            this._marks = { start: [o.url, "start"].join("#"), end: [o.url, "end"].join("#"), measure: o.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let o = performance.getEntriesByName(this._marks.measure);
            return o.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), o = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), o;
          }
        }, m.cO = function(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (W()) try {
              return yield Be(o, t, n, u, h);
            } catch {
            }
            return (function(v, b, w, S, I) {
              const E = v.width, L = v.height;
              Ye && ht || (Ye = new OffscreenCanvas(E, L), ht = Ye.getContext("2d", { willReadFrequently: true })), Ye.width = E, Ye.height = L, ht.drawImage(v, 0, 0, E, L);
              const N = ht.getImageData(b, w, S, I);
              return ht.clearRect(0, 0, E, L), N.data;
            })(o, t, n, u, h);
          }));
        }, m.cP = M0, m.cQ = P, m.cR = j0, m.cS = Au, m.cT = Ks, m.cU = function(o, t) {
          const n = /* @__PURE__ */ new Map();
          if (o != null) if (o.type === "Feature") n.set(bd(o, t), o);
          else for (const u of o.features) n.set(bd(u, t), u);
          return n;
        }, m.cV = function(o, t) {
          if (o == null) return true;
          if (o.type === "Feature") return bd(o, t) != null;
          if (o.type === "FeatureCollection") {
            const n = /* @__PURE__ */ new Set();
            for (const u of o.features) {
              const h = bd(u, t);
              if (h == null || n.has(h)) return false;
              n.add(h);
            }
            return true;
          }
          return false;
        }, m.cW = function(o, t, n) {
          var u, h, v, b;
          if (t.removeAll && o.clear(), t.remove) for (const w of t.remove) o.delete(w);
          if (t.add) for (const w of t.add) {
            const S = bd(w, n);
            S != null && o.set(S, w);
          }
          if (t.update) for (const w of t.update) {
            let S = o.get(w.id);
            if (S == null) continue;
            const I = !w.removeAllProperties && (((u = w.removeProperties) === null || u === void 0 ? void 0 : u.length) > 0 || ((h = w.addOrUpdateProperties) === null || h === void 0 ? void 0 : h.length) > 0);
            if ((w.newGeometry || w.removeAllProperties || I) && (S = Object.assign({}, S), o.set(w.id, S), I && (S.properties = Object.assign({}, S.properties))), w.newGeometry && (S.geometry = w.newGeometry), w.removeAllProperties) S.properties = {};
            else if (((v = w.removeProperties) === null || v === void 0 ? void 0 : v.length) > 0) for (const E of w.removeProperties) Object.prototype.hasOwnProperty.call(S.properties, E) && delete S.properties[E];
            if (((b = w.addOrUpdateProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const { key: E, value: L } of w.addOrUpdateProperties) S.properties[E] = L;
          }
        }, m.cX = aa, m.ca = function(o, t) {
          return o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.cb = (o) => o.type === "symbol", m.cc = (o) => o.type === "circle", m.cd = (o) => o.type === "heatmap", m.ce = (o) => o.type === "line", m.cf = (o) => o.type === "fill", m.cg = (o) => o.type === "fill-extrusion", m.ch = (o) => o.type === "hillshade", m.ci = (o) => o.type === "color-relief", m.cj = (o) => o.type === "raster", m.ck = (o) => o.type === "background", m.cl = (o) => o.type === "custom", m.cm = $t, m.cn = function(o, t, n) {
          const u = lt(t.x - n.x, t.y - n.y), h = lt(o.x - n.x, o.y - n.y);
          var v, b;
          return mt(Math.atan2(u[0] * h[1] - u[1] * h[0], (v = u)[0] * (b = h)[0] + v[1] * b[1]));
        }, m.co = Qt, m.cp = function(o, t) {
          return Qr[t] && (o instanceof MouseEvent || o instanceof WheelEvent);
        }, m.cq = function(o, t) {
          return Kt[t] && "touches" in o;
        }, m.cr = function(o) {
          return Kt[o] || Qr[o];
        }, m.cs = function(o, t, n) {
          var u = t[0], h = t[1];
          return o[0] = n[0] * u + n[4] * h + n[12], o[1] = n[1] * u + n[5] * h + n[13], o;
        }, m.ct = function(o, t) {
          const { x: n, y: u } = _d.fromLngLat(t);
          return !(o < 0 || o > 25 || u < 0 || u >= 1 || n < 0 || n >= 1);
        }, m.cu = function(o, t) {
          return o[0] = t[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = t[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = t[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }, m.cv = class extends ja {
        }, m.cw = Bw, m.cy = function(o) {
          return o.message === ki;
        }, m.cz = xe, m.d = he, m.e = It, m.f = (o) => s(void 0, void 0, void 0, (function* () {
          if (o.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(o)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), m.g = H, m.h = (o) => new Promise(((t, n) => {
          const u = new Image();
          u.onload = () => {
            t(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame((() => {
              u.src = nt;
            }));
          }, u.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const h = new Blob([new Uint8Array(o)], { type: "image/png" });
          u.src = o.byteLength ? URL.createObjectURL(h) : nt;
        })), m.i = wr, m.j = (o, t) => De(It(o, { type: "json" }), t), m.k = Xe, m.l = it, m.m = De, m.n = (o, t) => De(It(o, { type: "arrayBuffer" }), t), m.o = function(o) {
          return new am(o).readFields(lw, []);
        }, m.p = ev, m.q = ld, m.r = sn, m.s = bt, m.t = ed, m.u = kr, m.v = Te, m.w = Ut, m.x = ol, m.y = Nh, m.z = ds;
      })), f("worker", ["./shared"], (function(m) {
        class s {
          constructor(Z, H) {
            this.keyCache = {}, Z && this.replace(Z, H);
          }
          replace(Z, H) {
            this._layerConfigs = {}, this._layers = {}, this.update(Z, [], H);
          }
          update(Z, H, ne) {
            for (const Pe of Z) {
              this._layerConfigs[Pe.id] = Pe;
              const De = this._layers[Pe.id] = m.bJ(Pe, ne);
              De._featureFilter = m.aa(De.filter, ne), this.keyCache[Pe.id] && delete this.keyCache[Pe.id];
            }
            for (const Pe of H) delete this.keyCache[Pe], delete this._layerConfigs[Pe], delete this._layers[Pe];
            this.familiesBySource = {};
            const xe = m.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const Pe of xe) {
              const De = Pe.map(((xt) => this._layers[xt.id])), he = De[0];
              if (he.visibility === "none") continue;
              const ve = he.source || "";
              let je = this.familiesBySource[ve];
              je || (je = this.familiesBySource[ve] = {});
              const it = he.sourceLayer || "_geojsonTileLayer";
              let Xe = je[it];
              Xe || (Xe = je[it] = []), Xe.push(De);
            }
          }
        }
        class C {
          constructor(Z) {
            const H = {}, ne = [];
            for (const he in Z) {
              const ve = Z[he], je = H[he] = {};
              for (const it in ve) {
                const Xe = ve[+it];
                if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue;
                const xt = { x: 0, y: 0, w: Xe.bitmap.width + 2, h: Xe.bitmap.height + 2 };
                ne.push(xt), je[it] = { rect: xt, metrics: Xe.metrics };
              }
            }
            const { w: xe, h: Pe } = m.p(ne), De = new m.q({ width: xe || 1, height: Pe || 1 });
            for (const he in Z) {
              const ve = Z[he];
              for (const je in ve) {
                const it = ve[+je];
                if (!it || it.bitmap.width === 0 || it.bitmap.height === 0) continue;
                const Xe = H[he][je].rect;
                m.q.copy(it.bitmap, De, { x: 0, y: 0 }, { x: Xe.x + 1, y: Xe.y + 1 }, it.bitmap);
              }
            }
            this.image = De, this.positions = H;
          }
        }
        m.cD("GlyphAtlas", C);
        class P {
          constructor(Z) {
            this.tileID = new m.Z(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.uid = Z.uid, this.zoom = Z.zoom, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Z.showCollisionBoxes, this.collectResourceTiming = !!Z.collectResourceTiming, this.returnDependencies = !!Z.returnDependencies, this.promoteId = Z.promoteId, this.inFlightDependencies = [];
          }
          parse(Z, H, ne, xe, Pe) {
            return m._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = Z, this.collisionBoxArray = new m.a8();
              const De = new m.cE(Object.keys(Z.layers).sort()), he = new m.cF(this.tileID, this.promoteId);
              he.bucketLayerIDs = [];
              const ve = {}, je = { featureIndex: he, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: ne, subdivisionGranularity: Pe }, it = H.familiesBySource[this.source];
              for (const de in it) {
                const at = Z.layers[de];
                if (!at) continue;
                at.version === 1 && m.w(`Vector tile source "${this.source}" layer "${de}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Zt = De.encode(de), Rr = [];
                for (let Cr = 0; Cr < at.length; Cr++) {
                  const st = at.feature(Cr), ar = he.getId(st, de);
                  Rr.push({ feature: st, id: ar, index: Cr, sourceLayerIndex: Zt });
                }
                for (const Cr of it[de]) {
                  const st = Cr[0];
                  st.source !== this.source && m.w(`layer.source = ${st.source} does not equal this.source = ${this.source}`), st.minzoom && this.zoom < Math.floor(st.minzoom) || st.maxzoom && this.zoom >= st.maxzoom || st.visibility !== "none" && (M(Cr, this.zoom, ne), (ve[st.id] = st.createBucket({ index: he.bucketLayerIDs.length, layers: Cr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Zt, sourceID: this.source })).populate(Rr, je, this.tileID.canonical), he.bucketLayerIDs.push(Cr.map(((ar) => ar.id))));
                }
              }
              const Xe = m.bN(je.glyphDependencies, ((de) => Object.keys(de).map(Number)));
              this.inFlightDependencies.forEach(((de) => de == null ? void 0 : de.abort())), this.inFlightDependencies = [];
              let xt = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const de = new AbortController();
                this.inFlightDependencies.push(de), xt = xe.sendAsync({ type: "GG", data: { stacks: Xe, source: this.source, tileID: this.tileID, type: "glyphs" } }, de);
              }
              const Te = Object.keys(je.iconDependencies);
              let Vt = Promise.resolve({});
              if (Te.length) {
                const de = new AbortController();
                this.inFlightDependencies.push(de), Vt = xe.sendAsync({ type: "GI", data: { icons: Te, source: this.source, tileID: this.tileID, type: "icons" } }, de);
              }
              const or = Object.keys(je.patternDependencies);
              let qt = Promise.resolve({});
              if (or.length) {
                const de = new AbortController();
                this.inFlightDependencies.push(de), qt = xe.sendAsync({ type: "GI", data: { icons: or, source: this.source, tileID: this.tileID, type: "patterns" } }, de);
              }
              const dr = je.dashDependencies;
              let Br = Promise.resolve({});
              if (Object.keys(dr).length) {
                const de = new AbortController();
                this.inFlightDependencies.push(de), Br = xe.sendAsync({ type: "GDA", data: { dashes: dr } }, de);
              }
              const [Vr, Kr, ci, di] = yield Promise.all([xt, Vt, qt, Br]), Lr = new C(Vr), Ur = new m.cG(Kr, ci);
              for (const de in ve) {
                const at = ve[de];
                at instanceof m.a9 ? (M(at.layers, this.zoom, ne), m.cH({ bucket: at, glyphMap: Vr, glyphPositions: Lr.positions, imageMap: Kr, imagePositions: Ur.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: je.subdivisionGranularity })) : at.hasDependencies && (at instanceof m.cI || at instanceof m.cJ || at instanceof m.cK) && (M(at.layers, this.zoom, ne), at.addFeatures(je, this.tileID.canonical, Ur.patternPositions, di));
              }
              return this.status = "done", { buckets: Object.values(ve).filter(((de) => !de.isEmpty())), featureIndex: he, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Lr.image, imageAtlas: Ur, dashPositions: di, glyphMap: this.returnDependencies ? Vr : null, iconMap: this.returnDependencies ? Kr : null, glyphPositions: this.returnDependencies ? Lr.positions : null };
            }));
          }
        }
        function M(ze, Z, H) {
          const ne = new m.F(Z);
          for (const xe of ze) xe.recalculate(ne, H);
        }
        class F {
          constructor(Z, H, ne) {
            this.actor = Z, this.layerIndex = H, this.availableImages = ne, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const ne = yield m.n(Z.request, H);
              try {
                return { vectorTile: new m.cL(new m.cM(ne.data)), rawData: ne.data, cacheControl: ne.cacheControl, expires: ne.expires };
              } catch (xe) {
                const Pe = new Uint8Array(ne.data);
                let De = `Unable to parse the tile at ${Z.request.url}, `;
                throw De += Pe[0] === 31 && Pe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${xe.message}`, new Error(De);
              }
            }));
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = Z.uid, ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request), xe = new P(Z);
              this.loading[H] = xe;
              const Pe = new AbortController();
              xe.abort = Pe;
              try {
                const De = yield this.loadVectorTile(Z, Pe);
                if (delete this.loading[H], !De) return null;
                const he = De.rawData, ve = {};
                De.expires && (ve.expires = De.expires), De.cacheControl && (ve.cacheControl = De.cacheControl);
                const je = {};
                if (ne) {
                  const Xe = ne.finish();
                  Xe && (je.resourceTiming = JSON.parse(JSON.stringify(Xe)));
                }
                xe.vectorTile = De.vectorTile;
                const it = xe.parse(De.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                this.loaded[H] = xe, this.fetching[H] = { rawTileData: he, cacheControl: ve, resourceTiming: je };
                try {
                  const Xe = yield it;
                  return m.e({ rawTileData: he.slice(0) }, Xe, ve, je);
                } finally {
                  delete this.fetching[H];
                }
              } catch (De) {
                throw delete this.loading[H], xe.status = "done", this.loaded[H] = xe, De;
              }
            }));
          }
          reloadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = Z.uid;
              if (!this.loaded || !this.loaded[H]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ne = this.loaded[H];
              if (ne.showCollisionBoxes = Z.showCollisionBoxes, ne.status === "parsing") {
                const xe = yield ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                let Pe;
                if (this.fetching[H]) {
                  const { rawTileData: De, cacheControl: he, resourceTiming: ve } = this.fetching[H];
                  delete this.fetching[H], Pe = m.e({ rawTileData: De.slice(0) }, xe, he, ve);
                } else Pe = xe;
                return Pe;
              }
              if (ne.status === "done" && ne.vectorTile) return ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
            }));
          }
          abortTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = this.loading, ne = Z.uid;
              H && H[ne] && H[ne].abort && (H[ne].abort.abort(), delete H[ne]);
            }));
          }
          removeTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[Z.uid] && delete this.loaded[Z.uid];
            }));
          }
        }
        class D {
          constructor() {
            this.loaded = {};
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const { uid: H, encoding: ne, rawImageData: xe, redFactor: Pe, greenFactor: De, blueFactor: he, baseShift: ve } = Z, je = xe.width + 2, it = xe.height + 2, Xe = m.b(xe) ? new m.R({ width: je, height: it }, yield m.cO(xe, -1, -1, je, it)) : xe, xt = new m.cP(H, Xe, ne, Pe, De, he, ve);
              return this.loaded = this.loaded || {}, this.loaded[H] = xt, xt;
            }));
          }
          removeTile(Z) {
            const H = this.loaded, ne = Z.uid;
            H && H[ne] && delete H[ne];
          }
        }
        var A, O, V = (function() {
          if (O) return A;
          function ze(H, ne) {
            if (H.length !== 0) {
              Z(H[0], ne);
              for (var xe = 1; xe < H.length; xe++) Z(H[xe], !ne);
            }
          }
          function Z(H, ne) {
            for (var xe = 0, Pe = 0, De = 0, he = H.length, ve = he - 1; De < he; ve = De++) {
              var je = (H[De][0] - H[ve][0]) * (H[ve][1] + H[De][1]), it = xe + je;
              Pe += Math.abs(xe) >= Math.abs(je) ? xe - it + je : je - it + xe, xe = it;
            }
            xe + Pe >= 0 != !!ne && H.reverse();
          }
          return O = 1, A = function H(ne, xe) {
            var Pe, De = ne && ne.type;
            if (De === "FeatureCollection") for (Pe = 0; Pe < ne.features.length; Pe++) H(ne.features[Pe], xe);
            else if (De === "GeometryCollection") for (Pe = 0; Pe < ne.geometries.length; Pe++) H(ne.geometries[Pe], xe);
            else if (De === "Feature") H(ne.geometry, xe);
            else if (De === "Polygon") ze(ne.coordinates, xe);
            else if (De === "MultiPolygon") for (Pe = 0; Pe < ne.coordinates.length; Pe++) ze(ne.coordinates[Pe], xe);
            return ne;
          };
        })(), Y = m.cQ(V);
        class W extends m.cS {
          constructor(Z, H) {
            super(new m.cM(), 0, H, [], []), this.feature = Z, this.type = Z.type, this.properties = Z.tags ? Z.tags : {}, "id" in Z && (typeof Z.id == "string" ? this.id = parseInt(Z.id, 10) : typeof Z.id != "number" || isNaN(Z.id) || (this.id = Z.id));
          }
          loadGeometry() {
            const Z = [], H = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const ne of H) {
              const xe = [];
              for (const Pe of ne) xe.push(new m.P(Pe[0], Pe[1]));
              Z.push(xe);
            }
            return Z;
          }
        }
        class ee extends m.cR {
          constructor(Z, H) {
            super(new m.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = H ? H.version : 1, this.extent = H ? H.extent : 4096, this.length = Z.length, this.features = Z;
          }
          feature(Z) {
            return new W(this.features[Z], this.extent);
          }
        }
        function ie(ze, Z) {
          Z.writeVarintField(15, ze.version || 1), Z.writeStringField(1, ze.name || ""), Z.writeVarintField(5, ze.extent || 4096);
          const H = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let Pe = 0; Pe < ze.length; Pe++) H.feature = ze.feature(Pe), Z.writeMessage(2, te, H);
          const ne = H.keys;
          for (const Pe of ne) Z.writeStringField(3, Pe);
          const xe = H.values;
          for (const Pe of xe) Z.writeMessage(4, oe, Pe);
        }
        function te(ze, Z) {
          if (!ze.feature) return;
          const H = ze.feature;
          H.id !== void 0 && Z.writeVarintField(1, H.id), Z.writeMessage(2, re, ze), Z.writeVarintField(3, H.type), Z.writeMessage(4, pe, H);
        }
        function re(ze, Z) {
          var _a3;
          for (const H in (_a3 = ze.feature) == null ? void 0 : _a3.properties) {
            let ne = ze.feature.properties[H], xe = ze.keycache[H];
            if (ne === null) continue;
            xe === void 0 && (ze.keys.push(H), xe = ze.keys.length - 1, ze.keycache[H] = xe), Z.writeVarint(xe), typeof ne != "string" && typeof ne != "boolean" && typeof ne != "number" && (ne = JSON.stringify(ne));
            const Pe = typeof ne + ":" + ne;
            let De = ze.valuecache[Pe];
            De === void 0 && (ze.values.push(ne), De = ze.values.length - 1, ze.valuecache[Pe] = De), Z.writeVarint(De);
          }
        }
        function X(ze, Z) {
          return (Z << 3) + (7 & ze);
        }
        function Se(ze) {
          return ze << 1 ^ ze >> 31;
        }
        function pe(ze, Z) {
          const H = ze.loadGeometry(), ne = ze.type;
          let xe = 0, Pe = 0;
          for (const De of H) {
            let he = 1;
            ne === 1 && (he = De.length), Z.writeVarint(X(1, he));
            const ve = ne === 3 ? De.length - 1 : De.length;
            for (let je = 0; je < ve; je++) {
              je === 1 && ne !== 1 && Z.writeVarint(X(2, ve - 1));
              const it = De[je].x - xe, Xe = De[je].y - Pe;
              Z.writeVarint(Se(it)), Z.writeVarint(Se(Xe)), xe += it, Pe += Xe;
            }
            ze.type === 3 && Z.writeVarint(X(7, 1));
          }
        }
        function oe(ze, Z) {
          const H = typeof ze;
          H === "string" ? Z.writeStringField(1, ze) : H === "boolean" ? Z.writeBooleanField(7, ze) : H === "number" && (ze % 1 != 0 ? Z.writeDoubleField(3, ze) : ze < 0 ? Z.writeSVarintField(6, ze) : Z.writeVarintField(5, ze));
        }
        const fe = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (ze) => ze }, _e = Math.fround || (qe = new Float32Array(1), (ze) => (qe[0] = +ze, qe[0]));
        var qe;
        class Ve {
          constructor(Z) {
            this.options = Object.assign(Object.create(fe), Z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(Z) {
            const { log: H, minZoom: ne, maxZoom: xe } = this.options;
            H && console.time("total time");
            const Pe = `prepare ${Z.length} points`;
            H && console.time(Pe), this.points = Z;
            const De = [];
            for (let ve = 0; ve < Z.length; ve++) {
              const je = Z[ve];
              if (!je.geometry) continue;
              const [it, Xe] = je.geometry.coordinates, xt = _e(gt(it)), Te = _e(yt(Xe));
              De.push(xt, Te, 1 / 0, ve, -1, 1), this.options.reduce && De.push(0);
            }
            let he = this.trees[xe + 1] = this._createTree(De);
            H && console.timeEnd(Pe);
            for (let ve = xe; ve >= ne; ve--) {
              const je = +Date.now();
              he = this.trees[ve] = this._createTree(this._cluster(he, ve)), H && console.log("z%d: %d clusters in %dms", ve, he.numItems, +Date.now() - je);
            }
            return H && console.timeEnd("total time"), this;
          }
          getClusters(Z, H) {
            let ne = ((Z[0] + 180) % 360 + 360) % 360 - 180;
            const xe = Math.max(-90, Math.min(90, Z[1]));
            let Pe = Z[2] === 180 ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180;
            const De = Math.max(-90, Math.min(90, Z[3]));
            if (Z[2] - Z[0] >= 360) ne = -180, Pe = 180;
            else if (ne > Pe) {
              const Xe = this.getClusters([ne, xe, 180, De], H), xt = this.getClusters([-180, xe, Pe, De], H);
              return Xe.concat(xt);
            }
            const he = this.trees[this._limitZoom(H)], ve = he.range(gt(ne), yt(De), gt(Pe), yt(xe)), je = he.data, it = [];
            for (const Xe of ve) {
              const xt = this.stride * Xe;
              it.push(je[xt + 5] > 1 ? Qe(je, xt, this.clusterProps) : this.points[je[xt + 3]]);
            }
            return it;
          }
          getChildren(Z) {
            const H = this._getOriginId(Z), ne = this._getOriginZoom(Z), xe = "No cluster with the specified id.", Pe = this.trees[ne];
            if (!Pe) throw new Error(xe);
            const De = Pe.data;
            if (H * this.stride >= De.length) throw new Error(xe);
            const he = this.options.radius / (this.options.extent * Math.pow(2, ne - 1)), ve = Pe.within(De[H * this.stride], De[H * this.stride + 1], he), je = [];
            for (const it of ve) {
              const Xe = it * this.stride;
              De[Xe + 4] === Z && je.push(De[Xe + 5] > 1 ? Qe(De, Xe, this.clusterProps) : this.points[De[Xe + 3]]);
            }
            if (je.length === 0) throw new Error(xe);
            return je;
          }
          getLeaves(Z, H, ne) {
            const xe = [];
            return this._appendLeaves(xe, Z, H = H || 10, ne = ne || 0, 0), xe;
          }
          getTile(Z, H, ne) {
            const xe = this.trees[this._limitZoom(Z)], Pe = Math.pow(2, Z), { extent: De, radius: he } = this.options, ve = he / De, je = (ne - ve) / Pe, it = (ne + 1 + ve) / Pe, Xe = { features: [] };
            return this._addTileFeatures(xe.range((H - ve) / Pe, je, (H + 1 + ve) / Pe, it), xe.data, H, ne, Pe, Xe), H === 0 && this._addTileFeatures(xe.range(1 - ve / Pe, je, 1, it), xe.data, Pe, ne, Pe, Xe), H === Pe - 1 && this._addTileFeatures(xe.range(0, je, ve / Pe, it), xe.data, -1, ne, Pe, Xe), Xe.features.length ? Xe : null;
          }
          getClusterExpansionZoom(Z) {
            let H = this._getOriginZoom(Z) - 1;
            for (; H <= this.options.maxZoom; ) {
              const ne = this.getChildren(Z);
              if (H++, ne.length !== 1) break;
              Z = ne[0].properties.cluster_id;
            }
            return H;
          }
          _appendLeaves(Z, H, ne, xe, Pe) {
            const De = this.getChildren(H);
            for (const he of De) {
              const ve = he.properties;
              if (ve && ve.cluster ? Pe + ve.point_count <= xe ? Pe += ve.point_count : Pe = this._appendLeaves(Z, ve.cluster_id, ne, xe, Pe) : Pe < xe ? Pe++ : Z.push(he), Z.length === ne) break;
            }
            return Pe;
          }
          _createTree(Z) {
            const H = new m.aI(Z.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ne = 0; ne < Z.length; ne += this.stride) H.add(Z[ne], Z[ne + 1]);
            return H.finish(), H.data = Z, H;
          }
          _addTileFeatures(Z, H, ne, xe, Pe, De) {
            for (const he of Z) {
              const ve = he * this.stride, je = H[ve + 5] > 1;
              let it, Xe, xt;
              if (je) it = ut(H, ve, this.clusterProps), Xe = H[ve], xt = H[ve + 1];
              else {
                const or = this.points[H[ve + 3]];
                it = or.properties;
                const [qt, dr] = or.geometry.coordinates;
                Xe = gt(qt), xt = yt(dr);
              }
              const Te = { type: 1, geometry: [[Math.round(this.options.extent * (Xe * Pe - ne)), Math.round(this.options.extent * (xt * Pe - xe))]], tags: it };
              let Vt;
              Vt = je || this.options.generateId ? H[ve + 3] : this.points[H[ve + 3]].id, Vt !== void 0 && (Te.id = Vt), De.features.push(Te);
            }
          }
          _limitZoom(Z) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1));
          }
          _cluster(Z, H) {
            const { radius: ne, extent: xe, reduce: Pe, minPoints: De } = this.options, he = ne / (xe * Math.pow(2, H)), ve = Z.data, je = [], it = this.stride;
            for (let Xe = 0; Xe < ve.length; Xe += it) {
              if (ve[Xe + 2] <= H) continue;
              ve[Xe + 2] = H;
              const xt = ve[Xe], Te = ve[Xe + 1], Vt = Z.within(ve[Xe], ve[Xe + 1], he), or = ve[Xe + 5];
              let qt = or;
              for (const dr of Vt) {
                const Br = dr * it;
                ve[Br + 2] > H && (qt += ve[Br + 5]);
              }
              if (qt > or && qt >= De) {
                let dr, Br = xt * or, Vr = Te * or, Kr = -1;
                const ci = (Xe / it << 5) + (H + 1) + this.points.length;
                for (const di of Vt) {
                  const Lr = di * it;
                  if (ve[Lr + 2] <= H) continue;
                  ve[Lr + 2] = H;
                  const Ur = ve[Lr + 5];
                  Br += ve[Lr] * Ur, Vr += ve[Lr + 1] * Ur, ve[Lr + 4] = ci, Pe && (dr || (dr = this._map(ve, Xe, true), Kr = this.clusterProps.length, this.clusterProps.push(dr)), Pe(dr, this._map(ve, Lr)));
                }
                ve[Xe + 4] = ci, je.push(Br / qt, Vr / qt, 1 / 0, ci, -1, qt), Pe && je.push(Kr);
              } else {
                for (let dr = 0; dr < it; dr++) je.push(ve[Xe + dr]);
                if (qt > 1) for (const dr of Vt) {
                  const Br = dr * it;
                  if (!(ve[Br + 2] <= H)) {
                    ve[Br + 2] = H;
                    for (let Vr = 0; Vr < it; Vr++) je.push(ve[Br + Vr]);
                  }
                }
              }
            }
            return je;
          }
          _getOriginId(Z) {
            return Z - this.points.length >> 5;
          }
          _getOriginZoom(Z) {
            return (Z - this.points.length) % 32;
          }
          _map(Z, H, ne) {
            if (Z[H + 5] > 1) {
              const De = this.clusterProps[Z[H + 6]];
              return ne ? Object.assign({}, De) : De;
            }
            const xe = this.points[Z[H + 3]].properties, Pe = this.options.map(xe);
            return ne && Pe === xe ? Object.assign({}, Pe) : Pe;
          }
        }
        function Qe(ze, Z, H) {
          return { type: "Feature", id: ze[Z + 3], properties: ut(ze, Z, H), geometry: { type: "Point", coordinates: [(ne = ze[Z], 360 * (ne - 0.5)), lt(ze[Z + 1])] } };
          var ne;
        }
        function ut(ze, Z, H) {
          const ne = ze[Z + 5], xe = ne >= 1e4 ? `${Math.round(ne / 1e3)}k` : ne >= 1e3 ? Math.round(ne / 100) / 10 + "k" : ne, Pe = ze[Z + 6], De = Pe === -1 ? {} : Object.assign({}, H[Pe]);
          return Object.assign(De, { cluster: true, cluster_id: ze[Z + 3], point_count: ne, point_count_abbreviated: xe });
        }
        function gt(ze) {
          return ze / 360 + 0.5;
        }
        function yt(ze) {
          const Z = Math.sin(ze * Math.PI / 180), H = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return H < 0 ? 0 : H > 1 ? 1 : H;
        }
        function lt(ze) {
          const Z = (180 - 360 * ze) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90;
        }
        function et(ze, Z, H, ne) {
          let xe = ne;
          const Pe = Z + (H - Z >> 1);
          let De, he = H - Z;
          const ve = ze[Z], je = ze[Z + 1], it = ze[H], Xe = ze[H + 1];
          for (let xt = Z + 3; xt < H; xt += 3) {
            const Te = dt(ze[xt], ze[xt + 1], ve, je, it, Xe);
            if (Te > xe) De = xt, xe = Te;
            else if (Te === xe) {
              const Vt = Math.abs(xt - Pe);
              Vt < he && (De = xt, he = Vt);
            }
          }
          xe > ne && (De - Z > 3 && et(ze, Z, De, ne), ze[De + 2] = xe, H - De > 3 && et(ze, De, H, ne));
        }
        function dt(ze, Z, H, ne, xe, Pe) {
          let De = xe - H, he = Pe - ne;
          if (De !== 0 || he !== 0) {
            const ve = ((ze - H) * De + (Z - ne) * he) / (De * De + he * he);
            ve > 1 ? (H = xe, ne = Pe) : ve > 0 && (H += De * ve, ne += he * ve);
          }
          return De = ze - H, he = Z - ne, De * De + he * he;
        }
        function Ft(ze, Z, H, ne) {
          const xe = { id: ze ?? null, type: Z, geometry: H, tags: ne, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (Z === "Point" || Z === "MultiPoint" || Z === "LineString") ft(xe, H);
          else if (Z === "Polygon") ft(xe, H[0]);
          else if (Z === "MultiLineString") for (const Pe of H) ft(xe, Pe);
          else if (Z === "MultiPolygon") for (const Pe of H) ft(xe, Pe[0]);
          return xe;
        }
        function ft(ze, Z) {
          for (let H = 0; H < Z.length; H += 3) ze.minX = Math.min(ze.minX, Z[H]), ze.minY = Math.min(ze.minY, Z[H + 1]), ze.maxX = Math.max(ze.maxX, Z[H]), ze.maxY = Math.max(ze.maxY, Z[H + 1]);
        }
        function _t(ze, Z, H, ne) {
          if (!Z.geometry) return;
          const xe = Z.geometry.coordinates;
          if (xe && xe.length === 0) return;
          const Pe = Z.geometry.type, De = Math.pow(H.tolerance / ((1 << H.maxZoom) * H.extent), 2);
          let he = [], ve = Z.id;
          if (H.promoteId ? ve = Z.properties[H.promoteId] : H.generateId && (ve = ne || 0), Pe === "Point") $t(xe, he);
          else if (Pe === "MultiPoint") for (const je of xe) $t(je, he);
          else if (Pe === "LineString") Qt(xe, he, De, false);
          else if (Pe === "MultiLineString") {
            if (H.lineMetrics) {
              for (const je of xe) he = [], Qt(je, he, De, false), ze.push(Ft(ve, "LineString", he, Z.properties));
              return;
            }
            Lt(xe, he, De, false);
          } else if (Pe === "Polygon") Lt(xe, he, De, true);
          else {
            if (Pe !== "MultiPolygon") {
              if (Pe === "GeometryCollection") {
                for (const je of Z.geometry.geometries) _t(ze, { id: ve, geometry: je, properties: Z.properties }, H, ne);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const je of xe) {
              const it = [];
              Lt(je, it, De, true), he.push(it);
            }
          }
          ze.push(Ft(ve, Pe, he, Z.properties));
        }
        function $t(ze, Z) {
          Z.push(zt(ze[0]), It(ze[1]), 0);
        }
        function Qt(ze, Z, H, ne) {
          let xe, Pe, De = 0;
          for (let ve = 0; ve < ze.length; ve++) {
            const je = zt(ze[ve][0]), it = It(ze[ve][1]);
            Z.push(je, it, 0), ve > 0 && (De += ne ? (xe * it - je * Pe) / 2 : Math.sqrt(Math.pow(je - xe, 2) + Math.pow(it - Pe, 2))), xe = je, Pe = it;
          }
          const he = Z.length - 3;
          Z[2] = 1, et(Z, 0, he, H), Z[he + 2] = 1, Z.size = Math.abs(De), Z.start = 0, Z.end = Z.size;
        }
        function Lt(ze, Z, H, ne) {
          for (let xe = 0; xe < ze.length; xe++) {
            const Pe = [];
            Qt(ze[xe], Pe, H, ne), Z.push(Pe);
          }
        }
        function zt(ze) {
          return ze / 360 + 0.5;
        }
        function It(ze) {
          const Z = Math.sin(ze * Math.PI / 180), H = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return H < 0 ? 0 : H > 1 ? 1 : H;
        }
        function At(ze, Z, H, ne, xe, Pe, De, he) {
          if (ne /= Z, Pe >= (H /= Z) && De < ne) return ze;
          if (De < H || Pe >= ne) return null;
          const ve = [];
          for (const je of ze) {
            const it = je.geometry;
            let Xe = je.type;
            const xt = xe === 0 ? je.minX : je.minY, Te = xe === 0 ? je.maxX : je.maxY;
            if (xt >= H && Te < ne) {
              ve.push(je);
              continue;
            }
            if (Te < H || xt >= ne) continue;
            let Vt = [];
            if (Xe === "Point" || Xe === "MultiPoint") mr(it, Vt, H, ne, xe);
            else if (Xe === "LineString") gr(it, Vt, H, ne, xe, false, he.lineMetrics);
            else if (Xe === "MultiLineString") nr(it, Vt, H, ne, xe, false);
            else if (Xe === "Polygon") nr(it, Vt, H, ne, xe, true);
            else if (Xe === "MultiPolygon") for (const or of it) {
              const qt = [];
              nr(or, qt, H, ne, xe, true), qt.length && Vt.push(qt);
            }
            if (Vt.length) {
              if (he.lineMetrics && Xe === "LineString") {
                for (const or of Vt) ve.push(Ft(je.id, Xe, or, je.tags));
                continue;
              }
              Xe !== "LineString" && Xe !== "MultiLineString" || (Vt.length === 1 ? (Xe = "LineString", Vt = Vt[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = Vt.length === 3 ? "Point" : "MultiPoint"), ve.push(Ft(je.id, Xe, Vt, je.tags));
            }
          }
          return ve.length ? ve : null;
        }
        function mr(ze, Z, H, ne, xe) {
          for (let Pe = 0; Pe < ze.length; Pe += 3) {
            const De = ze[Pe + xe];
            De >= H && De <= ne && Ut(Z, ze[Pe], ze[Pe + 1], ze[Pe + 2]);
          }
        }
        function gr(ze, Z, H, ne, xe, Pe, De) {
          let he = ir(ze);
          const ve = xe === 0 ? Ar : wr;
          let je, it, Xe = ze.start;
          for (let qt = 0; qt < ze.length - 3; qt += 3) {
            const dr = ze[qt], Br = ze[qt + 1], Vr = ze[qt + 2], Kr = ze[qt + 3], ci = ze[qt + 4], di = xe === 0 ? dr : Br, Lr = xe === 0 ? Kr : ci;
            let Ur = false;
            De && (je = Math.sqrt(Math.pow(dr - Kr, 2) + Math.pow(Br - ci, 2))), di < H ? Lr > H && (it = ve(he, dr, Br, Kr, ci, H), De && (he.start = Xe + je * it)) : di > ne ? Lr < ne && (it = ve(he, dr, Br, Kr, ci, ne), De && (he.start = Xe + je * it)) : Ut(he, dr, Br, Vr), Lr < H && di >= H && (it = ve(he, dr, Br, Kr, ci, H), Ur = true), Lr > ne && di <= ne && (it = ve(he, dr, Br, Kr, ci, ne), Ur = true), !Pe && Ur && (De && (he.end = Xe + je * it), Z.push(he), he = ir(ze)), De && (Xe += je);
          }
          let xt = ze.length - 3;
          const Te = ze[xt], Vt = ze[xt + 1], or = xe === 0 ? Te : Vt;
          or >= H && or <= ne && Ut(he, Te, Vt, ze[xt + 2]), xt = he.length - 3, Pe && xt >= 3 && (he[xt] !== he[0] || he[xt + 1] !== he[1]) && Ut(he, he[0], he[1], he[2]), he.length && Z.push(he);
        }
        function ir(ze) {
          const Z = [];
          return Z.size = ze.size, Z.start = ze.start, Z.end = ze.end, Z;
        }
        function nr(ze, Z, H, ne, xe, Pe) {
          for (const De of ze) gr(De, Z, H, ne, xe, Pe, false);
        }
        function Ut(ze, Z, H, ne) {
          ze.push(Z, H, ne);
        }
        function Ar(ze, Z, H, ne, xe, Pe) {
          const De = (Pe - Z) / (ne - Z);
          return Ut(ze, Pe, H + (xe - H) * De, 1), De;
        }
        function wr(ze, Z, H, ne, xe, Pe) {
          const De = (Pe - H) / (xe - H);
          return Ut(ze, Z + (ne - Z) * De, Pe, 1), De;
        }
        function Ct(ze, Z) {
          const H = [];
          for (let ne = 0; ne < ze.length; ne++) {
            const xe = ze[ne], Pe = xe.type;
            let De;
            if (Pe === "Point" || Pe === "MultiPoint" || Pe === "LineString") De = Ee(xe.geometry, Z);
            else if (Pe === "MultiLineString" || Pe === "Polygon") {
              De = [];
              for (const he of xe.geometry) De.push(Ee(he, Z));
            } else if (Pe === "MultiPolygon") {
              De = [];
              for (const he of xe.geometry) {
                const ve = [];
                for (const je of he) ve.push(Ee(je, Z));
                De.push(ve);
              }
            }
            H.push(Ft(xe.id, Pe, De, xe.tags));
          }
          return H;
        }
        function Ee(ze, Z) {
          const H = [];
          H.size = ze.size, ze.start !== void 0 && (H.start = ze.start, H.end = ze.end);
          for (let ne = 0; ne < ze.length; ne += 3) H.push(ze[ne] + Z, ze[ne + 1], ze[ne + 2]);
          return H;
        }
        function nt(ze, Z) {
          if (ze.transformed) return ze;
          const H = 1 << ze.z, ne = ze.x, xe = ze.y;
          for (const Pe of ze.features) {
            const De = Pe.geometry, he = Pe.type;
            if (Pe.geometry = [], he === 1) for (let ve = 0; ve < De.length; ve += 2) Pe.geometry.push(Be(De[ve], De[ve + 1], Z, H, ne, xe));
            else for (let ve = 0; ve < De.length; ve++) {
              const je = [];
              for (let it = 0; it < De[ve].length; it += 2) je.push(Be(De[ve][it], De[ve][it + 1], Z, H, ne, xe));
              Pe.geometry.push(je);
            }
          }
          return ze.transformed = true, ze;
        }
        function Be(ze, Z, H, ne, xe, Pe) {
          return [Math.round(H * (ze * ne - xe)), Math.round(H * (Z * ne - Pe))];
        }
        function Ye(ze, Z, H, ne, xe) {
          const Pe = Z === xe.maxZoom ? 0 : xe.tolerance / ((1 << Z) * xe.extent), De = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ze.length, source: null, x: H, y: ne, z: Z, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const he of ze) ht(De, he, Pe, xe);
          return De;
        }
        function ht(ze, Z, H, ne) {
          const xe = Z.geometry, Pe = Z.type, De = [];
          if (ze.minX = Math.min(ze.minX, Z.minX), ze.minY = Math.min(ze.minY, Z.minY), ze.maxX = Math.max(ze.maxX, Z.maxX), ze.maxY = Math.max(ze.maxY, Z.maxY), Pe === "Point" || Pe === "MultiPoint") for (let he = 0; he < xe.length; he += 3) De.push(xe[he], xe[he + 1]), ze.numPoints++, ze.numSimplified++;
          else if (Pe === "LineString") bt(De, xe, ze, H, false, false);
          else if (Pe === "MultiLineString" || Pe === "Polygon") for (let he = 0; he < xe.length; he++) bt(De, xe[he], ze, H, Pe === "Polygon", he === 0);
          else if (Pe === "MultiPolygon") for (let he = 0; he < xe.length; he++) {
            const ve = xe[he];
            for (let je = 0; je < ve.length; je++) bt(De, ve[je], ze, H, true, je === 0);
          }
          if (De.length) {
            let he = Z.tags || null;
            if (Pe === "LineString" && ne.lineMetrics) {
              he = {};
              for (const je in Z.tags) he[je] = Z.tags[je];
              he.mapbox_clip_start = xe.start / xe.size, he.mapbox_clip_end = xe.end / xe.size;
            }
            const ve = { geometry: De, type: Pe === "Polygon" || Pe === "MultiPolygon" ? 3 : Pe === "LineString" || Pe === "MultiLineString" ? 2 : 1, tags: he };
            Z.id !== null && (ve.id = Z.id), ze.features.push(ve);
          }
        }
        function bt(ze, Z, H, ne, xe, Pe) {
          const De = ne * ne;
          if (ne > 0 && Z.size < (xe ? De : ne)) return void (H.numPoints += Z.length / 3);
          const he = [];
          for (let ve = 0; ve < Z.length; ve += 3) (ne === 0 || Z[ve + 2] > De) && (H.numSimplified++, he.push(Z[ve], Z[ve + 1])), H.numPoints++;
          xe && (function(ve, je) {
            let it = 0;
            for (let Xe = 0, xt = ve.length, Te = xt - 2; Xe < xt; Te = Xe, Xe += 2) it += (ve[Xe] - ve[Te]) * (ve[Xe + 1] + ve[Te + 1]);
            if (it > 0 === je) for (let Xe = 0, xt = ve.length; Xe < xt / 2; Xe += 2) {
              const Te = ve[Xe], Vt = ve[Xe + 1];
              ve[Xe] = ve[xt - 2 - Xe], ve[Xe + 1] = ve[xt - 1 - Xe], ve[xt - 2 - Xe] = Te, ve[xt - 1 - Xe] = Vt;
            }
          })(he, Pe), ze.push(he);
        }
        const tt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class mt {
          constructor(Z, H) {
            const ne = (H = this.options = (function(Pe, De) {
              for (const he in De) Pe[he] = De[he];
              return Pe;
            })(Object.create(tt), H)).debug;
            if (ne && console.time("preprocess data"), H.maxZoom < 0 || H.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (H.promoteId && H.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let xe = (function(Pe, De) {
              const he = [];
              if (Pe.type === "FeatureCollection") for (let ve = 0; ve < Pe.features.length; ve++) _t(he, Pe.features[ve], De, ve);
              else _t(he, Pe.type === "Feature" ? Pe : { geometry: Pe }, De);
              return he;
            })(Z, H);
            this.tiles = {}, this.tileCoords = [], ne && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", H.indexMaxZoom, H.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), xe = (function(Pe, De) {
              const he = De.buffer / De.extent;
              let ve = Pe;
              const je = At(Pe, 1, -1 - he, he, 0, -1, 2, De), it = At(Pe, 1, 1 - he, 2 + he, 0, -1, 2, De);
              return (je || it) && (ve = At(Pe, 1, -he, 1 + he, 0, -1, 2, De) || [], je && (ve = Ct(je, 1).concat(ve)), it && (ve = ve.concat(Ct(it, -1)))), ve;
            })(xe, H), xe.length && this.splitTile(xe, 0, 0, 0), ne && (xe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(Z, H, ne, xe, Pe, De, he) {
            const ve = [Z, H, ne, xe], je = this.options, it = je.debug;
            for (; ve.length; ) {
              xe = ve.pop(), ne = ve.pop(), H = ve.pop(), Z = ve.pop();
              const Xe = 1 << H, xt = Kt(H, ne, xe);
              let Te = this.tiles[xt];
              if (!Te && (it > 1 && console.time("creation"), Te = this.tiles[xt] = Ye(Z, H, ne, xe, je), this.tileCoords.push({ z: H, x: ne, y: xe }), it)) {
                it > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", H, ne, xe, Te.numFeatures, Te.numPoints, Te.numSimplified), console.timeEnd("creation"));
                const Ur = `z${H}`;
                this.stats[Ur] = (this.stats[Ur] || 0) + 1, this.total++;
              }
              if (Te.source = Z, Pe == null) {
                if (H === je.indexMaxZoom || Te.numPoints <= je.indexMaxPoints) continue;
              } else {
                if (H === je.maxZoom || H === Pe) continue;
                if (Pe != null) {
                  const Ur = Pe - H;
                  if (ne !== De >> Ur || xe !== he >> Ur) continue;
                }
              }
              if (Te.source = null, Z.length === 0) continue;
              it > 1 && console.time("clipping");
              const Vt = 0.5 * je.buffer / je.extent, or = 0.5 - Vt, qt = 0.5 + Vt, dr = 1 + Vt;
              let Br = null, Vr = null, Kr = null, ci = null, di = At(Z, Xe, ne - Vt, ne + qt, 0, Te.minX, Te.maxX, je), Lr = At(Z, Xe, ne + or, ne + dr, 0, Te.minX, Te.maxX, je);
              Z = null, di && (Br = At(di, Xe, xe - Vt, xe + qt, 1, Te.minY, Te.maxY, je), Vr = At(di, Xe, xe + or, xe + dr, 1, Te.minY, Te.maxY, je), di = null), Lr && (Kr = At(Lr, Xe, xe - Vt, xe + qt, 1, Te.minY, Te.maxY, je), ci = At(Lr, Xe, xe + or, xe + dr, 1, Te.minY, Te.maxY, je), Lr = null), it > 1 && console.timeEnd("clipping"), ve.push(Br || [], H + 1, 2 * ne, 2 * xe), ve.push(Vr || [], H + 1, 2 * ne, 2 * xe + 1), ve.push(Kr || [], H + 1, 2 * ne + 1, 2 * xe), ve.push(ci || [], H + 1, 2 * ne + 1, 2 * xe + 1);
            }
          }
          getTile(Z, H, ne) {
            Z = +Z, H = +H, ne = +ne;
            const xe = this.options, { extent: Pe, debug: De } = xe;
            if (Z < 0 || Z > 24) return null;
            const he = 1 << Z, ve = Kt(Z, H = H + he & he - 1, ne);
            if (this.tiles[ve]) return nt(this.tiles[ve], Pe);
            De > 1 && console.log("drilling down to z%d-%d-%d", Z, H, ne);
            let je, it = Z, Xe = H, xt = ne;
            for (; !je && it > 0; ) it--, Xe >>= 1, xt >>= 1, je = this.tiles[Kt(it, Xe, xt)];
            return je && je.source ? (De > 1 && (console.log("found parent tile z%d-%d-%d", it, Xe, xt), console.time("drilling down")), this.splitTile(je.source, it, Xe, xt, Z, H, ne), De > 1 && console.timeEnd("drilling down"), this.tiles[ve] ? nt(this.tiles[ve], Pe) : null) : null;
          }
        }
        function Kt(ze, Z, H) {
          return 32 * ((1 << ze) * H + Z) + ze;
        }
        class Qr extends F {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const ne = Z.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const xe = this._geoJSONIndex.getTile(ne.z, ne.x, ne.y);
              if (!xe) return null;
              const Pe = new ee(xe.features, { version: 2, extent: m.$ });
              let De = (function(he) {
                const ve = new m.cM();
                return (function(je, it) {
                  for (const Xe in je.layers) it.writeMessage(3, ie, je.layers[Xe]);
                })(he, ve), ve.finish();
              })(Pe);
              return De.byteOffset === 0 && De.byteLength === De.buffer.byteLength || (De = new Uint8Array(De)), { vectorTile: Pe, rawData: De.buffer };
            }));
          }
          loadData(Z) {
            return m._(this, void 0, void 0, (function* () {
              var H;
              (H = this._pendingRequest) === null || H === void 0 || H.abort();
              const ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(Z, this._pendingRequest);
                const xe = yield this._pendingData;
                this._geoJSONIndex = Z.cluster ? new Ve((function({ superclusterOptions: De, clusterProperties: he }) {
                  if (!he || !De) return De;
                  const ve = {}, je = {}, it = { accumulated: null, zoom: 0 }, Xe = { properties: null }, xt = Object.keys(he);
                  for (const Te of xt) {
                    const [Vt, or] = he[Te], qt = m.cT(or), dr = m.cT(typeof Vt == "string" ? [Vt, ["accumulated"], ["get", Te]] : Vt);
                    ve[Te] = qt.value, je[Te] = dr.value;
                  }
                  return De.map = (Te) => {
                    Xe.properties = Te;
                    const Vt = {};
                    for (const or of xt) Vt[or] = ve[or].evaluate(it, Xe);
                    return Vt;
                  }, De.reduce = (Te, Vt) => {
                    Xe.properties = Vt;
                    for (const or of xt) it.accumulated = Te[or], Te[or] = je[or].evaluate(it, Xe);
                  }, De;
                })(Z)).load(xe.features) : (function(De, he) {
                  return new mt(De, he);
                })(xe, Z.geojsonVtOptions), this.loaded = {};
                const Pe = { data: xe };
                if (ne) {
                  const De = ne.finish();
                  De && (Pe.resourceTiming = {}, Pe.resourceTiming[Z.source] = JSON.parse(JSON.stringify(De)));
                }
                return Pe;
              } catch (xe) {
                if (delete this._pendingRequest, m.cy(xe)) return { abandoned: true };
                throw xe;
              }
            }));
          }
          getData() {
            return m._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(Z) {
            const H = this.loaded;
            return H && H[Z.uid] ? super.reloadTile(Z) : this.loadTile(Z);
          }
          loadAndProcessGeoJSON(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              let ne = yield this.loadGeoJSON(Z, H);
              if (delete this._pendingRequest, typeof ne != "object") throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (Y(ne, true), Z.filter) {
                const xe = m.cT(Z.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (xe.result === "error") throw new Error(xe.value.map(((De) => `${De.key}: ${De.message}`)).join(", "));
                ne = { type: "FeatureCollection", features: ne.features.filter(((De) => xe.value.evaluate({ zoom: 0 }, De))) };
              }
              return ne;
            }));
          }
          loadGeoJSON(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const { promoteId: ne } = Z;
              if (Z.request) {
                const xe = yield m.j(Z.request, H);
                return this._dataUpdateable = m.cV(xe.data, ne) ? m.cU(xe.data, ne) : void 0, xe.data;
              }
              if (typeof Z.data == "string") try {
                const xe = JSON.parse(Z.data);
                return this._dataUpdateable = m.cV(xe, ne) ? m.cU(xe, ne) : void 0, xe;
              } catch {
                throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              }
              if (!Z.dataDiff) throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${Z.source}`);
              return m.cW(this._dataUpdateable, Z.dataDiff, ne), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(Z) {
            return m._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(Z) {
            return this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId);
          }
          getClusterChildren(Z) {
            return this._geoJSONIndex.getChildren(Z.clusterId);
          }
          getClusterLeaves(Z) {
            return this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset);
          }
        }
        class ki {
          constructor(Z) {
            this.self = Z, this.actor = new m.J(Z), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (H, ne) => {
              if (this.externalWorkerSourceTypes[H]) throw new Error(`Worker source with name "${H}" already registered.`);
              this.externalWorkerSourceTypes[H] = ne;
            }, this.self.addProtocol = m.cA, this.self.removeProtocol = m.cB, this.self.registerRTLTextPlugin = (H) => {
              m.cX.setMethods(H);
            }, this.actor.registerMessageHandler("LDT", ((H, ne) => this._getDEMWorkerSource(H, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RDT", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(H, ne.source).removeTile(ne);
            })))), this.actor.registerMessageHandler("GCEZ", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterExpansionZoom(ne);
            })))), this.actor.registerMessageHandler("GCC", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterChildren(ne);
            })))), this.actor.registerMessageHandler("GCL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterLeaves(ne);
            })))), this.actor.registerMessageHandler("LD", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).loadData(ne))), this.actor.registerMessageHandler("GD", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).getData())), this.actor.registerMessageHandler("LT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).reloadTile(ne))), this.actor.registerMessageHandler("AT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).abortTile(ne))), this.actor.registerMessageHandler("RMT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).removeTile(ne))), this.actor.registerMessageHandler("RS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              if (!this.workerSources[H] || !this.workerSources[H][ne.type] || !this.workerSources[H][ne.type][ne.source]) return;
              const xe = this.workerSources[H][ne.type][ne.source];
              delete this.workerSources[H][ne.type][ne.source], xe.removeSource !== void 0 && xe.removeSource(ne);
            })))), this.actor.registerMessageHandler("RM", ((H) => m._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[H], delete this.availableImages[H], delete this.workerSources[H], delete this.demWorkerSources[H], this.globalStates.delete(H);
            })))), this.actor.registerMessageHandler("SR", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this.referrer = ne;
            })))), this.actor.registerMessageHandler("SRPS", ((H, ne) => this._syncRTLPluginState(H, ne))), this.actor.registerMessageHandler("IS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this.self.importScripts(ne);
            })))), this.actor.registerMessageHandler("SI", ((H, ne) => this._setImages(H, ne))), this.actor.registerMessageHandler("UL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(H).update(ne.layers, ne.removedIds, this._getGlobalState(H));
            })))), this.actor.registerMessageHandler("UGS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              const xe = this._getGlobalState(H);
              for (const Pe in ne) xe[Pe] = ne[Pe];
            })))), this.actor.registerMessageHandler("SL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(H).replace(ne, this._getGlobalState(H));
            }))));
          }
          _getGlobalState(Z) {
            let H = this.globalStates.get(Z);
            return H || (H = {}, this.globalStates.set(Z, H)), H;
          }
          _setImages(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              this.availableImages[Z] = H;
              for (const ne in this.workerSources[Z]) {
                const xe = this.workerSources[Z][ne];
                for (const Pe in xe) xe[Pe].availableImages = H;
              }
            }));
          }
          _syncRTLPluginState(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              return yield m.cX.syncState(H, this.self.importScripts);
            }));
          }
          _getAvailableImages(Z) {
            let H = this.availableImages[Z];
            return H || (H = []), H;
          }
          _getLayerIndex(Z) {
            let H = this.layerIndexes[Z];
            return H || (H = this.layerIndexes[Z] = new s()), H;
          }
          _getWorkerSource(Z, H, ne) {
            if (this.workerSources[Z] || (this.workerSources[Z] = {}), this.workerSources[Z][H] || (this.workerSources[Z][H] = {}), !this.workerSources[Z][H][ne]) {
              const xe = { sendAsync: (Pe, De) => (Pe.targetMapId = Z, this.actor.sendAsync(Pe, De)) };
              switch (H) {
                case "vector":
                  this.workerSources[Z][H][ne] = new F(xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                case "geojson":
                  this.workerSources[Z][H][ne] = new Qr(xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                default:
                  this.workerSources[Z][H][ne] = new this.externalWorkerSourceTypes[H](xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
              }
            }
            return this.workerSources[Z][H][ne];
          }
          _getDEMWorkerSource(Z, H) {
            return this.demWorkerSources[Z] || (this.demWorkerSources[Z] = {}), this.demWorkerSources[Z][H] || (this.demWorkerSources[Z][H] = new D()), this.demWorkerSources[Z][H];
          }
        }
        return m.i(self) && (self.worker = new ki(self)), ki;
      })), f("index", ["exports", "./shared"], (function(m, s) {
        var C = "5.8.0";
        function P() {
          var y = new s.A(4);
          return s.A != Float32Array && (y[1] = 0, y[2] = 0), y[0] = 1, y[3] = 1, y;
        }
        let M, F;
        const D = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(y, e, a) {
          const c = requestAnimationFrame(((_) => {
            p(), e(_);
          })), { unsubscribe: p } = s.s(y.signal, "abort", (() => {
            p(), cancelAnimationFrame(c), a(s.c());
          }), false);
        }, frameAsync(y) {
          return new Promise(((e, a) => {
            this.frame(y, e, a);
          }));
        }, getImageData(y, e = 0) {
          return this.getImageCanvasContext(y).getImageData(-e, -e, y.width + 2 * e, y.height + 2 * e);
        }, getImageCanvasContext(y) {
          const e = window.document.createElement("canvas"), a = e.getContext("2d", { willReadFrequently: true });
          if (!a) throw new Error("failed to create canvas 2d context");
          return e.width = y.width, e.height = y.height, a.drawImage(y, 0, 0, y.width, y.height), a;
        }, resolveURL: (y) => (M || (M = document.createElement("a")), M.href = y, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (F == null && (F = matchMedia("(prefers-reduced-motion: reduce)")), F.matches);
        } };
        class A {
          static testProp(e) {
            if (!A.docStyle) return e[0];
            for (let a = 0; a < e.length; a++) if (e[a] in A.docStyle) return e[a];
            return e[0];
          }
          static create(e, a, c) {
            const p = window.document.createElement(e);
            return a !== void 0 && (p.className = a), c && c.appendChild(p), p;
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a);
          }
          static disableDrag() {
            A.docStyle && A.selectProp && (A.userSelect = A.docStyle[A.selectProp], A.docStyle[A.selectProp] = "none");
          }
          static enableDrag() {
            A.docStyle && A.selectProp && (A.docStyle[A.selectProp] = A.userSelect);
          }
          static setTransform(e, a) {
            e.style[A.transformProp] = a;
          }
          static addEventListener(e, a, c, p = {}) {
            e.addEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static removeEventListener(e, a, c, p = {}) {
            e.removeEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", A.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", A.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", A.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return { x: a.width / e.offsetWidth || 1, y: a.height / e.offsetHeight || 1, boundingClientRect: a };
          }
          static getPoint(e, a, c) {
            const p = a.boundingClientRect;
            return new s.P((c.clientX - p.left) / a.x - e.clientLeft, (c.clientY - p.top) / a.y - e.clientTop);
          }
          static mousePos(e, a) {
            const c = A.getScale(e);
            return A.getPoint(e, c, a);
          }
          static touchPos(e, a) {
            const c = [], p = A.getScale(e);
            for (let _ = 0; _ < a.length; _++) c.push(A.getPoint(e, p, a[_]));
            return c;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), c = a.querySelectorAll("script");
            for (const p of c) p.remove();
            return A.clean(a), a.innerHTML;
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) A.removeAttributes(c), A.clean(c);
          }
          static removeAttributes(e) {
            for (const { name: a, value: c } of e.attributes) A.isPossiblyDangerous(a, c) && e.removeAttribute(a);
          }
        }
        A.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, A.selectProp = A.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), A.transformProp = A.testProp(["transform", "WebkitTransform"]);
        const O = { supported: false, testSupport: function(y) {
          !W && Y && (ee ? ie(y) : V = y);
        } };
        let V, Y, W = false, ee = false;
        function ie(y) {
          const e = y.createTexture();
          y.bindTexture(y.TEXTURE_2D, e);
          try {
            if (y.texImage2D(y.TEXTURE_2D, 0, y.RGBA, y.RGBA, y.UNSIGNED_BYTE, Y), y.isContextLost()) return;
            O.supported = true;
          } catch {
          }
          y.deleteTexture(e), W = true;
        }
        var te;
        typeof document < "u" && (Y = document.createElement("img"), Y.onload = () => {
          V && ie(V), V = null, ee = true;
        }, Y.onerror = () => {
          W = true, V = null;
        }, Y.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(y) {
          let e, a, c, p;
          y.resetRequestQueue = () => {
            e = [], a = 0, c = 0, p = {};
          }, y.addThrottleControl = (T) => {
            const R = c++;
            return p[R] = T, R;
          }, y.removeThrottleControl = (T) => {
            delete p[T], x();
          }, y.getImage = (T, R, z = true) => new Promise(((j, $) => {
            O.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), s.e(T, { type: "image" }), e.push({ abortController: R, requestParameters: T, supportImageRefresh: z, state: "queued", onError: (U) => {
              $(U);
            }, onSuccess: (U) => {
              j(U);
            } }), x();
          }));
          const _ = (T) => s._(this, void 0, void 0, (function* () {
            T.state = "running";
            const { requestParameters: R, supportImageRefresh: z, onError: j, onSuccess: $, abortController: U } = T, Q = z === false && !s.i(self) && !s.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((ue, ge) => ue && ge === "accept"), true));
            a++;
            const se = Q ? k(R, U) : s.m(R, U);
            try {
              const ue = yield se;
              delete T.abortController, T.state = "completed", ue.data instanceof HTMLImageElement || s.b(ue.data) ? $(ue) : ue.data && $({ data: yield (le = ue.data, typeof createImageBitmap == "function" ? s.f(le) : s.h(le)), cacheControl: ue.cacheControl, expires: ue.expires });
            } catch (ue) {
              delete T.abortController, j(ue);
            } finally {
              a--, x();
            }
            var le;
          })), x = () => {
            const T = (() => {
              for (const R of Object.keys(p)) if (p[R]()) return true;
              return false;
            })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = a; R < T && e.length > 0; R++) {
              const z = e.shift();
              z.abortController.signal.aborted ? R-- : _(z);
            }
          }, k = (T, R) => new Promise(((z, j) => {
            const $ = new Image(), U = T.url, Q = T.credentials;
            Q && Q === "include" ? $.crossOrigin = "use-credentials" : (Q && Q === "same-origin" || !s.d(U)) && ($.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              $.src = "", j(s.c());
            })), $.fetchPriority = "high", $.onload = () => {
              $.onerror = $.onload = null, z({ data: $ });
            }, $.onerror = () => {
              $.onerror = $.onload = null, R.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, $.src = U;
          }));
        })(te || (te = {})), te.resetRequestQueue();
        class re {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function X(y) {
          const e = [];
          if (typeof y == "string") e.push({ id: "default", url: y });
          else if (y && y.length > 0) {
            const a = [];
            for (const { id: c, url: p } of y) {
              const _ = `${c}${p}`;
              a.indexOf(_) === -1 && (a.push(_), e.push({ id: c, url: p }));
            }
          }
          return e;
        }
        function Se(y, e, a) {
          try {
            const c = new URL(y);
            return c.pathname += `${e}${a}`, c.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${y}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function pe(y) {
          const { userImage: e } = y;
          return !!(e && e.render && e.render()) && (y.data.replace(new Uint8Array(e.data.buffer)), true);
        }
        class oe extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: a, promiseResolve: c } of this.requestors) c(this._getImagesForIds(a));
              this.requestors = [];
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new s.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null;
            }
            return a;
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a);
          }
          _validate(e, a) {
            let c = true;
            const p = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, p && p.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = false), this._validateStretch(a.stretchY, p && p.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = false), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), c = false), c;
          }
          _validateStretch(e, a) {
            if (!e) return true;
            let c = 0;
            for (const p of e) {
              if (p[0] < c || p[1] < p[0] || a < p[1]) return false;
              c = p[1];
            }
            return true;
          }
          _validateContent(e, a) {
            if (!e) return true;
            if (e.length !== 4) return false;
            const c = a.spriteData, p = c && c.width || a.data.width, _ = c && c.height || a.data.height;
            return !(e[0] < 0 || p < e[0] || e[1] < 0 || _ < e[1] || e[2] < 0 || p < e[2] || e[3] < 0 || _ < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, a, c = true) {
            const p = this.getImage(e);
            if (c && (p.data.width !== a.data.width || p.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${p.data.width}x${p.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = p.version + 1, this.images[e] = a, this.updatedImages[e] = true;
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let p = true;
              if (!this.isLoaded()) for (const _ of e) this.images[_] || (p = false);
              this.isLoaded() || p ? a(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: a });
            }));
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let p = this.getImage(c);
              p || (this.fire(new s.l("styleimagemissing", { id: c })), p = this.getImage(c)), p ? a[c] = { data: p.data.clone(), pixelRatio: p.pixelRatio, sdf: p.sdf, version: p.version, stretchX: p.stretchX, stretchY: p.stretchY, content: p.content, textFitWidth: p.textFitWidth, textFitHeight: p.textFitHeight, hasRenderCallback: !!(p.userImage && p.userImage.render) } : s.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return a;
          }
          getPixelSize() {
            const { width: e, height: a } = this.atlasImage;
            return { width: e, height: a };
          }
          getPattern(e) {
            const a = this.patterns[e], c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const p = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, _ = new s.I(p, c);
              this.patterns[e] = { bin: p, position: _ };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const _ in this.patterns) e.push(this.patterns[_].bin);
            const { w: a, h: c } = s.p(e), p = this.atlasImage;
            p.resize({ width: a || 1, height: c || 1 });
            for (const _ in this.patterns) {
              const { bin: x } = this.patterns[_], k = x.x + 1, T = x.y + 1, R = this.getImage(_).data, z = R.width, j = R.height;
              s.R.copy(R, p, { x: 0, y: 0 }, { x: k, y: T }, { width: z, height: j }), s.R.copy(R, p, { x: 0, y: j - 1 }, { x: k, y: T - 1 }, { width: z, height: 1 }), s.R.copy(R, p, { x: 0, y: 0 }, { x: k, y: T + j }, { width: z, height: 1 }), s.R.copy(R, p, { x: z - 1, y: 0 }, { x: k - 1, y: T }, { width: 1, height: j }), s.R.copy(R, p, { x: 0, y: 0 }, { x: k + z, y: T }, { width: 1, height: j });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = true;
              const c = this.getImage(a);
              c || s.w(`Image with ID: "${a}" was not found`), pe(c) && this.updateImage(a, c);
            }
          }
        }
        const fe = 1e20;
        function _e(y, e, a, c, p, _, x, k, T) {
          for (let R = e; R < e + c; R++) qe(y, a * _ + R, _, p, x, k, T);
          for (let R = a; R < a + p; R++) qe(y, R * _ + e, 1, c, x, k, T);
        }
        function qe(y, e, a, c, p, _, x) {
          _[0] = 0, x[0] = -fe, x[1] = fe, p[0] = y[e];
          for (let k = 1, T = 0, R = 0; k < c; k++) {
            p[k] = y[e + k * a];
            const z = k * k;
            do {
              const j = _[T];
              R = (p[k] - p[j] + z - j * j) / (k - j) / 2;
            } while (R <= x[T] && --T > -1);
            T++, _[T] = k, x[T] = R, x[T + 1] = fe;
          }
          for (let k = 0, T = 0; k < c; k++) {
            for (; x[T + 1] < k; ) T++;
            const R = _[T], z = k - R;
            y[e + k * a] = p[R] + z * z;
          }
        }
        class Ve {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = [];
              for (const _ in e) for (const x of e[_]) a.push(this._getAndCacheGlyphsPromise(_, x));
              const c = yield Promise.all(a), p = {};
              for (const { stack: _, id: x, glyph: k } of c) p[_] || (p[_] = {}), p[_][x] = k && { id: k.id, bitmap: k.bitmap.clone(), metrics: k.metrics };
              return p;
            }));
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function* () {
              let c = this.entries[e];
              c || (c = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let p = c.glyphs[a];
              if (p !== void 0) return { stack: e, id: a, glyph: p };
              if (p = this._tinySDF(c, e, a), p) return c.glyphs[a] = p, { stack: e, id: a, glyph: p };
              const _ = Math.floor(a / 256);
              if (256 * _ > 65535) throw new Error("glyphs > 65535 not supported");
              if (c.ranges[_]) return { stack: e, id: a, glyph: p };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!c.requests[_]) {
                const k = Ve.loadGlyphRange(e, _, this.url, this.requestManager);
                c.requests[_] = k;
              }
              const x = yield c.requests[_];
              for (const k in x) this._doesCharSupportLocalGlyph(+k) || (c.glyphs[+k] = x[+k]);
              return c.ranges[_] = true, { stack: e, id: a, glyph: x[a] || null };
            }));
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, a, c) {
            const p = this.localIdeographFontFamily;
            if (!p || !this._doesCharSupportLocalGlyph(c)) return;
            let _ = e.tinySDF;
            if (!_) {
              let k = "400";
              /bold/i.test(a) ? k = "900" : /medium/i.test(a) ? k = "500" : /light/i.test(a) && (k = "200"), _ = e.tinySDF = new Ve.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: p, fontWeight: k });
            }
            const x = _.draw(String.fromCharCode(c));
            return { id: c, bitmap: new s.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        Ve.loadGlyphRange = function(y, e, a, c) {
          return s._(this, void 0, void 0, (function* () {
            const p = 256 * e, _ = p + 255, x = c.transformRequest(a.replace("{fontstack}", y).replace("{range}", `${p}-${_}`), "Glyphs"), k = yield s.n(x, new AbortController());
            if (!k || !k.data) throw new Error(`Could not load glyph range. range: ${e}, ${p}-${_}`);
            const T = {};
            for (const R of s.o(k.data)) T[R.id] = R;
            return T;
          }));
        }, Ve.TinySDF = class {
          constructor({ fontSize: y = 24, buffer: e = 3, radius: a = 8, cutoff: c = 0.25, fontFamily: p = "sans-serif", fontWeight: _ = "normal", fontStyle: x = "normal", lang: k = null } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = k;
            const T = this.size = y + 4 * e, R = this._createCanvas(T), z = this.ctx = R.getContext("2d", { willReadFrequently: true });
            z.font = `${x} ${_} ${y}px ${p}`, z.textBaseline = "alphabetic", z.textAlign = "left", z.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T);
          }
          _createCanvas(y) {
            const e = document.createElement("canvas");
            return e.width = e.height = y, e;
          }
          draw(y) {
            const { width: e, actualBoundingBoxAscent: a, actualBoundingBoxDescent: c, actualBoundingBoxLeft: p, actualBoundingBoxRight: _ } = this.ctx.measureText(y), x = Math.ceil(a), k = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(_ - p))), T = Math.min(this.size - this.buffer, x + Math.ceil(c)), R = k + 2 * this.buffer, z = T + 2 * this.buffer, j = Math.max(R * z, 0), $ = new Uint8ClampedArray(j), U = { data: $, width: R, height: z, glyphWidth: k, glyphHeight: T, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
            if (k === 0 || T === 0) return U;
            const { ctx: Q, buffer: se, gridInner: le, gridOuter: ue } = this;
            this.lang && (Q.lang = this.lang), Q.clearRect(se, se, k, T), Q.fillText(y, se, se + x);
            const ge = Q.getImageData(se, se, k, T);
            ue.fill(fe, 0, j), le.fill(0, 0, j);
            for (let we = 0; we < T; we++) for (let ye = 0; ye < k; ye++) {
              const ke = ge.data[4 * (we * k + ye) + 3] / 255;
              if (ke === 0) continue;
              const Ae = (we + se) * R + ye + se;
              if (ke === 1) ue[Ae] = 0, le[Ae] = fe;
              else {
                const be = 0.5 - ke;
                ue[Ae] = be > 0 ? be * be : 0, le[Ae] = be < 0 ? be * be : 0;
              }
            }
            _e(ue, 0, 0, R, z, R, this.f, this.v, this.z), _e(le, se, se, k, T, R, this.f, this.v, this.z);
            for (let we = 0; we < j; we++) {
              const ye = Math.sqrt(ue[we]) - Math.sqrt(le[we]);
              $[we] = Math.round(255 - 255 * (ye / this.radius + this.cutoff));
            }
            return U;
          }
        };
        class Qe {
          constructor() {
            this.specification = s.v.light.position;
          }
          possiblyEvaluate(e, a) {
            return s.B(e.expression.evaluate(a));
          }
          interpolate(e, a, c) {
            return { x: s.C.number(e.x, a.x, c), y: s.C.number(e.y, a.y, c), z: s.C.number(e.z, a.z, c) };
          }
        }
        let ut;
        class gt extends s.E {
          constructor(e) {
            super(), ut = ut || new s.r({ anchor: new s.D(s.v.light.anchor), position: new Qe(), color: new s.D(s.v.light.color), intensity: new s.D(s.v.light.intensity) }), this._transitionable = new s.t(ut, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, a = {}) {
            if (!this._validate(s.x, e, a)) for (const c in e) {
              const p = e[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c) {
            return (!c || c.validate !== false) && s.y(this, e.call(s.z, { value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v }));
          }
        }
        const yt = new s.r({ "sky-color": new s.D(s.v.sky["sky-color"]), "horizon-color": new s.D(s.v.sky["horizon-color"]), "fog-color": new s.D(s.v.sky["fog-color"]), "fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"]) });
        class lt extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(yt, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0));
          }
          setSky(e, a = {}) {
            if (!this._validate(s.G, e, a)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const c in e) {
                const p = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== false && s.y(this, e.call(s.z, s.e({ value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class et {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c];
          }
          getDashRanges(e, a, c) {
            const p = [];
            let _ = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, x = e[0] * c, k = true;
            p.push({ left: _, right: x, isDash: k, zeroLength: e[0] === 0 });
            let T = e[0];
            for (let R = 1; R < e.length; R++) {
              k = !k;
              const z = e[R];
              _ = T * c, T += z, x = T * c, p.push({ left: _, right: x, isDash: k, zeroLength: z === 0 });
            }
            return p;
          }
          addRoundDash(e, a, c) {
            const p = a / 2;
            for (let _ = -c; _ <= c; _++) {
              const x = this.width * (this.nextRow + c + _);
              let k = 0, T = e[k];
              for (let R = 0; R < this.width; R++) {
                R / T.right > 1 && (T = e[++k]);
                const z = Math.abs(R - T.left), j = Math.abs(R - T.right), $ = Math.min(z, j);
                let U;
                const Q = _ / c * (p + 1);
                if (T.isDash) {
                  const se = p - Math.abs(Q);
                  U = Math.sqrt($ * $ + se * se);
                } else U = p - Math.sqrt($ * $ + Q * Q);
                this.data[x + R] = Math.max(0, Math.min(255, U + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let k = e.length - 1; k >= 0; --k) {
              const T = e[k], R = e[k + 1];
              T.zeroLength ? e.splice(k, 1) : R && R.isDash === T.isDash && (R.left = T.left, e.splice(k, 1));
            }
            const a = e[0], c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const p = this.width * this.nextRow;
            let _ = 0, x = e[_];
            for (let k = 0; k < this.width; k++) {
              k / x.right > 1 && (x = e[++_]);
              const T = Math.abs(k - x.left), R = Math.abs(k - x.right), z = Math.min(T, R);
              this.data[p + k] = Math.max(0, Math.min(255, (x.isDash ? z : -z) + 128));
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0, p = 2 * c + 1;
            if (this.nextRow + p > this.height) return s.w("LineAtlas out of space"), null;
            let _ = 0;
            for (let k = 0; k < e.length; k++) _ += e[k];
            if (_ !== 0) {
              const k = this.width / _, T = this.getDashRanges(e, this.width, k);
              a ? this.addRoundDash(T, k, c) : this.addRegularDash(T);
            }
            const x = { y: this.nextRow + c, height: 2 * c, width: _ };
            return this.nextRow += p, this.dirty = true, x;
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data));
          }
        }
        const dt = "maplibre_preloaded_worker_pool";
        class Ft {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < Ft.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = true, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((a) => {
              a.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[dt];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const ft = Math.floor(D.hardwareConcurrency / 2);
        let _t, $t;
        function Qt() {
          return _t || (_t = new Ft()), _t;
        }
        Ft.workerCount = s.H(globalThis) ? Math.max(Math.min(ft, 3), 1) : 1;
        class Lt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let p = 0; p < c.length; p++) {
              const _ = new s.J(c[p], a);
              _.name = `Worker ${p}`, this.actors.push(_);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, a) {
            const c = [];
            for (const p of this.actors) c.push(p.sendAsync({ type: e, data: a }));
            return Promise.all(c);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = true) {
            this.actors.forEach(((a) => {
              a.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a);
          }
        }
        function zt() {
          return $t || ($t = new Lt(Qt(), s.K), $t.registerMessageHandler("GR", ((y, e, a) => s.m(e, a)))), $t;
        }
        function It(y, e) {
          const a = s.L();
          return s.M(a, a, [1, 1, 0]), s.N(a, a, [0.5 * y.width, 0.5 * y.height, 1]), y.calculatePosMatrix ? s.O(a, a, y.calculatePosMatrix(e.toUnwrapped())) : a;
        }
        function At(y, e, a, c, p, _, x) {
          var k;
          const T = (function($, U, Q) {
            if ($) for (const se of $) {
              const le = U[se];
              if (le && le.source === Q && le.type === "fill-extrusion") return true;
            }
            else for (const se in U) {
              const le = U[se];
              if (le.source === Q && le.type === "fill-extrusion") return true;
            }
            return false;
          })((k = p == null ? void 0 : p.layers) !== null && k !== void 0 ? k : null, e, y.id), R = _.maxPitchScaleFactor(), z = y.tilesIn(c, R, T);
          z.sort(mr);
          const j = [];
          for (const $ of z) j.push({ wrappedTileID: $.tileID.wrapped().key, queryResults: $.tile.queryRenderedFeatures(e, a, y._state, $.queryGeometry, $.cameraQueryGeometry, $.scale, p, _, R, It(y.transform, $.tileID), x ? (U, Q) => x($.tileID, U, Q) : void 0) });
          return (function($, U) {
            for (const Q in $) for (const se of $[Q]) gr(se, U);
            return $;
          })((function($) {
            const U = {}, Q = {};
            for (const se of $) {
              const le = se.queryResults, ue = se.wrappedTileID, ge = Q[ue] = Q[ue] || {};
              for (const we in le) {
                const ye = le[we], ke = ge[we] = ge[we] || {}, Ae = U[we] = U[we] || [];
                for (const be of ye) ke[be.featureIndex] || (ke[be.featureIndex] = true, Ae.push(be));
              }
            }
            return U;
          })(j), y);
        }
        function mr(y, e) {
          const a = y.tileID, c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x;
        }
        function gr(y, e) {
          const a = y.feature, c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c;
        }
        function ir(y, e, a) {
          return s._(this, void 0, void 0, (function* () {
            let c = y;
            if (y.url ? c = (yield s.j(e.transformRequest(y.url, "Source"), a)).data : yield D.frameAsync(a), !c) return null;
            const p = s.Q(s.e(c, y), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (p.vectorLayerIds = c.vector_layers.map(((_) => _.id))), p;
          }));
        }
        class nr {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          extend(e) {
            const a = this._sw, c = this._ne;
            let p, _;
            if (e instanceof s.S) p = e, _ = e;
            else {
              if (!(e instanceof nr)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(nr.convert(e)) : this.extend(s.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.S.convert(e)) : this;
              if (p = e._sw, _ = e._ne, !p || !_) return this;
            }
            return a || c ? (a.lng = Math.min(p.lng, a.lng), a.lat = Math.min(p.lat, a.lat), c.lng = Math.max(_.lng, c.lng), c.lat = Math.max(_.lat, c.lat)) : (this._sw = new s.S(p.lng, p.lat), this._ne = new s.S(_.lng, _.lat)), this;
          }
          getCenter() {
            return new s.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new s.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new s.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: a, lat: c } = s.S.convert(e);
            let p = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (p = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && p;
          }
          static convert(e) {
            return e instanceof nr ? e : e && new nr(e);
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017, p = c / Math.cos(Math.PI / 180 * e.lat);
            return new nr(new s.S(e.lng - p, e.lat - c), new s.S(e.lng + p, e.lat + c));
          }
          adjustAntiMeridian() {
            const e = new s.S(this._sw.lng, this._sw.lat), a = new s.S(this._ne.lng, this._ne.lat);
            return new nr(e, e.lng > a.lng ? new s.S(a.lng + 360, a.lat) : a);
          }
        }
        class Ut {
          constructor(e, a, c) {
            this.bounds = nr.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const a = Math.pow(2, e.z), c = Math.floor(s.V(this.bounds.getWest()) * a), p = Math.floor(s.U(this.bounds.getNorth()) * a), _ = Math.ceil(s.V(this.bounds.getEast()) * a), x = Math.ceil(s.U(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < _ && e.y >= p && e.y < x;
          }
        }
        class Ar extends s.E {
          constructor(e, a, c, p) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, s.e(this, s.Q(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({ type: "vector" }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(p);
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield ir(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Ut(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return s.e({}, this._options);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(a, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let p = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((_, x) => {
                  e.reloadPromise = { resolve: _, reject: x };
                }));
              } else e.actor = this.dispatcher.getActor(), p = "LT";
              e.abortController = new AbortController();
              try {
                const _ = yield e.actor.sendAsync({ type: p, data: c }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, _);
              } catch (_) {
                if (delete e.abortController, e.aborted) return;
                if (_ && _.status !== 404) throw _;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject);
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class wr extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(p), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = s.e({ type: "raster" }, a), s.e(this, s.Q(a, ["url", "scheme", "tileSize"]));
          }
          load() {
            return s._(this, arguments, void 0, (function* (e = false) {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield ir(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, a && (s.e(this, a), a.bounds && (this.tileBounds = new Ut(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return s.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const c = yield te.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const p = this.map.painter.context, _ = p.gl, x = c.data;
                  e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: true }) : (e.texture = new s.T(p, x, _.RGBA, { useMipmap: true }), e.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE, _.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Ct extends wr {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const p = yield te.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (p && p.data) {
                  const _ = p.data;
                  this.map._refreshExpiredTiles && (p.cacheControl || p.expires) && e.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                  const x = s.b(_) && s.W() ? _ : yield this.readImageNow(_), k = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({ type: "LDT", data: k });
                    e.dem = T, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
                  }
                }
              } catch (p) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (p) throw e.state = "errored", p;
              }
            }));
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && s.X()) {
                const a = e.width + 2, c = e.height + 2;
                try {
                  return new s.R({ width: a, height: c }, yield s.Y(e, -1, -1, a, c));
                } catch {
                }
              }
              return D.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const a = e.canonical, c = Math.pow(2, a.z), p = (a.x - 1 + c) % c, _ = a.x === 0 ? e.wrap - 1 : e.wrap, x = (a.x + 1 + c) % c, k = a.x + 1 === c ? e.wrap + 1 : e.wrap, T = {};
            return T[new s.Z(e.overscaledZ, _, a.z, p, a.y).key] = { backfilled: false }, T[new s.Z(e.overscaledZ, k, a.z, x, a.y).key] = { backfilled: false }, a.y > 0 && (T[new s.Z(e.overscaledZ, _, a.z, p, a.y - 1).key] = { backfilled: false }, T[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = { backfilled: false }, T[new s.Z(e.overscaledZ, k, a.z, x, a.y - 1).key] = { backfilled: false }), a.y + 1 < c && (T[new s.Z(e.overscaledZ, _, a.z, p, a.y + 1).key] = { backfilled: false }, T[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = { backfilled: false }, T[new s.Z(e.overscaledZ, k, a.z, x, a.y + 1).key] = { backfilled: false }), T;
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        class Ee extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: a.data }, this.actor = c.getActor(), this.setEventedParent(p), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: a.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128), tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : 0.375), extent: s.$, maxZoom: this.maxzoom, lineMetrics: a.lineMetrics || false, generateId: a.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom), minPoints: Math.max(2, a.clusterMinPoints || 2), extent: s.$, radius: this._pixelsToTileUnits(a.clusterRadius || 50), log: false, generateId: a.generateId || false }, clusterProperties: a.clusterProperties, filter: a.filter }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (s.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return s._(this, void 0, void 0, (function* () {
              const e = s.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map(((a) => a.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return s._(this, void 0, void 0, (function* () {
              const e = new nr(), a = yield this.getData();
              let c;
              switch (a.type) {
                case "FeatureCollection":
                  c = a.features.map(((p) => this.getCoordinatesFromGeometry(p.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  c = this.getCoordinatesFromGeometry(a.geometry);
                  break;
                default:
                  c = this.getCoordinatesFromGeometry(a);
              }
              if (c.length == 0) return e;
              for (let p = 0; p < c.length - 1; p += 2) e.extend([c[p], c[p + 1]]);
              return e;
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: a, offset: c } });
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: a } = this._pendingWorkerUpdate;
              if (!e && !a) return void s.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const c = s.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(D.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = true, this.fire(new s.l("dataloading", { dataType: "source" }));
              try {
                const p = yield this.actor.sendAsync({ type: "LD", data: c });
                if (this._isUpdatingWorker = false, this._removed || p.abandoned) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this._data = p.data;
                let _ = null;
                p.resourceTiming && p.resourceTiming[this.id] && (_ = p.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && _ && _.length > 0 && s.e(x, { resourceTiming: _ }), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
              } catch (p) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this.fire(new s.k(p));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e.abortController = new AbortController();
              const p = yield this.actor.sendAsync({ type: a, data: c }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(p, this.map.painter, a === "RT");
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return s.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class nt extends s.E {
          constructor(e, a, c, p) {
            super(), this.flippedWindingOrder = false, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(p), this.options = a;
          }
          load(e) {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const a = yield te.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading());
              } catch (a) {
                this._request = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a1.fromLngLat);
            var c;
            return this.tileID = (function(p) {
              const _ = s.a2.fromPoints(p), x = _.width(), k = _.height(), T = Math.max(x, k), R = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)), z = Math.pow(2, R);
              return new s.a4(R, Math.floor((_.minX + _.maxX) / 2 * z), Math.floor((_.minY + _.maxY) / 2 * z));
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map(((p) => this.tileID.getTilePoint(p)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const _ = this.tiles[p];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e) {
            const { minX: a, minY: c, maxX: p, maxY: _ } = s.a2.fromPoints(e), x = {};
            for (let k = 0; k <= s.a3; k++) {
              const T = Math.pow(2, k), R = Math.floor(a * T), z = Math.floor(c * T), j = Math.floor(p * T), $ = Math.floor(_ * T);
              x[k] = { minTileX: R, minTileY: z, maxTileX: j, maxTileY: $ };
            }
            return x;
          }
        }
        class Be extends nt {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.roundZoom = true, this.type = "video", this.options = a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a5(this.urls);
                if (this._loaded = true, !a) return;
                this.video = a, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (a) {
                this.fire(new s.k(a));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const _ = this.tiles[p];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Ye extends nt {
          constructor(e, a, c, p) {
            super(e, a, c, p), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(((_) => !Array.isArray(_) || _.length !== 2 || _.some(((x) => typeof x != "number")))) || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context, c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new s.T(a, this.canvas, c.RGBA, { premultiply: true });
            let p = false;
            for (const _ in this.tiles) {
              const x = this.tiles[_];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, p = true);
            }
            p && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
            return false;
          }
        }
        const ht = {}, bt = (y) => {
          switch (y) {
            case "geojson":
              return Ee;
            case "image":
              return nt;
            case "raster":
              return wr;
            case "raster-dem":
              return Ct;
            case "vector":
              return Ar;
            case "video":
              return Be;
            case "canvas":
              return Ye;
          }
          return ht[y];
        }, tt = "RTLPluginLoaded";
        class mt extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = zt();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((a) => {
              throw this.status = "error", a;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function* (a, c = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = D.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(tt));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Kt = null;
        function Qr() {
          return Kt || (Kt = new mt()), Kt;
        }
        class ki {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = s.a7(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const a = e + this.timeAdded;
            a < this.fadeEndTime || (this.fadeEndTime = a);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(p, _) {
                const x = {};
                if (!_) return x;
                for (const k of p) {
                  const T = k.layerIds.map(((R) => _.getLayer(R))).filter(Boolean);
                  if (T.length !== 0) {
                    k.layers = T, k.stateDependentLayerIds && (k.stateDependentLayers = k.stateDependentLayerIds.map(((R) => T.filter(((z) => z.id === R))[0])));
                    for (const R of T) x[R.id] = k;
                  }
                }
                return x;
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = false;
              for (const p in this.buckets) {
                const _ = this.buckets[p];
                if (_ instanceof s.a9) {
                  if (this.hasSymbolBuckets = true, !c) break;
                  _.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const p in this.buckets) {
                const _ = this.buckets[p];
                if (_ instanceof s.a9 && _.hasRTLText) {
                  this.hasRTLText = true, Qr().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const p in this.buckets) {
                const _ = this.buckets[p];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(p).queryRadius(_));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions;
            } else this.collisionBoxArray = new s.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const c in this.buckets) {
              const p = this.buckets[c];
              p.uploadPending() && p.upload(e);
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, a, c, p, _, x, k, T, R, z, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: _, scale: x, tileSize: this.tileSize, pixelPosMatrix: z, transform: T, params: k, queryPadding: this.queryPadding * R, getElevation: j }, e, a, c) : {};
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const p = c.loadVTLayers(), _ = a && a.sourceLayer ? a.sourceLayer : "", x = p._geojsonTileLayer || p[_];
            if (!x) return;
            const k = s.aa(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState), { z: T, x: R, y: z } = this.tileID.canonical, j = { z: T, x: R, y: z };
            for (let $ = 0; $ < x.length; $++) {
              const U = x.feature($);
              if (k.needGeometry) {
                const le = s.ab(U, true);
                if (!k.filter(new s.F(this.tileID.overscaledZ), le, this.tileID.canonical)) continue;
              } else if (!k.filter(new s.F(this.tileID.overscaledZ), U)) continue;
              const Q = c.getId(U, _), se = new s.ac(U, T, R, z, Q);
              se.tile = j, e.push(se);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = s.ad(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let p = false;
              if (this.expirationTime > c) p = false;
              else if (a) if (this.expirationTime < a) p = true;
              else {
                const _ = this.expirationTime - a;
                _ ? this.expirationTime = c + Math.max(_, 3e4) : p = true;
              }
              else p = true;
              p ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const p in this.buckets) {
              if (!a.style.hasLayer(p)) continue;
              const _ = this.buckets[p], x = _.layers[0].sourceLayer || "_geojsonTileLayer", k = c[x], T = e[x];
              if (!k || !T || Object.keys(T).length === 0) continue;
              _.update(T, k, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const R = a && a.style && a.style.getLayer(p);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(_)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < D.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = D.now() + e;
          }
          setDependencies(e, a) {
            const c = {};
            for (const p of a) c[p] = true;
            this.dependencies[e] = c;
          }
          hasDependency(e, a) {
            for (const c of e) {
              const p = this.dependencies[c];
              if (p) {
                for (const _ of a) if (p[_]) return true;
              }
            }
            return false;
          }
        }
        class ze {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset();
          }
          reset() {
            for (const e in this.data) for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, a, c) {
            const p = e.wrapped().key;
            this.data[p] === void 0 && (this.data[p] = []);
            const _ = { value: a, timeout: void 0 };
            if (c !== void 0 && (_.timeout = setTimeout((() => {
              this.remove(e, _);
            }), c)), this.data[p].push(_), this.order.push(p), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value;
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key, p = a === void 0 ? 0 : this.data[c].indexOf(a), _ = this.data[c][p];
            return this.data[c].splice(p, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a);
            }
            return this;
          }
          filter(e) {
            const a = [];
            for (const c in this.data) for (const p of this.data[c]) e(p.value) || a.push(p);
            for (const c of a) this.remove(c.value.tileID, c);
          }
        }
        class Z {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, a, c) {
            const p = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][p] = this.stateChanges[e][p] || {}, s.e(this.stateChanges[e][p], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const _ in this.state[e]) _ !== p && (this.deletedStates[e][_] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][p] === null) {
              this.deletedStates[e][p] = {};
              for (const _ in this.state[e][p]) c[_] || (this.deletedStates[e][p][_] = null);
            } else for (const _ in c) this.deletedStates[e] && this.deletedStates[e][p] && this.deletedStates[e][p][_] === null && delete this.deletedStates[e][p][_];
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const p = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][p] !== null && (this.deletedStates[e][p] = this.deletedStates[e][p] || {}, this.deletedStates[e][p][c] = null);
            else if (a !== void 0) if (this.stateChanges[e] && this.stateChanges[e][p]) for (c in this.deletedStates[e][p] = {}, this.stateChanges[e][p]) this.deletedStates[e][p][c] = null;
            else this.deletedStates[e][p] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, a) {
            const c = String(a), p = s.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const _ = this.deletedStates[e][a];
              if (_ === null) return {};
              for (const x in _) delete p[x];
            }
            return p;
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a);
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const p in this.stateChanges) {
              this.state[p] = this.state[p] || {};
              const _ = {};
              for (const x in this.stateChanges[p]) this.state[p][x] || (this.state[p][x] = {}), s.e(this.state[p][x], this.stateChanges[p][x]), _[x] = this.state[p][x];
              c[p] = _;
            }
            for (const p in this.deletedStates) {
              this.state[p] = this.state[p] || {};
              const _ = {};
              if (this.deletedStates[p] === null) for (const x in this.state[p]) _[x] = {}, this.state[p][x] = {};
              else for (const x in this.deletedStates[p]) {
                if (this.deletedStates[p][x] === null) this.state[p][x] = {};
                else for (const k of Object.keys(this.deletedStates[p][x])) delete this.state[p][x][k];
                _[x] = this.state[p][x];
              }
              c[p] = c[p] || {}, s.e(c[p], _);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const p in e) e[p].setFeatureState(c, a);
          }
        }
        const H = 89.25;
        function ne(y, e) {
          const a = s.ah(e.lat, -s.ai, s.ai);
          return new s.P(s.V(e.lng) * y, s.U(a) * y);
        }
        function xe(y, e) {
          return new s.a1(e.x / y, e.y / y).toLngLat();
        }
        function Pe(y) {
          return y.cameraToCenterDistance * Math.min(0.85 * Math.tan(s.ae(90 - y.pitch)), Math.tan(s.ae(H - y.pitch)));
        }
        function De(y, e) {
          const a = y.canonical, c = e / s.af(a.z), p = a.x + Math.pow(2, a.z) * y.wrap, _ = s.ag(new Float64Array(16));
          return s.M(_, _, [p * c, a.y * c, 0]), s.N(_, _, [c / s.$, c / s.$, 1]), _;
        }
        function he(y, e, a, c, p) {
          const _ = s.a1.fromLngLat(y, e), x = p * s.aj(1, y.lat), k = x * Math.cos(s.ae(a)), T = Math.sqrt(x * x - k * k), R = T * Math.sin(s.ae(-c)), z = T * Math.cos(s.ae(-c));
          return new s.a1(_.x + R, _.y + z, _.z + k);
        }
        function ve(y, e, a) {
          const c = e.intersectsFrustum(y);
          if (!a || c === 0) return c;
          const p = e.intersectsPlane(a);
          return p === 0 ? 0 : c === 2 && p === 2 ? 2 : 1;
        }
        function je(y, e, a) {
          let c = 0;
          const p = (a - e) / 10;
          for (let _ = 0; _ < 10; _++) c += p * Math.pow(Math.cos(e + (_ + 0.5) / 10 * (a - e)), y);
          return c;
        }
        function it(y, e) {
          return function(a, c, p, _, x) {
            const k = 2 * ((y - 1) / s.ak(Math.cos(s.ae(H - x)) / Math.cos(s.ae(H))) - 1), T = Math.acos(p / _), R = 2 * je(k - 1, 0, s.ae(x / 2)), z = Math.min(s.ae(H), T + s.ae(x / 2)), j = je(k - 1, Math.min(z, T - s.ae(x / 2)), z), $ = Math.atan(c / p), U = Math.hypot(c, p);
            let Q = a;
            return Q += s.ak(_ / U / Math.max(0.5, Math.cos(s.ae(x / 2)))), Q += k * s.ak(Math.cos($)) / 2, Q -= s.ak(Math.max(1, j / R / e)) / 2, Q;
          };
        }
        const Xe = it(9.314, 3);
        function xt(y, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(y.zoom + s.ak(y.tileSize / e.tileSize));
          return Math.max(0, a);
        }
        function Te(y, e) {
          const a = y.getCameraFrustum(), c = y.getClippingPlane(), p = y.screenPointToMercatorCoordinate(y.getCameraPoint()), _ = s.a1.fromLngLat(y.center, y.elevation);
          p.z = _.z + Math.cos(y.pitchInRadians) * y.cameraToCenterDistance / y.worldSize;
          const x = y.getCoveringTilesDetailsProvider(), k = x.allowVariableZoom(y, e), T = xt(y, e), R = e.minzoom || 0, z = e.maxzoom !== void 0 ? e.maxzoom : y.maxZoom, j = Math.min(Math.max(0, T), z), $ = Math.pow(2, j), U = [$ * p.x, $ * p.y, 0], Q = [$ * _.x, $ * _.y, 0], se = Math.hypot(_.x - p.x, _.y - p.y), le = Math.abs(_.z - p.z), ue = Math.hypot(se, le), ge = (ke) => ({ zoom: 0, x: 0, y: 0, wrap: ke, fullyVisible: false }), we = [], ye = [];
          if (y.renderWorldCopies && x.allowWorldCopies()) for (let ke = 1; ke <= 3; ke++) we.push(ge(-ke)), we.push(ge(ke));
          for (we.push(ge(0)); we.length > 0; ) {
            const ke = we.pop(), Ae = ke.x, be = ke.y;
            let Le = ke.fullyVisible;
            const Ke = { x: Ae, y: be, z: ke.zoom }, We = x.getTileBoundingVolume(Ke, ke.wrap, y.elevation, e);
            if (!Le) {
              const St = ve(a, We, c);
              if (St === 0) continue;
              Le = St === 2;
            }
            const He = x.distanceToTile2d(p.x, p.y, Ke, We);
            let Je = T;
            k && (Je = (e.calculateTileZoom || Xe)(y.zoom + s.ak(y.tileSize / e.tileSize), He, le, ue, y.fov)), Je = (e.roundZoom ? Math.round : Math.floor)(Je), Je = Math.max(0, Je);
            const kt = Math.min(Je, z);
            if (ke.wrap = x.getWrap(_, Ke, ke.wrap), ke.zoom >= kt) {
              if (ke.zoom < R) continue;
              const St = j - ke.zoom, pt = U[0] - 0.5 - (Ae << St), Nt = U[1] - 0.5 - (be << St), yr = e.reparseOverscaled ? Math.max(ke.zoom, Je) : ke.zoom;
              ye.push({ tileID: new s.Z(ke.zoom === z ? yr : ke.zoom, ke.wrap, ke.zoom, Ae, be), distanceSq: s.al([Q[0] - 0.5 - Ae, Q[1] - 0.5 - be]), tileDistanceToCamera: Math.sqrt(pt * pt + Nt * Nt) });
            } else for (let St = 0; St < 4; St++) we.push({ zoom: ke.zoom + 1, x: (Ae << 1) + St % 2, y: (be << 1) + (St >> 1), wrap: ke.wrap, fullyVisible: Le });
          }
          return ye.sort(((ke, Ae) => ke.distanceSq - Ae.distanceSq)).map(((ke) => ke.tileID));
        }
        const Vt = s.a2.fromPoints([new s.P(0, 0), new s.P(s.$, s.$)]);
        class or extends s.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", ((p) => this._dataHandler(p))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((p, _, x, k) => {
              const T = new (bt(_.type))(p, _, x, k);
              if (T.id !== p) throw new Error(`Expected Source id to be ${p} instead of ${T.id}`);
              return T;
            })(e, a, c, this), this._tiles = {}, this._cache = new ze(0, ((p) => this._unloadTile(p))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Z(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, a, c) {
            return s._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c);
              } catch (p) {
                e.state = "errored", p.status !== 404 ? this._source.fire(new s.k(p, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(qt).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, p) => {
              const _ = c.tileID, x = p.tileID, k = new s.P(_.canonical.x, _.canonical.y)._rotate(-this.transform.bearingInRadians), T = new s.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return _.overscaledZ - x.overscaledZ || T.y - k.y || T.x - k.x;
            })).map(((c) => c.tileID.key)) : a.map(((c) => c.tileID)).sort(qt).map(((c) => c.key));
          }
          hasRenderableParent(e) {
            const a = this.findLoadedParent(e, 0);
            return !!a && this._isIdRenderable(a.tileID.key);
          }
          _isIdRenderable(e, a) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (a || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const a in this._tiles) e ? this._reloadTile(a, "expired") : this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading");
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a));
            }));
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = D.now(), c === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let p = 0; p < a.length; p++) {
              const _ = a[p];
              if (e.neighboringTiles && e.neighboringTiles[_]) {
                const x = this.getTileByID(_);
                c(e, x), c(x, e);
              }
            }
            function c(p, _) {
              p.needsHillshadePrepare = true, p.needsTerrainPrepare = true;
              let x = _.tileID.canonical.x - p.tileID.canonical.x;
              const k = _.tileID.canonical.y - p.tileID.canonical.y, T = Math.pow(2, p.tileID.canonical.z), R = _.tileID.key;
              x === 0 && k === 0 || Math.abs(k) > 1 || (Math.abs(x) > 1 && (Math.abs(x + T) === 1 ? x += T : Math.abs(x - T) === 1 && (x -= T)), _.dem && p.dem && (p.dem.backfillBorder(_.dem, x, k), p.neighboringTiles && p.neighboringTiles[R] && (p.neighboringTiles[R].backfilled = true)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, a) {
            const c = Object.values(e), p = this._getLoadedDescendents(c), _ = {};
            for (const x of c) {
              const k = p[x.key];
              if (!(k == null ? void 0 : k.length)) {
                _[x.key] = x;
                continue;
              }
              const T = x.overscaledZ + or.maxUnderzooming, R = k.filter((($) => $.tileID.overscaledZ <= T));
              if (!R.length) {
                _[x.key] = x;
                continue;
              }
              const z = Math.min(...R.map((($) => $.tileID.overscaledZ))), j = R.filter((($) => $.tileID.overscaledZ === z)).map((($) => $.tileID));
              for (const $ of j) a[$.key] = $;
              this._areDescendentsComplete(j, z, x.overscaledZ) || (_[x.key] = x);
            }
            return _;
          }
          _getLoadedDescendents(e) {
            var a;
            const c = {};
            for (const p in this._tiles) {
              const _ = this._tiles[p];
              if (_.hasData()) for (const x of e) _.tileID.isChildOf(x) && (c[a = x.key] || (c[a] = [])).push(_);
            }
            return c;
          }
          _areDescendentsComplete(e, a, c) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - c) === e.length;
          }
          findLoadedParent(e, a) {
            if (e.key in this._loadedParentTiles) {
              const c = this._loadedParentTiles[e.key];
              return c && c.tileID.overscaledZ >= a ? c : null;
            }
            for (let c = e.overscaledZ - 1; c >= a; c--) {
              const p = e.scaledTo(c), _ = this._getLoadedTile(p);
              if (_) return _;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a && a.hasData() ? a : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1, c = Math.ceil(e.height / this._source.tileSize) + 1, p = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), _ = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, p) : p;
            this._cache.setMaxSize(_);
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const p in this._tiles) {
                const _ = this._tiles[p];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + a), c[_.tileID.key] = _;
              }
              this._tiles = c;
              for (const p in this._timers) clearTimeout(this._timers[p]), delete this._timers[p];
              for (const p in this._tiles) this._setTileReloadTimer(p, this._tiles[p]);
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((R) => new s.Z(R.canonical.z, R.wrap, R.canonical.z, R.canonical.x, R.canonical.y))) : (c = Te(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: a, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (c = c.filter(((R) => this._source.hasTile(R))))) : c = [], this.usedForTerrain && (c = this._addTerrainIdealTiles(c));
            const p = xt(e, this._source), _ = Math.max(p - or.maxOverzooming, this._source.minzoom), x = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, x && this.fire(new s.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const k = this._updateRetainedTiles(c, p);
            dr(this._source.type) && !a && this._updateFadingTiles(k, _);
            for (const R in k) this._tiles[R].clearFadeHold();
            const T = s.am(this._tiles, k);
            for (const R of T) {
              const z = this._tiles[R];
              z.hasSymbolBuckets && !z.holdingForFade() ? z.setHoldDuration(this.map._fadeDuration) : z.hasSymbolBuckets && !z.symbolFadeFinished() || this._removeTile(R);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const c of e) if (c.canonical.z > this._source.minzoom) {
              const p = c.scaledTo(c.canonical.z - 1);
              a.push(p);
              const _ = c.scaledTo(Math.max(this._source.minzoom, Math.min(c.canonical.z, 5)));
              a.push(_);
            }
            return e.concat(a);
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, a) {
            var c;
            const p = {}, _ = {}, x = Math.max(a - or.maxOverzooming, this._source.minzoom);
            let k = {};
            for (const T of e) {
              const R = this._addTile(T);
              p[T.key] = T, R.hasData() || (k[T.key] = T);
            }
            k = this._retainLoadedChildren(k, p);
            for (const T in k) {
              const R = k[T];
              let z = this._tiles[T], j = z == null ? void 0 : z.wasRequested();
              for (let $ = R.overscaledZ - 1; $ >= x; --$) {
                const U = R.scaledTo($);
                if (_[U.key]) break;
                if (_[U.key] = true, z = this.getTile(U), !z && j && (z = this._addTile(U)), z) {
                  const Q = z.hasData();
                  if ((Q || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || j) && (p[U.key] = U), j = z.wasRequested(), Q) break;
                }
              }
            }
            return p;
          }
          _updateFadingTiles(e, a) {
            const c = {}, p = {}, _ = Object.keys(e), x = D.now();
            for (const k of _) {
              const T = e[k], R = this._tiles[k];
              if (!R || R.fadeEndTime !== 0 && R.fadeEndTime <= x) continue;
              const z = this.findLoadedParent(T, a), j = this.findLoadedSibling(T), $ = z || j || null;
              $ && (this._addTile($.tileID), c[$.tileID.key] = $.tileID), p[k] = T;
            }
            this._retainLoadedChildren(p, e);
            for (const k in c) e[k] || (this._coveredTiles[k] = true, e[k] = c[k]);
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const a = [];
              let c, p = this._tiles[e].tileID;
              for (; p.overscaledZ > 0; ) {
                if (p.key in this._loadedParentTiles) {
                  c = this._loadedParentTiles[p.key];
                  break;
                }
                a.push(p.key);
                const _ = p.scaledTo(p.overscaledZ - 1);
                if (c = this._getLoadedTile(_), c) break;
                p = _;
              }
              for (const _ of a) this._loadedParentTiles[_] = c;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const a = this._tiles[e].tileID, c = this._getLoadedTile(a);
              this._loadedSiblingTiles[a.key] = c;
            }
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, a)));
            const c = a;
            return a || (a = new ki(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new s.l("dataloading", { tile: a, coord: a.tileID, dataType: "source" })), a;
          }
          _setTileReloadTimer(e, a) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), c));
          }
          refreshTiles(e) {
            for (const a in this._tiles) (this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some(((c) => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired");
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = true, this._abortTile(a), this._unloadTile(a))));
          }
          _dataHandler(e) {
            const a = e.sourceDataType;
            e.dataType === "source" && a === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && a === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, a, c) {
            const p = [], _ = this.transform;
            if (!_) return p;
            const x = _.getCoveringTilesDetailsProvider().allowWorldCopies(), k = c ? _.getCameraQueryGeometry(e) : e, T = (U) => _.screenPointToMercatorCoordinate(U, this.terrain), R = this.transformBbox(e, T, !x), z = this.transformBbox(k, T, !x), j = this.getIds(), $ = s.a2.fromPoints(z);
            for (let U = 0; U < j.length; U++) {
              const Q = this._tiles[j[U]];
              if (Q.holdingForFade()) continue;
              const se = x ? [Q.tileID] : [Q.tileID.unwrapTo(-1), Q.tileID.unwrapTo(0)], le = Math.pow(2, _.zoom - Q.tileID.overscaledZ), ue = a * Q.queryPadding * s.$ / Q.tileSize / le;
              for (const ge of se) {
                const we = $.map(((ye) => ge.getTilePoint(new s.a1(ye.x, ye.y))));
                if (we.expandBy(ue), we.intersects(Vt)) {
                  const ye = R.map(((Ae) => ge.getTilePoint(Ae))), ke = z.map(((Ae) => ge.getTilePoint(Ae)));
                  p.push({ tile: Q, tileID: x ? ge : ge.unwrapTo(0), queryGeometry: ye, cameraQueryGeometry: ke, scale: le });
                }
              }
            }
            return p;
          }
          transformBbox(e, a, c) {
            let p = e.map(a);
            if (c) {
              const _ = s.a2.fromPoints(e);
              _.shrinkBy(1e-3 * Math.min(_.width(), _.height()));
              const x = _.map(a);
              s.a2.fromPoints(p).covers(x) || (p = p.map(((k) => k.x > 0.5 ? new s.a1(k.x - 1, k.y, k.z) : k)));
            }
            return p;
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map(((c) => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (dr(this._source.type)) {
              const e = D.now();
              for (const a in this._tiles) if (this._tiles[a].fadeEndTime >= e) return true;
            }
            return false;
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c);
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c);
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a);
          }
          setDependencies(e, a, c) {
            const p = this._tiles[e];
            p && p.setDependencies(a, c);
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter(((c) => !c.hasDependency(e, a)));
          }
        }
        function qt(y, e) {
          const a = Math.abs(2 * y.wrap) - +(y.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return y.overscaledZ - e.overscaledZ || c - a || e.canonical.y - y.canonical.y || e.canonical.x - y.canonical.x;
        }
        function dr(y) {
          return y === "raster" || y === "image" || y === "video";
        }
        or.maxOverzooming = 10, or.maxUnderzooming = 3;
        class Br {
          constructor(e, a) {
            this.reset(e, a);
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ah(e, 0, 1);
            let a = 1, c = this._distances[a];
            const p = e * this.paddedLength + this.padding;
            for (; c < p && a < this._distances.length; ) c = this._distances[++a];
            const _ = a - 1, x = this._distances[_], k = c - x, T = k > 0 ? (p - x) / k : 0;
            return this.points[_].mult(1 - T).add(this.points[a].mult(T));
          }
        }
        function Vr(y, e) {
          let a = true;
          return y === "always" || y !== "never" && e !== "never" || (a = false), a;
        }
        class Kr {
          constructor(e, a, c) {
            const p = this.boxCells = [], _ = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) p.push([]), _.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, a, c, p, _) {
            this._forEachCell(a, c, p, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p), this.bboxes.push(_);
          }
          insertCircle(e, a, c, p) {
            this._forEachCell(a - p, c - p, a + p, c + p, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(p);
          }
          _insertBoxCell(e, a, c, p, _, x) {
            this.boxCells[_].push(x);
          }
          _insertCircleCell(e, a, c, p, _, x) {
            this.circleCells[_].push(x);
          }
          _query(e, a, c, p, _, x, k) {
            if (c < 0 || e > this.width || p < 0 || a > this.height) return [];
            const T = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= p) {
              if (_) return [{ key: null, x1: e, y1: a, x2: c, y2: p }];
              for (let R = 0; R < this.boxKeys.length; R++) T.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const z = this.circles[3 * R], j = this.circles[3 * R + 1], $ = this.circles[3 * R + 2];
                T.push({ key: this.circleKeys[R], x1: z - $, y1: j - $, x2: z + $, y2: j + $ });
              }
            } else this._forEachCell(e, a, c, p, this._queryCell, T, { hitTest: _, overlapMode: x, seenUids: { box: {}, circle: {} } }, k);
            return T;
          }
          query(e, a, c, p) {
            return this._query(e, a, c, p, false, null);
          }
          hitTest(e, a, c, p, _, x) {
            return this._query(e, a, c, p, true, _, x).length > 0;
          }
          hitTestCircle(e, a, c, p, _) {
            const x = e - c, k = e + c, T = a - c, R = a + c;
            if (k < 0 || x > this.width || R < 0 || T > this.height) return false;
            const z = [];
            return this._forEachCell(x, T, k, R, this._queryCellCircle, z, { hitTest: true, overlapMode: p, circle: { x: e, y: a, radius: c }, seenUids: { box: {}, circle: {} } }, _), z.length > 0;
          }
          _queryCell(e, a, c, p, _, x, k, T) {
            const { seenUids: R, hitTest: z, overlapMode: j } = k, $ = this.boxCells[_];
            if ($ !== null) {
              const Q = this.bboxes;
              for (const se of $) if (!R.box[se]) {
                R.box[se] = true;
                const le = 4 * se, ue = this.boxKeys[se];
                if (e <= Q[le + 2] && a <= Q[le + 3] && c >= Q[le + 0] && p >= Q[le + 1] && (!T || T(ue)) && (!z || !Vr(j, ue.overlapMode)) && (x.push({ key: ue, x1: Q[le], y1: Q[le + 1], x2: Q[le + 2], y2: Q[le + 3] }), z)) return true;
              }
            }
            const U = this.circleCells[_];
            if (U !== null) {
              const Q = this.circles;
              for (const se of U) if (!R.circle[se]) {
                R.circle[se] = true;
                const le = 3 * se, ue = this.circleKeys[se];
                if (this._circleAndRectCollide(Q[le], Q[le + 1], Q[le + 2], e, a, c, p) && (!T || T(ue)) && (!z || !Vr(j, ue.overlapMode))) {
                  const ge = Q[le], we = Q[le + 1], ye = Q[le + 2];
                  if (x.push({ key: ue, x1: ge - ye, y1: we - ye, x2: ge + ye, y2: we + ye }), z) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e, a, c, p, _, x, k, T) {
            const { circle: R, seenUids: z, overlapMode: j } = k, $ = this.boxCells[_];
            if ($ !== null) {
              const Q = this.bboxes;
              for (const se of $) if (!z.box[se]) {
                z.box[se] = true;
                const le = 4 * se, ue = this.boxKeys[se];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, Q[le + 0], Q[le + 1], Q[le + 2], Q[le + 3]) && (!T || T(ue)) && !Vr(j, ue.overlapMode)) return x.push(true), true;
              }
            }
            const U = this.circleCells[_];
            if (U !== null) {
              const Q = this.circles;
              for (const se of U) if (!z.circle[se]) {
                z.circle[se] = true;
                const le = 3 * se, ue = this.circleKeys[se];
                if (this._circlesCollide(Q[le], Q[le + 1], Q[le + 2], R.x, R.y, R.radius) && (!T || T(ue)) && !Vr(j, ue.overlapMode)) return x.push(true), true;
              }
            }
          }
          _forEachCell(e, a, c, p, _, x, k, T) {
            const R = this._convertToXCellCoord(e), z = this._convertToYCellCoord(a), j = this._convertToXCellCoord(c), $ = this._convertToYCellCoord(p);
            for (let U = R; U <= j; U++) for (let Q = z; Q <= $; Q++) if (_.call(this, e, a, c, p, this.xCellCount * Q + U, x, k, T)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, a, c, p, _, x) {
            const k = p - e, T = _ - a, R = c + x;
            return R * R > k * k + T * T;
          }
          _circleAndRectCollide(e, a, c, p, _, x, k) {
            const T = (x - p) / 2, R = Math.abs(e - (p + T));
            if (R > T + c) return false;
            const z = (k - _) / 2, j = Math.abs(a - (_ + z));
            if (j > z + c) return false;
            if (R <= T || j <= z) return true;
            const $ = R - T, U = j - z;
            return $ * $ + U * U <= c * c;
          }
        }
        function ci(y, e, a) {
          const c = s.L();
          if (!y) {
            const { vecSouth: j, vecEast: $ } = Lr(e), U = P();
            U[0] = $[0], U[1] = $[1], U[2] = j[0], U[3] = j[1], p = U, (z = (x = (_ = U)[0]) * (R = _[3]) - (T = _[2]) * (k = _[1])) && (p[0] = R * (z = 1 / z), p[1] = -k * z, p[2] = -T * z, p[3] = x * z), c[0] = U[0], c[1] = U[1], c[4] = U[2], c[5] = U[3];
          }
          var p, _, x, k, T, R, z;
          return s.N(c, c, [1 / a, 1 / a, 1]), c;
        }
        function di(y, e, a, c) {
          if (y) {
            const p = s.L();
            if (!e) {
              const { vecSouth: _, vecEast: x } = Lr(a);
              p[0] = x[0], p[1] = x[1], p[4] = _[0], p[5] = _[1];
            }
            return s.N(p, p, [c, c, 1]), p;
          }
          return a.pixelsToClipSpaceMatrix;
        }
        function Lr(y) {
          const e = Math.cos(y.rollInRadians), a = Math.sin(y.rollInRadians), c = Math.cos(y.pitchInRadians), p = Math.cos(y.bearingInRadians), _ = Math.sin(y.bearingInRadians), x = s.ar();
          x[0] = -p * c * a - _ * e, x[1] = -_ * c * a + p * e;
          const k = s.as(x);
          k < 1e-9 ? s.at(x) : s.au(x, x, 1 / k);
          const T = s.ar();
          T[0] = p * c * e - _ * a, T[1] = _ * c * e + p * a;
          const R = s.as(T);
          return R < 1e-9 ? s.at(T) : s.au(T, T, 1 / R), { vecEast: T, vecSouth: x };
        }
        function Ur(y, e, a, c) {
          let p;
          c ? (p = [y, e, c(y, e), 1], s.aw(p, p, a)) : (p = [y, e, 0, 1], _o(p, p, a));
          const _ = p[3];
          return { point: new s.P(p[0] / _, p[1] / _), signedDistanceFromCamera: _, isOccluded: false };
        }
        function de(y, e) {
          return 0.5 + y / e * 0.5;
        }
        function at(y, e) {
          return y.x >= -e[0] && y.x <= e[0] && y.y >= -e[1] && y.y <= e[1];
        }
        function Zt(y, e, a, c, p, _, x, k, T, R, z, j, $) {
          const U = a ? y.textSizeData : y.iconSizeData, Q = s.an(U, e.transform.zoom), se = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], le = a ? y.text.dynamicLayoutVertexArray : y.icon.dynamicLayoutVertexArray;
          le.clear();
          const ue = y.lineVertexArray, ge = a ? y.text.placedSymbolArray : y.icon.placedSymbolArray, we = e.transform.width / e.transform.height;
          let ye = false;
          for (let ke = 0; ke < ge.length; ke++) {
            const Ae = ge.get(ke);
            if (Ae.hidden || Ae.writingMode === s.ao.vertical && !ye) {
              kn(Ae.numGlyphs, le);
              continue;
            }
            ye = false;
            const be = new s.P(Ae.anchorX, Ae.anchorY), Le = { getElevation: $, pitchedLabelPlaneMatrix: c, lineVertexArray: ue, pitchWithMap: _, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: be, unwrappedTileID: T, width: R, height: z, translation: j }, Ke = rn(Ae.anchorX, Ae.anchorY, Le);
            if (!at(Ke.point, se)) {
              kn(Ae.numGlyphs, le);
              continue;
            }
            const We = de(e.transform.cameraToCenterDistance, Ke.signedDistanceFromCamera), He = s.ap(U, Q, Ae), Je = _ ? He * e.transform.getPitchedTextCorrection(Ae.anchorX, Ae.anchorY, T) / We : He * We, kt = st({ projectionContext: Le, pitchedLabelPlaneMatrixInverse: p, symbol: Ae, fontSize: Je, flip: false, keepUpright: x, glyphOffsetArray: y.glyphOffsetArray, dynamicLayoutVertexArray: le, aspectRatio: we, rotateToLine: k });
            ye = kt.useVertical, (kt.notEnoughRoom || ye || kt.needsFlipping && st({ projectionContext: Le, pitchedLabelPlaneMatrixInverse: p, symbol: Ae, fontSize: Je, flip: true, keepUpright: x, glyphOffsetArray: y.glyphOffsetArray, dynamicLayoutVertexArray: le, aspectRatio: we, rotateToLine: k }).notEnoughRoom) && kn(Ae.numGlyphs, le);
          }
          a ? y.text.dynamicLayoutVertexBuffer.updateData(le) : y.icon.dynamicLayoutVertexBuffer.updateData(le);
        }
        function Rr(y, e, a, c, p, _, x, k) {
          const T = _.glyphStartIndex + _.numGlyphs, R = _.lineStartIndex, z = _.lineStartIndex + _.lineLength, j = e.getoffsetX(_.glyphStartIndex), $ = e.getoffsetX(T - 1), U = qn(y * j, a, c, p, _.segment, R, z, k, x);
          if (!U) return null;
          const Q = qn(y * $, a, c, p, _.segment, R, z, k, x);
          return Q ? k.projectionCache.anyProjectionOccluded ? null : { first: U, last: Q } : null;
        }
        function Cr(y, e, a, c) {
          return y === s.ao.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? { useVertical: true } : (y === s.ao.vertical ? e.y < a.y : e.x > a.x) ? { needsFlipping: true } : null;
        }
        function st(y) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: a, symbol: c, fontSize: p, flip: _, keepUpright: x, glyphOffsetArray: k, dynamicLayoutVertexArray: T, aspectRatio: R, rotateToLine: z } = y, j = p / 24, $ = c.lineOffsetX * j, U = c.lineOffsetY * j;
          let Q;
          if (c.numGlyphs > 1) {
            const se = c.glyphStartIndex + c.numGlyphs, le = c.lineStartIndex, ue = c.lineStartIndex + c.lineLength, ge = Rr(j, k, $, U, _, c, z, e);
            if (!ge) return { notEnoughRoom: true };
            const we = pn(ge.first.point.x, ge.first.point.y, e, a), ye = pn(ge.last.point.x, ge.last.point.y, e, a);
            if (x && !_) {
              const ke = Cr(c.writingMode, we, ye, R);
              if (ke) return ke;
            }
            Q = [ge.first];
            for (let ke = c.glyphStartIndex + 1; ke < se - 1; ke++) {
              const Ae = qn(j * k.getoffsetX(ke), $, U, _, c.segment, le, ue, e, z);
              if (!Ae) return { notEnoughRoom: true };
              Q.push(Ae);
            }
            Q.push(ge.last);
          } else {
            if (x && !_) {
              const le = ei(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, ue = c.lineStartIndex + c.segment + 1, ge = new s.P(e.lineVertexArray.getx(ue), e.lineVertexArray.gety(ue)), we = ei(ge.x, ge.y, e), ye = we.signedDistanceFromCamera > 0 ? we.point : ar(e.tileAnchorPoint, ge, le, 1, e), ke = pn(le.x, le.y, e, a), Ae = pn(ye.x, ye.y, e, a), be = Cr(c.writingMode, ke, Ae, R);
              if (be) return be;
            }
            const se = qn(j * k.getoffsetX(c.glyphStartIndex), $, U, _, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, z);
            if (!se || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            Q = [se];
          }
          for (const se of Q) s.av(T, se.point, se.angle);
          return {};
        }
        function ar(y, e, a, c, p) {
          const _ = y.add(y.sub(e)._unit()), x = ei(_.x, _.y, p).point, k = a.sub(x);
          return a.add(k._mult(c / k.mag()));
        }
        function cr(y, e, a) {
          const c = e.projectionCache;
          if (c.projections[y]) return c.projections[y];
          const p = new s.P(e.lineVertexArray.getx(y), e.lineVertexArray.gety(y)), _ = ei(p.x, p.y, e);
          if (_.signedDistanceFromCamera > 0) return c.projections[y] = _.point, c.anyProjectionOccluded = c.anyProjectionOccluded || _.isOccluded, _.point;
          const x = y - a.direction;
          return ar(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), p, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e);
        }
        function ei(y, e, a) {
          const c = y + a.translation[0], p = e + a.translation[1];
          let _;
          return a.pitchWithMap ? (_ = Ur(c, p, a.pitchedLabelPlaneMatrix, a.getElevation), _.isOccluded = false) : (_ = a.transform.projectTileCoordinates(c, p, a.unwrappedTileID, a.getElevation), _.point.x = (0.5 * _.point.x + 0.5) * a.width, _.point.y = (0.5 * -_.point.y + 0.5) * a.height), _;
        }
        function pn(y, e, a, c) {
          if (a.pitchWithMap) {
            const p = [y, e, 0, 1];
            return s.aw(p, p, c), a.transform.projectTileCoordinates(p[0] / p[3], p[1] / p[3], a.unwrappedTileID, a.getElevation).point;
          }
          return { x: y / a.width * 2 - 1, y: 1 - e / a.height * 2 };
        }
        function rn(y, e, a) {
          return a.transform.projectTileCoordinates(y, e, a.unwrappedTileID, a.getElevation);
        }
        function hr(y, e, a) {
          return y._unit()._perp()._mult(e * a);
        }
        function Jo(y, e, a, c, p, _, x, k, T) {
          if (k.projectionCache.offsets[y]) return k.projectionCache.offsets[y];
          const R = a.add(e);
          if (y + T.direction < c || y + T.direction >= p) return k.projectionCache.offsets[y] = R, R;
          const z = cr(y + T.direction, k, T), j = hr(z.sub(a), x, T.direction), $ = a.add(j), U = z.add(j);
          return k.projectionCache.offsets[y] = s.ax(_, R, $, U) || R, k.projectionCache.offsets[y];
        }
        function qn(y, e, a, c, p, _, x, k, T) {
          const R = c ? y - e : y + e;
          let z = R > 0 ? 1 : -1, j = 0;
          c && (z *= -1, j = Math.PI), z < 0 && (j += Math.PI);
          let $, U = z > 0 ? _ + p : _ + p + 1;
          k.projectionCache.cachedAnchorPoint ? $ = k.projectionCache.cachedAnchorPoint : ($ = ei(k.tileAnchorPoint.x, k.tileAnchorPoint.y, k).point, k.projectionCache.cachedAnchorPoint = $);
          let Q, se, le = $, ue = $, ge = 0, we = 0;
          const ye = Math.abs(R), ke = [];
          let Ae;
          for (; ge + we <= ye; ) {
            if (U += z, U < _ || U >= x) return null;
            ge += we, ue = le, se = Q;
            const Ke = { absOffsetX: ye, direction: z, distanceFromAnchor: ge, previousVertex: ue };
            if (le = cr(U, k, Ke), a === 0) ke.push(ue), Ae = le.sub(ue);
            else {
              let We;
              const He = le.sub(ue);
              We = He.mag() === 0 ? hr(cr(U + z, k, Ke).sub(le), a, z) : hr(He, a, z), se || (se = ue.add(We)), Q = Jo(U, We, le, _, x, se, a, k, Ke), ke.push(se), Ae = Q.sub(se);
            }
            we = Ae.mag();
          }
          const be = Ae._mult((ye - ge) / we)._add(se || ue), Le = j + Math.atan2(le.y - ue.y, le.x - ue.x);
          return ke.push(be), { point: be, angle: T ? Le : 0, path: ke };
        }
        const Qo = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function kn(y, e) {
          for (let a = 0; a < y; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(Qo, 3 * c);
          }
        }
        function _o(y, e, a) {
          const c = e[0], p = e[1];
          return y[0] = a[0] * c + a[4] * p + a[12], y[1] = a[1] * c + a[5] * p + a[13], y[3] = a[3] * c + a[7] * p + a[15], y;
        }
        const Xr = 100;
        class to {
          constructor(e, a = new Kr(e.width + 200, e.height + 200, 25), c = new Kr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Xr, this.screenBottomBoundary = e.height + Xr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, a, c, p, _, x, k, T, R, z, j, $) {
            const U = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], _, z, $), Q = c * U.perspectiveRatio;
            let se;
            if (x || k) se = this._projectCollisionBox(e, Q, p, _, x, k, T, U, z, j, $);
            else {
              const Ae = U.x + (j ? j.x * Q : 0), be = U.y + (j ? j.y * Q : 0);
              se = { allPointsOccluded: false, box: [Ae + e.x1 * Q, be + e.y1 * Q, Ae + e.x2 * Q, be + e.y2 * Q] };
            }
            const [le, ue, ge, we] = se.box, ye = x ? se.allPointsOccluded : U.isOccluded;
            let ke = ye;
            return ke || (ke = U.perspectiveRatio < this.perspectiveRatioCutoff), ke || (ke = !this.isInsideGrid(le, ue, ge, we)), ke || a !== "always" && this.grid.hitTest(le, ue, ge, we, a, R) ? { box: [le, ue, ge, we], placeable: false, offscreen: false, occluded: ye } : { box: [le, ue, ge, we], placeable: true, offscreen: this.isOffscreen(le, ue, ge, we), occluded: ye };
          }
          placeCollisionCircles(e, a, c, p, _, x, k, T, R, z, j, $, U, Q) {
            const se = [], le = new s.P(a.anchorX, a.anchorY), ue = this.getPerspectiveRatio(le.x, le.y, x, Q), ge = (R ? _ * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, x) / ue : _ * ue) / s.aB, we = { getElevation: Q, pitchedLabelPlaneMatrix: k, lineVertexArray: c, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: le, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: U }, ye = Rr(ge, p, a.lineOffsetX * ge, a.lineOffsetY * ge, false, a, false, we);
            let ke = false, Ae = false, be = true;
            if (ye) {
              const Le = 0.5 * j * ue + $, Ke = new s.P(-100, -100), We = new s.P(this.screenRightBoundary, this.screenBottomBoundary), He = new Br(), Je = ye.first, kt = ye.last;
              let St = [];
              for (let yr = Je.path.length - 1; yr >= 1; yr--) St.push(Je.path[yr]);
              for (let yr = 1; yr < kt.path.length; yr++) St.push(kt.path[yr]);
              const pt = 2.5 * Le;
              if (R) {
                const yr = this.projectPathToScreenSpace(St, we);
                St = yr.some(((Or) => Or.signedDistanceFromCamera <= 0)) ? [] : yr.map(((Or) => Or.point));
              }
              let Nt = [];
              if (St.length > 0) {
                const yr = St[0].clone(), Or = St[0].clone();
                for (let oi = 1; oi < St.length; oi++) yr.x = Math.min(yr.x, St[oi].x), yr.y = Math.min(yr.y, St[oi].y), Or.x = Math.max(Or.x, St[oi].x), Or.y = Math.max(Or.y, St[oi].y);
                Nt = yr.x >= Ke.x && Or.x <= We.x && yr.y >= Ke.y && Or.y <= We.y ? [St] : Or.x < Ke.x || yr.x > We.x || Or.y < Ke.y || yr.y > We.y ? [] : s.ay([St], Ke.x, Ke.y, We.x, We.y);
              }
              for (const yr of Nt) {
                He.reset(yr, 0.25 * Le);
                let Or = 0;
                Or = He.length <= 0.5 * Le ? 1 : Math.ceil(He.paddedLength / pt) + 1;
                for (let oi = 0; oi < Or; oi++) {
                  const ti = oi / Math.max(Or - 1, 1), fi = He.lerp(ti), ai = fi.x + Xr, Li = fi.y + Xr;
                  se.push(ai, Li, Le, 0);
                  const si = ai - Le, Yr = Li - Le, mi = ai + Le, xr = Li + Le;
                  if (be = be && this.isOffscreen(si, Yr, mi, xr), Ae = Ae || this.isInsideGrid(si, Yr, mi, xr), e !== "always" && this.grid.hitTestCircle(ai, Li, Le, e, z) && (ke = true, !T)) return { circles: [], offscreen: false, collisionDetected: ke };
                }
              }
            }
            return { circles: !T && ke || !Ae || ue < this.perspectiveRatioCutoff ? [] : se, offscreen: be, collisionDetected: ke };
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(p, _) {
              const x = s.L();
              return s.aq(x, _.pitchedLabelPlaneMatrix), p.map(((k) => {
                const T = Ur(k.x, k.y, x, _.getElevation), R = _.transform.projectTileCoordinates(T.point.x, T.point.y, _.unwrappedTileID, _.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * _.width, R.point.y = (0.5 * -R.point.y + 0.5) * _.height, R;
              }));
            })(e, a);
            return (function(p) {
              let _ = 0, x = 0, k = 0, T = 0;
              for (let R = 0; R < p.length; R++) p[R].isOccluded ? (k = R + 1, T = 0) : (T++, T > x && (x = T, _ = k));
              return p.slice(_, _ + x);
            })(c);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [], c = new s.a2();
            for (const j of e) {
              const $ = new s.P(j.x + Xr, j.y + Xr);
              c.extend($), a.push($);
            }
            const { minX: p, minY: _, maxX: x, maxY: k } = c, T = this.grid.query(p, _, x, k).concat(this.ignoredGrid.query(p, _, x, k)), R = {}, z = {};
            for (const j of T) {
              const $ = j.key;
              if (R[$.bucketInstanceId] === void 0 && (R[$.bucketInstanceId] = {}), R[$.bucketInstanceId][$.featureIndex]) continue;
              const U = [new s.P(j.x1, j.y1), new s.P(j.x2, j.y1), new s.P(j.x2, j.y2), new s.P(j.x1, j.y2)];
              s.az(a, U) && (R[$.bucketInstanceId][$.featureIndex] = true, z[$.bucketInstanceId] === void 0 && (z[$.bucketInstanceId] = []), z[$.bucketInstanceId].push($.featureIndex));
            }
            return z;
          }
          insertCollisionBox(e, a, c, p, _, x) {
            (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: p, featureIndex: _, collisionGroupID: x, overlapMode: a }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, a, c, p, _, x) {
            const k = c ? this.ignoredGrid : this.grid, T = { bucketInstanceId: p, featureIndex: _, collisionGroupID: x, overlapMode: a };
            for (let R = 0; R < e.length; R += 4) k.insertCircle(T, e[R], e[R + 1], e[R + 2]);
          }
          projectAndGetPerspectiveRatio(e, a, c, p, _) {
            if (_) {
              let x;
              p ? (x = [e, a, p(e, a), 1], s.aw(x, x, _)) : (x = [e, a, 0, 1], _o(x, x, _));
              const k = x[3];
              return { x: (x[0] / k + 1) / 2 * this.transform.width + Xr, y: (-x[1] / k + 1) / 2 * this.transform.height + Xr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / k * 0.5, isOccluded: false, signedDistanceFromCamera: k };
            }
            {
              const x = this.transform.projectTileCoordinates(e, a, c, p);
              return { x: (x.point.x + 1) / 2 * this.transform.width + Xr, y: (1 - x.point.y) / 2 * this.transform.height + Xr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, a, c, p) {
            const _ = this.transform.projectTileCoordinates(e, a, c, p);
            return 0.5 + this.transform.cameraToCenterDistance / _.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, a, c, p) {
            return c < Xr || e >= this.screenRightBoundary || p < Xr || a > this.screenBottomBoundary;
          }
          isInsideGrid(e, a, c, p) {
            return c >= 0 && e < this.gridRightBoundary && p >= 0 && a < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = s.ag([]);
            return s.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, a, c, p, _, x, k, T, R, z, j) {
            let $ = 1, U = 0, Q = 0, se = 1;
            const le = e.anchorPointX + k[0], ue = e.anchorPointY + k[1];
            if (x && !_) {
              const St = this.projectAndGetPerspectiveRatio(le + 1, ue, p, R, j), pt = St.x - T.x, Nt = Math.atan((St.y - T.y) / pt) + (pt < 0 ? Math.PI : 0), yr = Math.sin(Nt), Or = Math.cos(Nt);
              $ = Or, U = yr, Q = -yr, se = Or;
            } else if (!x && _) {
              const St = Lr(this.transform);
              $ = St.vecEast[0], U = St.vecEast[1], Q = St.vecSouth[0], se = St.vecSouth[1];
            }
            let ge = T.x, we = T.y, ye = a;
            _ && (ge = le, we = ue, ye = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), ye *= this.transform.getPitchedTextCorrection(le, ue, p), z || (ye *= s.ah(0.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), z && (ge += $ * z.x * ye + Q * z.y * ye, we += U * z.x * ye + se * z.y * ye);
            const ke = e.x1 * ye, Ae = e.x2 * ye, be = (ke + Ae) / 2, Le = e.y1 * ye, Ke = e.y2 * ye, We = (Le + Ke) / 2, He = [{ offsetX: ke, offsetY: Le }, { offsetX: be, offsetY: Le }, { offsetX: Ae, offsetY: Le }, { offsetX: Ae, offsetY: We }, { offsetX: Ae, offsetY: Ke }, { offsetX: be, offsetY: Ke }, { offsetX: ke, offsetY: Ke }, { offsetX: ke, offsetY: We }];
            let Je = [];
            for (const { offsetX: St, offsetY: pt } of He) Je.push(new s.P(ge + $ * St + Q * pt, we + U * St + se * pt));
            let kt = false;
            if (_) {
              const St = Je.map(((pt) => this.projectAndGetPerspectiveRatio(pt.x, pt.y, p, R, j)));
              kt = St.some(((pt) => !pt.isOccluded)), Je = St.map(((pt) => new s.P(pt.x, pt.y)));
            } else kt = true;
            return { box: s.aA(Je), allPointsOccluded: !kt };
          }
        }
        class nn {
          constructor(e, a, c, p) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : p && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class qr {
          constructor(e, a, c, p, _) {
            this.text = new nn(e ? e.text : null, a, c, _), this.icon = new nn(e ? e.icon : null, a, p, _);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Bl {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c;
          }
        }
        class xa {
          constructor(e, a, c, p, _) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = p, this.tileID = _;
          }
        }
        class Es {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: a, predicate: (c) => c.collisionGroupID === a };
            }
            return this.collisionGroups[e];
          }
        }
        function bo(y, e, a, c, p) {
          const { horizontalAlign: _, verticalAlign: x } = s.aH(y);
          return new s.P(-(_ - 0.5) * e + c[0] * p, -(x - 0.5) * a + c[1] * p);
        }
        class xo {
          constructor(e, a, c, p, _) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new to(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new Es(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, p) => a.getElevation(e, c, p) : null;
          }
          getBucketParts(e, a, c, p) {
            const _ = c.getBucket(a), x = c.latestFeatureIndex;
            if (!_ || !x || a.id !== _.layerIds[0]) return;
            const k = c.collisionBoxArray, T = _.layers[0].layout, R = _.layers[0].paint, z = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), j = c.tileSize / s.$, $ = c.tileID.toUnwrapped(), U = T.get("text-rotation-alignment") === "map", Q = s.aC(c, 1, this.transform.zoom), se = s.aD(this.collisionIndex.transform, c, R.get("text-translate"), R.get("text-translate-anchor")), le = s.aD(this.collisionIndex.transform, c, R.get("icon-translate"), R.get("icon-translate-anchor")), ue = ci(U, this.transform, Q);
            this.retainedQueryData[_.bucketInstanceId] = new xa(_.bucketInstanceId, x, _.sourceLayerIndex, _.index, c.tileID);
            const ge = { bucket: _, layout: T, translationText: se, translationIcon: le, unwrappedTileID: $, pitchedLabelPlaneMatrix: ue, scale: z, textPixelRatio: j, holdingForFade: c.holdingForFade(), collisionBoxArray: k, partiallyEvaluatedTextSize: s.an(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
            if (p) for (const we of _.sortKeyRanges) {
              const { sortKey: ye, symbolInstanceStart: ke, symbolInstanceEnd: Ae } = we;
              e.push({ sortKey: ye, symbolInstanceStart: ke, symbolInstanceEnd: Ae, parameters: ge });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: ge });
          }
          attemptAnchorPlacement(e, a, c, p, _, x, k, T, R, z, j, $, U, Q, se, le, ue, ge, we, ye) {
            const ke = s.aE[e.textAnchor], Ae = [e.textOffset0, e.textOffset1], be = bo(ke, c, p, Ae, _), Le = this.collisionIndex.placeCollisionBox(a, $, T, R, z, k, x, le, j.predicate, we, be, ye);
            if ((!ge || this.collisionIndex.placeCollisionBox(ge, $, T, R, z, k, x, ue, j.predicate, we, be, ye).placeable) && Le.placeable) {
              let Ke;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (Ke = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[U.crossTileID] = { textOffset: Ae, width: c, height: p, anchor: ke, textBoxScale: _, prevAnchor: Ke }, this.markUsedJustification(Q, ke, U, se), Q.allowVerticalPlacement && (this.markUsedOrientation(Q, se, U), this.placedOrientations[U.crossTileID] = se), { shift: be, placedGlyphBoxes: Le };
            }
          }
          placeLayerBucketPart(e, a, c) {
            const { bucket: p, layout: _, translationText: x, translationIcon: k, unwrappedTileID: T, pitchedLabelPlaneMatrix: R, textPixelRatio: z, holdingForFade: j, collisionBoxArray: $, partiallyEvaluatedTextSize: U, collisionGroup: Q } = e.parameters, se = _.get("text-optional"), le = _.get("icon-optional"), ue = s.aF(_, "text-overlap", "text-allow-overlap"), ge = ue === "always", we = s.aF(_, "icon-overlap", "icon-allow-overlap"), ye = we === "always", ke = _.get("text-rotation-alignment") === "map", Ae = _.get("text-pitch-alignment") === "map", be = _.get("icon-text-fit") !== "none", Le = _.get("symbol-z-order") === "viewport-y", Ke = ge && (ye || !p.hasIconData() || le), We = ye && (ge || !p.hasTextData() || se);
            !p.collisionArrays && $ && p.deserializeCollisionBoxes($);
            const He = this.retainedQueryData[p.bucketInstanceId].tileID, Je = this._getTerrainElevationFunc(He), kt = this.transform.getFastPathSimpleProjectionMatrix(He), St = (pt, Nt, yr) => {
              var Or, oi;
              if (a[pt.crossTileID]) return;
              if (j) return void (this.placements[pt.crossTileID] = new Bl(false, false, false));
              let ti = false, fi = false, ai = true, Li = null, si = { box: null, placeable: false, offscreen: null, occluded: false }, Yr = { placeable: false }, mi = null, xr = null, Yi = null, Bo = 0, Va = 0, sa = 0;
              Nt.textFeatureIndex ? Bo = Nt.textFeatureIndex : pt.useRuntimeCollisionCircles && (Bo = pt.featureIndex), Nt.verticalTextFeatureIndex && (Va = Nt.verticalTextFeatureIndex);
              const Ua = Nt.textBox;
              if (Ua) {
                const Ln = (Ei) => {
                  let Ri = s.ao.horizontal;
                  if (p.allowVerticalPlacement && !Ei && this.prevPlacement) {
                    const _n = this.prevPlacement.placedOrientations[pt.crossTileID];
                    _n && (this.placedOrientations[pt.crossTileID] = _n, Ri = _n, this.markUsedOrientation(p, Ri, pt));
                  }
                  return Ri;
                }, ua = (Ei, Ri) => {
                  if (p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && Nt.verticalTextBox) {
                    for (const _n of p.writingModes) if (_n === s.ao.vertical ? (si = Ri(), Yr = si) : si = Ei(), si && si.placeable) break;
                  } else si = Ei();
                }, Oo = pt.textAnchorOffsetStartIndex, ca = pt.textAnchorOffsetEndIndex;
                if (ca === Oo) {
                  const Ei = (Ri, _n) => {
                    const li = this.collisionIndex.placeCollisionBox(Ri, ue, z, He, T, Ae, ke, x, Q.predicate, Je, void 0, kt);
                    return li && li.placeable && (this.markUsedOrientation(p, _n, pt), this.placedOrientations[pt.crossTileID] = _n), li;
                  };
                  ua((() => Ei(Ua, s.ao.horizontal)), (() => {
                    const Ri = Nt.verticalTextBox;
                    return p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && Ri ? Ei(Ri, s.ao.vertical) : { box: null, offscreen: null };
                  })), Ln(si && si.placeable);
                } else {
                  let Ei = s.aE[(oi = (Or = this.prevPlacement) === null || Or === void 0 ? void 0 : Or.variableOffsets[pt.crossTileID]) === null || oi === void 0 ? void 0 : oi.anchor];
                  const Ri = (li, Su, Kh) => {
                    const Jh = li.x2 - li.x1, Vp = li.y2 - li.y1, ad = pt.textBoxScale, ul = be && we === "never" ? Su : null;
                    let Bn = null, To = ue === "never" ? 1 : 2, Hn = "never";
                    Ei && To++;
                    for (let $o = 0; $o < To; $o++) {
                      for (let ku = Oo; ku < ca; ku++) {
                        const sd = p.textAnchorOffsets.get(ku);
                        if (Ei && sd.textAnchor !== Ei) continue;
                        const Pu = this.attemptAnchorPlacement(sd, li, Jh, Vp, ad, ke, Ae, z, He, T, Q, Hn, pt, p, Kh, x, k, ul, Je);
                        if (Pu && (Bn = Pu.placedGlyphBoxes, Bn && Bn.placeable)) return ti = true, Li = Pu.shift, Bn;
                      }
                      Ei ? Ei = null : Hn = ue;
                    }
                    return c && !Bn && (Bn = { box: this.collisionIndex.placeCollisionBox(Ua, "always", z, He, T, Ae, ke, x, Q.predicate, Je, void 0, kt).box, offscreen: false, placeable: false, occluded: false }), Bn;
                  };
                  ua((() => Ri(Ua, Nt.iconBox, s.ao.horizontal)), (() => {
                    const li = Nt.verticalTextBox;
                    return p.allowVerticalPlacement && (!si || !si.placeable) && pt.numVerticalGlyphVertices > 0 && li ? Ri(li, Nt.verticalIconBox, s.ao.vertical) : { box: null, occluded: true, offscreen: null };
                  })), si && (ti = si.placeable, ai = si.offscreen);
                  const _n = Ln(si && si.placeable);
                  if (!ti && this.prevPlacement) {
                    const li = this.prevPlacement.variableOffsets[pt.crossTileID];
                    li && (this.variableOffsets[pt.crossTileID] = li, this.markUsedJustification(p, li.anchor, pt, _n));
                  }
                }
              }
              if (mi = si, ti = mi && mi.placeable, ai = mi && mi.offscreen, pt.useRuntimeCollisionCircles && pt.centerJustifiedTextSymbolIndex >= 0) {
                const Ln = p.text.placedSymbolArray.get(pt.centerJustifiedTextSymbolIndex), ua = s.ap(p.textSizeData, U, Ln), Oo = _.get("text-padding");
                xr = this.collisionIndex.placeCollisionCircles(ue, Ln, p.lineVertexArray, p.glyphOffsetArray, ua, T, R, c, Ae, Q.predicate, pt.collisionCircleDiameter, Oo, x, Je), xr.circles.length && xr.collisionDetected && !c && s.w("Collisions detected, but collision boxes are not shown"), ti = ge || xr.circles.length > 0 && !xr.collisionDetected, ai = ai && xr.offscreen;
              }
              if (Nt.iconFeatureIndex && (sa = Nt.iconFeatureIndex), Nt.iconBox) {
                const Ln = (ua) => this.collisionIndex.placeCollisionBox(ua, we, z, He, T, Ae, ke, k, Q.predicate, Je, be && Li ? Li : void 0, kt);
                Yr && Yr.placeable && Nt.verticalIconBox ? (Yi = Ln(Nt.verticalIconBox), fi = Yi.placeable) : (Yi = Ln(Nt.iconBox), fi = Yi.placeable), ai = ai && Yi.offscreen;
              }
              const ll = se || pt.numHorizontalGlyphVertices === 0 && pt.numVerticalGlyphVertices === 0, la = le || pt.numIconVertices === 0;
              ll || la ? la ? ll || (fi = fi && ti) : ti = fi && ti : fi = ti = fi && ti;
              const qa = fi && Yi.placeable;
              if (ti && mi.placeable && this.collisionIndex.insertCollisionBox(mi.box, ue, _.get("text-ignore-placement"), p.bucketInstanceId, Yr && Yr.placeable && Va ? Va : Bo, Q.ID), qa && this.collisionIndex.insertCollisionBox(Yi.box, we, _.get("icon-ignore-placement"), p.bucketInstanceId, sa, Q.ID), xr && ti && this.collisionIndex.insertCollisionCircles(xr.circles, ue, _.get("text-ignore-placement"), p.bucketInstanceId, Bo, Q.ID), c && this.storeCollisionData(p.bucketInstanceId, yr, Nt, mi, Yi, xr), pt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (p.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[pt.crossTileID] = new Bl((ti || Ke) && !(mi == null ? void 0 : mi.occluded), (fi || We) && !(Yi == null ? void 0 : Yi.occluded), ai || p.justReloaded), a[pt.crossTileID] = true;
            };
            if (Le) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const pt = p.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Nt = pt.length - 1; Nt >= 0; --Nt) {
                const yr = pt[Nt];
                St(p.symbolInstances.get(yr), p.collisionArrays[yr], yr);
              }
            } else for (let pt = e.symbolInstanceStart; pt < e.symbolInstanceEnd; pt++) St(p.symbolInstances.get(pt), p.collisionArrays[pt], pt);
            p.justReloaded = false;
          }
          storeCollisionData(e, a, c, p, _, x) {
            if (c.textBox || c.iconBox) {
              let k, T;
              this.collisionBoxArrays.has(e) ? k = this.collisionBoxArrays.get(e) : (k = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, k)), k.has(a) ? T = k.get(a) : (T = { text: null, icon: null }, k.set(a, T)), c.textBox && (T.text = p.box), c.iconBox && (T.icon = _.box);
            }
            if (x) {
              let k = this.collisionCircleArrays[e];
              k === void 0 && (k = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < x.circles.length; T += 4) k.push(x.circles[T + 0] - Xr), k.push(x.circles[T + 1] - Xr), k.push(x.circles[T + 2]), k.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, a, c, p) {
            let _;
            _ = p === s.ao.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[s.aG(a)];
            const x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const k of x) k >= 0 && (e.text.placedSymbolArray.get(k).crossTileID = _ >= 0 && k !== _ ? 0 : c.crossTileID);
          }
          markUsedOrientation(e, a, c) {
            const p = a === s.ao.horizontal || a === s.ao.horizontalOnly ? a : 0, _ = a === s.ao.vertical ? a : 0, x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const k of x) e.text.placedSymbolArray.get(k).placedOrientation = p;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = false;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const p = a ? a.symbolFadeChange(e) : 1, _ = a ? a.opacities : {}, x = a ? a.variableOffsets : {}, k = a ? a.placedOrientations : {};
            for (const T in this.placements) {
              const R = this.placements[T], z = _[T];
              z ? (this.opacities[T] = new qr(z, p, R.text, R.icon), c = c || R.text !== z.text.placed || R.icon !== z.icon.placed) : (this.opacities[T] = new qr(null, p, R.text, R.icon, R.skipFade), c = c || R.text || R.icon);
            }
            for (const T in _) {
              const R = _[T];
              if (!this.opacities[T]) {
                const z = new qr(R, p, false, false);
                z.isHidden() || (this.opacities[T] = z, c = c || R.text.placed || R.icon.placed);
              }
            }
            for (const T in x) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = x[T]);
            for (const T in k) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = k[T]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const p of a) {
              const _ = p.getBucket(e);
              _ && p.latestFeatureIndex && e.id === _.layerIds[0] && this.updateBucketOpacities(_, p.tileID, c, p.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, a, c, p) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const _ = e.layers[0], x = _.layout, k = new qr(null, 0, false, false, true), T = x.get("text-allow-overlap"), R = x.get("icon-allow-overlap"), z = _._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset"), j = x.get("text-rotation-alignment") === "map", $ = x.get("text-pitch-alignment") === "map", U = x.get("icon-text-fit") !== "none", Q = new qr(null, 0, T && (R || !e.hasIconData() || x.get("icon-optional")), R && (T || !e.hasTextData() || x.get("text-optional")), true);
            !e.collisionArrays && p && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(p);
            const se = (ue, ge, we) => {
              for (let ye = 0; ye < ge / 4; ye++) ue.opacityVertexArray.emplaceBack(we);
              ue.hasVisibleVertices = ue.hasVisibleVertices || we !== ta;
            }, le = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ue = 0; ue < e.symbolInstances.length; ue++) {
              const ge = e.symbolInstances.get(ue), { numHorizontalGlyphVertices: we, numVerticalGlyphVertices: ye, crossTileID: ke } = ge;
              let Ae = this.opacities[ke];
              c[ke] ? Ae = k : Ae || (Ae = Q, this.opacities[ke] = Ae), c[ke] = true;
              const be = ge.numIconVertices > 0, Le = this.placedOrientations[ge.crossTileID], Ke = Le === s.ao.vertical, We = Le === s.ao.horizontal || Le === s.ao.horizontalOnly;
              if (we > 0 || ye > 0) {
                const Je = As(Ae.text);
                se(e.text, we, Ke ? ta : Je), se(e.text, ye, We ? ta : Je);
                const kt = Ae.text.isHidden();
                [ge.rightJustifiedTextSymbolIndex, ge.centerJustifiedTextSymbolIndex, ge.leftJustifiedTextSymbolIndex].forEach(((Nt) => {
                  Nt >= 0 && (e.text.placedSymbolArray.get(Nt).hidden = kt || Ke ? 1 : 0);
                })), ge.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ge.verticalPlacedTextSymbolIndex).hidden = kt || We ? 1 : 0);
                const St = this.variableOffsets[ge.crossTileID];
                St && this.markUsedJustification(e, St.anchor, ge, Le);
                const pt = this.placedOrientations[ge.crossTileID];
                pt && (this.markUsedJustification(e, "left", ge, pt), this.markUsedOrientation(e, pt, ge));
              }
              if (be) {
                const Je = As(Ae.icon), kt = !(U && ge.verticalPlacedIconSymbolIndex && Ke);
                ge.placedIconSymbolIndex >= 0 && (se(e.icon, ge.numIconVertices, kt ? Je : ta), e.icon.placedSymbolArray.get(ge.placedIconSymbolIndex).hidden = Ae.icon.isHidden()), ge.verticalPlacedIconSymbolIndex >= 0 && (se(e.icon, ge.numVerticalIconVertices, kt ? ta : Je), e.icon.placedSymbolArray.get(ge.verticalPlacedIconSymbolIndex).hidden = Ae.icon.isHidden());
              }
              const He = le && le.has(ue) ? le.get(ue) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Je = e.collisionArrays[ue];
                if (Je) {
                  let kt = new s.P(0, 0);
                  if (Je.textBox || Je.verticalTextBox) {
                    let St = true;
                    if (z) {
                      const pt = this.variableOffsets[ke];
                      pt ? (kt = bo(pt.anchor, pt.width, pt.height, pt.textOffset, pt.textBoxScale), j && kt._rotate($ ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : St = false;
                    }
                    if (Je.textBox || Je.verticalTextBox) {
                      let pt;
                      Je.textBox && (pt = Ke), Je.verticalTextBox && (pt = We), Rs(e.textCollisionBox.collisionVertexArray, Ae.text.placed, !St || pt, He.text, kt.x, kt.y);
                    }
                  }
                  if (Je.iconBox || Je.verticalIconBox) {
                    const St = !!(!We && Je.verticalIconBox);
                    let pt;
                    Je.iconBox && (pt = St), Je.verticalIconBox && (pt = !St), Rs(e.iconCollisionBox.collisionVertexArray, Ae.icon.placed, pt, He.icon, U ? kt.x : 0, U ? kt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Rs(y, e, a, c, p, _) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const x = c[0] - Xr, k = c[1] - Xr, T = c[2] - Xr, R = c[3] - Xr;
          y.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, x, k), y.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, T, k), y.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, T, R), y.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, _ || 0, x, R);
        }
        const Ol = Math.pow(2, 25), $l = Math.pow(2, 24), ea = Math.pow(2, 17), jl = Math.pow(2, 16), fc = Math.pow(2, 9), pc = Math.pow(2, 8), mc = Math.pow(2, 1);
        function As(y) {
          if (y.opacity === 0 && !y.placed) return 0;
          if (y.opacity === 1 && y.placed) return 4294967295;
          const e = y.placed ? 1 : 0, a = Math.floor(127 * y.opacity);
          return a * Ol + e * $l + a * ea + e * jl + a * fc + e * pc + a * mc + e;
        }
        const ta = 0;
        class Ds {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, a, c, p, _) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (a.getBucketParts(x, p, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, x.sort(((k, T) => k.sortKey - T.sortKey))); this._currentPartIndex < x.length; ) if (a.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _()) return true;
            return false;
          }
        }
        class zs {
          constructor(e, a, c, p, _, x, k, T) {
            this.placement = new xo(e, a, x, k, T), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = p, this._showCollisionBoxes = _, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, a, c) {
            const p = D.now(), _ = () => !this._forceFullPlacement && D.now() - p > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = a[e[this._currentPlacementIndex]], k = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= k) && (!x.maxzoom || x.maxzoom > k)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ds(x)), this._inProgressLayer.continuePlacement(c[x.source], this.placement, this._showCollisionBoxes, x, _)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const ra = 512 / s.$ / 2;
        class Fs {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const p = /* @__PURE__ */ new Map();
            for (let _ = 0; _ < a.length; _++) {
              const x = a.get(_), k = x.key, T = p.get(k);
              T ? T.push(x) : p.set(k, [x]);
            }
            for (const [_, x] of p) {
              const k = { positions: x.map(((T) => ({ x: Math.floor(T.anchorX * ra), y: Math.floor(T.anchorY * ra) }))), crossTileIDs: x.map(((T) => T.crossTileID)) };
              if (k.positions.length > 128) {
                const T = new s.aI(k.positions.length, 16, Uint16Array);
                for (const { x: R, y: z } of k.positions) T.add(R, z);
                T.finish(), delete k.positions, k.index = T;
              }
              this._symbolsByKey[_] = k;
            }
          }
          getScaledCoordinates(e, a) {
            const { x: c, y: p, z: _ } = this.tileID.canonical, { x, y: k, z: T } = a.canonical, R = ra / Math.pow(2, T - _), z = (k * s.$ + e.anchorY) * R, j = p * s.$ * ra;
            return { x: Math.floor((x * s.$ + e.anchorX) * R - c * s.$ * ra), y: Math.floor(z - j) };
          }
          findMatches(e, a, c) {
            const p = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let _ = 0; _ < e.length; _++) {
              const x = e.get(_);
              if (x.crossTileID) continue;
              const k = this._symbolsByKey[x.key];
              if (!k) continue;
              const T = this.getScaledCoordinates(x, a);
              if (k.index) {
                const R = k.index.range(T.x - p, T.y - p, T.x + p, T.y + p).sort();
                for (const z of R) {
                  const j = k.crossTileIDs[z];
                  if (!c[j]) {
                    c[j] = true, x.crossTileID = j;
                    break;
                  }
                }
              } else if (k.positions) for (let R = 0; R < k.positions.length; R++) {
                const z = k.positions[R], j = k.crossTileIDs[R];
                if (Math.abs(z.x - T.x) <= p && Math.abs(z.y - T.y) <= p && !c[j]) {
                  c[j] = true, x.crossTileID = j;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class Ls {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class gc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0) for (const c in this.indexes) {
              const p = this.indexes[c], _ = {};
              for (const x in p) {
                const k = p[x];
                k.tileID = k.tileID.unwrapTo(k.tileID.wrap + a), _[k.tileID.key] = k;
              }
              this.indexes[c] = _;
            }
            this.lng = e;
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) a.symbolInstances.get(_).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const p = this.usedCrossTileIDs[e.overscaledZ];
            for (const _ in this.indexes) {
              const x = this.indexes[_];
              if (Number(_) > e.overscaledZ) for (const k in x) {
                const T = x[k];
                T.tileID.isChildOf(e) && T.findMatches(a.symbolInstances, e, p);
              }
              else {
                const k = x[e.scaledTo(Number(_)).key];
                k && k.findMatches(a.symbolInstances, e, p);
              }
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) {
              const x = a.symbolInstances.get(_);
              x.crossTileID || (x.crossTileID = c.generate(), p[x.crossTileID] = true);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Fs(e, a.symbolInstances, a.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists()) for (const p of c) delete this.usedCrossTileIDs[e][p];
          }
          removeStaleBuckets(e) {
            let a = false;
            for (const c in this.indexes) {
              const p = this.indexes[c];
              for (const _ in p) e[p[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, p[_]), delete p[_], a = true);
            }
            return a;
          }
        }
        class ia {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Ls(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, a, c) {
            let p = this.layerIndexes[e.id];
            p === void 0 && (p = this.layerIndexes[e.id] = new gc());
            let _ = false;
            const x = {};
            p.handleWrapJump(c);
            for (const k of a) {
              const T = k.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), p.addBucket(k.tileID, T, this.crossTileIDs) && (_ = true), x[T.bucketInstanceId] = true);
            }
            return p.removeStaleBuckets(x) && (_ = true), _;
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach(((c) => {
              a[c] = true;
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c];
          }
        }
        var wa = "void main() {fragColor=vec4(1.0);}";
        const An = { prelude: _r(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: _r("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: _r("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: _r(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: _r(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _r(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: _r(wa, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: _r(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: _r(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _r("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _r("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: _r(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: _r("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: _r(wa, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: _r(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: _r(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: _r(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: _r(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: _r(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: _r(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: _r(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _r(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: _r(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: _r(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: _r(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: _r(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: _r(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: _r(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: _r(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: _r(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: _r("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: _r("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: _r("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: _r("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: _r(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: _r("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function _r(y, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = e.match(/in ([\w]+) ([\w]+)/g), p = y.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), _ = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = _ ? _.concat(p) : p, k = {};
          return { fragmentSource: y = y.replace(a, ((T, R, z, j, $) => (k[$] = true, R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
in ${z} ${j} ${$};
#else
uniform ${z} ${j} u_${$};
#endif
` : `
#ifdef HAS_UNIFORM_u_${$}
    ${z} ${j} ${$} = u_${$};
#endif
`))), vertexSource: e = e.replace(a, ((T, R, z, j, $) => {
            const U = j === "float" ? "vec2" : "vec4", Q = $.match(/color/) ? "color" : U;
            return k[$] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${z} ${U} a_${$};
out ${z} ${j} ${$};
#else
uniform ${z} ${j} u_${$};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = a_${$};
#else
    ${z} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = unpack_mix_${Q}(a_${$}, u_${$}_t);
#else
    ${z} ${j} ${$} = u_${$};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${z} ${U} a_${$};
#else
uniform ${z} ${j} u_${$};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${z} ${j} ${$} = a_${$};
#else
    ${z} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${z} ${j} ${$} = unpack_mix_${Q}(a_${$}, u_${$}_t);
#else
    ${z} ${j} ${$} = u_${$};
#endif
`;
          })), staticAttributes: c, staticUniforms: x };
        }
        class Ao {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var wo = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const ro = "#define PROJECTION_MERCATOR", Do = "mercator";
        class br {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return Do;
          }
          get shaderDefine() {
            return ro;
          }
          get shaderPreludeCode() {
            return An.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return An.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return s.aK.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, a, c, p, _) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(s.$, 0), x.emplaceBack(0, s.$), x.emplaceBack(s.$, s.$);
            const k = e.createVertexBuffer(x, wo.members), T = s.aM.simpleSegment(0, 0, 4, 2), R = new s.aN();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const z = e.createIndexBuffer(R);
            return this._cachedMesh = new Ao(k, z, T), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class Ca {
          constructor(e = 0, a = 0, c = 0, p = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(p) || p < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = p;
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = s.C.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = s.C.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = s.C.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = s.C.number(e.right, a.right, c)), this;
          }
          getCenter(e, a) {
            const c = s.ah((this.left + e - this.right) / 2, 0, e), p = s.ah((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(c, p);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new Ca(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Nl(y, e) {
          if (!y.renderWorldCopies || y.lngRange) return;
          const a = e.lng - y.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0;
        }
        function Vl(y) {
          return Math.max(0, Math.floor(y));
        }
        class mn {
          constructor(e, a, c, p, _, x) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = x === void 0 || !!x, this._minZoom = a || 0, this._maxZoom = c || 22, this._minPitch = p ?? 0, this._maxPitch = _ ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Vl(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Ca(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Vl(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Ca(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new s.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const a = s.aO(e, -180, 180) * Math.PI / 180;
            var c, p, _, x, k, T, R, z, j;
            this._bearingInRadians !== a && (this._unmodified = false, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = P(), c = this._rotationMatrix, _ = -this._bearingInRadians, x = (p = this._rotationMatrix)[0], k = p[1], T = p[2], R = p[3], z = Math.sin(_), j = Math.cos(_), c[0] = x * j + T * z, c[1] = k * j + R * z, c[2] = x * -z + T * j, c[3] = k * -z + R * j);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const a = s.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = false, this._pitchInRadians = a, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = false, this._rollInRadians = a, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return s.aP(this._fovInRadians);
          }
          setFov(e) {
            e = s.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = s.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const a = this.getConstrained(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = false, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.af(a), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = a, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, a, c) {
            this._unmodified = false, this._edgeInsets.interpolate(e, a, c), this._constrain(), this._calcMatrices();
          }
          resize(e, a, c = true) {
            this._width = e, this._height = a, c && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new nr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-s.ai, s.ai]);
          }
          getConstrained(e, a) {
            return this._callbacks.getConstrained(e, a);
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const { minX: c, minY: p, maxX: _, maxY: x } = s.a2.fromPoints(a).extend(e);
              return [new s.P(c, p), new s.P(_, p), new s.P(_, x), new s.P(c, x), new s.P(c, p)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e = this._unmodified, { center: a, zoom: c } = this.getConstrained(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.ag(new Float64Array(16));
              s.N(e, e, [this._width / 2, -this._height / 2, 1]), s.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.ag(new Float64Array(16)), s.N(e, e, [1, -1, 1]), s.M(e, e, [-1, -1, 0]), s.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            const _ = c !== void 0 ? c : this.bearing, x = p = p !== void 0 ? p : this.pitch, k = s.a1.fromLngLat(e, a), T = -Math.cos(s.ae(x)), R = Math.sin(s.ae(x)), z = R * Math.sin(s.ae(_)), j = -R * Math.cos(s.ae(_));
            let $ = this.elevation;
            const U = a - $;
            let Q;
            T * U >= 0 || Math.abs(T) < 0.1 ? (Q = 1e4, $ = a + Q * T) : Q = -U / T;
            let se, le, ue = s.aQ(1, k.y), ge = 0;
            do {
              if (ge += 1, ge > 10) break;
              le = Q / ue, se = new s.a1(k.x + z * le, k.y + j * le), ue = 1 / se.meterInMercatorCoordinateUnits();
            } while (Math.abs(Q - le * ue) > 1e-12);
            return { center: se.toLngLat(), elevation: $, zoom: s.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / le / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.aj(1, this.center.lat) * this.worldSize, c = this.cameraToCenterDistance / a, p = s.a1.fromLngLat(this.center, this.elevation), _ = he(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const x = this.calculateCenterFromCameraLngLatAlt(_.toLngLat(), s.aQ(_.z, p.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return he(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.$, 1 / a / s.$];
          }
        }
        class Ni {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aR([], s.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2], c = s.aT(this.min), p = s.aT(this.max);
            for (let _ = 0; _ < a.length; _++) c[_] = a[_] ? this.min[_] : this.center[_], p[_] = a[_] ? this.center[_] : this.max[_];
            return p[2] = this.max[2], new Ni(c, p);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let a = true;
            for (let c = 0; c < e.planes.length; c++) {
              const p = this.intersectsPlane(e.planes[c]);
              if (p === 0) return 0;
              p === 1 && (a = false);
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let a = e[3], c = e[3];
            for (let p = 0; p < 3; p++) e[p] > 0 ? (a += e[p] * this.min[p], c += e[p] * this.max[p]) : (c += e[p] * this.min[p], a += e[p] * this.max[p]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1;
          }
        }
        class gn {
          distanceToTile2d(e, a, c, p) {
            const _ = p.distanceX([e, a]), x = p.distanceY([e, a]);
            return Math.hypot(_, x);
          }
          getWrap(e, a, c) {
            return c;
          }
          getTileBoundingVolume(e, a, c, p) {
            var _, x;
            let k = 0, T = 0;
            if (p == null ? void 0 : p.terrain) {
              const z = new s.Z(e.z, a, e.z, e.x, e.y), j = p.terrain.getMinMaxElevation(z);
              k = (_ = j.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), T = (x = j.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            const R = 1 << e.z;
            return new Ni([a + e.x / R, e.y / R, k], [a + (e.x + 1) / R, (e.y + 1) / R, T]);
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, p = s.ah(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > p;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Mi {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c;
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, p, _) {
            const x = _ ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], k = Math.pow(2, c), T = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((($) => (function(U, Q, se, le) {
              const ue = s.aw([], U, Q), ge = 1 / ue[3] / se * le;
              return s.aY(ue, ue, [ge, ge, 1 / ue[3], ge]);
            })($, e, a, k)));
            p && (function($, U, Q, se) {
              const le = se ? 4 : 0, ue = se ? 0 : 4;
              let ge = 0;
              const we = [], ye = [];
              for (let be = 0; be < 4; be++) {
                const Le = s.aU([], $[be + ue], $[be + le]), Ke = s.aZ(Le);
                s.aR(Le, Le, 1 / Ke), we.push(Ke), ye.push(Le);
              }
              for (let be = 0; be < 4; be++) {
                const Le = s.a_($[be + le], ye[be], Q);
                ge = Le !== null && Le >= 0 ? Math.max(ge, Le) : Math.max(ge, we[be]);
              }
              const ke = (function(be, Le) {
                const Ke = s.aU([], be[Le[0]], be[Le[1]]), We = s.aU([], be[Le[2]], be[Le[1]]), He = [0, 0, 0, 0];
                return s.aV(He, s.aW([], Ke, We)), He[3] = -s.aX(He, be[Le[0]]), He;
              })($, U), Ae = (function(be, Le) {
                const Ke = s.a$(be), We = s.b0([], be, 1 / Ke), He = s.aU([], Le, s.aR([], We, s.aX(Le, We))), Je = s.a$(He);
                if (Je > 0) {
                  const kt = Math.sqrt(1 - We[3] * We[3]), St = s.aR([], We, -We[3]), pt = s.aS([], St, s.aR([], He, kt / Je));
                  return s.b1(Le, pt);
                }
                return null;
              })(Q, ke);
              if (Ae !== null) {
                const be = Ae / s.aX(ye[0], ke);
                ge = Math.min(ge, be);
              }
              for (let be = 0; be < 4; be++) {
                const Le = Math.min(ge, we[be]);
                $[be + ue] = [$[be + le][0] + ye[be][0] * Le, $[be + le][1] + ye[be][1] * Le, $[be + le][2] + ye[be][2] * Le, 1];
              }
            })(T, x[0], p, _);
            const R = x.map((($) => {
              const U = s.aU([], T[$[0]], T[$[1]]), Q = s.aU([], T[$[2]], T[$[1]]), se = s.aV([], s.aW([], U, Q)), le = -s.aX(se, T[$[1]]);
              return se.concat(le);
            })), z = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const $ of T) for (let U = 0; U < 3; U++) z[U] = Math.min(z[U], $[U]), j[U] = Math.max(j[U], $[U]);
            return new Mi(T, R, new Ni(z, j));
          }
        }
        class Jr {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, a) {
          }
          constructor(e, a, c, p, _) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new mn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (x, k) => this.getConstrained(x, k) }, e, a, c, p, _), this._coveringTilesDetailsProvider = new gn();
          }
          clone() {
            const e = new Jr();
            return e.apply(this), e;
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new s.P(0, 0)), p = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)), _ = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)), k = Math.floor(Math.min(c.x, p.x, _.x, x.x)), T = Math.floor(Math.max(c.x, p.x, _.x, x.x)), R = 1;
              for (let z = k - R; z <= T + R; z++) z !== 0 && a.push(new s.b2(z, e));
            }
            return a;
          }
          getCameraFrustum() {
            return Mi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e), c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c);
          }
          setLocationAtPoint(e, a) {
            const c = s.aj(this.elevation, this.center.lat), p = this.screenPointToMercatorCoordinateAtZ(a, c), _ = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c), x = s.a1.fromLngLat(e), k = new s.a1(x.x - (p.x - _.x), x.y - (p.y - _.y));
            this.setCenter(k == null ? void 0 : k.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a1.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a1.fromLngLat(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0, p = [e.x, e.y, 0, 1], _ = [e.x, e.y, 1, 1];
            s.aw(p, p, this._pixelMatrixInverse), s.aw(_, _, this._pixelMatrixInverse);
            const x = p[3], k = _[3], T = p[1] / x, R = _[1] / k, z = p[2] / x, j = _[2] / k, $ = z === j ? 0 : (c - z) / (j - z);
            return new s.a1(s.C.number(p[0] / x, _[0] / k, $) / this.worldSize, s.C.number(T, R, $) / this.worldSize, c);
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const p = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aw(p, p, c), new s.P(p[0] / p[3], p[1] / p[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Pe(this));
            return new nr().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - Pe(this);
          }
          calculatePosMatrix(e, a = false, c) {
            var p;
            const _ = (p = e.key) !== null && p !== void 0 ? p : s.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), x = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(_)) {
              const R = x.get(_);
              return c ? R.f32 : R.f64;
            }
            const k = De(e, this.worldSize);
            s.O(k, a ? this._alignedProjMatrix : this._viewProjMatrix, k);
            const T = { f64: k, f32: new Float32Array(k) };
            return x.set(_, T), c ? T.f32 : T.f64;
          }
          calculateFogMatrix(e) {
            const a = e.key, c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const p = De(e, this.worldSize);
            return s.O(p, this._fogMatrix, p), c.set(a, new Float32Array(p)), c.get(a);
          }
          getConstrained(e, a) {
            a = s.ah(+a, this.minZoom, this.maxZoom);
            const c = { center: new s.S(e.lng, e.lat), zoom: a };
            let p = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && p === null) {
              const we = 179.9999999999;
              p = [-we, we];
            }
            const _ = this.tileSize * s.af(c.zoom);
            let x = 0, k = _, T = 0, R = _, z = 0, j = 0;
            const { x: $, y: U } = this.size;
            if (this._helper._latRange) {
              const we = this._helper._latRange;
              x = s.U(we[1]) * _, k = s.U(we[0]) * _, k - x < U && (z = U / (k - x));
            }
            p && (T = s.aO(s.V(p[0]) * _, 0, _), R = s.aO(s.V(p[1]) * _, 0, _), R < T && (R += _), R - T < $ && (j = $ / (R - T)));
            const { x: Q, y: se } = ne(_, e);
            let le, ue;
            const ge = Math.max(j || 0, z || 0);
            if (ge) {
              const we = new s.P(j ? (R + T) / 2 : Q, z ? (k + x) / 2 : se);
              return c.center = xe(_, we).wrap(), c.zoom += s.ak(ge), c;
            }
            if (this._helper._latRange) {
              const we = U / 2;
              se - we < x && (ue = x + we), se + we > k && (ue = k - we);
            }
            if (p) {
              const we = (T + R) / 2;
              let ye = Q;
              this._helper._renderWorldCopies && (ye = s.aO(Q, we - _ / 2, we + _ / 2));
              const ke = $ / 2;
              ye - ke < T && (le = T + ke), ye + ke > R && (le = R - ke);
            }
            if (le !== void 0 || ue !== void 0) {
              const we = new s.P(le ?? Q, ue ?? se);
              c.center = xe(_, we).wrap();
            }
            return c;
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const p = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), _ = e - p * this._helper._pixelPerMeter / Math.cos(a), x = p < 0 ? _ : e, k = Math.PI / 2 + this.pitchInRadians, T = s.ae(this.fov) * (Math.abs(Math.cos(s.ae(this.roll))) * this.height + Math.abs(Math.sin(s.ae(this.roll))) * this.width) / this.height * (0.5 + c.y / this.height), R = Math.sin(T) * x / Math.sin(s.ah(Math.PI - k - T, 0.01, Math.PI - 0.01)), z = Pe(this), j = Math.atan(z / this._helper.cameraToCenterDistance), $ = s.ae(0.75), U = j > $ ? 2 * j * (0.5 + c.y / (2 * z)) : $, Q = Math.sin(U) * x / Math.sin(s.ah(Math.PI - k - U, 0.01, Math.PI - 0.01)), se = Math.min(R, Q);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * se + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, a = ne(this.worldSize, this.center), c = a.x, p = a.y;
            this._helper._pixelPerMeter = s.aj(1, this.center.lat) * this.worldSize;
            const _ = s.ae(Math.min(this.pitch, H)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(_));
            let k;
            this._calculateNearFarZIfNeeded(x, _, e), k = new Float64Array(16), s.b4(k, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.aq(this._invProjMatrix, k), k[8] = 2 * -e.x / this._helper._width, k[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b5(k), s.N(k, k, [1, -1, 1]), s.M(k, k, [0, 0, -this._helper.cameraToCenterDistance]), s.b6(k, k, -this.rollInRadians), s.b7(k, k, this.pitchInRadians), s.b6(k, k, -this.bearingInRadians), s.M(k, k, [-c, -p, 0]), this._mercatorMatrix = s.N([], k, [this.worldSize, this.worldSize, this.worldSize]), s.N(k, k, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k), s.M(k, k, [0, 0, -this.elevation]), this._viewProjMatrix = k, this._invViewProjMatrix = s.aq([], k);
            const T = [0, 0, -1, 1];
            s.aw(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), s.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.M(this._fogMatrix, this._fogMatrix, [-c, -p, 0]), s.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k);
            const R = this._helper._width % 2 / 2, z = this._helper._height % 2 / 2, j = Math.cos(this.bearingInRadians), $ = Math.sin(-this.bearingInRadians), U = c - Math.round(c) + j * R + $ * z, Q = p - Math.round(p) + j * z + $ * R, se = new Float64Array(k);
            if (s.M(se, se, [U > 0.5 ? U - 1 : U, Q > 0.5 ? Q - 1 : Q, 0]), this._alignedProjMatrix = se, k = s.aq(new Float64Array(16), this._pixelMatrix), !k) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = k, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)), a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aw(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return he(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, a) {
            const c = s.a1.fromLngLat(e), p = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return s.aw(p, p, this._viewProjMatrix), p[2] / p[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: a, aligned: c, applyTerrainMatrix: p } = e, _ = this._helper.getMercatorTileCoordinates(a), x = a ? this.calculatePosMatrix(a, c, true) : null;
            let k;
            return k = a && a.terrainRttPosMatrix32f && p ? a.terrainRttPosMatrix32f : x || s.b8(), { mainMatrix: k, tileMercatorCoords: _, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: k };
          }
          isLocationOccluded(e) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, a, c) {
            return 1;
          }
          transformLightDirection(e) {
            return s.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, a, c, p) {
            const _ = this.calculatePosMatrix(c);
            let x;
            p ? (x = [e, a, p(e, a), 1], s.aw(x, x, _)) : (x = [e, a, 0, 1], _o(x, x, _));
            const k = x[3];
            return { point: new s.P(x[0] / k, x[1] / k), signedDistanceFromCamera: k, isOccluded: false };
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a);
          }
          getMatrixForModel(e, a) {
            const c = s.a1.fromLngLat(e, a), p = c.meterInMercatorCoordinateUnits(), _ = s.b9();
            return s.M(_, _, [c.x, c.y, c.z]), s.b6(_, _, Math.PI), s.b7(_, _, Math.PI / 2), s.N(_, _, [-p, p, p]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = new s.Z(0, 0, 0, 0, 0), c = this.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: e }), p = De(a, this.worldSize);
            s.O(p, this._viewProjMatrix, p), c.tileMercatorCoords = [0, 0, 1, 1];
            const _ = [s.$, s.$, this.worldSize / this._helper.pixelsPerMeter], x = s.ba();
            return s.N(x, p, _), c.fallbackMatrix = x, c.mainMatrix = x, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function lh() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function vn(y) {
          if (y.useSlerp) if (y.k < 1) {
            const e = s.bb(y.startEulerAngles.roll, y.startEulerAngles.pitch, y.startEulerAngles.bearing), a = s.bb(y.endEulerAngles.roll, y.endEulerAngles.pitch, y.endEulerAngles.bearing), c = new Float64Array(4);
            s.bc(c, e, a, y.k);
            const p = s.bd(c);
            y.tr.setRoll(p.roll), y.tr.setPitch(p.pitch), y.tr.setBearing(p.bearing);
          } else y.tr.setRoll(y.endEulerAngles.roll), y.tr.setPitch(y.endEulerAngles.pitch), y.tr.setBearing(y.endEulerAngles.bearing);
          else y.tr.setRoll(s.C.number(y.startEulerAngles.roll, y.endEulerAngles.roll, y.k)), y.tr.setPitch(s.C.number(y.startEulerAngles.pitch, y.endEulerAngles.pitch, y.k)), y.tr.setBearing(s.C.number(y.startEulerAngles.bearing, y.endEulerAngles.bearing, y.k));
        }
        function Dn(y, e, a, c, p) {
          const _ = p.padding, x = ne(p.worldSize, a.getNorthWest()), k = ne(p.worldSize, a.getNorthEast()), T = ne(p.worldSize, a.getSouthEast()), R = ne(p.worldSize, a.getSouthWest()), z = s.ae(-c), j = x.rotate(z), $ = k.rotate(z), U = T.rotate(z), Q = R.rotate(z), se = new s.P(Math.max(j.x, $.x, Q.x, U.x), Math.max(j.y, $.y, Q.y, U.y)), le = new s.P(Math.min(j.x, $.x, Q.x, U.x), Math.min(j.y, $.y, Q.y, U.y)), ue = se.sub(le), ge = (p.width - (_.left + _.right + e.left + e.right)) / ue.x, we = (p.height - (_.top + _.bottom + e.top + e.bottom)) / ue.y;
          if (we < 0 || ge < 0) return void lh();
          const ye = Math.min(s.ak(p.scale * Math.min(ge, we)), y.maxZoom), ke = s.P.convert(y.offset), Ae = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ae(c)), be = ke.add(Ae).mult(p.scale / s.af(ye));
          return { center: xe(p.worldSize, x.add(T).div(2).sub(be)), zoom: ye, bearing: c };
        }
        class on {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e, a) {
            const c = e.mag(), p = Math.abs(Pe(a));
            return { easingOffset: e.mult(Math.min(0.75 * p / c, 1)), easingCenter: a.center };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < 0.01 || a.setLocationAtPoint(c, e.around);
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            return Dn(e, a, c, p, _);
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.S.convert(a.center));
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.padding, _ = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, x = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, k = a.zoom !== void 0, T = !e.isPaddingEqual(a.padding);
            let R = false;
            const z = k ? +a.zoom : e.zoom;
            let j = e.centerPoint.add(a.offsetAsPoint);
            const $ = e.screenPointToLocation(j), { center: U, zoom: Q } = e.getConstrained(s.S.convert(a.center || $), z ?? c);
            Nl(e, U);
            const se = ne(e.worldSize, $), le = ne(e.worldSize, U).sub(se), ue = s.af(Q - c);
            return R = Q !== c, { easeFunc: (ge) => {
              if (R && e.setZoom(s.C.number(c, Q, ge)), s.be(_, x) || vn({ startEulerAngles: _, endEulerAngles: x, tr: e, k: ge, useSlerp: _.roll != x.roll }), T && (e.interpolatePadding(p, a.padding, ge), j = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const we = s.af(e.zoom - c), ye = Q > c ? Math.min(2, ue) : Math.max(0.5, ue), ke = Math.pow(ye, 1 - ge), Ae = xe(e.worldSize, se.add(le.mult(ge * ke)).mult(we));
                e.setLocationAtPoint(e.renderWorldCopies ? Ae.wrap() : Ae, j);
              }
            }, isZooming: R, elevationCenter: U };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.zoom, _ = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), c ? +a.zoom : p), x = _.center, k = _.zoom;
            Nl(e, x);
            const T = ne(e.worldSize, a.locationAtOffset), R = ne(e.worldSize, x).sub(T), z = R.mag(), j = s.af(k - p);
            let $;
            if (a.minZoom !== void 0) {
              const U = Math.min(+a.minZoom, p, k), Q = e.getConstrained(x, U).zoom;
              $ = s.af(Q - p);
            }
            return { easeFunc: (U, Q, se, le) => {
              e.setZoom(U === 1 ? k : p + s.ak(Q));
              const ue = U === 1 ? x : xe(e.worldSize, T.add(R.mult(se)).mult(Q));
              e.setLocationAtPoint(e.renderWorldCopies ? ue.wrap() : ue, le);
            }, scaleOfZoom: j, targetCenter: x, scaleOfMinZoom: $, pixelPathLength: z };
          }
        }
        class ii {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c;
          }
        }
        ii.Replace = [1, 0], ii.disabled = new ii(ii.Replace, s.bf.transparent, [false, false, false, false]), ii.unblended = new ii(ii.Replace, s.bf.transparent, [true, true, true, true]), ii.alphaBlended = new ii([1, 771], s.bf.transparent, [true, true, true, true]);
        const Sa = 2305;
        class sr {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c;
          }
        }
        sr.disabled = new sr(false, 1029, Sa), sr.backCCW = new sr(true, 1029, Sa), sr.frontCCW = new sr(true, 1028, Sa);
        class vr {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c;
          }
        }
        vr.ReadOnly = false, vr.ReadWrite = true, vr.disabled = new vr(519, vr.ReadOnly, [0, 1]);
        const zo = 7680;
        class Er {
          constructor(e, a, c, p, _, x) {
            this.test = e, this.ref = a, this.mask = c, this.fail = p, this.depthFail = _, this.pass = x;
          }
        }
        Er.disabled = new Er({ func: 519, mask: 0 }, 0, 0, zo, zo, zo);
        const zn = /* @__PURE__ */ new WeakMap();
        function Co(y) {
          var e;
          if (zn.has(y)) return zn.get(y);
          {
            const a = (e = y.getParameter(y.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return zn.set(y, a), a;
          }
        }
        class So {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context, c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const p = new s.aL();
            p.emplaceBack(-1, -1), p.emplaceBack(2, -1), p.emplaceBack(-1, 2);
            const _ = new s.aN();
            _.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ao(a.createVertexBuffer(p, wo.members), a.createIndexBuffer(_), s.aM.simpleSegment(0, 0, p.length, _.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const x = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, x), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(x), Co(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context, p = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({ color: s.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, p.TRIANGLES, vr.disabled, Er.disabled, ii.unblended, sr.disabled, /* @__PURE__ */ ((_, x) => ({ u_input: _, u_output_expected: x }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Co(p)) {
              p.bindBuffer(p.PIXEL_PACK_BUFFER, this._pbo), p.readBuffer(p.COLOR_ATTACHMENT0), p.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), p.bindBuffer(p.PIXEL_PACK_BUFFER, null);
              const _ = p.fenceSync(p.SYNC_GPU_COMMANDS_COMPLETE, 0);
              p.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: _ };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Co(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = So._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128;
          }
        }
        const Ul = s.$ / 128;
        function vc(y, e) {
          const a = y.granularity !== void 0 ? Math.max(y.granularity, 1) : 1, c = a + (y.generateBorders ? 2 : 0), p = a + (y.extendToNorthPole || y.generateBorders ? 1 : 0) + (y.extendToSouthPole || y.generateBorders ? 1 : 0), _ = c + 1, x = p + 1, k = y.generateBorders ? -1 : 0, T = y.generateBorders || y.extendToNorthPole ? -1 : 0, R = a + (y.generateBorders ? 1 : 0), z = a + (y.generateBorders || y.extendToSouthPole ? 1 : 0), j = _ * x, $ = c * p * 6, U = _ * x > 65536;
          if (U && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Q = U || e === "32bit", se = new Int16Array(2 * j);
          let le = 0;
          for (let we = T; we <= z; we++) for (let ye = k; ye <= R; ye++) {
            let ke = ye / a * s.$;
            ye === -1 && (ke = -Ul), ye === a + 1 && (ke = s.$ + Ul);
            let Ae = we / a * s.$;
            we === -1 && (Ae = y.extendToNorthPole ? s.bh : -Ul), we === a + 1 && (Ae = y.extendToSouthPole ? s.bi : s.$ + Ul), se[le++] = ke, se[le++] = Ae;
          }
          const ue = Q ? new Uint32Array($) : new Uint16Array($);
          let ge = 0;
          for (let we = 0; we < p; we++) for (let ye = 0; ye < c; ye++) {
            const ke = ye + 1 + we * _, Ae = ye + (we + 1) * _, be = ye + 1 + (we + 1) * _;
            ue[ge++] = ye + we * _, ue[ge++] = Ae, ue[ge++] = ke, ue[ge++] = ke, ue[ge++] = Ae, ue[ge++] = be;
          }
          return { vertices: se.buffer.slice(0), indices: ue.buffer.slice(0), uses32bitIndices: Q };
        }
        const is = new s.aK({ fill: new s.bj(128, 2), line: new s.bj(512, 0), tile: new s.bj(128, 32), stencil: new s.bj(128, 1), circle: 3 });
        class Bs {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return An.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return An.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return is;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new So(e));
            const a = s.U(this._errorQueryLatitudeDegrees), c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - 0.5 * Math.PI, p = this._errorMeasurement.updateErrorLoop(a, c), _ = D.now();
            p !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = p, this._errorMeasurementLastChangeTime = _);
            const x = Math.min(Math.max((_ - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = s.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bl(x));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, a, c, p, _) {
            const x = (_ === "stencil" ? is.stencil : is.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, { granularity: x, generateBorders: c, extendToNorthPole: a.y === 0 && p, extendToSouthPole: a.y === (1 << a.z) - 1 && p });
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const p = (function(_, x) {
              const k = vc(x, "16bit"), T = s.aL.deserialize({ arrayBuffer: k.vertices, length: k.vertices.byteLength / 2 / 2 }), R = s.aN.deserialize({ arrayBuffer: k.indices, length: k.indices.byteLength / 2 / 3 });
              return new Ao(_.createVertexBuffer(T, wo.members), _.createIndexBuffer(R), s.aM.simpleSegment(0, 0, T.length, R.length));
            })(e, a);
            return this._tileMeshCache[c] = p, p;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = D.now();
            let a = false;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const ql = new s.r({ type: new s.D(s.v.projection.type) });
        class Gl extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(ql, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0)), this._mercatorProjection = new br(), this._verticalPerspectiveProjection = new Bs();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, a, c, p, _) {
            return this.currentProjection.getMeshFromTileID(e, a, c, p, _);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function Wl(y) {
          const e = ns(y.worldSize, y.center.lat);
          return 2 * Math.PI * e;
        }
        function io(y, e, a, c, p) {
          const _ = 1 / (1 << p), x = e / s.$ * _ + c * _, k = s.bo((y / s.$ * _ + a * _) * Math.PI * 2 + Math.PI, 2 * Math.PI), T = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(T), z = new Float64Array(3);
          return z[0] = Math.sin(k) * R, z[1] = Math.sin(T), z[2] = Math.cos(k) * R, z;
        }
        function Vi(y) {
          return (function(e, a) {
            const c = Math.cos(a), p = new Float64Array(3);
            return p[0] = Math.sin(e) * c, p[1] = Math.sin(a), p[2] = Math.cos(e) * c, p;
          })(y.lng * Math.PI / 180, y.lat * Math.PI / 180);
        }
        function ns(y, e) {
          return y / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Os(y) {
          const e = Math.asin(y[1]) / Math.PI * 180, a = Math.sqrt(y[0] * y[0] + y[2] * y[2]);
          if (a > 1e-6) {
            const c = y[0] / a, p = Math.acos(y[2] / a), _ = (c > 0 ? p : -p) / Math.PI * 180;
            return new s.S(s.aO(_, -180, 180), e);
          }
          return new s.S(0, e);
        }
        function ka(y) {
          return Math.cos(y * Math.PI / 180);
        }
        function Si(y, e) {
          const a = ka(y), c = ka(e);
          return s.ak(c / a);
        }
        function uh(y, e) {
          const a = y.rotate(e.bearingInRadians), c = e.zoom + Si(e.center.lat, 0), p = s.bk(1 / ka(e.center.lat), 1 / ka(Math.min(Math.abs(e.center.lat), 60)), s.bn(c, 7, 3, 0, 1)), _ = 360 / Wl({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new s.S(e.center.lng - a.x * _ * p, s.ah(e.center.lat + a.y * _, -s.ai, s.ai));
        }
        function $s(y) {
          const e = 0.5 * y, a = Math.sin(e), c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a);
        }
        function yc(y, e, a, c) {
          const p = y.lat + a * c;
          if (Math.abs(a) > 1) {
            const _ = (Math.sign(y.lat + a) !== Math.sign(y.lat) ? -Math.abs(y.lat) : Math.abs(y.lat)) * Math.PI / 180, x = Math.abs(y.lat + a) * Math.PI / 180, k = $s(_ + c * (x - _)), T = $s(_), R = $s(x);
            return new s.S(y.lng + e * ((k - T) / (R - T)), p);
          }
          return new s.S(y.lng + e * c, p);
        }
        class bp {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e, a, c, p) {
            const _ = `${e.z}_${e.x}_${e.y}_${(p == null ? void 0 : p.terrain) ? "t" : ""}`, x = this._cache.get(_);
            if (x) return x;
            const k = this._cachePrevious.get(_);
            if (k) return this._cache.set(_, k), k;
            const T = this._boundingVolumeFactory(e, a, c, p);
            return this._cache.set(_, T), this._hadAnyChanges = true, T;
          }
        }
        class os {
          constructor(e, a, c, p) {
            this.min = c, this.max = p, this.points = e, this.planes = a;
          }
          static fromAabb(e, a) {
            const c = [];
            for (let p = 0; p < 8; p++) c.push([1 & ~p ? e[0] : a[0], (p >> 1 & 1) == 1 ? a[1] : e[1], (p >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new os(c, [[-1, 0, 0, a[0]], [1, 0, 0, -e[0]], [0, -1, 0, a[1]], [0, 1, 0, -e[1]], [0, 0, -1, a[2]], [0, 0, 1, -e[2]]], e, a);
          }
          static fromCenterSizeAngles(e, a, c) {
            const p = s.br([], c[0], c[1], c[2]), _ = s.bs([], [a[0], 0, 0], p), x = s.bs([], [0, a[1], 0], p), k = s.bs([], [0, 0, a[2]], p), T = [...e], R = [...e];
            for (let j = 0; j < 8; j++) for (let $ = 0; $ < 3; $++) {
              const U = e[$] + _[$] * (1 & ~j ? -1 : 1) + x[$] * ((j >> 1 & 1) == 1 ? 1 : -1) + k[$] * ((j >> 2 & 1) == 1 ? 1 : -1);
              T[$] = Math.min(T[$], U), R[$] = Math.max(R[$], U);
            }
            const z = [];
            for (let j = 0; j < 8; j++) {
              const $ = [...e];
              s.aS($, $, s.aR([], _, 1 & ~j ? -1 : 1)), s.aS($, $, s.aR([], x, (j >> 1 & 1) == 1 ? 1 : -1)), s.aS($, $, s.aR([], k, (j >> 2 & 1) == 1 ? 1 : -1)), z.push($);
            }
            return new os(z, [[..._, -s.aX(_, z[0])], [...x, -s.aX(x, z[0])], [...k, -s.aX(k, z[0])], [-_[0], -_[1], -_[2], -s.aX(_, z[7])], [-x[0], -x[1], -x[2], -s.aX(x, z[7])], [-k[0], -k[1], -k[2], -s.aX(k, z[7])]], T, R);
          }
          intersectsFrustum(e) {
            let a = true;
            const c = this.points.length, p = this.planes.length, _ = e.planes.length, x = e.points.length;
            for (let k = 0; k < _; k++) {
              const T = e.planes[k];
              let R = 0;
              for (let z = 0; z < c; z++) {
                const j = this.points[z];
                T[0] * j[0] + T[1] * j[1] + T[2] * j[2] + T[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < c && (a = false);
            }
            if (a) return 2;
            for (let k = 0; k < p; k++) {
              const T = this.planes[k];
              let R = 0;
              for (let z = 0; z < x; z++) {
                const j = e.points[z];
                T[0] * j[0] + T[1] * j[1] + T[2] * j[2] + T[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let p = 0; p < a; p++) {
              const _ = this.points[p];
              e[0] * _[0] + e[1] * _[1] + e[2] * _[2] + e[3] >= 0 && c++;
            }
            return c === a ? 2 : c === 0 ? 0 : 1;
          }
        }
        function Xi(y, e, a) {
          const c = y - e;
          return c < 0 ? -c : Math.max(0, c - a);
        }
        function js(y, e, a, c, p) {
          const _ = y - a;
          let x;
          return x = _ < 0 ? Math.min(-_, 1 + _ - p) : _ > 1 ? Math.min(Math.max(_ - p, 0), 1 - _) : 0, Math.max(x, Xi(e, c, p));
        }
        class ko {
          constructor() {
            this._boundingVolumeCache = new bp(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, a, c, p) {
            const _ = 1 << c.z, x = 1 / _, k = c.x / _, T = c.y / _;
            let R = 2;
            return R = Math.min(R, js(e, a, k, T, x)), R = Math.min(R, js(e, a, k + 0.5, -T - x, x)), R = Math.min(R, js(e, a, k + 0.5, 2 - T - x, x)), R;
          }
          getWrap(e, a, c) {
            const p = 1 << a.z, _ = 1 / p, x = a.x / p, k = Xi(e.x, x, _), T = Xi(e.x, x - 1, _), R = Xi(e.x, x + 1, _), z = Math.min(k, T, R);
            return z === R ? 1 : z === T ? -1 : 0;
          }
          allowVariableZoom(e, a) {
            return xt(e, a) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e, a, c, p) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, p);
          }
          _computeTileBoundingVolume(e, a, c, p) {
            var _, x;
            let k = 0, T = 0;
            if (p == null ? void 0 : p.terrain) {
              const R = new s.Z(e.z, a, e.z, e.x, e.y), z = p.terrain.getMinMaxElevation(R);
              k = (_ = z.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), T = (x = z.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            if (k /= s.bu, T /= s.bu, k += 1, T += 1, e.z <= 0) return os.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return os.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const R = [io(0, 0, e.x, e.y, e.z), io(s.$, 0, e.x, e.y, e.z), io(s.$, s.$, e.x, e.y, e.z), io(0, s.$, e.x, e.y, e.z)], z = [];
              for (const He of R) z.push(s.aR([], He, T));
              if (T !== k) for (const He of R) z.push(s.aR([], He, k));
              e.y === 0 && z.push([0, 1, 0]), e.y === (1 << e.z) - 1 && z.push([0, -1, 0]);
              const j = [1, 1, 1], $ = [-1, -1, -1];
              for (const He of z) for (let Je = 0; Je < 3; Je++) j[Je] = Math.min(j[Je], He[Je]), $[Je] = Math.max($[Je], He[Je]);
              const U = io(s.$ / 2, s.$ / 2, e.x, e.y, e.z), Q = s.aW([], [0, 1, 0], U);
              s.aV(Q, Q);
              const se = s.aW([], U, Q);
              s.aV(se, se);
              const le = s.aW([], R[2], R[1]);
              s.aV(le, le);
              const ue = s.aW([], R[0], R[3]);
              s.aV(ue, ue), z.push(s.aR([], U, T)), e.y >= (1 << e.z) / 2 && z.push(s.aR([], io(s.$ / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && z.push(s.aR([], io(s.$ / 2, s.$, e.x, e.y, e.z), T));
              const ge = Ns(U, z), we = Ns(se, z), ye = [-U[0], -U[1], -U[2], ge.max], ke = [U[0], U[1], U[2], -ge.min], Ae = [-se[0], -se[1], -se[2], we.max], be = [se[0], se[1], se[2], -we.min], Le = [...le, 0], Ke = [...ue, 0], We = [];
              return e.y === 0 ? We.push(s.bt(Ke, Le, ye), s.bt(Ke, Le, ke)) : We.push(s.bt(Ae, Le, ye), s.bt(Ae, Le, ke), s.bt(Ae, Ke, ye), s.bt(Ae, Ke, ke)), e.y === (1 << e.z) - 1 ? We.push(s.bt(Ke, Le, ye), s.bt(Ke, Le, ke)) : We.push(s.bt(be, Le, ye), s.bt(be, Le, ke), s.bt(be, Ke, ye), s.bt(be, Ke, ke)), new os(We, [ye, ke, Ae, be, Le, Ke], j, $);
            }
          }
        }
        function Ns(y, e) {
          let a = 1 / 0, c = -1 / 0;
          for (const p of e) {
            const _ = s.aX(y, p);
            a = Math.min(a, _), c = Math.max(c, _);
          }
          return { min: a, max: c };
        }
        class Vs {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a) {
            this._helper.resize(e, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = s.bv(), this._projectionMatrix = s.b9(), this._globeViewProjMatrix32f = s.b8(), this._globeViewProjMatrixNoCorrection = s.b9(), this._globeViewProjMatrixNoCorrectionInverted = s.b9(), this._globeProjMatrixInverted = s.b9(), this._cameraPosition = s.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new mn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._coveringTilesDetailsProvider = new ko();
          }
          clone() {
            const e = new Vs();
            return e.apply(this), e;
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = s.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: a, applyGlobeMatrix: c } = e, p = this._helper.getMercatorTileCoordinates(a);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: p, clippingPlane: this._cachedClippingPlane, projectionTransition: c ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians, c = this.cameraToCenterDistance / e, p = Math.sin(a) * c, _ = Math.cos(a) * c + 1, x = 1 / Math.sqrt(p * p + _ * _) * 1;
            let k = -p, T = _;
            const R = Math.sqrt(k * k + T * T);
            k /= R, T /= R;
            const z = [0, k, T];
            s.bw(z, z, [0, 0, 0], -this.bearingInRadians), s.bx(z, z, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.by(z, z, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / s.aZ(z);
            return s.aR(z, z, j), [...z, -x * j];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Vi(e));
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180, c = this._helper._center.lat * Math.PI / 180, p = Math.cos(c), _ = [Math.sin(a) * p, Math.sin(c), Math.cos(a) * p], x = [_[2], 0, -_[0]], k = [0, 0, 0];
            s.aW(k, x, _), s.aV(x, x), s.aV(k, k);
            const T = [0, 0, 0];
            return s.aV(T, [x[0] * e[0] + k[0] * e[1] + _[0] * e[2], x[1] * e[0] + k[1] * e[1] + _[1] * e[2], x[2] * e[0] + k[2] * e[1] + _[2] * e[2]]), T;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = (function(k, T, R) {
              const z = 1 / (1 << R.z);
              return new s.a1(k / s.$ * z + R.x * z, T / s.$ * z + R.y * z);
            })(e, a, c.canonical), _ = (x = p.y, [s.bo(p.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(_[1]);
          }
          projectTileCoordinates(e, a, c, p) {
            const _ = c.canonical, x = io(e, a, _.x, _.y, _.z), k = 1 + (p ? p(e, a) : 0) / s.bu, T = [x[0] * k, x[1] * k, x[2] * k, 1];
            s.aw(T, T, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, z = R[0] * x[0] + R[1] * x[1] + R[2] * x[2] + R[3] < 0;
            return { point: new s.P(T[0] / T[3], T[1] / T[3]), signedDistanceFromCamera: T[3], isOccluded: z };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = ns(this.worldSize, this.center.lat), a = s.ba(), c = s.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b4(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const p = this.centerOffset;
            a[8] = 2 * -p.x / this._helper._width, a[9] = 2 * p.y / this._helper._height, this._projectionMatrix = s.b5(a), this._globeProjMatrixInverted = s.ba(), s.aq(this._globeProjMatrixInverted, a), s.M(a, a, [0, 0, -this.cameraToCenterDistance]), s.b6(a, a, this.rollInRadians), s.b7(a, a, -this.pitchInRadians), s.b6(a, a, this.bearingInRadians), s.M(a, a, [0, 0, -e]);
            const _ = s.bp();
            _[0] = e, _[1] = e, _[2] = e, s.b7(c, a, this.center.lat * Math.PI / 180), s.bz(c, c, -this.center.lng * Math.PI / 180), s.N(c, c, _), this._globeViewProjMatrixNoCorrection = c, s.b7(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bz(a, a, -this.center.lng * Math.PI / 180), s.N(a, a, _), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.ba(), s.aq(this._globeViewProjMatrixNoCorrectionInverted, c);
            const x = s.bp();
            this._cameraPosition = s.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bw(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), s.bx(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), s.bw(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), s.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bx(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), s.by(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const k = s.b5(this._globeViewProjMatrixNoCorrectionInverted);
            s.N(k, k, [1, 1, -1]), this._cachedFrustum = Mi.fromInvProjectionMatrix(k, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.ba();
            return s.ag(a), a;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = Vi(e);
            s.aR(c, c, 1 + a / s.bu);
            const p = s.bv();
            return s.aw(p, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), p[2] / p[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, a = 0.5 * this.height, c = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)], p = [];
            for (const j of c) p.push(this.unprojectScreenPoint(j));
            let _ = 0, x = 0, k = 0, T = 0;
            const R = this.center;
            for (const j of p) {
              const $ = s.bA(R.lng, j.lng), U = s.bA(R.lat, j.lat);
              $ < x && (x = $), $ > _ && (_ = $), U < T && (T = U), U > k && (k = U);
            }
            const z = [R.lng + x, R.lat + T, R.lng + _, R.lat + k];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (z[3] = 90, z[0] = -180, z[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (z[1] = -90, z[0] = -180, z[2] = 180), new nr(z);
          }
          getConstrained(e, a) {
            const c = s.ah(e.lat, -s.ai, s.ai), p = s.ah(+a, this.minZoom + Si(0, c), this.maxZoom);
            return { center: new s.S(e.lng, c), zoom: p };
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            const c = Vi(this.unprojectScreenPoint(a)), p = Vi(e), _ = s.bp();
            s.bB(_);
            const x = s.bp();
            s.by(x, c, _, -this.center.lng * Math.PI / 180), s.bx(x, x, _, this.center.lat * Math.PI / 180);
            const k = p[0] * p[0] + p[2] * p[2], T = x[0] * x[0];
            if (k < T) return;
            const R = Math.sqrt(k - T), z = -R, j = s.bC(p[0], p[2], x[0], R), $ = s.bC(p[0], p[2], x[0], z), U = s.bp();
            s.by(U, p, _, -j);
            const Q = s.bC(U[1], U[2], x[1], x[2]), se = s.bp();
            s.by(se, p, _, -$);
            const le = s.bC(se[1], se[2], x[1], x[2]), ue = 0.5 * Math.PI, ge = Q >= -ue && Q <= ue, we = le >= -ue && le <= ue;
            let ye, ke;
            if (ge && we) {
              const Ke = this.center.lng * Math.PI / 180, We = this.center.lat * Math.PI / 180;
              s.bD(j, Ke) + s.bD(Q, We) < s.bD($, Ke) + s.bD(le, We) ? (ye = j, ke = Q) : (ye = $, ke = le);
            } else if (ge) ye = j, ke = Q;
            else {
              if (!we) return;
              ye = $, ke = le;
            }
            const Ae = ye / Math.PI * 180, be = ke / Math.PI * 180, Le = this.center.lat;
            this.setCenter(new s.S(Ae, s.ah(be, -90, 90))), this.setZoom(this.zoom + Si(Le, this.center.lat));
          }
          locationToScreenPoint(e, a) {
            const c = Vi(e);
            if (a) {
              const p = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aR(c, c, 1 + p / s.bu);
            }
            return this._projectSurfacePointToScreen(c);
          }
          _projectSurfacePointToScreen(e) {
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((0.5 * a[0] + 0.5) * this.width, (0.5 * -a[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c;
            }
            return s.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition, p = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, p);
          }
          getRayDirectionFromPixel(e) {
            const a = s.bv();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aw(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = s.bp();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const p = s.bp();
            return s.aV(p, c), p;
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return false;
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1;
          }
          rayPlanetIntersection(e, a) {
            const c = s.aX(e, a), p = s.bp(), _ = s.bp();
            s.aR(_, a, c), s.aU(p, e, _);
            const x = 1 - s.aX(p, p);
            if (x < 0) return null;
            const k = s.aX(e, e) - 1, T = -c + (c < 0 ? 1 : -1) * Math.sqrt(x), R = k / T, z = T;
            return { tMin: Math.min(R, z), tMax: Math.max(R, z) };
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition, c = this.getRayDirectionFromPixel(e), p = this.rayPlanetIntersection(a, c);
            if (p) {
              const z = s.bp();
              s.aS(z, a, [c[0] * p.tMin, c[1] * p.tMin, c[2] * p.tMin]);
              const j = s.bp();
              return s.aV(j, z), Os(j);
            }
            const _ = this._cachedClippingPlane, x = _[0] * c[0] + _[1] * c[1] + _[2] * c[2], k = -s.b1(_, a) / x, T = s.bp();
            if (k > 0) s.aS(T, a, [c[0] * k, c[1] * k, c[2] * k]);
            else {
              const z = s.bp();
              s.aS(z, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const j = s.b1(this._cachedClippingPlane, z);
              s.aU(T, z, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j]);
            }
            const R = (function(z) {
              const j = s.bp();
              return j[0] = z[0] * -z[3], j[1] = z[1] * -z[3], j[2] = z[2] * -z[3], { center: j, radius: Math.sqrt(1 - z[3] * z[3]) };
            })(_);
            return Os((function(z, j, $) {
              const U = s.bp();
              s.aU(U, $, z);
              const Q = s.bp();
              return s.bq(Q, z, U, j / s.a$(U)), Q;
            })(R.center, R.radius, T));
          }
          getMatrixForModel(e, a) {
            const c = s.S.convert(e), p = 1 / s.bu, _ = s.b9();
            return s.bz(_, _, c.lng / 180 * Math.PI), s.b7(_, _, -c.lat / 180 * Math.PI), s.M(_, _, [0, 0, 1 + a / s.bu]), s.b7(_, _, 0.5 * Math.PI), s.N(_, _, [p, p, p]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this.getProjectionData({ overscaledTileID: new s.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return a.tileMercatorCoords = [0, 0, 1, 1], a;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class Us {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new mn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._globeness = 1, this._mercatorTransform = new Jr(), this._verticalPerspectiveTransform = new Vs();
          }
          clone() {
            const e = new Us();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e), c = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix, clippingPlane: c.clippingPlane, tileMercatorCoords: c.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: a.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return s.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return s.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = this._mercatorTransform.getPitchedTextCorrection(e, a, c), _ = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return s.bk(p, _, this._globeness);
          }
          projectTileCoordinates(e, a, c, p) {
            return this.currentTransform.projectTileCoordinates(e, a, c, p);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, a) {
            return this.currentTransform.getConstrained(e, a);
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a);
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a);
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a);
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a);
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class an {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e, a) {
            const c = uh(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), { easingCenter: c, easingOffset: new s.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around, p = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const _ = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const x = a.zoom - _;
            if (x === 0) return;
            const k = s.bA(a.center.lng, p.lng), T = k / (Math.abs(k / 180) + 1), R = s.bA(a.center.lat, p.lat), z = a.getRayDirectionFromPixel(c), j = a.cameraPosition, $ = -1 * s.aX(j, z), U = s.bp();
            s.aS(U, j, [z[0] * $, z[1] * $, z[2] * $]);
            const Q = s.aZ(U) - 1, se = Math.exp(0.5 * -Math.max(Q - 0.3, 0)), le = ns(a.worldSize, a.center.lat) / Math.min(a.width, a.height), ue = s.bn(le, 0.9, 0.5, 1, 0.25), ge = (1 - s.af(-x)) * Math.min(se, ue), we = a.center.lat, ye = a.zoom, ke = new s.S(a.center.lng + T * ge, s.ah(a.center.lat + R * ge, -s.ai, s.ai));
            a.setLocationAtPoint(p, c);
            const Ae = a.center, be = s.bn(Math.abs(k), 45, 85, 0, 1), Le = s.bn(le, 0.75, 0.35, 0, 1), Ke = Math.pow(Math.max(be, Le), 0.25), We = s.bA(Ae.lng, ke.lng), He = s.bA(Ae.lat, ke.lat);
            a.setCenter(new s.S(Ae.lng + We * Ke, Ae.lat + He * Ke).wrap()), a.setZoom(ye + Si(we, a.center.lat));
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const p = a.center.lat, _ = a.zoom;
            a.setCenter(uh(e.panDelta, a).wrap()), a.setZoom(_ + Si(p, a.center.lat));
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            const x = Dn(e, a, c, p, _), k = a.left / _.width * 2 - 1, T = (_.width - a.right) / _.width * 2 - 1, R = a.top / _.height * -2 + 1, z = (_.height - a.bottom) / _.height * -2 + 1, j = s.bA(c.getWest(), c.getEast()) < 0, $ = j ? c.getEast() : c.getWest(), U = j ? c.getWest() : c.getEast(), Q = Math.max(c.getNorth(), c.getSouth()), se = Math.min(c.getNorth(), c.getSouth()), le = $ + 0.5 * s.bA($, U), ue = Q + 0.5 * s.bA(Q, se), ge = _.clone();
            ge.setCenter(x.center), ge.setBearing(x.bearing), ge.setPitch(0), ge.setRoll(0), ge.setZoom(x.zoom);
            const we = ge.modelViewProjectionMatrix, ye = [Vi(c.getNorthWest()), Vi(c.getNorthEast()), Vi(c.getSouthWest()), Vi(c.getSouthEast()), Vi(new s.S(U, ue)), Vi(new s.S($, ue)), Vi(new s.S(le, Q)), Vi(new s.S(le, se))], ke = Vi(x.center);
            let Ae = Number.POSITIVE_INFINITY;
            for (const be of ye) k < 0 && (Ae = an.getLesserNonNegativeNonNull(Ae, an.solveVectorScale(be, ke, we, "x", k))), T > 0 && (Ae = an.getLesserNonNegativeNonNull(Ae, an.solveVectorScale(be, ke, we, "x", T))), R > 0 && (Ae = an.getLesserNonNegativeNonNull(Ae, an.solveVectorScale(be, ke, we, "y", R))), z < 0 && (Ae = an.getLesserNonNegativeNonNull(Ae, an.solveVectorScale(be, ke, we, "y", z)));
            if (Number.isFinite(Ae) && Ae !== 0) return x.zoom = ge.zoom + s.ak(Ae), x;
            lh();
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat, p = e.getConstrained(a.center ? s.S.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(p.wrap());
            const _ = a.zoom !== void 0 ? +a.zoom : e.zoom + Si(c, p.lat);
            e.zoom !== _ && e.setZoom(_);
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.center, _ = e.padding, x = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, k = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, T = a.zoom !== void 0, R = !e.isPaddingEqual(a.padding);
            let z = false;
            const j = a.center ? s.S.convert(a.center) : p, $ = e.getConstrained(j, c).center;
            Nl(e, $);
            const U = e.clone();
            U.setCenter($), U.setZoom(T ? +a.zoom : c + Si(p.lat, j.lat)), U.setBearing(a.bearing);
            const Q = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            U.setLocationAtPoint($, Q);
            const se = (a.offset && a.offsetAsPoint.mag()) > 0 ? U.center : $, le = T ? +a.zoom : c + Si(p.lat, se.lat), ue = c + Si(p.lat, 0), ge = le + Si(se.lat, 0), we = s.bA(p.lng, se.lng), ye = s.bA(p.lat, se.lat), ke = s.af(ge - ue);
            return z = le !== c, { easeFunc: (Ae) => {
              if (s.be(x, k) || vn({ startEulerAngles: x, endEulerAngles: k, tr: e, k: Ae, useSlerp: x.roll != k.roll }), R && e.interpolatePadding(_, a.padding, Ae), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const be = ge > ue ? Math.min(2, ke) : Math.max(0.5, ke), Le = Math.pow(be, 1 - Ae), Ke = yc(p, we, ye, Ae * Le);
                e.setCenter(Ke.wrap());
              }
              if (z) {
                const be = s.C.number(ue, ge, Ae) + Si(0, e.center.lat);
                e.setZoom(be);
              }
            }, isZooming: z, elevationCenter: se };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.center, _ = e.zoom, x = e.padding, k = !e.isPaddingEqual(a.padding), T = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), _).center, R = c ? +a.zoom : e.zoom + Si(e.center.lat, T.lat), z = e.clone();
            z.setCenter(T), z.setZoom(R), z.setBearing(a.bearing);
            const j = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            z.setLocationAtPoint(T, j);
            const $ = z.center;
            Nl(e, $);
            const U = (function(ye, ke, Ae) {
              const be = Vi(ke), Le = Vi(Ae), Ke = s.aX(be, Le), We = Math.acos(Ke), He = Wl(ye);
              return We / (2 * Math.PI) * He;
            })(e, p, $), Q = _ + Si(p.lat, 0), se = R + Si($.lat, 0), le = s.af(se - Q);
            let ue;
            if (typeof a.minZoom == "number") {
              const ye = +a.minZoom + Si($.lat, 0), ke = Math.min(ye, Q, se) + Si(0, $.lat), Ae = e.getConstrained($, ke).zoom + Si($.lat, 0);
              ue = s.af(Ae - Q);
            }
            const ge = s.bA(p.lng, $.lng), we = s.bA(p.lat, $.lat);
            return { easeFunc: (ye, ke, Ae, be) => {
              const Le = yc(p, ge, we, Ae);
              k && e.interpolatePadding(x, a.padding, ye);
              const Ke = ye === 1 ? $ : Le;
              e.setCenter(Ke.wrap());
              const We = Q + s.ak(ke);
              e.setZoom(ye === 1 ? R : We + Si(0, Ke.lat));
            }, scaleOfZoom: le, targetCenter: $, scaleOfMinZoom: ue, pixelPathLength: U };
          }
          static solveVectorScale(e, a, c, p, _) {
            const x = p === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]], k = [c[3], c[7], c[11], c[15]], T = e[0] * x[0] + e[1] * x[1] + e[2] * x[2], R = e[0] * k[0] + e[1] * k[1] + e[2] * k[2], z = a[0] * x[0] + a[1] * x[1] + a[2] * x[2], j = a[0] * k[0] + a[1] * k[1] + a[2] * k[2];
            return z + _ * R === T + _ * j || k[3] * (T - z) + x[3] * (j - R) + T * j == z * R ? null : (z + x[3] - _ * j - _ * k[3]) / (z - T - _ * j + _ * R);
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e;
          }
        }
        class ch {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new on(), this._verticalPerspectiveCameraHelper = new an();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a);
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a);
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c);
          }
          cameraForBoxAndBearing(e, a, c, p, _) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, p, _);
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a);
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a);
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a);
          }
        }
        const Zl = (y, e) => s.y(y, e && e.filter(((a) => a.identifier !== "source.canvas"))), xp = s.bE();
        class _c extends s.E {
          constructor(e, a = {}) {
            var c, p;
            super(), this._rtlPluginLoaded = () => {
              for (const x in this.sourceCaches) {
                const k = this.sourceCaches[x].getSource().type;
                k !== "vector" && k !== "geojson" || this.sourceCaches[x].reload();
              }
            }, this.map = e, this.dispatcher = new Lt(Qt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((x, k) => this.getGlyphs(x, k))), this.dispatcher.registerMessageHandler("GI", ((x, k) => this.getImages(x, k))), this.dispatcher.registerMessageHandler("GDA", ((x, k) => this.getDashes(x, k))), this.imageManager = new oe(), this.imageManager.setEventedParent(this);
            const _ = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((p = document.documentElement) === null || p === void 0 ? void 0 : p.lang) || void 0;
            this.glyphManager = new Ve(e._requestManager, a.localIdeographFontFamily, _), this.lineAtlas = new et(256, 512), this.crossTileSymbolIndex = new ia(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.bF(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bG()), Qr().on(tt, this._rtlPluginLoaded), this.on("data", ((x) => {
              if (x.dataType !== "source" || x.sourceDataType !== "metadata") return;
              const k = this.sourceCaches[x.sourceId];
              if (!k) return;
              const T = k.getSource();
              if (T && T.vectorLayerIds) for (const R in this._layers) {
                const z = this._layers[R];
                z.source === T.id && this._validateLayer(z);
              }
            }));
          }
          setGlobalStateProperty(e, a) {
            var c, p, _;
            this._checkLoaded();
            const x = a === null ? (_ = (p = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || p === void 0 ? void 0 : p.default) !== null && _ !== void 0 ? _ : null : a;
            if (s.bH(x, this._globalState[e])) return this;
            this._globalState[e] = x, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !s.bH(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = /* @__PURE__ */ new Set(), c = {};
            for (const p of e) {
              c[p] = this._globalState[p];
              for (const _ in this._layers) {
                const x = this._layers[_], k = x.getLayoutAffectingGlobalStateRefs(), T = x.getPaintAffectingGlobalStateRefs();
                if (k.has(p) && a.add(x.source), T.has(p)) for (const { name: R, value: z } of T.get(p)) this._updatePaintProperty(x, R, z);
              }
            }
            this.dispatcher.broadcast("UGS", c);
            for (const p in this.sourceCaches) a.has(p) && (this._reloadSource(p), this._changed = true);
          }
          loadURL(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), a.validate = typeof a.validate != "boolean" || a.validate;
            const p = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const _ = this._loadStyleRequest;
            s.j(p, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, a, c);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !_.signal.aborted && this.fire(new s.k(x));
            }));
          }
          loadJSON(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), D.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== false, this._load(e, a, c);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._load(xp, { validate: false });
          }
          _load(e, a, c) {
            var p, _;
            let x = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !Zl(this, s.z(x))) {
              x = Object.assign({}, x), this._loaded = true, this.stylesheet = x;
              for (const k in x.sources) this.addSource(k, x.sources[k], { validate: false });
              x.sprite ? this._loadSprite(x.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(x.glyphs), this._createLayers(), this.light = new gt(this.stylesheet.light), this._setProjectionInternal(((p = this.stylesheet.projection) === null || p === void 0 ? void 0 : p.type) || "mercator"), this.sky = new lt(this.stylesheet.sky), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.fire(new s.l("data", { dataType: "style" })), this.fire(new s.l("style.load"));
            }
          }
          _createLayers() {
            var e;
            const a = s.bI(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", a), this._order = a.map(((c) => c.id)), this._layers = {}, this._serializedLayers = null;
            for (const c of a) {
              const p = s.bJ(c, this._globalState);
              p.setEventedParent(this, { layer: { id: c.id } }), this._layers[c.id] = p;
            }
          }
          _loadSprite(e, a = false, c = void 0) {
            let p;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(_, x, k, T) {
              return s._(this, void 0, void 0, (function* () {
                const R = X(_), z = k > 1 ? "@2x" : "", j = {}, $ = {};
                for (const { id: U, url: Q } of R) {
                  const se = x.transformRequest(Se(Q, z, ".json"), "SpriteJSON");
                  j[U] = s.j(se, T);
                  const le = x.transformRequest(Se(Q, z, ".png"), "SpriteImage");
                  $[U] = te.getImage(le, T);
                }
                return yield Promise.all([...Object.values(j), ...Object.values($)]), (function(U, Q) {
                  return s._(this, void 0, void 0, (function* () {
                    const se = {};
                    for (const le in U) {
                      se[le] = {};
                      const ue = D.getImageCanvasContext((yield Q[le]).data), ge = (yield U[le]).data;
                      for (const we in ge) {
                        const { width: ye, height: ke, x: Ae, y: be, sdf: Le, pixelRatio: Ke, stretchX: We, stretchY: He, content: Je, textFitWidth: kt, textFitHeight: St } = ge[we];
                        se[le][we] = { data: null, pixelRatio: Ke, sdf: Le, stretchX: We, stretchY: He, content: Je, textFitWidth: kt, textFitHeight: St, spriteData: { width: ye, height: ke, x: Ae, y: be, context: ue } };
                      }
                    }
                    return se;
                  }));
                })(j, $);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((_) => {
              if (this._spriteRequest = null, _) for (const x in _) {
                this._spritesImagesIds[x] = [];
                const k = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((T) => !(T in _))) : [];
                for (const T of k) this.imageManager.removeImage(T), this._changedImages[T] = true;
                for (const T in _[x]) {
                  const R = x === "default" ? T : `${x}:${T}`;
                  this._spritesImagesIds[x].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, _[x][T], false) : this.imageManager.addImage(R, _[x][T]), a && (this._changedImages[R] = true);
                }
              }
            })).catch(((_) => {
              this._spriteRequest = null, p = _, this.fire(new s.k(p));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), a && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" })), c && c(p);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const a = this.sourceCaches[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const p = a.getSource();
            (p.type === "geojson" || p.vectorLayerIds && p.vectorLayerIds.indexOf(c) === -1) && this.fire(new s.k(new Error(`Source layer "${c}" does not exist on source "${p.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, a = false) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bK(c) : c);
            const p = [];
            for (const _ of e) if (c[_]) {
              const x = a ? s.bK(c[_]) : c[_];
              p.push(x);
            }
            return p;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const p = this._layers[c];
              p.type !== "custom" && (e[c] = p.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return true;
            for (const p in this.sourceCaches) if (this.sourceCaches[p].hasTransition()) return true;
            for (const p in this._layers) if (this._layers[p].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const p = Object.keys(this._updatedLayers), _ = Object.keys(this._removedLayers);
              (p.length || _.length) && this._updateWorkerLayers(p, _);
              for (const x in this._updatedSources) {
                const k = this._updatedSources[x];
                if (k === "reload") this._reloadSource(x);
                else {
                  if (k !== "clear") throw new Error(`Invalid action ${k}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const c = {};
            for (const p in this.sourceCaches) {
              const _ = this.sourceCaches[p];
              c[p] = _.used, _.used = false;
            }
            for (const p of this._order) {
              const _ = this._layers[p];
              _.recalculate(e, this._availableImages), !_.isHidden(e.zoom) && _.source && (this.sourceCaches[_.source].used = true);
            }
            for (const p in c) {
              const _ = this.sourceCaches[p];
              !!c[p] != !!_.used && _.fire(new s.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: p }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, false), removedIds: a });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const p = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(p, e) : e, ((c = a.validate) === null || c === void 0 || c) && Zl(this, s.z(e))) return false;
            (e = s.bK(e)).layers = s.bI(e.layers);
            const _ = s.bL(p, e), x = this._getOperationsToPerform(_);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return false;
            for (const k of x.operations) k();
            return this.stylesheet = e, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e) {
            const a = [], c = [];
            for (const p of e) switch (p.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, p.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, p.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, p.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, p.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, p.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, p.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, p.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, p.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, p.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, p.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, p.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, p.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, p.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, p.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, p.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, p.args)));
                break;
              case "setTransition":
                a.push((() => {
                }));
                break;
              default:
                c.push(p.command);
            }
            return { operations: a, unimplemented: c };
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e);
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.z.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = true);
            const p = this.sourceCaches[e] = new or(e, a, this.dispatcher);
            p.style = this, p.setEventedParent(this, (() => ({ isSourceLoaded: p.loaded(), source: p.serialize(), sourceId: e }))), p.onAdd(this.map), this._changed = true;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers) if (this._layers[c].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], a.fire(new s.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), a.setEventedParent(null), a.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.sourceCaches[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = true;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const p = e.id;
            if (this.getLayer(p)) return void this.fire(new s.k(new Error(`Layer "${p}" already exists on this map.`)));
            let _;
            if (e.type === "custom") {
              if (Zl(this, s.bM(e))) return;
              _ = s.bJ(e, this._globalState);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(p, e.source), e = s.bK(e), e = s.e(e, { source: p })), this._validate(s.z.layer, `layers.${p}`, e, { arrayIndex: -1 }, c)) return;
              _ = s.bJ(e, this._globalState), this._validateLayer(_), _.setEventedParent(this, { layer: { id: p } });
            }
            const x = a ? this._order.indexOf(a) : this._order.length;
            if (a && x === -1) this.fire(new s.k(new Error(`Cannot add layer "${p}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(x, 0, p), this._layerOrderChanged = true, this._layers[p] = _, this._removedLayers[p] && _.source && _.type !== "custom") {
                const k = this._removedLayers[p];
                delete this._removedLayers[p], k.type !== _.type ? this._updatedSources[_.source] = "clear" : (this._updatedSources[_.source] = "reload", this.sourceCaches[_.source].pause());
              }
              this._updateLayer(_), _.onAdd && _.onAdd(this.map);
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const p = a ? this._order.indexOf(a) : this._order.length;
            a && p === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(p, 0, e), this._layerOrderChanged = true);
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? p.minzoom === a && p.maxzoom === c || (a != null && (p.minzoom = a), c != null && (p.maxzoom = c), this._updateLayer(p)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            if (p) {
              if (!s.bH(p.filter, a)) return a == null ? (p.setFilter(void 0), void this._updateLayer(p)) : void (this._validate(s.z.filter, `layers.${p.id}.filter`, a, null, c) || (p.setFilter(s.bK(a)), this._updateLayer(p)));
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return s.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bH(_.getLayoutProperty(a), c) || (_.setLayoutProperty(a, c, p), this._updateLayer(_)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bH(_.getPaintProperty(a), c) || this._updatePaintProperty(_, a, c, p) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, a, c, p = {}) {
            e.setPaintProperty(a, c, p) && this._updateLayer(e), this._changed = true, this._updatedPaintProps[e.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a);
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = e.sourceLayer, _ = this.sourceCaches[c];
            if (_ === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const x = _.getSource().type;
            x === "geojson" && p ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || p ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), _.setFeatureState(p, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = this.sourceCaches[c];
            if (p === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const _ = p.getSource().type, x = _ === "vector" ? e.sourceLayer : void 0;
            _ !== "vector" || x ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : p.removeFeatureState(x, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source, c = e.sourceLayer, p = this.sourceCaches[a];
            if (p !== void 0) return p.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), p.getFeatureState(c, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)));
          }
          getTransition() {
            return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bN(this.sourceCaches, ((_) => _.serialize())), a = this._serializeByIds(this._order, true), c = this.map.getTerrain() || void 0, p = this.stylesheet;
            return s.bO({ version: p.version, name: p.name, metadata: p.metadata, light: p.light, sky: p.sky, center: p.center, zoom: p.zoom, bearing: p.bearing, pitch: p.pitch, sprite: p.sprite, glyphs: p.glyphs, transition: p.transition, projection: p.projection, sources: e, layers: a, terrain: c }, ((_) => _ !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = true, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = (x) => this._layers[x].type === "fill-extrusion", c = {}, p = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) {
                c[k] = x;
                for (const T of e) {
                  const R = T[k];
                  if (R) for (const z of R) p.push(z);
                }
              }
            }
            p.sort(((x, k) => k.intersectionZ - x.intersectionZ));
            const _ = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) for (let T = p.length - 1; T >= 0; T--) {
                const R = p[T].feature;
                if (c[R.layer.id] < x) break;
                _.push(R), p.pop();
              }
              else for (const T of e) {
                const R = T[k];
                if (R) for (const z of R) _.push(z.feature);
              }
            }
            return _;
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(s.z.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const p = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of a.layers) {
                const z = this._layers[R];
                if (!z) return this.fire(new s.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                p[z.source] = true;
              }
            }
            const _ = [];
            a.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), k = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null, T = Object.assign(Object.assign({}, a), { layers: k, globalState: this._globalState });
            for (const R in this.sourceCaches) a.layers && !p[R] || _.push(At(this.sourceCaches[R], this._layers, x, e, T, c, this.map.terrain ? (z, j, $) => this.map.terrain.getElevation(z, j, $) : void 0));
            return this.placement && _.push((function(R, z, j, $, U, Q, se) {
              const le = {}, ue = Q.queryRenderedSymbols($), ge = [];
              for (const we of Object.keys(ue).map(Number)) ge.push(se[we]);
              ge.sort(mr);
              for (const we of ge) {
                const ye = we.featureIndex.lookupSymbolFeatures(ue[we.bucketInstanceId], z, we.bucketIndex, we.sourceLayerIndex, { filterSpec: U.filter, globalState: U.globalState }, U.layers, U.availableImages, R);
                for (const ke in ye) {
                  const Ae = le[ke] = le[ke] || [], be = ye[ke];
                  be.sort(((Le, Ke) => {
                    const We = we.featureSortOrder;
                    if (We) {
                      const He = We.indexOf(Le.featureIndex);
                      return We.indexOf(Ke.featureIndex) - He;
                    }
                    return Ke.featureIndex - Le.featureIndex;
                  }));
                  for (const Le of be) Ae.push(Le);
                }
              }
              return (function(we, ye, ke) {
                for (const Ae in we) for (const be of we[Ae]) gr(be, ke[ye[Ae].source]);
                return we;
              })(le, R, j);
            })(this._layers, x, this.sourceCaches, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(_);
          }
          querySourceFeatures(e, a) {
            (a == null ? void 0 : a.filter) && this._validate(s.z.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.sourceCaches[e];
            return c ? (function(p, _) {
              const x = p.getRenderableIds().map(((R) => p.getTileByID(R))), k = [], T = {};
              for (let R = 0; R < x.length; R++) {
                const z = x[R], j = z.tileID.canonical.key;
                T[j] || (T[j] = true, z.querySourceFeatures(k, _));
              }
              return k;
            })(c, a ? Object.assign(Object.assign({}, a), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let p = false;
            for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const _ = { now: D.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, a), this.light.updateTransitions(_);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let p = false;
            if (!e && !c) return;
            if (e && !c) p = true;
            else if (!e && c) p = true;
            else for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const _ = { now: D.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(_);
          }
          _setProjectionInternal(e) {
            const a = (function(c) {
              if (Array.isArray(c)) {
                const p = new Gl({ type: c });
                return { projection: p, transform: new Us(), cameraHelper: new ch(p) };
              }
              switch (c) {
                case "mercator":
                  return { projection: new br(), transform: new Jr(), cameraHelper: new on() };
                case "globe": {
                  const p = new Gl({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: p, transform: new Us(), cameraHelper: new ch(p) };
                }
                case "vertical-perspective":
                  return { projection: new Bs(), transform: new Vs(), cameraHelper: new an() };
                default:
                  return s.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), { projection: new br(), transform: new Jr(), cameraHelper: new on() };
              }
            })(e);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.sourceCaches) this.sourceCaches[c].reload();
          }
          _validate(e, a, c, p, _ = {}) {
            return (!_ || _.validate !== false) && Zl(this, e.call(s.z, s.e({ key: a, style: this.serialize(), value: c, styleSpec: s.v }, p)));
          }
          _remove(e = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Qr().off(tt, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.sourceCaches) {
              const c = this.sourceCaches[a];
              c.setEventedParent(null), c.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const a in this.sourceCaches) this.sourceCaches[a].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, a, c, p, _ = false) {
            let x = false, k = false;
            const T = {};
            for (const R of this._order) {
              const z = this._layers[R];
              if (z.type !== "symbol") continue;
              if (!T[z.source]) {
                const $ = this.sourceCaches[z.source];
                T[z.source] = $.getRenderableIds(true).map(((U) => $.getTileByID(U))).sort(((U, Q) => Q.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(Q.tileID) ? -1 : 1)));
              }
              const j = this.crossTileSymbolIndex.addLayer(z, T[z.source], e.center.lng);
              x = x || j;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((_ = _ || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(D.now(), e.zoom)) && (this.pauseablePlacement = new zs(e, this.map.terrain, this._order, _, a, c, p, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(D.now()), k = true), x && this.pauseablePlacement.placement.setStale()), k || x) for (const R of this._order) {
              const z = this._layers[R];
              z.type === "symbol" && this.placement.updateLayerOpacities(z, T[z.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(D.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, a.icons), c;
            }));
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.glyphManager.getGlyphs(a.stacks), p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, [""]), c;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.z.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          getDashes(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = {};
              for (const [p, _] of Object.entries(a.dashes)) c[p] = this.lineAtlas.getDash(_.dasharray, _.round);
              return c;
            }));
          }
          addSprite(e, a, c = {}, p) {
            this._checkLoaded();
            const _ = [{ id: e, url: a }], x = [...X(this.stylesheet.sprite), ..._];
            this._validate(s.z.sprite, "sprite", x, null, c) || (this.stylesheet.sprite = x, this._loadSprite(_, true, p));
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = X(this.stylesheet.sprite);
            if (a.find(((c) => c.id === e))) {
              if (this._spritesImagesIds[e]) for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = true;
              a.splice(a.findIndex(((c) => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return X(this.stylesheet.sprite);
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(s.z.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, true, c) : (this._unloadSprite(), c && c(null)));
          }
        }
        var wp = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Cp {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, a, c, p, _, x, k, T, R) {
            this.context = e;
            let z = this.boundPaintVertexBuffers.length !== p.length;
            for (let j = 0; !z && j < p.length; j++) this.boundPaintVertexBuffers[j] !== p[j] && (z = true);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || z || this.boundIndexBuffer !== _ || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== k || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(a, c, p, _, x, k, T, R) : (e.bindVertexArray.set(this.vao), k && k.bind(), _ && _.dynamicDraw && _.bind(), T && T.bind(), R && R.bind());
          }
          freshBind(e, a, c, p, _, x, k, T) {
            const R = e.numAttributes, z = this.context, j = z.gl;
            this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = p, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = k, this.boundDynamicVertexBuffer3 = T, a.enableAttributes(j, e);
            for (const $ of c) $.enableAttributes(j, e);
            x && x.enableAttributes(j, e), k && k.enableAttributes(j, e), T && T.enableAttributes(j, e), a.bind(), a.setVertexAttribPointers(j, e, _);
            for (const $ of c) $.bind(), $.setVertexAttribPointers(j, e, _);
            x && (x.bind(), x.setVertexAttribPointers(j, e, _)), p && p.bind(), k && (k.bind(), k.setVertexAttribPointers(j, e, _)), T && (T.bind(), T.setVertexAttribPointers(j, e, _)), z.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Hl = (y, e, a, c, p) => ({ u_texture: 0, u_ele_delta: y, u_fog_matrix: e, u_fog_color: a ? a.properties.get("fog-color") : s.bf.white, u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: p ? 0 : a ? a.calculateFogBlendOpacity(c) : 0, u_horizon_color: a ? a.properties.get("horizon-color") : s.bf.white, u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: p ? 1 : 0 }), bc = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Pa(y) {
          const e = [];
          for (let a = 0; a < y.length; a++) {
            if (y[a] === null) continue;
            const c = y[a].split(" ");
            e.push(c.pop());
          }
          return e;
        }
        class xc {
          constructor(e, a, c, p, _, x, k, T, R = []) {
            const z = e.gl;
            this.program = z.createProgram();
            const j = Pa(a.staticAttributes), $ = c ? c.getBinderAttributes() : [], U = j.concat($), Q = An.prelude.staticUniforms ? Pa(An.prelude.staticUniforms) : [], se = k.staticUniforms ? Pa(k.staticUniforms) : [], le = a.staticUniforms ? Pa(a.staticUniforms) : [], ue = c ? c.getBinderUniforms() : [], ge = Q.concat(se).concat(le).concat(ue), we = [];
            for (const We of ge) we.indexOf(We) < 0 && we.push(We);
            const ye = c ? c.defines() : [];
            Co(z) && ye.unshift("#version 300 es"), _ && ye.push("#define OVERDRAW_INSPECTOR;"), x && ye.push("#define TERRAIN3D;"), T && ye.push(T), R && ye.push(...R);
            let ke = ye.concat(An.prelude.fragmentSource, k.fragmentSource, a.fragmentSource).join(`
`), Ae = ye.concat(An.prelude.vertexSource, k.vertexSource, a.vertexSource).join(`
`);
            Co(z) || (ke = (function(We) {
              return We.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(ke), Ae = (function(We) {
              return We.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Ae));
            const be = z.createShader(z.FRAGMENT_SHADER);
            if (z.isContextLost()) return void (this.failedToCreate = true);
            if (z.shaderSource(be, ke), z.compileShader(be), !z.getShaderParameter(be, z.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${z.getShaderInfoLog(be)}`);
            z.attachShader(this.program, be);
            const Le = z.createShader(z.VERTEX_SHADER);
            if (z.isContextLost()) return void (this.failedToCreate = true);
            if (z.shaderSource(Le, Ae), z.compileShader(Le), !z.getShaderParameter(Le, z.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${z.getShaderInfoLog(Le)}`);
            z.attachShader(this.program, Le), this.attributes = {};
            const Ke = {};
            this.numAttributes = U.length;
            for (let We = 0; We < this.numAttributes; We++) U[We] && (z.bindAttribLocation(this.program, We, U[We]), this.attributes[U[We]] = We);
            if (z.linkProgram(this.program), !z.getProgramParameter(this.program, z.LINK_STATUS)) throw new Error(`Program failed to link: ${z.getProgramInfoLog(this.program)}`);
            z.deleteShader(Le), z.deleteShader(be);
            for (let We = 0; We < we.length; We++) {
              const He = we[We];
              if (He && !Ke[He]) {
                const Je = z.getUniformLocation(this.program, He);
                Je && (Ke[He] = Je);
              }
            }
            this.fixedUniforms = p(e, Ke), this.terrainUniforms = ((We, He) => ({ u_depth: new s.bP(We, He.u_depth), u_terrain: new s.bP(We, He.u_terrain), u_terrain_dim: new s.bg(We, He.u_terrain_dim), u_terrain_matrix: new s.bR(We, He.u_terrain_matrix), u_terrain_unpack: new s.bS(We, He.u_terrain_unpack), u_terrain_exaggeration: new s.bg(We, He.u_terrain_exaggeration) }))(e, Ke), this.projectionUniforms = ((We, He) => ({ u_projection_matrix: new s.bR(We, He.u_projection_matrix), u_projection_tile_mercator_coords: new s.bS(We, He.u_projection_tile_mercator_coords), u_projection_clipping_plane: new s.bS(We, He.u_projection_clipping_plane), u_projection_transition: new s.bg(We, He.u_projection_transition), u_projection_fallback_matrix: new s.bR(We, He.u_projection_fallback_matrix) }))(e, Ke), this.binderUniforms = c ? c.getUniforms(e, Ke) : [];
          }
          draw(e, a, c, p, _, x, k, T, R, z, j, $, U, Q, se, le, ue, ge, we) {
            const ye = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(p), e.setColorMode(_), e.setCullFace(x), T) {
              e.activeTexture.set(ye.TEXTURE2), ye.bindTexture(ye.TEXTURE_2D, T.depthTexture), e.activeTexture.set(ye.TEXTURE3), ye.bindTexture(ye.TEXTURE_2D, T.texture);
              for (const Ae in this.terrainUniforms) this.terrainUniforms[Ae].set(T[Ae]);
            }
            if (R) for (const Ae in R) this.projectionUniforms[bc[Ae]].set(R[Ae]);
            if (k) for (const Ae in this.fixedUniforms) this.fixedUniforms[Ae].set(k[Ae]);
            le && le.setUniforms(e, this.binderUniforms, Q, { zoom: se });
            let ke = 0;
            switch (a) {
              case ye.LINES:
                ke = 2;
                break;
              case ye.TRIANGLES:
                ke = 3;
                break;
              case ye.LINE_STRIP:
                ke = 1;
            }
            for (const Ae of U.get()) {
              const be = Ae.vaos || (Ae.vaos = {});
              (be[z] || (be[z] = new Cp())).bind(e, this, j, le ? le.getPaintVertexBuffers() : [], $, Ae.vertexOffset, ue, ge, we), ye.drawElements(a, Ae.primitiveLength * ke, ye.UNSIGNED_SHORT, Ae.primitiveOffset * ke * 2);
            }
          }
        }
        function Xl(y, e, a) {
          const c = 1 / s.aC(a, 1, e.transform.tileZoom), p = Math.pow(2, a.tileID.overscaledZ), _ = a.tileSize * Math.pow(2, e.transform.tileZoom) / p, x = _ * (a.tileID.canonical.x + a.tileID.wrap * p), k = _ * a.tileID.canonical.y;
          return { u_image: 0, u_texsize: a.imageAtlasTexture.size, u_scale: [c, y.fromScale, y.toScale], u_fade: y.t, u_pixel_coord_upper: [x >> 16, k >> 16], u_pixel_coord_lower: [65535 & x, 65535 & k] };
        }
        const no = (y, e, a, c) => {
          const p = y.style.light, _ = p.properties.get("position"), x = [_.x, _.y, _.z], k = s.bV();
          p.properties.get("anchor") === "viewport" && s.bW(k, y.transform.bearingInRadians), s.bX(x, x, k);
          const T = y.transform.transformLightDirection(x), R = p.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: T, u_lightintensity: p.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +e, u_opacity: a, u_fill_translate: c };
        }, Sp = (y, e, a, c, p, _, x) => s.e(no(y, e, a, c), Xl(_, y, x), { u_height_factor: -Math.pow(2, p.overscaledZ) / x.tileSize / 8 }), Yl = (y, e, a, c) => s.e(Xl(e, y, a), { u_fill_translate: c }), qs = (y, e) => ({ u_world: y, u_fill_translate: e }), Gs = (y, e, a, c, p) => s.e(Yl(y, e, a, p), { u_world: c }), kp = (y, e, a, c, p) => {
          const _ = y.transform;
          let x, k, T = 0;
          if (a.paint.get("circle-pitch-alignment") === "map") {
            const R = s.aC(e, 1, _.zoom);
            x = true, k = [R, R], T = R / (s.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * p;
          } else x = false, k = _.pixelsToGLUnits;
          return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: y.pixelRatio, u_extrude_scale: k, u_globe_extrude_scale: T, u_translate: c };
        }, Kl = (y) => ({ u_pixel_extrude_scale: [1 / y.width, 1 / y.height] }), Pp = (y) => ({ u_viewport_size: [y.width, y.height] }), Ta = (y, e = 1) => ({ u_color: y, u_overlay: 0, u_overlay_scale: e }), dh = (y, e, a, c) => {
          const p = s.aC(y, 1, e) / (s.$ * Math.pow(2, y.tileID.overscaledZ)) * 2 * Math.PI * c;
          return { u_extrude_scale: s.aC(y, 1, e), u_intensity: a, u_globe_extrude_scale: p };
        }, wc = (y, e, a, c) => {
          const p = s.L();
          s.bY(p, 0, y.width, y.height, 0, 0, 1);
          const _ = y.context.gl;
          return { u_matrix: p, u_world: [_.drawingBufferWidth, _.drawingBufferHeight], u_image: a, u_color_ramp: c, u_opacity: e.paint.get("heatmap-opacity") };
        }, Tp = (y, e, a) => {
          const c = a.paint.get("hillshade-accent-color");
          let p;
          switch (a.paint.get("hillshade-method")) {
            case "basic":
              p = 4;
              break;
            case "combined":
              p = 1;
              break;
            case "igor":
              p = 2;
              break;
            case "multidirectional":
              p = 3;
              break;
            default:
              p = 0;
          }
          const _ = a.getIlluminationProperties();
          for (let x = 0; x < _.directionRadians.length; x++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (_.directionRadians[x] += y.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Cc(0, e.tileID), u_exaggeration: a.paint.get("hillshade-exaggeration"), u_altitudes: _.altitudeRadians, u_azimuths: _.directionRadians, u_accent: c, u_method: p, u_highlights: _.highlightColor, u_shadows: _.shadowColor };
        }, hh = (y, e) => {
          const a = e.stride, c = s.L();
          return s.bY(c, 0, s.$, -s.$, 0, 0, 1), s.M(c, c, [0, -s.$, 0]), { u_matrix: c, u_image: 1, u_dimension: [a, a], u_zoom: y.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function Cc(y, e) {
          const a = Math.pow(2, e.canonical.z), c = e.canonical.y;
          return [new s.a1(0, c / a).toLngLat().lat, new s.a1(0, (c + 1) / a).toLngLat().lat];
        }
        const fh = (y, e, a = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: a, u_opacity: y.paint.get("color-relief-opacity") }), Jl = (y, e, a, c) => {
          const p = y.transform;
          return { u_translation: kc(y, e, a), u_ratio: c / s.aC(e, 1, p.zoom), u_device_pixel_ratio: y.pixelRatio, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
        }, ph = (y, e, a, c, p) => s.e(Jl(y, e, a, c), { u_image: 0, u_image_height: p }), mh = (y, e, a, c, p) => {
          const _ = y.transform, x = Sc(e, _);
          return { u_translation: kc(y, e, a), u_texsize: e.imageAtlasTexture.size, u_ratio: c / s.aC(e, 1, _.zoom), u_device_pixel_ratio: y.pixelRatio, u_image: 0, u_scale: [x, p.fromScale, p.toScale], u_fade: p.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
        }, Ia = (y, e, a, c, p) => {
          const _ = Sc(e, y.transform);
          return s.e(Jl(y, e, a, c), { u_tileratio: _, u_crossfade_from: p.fromScale, u_crossfade_to: p.toScale, u_image: 0, u_mix: p.t, u_lineatlas_width: y.lineAtlas.width, u_lineatlas_height: y.lineAtlas.height });
        };
        function Sc(y, e) {
          return 1 / s.aC(y, 1, e.tileZoom);
        }
        function kc(y, e, a) {
          return s.aD(y.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"));
        }
        const Ws = (y, e, a, c, p) => {
          return { u_tl_parent: y, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: a.mix, u_opacity: a.opacity * c.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: c.paint.get("raster-brightness-min"), u_brightness_high: c.paint.get("raster-brightness-max"), u_saturation_factor: (x = c.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (_ = c.paint.get("raster-contrast"), _ > 0 ? 1 / (1 - _) : 1 + _), u_spin_weights: Ip(c.paint.get("raster-hue-rotate")), u_coords_top: [p[0].x, p[0].y, p[1].x, p[1].y], u_coords_bottom: [p[3].x, p[3].y, p[2].x, p[2].y] };
          var _, x;
        };
        function Ip(y) {
          y *= Math.PI / 180;
          const e = Math.sin(y), a = Math.cos(y);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3];
        }
        const Zs = (y, e, a, c, p, _, x, k, T, R, z, j, $) => {
          const U = x.transform;
          return { u_is_size_zoom_constant: +(y === "constant" || y === "source"), u_is_size_feature_constant: +(y === "constant" || y === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: U.cameraToCenterDistance, u_pitch: U.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +a, u_aspect_ratio: U.width / U.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: k, u_coord_matrix: T, u_is_text: +z, u_pitch_with_map: +c, u_is_along_line: p, u_is_variable_anchor: _, u_texsize: j, u_texture: 0, u_translation: R, u_pitched_scale: $ };
        }, gh = (y, e, a, c, p, _, x, k, T, R, z, j, $, U) => {
          const Q = x.transform;
          return s.e(Zs(y, e, a, c, p, _, x, k, T, R, z, j, U), { u_gamma_scale: c ? Math.cos(Q.pitch * Math.PI / 180) * Q.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, Mp = (y, e, a, c, p, _, x, k, T, R, z, j, $) => s.e(gh(y, e, a, c, p, _, x, k, T, R, true, z, 0, $), { u_texsize_icon: j, u_texture_icon: 1 }), vh = (y, e) => ({ u_opacity: y, u_color: e }), yh = (y, e, a, c, p) => s.e((function(_, x, k, T) {
          const R = k.imageManager.getPattern(_.from.toString()), z = k.imageManager.getPattern(_.to.toString()), { width: j, height: $ } = k.imageManager.getPixelSize(), U = Math.pow(2, T.tileID.overscaledZ), Q = T.tileSize * Math.pow(2, k.transform.tileZoom) / U, se = Q * (T.tileID.canonical.x + T.tileID.wrap * U), le = Q * T.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: z.tl, u_pattern_br_b: z.br, u_texsize: [j, $], u_mix: x.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: z.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / s.aC(T, 1, k.transform.tileZoom), u_pixel_coord_upper: [se >> 16, le >> 16], u_pixel_coord_lower: [65535 & se, 65535 & le] };
        })(a, p, e, c), { u_opacity: y }), Pc = (y, e) => {
        }, Tc = { fillExtrusion: (y, e) => ({ u_lightpos: new s.bT(y, e.u_lightpos), u_lightpos_globe: new s.bT(y, e.u_lightpos_globe), u_lightintensity: new s.bg(y, e.u_lightintensity), u_lightcolor: new s.bT(y, e.u_lightcolor), u_vertical_gradient: new s.bg(y, e.u_vertical_gradient), u_opacity: new s.bg(y, e.u_opacity), u_fill_translate: new s.bU(y, e.u_fill_translate) }), fillExtrusionPattern: (y, e) => ({ u_lightpos: new s.bT(y, e.u_lightpos), u_lightpos_globe: new s.bT(y, e.u_lightpos_globe), u_lightintensity: new s.bg(y, e.u_lightintensity), u_lightcolor: new s.bT(y, e.u_lightcolor), u_vertical_gradient: new s.bg(y, e.u_vertical_gradient), u_height_factor: new s.bg(y, e.u_height_factor), u_opacity: new s.bg(y, e.u_opacity), u_fill_translate: new s.bU(y, e.u_fill_translate), u_image: new s.bP(y, e.u_image), u_texsize: new s.bU(y, e.u_texsize), u_pixel_coord_upper: new s.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(y, e.u_pixel_coord_lower), u_scale: new s.bT(y, e.u_scale), u_fade: new s.bg(y, e.u_fade) }), fill: (y, e) => ({ u_fill_translate: new s.bU(y, e.u_fill_translate) }), fillPattern: (y, e) => ({ u_image: new s.bP(y, e.u_image), u_texsize: new s.bU(y, e.u_texsize), u_pixel_coord_upper: new s.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(y, e.u_pixel_coord_lower), u_scale: new s.bT(y, e.u_scale), u_fade: new s.bg(y, e.u_fade), u_fill_translate: new s.bU(y, e.u_fill_translate) }), fillOutline: (y, e) => ({ u_world: new s.bU(y, e.u_world), u_fill_translate: new s.bU(y, e.u_fill_translate) }), fillOutlinePattern: (y, e) => ({ u_world: new s.bU(y, e.u_world), u_image: new s.bP(y, e.u_image), u_texsize: new s.bU(y, e.u_texsize), u_pixel_coord_upper: new s.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(y, e.u_pixel_coord_lower), u_scale: new s.bT(y, e.u_scale), u_fade: new s.bg(y, e.u_fade), u_fill_translate: new s.bU(y, e.u_fill_translate) }), circle: (y, e) => ({ u_camera_to_center_distance: new s.bg(y, e.u_camera_to_center_distance), u_scale_with_map: new s.bP(y, e.u_scale_with_map), u_pitch_with_map: new s.bP(y, e.u_pitch_with_map), u_extrude_scale: new s.bU(y, e.u_extrude_scale), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_globe_extrude_scale: new s.bg(y, e.u_globe_extrude_scale), u_translate: new s.bU(y, e.u_translate) }), collisionBox: (y, e) => ({ u_pixel_extrude_scale: new s.bU(y, e.u_pixel_extrude_scale) }), collisionCircle: (y, e) => ({ u_viewport_size: new s.bU(y, e.u_viewport_size) }), debug: (y, e) => ({ u_color: new s.bQ(y, e.u_color), u_overlay: new s.bP(y, e.u_overlay), u_overlay_scale: new s.bg(y, e.u_overlay_scale) }), depth: Pc, clippingMask: Pc, heatmap: (y, e) => ({ u_extrude_scale: new s.bg(y, e.u_extrude_scale), u_intensity: new s.bg(y, e.u_intensity), u_globe_extrude_scale: new s.bg(y, e.u_globe_extrude_scale) }), heatmapTexture: (y, e) => ({ u_matrix: new s.bR(y, e.u_matrix), u_world: new s.bU(y, e.u_world), u_image: new s.bP(y, e.u_image), u_color_ramp: new s.bP(y, e.u_color_ramp), u_opacity: new s.bg(y, e.u_opacity) }), hillshade: (y, e) => ({ u_image: new s.bP(y, e.u_image), u_latrange: new s.bU(y, e.u_latrange), u_exaggeration: new s.bg(y, e.u_exaggeration), u_altitudes: new s.b_(y, e.u_altitudes), u_azimuths: new s.b_(y, e.u_azimuths), u_accent: new s.bQ(y, e.u_accent), u_method: new s.bP(y, e.u_method), u_shadows: new s.bZ(y, e.u_shadows), u_highlights: new s.bZ(y, e.u_highlights) }), hillshadePrepare: (y, e) => ({ u_matrix: new s.bR(y, e.u_matrix), u_image: new s.bP(y, e.u_image), u_dimension: new s.bU(y, e.u_dimension), u_zoom: new s.bg(y, e.u_zoom), u_unpack: new s.bS(y, e.u_unpack) }), colorRelief: (y, e) => ({ u_image: new s.bP(y, e.u_image), u_unpack: new s.bS(y, e.u_unpack), u_dimension: new s.bU(y, e.u_dimension), u_elevation_stops: new s.bP(y, e.u_elevation_stops), u_color_stops: new s.bP(y, e.u_color_stops), u_color_ramp_size: new s.bP(y, e.u_color_ramp_size), u_opacity: new s.bg(y, e.u_opacity) }), line: (y, e) => ({ u_translation: new s.bU(y, e.u_translation), u_ratio: new s.bg(y, e.u_ratio), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(y, e.u_units_to_pixels) }), lineGradient: (y, e) => ({ u_translation: new s.bU(y, e.u_translation), u_ratio: new s.bg(y, e.u_ratio), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(y, e.u_units_to_pixels), u_image: new s.bP(y, e.u_image), u_image_height: new s.bg(y, e.u_image_height) }), linePattern: (y, e) => ({ u_translation: new s.bU(y, e.u_translation), u_texsize: new s.bU(y, e.u_texsize), u_ratio: new s.bg(y, e.u_ratio), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_image: new s.bP(y, e.u_image), u_units_to_pixels: new s.bU(y, e.u_units_to_pixels), u_scale: new s.bT(y, e.u_scale), u_fade: new s.bg(y, e.u_fade) }), lineSDF: (y, e) => ({ u_translation: new s.bU(y, e.u_translation), u_ratio: new s.bg(y, e.u_ratio), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(y, e.u_units_to_pixels), u_image: new s.bP(y, e.u_image), u_mix: new s.bg(y, e.u_mix), u_tileratio: new s.bg(y, e.u_tileratio), u_crossfade_from: new s.bg(y, e.u_crossfade_from), u_crossfade_to: new s.bg(y, e.u_crossfade_to), u_lineatlas_width: new s.bg(y, e.u_lineatlas_width), u_lineatlas_height: new s.bg(y, e.u_lineatlas_height) }), raster: (y, e) => ({ u_tl_parent: new s.bU(y, e.u_tl_parent), u_scale_parent: new s.bg(y, e.u_scale_parent), u_buffer_scale: new s.bg(y, e.u_buffer_scale), u_fade_t: new s.bg(y, e.u_fade_t), u_opacity: new s.bg(y, e.u_opacity), u_image0: new s.bP(y, e.u_image0), u_image1: new s.bP(y, e.u_image1), u_brightness_low: new s.bg(y, e.u_brightness_low), u_brightness_high: new s.bg(y, e.u_brightness_high), u_saturation_factor: new s.bg(y, e.u_saturation_factor), u_contrast_factor: new s.bg(y, e.u_contrast_factor), u_spin_weights: new s.bT(y, e.u_spin_weights), u_coords_top: new s.bS(y, e.u_coords_top), u_coords_bottom: new s.bS(y, e.u_coords_bottom) }), symbolIcon: (y, e) => ({ u_is_size_zoom_constant: new s.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(y, e.u_is_size_feature_constant), u_size_t: new s.bg(y, e.u_size_t), u_size: new s.bg(y, e.u_size), u_camera_to_center_distance: new s.bg(y, e.u_camera_to_center_distance), u_pitch: new s.bg(y, e.u_pitch), u_rotate_symbol: new s.bP(y, e.u_rotate_symbol), u_aspect_ratio: new s.bg(y, e.u_aspect_ratio), u_fade_change: new s.bg(y, e.u_fade_change), u_label_plane_matrix: new s.bR(y, e.u_label_plane_matrix), u_coord_matrix: new s.bR(y, e.u_coord_matrix), u_is_text: new s.bP(y, e.u_is_text), u_pitch_with_map: new s.bP(y, e.u_pitch_with_map), u_is_along_line: new s.bP(y, e.u_is_along_line), u_is_variable_anchor: new s.bP(y, e.u_is_variable_anchor), u_texsize: new s.bU(y, e.u_texsize), u_texture: new s.bP(y, e.u_texture), u_translation: new s.bU(y, e.u_translation), u_pitched_scale: new s.bg(y, e.u_pitched_scale) }), symbolSDF: (y, e) => ({ u_is_size_zoom_constant: new s.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(y, e.u_is_size_feature_constant), u_size_t: new s.bg(y, e.u_size_t), u_size: new s.bg(y, e.u_size), u_camera_to_center_distance: new s.bg(y, e.u_camera_to_center_distance), u_pitch: new s.bg(y, e.u_pitch), u_rotate_symbol: new s.bP(y, e.u_rotate_symbol), u_aspect_ratio: new s.bg(y, e.u_aspect_ratio), u_fade_change: new s.bg(y, e.u_fade_change), u_label_plane_matrix: new s.bR(y, e.u_label_plane_matrix), u_coord_matrix: new s.bR(y, e.u_coord_matrix), u_is_text: new s.bP(y, e.u_is_text), u_pitch_with_map: new s.bP(y, e.u_pitch_with_map), u_is_along_line: new s.bP(y, e.u_is_along_line), u_is_variable_anchor: new s.bP(y, e.u_is_variable_anchor), u_texsize: new s.bU(y, e.u_texsize), u_texture: new s.bP(y, e.u_texture), u_gamma_scale: new s.bg(y, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_is_halo: new s.bP(y, e.u_is_halo), u_translation: new s.bU(y, e.u_translation), u_pitched_scale: new s.bg(y, e.u_pitched_scale) }), symbolTextAndIcon: (y, e) => ({ u_is_size_zoom_constant: new s.bP(y, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(y, e.u_is_size_feature_constant), u_size_t: new s.bg(y, e.u_size_t), u_size: new s.bg(y, e.u_size), u_camera_to_center_distance: new s.bg(y, e.u_camera_to_center_distance), u_pitch: new s.bg(y, e.u_pitch), u_rotate_symbol: new s.bP(y, e.u_rotate_symbol), u_aspect_ratio: new s.bg(y, e.u_aspect_ratio), u_fade_change: new s.bg(y, e.u_fade_change), u_label_plane_matrix: new s.bR(y, e.u_label_plane_matrix), u_coord_matrix: new s.bR(y, e.u_coord_matrix), u_is_text: new s.bP(y, e.u_is_text), u_pitch_with_map: new s.bP(y, e.u_pitch_with_map), u_is_along_line: new s.bP(y, e.u_is_along_line), u_is_variable_anchor: new s.bP(y, e.u_is_variable_anchor), u_texsize: new s.bU(y, e.u_texsize), u_texsize_icon: new s.bU(y, e.u_texsize_icon), u_texture: new s.bP(y, e.u_texture), u_texture_icon: new s.bP(y, e.u_texture_icon), u_gamma_scale: new s.bg(y, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(y, e.u_device_pixel_ratio), u_is_halo: new s.bP(y, e.u_is_halo), u_translation: new s.bU(y, e.u_translation), u_pitched_scale: new s.bg(y, e.u_pitched_scale) }), background: (y, e) => ({ u_opacity: new s.bg(y, e.u_opacity), u_color: new s.bQ(y, e.u_color) }), backgroundPattern: (y, e) => ({ u_opacity: new s.bg(y, e.u_opacity), u_image: new s.bP(y, e.u_image), u_pattern_tl_a: new s.bU(y, e.u_pattern_tl_a), u_pattern_br_a: new s.bU(y, e.u_pattern_br_a), u_pattern_tl_b: new s.bU(y, e.u_pattern_tl_b), u_pattern_br_b: new s.bU(y, e.u_pattern_br_b), u_texsize: new s.bU(y, e.u_texsize), u_mix: new s.bg(y, e.u_mix), u_pattern_size_a: new s.bU(y, e.u_pattern_size_a), u_pattern_size_b: new s.bU(y, e.u_pattern_size_b), u_scale_a: new s.bg(y, e.u_scale_a), u_scale_b: new s.bg(y, e.u_scale_b), u_pixel_coord_upper: new s.bU(y, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(y, e.u_pixel_coord_lower), u_tile_units_to_pixels: new s.bg(y, e.u_tile_units_to_pixels) }), terrain: (y, e) => ({ u_texture: new s.bP(y, e.u_texture), u_ele_delta: new s.bg(y, e.u_ele_delta), u_fog_matrix: new s.bR(y, e.u_fog_matrix), u_fog_color: new s.bQ(y, e.u_fog_color), u_fog_ground_blend: new s.bg(y, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.bg(y, e.u_fog_ground_blend_opacity), u_horizon_color: new s.bQ(y, e.u_horizon_color), u_horizon_fog_blend: new s.bg(y, e.u_horizon_fog_blend), u_is_globe_mode: new s.bg(y, e.u_is_globe_mode) }), terrainDepth: (y, e) => ({ u_ele_delta: new s.bg(y, e.u_ele_delta) }), terrainCoords: (y, e) => ({ u_texture: new s.bP(y, e.u_texture), u_terrain_coords_id: new s.bg(y, e.u_terrain_coords_id), u_ele_delta: new s.bg(y, e.u_ele_delta) }), projectionErrorMeasurement: (y, e) => ({ u_input: new s.bg(y, e.u_input), u_output_expected: new s.bg(y, e.u_output_expected) }), atmosphere: (y, e) => ({ u_sun_pos: new s.bT(y, e.u_sun_pos), u_atmosphere_blend: new s.bg(y, e.u_atmosphere_blend), u_globe_position: new s.bT(y, e.u_globe_position), u_globe_radius: new s.bg(y, e.u_globe_radius), u_inv_proj_matrix: new s.bR(y, e.u_inv_proj_matrix) }), sky: (y, e) => ({ u_sky_color: new s.bQ(y, e.u_sky_color), u_horizon_color: new s.bQ(y, e.u_horizon_color), u_horizon: new s.bU(y, e.u_horizon), u_horizon_normal: new s.bU(y, e.u_horizon_normal), u_sky_horizon_blend: new s.bg(y, e.u_sky_horizon_blend), u_sky_blend: new s.bg(y, e.u_sky_blend) }) };
        class _h {
          constructor(e, a, c) {
            this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), p.bufferData(p.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ql = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Fo {
          constructor(e, a, c, p) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = p, this.context = e;
            const _ = e.gl;
            this.buffer = _.createBuffer(), e.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const p = a.attributes[this.attributes[c].name];
              p !== void 0 && e.enableVertexAttribArray(p);
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let p = 0; p < this.attributes.length; p++) {
              const _ = this.attributes[p], x = a.attributes[_.name];
              x !== void 0 && e.vertexAttribPointer(x, _.components, e[Ql[_.type]], false, this.itemSize, _.offset + this.itemSize * (c || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class zr {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ic extends zr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Mc extends zr {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = false);
          }
        }
        class bh extends zr {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = false);
          }
        }
        class Ec extends zr {
          getDefault() {
            return [true, true, true, true];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Ma extends zr {
          getDefault() {
            return true;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = false);
          }
        }
        class Rc extends zr {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = false);
          }
        }
        class Ep extends zr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
          }
        }
        class Rp extends zr {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
          }
        }
        class Ap extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = false;
          }
        }
        class Dp extends zr {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class xh extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = false;
          }
        }
        class zp extends zr {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = false);
          }
        }
        class wh extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = false;
          }
        }
        class eu extends zr {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class tu extends zr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class ru extends zr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = false);
          }
        }
        class Ac extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = false;
          }
        }
        class Ea extends zr {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = false);
          }
        }
        class Hs extends zr {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = false);
          }
        }
        class as extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = false);
          }
        }
        class Gn extends zr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = false);
          }
        }
        class Ch extends zr {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Sh extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Dc extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Ra extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = false;
          }
        }
        class iu extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class nu extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Xs extends zr {
          getDefault() {
            return null;
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            Co(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = false;
          }
        }
        class ou extends zr {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
          }
        }
        class kh extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class ss extends zr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class na extends zr {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a;
          }
          getDefault() {
            return null;
          }
        }
        class Ph extends na {
          setDirty() {
            this.dirty = true;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
          }
        }
        class zc extends na {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Sr extends na {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        const Ys = "Framebuffer is not complete";
        class Fp {
          constructor(e, a, c, p, _) {
            this.context = e, this.width = a, this.height = c;
            const x = e.gl, k = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new Ph(e, k), p) this.depthAttachment = _ ? new Sr(e, k) : new zc(e, k);
            else if (_) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error(Ys);
          }
          destroy() {
            const e = this.context.gl, a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class Th {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new Ic(this), this.clearDepth = new Mc(this), this.clearStencil = new bh(this), this.colorMask = new Ec(this), this.depthMask = new Ma(this), this.stencilMask = new Rc(this), this.stencilFunc = new Ep(this), this.stencilOp = new Rp(this), this.stencilTest = new Ap(this), this.depthRange = new Dp(this), this.depthTest = new xh(this), this.depthFunc = new zp(this), this.blend = new wh(this), this.blendFunc = new eu(this), this.blendColor = new tu(this), this.blendEquation = new ru(this), this.cullFace = new Ac(this), this.cullFaceSide = new Ea(this), this.frontFace = new Hs(this), this.program = new as(this), this.activeTexture = new Gn(this), this.viewport = new Ch(this), this.bindFramebuffer = new Sh(this), this.bindRenderbuffer = new Dc(this), this.bindTexture = new Ra(this), this.bindVertexBuffer = new iu(this), this.bindElementBuffer = new nu(this), this.bindVertexArray = new Xs(this), this.pixelStoreUnpack = new ou(this), this.pixelStoreUnpackPremultiplyAlpha = new kh(this), this.pixelStoreUnpackFlipY = new ss(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Co(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const p = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : p == null ? void 0 : p.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : p == null ? void 0 : p.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const p = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = p == null ? void 0 : p.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e, a) {
            return new _h(this, e, a);
          }
          createVertexBuffer(e, a, c) {
            return new Fo(this, e, a, c);
          }
          createRenderbuffer(e, a, c) {
            const p = this.gl, _ = p.createRenderbuffer();
            return this.bindRenderbuffer.set(_), p.renderbufferStorage(p.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), _;
          }
          createFramebuffer(e, a, c, p) {
            return new Fp(this, e, a, c, p);
          }
          clear({ color: e, depth: a, stencil: c }) {
            const p = this.gl;
            let _ = 0;
            e && (_ |= p.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), a !== void 0 && (_ |= p.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(true)), c !== void 0 && (_ |= p.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), p.clear(_);
          }
          setCullFace(e) {
            e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(false);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e) {
            s.bH(e.blendFunction, ii.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return Co(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var a;
            return Co(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let oa;
        function Ih(y, e, a, c, p) {
          const _ = y.context, x = y.transform, k = _.gl, T = y.useProgram("collisionBox"), R = [];
          let z = 0, j = 0;
          for (let ue = 0; ue < c.length; ue++) {
            const ge = c[ue], we = e.getTile(ge).getBucket(a);
            if (!we) continue;
            const ye = p ? we.textCollisionBox : we.iconCollisionBox, ke = we.collisionCircleArray;
            ke.length > 0 && (R.push({ circleArray: ke, circleOffset: j, coord: ge }), z += ke.length / 4, j = z), ye && T.draw(_, k.LINES, vr.disabled, Er.disabled, y.colorModeForRenderPass(), sr.disabled, Kl(y.transform), y.style.map.terrain && y.style.map.terrain.getTerrainData(ge), x.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: true, applyTerrainMatrix: true }), a.id, ye.layoutVertexBuffer, ye.indexBuffer, ye.segments, null, y.transform.zoom, null, null, ye.collisionVertexBuffer);
          }
          if (!p || !R.length) return;
          const $ = y.useProgram("collisionCircle"), U = new s.b$();
          U.resize(4 * z), U._trim();
          let Q = 0;
          for (const ue of R) for (let ge = 0; ge < ue.circleArray.length / 4; ge++) {
            const we = 4 * ge, ye = ue.circleArray[we + 0], ke = ue.circleArray[we + 1], Ae = ue.circleArray[we + 2], be = ue.circleArray[we + 3];
            U.emplace(Q++, ye, ke, Ae, be, 0), U.emplace(Q++, ye, ke, Ae, be, 1), U.emplace(Q++, ye, ke, Ae, be, 2), U.emplace(Q++, ye, ke, Ae, be, 3);
          }
          (!oa || oa.length < 2 * z) && (oa = (function(ue) {
            const ge = 2 * ue, we = new s.c1();
            we.resize(ge), we._trim();
            for (let ye = 0; ye < ge; ye++) {
              const ke = 6 * ye;
              we.uint16[ke + 0] = 4 * ye + 0, we.uint16[ke + 1] = 4 * ye + 1, we.uint16[ke + 2] = 4 * ye + 2, we.uint16[ke + 3] = 4 * ye + 2, we.uint16[ke + 4] = 4 * ye + 3, we.uint16[ke + 5] = 4 * ye + 0;
            }
            return we;
          })(z));
          const se = _.createIndexBuffer(oa, true), le = _.createVertexBuffer(U, s.c0.members, true);
          for (const ue of R) {
            const ge = Pp(y.transform);
            $.draw(_, k.TRIANGLES, vr.disabled, Er.disabled, y.colorModeForRenderPass(), sr.disabled, ge, y.style.map.terrain && y.style.map.terrain.getTerrainData(ue.coord), null, a.id, le, se, s.aM.simpleSegment(0, 2 * ue.circleOffset, ue.circleArray.length, ue.circleArray.length / 2), null, y.transform.zoom, null, null, null);
          }
          le.destroy(), se.destroy();
        }
        const Lp = s.ag(new Float32Array(16));
        function Mh(y, e, a, c, p, _) {
          const { horizontalAlign: x, verticalAlign: k } = s.aH(y);
          return new s.P((-(x - 0.5) * e / p + c[0]) * _, (-(k - 0.5) * a / p + c[1]) * _);
        }
        function Bp(y, e, a, c, p, _) {
          const x = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let k = c.mult(_);
            a || (k = k.rotate(-p));
            const T = x.add(k);
            return Ur(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (a) {
            const k = ei(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(y), T = Math.atan(k.y / k.x) + (k.x < 0 ? Math.PI : 0);
            return y.add(c.rotate(T));
          }
          return y.add(c);
        }
        function Fc(y, e, a, c, p, _, x, k, T, R, z, j) {
          const $ = y.text.placedSymbolArray, U = y.text.dynamicLayoutVertexArray, Q = y.icon.dynamicLayoutVertexArray, se = {};
          U.clear();
          for (let le = 0; le < $.length; le++) {
            const ue = $.get(le), ge = ue.hidden || !ue.crossTileID || y.allowVerticalPlacement && !ue.placedOrientation ? null : c[ue.crossTileID];
            if (ge) {
              const we = new s.P(ue.anchorX, ue.anchorY), ye = { getElevation: j, width: p.width, height: p.height, pitchedLabelPlaneMatrix: _, pitchWithMap: a, transform: p, tileAnchorPoint: we, translation: R, unwrappedTileID: z }, ke = a ? rn(we.x, we.y, ye) : ei(we.x, we.y, ye), Ae = de(p.cameraToCenterDistance, ke.signedDistanceFromCamera);
              let be = s.ap(y.textSizeData, k, ue) * Ae / s.aB;
              a && (be *= y.tilePixelRatio / x);
              const { width: Le, height: Ke, anchor: We, textOffset: He, textBoxScale: Je } = ge, kt = Mh(We, Le, Ke, He, Je, be), St = p.getPitchedTextCorrection(we.x + R[0], we.y + R[1], z), pt = Bp(ke.point, ye, e, kt, -p.bearingInRadians, St), Nt = y.allowVerticalPlacement && ue.placedOrientation === s.ao.vertical ? Math.PI / 2 : 0;
              for (let yr = 0; yr < ue.numGlyphs; yr++) s.av(U, pt, Nt);
              T && ue.associatedIconIndex >= 0 && (se[ue.associatedIconIndex] = { shiftedAnchor: pt, angle: Nt });
            } else kn(ue.numGlyphs, U);
          }
          if (T) {
            Q.clear();
            const le = y.icon.placedSymbolArray;
            for (let ue = 0; ue < le.length; ue++) {
              const ge = le.get(ue);
              if (ge.hidden) kn(ge.numGlyphs, Q);
              else {
                const we = se[ue];
                if (we) for (let ye = 0; ye < ge.numGlyphs; ye++) s.av(Q, we.shiftedAnchor, we.angle);
                else kn(ge.numGlyphs, Q);
              }
            }
            y.icon.dynamicLayoutVertexBuffer.updateData(Q);
          }
          y.text.dynamicLayoutVertexBuffer.updateData(U);
        }
        function au(y, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : y ? "symbolSDF" : "symbolIcon";
        }
        function Ks(y, e, a, c, p, _, x, k, T, R, z, j, $) {
          const U = y.context, Q = U.gl, se = y.transform, le = k === "map", ue = T === "map", ge = k !== "viewport" && a.layout.get("symbol-placement") !== "point", we = le && !ue && !ge, ye = !a.layout.get("symbol-sort-key").isConstant();
          let ke = false;
          const Ae = y.getDepthModeForSublayer(0, vr.ReadOnly), be = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Le = [], Ke = se.getCircleRadiusCorrection();
          for (const We of c) {
            const He = e.getTile(We), Je = He.getBucket(a);
            if (!Je) continue;
            const kt = p ? Je.text : Je.icon;
            if (!kt || !kt.segments.get().length || !kt.hasVisibleVertices) continue;
            const St = kt.programConfigurations.get(a.id), pt = p || Je.sdfIcons, Nt = p ? Je.textSizeData : Je.iconSizeData, yr = ue || se.pitch !== 0, Or = y.useProgram(au(pt, p, Je), St), oi = s.an(Nt, se.zoom), ti = y.style.map.terrain && y.style.map.terrain.getTerrainData(We);
            let fi, ai, Li, si, Yr = [0, 0], mi = null;
            if (p) ai = He.glyphAtlasTexture, Li = Q.LINEAR, fi = He.glyphAtlasTexture.size, Je.iconsInText && (Yr = He.imageAtlasTexture.size, mi = He.imageAtlasTexture, si = yr || y.options.rotating || y.options.zooming || Nt.kind === "composite" || Nt.kind === "camera" ? Q.LINEAR : Q.NEAREST);
            else {
              const Ei = a.layout.get("icon-size").constantOr(0) !== 1 || Je.iconsNeedLinear;
              ai = He.imageAtlasTexture, Li = pt || y.options.rotating || y.options.zooming || Ei || yr ? Q.LINEAR : Q.NEAREST, fi = He.imageAtlasTexture.size;
            }
            const xr = s.aC(He, 1, y.transform.zoom), Yi = ci(le, y.transform, xr), Bo = s.L();
            s.aq(Bo, Yi);
            const Va = di(ue, le, y.transform, xr), sa = s.aD(se, He, _, x), Ua = se.getProjectionData({ overscaledTileID: We, applyGlobeMatrix: !$, applyTerrainMatrix: true }), ll = be && Je.hasTextData(), la = a.layout.get("icon-text-fit") !== "none" && ll && Je.hasIconData();
            if (ge) {
              const Ei = y.style.map.terrain ? (_n, li) => y.style.map.terrain.getElevation(We, _n, li) : null, Ri = a.layout.get("text-rotation-alignment") === "map";
              Zt(Je, y, p, Yi, Bo, ue, R, Ri, We.toUnwrapped(), se.width, se.height, sa, Ei);
            }
            const qa = p && be || la, Ln = ge || qa ? Lp : ue ? Yi : y.transform.clipSpaceToPixelsMatrix, ua = pt && a.paint.get(p ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Oo;
            Oo = pt ? Je.iconsInText ? Mp(Nt.kind, oi, we, ue, ge, qa, y, Ln, Va, sa, fi, Yr, Ke) : gh(Nt.kind, oi, we, ue, ge, qa, y, Ln, Va, sa, p, fi, 0, Ke) : Zs(Nt.kind, oi, we, ue, ge, qa, y, Ln, Va, sa, p, fi, Ke);
            const ca = { program: Or, buffers: kt, uniformValues: Oo, projectionData: Ua, atlasTexture: ai, atlasTextureIcon: mi, atlasInterpolation: Li, atlasInterpolationIcon: si, isSDF: pt, hasHalo: ua };
            if (ye && Je.canOverlap) {
              ke = true;
              const Ei = kt.segments.get();
              for (const Ri of Ei) Le.push({ segments: new s.aM([Ri]), sortKey: Ri.sortKey, state: ca, terrainData: ti });
            } else Le.push({ segments: kt.segments, sortKey: 0, state: ca, terrainData: ti });
          }
          ke && Le.sort(((We, He) => We.sortKey - He.sortKey));
          for (const We of Le) {
            const He = We.state;
            if (U.activeTexture.set(Q.TEXTURE0), He.atlasTexture.bind(He.atlasInterpolation, Q.CLAMP_TO_EDGE), He.atlasTextureIcon && (U.activeTexture.set(Q.TEXTURE1), He.atlasTextureIcon && He.atlasTextureIcon.bind(He.atlasInterpolationIcon, Q.CLAMP_TO_EDGE)), He.isSDF) {
              const Je = He.uniformValues;
              He.hasHalo && (Je.u_is_halo = 1, Js(He.buffers, We.segments, a, y, He.program, Ae, z, j, Je, He.projectionData, We.terrainData)), Je.u_is_halo = 0;
            }
            Js(He.buffers, We.segments, a, y, He.program, Ae, z, j, He.uniformValues, He.projectionData, We.terrainData);
          }
        }
        function Js(y, e, a, c, p, _, x, k, T, R, z) {
          const j = c.context;
          p.draw(j, j.gl.TRIANGLES, _, x, k, sr.backCCW, T, z, R, a.id, y.layoutVertexBuffer, y.indexBuffer, e, a.paint, c.transform.zoom, y.programConfigurations.get(a.id), y.dynamicLayoutVertexBuffer, y.opacityVertexBuffer);
        }
        function Lc(y, e, a, c, p) {
          const _ = y.context, x = _.gl, k = Er.disabled, T = new ii([x.ONE, x.ONE], s.bf.transparent, [true, true, true, true]), R = e.getBucket(a);
          if (!R) return;
          const z = c.key;
          let j = a.heatmapFbos.get(z);
          j || (j = Qs(_, e.tileSize, e.tileSize), a.heatmapFbos.set(z, j)), _.bindFramebuffer.set(j.framebuffer), _.viewport.set([0, 0, e.tileSize, e.tileSize]), _.clear({ color: s.bf.transparent });
          const $ = R.programConfigurations.get(a.id), U = y.useProgram("heatmap", $, !p), Q = y.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), se = y.style.map.terrain.getTerrainData(c);
          U.draw(_, x.TRIANGLES, vr.disabled, k, T, sr.disabled, dh(e, y.transform.zoom, a.paint.get("heatmap-intensity"), 1), se, Q, a.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, a.paint, y.transform.zoom, $);
        }
        function Eh(y, e, a, c, p) {
          const _ = y.context, x = _.gl, k = y.transform;
          _.setColorMode(y.colorModeForRenderPass());
          const T = el(_, e), R = a.key, z = e.heatmapFbos.get(R);
          if (!z) return;
          _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, z.colorAttachment.get()), _.activeTexture.set(x.TEXTURE1), T.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const j = k.getProjectionData({ overscaledTileID: a, applyTerrainMatrix: p, applyGlobeMatrix: !c });
          y.useProgram("heatmapTexture").draw(_, x.TRIANGLES, vr.disabled, Er.disabled, y.colorModeForRenderPass(), sr.disabled, wc(y, e, 0, 1), null, j, e.id, y.rasterBoundsBuffer, y.quadTriangleIndexBuffer, y.rasterBoundsSegments, e.paint, k.zoom), z.destroy(), e.heatmapFbos.delete(R);
        }
        function Qs(y, e, a) {
          var c, p;
          const _ = y.gl, x = _.createTexture();
          _.bindTexture(_.TEXTURE_2D, x), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.LINEAR), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.LINEAR);
          const k = (c = y.HALF_FLOAT) !== null && c !== void 0 ? c : _.UNSIGNED_BYTE, T = (p = y.RGBA16F) !== null && p !== void 0 ? p : _.RGBA;
          _.texImage2D(_.TEXTURE_2D, 0, T, e, a, 0, _.RGBA, k, null);
          const R = y.createFramebuffer(e, a, false, false);
          return R.colorAttachment.set(x), R;
        }
        function el(y, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(y, e.colorRamp, y.gl.RGBA)), e.colorRampTexture;
        }
        function tl(y, e, a, c, p) {
          if (!a || !c || !c.imageAtlas) return;
          const _ = c.imageAtlas.patternPositions;
          let x = _[a.to.toString()], k = _[a.from.toString()];
          if (!x && k && (x = k), !k && x && (k = x), !x || !k) {
            const T = p.getPaintProperty(e);
            x = _[T], k = _[T];
          }
          x && k && y.setConstantPatternPositions(x, k);
        }
        function Aa(y, e, a, c, p, _, x, k) {
          const T = y.context.gl, R = "fill-pattern", z = a.paint.get(R), j = z && z.constantOr(1), $ = a.getCrossfadeParameters();
          let U, Q, se, le, ue;
          const ge = y.transform, we = a.paint.get("fill-translate"), ye = a.paint.get("fill-translate-anchor");
          x ? (Q = j && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", U = T.LINES) : (Q = j ? "fillPattern" : "fill", U = T.TRIANGLES);
          const ke = z.constantOr(null);
          for (const Ae of c) {
            const be = e.getTile(Ae);
            if (j && !be.patternsLoaded()) continue;
            const Le = be.getBucket(a);
            if (!Le) continue;
            const Ke = Le.programConfigurations.get(a.id), We = y.useProgram(Q, Ke), He = y.style.map.terrain && y.style.map.terrain.getTerrainData(Ae);
            j && (y.context.activeTexture.set(T.TEXTURE0), be.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), Ke.updatePaintBuffers($)), tl(Ke, R, ke, be, a);
            const Je = ge.getProjectionData({ overscaledTileID: Ae, applyGlobeMatrix: !k, applyTerrainMatrix: true }), kt = s.aD(ge, be, we, ye);
            if (x) {
              le = Le.indexBuffer2, ue = Le.segments2;
              const pt = [T.drawingBufferWidth, T.drawingBufferHeight];
              se = Q === "fillOutlinePattern" && j ? Gs(y, $, be, pt, kt) : qs(pt, kt);
            } else le = Le.indexBuffer, ue = Le.segments, se = j ? Yl(y, $, be, kt) : { u_fill_translate: kt };
            const St = y.stencilModeForClipping(Ae);
            We.draw(y.context, U, p, St, _, sr.backCCW, se, He, Je, a.id, Le.layoutVertexBuffer, le, ue, a.paint, y.transform.zoom, Ke);
          }
        }
        function rl(y, e, a, c, p, _, x, k) {
          const T = y.context, R = T.gl, z = "fill-extrusion-pattern", j = a.paint.get(z), $ = j.constantOr(1), U = a.getCrossfadeParameters(), Q = a.paint.get("fill-extrusion-opacity"), se = j.constantOr(null), le = y.transform;
          for (const ue of c) {
            const ge = e.getTile(ue), we = ge.getBucket(a);
            if (!we) continue;
            const ye = y.style.map.terrain && y.style.map.terrain.getTerrainData(ue), ke = we.programConfigurations.get(a.id), Ae = y.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", ke);
            $ && (y.context.activeTexture.set(R.TEXTURE0), ge.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), ke.updatePaintBuffers(U));
            const be = le.getProjectionData({ overscaledTileID: ue, applyGlobeMatrix: !k, applyTerrainMatrix: true });
            tl(ke, z, se, ge, a);
            const Le = s.aD(le, ge, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")), Ke = a.paint.get("fill-extrusion-vertical-gradient"), We = $ ? Sp(y, Ke, Q, Le, ue, U, ge) : no(y, Ke, Q, Le);
            Ae.draw(T, T.gl.TRIANGLES, p, _, x, sr.backCCW, We, ye, be, a.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, a.paint, y.transform.zoom, ke, y.style.map.terrain && we.centroidVertexBuffer);
          }
        }
        function Bc(y, e, a, c, p, _, x, k, T) {
          var R;
          const z = y.style.projection, j = y.context, $ = y.transform, U = j.gl, Q = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`], se = y.useProgram("hillshade", null, false, Q), le = !y.options.moving;
          for (const ue of c) {
            const ge = e.getTile(ue), we = ge.fbo;
            if (!we) continue;
            const ye = z.getMeshFromTileID(j, ue.canonical, k, true, "raster"), ke = (R = y.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ue);
            j.activeTexture.set(U.TEXTURE0), U.bindTexture(U.TEXTURE_2D, we.colorAttachment.get());
            const Ae = $.getProjectionData({ overscaledTileID: ue, aligned: le, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            se.draw(j, U.TRIANGLES, _, p[ue.overscaledZ], x, sr.backCCW, Tp(y, ge, a), ke, Ae, a.id, ye.vertexBuffer, ye.indexBuffer, ye.segments);
          }
        }
        function Da(y, e, a, c, p, _, x, k, T) {
          var R;
          const z = y.style.projection, j = y.context, $ = y.transform, U = j.gl, Q = y.useProgram("colorRelief"), se = !y.options.moving;
          let le = true, ue = 0;
          for (const ge of c) {
            const we = e.getTile(ge), ye = we.dem;
            if (le) {
              const We = U.getParameter(U.MAX_TEXTURE_SIZE), { elevationTexture: He, colorTexture: Je } = a.getColorRampTextures(j, We, ye.getUnpackVector());
              j.activeTexture.set(U.TEXTURE1), He.bind(U.NEAREST, U.CLAMP_TO_EDGE), j.activeTexture.set(U.TEXTURE4), Je.bind(U.LINEAR, U.CLAMP_TO_EDGE), le = false, ue = He.size[0];
            }
            if (!ye || !ye.data) continue;
            const ke = ye.stride, Ae = ye.getPixels();
            if (j.activeTexture.set(U.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(false), we.demTexture = we.demTexture || y.getTileTexture(ke), we.demTexture) {
              const We = we.demTexture;
              We.update(Ae, { premultiply: false }), We.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            } else we.demTexture = new s.T(j, Ae, U.RGBA, { premultiply: false }), we.demTexture.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            const be = z.getMeshFromTileID(j, ge.canonical, k, true, "raster"), Le = (R = y.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ge), Ke = $.getProjectionData({ overscaledTileID: ge, aligned: se, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            Q.draw(j, U.TRIANGLES, _, p[ge.overscaledZ], x, sr.backCCW, fh(a, we.dem, ue), Le, Ke, a.id, be.vertexBuffer, be.indexBuffer, be.segments);
          }
        }
        const Oc = [new s.P(0, 0), new s.P(s.$, 0), new s.P(s.$, s.$), new s.P(0, s.$)];
        function il(y, e, a, c, p, _, x, k, T = false, R = false) {
          const z = c[c.length - 1].overscaledZ, j = y.context, $ = j.gl, U = y.useProgram("raster"), Q = y.transform, se = y.style.projection, le = y.colorModeForRenderPass(), ue = !y.options.moving;
          for (const ge of c) {
            const we = y.getDepthModeForSublayer(ge.overscaledZ - z, a.paint.get("raster-opacity") === 1 ? vr.ReadWrite : vr.ReadOnly, $.LESS), ye = e.getTile(ge);
            ye.registerFadeDuration(a.paint.get("raster-fade-duration"));
            const ke = e.findLoadedParent(ge, 0), Ae = e.findLoadedSibling(ge), be = su(ye, ke || Ae || null, e, a, y.transform, y.style.map.terrain);
            let Le, Ke;
            const We = a.paint.get("raster-resampling") === "nearest" ? $.NEAREST : $.LINEAR;
            j.activeTexture.set($.TEXTURE0), ye.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), j.activeTexture.set($.TEXTURE1), ke ? (ke.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), Le = Math.pow(2, ke.tileID.overscaledZ - ye.tileID.overscaledZ), Ke = [ye.tileID.canonical.x * Le % 1, ye.tileID.canonical.y * Le % 1]) : ye.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), ye.texture.useMipmap && j.extTextureFilterAnisotropic && y.transform.pitch > 20 && $.texParameterf($.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const He = y.style.map.terrain && y.style.map.terrain.getTerrainData(ge), Je = Q.getProjectionData({ overscaledTileID: ge, aligned: ue, applyGlobeMatrix: !R, applyTerrainMatrix: true }), kt = Ws(Ke || [0, 0], Le || 1, be, a, k), St = se.getMeshFromTileID(j, ge.canonical, _, x, "raster");
            U.draw(j, $.TRIANGLES, we, p ? p[ge.overscaledZ] : Er.disabled, le, T ? sr.frontCCW : sr.backCCW, kt, He, Je, a.id, St.vertexBuffer, St.indexBuffer, St.segments);
          }
        }
        function su(y, e, a, c, p, _) {
          const x = c.paint.get("raster-fade-duration");
          if (!_ && x > 0) {
            const k = D.now(), T = (k - y.timeAdded) / x, R = e ? (k - e.timeAdded) / x : -1, z = a.getSource(), j = xt(p, { tileSize: z.tileSize, roundZoom: z.roundZoom }), $ = !e || Math.abs(e.tileID.overscaledZ - j) > Math.abs(y.tileID.overscaledZ - j), U = $ && y.refreshedUponExpiration ? 1 : s.ah($ ? T : 1 - R, 0, 1);
            return y.refreshedUponExpiration && T >= 1 && (y.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - U } : { opacity: U, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const $c = new s.bf(1, 0, 0, 1), Rh = new s.bf(0, 1, 0, 1), Ah = new s.bf(0, 0, 1, 1), lu = new s.bf(1, 0, 1, 1), jc = new s.bf(0, 1, 1, 1);
        function Dh(y, e, a, c) {
          hi(y, 0, e + a / 2, y.transform.width, a, c);
        }
        function Nc(y, e, a, c) {
          hi(y, e - a / 2, 0, a, y.transform.height, c);
        }
        function hi(y, e, a, c, p, _) {
          const x = y.context, k = x.gl;
          k.enable(k.SCISSOR_TEST), k.scissor(e * y.pixelRatio, a * y.pixelRatio, c * y.pixelRatio, p * y.pixelRatio), x.clear({ color: _ }), k.disable(k.SCISSOR_TEST);
        }
        function za(y, e, a) {
          const c = y.context, p = c.gl, _ = y.useProgram("debug"), x = vr.disabled, k = Er.disabled, T = y.colorModeForRenderPass(), R = "$debug", z = y.style.map.terrain && y.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(p.TEXTURE0);
          const j = e.getTileByID(a.key).latestRawTileData, $ = Math.floor((j && j.byteLength || 0) / 1024), U = e.getTile(a).tileSize, Q = 512 / Math.min(U, 512) * (a.overscaledZ / y.transform.zoom) * 0.5;
          let se = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (se += ` => ${a.overscaledZ}`), (function(ue, ge) {
            ue.initDebugOverlayCanvas();
            const we = ue.debugOverlayCanvas, ye = ue.context.gl, ke = ue.debugOverlayCanvas.getContext("2d");
            ke.clearRect(0, 0, we.width, we.height), ke.shadowColor = "white", ke.shadowBlur = 2, ke.lineWidth = 1.5, ke.strokeStyle = "white", ke.textBaseline = "top", ke.font = "bold 36px Open Sans, sans-serif", ke.fillText(ge, 5, 5), ke.strokeText(ge, 5, 5), ue.debugOverlayTexture.update(we), ue.debugOverlayTexture.bind(ye.LINEAR, ye.CLAMP_TO_EDGE);
          })(y, `${se} ${$}kB`);
          const le = y.transform.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: true, applyTerrainMatrix: true });
          _.draw(c, p.TRIANGLES, x, k, ii.alphaBlended, sr.disabled, Ta(s.bf.transparent, Q), null, le, R, y.debugBuffer, y.quadTriangleIndexBuffer, y.debugSegments), _.draw(c, p.LINE_STRIP, x, k, T, sr.disabled, Ta(s.bf.red), z, le, R, y.debugBuffer, y.tileBorderIndexBuffer, y.debugSegments);
        }
        function Fn(y, e, a, c) {
          const { isRenderingGlobe: p } = c, _ = y.context, x = _.gl, k = y.transform, T = y.colorModeForRenderPass(), R = y.getDepthModeFor3D(), z = y.useProgram("terrain");
          _.bindFramebuffer.set(null), _.viewport.set([0, 0, y.width, y.height]);
          for (const j of a) {
            const $ = e.getTerrainMesh(j.tileID), U = y.renderToTexture.getTexture(j), Q = e.getTerrainData(j.tileID);
            _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, U.texture);
            const se = e.getMeshFrameDelta(k.zoom), le = k.calculateFogMatrix(j.tileID.toUnwrapped()), ue = Hl(se, le, y.style.sky, k.pitch, p), ge = k.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            z.draw(_, x.TRIANGLES, R, Er.disabled, T, sr.backCCW, ue, Q, ge, "terrain", $.vertexBuffer, $.indexBuffer, $.segments);
          }
        }
        function uu(y, e) {
          if (!e.mesh) {
            const a = new s.aL();
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new s.aN();
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new Ao(y.createVertexBuffer(a, wo.members), y.createIndexBuffer(c), s.aM.simpleSegment(0, 0, a.length, c.length));
          }
          return e.mesh;
        }
        class cu {
          constructor(e, a) {
            this.context = new Th(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: s.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = or.maxUnderzooming + or.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ia();
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const p of this.style._order) this.style._layers[p].resize();
          }
          setup() {
            const e = this.context, a = new s.aL();
            a.emplaceBack(0, 0), a.emplaceBack(s.$, 0), a.emplaceBack(0, s.$), a.emplaceBack(s.$, s.$), this.tileExtentBuffer = e.createVertexBuffer(a, wo.members), this.tileExtentSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const c = new s.aL();
            c.emplaceBack(0, 0), c.emplaceBack(s.$, 0), c.emplaceBack(0, s.$), c.emplaceBack(s.$, s.$), this.debugBuffer = e.createVertexBuffer(c, wo.members), this.debugSegments = s.aM.simpleSegment(0, 0, 4, 5);
            const p = new s.c6();
            p.emplaceBack(0, 0, 0, 0), p.emplaceBack(s.$, 0, s.$, 0), p.emplaceBack(0, s.$, 0, s.$), p.emplaceBack(s.$, s.$, s.$, s.$), this.rasterBoundsBuffer = e.createVertexBuffer(p, wp.members), this.rasterBoundsSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const _ = new s.aL();
            _.emplaceBack(0, 0), _.emplaceBack(s.$, 0), _.emplaceBack(0, s.$), _.emplaceBack(s.$, s.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(_, wo.members), this.rasterBoundsSegmentsPosOnly = s.aM.simpleSegment(0, 0, 4, 5);
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(x, wo.members), this.viewportSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const k = new s.c7();
            k.emplaceBack(0), k.emplaceBack(1), k.emplaceBack(3), k.emplaceBack(2), k.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(k);
            const T = new s.aN();
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const R = this.context.gl;
            this.stencilClearMode = new Er({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new Ao(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = s.L();
            s.bY(c, 0, this.width, this.height, 0, 0, 1), s.N(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const p = { mainMatrix: c, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: c };
            this.useProgram("clippingMask", null, true).draw(e, a.TRIANGLES, vr.disabled, this.stencilClearMode, ii.disabled, sr.disabled, null, null, p, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const p = this.context;
            p.setColorMode(ii.disabled), p.setDepthMode(vr.disabled);
            const _ = {};
            for (const x of a) _[x.key] = this.nextStencilID++;
            this._renderTileMasks(_, a, c, true), this._renderTileMasks(_, a, c, false), this._tileClippingMaskIDs = _;
          }
          _renderTileMasks(e, a, c, p) {
            const _ = this.context, x = _.gl, k = this.style.projection, T = this.transform, R = this.useProgram("clippingMask");
            for (const z of a) {
              const j = e[z.key], $ = this.style.map.terrain && this.style.map.terrain.getTerrainData(z), U = k.getMeshFromTileID(this.context, z.canonical, p, true, "stencil"), Q = T.getProjectionData({ overscaledTileID: z, applyGlobeMatrix: !c, applyTerrainMatrix: true });
              R.draw(_, x.TRIANGLES, vr.disabled, new Er({ func: x.ALWAYS, mask: 0 }, j, 255, x.KEEP, x.KEEP, x.REPLACE), ii.disabled, c ? sr.disabled : sr.backCCW, null, $, Q, "$clipping", U.vertexBuffer, U.indexBuffer, U.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, a = e.gl, c = this.style.projection, p = this.transform, _ = this.useProgram("depth"), x = this.getDepthModeFor3D(), k = Te(p, { tileSize: p.tileSize });
            for (const T of k) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(T), z = c.getMeshFromTileID(this.context, T.canonical, true, true, "raster"), j = p.getProjectionData({ overscaledTileID: T, applyGlobeMatrix: true, applyTerrainMatrix: true });
              _.draw(e, a.TRIANGLES, x, Er.disabled, ii.disabled, sr.backCCW, null, R, j, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, a = this.context.gl;
            return new Er({ func: a.NOTEQUAL, mask: 255 }, e, 255, a.KEEP, a.KEEP, a.REPLACE);
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Er({ func: a.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - p + 1;
            if (_ > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + _ > 256 && this.clearStencil();
              const x = {};
              for (let k = 0; k < _; k++) x[k + p] = new Er({ func: a.GEQUAL, mask: 255 }, k + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += _, [x, c];
            }
            return [{ [p]: Er.disabled }, c];
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - p + 1;
            if (this.clearStencil(), _ > 1) {
              const x = {}, k = {};
              for (let T = 0; T < _; T++) x[T + p] = new Er({ func: a.GREATER, mask: 255 }, _ + 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE), k[T + p] = new Er({ func: a.GREATER, mask: 255 }, 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * _ + 1, [x, k, c];
            }
            return this.nextStencilID = 3, [{ [p]: new Er({ func: a.GREATER, mask: 255 }, 2, 255, a.KEEP, a.KEEP, a.REPLACE) }, { [p]: new Er({ func: a.GREATER, mask: 255 }, 1, 255, a.KEEP, a.KEEP, a.REPLACE) }, c];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new ii([e.CONSTANT_COLOR, e.ONE], new s.bf(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? ii.unblended : ii.alphaBlended;
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return vr.disabled;
            const p = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new vr(c || this.context.gl.LEQUAL, a, [p, p]);
          }
          getDepthModeFor3D() {
            return new vr(this.context.gl.LEQUAL, vr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, a) {
            var c, p;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(D.now()), this.imageManager.beginFrame();
            const _ = this.style._order, x = this.style.sourceCaches, k = {}, T = {}, R = {}, z = { isRenderingToTexture: false, isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0 };
            for (const $ in x) {
              const U = x[$];
              U.used && U.prepare(this.context), k[$] = U.getVisibleCoordinates(false), T[$] = k[$].slice().reverse(), R[$] = U.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let $ = 0; $ < _.length; $++) if (this.style._layers[_[$]].is3D()) {
              this.opaquePassCutoff = $;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const $ of _) {
              const U = this.style._layers[$];
              if (!U.hasOffscreenPass() || U.isHidden(this.transform.zoom)) continue;
              const Q = T[U.source];
              (U.type === "custom" || Q.length) && this.renderLayer(this, x[U.source], U, Q, z);
            }
            if ((p = this.style.projection) === null || p === void 0 || p.updateGPUdependent({ context: this.context, useProgram: ($) => this.useProgram($) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: a.showOverdrawInspector ? s.bf.black : s.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function($, U) {
              const Q = $.context, se = Q.gl, le = ((Ae, be, Le) => {
                const Ke = Math.cos(be.rollInRadians), We = Math.sin(be.rollInRadians), He = Pe(be), Je = be.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: Ae.properties.get("sky-color"), u_horizon_color: Ae.properties.get("horizon-color"), u_horizon: [(be.width / 2 - He * We) * Le, (be.height / 2 + He * Ke) * Le], u_horizon_normal: [-We, Ke], u_sky_horizon_blend: Ae.properties.get("sky-horizon-blend") * be.height / 2 * Le, u_sky_blend: Je };
              })(U, $.style.map.transform, $.pixelRatio), ue = new vr(se.LEQUAL, vr.ReadWrite, [0, 1]), ge = Er.disabled, we = $.colorModeForRenderPass(), ye = $.useProgram("sky"), ke = uu(Q, U);
              ye.draw(Q, se.TRIANGLES, ue, ge, we, sr.disabled, le, null, void 0, "sky", ke.vertexBuffer, ke.indexBuffer, ke.segments);
            })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const $ = this.style._layers[_[this.currentLayer]], U = x[$.source], Q = k[$.source];
              this._renderTileClippingMasks($, Q, false), this.renderLayer(this, U, $, Q, z);
            }
            this.renderPass = "translucent";
            let j = false;
            for (this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
              const $ = this.style._layers[_[this.currentLayer]], U = x[$.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer($, z)) continue;
              this.opaquePassEnabledForLayer() || j || (j = true, z.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Q = ($.type === "symbol" ? R : T)[$.source];
              this._renderTileClippingMasks($, k[$.source], !!this.renderToTexture), this.renderLayer(this, U, $, Q, z);
            }
            if (z.isRenderingGlobe && (function($, U, Q) {
              const se = $.context, le = se.gl, ue = $.useProgram("atmosphere"), ge = new vr(le.LEQUAL, vr.ReadOnly, [0, 1]), we = $.transform, ye = (function(Je, kt) {
                const St = Je.properties.get("position"), pt = [-St.x, -St.y, -St.z], Nt = s.ag(new Float64Array(16));
                return Je.properties.get("anchor") === "map" && (s.b6(Nt, Nt, kt.rollInRadians), s.b7(Nt, Nt, -kt.pitchInRadians), s.b6(Nt, Nt, kt.bearingInRadians), s.b7(Nt, Nt, kt.center.lat * Math.PI / 180), s.bz(Nt, Nt, -kt.center.lng * Math.PI / 180)), s.c5(pt, pt, Nt), pt;
              })(Q, $.transform), ke = we.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), Ae = U.properties.get("atmosphere-blend") * ke.projectionTransition;
              if (Ae === 0) return;
              const be = ns(we.worldSize, we.center.lat), Le = we.inverseProjectionMatrix, Ke = new Float64Array(4);
              Ke[3] = 1, s.aw(Ke, Ke, we.modelViewProjectionMatrix), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1, s.aw(Ke, Ke, Le), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1;
              const We = /* @__PURE__ */ ((Je, kt, St, pt, Nt) => ({ u_sun_pos: Je, u_atmosphere_blend: kt, u_globe_position: St, u_globe_radius: pt, u_inv_proj_matrix: Nt }))(ye, Ae, [Ke[0], Ke[1], Ke[2]], be, Le), He = uu(se, U);
              ue.draw(se, le.TRIANGLES, ge, Er.disabled, ii.alphaBlended, sr.disabled, We, null, null, "atmosphere", He.vertexBuffer, He.indexBuffer, He.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const $ = (function(U, Q) {
                let se = null;
                const le = Object.values(U._layers).flatMap(((ye) => ye.source && !ye.isHidden(Q) ? [U.sourceCaches[ye.source]] : [])), ue = le.filter(((ye) => ye.getSource().type === "vector")), ge = le.filter(((ye) => ye.getSource().type !== "vector")), we = (ye) => {
                  (!se || se.getSource().maxzoom < ye.getSource().maxzoom) && (se = ye);
                };
                return ue.forEach(((ye) => we(ye))), se || ge.forEach(((ye) => we(ye))), se;
              })(this.style, this.transform.zoom);
              $ && (function(U, Q, se) {
                for (let le = 0; le < se.length; le++) za(U, Q, se[le]);
              })(this, $, $.getVisibleCoordinates());
            }
            this.options.showPadding && (function($) {
              const U = $.transform.padding;
              Dh($, $.transform.height - (U.top || 0), 3, $c), Dh($, U.bottom || 0, 3, Rh), Nc($, U.left || 0, 3, Ah), Nc($, $.transform.width - (U.right || 0), 3, lu);
              const Q = $.transform.centerPoint;
              (function(se, le, ue, ge) {
                hi(se, le - 1, ue - 10, 2, 20, ge), hi(se, le - 10, ue - 1, 20, 2, ge);
              })($, Q.x, $.transform.height - Q.y, jc);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
            let p = this.terrainFacilitator.dirty;
            p || (p = e ? !s.c8(a, c) : !s.c9(a, c)), p || (p = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), p && (s.ca(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(_, x) {
              const k = _.context, T = k.gl, R = _.transform, z = ii.unblended, j = new vr(T.LEQUAL, vr.ReadWrite, [0, 1]), $ = x.sourceCache.getRenderableTiles(), U = _.useProgram("terrainDepth");
              k.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 });
              for (const Q of $) {
                const se = x.getTerrainMesh(Q.tileID), le = x.getTerrainData(Q.tileID), ue = R.getProjectionData({ overscaledTileID: Q.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), ge = { u_ele_delta: x.getMeshFrameDelta(R.zoom) };
                U.draw(k, T.TRIANGLES, j, Er.disabled, z, sr.backCCW, ge, le, ue, "terrain", se.vertexBuffer, se.indexBuffer, se.segments);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain), (function(_, x) {
              const k = _.context, T = k.gl, R = _.transform, z = ii.unblended, j = new vr(T.LEQUAL, vr.ReadWrite, [0, 1]), $ = x.getCoordsTexture(), U = x.sourceCache.getRenderableTiles(), Q = _.useProgram("terrainCoords");
              k.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 }), x.coordsIndex = [];
              for (const se of U) {
                const le = x.getTerrainMesh(se.tileID), ue = x.getTerrainData(se.tileID);
                k.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, $.texture);
                const ge = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(R.zoom) }, we = R.getProjectionData({ overscaledTileID: se.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                Q.draw(k, T.TRIANGLES, j, Er.disabled, z, sr.backCCW, ge, ue, we, "terrain", le.vertexBuffer, le.indexBuffer, le.segments), x.coordsIndex.push(se.tileID.key);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, a, c, p, _) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (p || []).length) && (this.id = c.id, s.cb(c) ? (function(x, k, T, R, z, j) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: $ } = j, U = Er.disabled, Q = x.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(se, le, ue, ge, we, ye, ke, Ae, be) {
                const Le = le.transform, Ke = le.style.map.terrain, We = we === "map", He = ye === "map";
                for (const Je of se) {
                  const kt = ge.getTile(Je), St = kt.getBucket(ue);
                  if (!St || !St.text || !St.text.segments.get().length) continue;
                  const pt = s.an(St.textSizeData, Le.zoom), Nt = s.aC(kt, 1, le.transform.zoom), yr = ci(We, le.transform, Nt), Or = ue.layout.get("icon-text-fit") !== "none" && St.hasIconData();
                  if (pt) {
                    const oi = Math.pow(2, Le.zoom - kt.tileID.overscaledZ), ti = Ke ? (fi, ai) => Ke.getElevation(Je, fi, ai) : null;
                    Fc(St, We, He, be, Le, yr, oi, pt, Or, s.aD(Le, kt, ke, Ae), Je.toUnwrapped(), ti);
                  }
                }
              })(R, x, T, k, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), z), T.paint.get("icon-opacity").constantOr(1) !== 0 && Ks(x, k, T, R, false, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), U, Q, $), T.paint.get("text-opacity").constantOr(1) !== 0 && Ks(x, k, T, R, true, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), U, Q, $), k.map.showCollisionBoxes && (Ih(x, k, T, R, true), Ih(x, k, T, R, false));
            })(e, a, c, p, this.style.placement.variableOffsets, _) : s.cc(c) ? (function(x, k, T, R, z) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = z, $ = T.paint.get("circle-opacity"), U = T.paint.get("circle-stroke-width"), Q = T.paint.get("circle-stroke-opacity"), se = !T.layout.get("circle-sort-key").isConstant();
              if ($.constantOr(1) === 0 && (U.constantOr(1) === 0 || Q.constantOr(1) === 0)) return;
              const le = x.context, ue = le.gl, ge = x.transform, we = x.getDepthModeForSublayer(0, vr.ReadOnly), ye = Er.disabled, ke = x.colorModeForRenderPass(), Ae = [], be = ge.getCircleRadiusCorrection();
              for (let Le = 0; Le < R.length; Le++) {
                const Ke = R[Le], We = k.getTile(Ke), He = We.getBucket(T);
                if (!He) continue;
                const Je = T.paint.get("circle-translate"), kt = T.paint.get("circle-translate-anchor"), St = s.aD(ge, We, Je, kt), pt = He.programConfigurations.get(T.id), Nt = x.useProgram("circle", pt), yr = He.layoutVertexBuffer, Or = He.indexBuffer, oi = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ke), ti = { programConfiguration: pt, program: Nt, layoutVertexBuffer: yr, indexBuffer: Or, uniformValues: kp(x, We, T, St, be), terrainData: oi, projectionData: ge.getProjectionData({ overscaledTileID: Ke, applyGlobeMatrix: !j, applyTerrainMatrix: true }) };
                if (se) {
                  const fi = He.segments.get();
                  for (const ai of fi) Ae.push({ segments: new s.aM([ai]), sortKey: ai.sortKey, state: ti });
                } else Ae.push({ segments: He.segments, sortKey: 0, state: ti });
              }
              se && Ae.sort(((Le, Ke) => Le.sortKey - Ke.sortKey));
              for (const Le of Ae) {
                const { programConfiguration: Ke, program: We, layoutVertexBuffer: He, indexBuffer: Je, uniformValues: kt, terrainData: St, projectionData: pt } = Le.state;
                We.draw(le, ue.TRIANGLES, we, ye, ke, sr.backCCW, kt, St, pt, T.id, He, Je, Le.segments, T.paint, x.transform.zoom, Ke);
              }
            })(e, a, c, p, _) : s.cd(c) ? (function(x, k, T, R, z) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const j = x.context, { isRenderingToTexture: $, isRenderingGlobe: U } = z;
              if (x.style.map.terrain) {
                for (const Q of R) {
                  const se = k.getTile(Q);
                  k.hasRenderableParent(Q) || (x.renderPass === "offscreen" ? Lc(x, se, T, Q, U) : x.renderPass === "translucent" && Eh(x, T, Q, $, U));
                }
                j.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(Q, se, le, ue) {
                const ge = Q.context, we = ge.gl, ye = Q.transform, ke = Er.disabled, Ae = new ii([we.ONE, we.ONE], s.bf.transparent, [true, true, true, true]);
                (function(be, Le, Ke) {
                  const We = be.gl;
                  be.activeTexture.set(We.TEXTURE1), be.viewport.set([0, 0, Le.width / 4, Le.height / 4]);
                  let He = Ke.heatmapFbos.get(s.c2);
                  He ? (We.bindTexture(We.TEXTURE_2D, He.colorAttachment.get()), be.bindFramebuffer.set(He.framebuffer)) : (He = Qs(be, Le.width / 4, Le.height / 4), Ke.heatmapFbos.set(s.c2, He));
                })(ge, Q, le), ge.clear({ color: s.bf.transparent });
                for (let be = 0; be < ue.length; be++) {
                  const Le = ue[be];
                  if (se.hasRenderableParent(Le)) continue;
                  const Ke = se.getTile(Le), We = Ke.getBucket(le);
                  if (!We) continue;
                  const He = We.programConfigurations.get(le.id), Je = Q.useProgram("heatmap", He), kt = ye.getProjectionData({ overscaledTileID: Le, applyGlobeMatrix: true, applyTerrainMatrix: false }), St = ye.getCircleRadiusCorrection();
                  Je.draw(ge, we.TRIANGLES, vr.disabled, ke, Ae, sr.backCCW, dh(Ke, ye.zoom, le.paint.get("heatmap-intensity"), St), null, kt, le.id, We.layoutVertexBuffer, We.indexBuffer, We.segments, le.paint, ye.zoom, He);
                }
                ge.viewport.set([0, 0, Q.width, Q.height]);
              })(x, k, T, R) : x.renderPass === "translucent" && (function(Q, se) {
                const le = Q.context, ue = le.gl;
                le.setColorMode(Q.colorModeForRenderPass());
                const ge = se.heatmapFbos.get(s.c2);
                ge && (le.activeTexture.set(ue.TEXTURE0), ue.bindTexture(ue.TEXTURE_2D, ge.colorAttachment.get()), le.activeTexture.set(ue.TEXTURE1), el(le, se).bind(ue.LINEAR, ue.CLAMP_TO_EDGE), Q.useProgram("heatmapTexture").draw(le, ue.TRIANGLES, vr.disabled, Er.disabled, Q.colorModeForRenderPass(), sr.disabled, wc(Q, se, 0, 1), null, null, se.id, Q.viewportBuffer, Q.quadTriangleIndexBuffer, Q.viewportSegments, se.paint, Q.transform.zoom));
              })(x, T);
            })(e, a, c, p, _) : s.ce(c) ? (function(x, k, T, R, z) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = z, $ = T.paint.get("line-opacity"), U = T.paint.get("line-width");
              if ($.constantOr(1) === 0 || U.constantOr(1) === 0) return;
              const Q = x.getDepthModeForSublayer(0, vr.ReadOnly), se = x.colorModeForRenderPass(), le = T.paint.get("line-dasharray"), ue = le.constantOr(1), ge = T.paint.get("line-pattern"), we = ge.constantOr(1), ye = T.paint.get("line-gradient"), ke = T.getCrossfadeParameters(), Ae = we ? "linePattern" : ue ? "lineSDF" : ye ? "lineGradient" : "line", be = x.context, Le = be.gl, Ke = x.transform;
              let We = true;
              for (const He of R) {
                const Je = k.getTile(He);
                if (we && !Je.patternsLoaded()) continue;
                const kt = Je.getBucket(T);
                if (!kt) continue;
                const St = kt.programConfigurations.get(T.id), pt = x.context.program.get(), Nt = x.useProgram(Ae, St), yr = We || Nt.program !== pt, Or = x.style.map.terrain && x.style.map.terrain.getTerrainData(He), oi = ge.constantOr(null), ti = le && le.constantOr(null);
                if (oi && Je.imageAtlas) {
                  const Yr = Je.imageAtlas, mi = Yr.patternPositions[oi.to.toString()], xr = Yr.patternPositions[oi.from.toString()];
                  mi && xr && St.setConstantPatternPositions(mi, xr);
                } else if (ti) {
                  const Yr = T.layout.get("line-cap") === "round", mi = x.lineAtlas.getDash(ti.to, Yr), xr = x.lineAtlas.getDash(ti.from, Yr);
                  St.setConstantDashPositions(mi, xr);
                }
                const fi = Ke.getProjectionData({ overscaledTileID: He, applyGlobeMatrix: !j, applyTerrainMatrix: true }), ai = Ke.getPixelScale(), Li = we ? mh(x, Je, T, ai, ke) : ue ? Ia(x, Je, T, ai, ke) : ye ? ph(x, Je, T, ai, kt.lineClipsArray.length) : Jl(x, Je, T, ai);
                if (we) be.activeTexture.set(Le.TEXTURE0), Je.imageAtlasTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE), St.updatePaintBuffers(ke);
                else if (ue) (yr || x.lineAtlas.dirty) && (be.activeTexture.set(Le.TEXTURE0), x.lineAtlas.bind(be)), St.updatePaintBuffers(ke);
                else if (ye) {
                  const Yr = kt.gradients[T.id];
                  let mi = Yr.texture;
                  if (T.gradientVersion !== Yr.version) {
                    let xr = 256;
                    if (T.stepInterpolant) {
                      const Yi = k.getSource().maxzoom, Bo = He.canonical.z === Yi ? Math.ceil(1 << x.transform.maxZoom - He.canonical.z) : 1;
                      xr = s.ah(s.c3(kt.maxLineLength / s.$ * 1024 * Bo), 256, be.maxTextureSize);
                    }
                    Yr.gradient = s.c4({ expression: T.gradientExpression(), evaluationKey: "lineProgress", resolution: xr, image: Yr.gradient || void 0, clips: kt.lineClipsArray }), Yr.texture ? Yr.texture.update(Yr.gradient) : Yr.texture = new s.T(be, Yr.gradient, Le.RGBA), Yr.version = T.gradientVersion, mi = Yr.texture;
                  }
                  be.activeTexture.set(Le.TEXTURE0), mi.bind(T.stepInterpolant ? Le.NEAREST : Le.LINEAR, Le.CLAMP_TO_EDGE);
                }
                const si = x.stencilModeForClipping(He);
                Nt.draw(be, Le.TRIANGLES, Q, si, se, sr.disabled, Li, Or, fi, T.id, kt.layoutVertexBuffer, kt.indexBuffer, kt.segments, T.paint, x.transform.zoom, St, kt.layoutVertexBuffer2), We = false;
              }
            })(e, a, c, p, _) : s.cf(c) ? (function(x, k, T, R, z) {
              const j = T.paint.get("fill-color"), $ = T.paint.get("fill-opacity");
              if ($.constantOr(1) === 0) return;
              const { isRenderingToTexture: U } = z, Q = x.colorModeForRenderPass(), se = T.paint.get("fill-pattern"), le = x.opaquePassEnabledForLayer() && !se.constantOr(1) && j.constantOr(s.bf.transparent).a === 1 && $.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === le) {
                const ue = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? vr.ReadWrite : vr.ReadOnly);
                Aa(x, k, T, R, ue, Q, false, U);
              }
              if (x.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const ue = x.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, vr.ReadOnly);
                Aa(x, k, T, R, ue, Q, true, U);
              }
            })(e, a, c, p, _) : s.cg(c) ? (function(x, k, T, R, z) {
              const j = T.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: $ } = z;
              if (x.renderPass === "translucent") {
                const U = new vr(x.context.gl.LEQUAL, vr.ReadWrite, x.depthRangeFor3D);
                if (j !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) rl(x, k, T, R, U, Er.disabled, ii.disabled, $), rl(x, k, T, R, U, x.stencilModeFor3D(), x.colorModeForRenderPass(), $);
                else {
                  const Q = x.colorModeForRenderPass();
                  rl(x, k, T, R, U, Er.disabled, Q, $);
                }
              }
            })(e, a, c, p, _) : s.ch(c) ? (function(x, k, T, R, z) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = z, $ = x.context, U = x.style.projection.useSubdivision, Q = x.getDepthModeForSublayer(0, vr.ReadOnly), se = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(le, ue, ge, we, ye, ke, Ae) {
                const be = le.context, Le = be.gl;
                for (const Ke of ge) {
                  const We = ue.getTile(Ke), He = We.dem;
                  if (!He || !He.data || !We.needsHillshadePrepare) continue;
                  const Je = He.dim, kt = He.stride, St = He.getPixels();
                  if (be.activeTexture.set(Le.TEXTURE1), be.pixelStoreUnpackPremultiplyAlpha.set(false), We.demTexture = We.demTexture || le.getTileTexture(kt), We.demTexture) {
                    const Nt = We.demTexture;
                    Nt.update(St, { premultiply: false }), Nt.bind(Le.NEAREST, Le.CLAMP_TO_EDGE);
                  } else We.demTexture = new s.T(be, St, Le.RGBA, { premultiply: false }), We.demTexture.bind(Le.NEAREST, Le.CLAMP_TO_EDGE);
                  be.activeTexture.set(Le.TEXTURE0);
                  let pt = We.fbo;
                  if (!pt) {
                    const Nt = new s.T(be, { width: Je, height: Je, data: null }, Le.RGBA);
                    Nt.bind(Le.LINEAR, Le.CLAMP_TO_EDGE), pt = We.fbo = be.createFramebuffer(Je, Je, true, false), pt.colorAttachment.set(Nt.texture);
                  }
                  be.bindFramebuffer.set(pt.framebuffer), be.viewport.set([0, 0, Je, Je]), le.useProgram("hillshadePrepare").draw(be, Le.TRIANGLES, ye, ke, Ae, sr.disabled, hh(We.tileID, He), null, null, we.id, le.rasterBoundsBuffer, le.quadTriangleIndexBuffer, le.rasterBoundsSegments), We.needsHillshadePrepare = false;
                }
              })(x, k, R, T, Q, Er.disabled, se), $.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (U) {
                const [le, ue, ge] = x.stencilConfigForOverlapTwoPass(R);
                Bc(x, k, T, ge, le, Q, se, false, j), Bc(x, k, T, ge, ue, Q, se, true, j);
              } else {
                const [le, ue] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                Bc(x, k, T, ue, le, Q, se, false, j);
              }
            })(e, a, c, p, _) : s.ci(c) ? (function(x, k, T, R, z) {
              if (x.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: j } = z, $ = x.style.projection.useSubdivision, U = x.getDepthModeForSublayer(0, vr.ReadOnly), Q = x.colorModeForRenderPass();
              if ($) {
                const [se, le, ue] = x.stencilConfigForOverlapTwoPass(R);
                Da(x, k, T, ue, se, U, Q, false, j), Da(x, k, T, ue, le, U, Q, true, j);
              } else {
                const [se, le] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                Da(x, k, T, le, se, U, Q, false, j);
              }
            })(e, a, c, p, _) : s.cj(c) ? (function(x, k, T, R, z) {
              if (x.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: j } = z, $ = k.getSource(), U = x.style.projection.useSubdivision;
              if ($ instanceof nt) il(x, k, T, R, null, false, false, $.tileCoords, $.flippedWindingOrder, j);
              else if (U) {
                const [Q, se, le] = x.stencilConfigForOverlapTwoPass(R);
                il(x, k, T, le, Q, false, true, Oc, false, j), il(x, k, T, le, se, true, true, Oc, false, j);
              } else {
                const [Q, se] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                il(x, k, T, se, Q, false, true, Oc, false, j);
              }
            })(e, a, c, p, _) : s.ck(c) ? (function(x, k, T, R, z) {
              const j = T.paint.get("background-color"), $ = T.paint.get("background-opacity");
              if ($ === 0) return;
              const { isRenderingToTexture: U } = z, Q = x.context, se = Q.gl, le = x.style.projection, ue = x.transform, ge = ue.tileSize, we = T.paint.get("background-pattern");
              if (x.isPatternMissing(we)) return;
              const ye = !we && j.a === 1 && $ === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== ye) return;
              const ke = Er.disabled, Ae = x.getDepthModeForSublayer(0, ye === "opaque" ? vr.ReadWrite : vr.ReadOnly), be = x.colorModeForRenderPass(), Le = x.useProgram(we ? "backgroundPattern" : "background"), Ke = R || Te(ue, { tileSize: ge, terrain: x.style.map.terrain });
              we && (Q.activeTexture.set(se.TEXTURE0), x.imageManager.bind(x.context));
              const We = T.getCrossfadeParameters();
              for (const He of Ke) {
                const Je = ue.getProjectionData({ overscaledTileID: He, applyGlobeMatrix: !U, applyTerrainMatrix: true }), kt = we ? yh($, x, we, { tileID: He, tileSize: ge }, We) : vh($, j), St = x.style.map.terrain && x.style.map.terrain.getTerrainData(He), pt = le.getMeshFromTileID(Q, He.canonical, false, true, "raster");
                Le.draw(Q, se.TRIANGLES, Ae, ke, be, sr.backCCW, kt, St, Je, T.id, pt.vertexBuffer, pt.indexBuffer, pt.segments);
              }
            })(e, 0, c, p, _) : s.cl(c) && (function(x, k, T, R) {
              const { isRenderingGlobe: z } = R, j = x.context, $ = T.implementation, U = x.style.projection, Q = x.transform, se = Q.getProjectionDataForCustomLayer(z), le = { farZ: Q.farZ, nearZ: Q.nearZ, fov: Q.fov * Math.PI / 180, modelViewProjectionMatrix: Q.modelViewProjectionMatrix, projectionMatrix: Q.projectionMatrix, shaderData: { variantName: U.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${U.shaderPreludeCode.vertexSource}`, define: U.shaderDefine }, defaultProjectionData: se }, ue = $.renderingMode ? $.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const ge = $.prerender;
                ge && (x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), ge.call($, j.gl, le), j.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), j.setStencilMode(Er.disabled);
                const ge = ue === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, vr.ReadOnly);
                j.setDepthMode(ge), $.render(j.gl, le), j.setDirty(), x.setBaseState(), j.bindFramebuffer.set(null);
              }
            })(e, 0, c, _));
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return false;
            if (!e.from || !e.to) return true;
            const a = this.imageManager.getPattern(e.from.toString()), c = this.imageManager.getPattern(e.to.toString());
            return !a || !c;
          }
          useProgram(e, a, c = false, p = []) {
            this.cache = this.cache || {};
            const _ = !!this.style.map.terrain, x = this.style.projection, k = c ? An.projectionMercator : x.shaderPreludeCode, T = c ? ro : x.shaderDefine, R = e + (a ? a.cacheKey : "") + `/${c ? Do : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (_ ? "/terrain" : "") + (p ? `/${p.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new xc(this.context, An[e], a, Tc[e], this._showOverdrawInspector, _, k, T, p)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: a } = this.context.gl;
            return this.width !== e || this.height !== a;
          }
        }
        function Vc(y, e) {
          let a, c = false, p = null, _ = null;
          const x = () => {
            p = null, c && (y.apply(_, a), p = setTimeout(x, e), c = false);
          };
          return (...k) => (c = true, _ = this, a = k, p || x(), p);
        }
        class Fa {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map(((p) => p.split("="))).forEach(((p) => {
                  p[0] === this._hashName && (c = p);
                })), (c && c[1] || "").split("/");
              }
              return a.split("/");
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return false;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: c, pitch: +(a[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a);
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let p = c;
              p.split("&").length > 0 && (p = p.split("&")[0]), this._hashName && (p = `${this._hashName}=${c}`);
              let _ = window.location.hash.replace(p, "");
              _.startsWith("#&") ? _ = _.slice(0, 1) + _.slice(2) : _ === "#" && (_ = "");
              let x = window.location.href.replace(/(#.+)?$/, _);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = Vc(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const a = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, p = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, p), x = Math.round(a.lng * _) / _, k = Math.round(a.lat * _) / _, T = this._map.getBearing(), R = this._map.getPitch();
            let z = "";
            if (z += e ? `/${x}/${k}/${c}` : `${c}/${k}/${x}`, (T || R) && (z += "/" + Math.round(10 * T) / 10), R && (z += `/${Math.round(R)}`), this._hashName) {
              const j = this._hashName;
              let $ = false;
              const U = window.location.hash.slice(1).split("&").map(((Q) => {
                const se = Q.split("=")[0];
                return se === j ? ($ = true, `${se}=${z}`) : Q;
              })).filter(((Q) => Q));
              return $ || U.push(`${j}=${z}`), `#${U.join("&")}`;
            }
            return `#${z}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return false;
            try {
              new s.S(+e[2], +e[1]);
            } catch {
              return false;
            }
            const a = +e[0], c = +(e[3] || 0), p = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && p >= this._map.getMinPitch() && p <= this._map.getMaxPitch();
          }
        }
        const La = { linearity: 0.3, easing: s.cm(0, 0, 0.3, 1) }, nl = s.e({ deceleration: 2500, maxSpeed: 1400 }, La), Uc = s.e({ deceleration: 20, maxSpeed: 1400 }, La), zh = s.e({ deceleration: 1e3, maxSpeed: 360 }, La), Fh = s.e({ deceleration: 1e3, maxSpeed: 90 }, La), Lh = s.e({ deceleration: 1e3, maxSpeed: 360 }, La);
        class Bh {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: D.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, a = D.now();
            for (; e.length > 0 && a - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: _ } of this._inertiaBuffer) a.zoom += _.zoomDelta || 0, a.bearing += _.bearingDelta || 0, a.pitch += _.pitchDelta || 0, a.roll += _.rollDelta || 0, _.panDelta && a.pan._add(_.panDelta), _.around && (a.around = _.around), _.pinchAround && (a.pinchAround = _.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, p = {};
            if (a.pan.mag()) {
              const _ = oo(a.pan.mag(), c, s.e({}, nl, e || {})), x = a.pan.mult(_.amount / a.pan.mag()), k = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              p.center = k.easingCenter, p.offset = k.easingOffset, ls(p, _);
            }
            if (a.zoom) {
              const _ = oo(a.zoom, c, Uc);
              p.zoom = this._map.transform.zoom + _.amount, ls(p, _);
            }
            if (a.bearing) {
              const _ = oo(a.bearing, c, zh);
              p.bearing = this._map.transform.bearing + s.ah(_.amount, -179, 179), ls(p, _);
            }
            if (a.pitch) {
              const _ = oo(a.pitch, c, Fh);
              p.pitch = this._map.transform.pitch + _.amount, ls(p, _);
            }
            if (a.roll) {
              const _ = oo(a.roll, c, Lh);
              p.roll = this._map.transform.roll + s.ah(_.amount, -179, 179), ls(p, _);
            }
            if (p.zoom || p.bearing) {
              const _ = a.pinchAround === void 0 ? a.around : a.pinchAround;
              p.around = _ ? this._map.unproject(_) : this._map.getCenter();
            }
            return this.clear(), s.e(p, { noMoveStart: true });
          }
        }
        function ls(y, e) {
          (!y.duration || y.duration < e.duration) && (y.duration = e.duration, y.easing = e.easing);
        }
        function oo(y, e, a) {
          const { maxSpeed: c, linearity: p, deceleration: _ } = a, x = s.ah(y * p / (e / 1e3), -c, c), k = Math.abs(x) / (_ * p);
          return { easing: a.easing, duration: 1e3 * k, amount: x * (k / 2) };
        }
        class Pn extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c, p = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const _ = A.mousePos(a.getCanvas(), c), x = a.unproject(_);
            super(e, s.e({ point: _, lngLat: x, originalEvent: c }, p)), this._defaultPrevented = false, this.target = a;
          }
        }
        class us extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            const p = e === "touchend" ? c.changedTouches : c.touches, _ = A.touchPos(a.getCanvasContainer(), p), x = _.map(((T) => a.unproject(T))), k = _.reduce(((T, R, z, j) => T.add(R.div(j.length))), new s.P(0, 0));
            super(e, { points: _, point: k, lngLats: x, lngLat: a.unproject(k), originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class qc extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            super(e, { originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class Oh {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new qc(e.type, this._map, e));
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new Pn(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new Pn(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Pn(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new us(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new us(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new us(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new us(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class $h {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Pn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Pn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class cs {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain);
          }
        }
        class Gc {
          constructor(e, a) {
            this._map = e, this._tr = new cs(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (A.disableDrag(), this._startPos = this._lastPos = a, this._active = true);
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const p = this._startPos;
            this._lastPos = c, this._box || (this._box = A.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const _ = Math.min(p.x, c.x), x = Math.max(p.x, c.x), k = Math.min(p.y, c.y), T = Math.max(p.y, c.y);
            A.setTransform(this._box, `translate(${_}px,${k}px)`), this._box.style.width = x - _ + "px", this._box.style.height = T - k + "px";
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos, p = a;
            if (this.reset(), A.suppressClick(), c.x !== p.x || c.y !== p.y) return this._map.fire(new s.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (_) => _.fitScreenCoordinates(c, p, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (A.remove(this._box), this._box = null), A.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, { originalEvent: a }));
          }
        }
        function du(y, e) {
          if (y.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${y.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < y.length; c++) a[y[c].identifier] = e[c];
          return a;
        }
        class hu {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(p) {
              const _ = new s.P(0, 0);
              for (const x of p) _._add(x);
              return _.div(p.length);
            })(a), this.touches = du(c, a)));
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const p = du(c, a);
            for (const _ in this.touches) {
              const x = p[_];
              (!x || x.dist(this.touches[_]) > 30) && (this.aborted = true);
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = true), c.length === 0) {
              const p = !this.aborted && this.centroid;
              if (this.reset(), p) return p;
            }
          }
        }
        class fu {
          constructor(e) {
            this.singleTap = new hu(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this.singleTap.touchend(e, a, c);
            if (p) {
              const _ = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(p) < 30;
              if (_ && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = p, this.count === this.numTaps) return this.reset(), p;
            }
          }
        }
        class Wn {
          constructor(e) {
            this._tr = new cs(e), this._zoomIn = new fu({ numTouches: 1, numTaps: 2 }), this._zoomOut = new fu({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this._zoomIn.touchend(e, a, c), _ = this._zoomOut.touchend(e, a, c), x = this._tr;
            return p ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(p) }, { originalEvent: e }) }) : _ ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(_) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class yn {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = true, a;
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const p = Array.isArray(a) ? a[0] : a;
            return !this._moved && p.dist(c) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = p, this._move(c, p));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && A.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const jh = 0, ao = 2, ds = { [jh]: 1, [ao]: 2 };
        class ol {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const a = A.mouseButton(e);
            this._eventButton = a;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const p = ds[c];
              return a.buttons === void 0 || (a.buttons & p) !== p;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return A.mouseButton(e) === this._eventButton;
          }
        }
        class Op {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class $p {
          constructor(e = new ol({ checkCorrectEvent: () => true }), a = new Op()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a;
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.startMove(a)), ((a) => this.oneFingerTouchMoveStateManager.startMove(a)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.endMove(a)), ((a) => this.oneFingerTouchMoveStateManager.endMove(a)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidStartEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidMoveEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidEndEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)));
          }
        }
        const pu = (y) => {
          y.mousedown = y.dragStart, y.mousemoveWindow = y.dragMove, y.mouseup = y.dragEnd, y.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class Nh {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new s.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = true);
            const p = du(c, a), _ = new s.P(0, 0), x = new s.P(0, 0);
            let k = 0;
            for (const R in p) {
              const z = p[R], j = this._touches[R];
              j && (_._add(z), x._add(z.sub(j)), k++, p[R] = z);
            }
            if (this._touches = p, this._shouldBePrevented(k) || !x.mag()) return;
            const T = x.div(k);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : { around: _.div(k), panDelta: T };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ba {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]));
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [p, _] = this._firstTwoTouches, x = Zn(c, a, p), k = Zn(c, a, _);
            if (!x || !k) return;
            const T = this._aroundCenter ? null : x.add(k).div(2);
            return this._move([x, k], T, e);
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [p, _] = this._firstTwoTouches, x = Zn(c, a, p), k = Zn(c, a, _);
            x && k || (this._active && A.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = true, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Zn(y, e, a) {
          for (let c = 0; c < y.length; c++) if (y[c].identifier === a) return e[c];
        }
        function Ot(y, e) {
          return Math.log(y / e) / Math.LN2;
        }
        class Wc extends Ba {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Ot(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Ot(this._distance, c), pinchAround: a };
          }
        }
        function mu(y, e) {
          return 180 * y.angleWith(e) / Math.PI;
        }
        class Zc extends Ba {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, a, c) {
            const p = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: mu(this._vector, p), pinchAround: a };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360, c = mu(e, this._startVector);
            return Math.abs(c) < a;
          }
        }
        function Oa(y) {
          return Math.abs(y.y) > Math.abs(y.x);
        }
        class hs extends Ba {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length;
          }
          _start(e) {
            this._lastPoints = e, Oa(e[0].sub(e[1])) && (this._valid = false);
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const p = e[0].sub(this._lastPoints[0]), _ = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(p, _, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = true, { pitchDelta: (p.y + _.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const p = e.mag() >= 2, _ = a.mag() >= 2;
            if (!p && !_) return;
            if (!p || !_) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const x = e.y > 0 == a.y > 0;
            return Oa(e) && Oa(a) && x;
          }
        }
        const Hc = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class kr {
          constructor(e) {
            this._tr = new cs(e);
            const a = Hc;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0, c = 0, p = 0, _ = 0, x = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), _ = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), _ = 1);
                break;
              case 38:
                e.shiftKey ? p = 1 : (e.preventDefault(), x = -1);
                break;
              case 40:
                e.shiftKey ? p = -1 : (e.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, p = 0), { cameraAnimation: (k) => {
              const T = this._tr;
              k.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Xc, zoom: a ? Math.round(T.zoom) + a * (e.shiftKey ? 2 : 1) : T.zoom, bearing: T.bearing + c * this._bearingStep, pitch: T.pitch + p * this._pitchStep, offset: [-_ * this._panStep, -x * this._panStep], center: T.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Xc(y) {
          return y * (2 - y);
        }
        const Vh = 4.000244140625, Yc = 1 / 450;
        class Uh {
          constructor(e, a) {
            this._onTimeout = (c) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
            }, this._map = e, this._tr = new cs(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Yc;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = D.now(), p = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % Vh == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : p > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(p * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = A.mousePos(this._map.getCanvas(), e), c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(s.S.convert(c.center)) : a, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const k = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += k), typeof this._targetZoom == "number" && (this._targetZoom += k);
            }
            if (this._delta !== 0) {
              const k = this._type === "wheel" && Math.abs(this._delta) > Vh ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * k)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const R = typeof this._targetZoom != "number" ? e.scale : s.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), s.ak(R * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, c = this._startZoom, p = this._easing;
            let _, x = false;
            if (this._type === "wheel" && c && p) {
              const k = D.now() - this._lastWheelEventTime, T = Math.min((k + 5) / 200, 1), R = p(T);
              _ = s.C.number(c, a, R), T < 1 ? this._frameId || (this._frameId = true) : x = true;
            } else _ = a, x = true;
            return this._active = true, x && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = _, { noInertia: true, needsRenderFrame: !x, zoomDelta: _ - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let a = s.co;
            if (this._prevEase) {
              const c = this._prevEase, p = (D.now() - c.start) / c.duration, _ = c.easing(p + 0.01) - c.easing(p), x = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, k = Math.sqrt(0.0729 - x * x);
              a = s.cm(x, k, 0.25, 1);
            }
            return this._prevEase = { start: D.now(), duration: e, easing: a }, a;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class qh {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Gh {
          constructor(e) {
            this._tr = new cs(e), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e, a) {
            return e.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(a) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Kc {
          constructor() {
            this._tap = new fu({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, a, c) {
            if (!this._swipePoint) if (this._tapTime) {
              const p = a[0], _ = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(p) < 30;
              _ && x ? c.length > 0 && (this._swipePoint = p, this._swipeTouch = c[0].identifier) : this.reset();
            } else this._tap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const p = a[0], _ = p.y - this._swipePoint.y;
                return this._swipePoint = p, e.preventDefault(), this._active = true, { zoomDelta: _ / 128 };
              }
            } else this._tap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const p = this._tap.touchend(e, a, c);
              p && (this._tapTime = e.timeStamp, this._tapPoint = p);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Jc {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Wh {
          constructor(e, a, c, p) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = p;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Qc {
          constructor(e, a, c, p) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = p, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Zh {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = A.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), p = document.createElement("div");
            p.className = "maplibregl-desktop-message", p.textContent = a, this._container.appendChild(p);
            const _ = document.createElement("div");
            _.className = "maplibregl-mobile-message", _.textContent = c, this._container.appendChild(_), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (A.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", { gestureType: e, originalEvent: a })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const gu = (y) => y.zoom || y.drag || y.roll || y.pitch || y.rotate;
        class aa extends s.l {
        }
        function Gr(y) {
          return y.panDelta && y.panDelta.mag() || y.zoomDelta || y.bearingDelta || y.pitchDelta || y.rollDelta;
        }
        class jp {
          constructor(e, a) {
            this.handleWindowEvent = (p) => {
              this.handleEvent(p, `${p.type}Window`);
            }, this.handleEvent = (p, _) => {
              if (p.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const x = p.type === "renderFrame" ? void 0 : p, k = { needsRenderFrame: false }, T = {}, R = {};
              for (const { handlerName: $, handler: U, allowed: Q } of this._handlers) {
                if (!U.isEnabled()) continue;
                let se;
                if (this._blockedByActive(R, Q, $)) U.reset();
                else if (U[_ || p.type]) {
                  if (s.cp(p, _ || p.type)) {
                    const le = A.mousePos(this._map.getCanvas(), p);
                    se = U[_ || p.type](p, le);
                  } else if (s.cq(p, _ || p.type)) {
                    const le = this._getMapTouches(p.touches), ue = A.touchPos(this._map.getCanvas(), le);
                    se = U[_ || p.type](p, ue, le);
                  } else s.cr(_ || p.type) || (se = U[_ || p.type](p));
                  this.mergeHandlerResult(k, T, se, $, x), se && se.needsRenderFrame && this._triggerRenderFrame();
                }
                (se || U.isActive()) && (R[$] = U);
              }
              const z = {};
              for (const $ in this._previousActiveHandlers) R[$] || (z[$] = x);
              this._previousActiveHandlers = R, (Object.keys(z).length || Gr(k)) && (this._changes.push([k, T, z]), this._triggerRenderFrame()), (Object.keys(R).length || Gr(k)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: j } = k;
              j && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], j(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Bh(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: true }], [c, "touchmove", { passive: false }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: false }], [c, "keyup", void 0], [c, "wheel", { passive: false }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [p, _, x] of this._listeners) A.addEventListener(p, _, p === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [e, a, c] of this._listeners) A.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c);
          }
          _addDefaultHandlers(e) {
            const a = this._map, c = a.getCanvasContainer();
            this._add("mapEvent", new Oh(a, e));
            const p = a.boxZoom = new Gc(a, e);
            this._add("boxZoom", p), e.interactive && e.boxZoom && p.enable();
            const _ = a.cooperativeGestures = new Zh(a, e.cooperativeGestures);
            this._add("cooperativeGestures", _), e.cooperativeGestures && _.enable();
            const x = new Wn(a), k = new Gh(a);
            a.doubleClickZoom = new qh(k, x), this._add("tapZoom", x), this._add("clickZoom", k), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const T = new Kc();
            this._add("tapDragZoom", T);
            const R = a.touchPitch = new hs(a);
            this._add("touchPitch", R), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const z = () => a.project(a.getCenter()), j = (function({ enable: ye, clickTolerance: ke, aroundCenter: Ae = true, minPixelCenterThreshold: be = 100, rotateDegreesPerPixelMoved: Le = 0.8 }, Ke) {
              const We = new ol({ checkCorrectEvent: (He) => A.mouseButton(He) === 0 && He.ctrlKey || A.mouseButton(He) === 2 && !He.ctrlKey });
              return new yn({ clickTolerance: ke, move: (He, Je) => {
                const kt = Ke();
                if (Ae && Math.abs(kt.y - He.y) > be) return { bearingDelta: s.cn(new s.P(He.x, Je.y), Je, kt) };
                let St = (Je.x - He.x) * Le;
                return Ae && Je.y < kt.y && (St = -St), { bearingDelta: St };
              }, moveStateManager: We, enable: ye, assignEvents: pu });
            })(e, z), $ = (function({ enable: ye, clickTolerance: ke, pitchDegreesPerPixelMoved: Ae = -0.5 }) {
              const be = new ol({ checkCorrectEvent: (Le) => A.mouseButton(Le) === 0 && Le.ctrlKey || A.mouseButton(Le) === 2 });
              return new yn({ clickTolerance: ke, move: (Le, Ke) => ({ pitchDelta: (Ke.y - Le.y) * Ae }), moveStateManager: be, enable: ye, assignEvents: pu });
            })(e), U = (function({ enable: ye, clickTolerance: ke, rollDegreesPerPixelMoved: Ae = 0.3 }, be) {
              const Le = new ol({ checkCorrectEvent: (Ke) => A.mouseButton(Ke) === 2 && Ke.ctrlKey });
              return new yn({ clickTolerance: ke, move: (Ke, We) => {
                const He = be();
                let Je = (We.x - Ke.x) * Ae;
                return We.y < He.y && (Je = -Je), { rollDelta: Je };
              }, moveStateManager: Le, enable: ye, assignEvents: pu });
            })(e, z);
            a.dragRotate = new Wh(e, j, $, U), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", $, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", U, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Q = (function({ enable: ye, clickTolerance: ke }) {
              const Ae = new ol({ checkCorrectEvent: (be) => A.mouseButton(be) === 0 && !be.ctrlKey });
              return new yn({ clickTolerance: ke, move: (be, Le) => ({ around: Le, panDelta: Le.sub(be) }), activateOnStart: true, moveStateManager: Ae, enable: ye, assignEvents: pu });
            })(e), se = new Nh(e, a);
            a.dragPan = new Jc(c, Q, se), this._add("mousePan", Q), this._add("touchPan", se, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const le = new Zc(), ue = new Wc();
            a.touchZoomRotate = new Qc(c, ue, le, T), this._add("touchRotate", le, ["touchPan", "touchZoom"]), this._add("touchZoom", ue, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate);
            const ge = a.scrollZoom = new Uh(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ge, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const we = a.keyboard = new kr(a);
            this._add("keyboard", we), e.interactive && e.keyboard && a.keyboard.enable(), this._add("blockableMapEvent", new $h(a));
          }
          _add(e, a, c) {
            this._handlers.push({ handlerName: e, handler: a, allowed: c }), this._handlersById[e] = a;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: a } of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!gu(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, a, c) {
            for (const p in e) if (p !== c && (!a || a.indexOf(p) < 0)) return true;
            return false;
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a;
          }
          mergeHandlerResult(e, a, c, p, _) {
            if (!c) return;
            s.e(e, c);
            const x = { handlerName: p, originalEvent: c.originalEvent || _ };
            c.zoomDelta !== void 0 && (a.zoom = x), c.panDelta !== void 0 && (a.drag = x), c.rollDelta !== void 0 && (a.roll = x), c.pitchDelta !== void 0 && (a.pitch = x), c.bearingDelta !== void 0 && (a.rotate = x);
          }
          _applyChanges() {
            const e = {}, a = {}, c = {};
            for (const [p, _, x] of this._changes) p.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(p.panDelta)), p.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + p.zoomDelta), p.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + p.bearingDelta), p.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + p.pitchDelta), p.rollDelta && (e.rollDelta = (e.rollDelta || 0) + p.rollDelta), p.around !== void 0 && (e.around = p.around), p.pinchAround !== void 0 && (e.pinchAround = p.pinchAround), p.noInertia && (e.noInertia = p.noInertia), s.e(a, _), s.e(c, x);
            this._updateMapTransform(e, a, c), this._changes = [];
          }
          _updateMapTransform(e, a, c) {
            const p = this._map, _ = p._getTransformForUpdate(), x = p.terrain;
            if (!(Gr(e) || x && this._terrainMovement)) return this._fireEvents(a, c, true);
            p._stop(true);
            let { panDelta: k, zoomDelta: T, bearingDelta: R, pitchDelta: z, rollDelta: j, around: $, pinchAround: U } = e;
            U !== void 0 && ($ = U), $ = $ || p.transform.centerPoint, x && !_.isPointOnMapSurface($) && ($ = _.centerPoint);
            const Q = { panDelta: k, zoomDelta: T, rollDelta: j, pitchDelta: z, bearingDelta: R, around: $ };
            this._map.cameraHelper.useGlobeControls && !_.isPointOnMapSurface($) && ($ = _.centerPoint);
            const se = $.distSqr(_.centerPoint) < 0.01 ? _.center : _.screenPointToLocation(k ? $.sub(k) : $);
            this._handleMapControls({ terrain: x, tr: _, deltasForHelper: Q, preZoomAroundLoc: se, combinedEventsInProgress: a, panDelta: k }), p._applyUpdatedTransform(_), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, true);
          }
          _handleMapControls({ terrain: e, tr: a, deltasForHelper: c, preZoomAroundLoc: p, combinedEventsInProgress: _, panDelta: x }) {
            const k = this._map.cameraHelper;
            if (k.handleMapControlsRollPitchBearingZoom(c, a), e) return k.useGlobeControls ? (this._terrainMovement || !_.drag && !_.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void k.handleMapControlsPan(c, a, p)) : this._terrainMovement || !_.drag && !_.zoom ? void (_.drag && this._terrainMovement && x ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(x))) : k.handleMapControlsPan(c, a, p)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void k.handleMapControlsPan(c, a, p));
            k.handleMapControlsPan(c, a, p);
          }
          _fireEvents(e, a, c) {
            const p = gu(this._eventsInProgress), _ = gu(e), x = {};
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._eventsInProgress[j] || (x[`${j}start`] = $), this._eventsInProgress[j] = e[j];
            }
            !p && _ && this._fireEvent("movestart", _.originalEvent);
            for (const j in x) this._fireEvent(j, x[j]);
            _ && this._fireEvent("move", _.originalEvent);
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._fireEvent(j, $);
            }
            const k = {};
            let T;
            for (const j in this._eventsInProgress) {
              const { handlerName: $, originalEvent: U } = this._eventsInProgress[j];
              this._handlersById[$].isActive() || (delete this._eventsInProgress[j], T = a[$] || U, k[`${j}end`] = T);
            }
            for (const j in k) this._fireEvent(j, k[j]);
            const R = gu(this._eventsInProgress), z = (p || _) && !R;
            if (z && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j);
            }
            if (c && z) {
              this._updatingCamera = true;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (U) => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
              !j || !j.essential && D.prefersReducedMotion ? (this._map.fire(new s.l("moveend", { originalEvent: T })), $(this._map.getBearing()) && this._map.resetNorth()) : ($(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = true, this._map.easeTo(j, { originalEvent: T })), this._updatingCamera = false;
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? { originalEvent: a } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new aa("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class vu extends s.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const p = Math.min((D.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(p)), p < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a;
          }
          getCenter() {
            return new s.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, a) {
            return this.jumpTo({ center: e }, a);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, a) {
            return this.jumpTo({ elevation: e }, a), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, a, c) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({ offset: e }, a), c);
          }
          panTo(e, a, c) {
            return this.easeTo(s.e({ center: e }, a), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, a) {
            return this.jumpTo({ zoom: e }, a), this;
          }
          zoomTo(e, a, c) {
            return this.easeTo(s.e({ zoom: e }, a), c);
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this;
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, a) {
            return this.jumpTo({ bearing: e }, a), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, a) {
            return this.jumpTo({ padding: e }, a), this;
          }
          rotateTo(e, a, c) {
            return this.easeTo(s.e({ bearing: e }, a), c);
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({ duration: 1e3 }, e), a), this;
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), a), this;
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, a) {
            return this.jumpTo({ pitch: e }, a), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, a) {
            return this.jumpTo({ roll: e }, a), this;
          }
          cameraForBounds(e, a) {
            e = nr.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a);
          }
          _cameraForBoxAndBearing(e, a, c, p) {
            const _ = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (p = s.e({ padding: _, offset: [0, 0], maxZoom: this.transform.maxZoom }, p)).padding == "number") {
              const R = p.padding;
              p.padding = { top: R, bottom: R, right: R, left: R };
            }
            const x = s.e(_, p.padding);
            p.padding = x;
            const k = this.transform, T = new nr(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(p, x, T, c, k);
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c);
          }
          fitScreenCoordinates(e, a, c, p, _) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), c, p), p, _);
          }
          _fitInternal(e, a, c) {
            return e ? (delete (a = s.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this;
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let p = false, _ = false, x = false;
            const k = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const T = c.zoom !== k;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (p = true, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (_ = true, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (x = true, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), T && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), p && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), _ && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), x && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a));
          }
          calculateCameraOptionsFromTo(e, a, c, p = 0) {
            const _ = s.a1.fromLngLat(e, a), x = s.a1.fromLngLat(c, p), k = x.x - _.x, T = x.y - _.y, R = x.z - _.z, z = Math.hypot(k, T, R);
            if (z === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(k, T), $ = s.ak(this.transform.cameraToCenterDistance / z / this.transform.tileSize), U = 180 * Math.atan2(k, -T) / Math.PI;
            let Q = 180 * Math.acos(j / z) / Math.PI;
            return Q = R < 0 ? 90 - Q : 90 + Q, { center: x.toLngLat(), elevation: p, zoom: $, pitch: Q, bearing: U };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, p, _) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, p);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: c, pitch: p, roll: _ };
          }
          easeTo(e, a) {
            this._stop(false, e.easeId), ((e = s.e({ offset: [0, 0], duration: 500, easing: s.co }, e)).animate === false || !e.essential && D.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(), p = this.getBearing(), _ = c.pitch, x = c.roll, k = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, T = "pitch" in e ? +e.pitch : _, R = "roll" in e ? this._normalizeBearing(e.roll, x) : x, z = "padding" in e ? e.padding : c.padding, j = s.P.convert(e.offset);
            let $, U;
            e.around && ($ = s.S.convert(e.around), U = c.locationToScreenPoint($));
            const Q = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, se = this.cameraHelper.handleEaseTo(c, { bearing: k, pitch: T, roll: R, padding: z, around: $, aroundPoint: U, offsetAsPoint: j, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || p !== k, this._pitching = this._pitching || T !== _, this._rolling = this._rolling || R !== x, this._padding = !c.isPaddingEqual(z), this._zooming = this._zooming || se.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Q), this.terrain && this._prepareElevation(se.elevationCenter), this._ease(((le) => {
              se.easeFunc(le), this.terrain && !e.freezeElevation && this._updateElevation(le), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), ((le) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, le);
            }), e), this;
          }
          _prepareEase(e, a, c = {}) {
            this._moving = true, a || c.moving || this.fire(new s.l("movestart", e)), this._zooming && !c.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new s.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a;
            }
            this.transform.setElevation(s.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(), c = e.getCameraAltitude(), p = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < p) {
              const _ = this.calculateCameraOptionsFromTo(a, p, e.center, e.elevation);
              return { pitch: _.pitch, zoom: _.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push(((p) => this._elevateCameraIfInsideTerrain(p))), this.transformCameraUpdate && a.push(((p) => this.transformCameraUpdate(p))), !a.length) return;
            const c = e.clone();
            for (const p of a) {
              const _ = c.clone(), { center: x, zoom: k, roll: T, pitch: R, bearing: z, elevation: j } = p(_);
              x && _.setCenter(x), j !== void 0 && _.setElevation(j), k !== void 0 && _.setZoom(k), T !== void 0 && _.setRoll(T), R !== void 0 && _.setPitch(R), z !== void 0 && _.setBearing(z), c.apply(_);
            }
            this.transform.apply(c);
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e));
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming, p = this._rotating, _ = this._pitching, x = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, c && this.fire(new s.l("zoomend", e)), p && this.fire(new s.l("rotateend", e)), _ && this.fire(new s.l("pitchend", e)), x && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e));
          }
          flyTo(e, a) {
            if (!e.essential && D.prefersReducedMotion) {
              const Je = s.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Je, a);
            }
            this.stop(), e = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.co }, e);
            const c = this._getTransformForUpdate(), p = c.bearing, _ = c.pitch, x = c.roll, k = c.padding, T = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, R = "pitch" in e ? +e.pitch : _, z = "roll" in e ? this._normalizeBearing(e.roll, x) : x, j = "padding" in e ? e.padding : c.padding, $ = s.P.convert(e.offset);
            let U = c.centerPoint.add($);
            const Q = c.screenPointToLocation(U), se = this.cameraHelper.handleFlyTo(c, { bearing: T, pitch: R, roll: z, padding: j, locationAtOffset: Q, offsetAsPoint: $, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let le = e.curve;
            const ue = Math.max(c.width, c.height), ge = ue / se.scaleOfZoom, we = se.pixelPathLength;
            typeof se.scaleOfMinZoom == "number" && (le = Math.sqrt(ue / se.scaleOfMinZoom / we * 2));
            const ye = le * le;
            function ke(Je) {
              const kt = (ge * ge - ue * ue + (Je ? -1 : 1) * ye * ye * we * we) / (2 * (Je ? ge : ue) * ye * we);
              return Math.log(Math.sqrt(kt * kt + 1) - kt);
            }
            function Ae(Je) {
              return (Math.exp(Je) - Math.exp(-Je)) / 2;
            }
            function be(Je) {
              return (Math.exp(Je) + Math.exp(-Je)) / 2;
            }
            const Le = ke(false);
            let Ke = function(Je) {
              return be(Le) / be(Le + le * Je);
            }, We = function(Je) {
              return ue * ((be(Le) * (Ae(kt = Le + le * Je) / be(kt)) - Ae(Le)) / ye) / we;
              var kt;
            }, He = (ke(true) - Le) / le;
            if (Math.abs(we) < 2e-6 || !isFinite(He)) {
              if (Math.abs(ue - ge) < 1e-6) return this.easeTo(e, a);
              const Je = ge < ue ? -1 : 1;
              He = Math.abs(Math.log(ge / ue)) / le, We = () => 0, Ke = (kt) => Math.exp(Je * le * kt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * He / ("screenSpeed" in e ? +e.screenSpeed / le : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = true, this._rotating = p !== T, this._pitching = R !== _, this._rolling = z !== x, this._padding = !c.isPaddingEqual(j), this._prepareEase(a, false), this.terrain && this._prepareElevation(se.targetCenter), this._ease(((Je) => {
              const kt = Je * He, St = 1 / Ke(kt), pt = We(kt);
              this._rotating && c.setBearing(s.C.number(p, T, Je)), this._pitching && c.setPitch(s.C.number(_, R, Je)), this._rolling && c.setRoll(s.C.number(x, z, Je)), this._padding && (c.interpolatePadding(k, j, Je), U = c.centerPoint.add($)), se.easeFunc(Je, St, pt, U), this.terrain && !e.freezeElevation && this._updateElevation(Je), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const p = this._onEaseEnd;
              delete this._onEaseEnd, p.call(this, a);
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(false), this;
          }
          _ease(e, a, c) {
            c.animate === false || c.duration === 0 ? (e(1), a()) : (this._easeStart = D.now(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, a) {
            e = s.aO(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const yu = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class ed {
          constructor(e = yu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (a) => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = A.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = A.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = A.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((p) => typeof p != "string" ? "" : p))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const p = this._map.style.stylesheet;
              this.styleOwner = p.owner, this.styleId = p.id;
            }
            const a = this._map.style.sourceCaches;
            for (const p in a) {
              const _ = a[p];
              if (_.used || _.usedForTerrain) {
                const x = _.getSource();
                x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
              }
            }
            e = e.filter(((p) => String(p).trim())), e.sort(((p, _) => p.length - _.length)), e = e.filter(((p, _) => {
              for (let x = _ + 1; x < e.length; x++) if (e[x].indexOf(p) >= 0) return false;
              return true;
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = A.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class td {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = A.create("div", "maplibregl-ctrl");
            const a = A.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Hh {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({ callback: e, id: a, cancelled: false }), a;
          }
          remove(e) {
            const a = this._currentlyRunning, c = a ? this._queue.concat(a) : this._queue;
            for (const p of c) if (p.id === e) return void (p.cancelled = true);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a) if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var Np = s.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Po extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = D.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = true, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e, a) {
            this.sourceCache.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const p of Te(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: a, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) c[p.key] = true, this._renderableTilesKeys.push(p.key), this._tiles[p.key] || (p.terrainRttPosMatrix32f = new Float64Array(16), s.bY(p.terrainRttPosMatrix32f, 0, s.$, s.$, 0, 0, 1), this._tiles[p.key] = new ki(p, this.tileSize), this._lastTilesetChange = D.now());
            for (const p in this._tiles) c[p] || delete this._tiles[p];
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const p = this._tiles[c].tileID, _ = e.clone(), x = s.ba();
              if (p.canonical.equals(e.canonical)) s.bY(x, 0, s.$, s.$, 0, 0, 1);
              else if (p.canonical.isChildOf(e.canonical)) {
                const k = p.canonical.z - e.canonical.z, T = p.canonical.x - (p.canonical.x >> k << k), R = p.canonical.y - (p.canonical.y >> k << k), z = s.$ >> k;
                s.bY(x, 0, z, z, 0, 0, 1), s.M(x, x, [-T * z, -R * z, 0]);
              } else {
                if (!e.canonical.isChildOf(p.canonical)) continue;
                {
                  const k = e.canonical.z - p.canonical.z, T = e.canonical.x - (e.canonical.x >> k << k), R = e.canonical.y - (e.canonical.y >> k << k), z = s.$ >> k;
                  s.bY(x, 0, s.$, s.$, 0, 0, 1), s.M(x, x, [T * z, R * z, 0]), s.N(x, x, [1 / 2 ** k, 1 / 2 ** k, 0]);
                }
              }
              _.terrainRttPosMatrix32f = new Float32Array(x), a[c] = _;
            }
            return a;
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const p of this._renderableTilesKeys) {
              const _ = this._tiles[p].tileID;
              if (!this._isWithinTileRanges(_, a)) continue;
              const x = e.clone(), k = s.ba();
              if (_.canonical.z === e.canonical.z) {
                const T = e.canonical.x - _.canonical.x, R = e.canonical.y - _.canonical.y;
                s.bY(k, 0, s.$, s.$, 0, 0, 1), s.M(k, k, [T * s.$, R * s.$, 0]);
              } else if (_.canonical.z > e.canonical.z) {
                const T = _.canonical.z - e.canonical.z, R = _.canonical.x - (_.canonical.x >> T << T), z = _.canonical.y - (_.canonical.y >> T << T), j = e.canonical.x - (_.canonical.x >> T), $ = e.canonical.y - (_.canonical.y >> T), U = s.$ >> T;
                s.bY(k, 0, U, U, 0, 0, 1), s.M(k, k, [-R * U + j * s.$, -z * U + $ * s.$, 0]);
              } else {
                const T = e.canonical.z - _.canonical.z, R = e.canonical.x - (e.canonical.x >> T << T), z = e.canonical.y - (e.canonical.y >> T << T), j = (e.canonical.x >> T) - _.canonical.x, $ = (e.canonical.y >> T) - _.canonical.y, U = s.$ << T;
                s.bY(k, 0, U, U, 0, 0, 1), s.M(k, k, [R * s.$ + j * U, z * s.$ + $ * U, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(k), c[p] = x;
            }
            return c;
          }
          getSourceTile(e, a) {
            const c = this.sourceCache._source;
            let p = e.overscaledZ - this.deltaZoom;
            if (p > c.maxzoom && (p = c.maxzoom), p < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(p).key);
            let _ = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!_ || !_.dem) && a) for (; p >= c.minzoom && (!_ || !_.dem); ) _ = this.sourceCache.getTileByID(e.scaledTo(p--).key);
            return _;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY;
          }
        }
        class _u {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new Po(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, a, c, p = s.$) {
            var _;
            if (!(a >= 0 && a < p && c >= 0 && c < p)) return 0;
            const x = this.getTerrainData(e), k = (_ = x.tile) === null || _ === void 0 ? void 0 : _.dem;
            if (!k) return 0;
            const T = s.cs([], [a / p * s.$, c / p * s.$], x.u_terrain_matrix), R = [T[0] * k.dim, T[1] * k.dim], z = Math.floor(R[0]), j = Math.floor(R[1]), $ = R[0] - z, U = R[1] - j;
            return k.get(z, j) * (1 - $) * (1 - U) + k.get(z + 1, j) * $ * (1 - U) + k.get(z, j + 1) * (1 - $) * U + k.get(z + 1, j + 1) * $ * U;
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.ct(a, e.wrap())) return 0;
            const { tileID: c, mercatorX: p, mercatorY: _ } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, p % s.$, _ % s.$, s.$);
          }
          getElevation(e, a, c, p = s.$) {
            return this.getDEMElevation(e, a, c, p) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const p = this.painter.context, _ = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(p, _, p.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(p, new s.R({ width: 1, height: 1 }), p.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.ag([]);
            }
            const a = this.sourceCache.getSourceTile(e, true);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const p = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), { premultiply: false }) : a.demTexture = new s.T(p, a.dem.getPixels(), p.gl.RGBA, { premultiply: false }), a.demTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = false;
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const p = this.sourceCache.sourceCache._source.maxzoom;
              let _ = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= p ? _ = e.canonical.z - p : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = e.canonical.x - (e.canonical.x >> _ << _), k = e.canonical.y - (e.canonical.y >> _ << _), T = s.cu(new Float64Array(16), [1 / (s.$ << _), 1 / (s.$ << _), 0]);
              s.M(T, T, [x * s.$, k * s.$, 0]), this._demMatrixCache[e.key] = { matrix: T, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: a && a.dem && a.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (a && a.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: a };
          }
          getFramebuffer(e) {
            const a = this.painter, c = a.width / devicePixelRatio, p = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === p || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, p, true, false), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, p))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let _ = 0, x = 0; _ < this._coordsTextureSize; _++) for (let k = 0; k < this._coordsTextureSize; k++, x += 4) a[x + 0] = 255 & k, a[x + 1] = 255 & _, a[x + 2] = k >> 8 << 4 | _ >> 8, a[x + 3] = 0;
            const c = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(a.buffer)), p = new s.T(e, c, e.gl.RGBA, { premultiply: false });
            return p.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = p, p;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(true);
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl, _ = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), k = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), p.readPixels(_, k - x - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const T = a[0] + (a[2] >> 4 << 8), R = a[1] + ((15 & a[2]) << 8), z = this.coordsIndex[255 - a[3]], j = z && this.sourceCache.getTileByID(z);
            if (!j) return null;
            const $ = this._coordsTextureSize, U = (1 << j.tileID.canonical.z) * $;
            return new s.a1((j.tileID.canonical.x * $ + T) / U + j.tileID.wrap, (j.tileID.canonical.y * $ + R) / U, this.getElevation(j.tileID, T, R, $));
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), p.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256;
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0, p = c && e.canonical.y === 0, _ = c && e.canonical.y === (1 << e.canonical.z) - 1, x = `m_${p ? "n" : ""}_${_ ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const k = this.painter.context, T = new s.cv(), R = new s.aN(), z = this.meshSize, j = s.$ / z, $ = z * z;
            for (let be = 0; be <= z; be++) for (let Le = 0; Le <= z; Le++) T.emplaceBack(Le * j, be * j, 0);
            for (let be = 0; be < $; be += z + 1) for (let Le = 0; Le < z; Le++) R.emplaceBack(Le + be, z + Le + be + 1, z + Le + be + 2), R.emplaceBack(Le + be, z + Le + be + 2, Le + be + 1);
            const U = T.length, Q = U + (z + 1), se = (z + 1) * z, le = p ? s.bh : 0, ue = p ? 0 : 1, ge = _ ? s.bi : s.$, we = _ ? 0 : 1;
            for (let be = 0; be <= z; be++) T.emplaceBack(be * j, le, ue);
            for (let be = 0; be <= z; be++) T.emplaceBack(be * j, ge, we);
            for (let be = 0; be < z; be++) R.emplaceBack(se + be, Q + be, Q + be + 1), R.emplaceBack(se + be, Q + be + 1, se + be + 1), R.emplaceBack(0 + be, U + be + 1, U + be), R.emplaceBack(0 + be, 0 + be + 1, U + be + 1);
            const ye = T.length, ke = ye + 2 * (z + 1);
            for (const be of [0, 1]) for (let Le = 0; Le <= z; Le++) for (const Ke of [0, 1]) T.emplaceBack(be * s.$, Le * j, Ke);
            for (let be = 0; be < 2 * z; be += 2) R.emplaceBack(ye + be, ye + be + 1, ye + be + 3), R.emplaceBack(ye + be, ye + be + 3, ye + be + 2), R.emplaceBack(ke + be, ke + be + 3, ke + be + 1), R.emplaceBack(ke + be, ke + be + 2, ke + be + 3);
            const Ae = new Ao(k.createVertexBuffer(T, Np.members), k.createIndexBuffer(R), s.aM.simpleSegment(0, 0, T.length, R.length));
            return this._meshCache[x] = Ae, Ae;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const { tileID: p } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(p).minElevation) !== null && c !== void 0 ? c : 0;
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile, c = { minElevation: null, maxElevation: null };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c;
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = s.a1.fromLngLat(e.wrap()), p = (1 << a) * s.$, _ = c.x * p, x = c.y * p, k = Math.floor(_ / s.$), T = Math.floor(x / s.$);
            return { tileID: new s.Z(a, 0, a, k, T), mercatorX: _, mercatorY: x };
          }
        }
        class Wt {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), c = new s.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), { id: e, fbo: a, texture: c, stamp: -1, inUse: false };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((a) => e.id !== a)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed) if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = false;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === false;
          }
        }
        const er = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class al {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new Wt(e.context, 30, a.sourceCache.tileSize * a.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((c) => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.sourceCaches) {
              this._coordsAscending[c] = {};
              const p = e.sourceCaches[c].getVisibleCoordinates(), _ = e.sourceCaches[c].getSource(), x = _ instanceof nt ? _.terrainTileRanges : null;
              for (const k of p) {
                const T = this.terrain.sourceCache.getTerrainCoords(k, x);
                for (const R in T) this._coordsAscending[c][R] || (this._coordsAscending[c][R] = []), this._coordsAscending[c][R].push(T[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const p = e._layers[c], _ = p.source;
              if (er[p.type] && !this._coordsAscendingStr[_]) {
                this._coordsAscendingStr[_] = {};
                for (const x in this._coordsAscending[_]) this._coordsAscendingStr[_][x] = this._coordsAscending[_][x].map(((k) => k.key)).sort().join();
              }
            }
            for (const c of this._renderableTiles) for (const p in this._coordsAscendingStr) {
              const _ = this._coordsAscendingStr[p][c.tileID.key];
              _ && _ !== c.rttCoords[p] && (c.rtt = []);
            }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return false;
            const c = Object.assign(Object.assign({}, a), { isRenderingToTexture: true }), p = e.type, _ = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (er[p] && (this._prevType && er[this._prevType] || this._stacks.push([]), this._prevType = p, this._stacks[this._stacks.length - 1].push(e.id), !x)) return true;
            if (er[this._prevType] || er[p] && x) {
              this._prevType = p;
              const k = this._stacks.length - 1, T = this._stacks[k] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (Fn(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[k]) {
                  const j = this.pool.getObjectForId(R.rtt[k].id);
                  if (j.stamp === R.rtt[k].stamp) {
                    this.pool.useObject(j);
                    continue;
                  }
                }
                const z = this.pool.getOrCreateFreeObject();
                this.pool.useObject(z), this.pool.stampObject(z), R.rtt[k] = { id: z.id, stamp: z.stamp }, _.context.bindFramebuffer.set(z.fbo.framebuffer), _.context.clear({ color: s.bf.transparent, stencil: 0 }), _.currentStencilSource = void 0;
                for (let j = 0; j < T.length; j++) {
                  const $ = _.style._layers[T[j]], U = $.source ? this._coordsAscending[$.source][R.tileID.key] : [R.tileID];
                  _.context.viewport.set([0, 0, z.fbo.width, z.fbo.height]), _._renderTileClippingMasks($, U, true), _.renderLayer(_, _.style.sourceCaches[$.source], $, U, c), $.source && (R.rttCoords[$.source] = this._coordsAscendingStr[$.source][R.tileID.key]);
                }
              }
              return Fn(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), er[p];
            }
            return false;
          }
        }
        const Xh = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, bu = C, sn = { hash: false, interactive: true, bearingSnap: 7, attributionControl: yu, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Yh = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class so {
          constructor(e, a, c = false) {
            this.mousedown = (_) => {
              this.startMove(_, A.mousePos(this.element, _)), A.addEventListener(window, "mousemove", this.mousemove), A.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (_) => {
              this.move(_, A.mousePos(this.element, _));
            }, this.mouseup = (_) => {
              this._rotatePitchHandler.dragEnd(_), this.offTemp();
            }, this.touchstart = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = A.touchPos(this.element, _.targetTouches)[0], this.startMove(_, this._startPos), A.addEventListener(window, "touchmove", this.touchmove, { passive: false }), A.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._lastPos = A.touchPos(this.element, _.targetTouches)[0], this.move(_, this._lastPos));
            }, this.touchend = (_) => {
              _.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = a;
            const p = new $p();
            this._rotatePitchHandler = new yn({ clickTolerance: 3, move: (_, x) => {
              const k = a.getBoundingClientRect(), T = new s.P((k.bottom - k.top) / 2, (k.right - k.left) / 2);
              return { bearingDelta: s.cn(new s.P(_.x, x.y), x, T), pitchDelta: c ? -0.5 * (x.y - _.y) : void 0 };
            }, moveStateManager: p, enable: true, assignEvents: () => {
            } }), this.map = e, A.addEventListener(a, "mousedown", this.mousedown), A.addEventListener(a, "touchstart", this.touchstart, { passive: false }), A.addEventListener(a, "touchcancel", this.reset);
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), A.disableDrag();
          }
          move(e, a) {
            const c = this.map, { bearingDelta: p, pitchDelta: _ } = this._rotatePitchHandler.dragMove(e, a) || {};
            p && c.setBearing(c.getBearing() + p), _ && c.setPitch(c.getPitch() + _);
          }
          off() {
            const e = this.element;
            A.removeEventListener(e, "mousedown", this.mousedown), A.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend), A.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            A.enableDrag(), A.removeEventListener(window, "mousemove", this.mousemove), A.removeEventListener(window, "mouseup", this.mouseup), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let $a;
        function fs(y, e, a, c = false) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return y == null ? void 0 : y.wrap();
          const p = new s.S(y.lng, y.lat);
          if (y = new s.S(y.lng, y.lat), e) {
            const _ = new s.S(y.lng - 360, y.lat), x = new s.S(y.lng + 360, y.lat), k = a.locationToScreenPoint(y).distSqr(e);
            a.locationToScreenPoint(_).distSqr(e) < k ? y = _ : a.locationToScreenPoint(x).distSqr(e) < k && (y = x);
          }
          for (; Math.abs(y.lng - a.center.lng) > 180; ) {
            const _ = a.locationToScreenPoint(y);
            if (_.x >= 0 && _.y >= 0 && _.x <= a.width && _.y <= a.height) break;
            y.lng > a.center.lng ? y.lng -= 360 : y.lng += 360;
          }
          return y.lng !== p.lng && a.isPointOnMapSurface(a.locationToScreenPoint(y)) ? y : p;
        }
        const ni = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function xi(y, e, a) {
          const c = y.classList;
          for (const p in ni) c.remove(`maplibregl-${a}-anchor-${p}`);
          c.add(`maplibregl-${a}-anchor-${e}`);
        }
        class xu extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = (a) => {
              const c = a.code, p = a.charCode || a.keyCode;
              c !== "Space" && c !== "Enter" && p !== 32 && p !== 13 || this.togglePopup();
            }, this._onMapClick = (a) => {
              const c = a.originalEvent.target, p = this._element;
              this._popup && (c === p || p.contains(c)) && this.togglePopup();
            }, this._update = (a) => {
              if (!this._map) return;
              const c = this._map.loaded() && !this._map.isMoving();
              ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = fs(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let p = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let _ = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), A.setTransform(this._element, `${ni[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${_} ${p}`), D.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(a && a.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (a) => {
              if (!this._isDragging) {
                const c = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = a.point.dist(this._pointerdownPos) >= c;
              }
              this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (a) => {
              this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || false, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = A.create("div");
              const a = A.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, p = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${p}px`), a.setAttributeNS(null, "viewBox", `0 0 ${p} ${c}`);
              const _ = A.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "stroke", "none"), _.setAttributeNS(null, "stroke-width", "1"), _.setAttributeNS(null, "fill", "none"), _.setAttributeNS(null, "fill-rule", "evenodd");
              const x = A.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const k = A.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), k.setAttributeNS(null, "fill", "#000000");
              const T = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const ue of T) {
                const ge = A.createNS("http://www.w3.org/2000/svg", "ellipse");
                ge.setAttributeNS(null, "opacity", "0.04"), ge.setAttributeNS(null, "cx", "10.5"), ge.setAttributeNS(null, "cy", "5.80029008"), ge.setAttributeNS(null, "rx", ue.rx), ge.setAttributeNS(null, "ry", ue.ry), k.appendChild(ge);
              }
              const R = A.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const z = A.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(z);
              const j = A.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const $ = A.createNS("http://www.w3.org/2000/svg", "path");
              $.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild($);
              const U = A.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
              const Q = A.createNS("http://www.w3.org/2000/svg", "g");
              Q.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const se = A.createNS("http://www.w3.org/2000/svg", "circle");
              se.setAttributeNS(null, "fill", "#000000"), se.setAttributeNS(null, "opacity", "0.25"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962");
              const le = A.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#FFFFFF"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962"), Q.appendChild(se), Q.appendChild(le), x.appendChild(k), x.appendChild(R), x.appendChild(j), x.appendChild(U), x.appendChild(Q), a.appendChild(x), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", p * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((a) => {
              a.preventDefault();
            })), this._element.addEventListener("mousedown", ((a) => {
              a.preventDefault();
            })), xi(this._element, this._anchor, "marker"), e && e.className) for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), A.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = s.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const p = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [p, -1 * (38.1 - 13.5 + p)], "bottom-right": [-p, -1 * (38.1 - 13.5 + p)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = false) {
            var a, c;
            const p = (a = this._map) === null || a === void 0 ? void 0 : a.terrain, _ = this._map.transform.isLocationOccluded(this._lngLat);
            if (!p || _) {
              const U = _ ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== U && (this._element.style.opacity = U));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, k = x.terrain.depthAtPoint(this._pos), T = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, T) - k < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / x.transform.pixelsPerMeter, z = Math.sin(x.getPitch() * Math.PI / 180) * R, j = x.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), $ = x.transform.lngLatToCameraDepth(this._lngLat, T + z) - j > 6e-3;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && $ && this._popup.remove(), this._element.style.opacity = $ ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(true), this;
          }
        }
        const sl = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let ja = 0, Na = false;
        const rd = { maxWidth: 100, unit: "metric" };
        function wu(y, e, a) {
          const c = a && a.maxWidth || 100, p = y._container.clientHeight / 2, _ = y._container.clientWidth / 2, x = y.unproject([_ - c / 2, p]), k = y.unproject([_ + c / 2, p]), T = Math.round(y.project(k).x - y.project(x).x), R = Math.min(c, T, y._container.clientWidth), z = x.distanceTo(k);
          if (a && a.unit === "imperial") {
            const j = 3.2808 * z;
            j > 5280 ? Lo(e, R, j / 5280, y._getUIString("ScaleControl.Miles")) : Lo(e, R, j, y._getUIString("ScaleControl.Feet"));
          } else a && a.unit === "nautical" ? Lo(e, R, z / 1852, y._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? Lo(e, R, z / 1e3, y._getUIString("ScaleControl.Kilometers")) : Lo(e, R, z, y._getUIString("ScaleControl.Meters"));
        }
        function Lo(y, e, a, c) {
          const p = (function(_) {
            const x = Math.pow(10, `${Math.floor(_)}`.length - 1);
            let k = _ / x;
            return k = k >= 10 ? 10 : k >= 5 ? 5 : k >= 3 ? 3 : k >= 2 ? 2 : k >= 1 ? 1 : (function(T) {
              const R = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * R) / R;
            })(k), x * k;
          })(a);
          y.style.width = e * (p / a) + "px", y.innerHTML = `${p}&nbsp;${c}`;
        }
        const id = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, nd = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Cu(y) {
          if (y) {
            if (typeof y == "number") {
              const e = Math.round(Math.abs(y) / Math.SQRT2);
              return { center: new s.P(0, 0), top: new s.P(0, y), "top-left": new s.P(e, e), "top-right": new s.P(-e, e), bottom: new s.P(0, -y), "bottom-left": new s.P(e, -e), "bottom-right": new s.P(-e, -e), left: new s.P(y, 0), right: new s.P(-y, 0) };
            }
            if (y instanceof s.P || Array.isArray(y)) {
              const e = s.P.convert(y);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: s.P.convert(y.center || [0, 0]), top: s.P.convert(y.top || [0, 0]), "top-left": s.P.convert(y["top-left"] || [0, 0]), "top-right": s.P.convert(y["top-right"] || [0, 0]), bottom: s.P.convert(y.bottom || [0, 0]), "bottom-left": s.P.convert(y["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(y["bottom-right"] || [0, 0]), left: s.P.convert(y.left || [0, 0]), right: s.P.convert(y.right || [0, 0]) };
          }
          return Cu(new s.P(0, 0));
        }
        const od = C;
        m.AJAXError = s.cz, m.Event = s.l, m.Evented = s.E, m.LngLat = s.S, m.MercatorCoordinate = s.a1, m.Point = s.P, m.addProtocol = s.cA, m.config = s.a, m.removeProtocol = s.cB, m.AttributionControl = ed, m.BoxZoomHandler = Gc, m.CanvasSource = Ye, m.CooperativeGesturesHandler = Zh, m.DoubleClickZoomHandler = qh, m.DragPanHandler = Jc, m.DragRotateHandler = Wh, m.EdgeInsets = Ca, m.FullscreenControl = class extends s.E {
          constructor(y = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, y && y.container && (y.container instanceof HTMLElement ? this._container = y.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(y) {
            return this._map = y, this._container || (this._container = this._map.getContainer()), this._controlContainer = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            A.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const y = this._fullscreenButton = A.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            A.create("span", "maplibregl-ctrl-icon", y).setAttribute("aria-hidden", "true"), y.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const y = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", y), this._fullscreenButton.title = y;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, m.GeoJSONSource = Ee, m.GeolocateControl = class extends s.E {
          constructor(y) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const a = new s.S(e.coords.longitude, e.coords.latitude), c = e.coords.accuracy, p = this._map.getBearing(), _ = s.e({ bearing: p }, this.options.fitBoundsOptions), x = nr.fromLngLat(a, c);
              this._map.fitBounds(x, _, { geolocateSource: true });
            }, this._updateMarker = (e) => {
              if (e) {
                const a = new s.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && Na) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = A.create("button", "maplibregl-ctrl-geolocate", this._container), A.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === false) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = A.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new xu({ element: this._dotElement }), this._circleElement = A.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new xu({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((a) => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")));
                }));
              }
            }, this.options = s.e({}, sl, y);
          }
          onAdd(y) {
            return this._map = y, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function* (e = false) {
                if ($a !== void 0 && !e) return $a;
                if (window.navigator.permissions === void 0) return $a = !!window.navigator.geolocation, $a;
                try {
                  $a = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  $a = !!window.navigator.geolocation;
                }
                return $a;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), A.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, ja = 0, Na = false;
          }
          _isOutOfMapMaxBounds(y) {
            const e = this._map.getMaxBounds(), a = y.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const y = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && y)) return;
            const e = this._map.project(y), a = this._map.unproject([e.x + 100, e.y]), c = y.distanceTo(a) / 100, p = 2 * this._accuracy / c;
            this._circleElement.style.width = `${p.toFixed(2)}px`, this._circleElement.style.height = `${p.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ja--, Na = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let y;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ja++, ja > 1 ? (y = { maximumAge: 6e5, timeout: 0 }, Na = true) : (y = this.options.positionOptions, Na = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, y);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, m.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var y;
              const e = (y = this._map.getProjection()) === null || y === void 0 ? void 0 : y.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var y;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((y = this._map.getProjection()) === null || y === void 0 ? void 0 : y.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(y) {
            return this._map = y, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = A.create("button", "maplibregl-ctrl-globe", this._container), A.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, m.Hash = Fa, m.ImageSource = nt, m.KeyboardHandler = kr, m.LngLatBounds = nr, m.LogoControl = td, m.Map = class extends vu {
          constructor(y) {
            var e, a;
            s.cw.mark(s.cx.create);
            const c = Object.assign(Object.assign(Object.assign({}, sn), y), { canvasContextAttributes: Object.assign(Object.assign({}, sn.canvasContextAttributes), y.canvasContextAttributes) });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const p = new Jr(), _ = new on();
            if (c.minZoom !== void 0 && p.setMinZoom(c.minZoom), c.maxZoom !== void 0 && p.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && p.setMinPitch(c.minPitch), c.maxPitch !== void 0 && p.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && p.setRenderWorldCopies(c.renderWorldCopies), super(p, _, { bearingSnap: c.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Hh(), this._controls = [], this._mapId = s.a7(), this._contextLost = (k) => {
              k.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", { originalEvent: k }));
            }, this._contextRestored = (k) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", { originalEvent: k }));
            }, this._onMapScroll = (k) => {
              if (k.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === true, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === true, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === true, this._collectResourceTiming = c.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, Xh), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = te.addThrottleControl((() => this.isMoving())), this._requestManager = new re(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`);
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container;
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let k = false;
              const T = Vc(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                k ? T(R) : k = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new jp(this, c), this._hash = c.hash && new Fa(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: c.center, elevation: c.elevation, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, roll: c.roll }), c.bounds && (this.resize(), this.fitBounds(c.bounds, s.e({}, c.fitBoundsOptions, { duration: 0 }))));
            const x = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, { localIdeographFontFamily: c.localIdeographFontFamily }), c.attributionControl && this.addControl(new ed(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new td(), c.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const k = s.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(k);
              }
            })), this.on("data", ((k) => {
              this._update(k.dataType === "style"), this.fire(new s.l(`${k.dataType}data`, k));
            })), this.on("dataloading", ((k) => {
              this.fire(new s.l(`${k.dataType}dataloading`, k));
            })), this.on("dataabort", ((k) => {
              this.fire(new s.l("sourcedataabort", k));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(y, e) {
            return this.style.setGlobalStateProperty(y, e), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(y, e) {
            if (e === void 0 && (e = y.getDefaultPosition ? y.getDefaultPosition() : "top-right"), !y || !y.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = y.onAdd(this);
            this._controls.push(y);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this;
          }
          removeControl(y) {
            if (!y || !y.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(y);
            return e > -1 && this._controls.splice(e, 1), y.onRemove(this), this;
          }
          hasControl(y) {
            return this._controls.indexOf(y) > -1;
          }
          coveringTiles(y) {
            return Te(this.transform, y);
          }
          calculateCameraOptionsFromTo(y, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(y, e, a, c);
          }
          resize(y, e = true) {
            const [a, c] = this._containerDimensions(), p = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, p), this.painter.resize(a, c, p), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const k = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, k), this.painter.resize(a, c, k);
            }
            this._resizeTransform(e);
            const _ = !this._moving;
            return _ && (this.stop(), this.fire(new s.l("movestart", y)).fire(new s.l("move", y))), this.fire(new s.l("resize", y)), _ && this.fire(new s.l("moveend", y)), this;
          }
          _resizeTransform(y = true) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, y), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, y);
          }
          _getClampedPixelRatio(y, e) {
            const { 0: a, 1: c } = this._maxCanvasSize, p = this.getPixelRatio(), _ = y * p, x = e * p;
            return Math.min(_ > a ? a / _ : 1, x > c ? c / x : 1) * p;
          }
          getPixelRatio() {
            var y;
            return (y = this._overridePixelRatio) !== null && y !== void 0 ? y : devicePixelRatio;
          }
          setPixelRatio(y) {
            this._overridePixelRatio = y, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(y) {
            return this.transform.setMaxBounds(nr.convert(y)), this._update();
          }
          setMinZoom(y) {
            if ((y = y ?? -2) >= -2 && y <= this.transform.maxZoom) return this.transform.setMinZoom(y), this._update(), this.getZoom() < y && this.setZoom(y), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(y) {
            if ((y = y ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(y), this._update(), this.getZoom() > y && this.setZoom(y), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(y) {
            if ((y = y ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (y >= 0 && y <= this.transform.maxPitch) return this.transform.setMinPitch(y), this._update(), this.getPitch() < y && this.setPitch(y), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(y) {
            if ((y = y ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (y >= this.transform.minPitch) return this.transform.setMaxPitch(y), this._update(), this.getPitch() > y && this.setPitch(y), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(y) {
            return this.transform.setRenderWorldCopies(y), this._update();
          }
          project(y) {
            return this.transform.locationToScreenPoint(s.S.convert(y), this.style && this.terrain);
          }
          unproject(y) {
            return this.transform.screenPointToLocation(s.P.convert(y), this.terrain);
          }
          isMoving() {
            var y;
            return this._moving || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isMoving());
          }
          isZooming() {
            var y;
            return this._zooming || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isZooming());
          }
          isRotating() {
            var y;
            return this._rotating || ((y = this.handlers) === null || y === void 0 ? void 0 : y.isRotating());
          }
          _createDelegatedListener(y, e, a) {
            if (y === "mouseenter" || y === "mouseover") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (_) => {
                const x = e.filter(((T) => this.getLayer(T))), k = x.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: x }) : [];
                k.length ? c || (c = true, a.call(this, new Pn(y, this, _.originalEvent, { features: k }))) : c = false;
              }, mouseout: () => {
                c = false;
              } } };
            }
            if (y === "mouseleave" || y === "mouseout") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (x) => {
                const k = e.filter(((T) => this.getLayer(T)));
                (k.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: k }) : []).length ? c = true : c && (c = false, a.call(this, new Pn(y, this, x.originalEvent)));
              }, mouseout: (x) => {
                c && (c = false, a.call(this, new Pn(y, this, x.originalEvent)));
              } } };
            }
            {
              const c = (p) => {
                const _ = e.filter(((k) => this.getLayer(k))), x = _.length !== 0 ? this.queryRenderedFeatures(p.point, { layers: _ }) : [];
                x.length && (p.features = x, a.call(this, p), delete p.features);
              };
              return { layers: e, listener: a, delegates: { [y]: c } };
            }
          }
          _saveDelegatedListener(y, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[y] = this._delegatedListeners[y] || [], this._delegatedListeners[y].push(e);
          }
          _removeDelegatedListener(y, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[y]) return;
            const c = this._delegatedListeners[y];
            for (let p = 0; p < c.length; p++) {
              const _ = c[p];
              if (_.listener === a && _.layers.length === e.length && _.layers.every(((x) => e.includes(x)))) {
                for (const x in _.delegates) this.off(x, _.delegates[x]);
                return void c.splice(p, 1);
              }
            }
          }
          on(y, e, a) {
            if (a === void 0) return super.on(y, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(y, c, a);
            this._saveDelegatedListener(y, p);
            for (const _ in p.delegates) this.on(_, p.delegates[_]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(y, c, a);
            } };
          }
          once(y, e, a) {
            if (a === void 0) return super.once(y, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(y, c, a);
            for (const _ in p.delegates) {
              const x = p.delegates[_];
              p.delegates[_] = (...k) => {
                this._removeDelegatedListener(y, c, a), x(...k);
              };
            }
            this._saveDelegatedListener(y, p);
            for (const _ in p.delegates) this.once(_, p.delegates[_]);
            return this;
          }
          off(y, e, a) {
            return a === void 0 ? super.off(y, e) : (this._removeDelegatedListener(y, typeof e == "string" ? [e] : e, a), this);
          }
          queryRenderedFeatures(y, e) {
            if (!this.style) return [];
            let a;
            const c = y instanceof s.P || Array.isArray(y), p = c ? y : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (c ? {} : y) || {}, p instanceof s.P || typeof p[0] == "number") a = [s.P.convert(p)];
            else {
              const _ = s.P.convert(p[0]), x = s.P.convert(p[1]);
              a = [_, new s.P(x.x, _.y), x, new s.P(_.x, x.y), _];
            }
            return this.style.queryRenderedFeatures(a, e, this.transform);
          }
          querySourceFeatures(y, e) {
            return this.style.querySourceFeatures(y, e);
          }
          setStyle(y, e) {
            return (e = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== false && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && y ? (this._diffStyle(y, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(y, e));
          }
          setTransformRequest(y) {
            return this._requestManager.setTransformRequest(y), this;
          }
          _getUIString(y) {
            const e = this._locale[y];
            if (e == null) throw new Error(`Missing UI string '${y}'`);
            return e;
          }
          _updateStyle(y, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(y, e)));
            const p = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!y)), y ? (this.style = new _c(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof y == "string" ? this.style.loadURL(y, e, p) : this.style.loadJSON(y, e, p), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new _c(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(y, e) {
            if (typeof y == "string") {
              const a = this._requestManager.transformRequest(y, "Style");
              s.j(a, new AbortController()).then(((c) => {
                this._updateDiff(c.data, e);
              })).catch(((c) => {
                c && this.fire(new s.k(c));
              }));
            } else typeof y == "object" && this._updateDiff(y, e);
          }
          _updateDiff(y, e) {
            try {
              this.style.setState(y, e) && this._update(true);
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`), this._updateStyle(y, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
          }
          addSource(y, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(y, e), this._update(true);
          }
          isSourceLoaded(y) {
            const e = this.style && this.style.sourceCaches[y];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no source with ID '${y}'`)));
          }
          setTerrain(y) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), y) {
              const e = this.style.sourceCaches[y.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${y.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === y.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === y.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new _u(this.painter, e, y), this.painter.renderToTexture = new al(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (a) => {
                var c;
                a.dataType === "style" ? this.terrain.sourceCache.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== y.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(a.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", { terrain: y })), this;
          }
          getTerrain() {
            var y, e;
            return (e = (y = this.terrain) === null || y === void 0 ? void 0 : y.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const y = this.style && this.style.sourceCaches;
            for (const e in y) {
              const a = y[e]._tiles;
              for (const c in a) {
                const p = a[c];
                if (p.state !== "loaded" && p.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(y) {
            return this.style.removeSource(y), this._update(true);
          }
          getSource(y) {
            return this.style.getSource(y);
          }
          setSourceTileLodParams(y, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = it(Math.max(1, y), Math.max(1, e));
            } else for (const c in this.style.sourceCaches) this.style.sourceCaches[c].getSource().calculateTileZoom = it(Math.max(1, y), Math.max(1, e));
            return this._update(true), this;
          }
          refreshTiles(y, e) {
            const a = this.style.sourceCaches[y];
            if (!a) throw new Error(`There is no source cache with ID "${y}", cannot refresh tile`);
            e === void 0 ? a.reload(true) : a.refreshTiles(e.map(((c) => new s.a4(c.z, c.x, c.y))));
          }
          addImage(y, e, a = {}) {
            const { pixelRatio: c = 1, sdf: p = false, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: z, height: j, data: $ } = e, U = e;
                return this.style.addImage(y, { data: new s.R({ width: z, height: j }, new Uint8Array($)), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R, sdf: p, version: 0, userImage: U }), U.onAdd && U.onAdd(this, y), this;
              }
            }
            {
              const { width: z, height: j, data: $ } = D.getImageData(e);
              this.style.addImage(y, { data: new s.R({ width: z, height: j }, $), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R, sdf: p, version: 0 });
            }
          }
          updateImage(y, e) {
            const a = this.style.getImage(y);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || s.b(e) ? D.getImageData(e) : e, { width: p, height: _, data: x } = c;
            if (p === void 0 || _ === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (p !== a.data.width || _ !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const k = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(x, k), this.style.updateImage(y, a), this;
          }
          getImage(y) {
            return this.style.getImage(y);
          }
          hasImage(y) {
            return y ? !!this.style.getImage(y) : (this.fire(new s.k(new Error("Missing required image id"))), false);
          }
          removeImage(y) {
            this.style.removeImage(y);
          }
          loadImage(y) {
            return te.getImage(this._requestManager.transformRequest(y, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(y, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(y, e), this._update(true);
          }
          moveLayer(y, e) {
            return this.style.moveLayer(y, e), this._update(true);
          }
          removeLayer(y) {
            return this.style.removeLayer(y), this._update(true);
          }
          getLayer(y) {
            return this.style.getLayer(y);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(y, e, a) {
            return this.style.setLayerZoomRange(y, e, a), this._update(true);
          }
          setFilter(y, e, a = {}) {
            return this.style.setFilter(y, e, a), this._update(true);
          }
          getFilter(y) {
            return this.style.getFilter(y);
          }
          setPaintProperty(y, e, a, c = {}) {
            return this.style.setPaintProperty(y, e, a, c), this._update(true);
          }
          getPaintProperty(y, e) {
            return this.style.getPaintProperty(y, e);
          }
          setLayoutProperty(y, e, a, c = {}) {
            return this.style.setLayoutProperty(y, e, a, c), this._update(true);
          }
          getLayoutProperty(y, e) {
            return this.style.getLayoutProperty(y, e);
          }
          setGlyphs(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(y, e), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(y, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(y, e, a, ((c) => {
              c || this._update(true);
            })), this;
          }
          removeSprite(y) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(y), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(y, e, ((a) => {
              a || this._update(true);
            })), this;
          }
          setLight(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(y, e), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(y, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(y, e), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(y, e) {
            return this.style.setFeatureState(y, e), this._update();
          }
          removeFeatureState(y, e) {
            return this.style.removeFeatureState(y, e), this._update();
          }
          getFeatureState(y) {
            return this.style.getFeatureState(y);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let y = 0, e = 0;
            return this._container && (y = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [y, e];
          }
          _setupContainer() {
            const y = this._container;
            y.classList.add("maplibregl-map");
            const e = this._canvasContainer = A.create("div", "maplibregl-canvas-container", y);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = A.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(), c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const p = this._controlContainer = A.create("div", "maplibregl-control-container", y), _ = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              _[x] = A.create("div", `maplibregl-ctrl-${x} `, p);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(y, e, a) {
            this._canvas.width = Math.floor(a * y), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${y}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const y = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((c) => {
              e = { requestedAttributes: y }, c && (e.statusMessage = c.statusMessage, e.type = c.type);
            }), { once: true });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, y) : this._canvas.getContext("webgl2", y) || this._canvas.getContext("webgl", y), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c);
            }
            this.painter = new cu(a, this.transform), O.testSupport(a);
          }
          migrateProjection(y, e) {
            super.migrateProjection(y, e), this.painter.transform = y, this.fire(new s.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(y) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || y, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(y) {
            return this._update(), this._renderTaskQueue.add(y);
          }
          _cancelRenderFrame(y) {
            this._renderTaskQueue.remove(y);
          }
          _render(y) {
            var e, a, c, p, _;
            const x = this._idleTriggered ? this._fadeDuration : 0, k = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(y), this._removed) return;
            let T = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const j = this.transform.zoom, $ = D.now();
              this.style.zoomHistory.update(j, $);
              const U = new s.F(j, { now: $, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), Q = U.crossFadingFactor();
              Q === 1 && Q === this._crossFadingFactor || (T = true, this._crossFadingFactor = Q), this.style.update(U);
            }
            const R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== k;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((p = this.style.projection) === null || p === void 0 ? void 0 : p.transitionState, (_ = this.style.projection) === null || _ === void 0 ? void 0 : _.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = true, s.cw.mark(s.cx.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const z = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return z || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || z || (this._fullyLoaded = true, s.cw.mark(s.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var y;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), te.removeThrottleControl(this._imageQueueHandle), (y = this._resizeObserver) === null || y === void 0 || y.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (e == null ? void 0 : e.loseContext) && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), A.remove(this._canvasContainer), A.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), s.cw.clearMetrics(), this._removed = true, this.fire(new s.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), D.frame(this._frameRequest, ((y) => {
              s.cw.frame(y), this._frameRequest = null;
              try {
                this._render(y);
              } catch (e) {
                if (!s.cy(e) && !(function(a) {
                  return a.message === Ys;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(y) {
            this._showTileBoundaries !== y && (this._showTileBoundaries = y, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(y) {
            this._showPadding !== y && (this._showPadding = y, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(y) {
            this._showCollisionBoxes !== y && (this._showCollisionBoxes = y, y ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(y) {
            this._showOverdrawInspector !== y && (this._showOverdrawInspector = y, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(y) {
            this._repaint !== y && (this._repaint = y, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(y) {
            this._vertices = y, this._update();
          }
          get version() {
            return bu;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(y) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(y), this._update(true);
          }
        }, m.MapMouseEvent = Pn, m.MapTouchEvent = us, m.MapWheelEvent = qc, m.Marker = xu, m.NavigationControl = class {
          constructor(y) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), a = e === this._map.getMaxZoom(), c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c);
            }, this.options = s.e({}, Yh, y), this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = A.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(y) {
            return this._map = y, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new so(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            A.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(y, e) {
            const a = A.create("button", y, this._container);
            return a.type = "button", a.addEventListener("click", e), a;
          }
        }, m.Popup = class extends s.E {
          constructor(y) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && A.remove(this._content), this._container && (A.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = A.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = A.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = fs(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const p = Cu(this.options.offset);
              if (!c) {
                const x = this._container.offsetWidth, k = this._container.offsetHeight;
                let T;
                T = a.y + p.bottom.y < k ? ["top"] : a.y > this._map.transform.height - k ? ["bottom"] : [], a.x < x / 2 ? T.push("left") : a.x > this._map.transform.width - x / 2 && T.push("right"), c = T.length === 0 ? "bottom" : T.join("-");
              }
              let _ = a.add(p[c]);
              this.options.subpixelPositioning || (_ = _.round()), A.setTransform(this._container, `${ni[c]} translate(${_.x}px,${_.y}px)`), xi(this._container, c, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = s.e(Object.create(id), y);
          }
          addTo(y) {
            return this._map && this.remove(), this._map = y, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(y) {
            return this._lngLat = s.S.convert(y), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(y) {
            return this.setDOMContent(document.createTextNode(y));
          }
          setHTML(y) {
            const e = document.createDocumentFragment(), a = document.createElement("body");
            let c;
            for (a.innerHTML = y; c = a.firstChild, c; ) e.appendChild(c);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var y;
            return (y = this._container) === null || y === void 0 ? void 0 : y.style.maxWidth;
          }
          setMaxWidth(y) {
            return this.options.maxWidth = y, this._update(), this;
          }
          setDOMContent(y) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = A.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(y), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(y) {
            return this._container && this._container.classList.add(y), this;
          }
          removeClassName(y) {
            return this._container && this._container.classList.remove(y), this;
          }
          setOffset(y) {
            return this.options.offset = y, this._update(), this;
          }
          toggleClassName(y) {
            if (this._container) return this._container.classList.toggle(y);
          }
          setSubpixelPositioning(y) {
            this.options.subpixelPositioning = y;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = A.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const y = this._container.querySelector(nd);
            y && y.focus();
          }
        }, m.RasterDEMTileSource = Ct, m.RasterTileSource = wr, m.ScaleControl = class {
          constructor(y) {
            this._onMove = () => {
              wu(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, wu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, rd), y);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(y) {
            return this._map = y, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", y.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, m.ScrollZoomHandler = Uh, m.Style = _c, m.TerrainControl = class {
          constructor(y) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = y;
          }
          onAdd(y) {
            return this._map = y, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = A.create("button", "maplibregl-ctrl-terrain", this._container), A.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, m.TwoFingersTouchPitchHandler = hs, m.TwoFingersTouchRotateHandler = Zc, m.TwoFingersTouchZoomHandler = Wc, m.TwoFingersTouchZoomRotateHandler = Qc, m.VectorTileSource = Ar, m.VideoSource = Be, m.addSourceType = (y, e) => s._(void 0, void 0, void 0, (function* () {
          if (bt(y)) throw new Error(`A source type called "${y}" already exists.`);
          ((a, c) => {
            ht[a] = c;
          })(y, e);
        })), m.clearPrewarmedResources = function() {
          const y = _t;
          y && (y.isPreloaded() && y.numActive() === 1 ? (y.release(dt), _t = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, m.createTileMesh = vc, m.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, m.getRTLTextPluginStatus = function() {
          return Qr().getRTLTextPluginStatus();
        }, m.getVersion = function() {
          return od;
        }, m.getWorkerCount = function() {
          return Ft.workerCount;
        }, m.getWorkerUrl = function() {
          return s.a.WORKER_URL;
        }, m.importScriptInWorkers = function(y) {
          return zt().broadcast("IS", y);
        }, m.prewarm = function() {
          Qt().acquire(dt);
        }, m.setMaxParallelImageRequests = function(y) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = y;
        }, m.setRTLTextPlugin = function(y, e) {
          return Qr().setRTLTextPlugin(y, e);
        }, m.setWorkerCount = function(y) {
          Ft.workerCount = y;
        }, m.setWorkerUrl = function(y) {
          s.a.WORKER_URL = y;
        };
      }));
      var g = l;
      return g;
    }));
  })(Nf)), Nf.exports;
}
var Ps = _6();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const b6 = Symbol("map"), Ll = b6, ih = Symbol("isLoaded"), x6 = Symbol("isInitialized"), o1 = x6, e0 = Symbol("componentId"), t0 = Symbol("sourceId"), a1 = Symbol("sourceLayerRegistry"), w6 = Symbol("marker"), C6 = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function S6(r, i, l, d) {
  return (f) => l.emit(d, { type: f.type, map: i, component: r, event: f });
}
function k6(r, i) {
  const l = Ps.LngLat.convert(r), d = Ps.LngLat.convert(i);
  return l.lng === d.lng && l.lat === d.lat;
}
var fp = ((r) => (r.TOP_LEFT = "top-left", r.TOP_RIGHT = "top-right", r.BOTTOM_LEFT = "bottom-left", r.BOTTOM_RIGHT = "bottom-right", r))(fp || {});
const nh = Object.values(fp), Uy = /* @__PURE__ */ new Map(), P6 = Symbol("default");
function T6(r, i, l = P6) {
  var _a3;
  let d = Uy.get(l);
  return d || (d = n2({ isLoaded: false, isMounted: false, language: null }), Uy.set(l, d)), d.isLoaded = ((_a3 = i.value) == null ? void 0 : _a3.loaded()) || false, d.isMounted = false, d.component = r, d.map = i.value, d;
}
const s1 = ot({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (r) => r in fp }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(r, i) {
  const l = Xv(Qd()), d = Ss(), f = Ss(), g = Re(false), m = Re(false), s = /* @__PURE__ */ new Map(), C = T6(l, f, r.mapKey);
  Zr(Ll, f), Zr(ih, m), Zr(o1, g), Zr(e0, l.uid), Zr(t0, ""), Ht(() => r.bearing, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setBearing(D));
  }), Ht(() => r.bounds, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.fitBounds(D, r.fitBoundsOptions));
  }), Ht(() => r.center, (D) => {
    var _a3, _b2;
    const A = (_a3 = f.value) == null ? void 0 : _a3.getCenter();
    D && A && !k6(D, A) && ((_b2 = f.value) == null ? void 0 : _b2.setCenter(D));
  }), Ht(() => r.maxBounds, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setMaxBounds(D));
  }), Ht(() => r.maxPitch, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setMaxPitch(D));
  }), Ht(() => r.maxZoom, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setMaxZoom(D));
  }), Ht(() => r.minPitch, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setMinPitch(D));
  }), Ht(() => r.minZoom, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setMinZoom(D));
  }), Ht(() => r.pitch, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setPitch(D));
  }), Ht(() => r.renderWorldCopies, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setRenderWorldCopies(D));
  }), Ht(() => r.mapStyle, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setStyle(D));
  }), Ht(() => r.transformRequest, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setTransformRequest(D));
  }), Ht(() => r.zoom, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(D));
  }), Ht(() => r.zoom, (D) => {
    var _a3;
    D && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(D));
  });
  function P() {
    C.isMounted = true;
    const D = { ...r, style: r.mapStyle, container: d.value };
    for (const A of Object.keys(D)) D[A] === void 0 && delete D[A];
    if (f.value = Xv(new Ps.Map(D)), C.map = f.value, g.value = true, s.set("__load", () => (m.value = true, C.isLoaded = true)), f.value.on("load", s.get("__load")), s.set("__moveend", () => i.emit("update:center", f.value.getCenter())), f.value.on("moveend", s.get("__moveend")), s.set("__zoomend", () => i.emit("update:zoom", f.value.getZoom())), f.value.on("zoomend", s.get("__zoomend")), s.set("__pitchend", () => i.emit("update:pitch", f.value.getPitch())), f.value.on("pitchend", s.get("__pitchend")), s.set("__rotateend", () => i.emit("update:bearing", f.value.getBearing())), f.value.on("rotateend", s.get("__rotateend")), l.vnode.props) {
      for (const A of C6) if (l.vnode.props["onMap:" + A]) {
        const O = `map:${A}`, V = S6(l, f.value, i, O);
        s.set(A, V), f.value.on(A, V);
      }
    }
    f.value.getCanvas().addEventListener("webglcontextlost", F);
  }
  async function M() {
    C.isMounted = false, C.isLoaded = false, m.value = false, f.value && (f.value.getCanvas().removeEventListener("webglcontextlost", F), g.value = false, s.forEach((D, A) => {
      f.value.off(A.startsWith("__") ? A.substring(2) : A, D);
    }), f.value.remove());
  }
  function F() {
    M(), Vn(P);
  }
  return ji(P), Sn(M), i.expose({ map: f }), () => [B("div", { ref: d, style: { height: r.height, width: r.width } }), g.value && i.slots.default ? i.slots.default({}) : void 0];
}, render() {
  return null;
} });
function I6(r, i, l) {
  Ht(r, (d) => {
    var _a3, _b2;
    d && nh.indexOf(d) === -1 || (((_a3 = i.value) == null ? void 0 : _a3.hasControl(l)) && i.value.removeControl(l), (_b2 = i.value) == null ? void 0 : _b2.addControl(l, d));
  }, { immediate: true });
}
function pp(r, i) {
  const l = pr(Ll), d = pr(o1), f = Ss();
  return f.value = r(), I6(() => i.position, l, f.value), Sn(() => {
    var _a3;
    return d.value && ((_a3 = l.value) == null ? void 0 : _a3.removeControl(f.value));
  }), { control: f, map: l };
}
class M6 {
  constructor(i, l) {
    __publicField(this, "container");
    this.isAdded = i, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return fp.TOP_LEFT;
  }
  onAdd() {
    return Vn(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(i) {
    this.container.className = i;
  }
}
const Mf = ot({ name: "MglCustomControl", props: { position: { type: String, validator: (r) => nh.indexOf(r) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(r, { slots: i }) {
  const l = Re(false), { control: d } = pp(() => new M6(l, r.class), r);
  return Ht(() => r.class, () => d.value.setClasses(r.class)), () => {
    var _a3;
    return l.value ? B(k_, { to: d.value.container }, (_a3 = i.default) == null ? void 0 : _a3.call(i, {})) : jr("custom-component");
  };
}, render() {
  return null;
} }), l1 = ot({ name: "MglFullscreenControl", props: { position: { type: String, validator: (r) => nh.indexOf(r) !== -1 }, container: { type: Object, default: null } }, setup(r) {
  const { control: i, map: l } = pp(() => new Ps.FullscreenControl({ container: r.container || void 0 }), r);
  function d() {
    Vn(() => {
      var _a3;
      return (_a3 = l.value) == null ? void 0 : _a3.resize();
    });
  }
  i.value.on("fullscreenstart", d), i.value.on("fullscreenend", d), Sn(() => {
    i.value.off("fullscreenstart", d), i.value.off("fullscreenend", d);
  });
}, render() {
  return null;
} }), u1 = ot({ name: "MglNavigationControl", props: { position: { type: String, validator: (r) => nh.indexOf(r) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(r) {
  pp(() => new Ps.NavigationControl({ showCompass: r.showCompass, showZoom: r.showZoom, visualizePitch: r.visualizePitch }), r);
}, render() {
  return null;
} });
var c1 = ((r) => (r.IMPERIAL = "imperial", r.METRIC = "metric", r.NAUTICAL = "nautical", r))(c1 || {});
const E6 = Object.values(c1), d1 = ot({ name: "MglScaleControl", props: { position: { type: String, validator: (r) => nh.indexOf(r) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (r) => E6.indexOf(r) !== -1 } }, setup(r) {
  pp(() => new Ps.ScaleControl({ maxWidth: r.maxWidth, unit: r.unit }), r);
}, render() {
  return null;
} }), R6 = ot({ name: "MglMarker", emits: ["dragstart", "drag", "dragend", "update:coordinates"], props: { coordinates: { type: [Object, Array], required: true }, className: String, offset: [Object, Array], anchor: String, color: String, draggable: Boolean, clickTolerance: Number, rotation: Number, rotationAlignment: String, pitchAlignment: String, scale: Number, opacity: String, opacityWhenCovered: String, subpixelPositioning: { type: Boolean, default: false } }, setup(r, { slots: i, emit: l }) {
  const d = pr(Ll), f = Ss(), g = Re(), m = Re(false), s = /* @__PURE__ */ new Map();
  function C(P, M) {
    const F = (D) => {
      M && M(), l(P, D);
    };
    f.value.on(P, F), s.set(P, F);
  }
  return Zr(w6, f), ji(() => {
    const P = { ...r };
    i.marker && (P.element = g.value), f.value = new Ps.Marker(P), f.value.setLngLat(r.coordinates).addTo(d.value), C("dragstart"), C("drag", () => {
      var _a3;
      l("update:coordinates", (_a3 = f.value) == null ? void 0 : _a3.getLngLat());
    }), C("dragend", () => {
      var _a3;
      l("update:coordinates", (_a3 = f.value) == null ? void 0 : _a3.getLngLat());
    }), m.value = true;
  }), Ht(() => r.coordinates, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setLngLat(P);
  }, { deep: true }), Ht(() => r.draggable, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setDraggable(P);
  }), Ht(() => r.offset, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOffset(P || [0, 0]);
  }), Ht(() => r.pitchAlignment, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setPitchAlignment(P || "auto");
  }), Ht(() => r.rotation, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setRotation(P);
  }), Ht(() => r.rotationAlignment, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setRotationAlignment(P || "auto");
  }), Ht(() => r.opacity, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOpacity(P, r.opacityWhenCovered);
  }), Ht(() => r.opacityWhenCovered, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOpacity(r.opacity, P);
  }), Ht(() => r.subpixelPositioning, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setSubpixelPositioning(P);
  }), Ht(() => r.className, (P, M) => {
    var _a3, _b2;
    M && ((_a3 = f.value) == null ? void 0 : _a3.removeClassName(M)), P && ((_b2 = f.value) == null ? void 0 : _b2.addClassName(P));
  }), Sn(() => {
    var _a3;
    s.forEach((P, M) => {
      var _a4;
      (_a4 = f.value) == null ? void 0 : _a4.off(M, P);
    }), (_a3 = f.value) == null ? void 0 : _a3.remove();
  }), () => [B("div", i.default && m.value ? i.default({}) : void 0), B("div", { ref: g }, i.marker ? i.marker() : void 0)];
}, render() {
  return null;
} });
let A6 = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(i, l) {
    this.unmountHandlers.set(i, l);
  }
  unregisterUnmountHandler(i) {
    this.unmountHandlers.delete(i);
  }
  unmount() {
    this.unmountHandlers.forEach((i) => i());
  }
}, r0 = (_a = class {
  static genSourceOpts(i) {
    const l = { ...i };
    for (const d of Object.keys(l)) (l[d] === void 0 || d === "sourceId") && delete l[d];
    return l;
  }
  static getSourceRef(i, l) {
    const d = typeof l == "string", f = String(i) + (d ? l : "");
    let g = _a.REFS.get(f);
    return g || (g = Re(d ? null : void 0), _a.REFS.set(f, g)), g;
  }
}, __publicField(_a, "REFS", /* @__PURE__ */ new Map()), _a);
function D6(r, i, l) {
  const d = pr(Ll), f = pr(ih);
  function g() {
    f.value && (d.value.addSource(i.sourceId, r0.genSourceOpts(i)), r.value = d.value.getSource(i.sourceId));
  }
  return Ht(f, g, { immediate: true }), d.value.on("style.load", g), Sn(() => {
    f.value && (l.unmount(), d.value.removeSource(i.sourceId)), d.value.off("style.load", g);
  });
}
const z6 = ot({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(r, { slots: i }) {
  const l = pr(e0), d = r0.getSourceRef(l, r.sourceId), f = new A6(), g = { ...r, type: "geojson" };
  return Zr(t0, r.sourceId), Zr(a1, f), D6(d, g, f), Ht([i2(r.data) ? r.data : () => r.data, d], ([m, s]) => {
    s == null ? void 0 : s.setData(m || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [jr("GeoJSON Source"), d.value && i.default ? i.default({}) : void 0];
} }), Yo = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function Is() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function F6(r, i, l, d) {
  const f = { id: r, type: i, source: l.source || d, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const g of Object.keys(f)) f[g] === void 0 && delete f[g];
  return f;
}
function L6(r, i, l) {
  if (l.props) for (const d of Yo) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.on(d, i, l.props[f]);
  }
}
function B6(r, i, l) {
  if (l.props) for (const d of Yo) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.off(d, i, l.props[f]);
  }
}
function h1(r, i) {
  const l = pr(Ll), d = pr(ih), f = pr(a1);
  function g() {
    d.value && (i && B6(l.value, r, i.vnode), l.value.getLayer(r) && l.value.removeLayer(r));
  }
  f.registerUnmountHandler(r, g), Sn(() => {
    f.unregisterUnmountHandler(r), g();
  });
}
ot({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...Yo], setup(r) {
  const i = pr(Ll), l = pr(ih);
  return h1(r.layerId), Ht(() => r.layout, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setLayoutProperty(r.layerId, f, g);
  }), Ht(() => r.paint, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setPaintProperty(r.layerId, f, g);
  }), Ht(l, (d) => {
    d && i.value.addLayer({ id: r.layerId, type: "background", metadata: r.metadata, minzoom: r.minzoom, maxzoom: r.maxzoom, layout: r.layout, paint: r.paint }, r.before || void 0);
  }, { immediate: true }), () => jr("Background Layer");
} });
function Ms(r, i) {
  const l = pr(t0);
  if (!l && !i.source) return;
  const d = Qd(), f = pr(Ll), g = pr(ih), m = pr(e0), s = r0.getSourceRef(m, i.source || l);
  return h1(i.layerId, d), Ht(() => i.minzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Ht(() => i.maxzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Ht(() => i.layout, (C) => {
    if (C) for (const [P, M] of Object.entries(C)) f.value.setLayoutProperty(i.layerId, P, M);
  }, { deep: true }), Ht(() => i.paint, (C) => {
    if (C) for (const [P, M] of Object.entries(C)) f.value.setPaintProperty(i.layerId, P, M);
  }, { deep: true }), Ht(() => i.filter, (C) => f.value.setFilter(i.layerId, C), { deep: true }), Ht([g, s], ([C, P]) => {
    C && (P || P === void 0) && (f.value.addLayer(F6(i.layerId, r, i, l), i.before || void 0), L6(f.value, i.layerId, d.vnode));
  }, { immediate: true }), () => jr(`${r} Layer`);
}
ot({ name: "MglCircleLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("circle", r);
} });
ot({ name: "MglFillLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("fill", r);
} });
ot({ name: "MglFillExtrusionLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("fill-extrusion", r);
} });
ot({ name: "MglHeatmapLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("heatmap", r);
} });
ot({ name: "MglHillshadeLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("hillshade", r);
} });
const O6 = ot({ name: "MglLineLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("line", r);
} });
ot({ name: "MglRasterLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("raster", r);
} });
ot({ name: "MglSymbolLayer", props: Is(), emits: [...Yo], setup(r) {
  return Ms("symbol", r);
} });
const $6 = 0.3, j6 = ot({ __name: "MapCompass", props: es({ pitch: {}, size: {}, tracking: { type: Boolean } }, { bearing: { default: 0 }, bearingModifiers: {} }), emits: es(["toggleTracking"], ["update:bearing"]), setup(r, { emit: i }) {
  Fl((X) => ({ v1c8003b6: J(l).primaryColor, v11ea132b: J(l).modalColor, v1738aa7c: J(l).borderColor, v34c26392: J(l).textColorBase }));
  const l = ks(), d = r, f = tc(r, "bearing"), g = i, m = Me(() => `transform: rotate(${-f.value % 360}deg)`), s = Me(() => `transform: rotateX(${Math.min(45, d.pitch ? d.pitch : 0)}deg); transition: all 0.3s ease;`), C = Me(() => d.size || 40), P = Me(() => C.value / 6), M = Me(() => P.value / 2), F = Me(() => C.value / 8), D = Me(() => F.value / 2), A = Me(() => C.value / 3), O = Me(() => ({ width: `${P.value}px`, height: `${P.value}px`, top: "0px", left: `calc(50% - ${P.value / 2}px)`, transform: `translateY(-${M.value}px)` })), V = Me(() => ({ width: `${F.value}px`, height: `${F.value}px`, top: `calc(50% - ${F.value / 2}px)`, right: "0px", transform: `translateX(${D.value}px)` })), Y = Me(() => ({ width: `${F.value}px`, height: `${F.value}px`, bottom: "0px", left: `calc(50% - ${F.value / 2}px)`, transform: `translateY(${D.value}px)` })), W = Me(() => ({ width: `${F.value}px`, height: `${F.value}px`, top: `calc(50% - ${F.value / 2}px)`, left: "0px", transform: `translateX(-${D.value}px)` })), ee = Me(() => ({ height: `${A.value}px`, width: "100%", top: `calc(50% - ${A.value / 2}px)`, fontSize: `${A.value}px`, lineHeight: `${A.value}px` })), ie = Me(() => ({ width: `${C.value}px`, height: `${C.value}px` })), te = ["N", "E", "S", "W"], re = Me(() => {
    const X = f.value > 0 ? f.value : 360 + f.value;
    return te[Math.round(X % 360 / 90) % 4];
  });
  return ji(() => {
    const X = document.querySelector(".map-compass");
    X.onclick = () => {
      g("toggleTracking"), d.tracking || (f.value = 0);
    }, X && X.addEventListener("wheel", (Se) => {
      if (d.tracking) return;
      Se.preventDefault();
      const pe = (f.value + Se.deltaY * $6) % 360;
      f.value = Math.round(pe >= 0 ? pe : 360 + pe);
    });
  }), (X, Se) => (wt(), Xt("div", { style: In(s.value) }, [Pt("div", { class: qo(["map-compass", { "tracking-active": d.tracking }]), style: In(ie.value) }, [Pt("div", { class: "compass-panel", style: In(m.value) }, [Pt("div", { class: "pin north-pin", style: In(O.value) }, null, 4), Pt("div", { class: "pin east-pin", style: In(V.value) }, null, 4), Pt("div", { class: "pin south-pin", style: In(Y.value) }, null, 4), Pt("div", { class: "pin west-pin", style: In(W.value) }, null, 4)], 4), Pt("span", { class: "compass-orientation-text", style: In(ee.value) }, ur(re.value), 5)], 6)], 4));
} }), N6 = Qn(j6, [["__scopeId", "data-v-0f30b63f"]]);
function Cn() {
  return Cn = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) ({}).hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, Cn.apply(null, arguments);
}
var Mn;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(Mn || (Mn = {}));
const dn = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, zi = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount" }, Vf = 10;
function Hm(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function qy(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function Gy(r) {
  return !!(function(i) {
    return typeof i == "number" && !isNaN(new Date(i).valueOf());
  })(r);
}
const V6 = "Feature mode property does not match the mode being added to";
var oc;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(oc || (oc = {}));
const U6 = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class mp {
  get state() {
    return this._state;
  }
  set state(i) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(i) {
    if (typeof i != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = i;
  }
  registerBehaviors(i) {
  }
  constructor(i, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = U6, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = oc.Drawing, this.mode = "base", l || this.updateOptions(i);
  }
  updateOptions(i) {
    i != null && i.styles && (this.styles = Cn({}, this._styles, i.styles)), i != null && i.pointerDistance && (this.pointerDistance = i.pointerDistance), i != null && i.validation && (this.validate = i && i.validation), i != null && i.projection && (this.projection = i.projection), (i == null ? void 0 : i.pointerEvents) !== void 0 && (this.pointerEvents = i.pointerEvents);
  }
  allowPointerEvent(i, l) {
    return typeof i == "boolean" ? i : typeof i != "function" || i(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(i) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = i.store, this.store.registerOnChange(i.onChange), this.setDoubleClickToZoom = i.setDoubleClickToZoom, this.project = i.project, this.unproject = i.unproject, this.onSelect = i.onSelect, this.onDeselect = i.onDeselect, this.setCursor = i.setCursor, this.onStyleChange = i.onChange, this.onFinish = i.onFinish, this.coordinatePrecision = i.coordinatePrecision, this.registerBehaviors({ mode: i.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: i.coordinatePrecision, projection: this.projection });
  }
  validateFeature(i) {
    return this.performFeatureValidation(i);
  }
  afterFeatureAdded(i) {
  }
  afterFeatureUpdated(i) {
  }
  performFeatureValidation(i) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(d, f) {
      let g;
      if (Hm(d)) if (d.id == null) g = "Feature has no id";
      else if (typeof d.id != "string" && typeof d.id != "number") g = "Feature must be string or number as per GeoJSON spec";
      else if (f(d.id)) if (Hm(d.geometry)) if (Hm(d.properties)) if (typeof d.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(d.geometry.type)) if (Array.isArray(d.geometry.coordinates)) {
        if (!d.properties.mode || typeof d.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else g = "Feature coordinates is not an array";
      else g = "Feature is not Point, LineString or Polygon";
      else g = "Feature has no properties";
      else g = "Feature has no geometry";
      else g = "Feature must match the id strategy (default is UUID4)";
      else g = "Feature is not object";
      return g ? { valid: false, reason: g } : { valid: true };
    })(i, this.store.idStrategy.isValidId);
    if (this.validate) {
      const d = this.validate(i, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional });
      return { valid: l.valid && d.valid, reason: d.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(i, l) {
    const d = this.performFeatureValidation(i);
    return d.valid ? i.properties.mode !== this.mode ? { valid: false, reason: V6 } : l(i) : { valid: false, reason: d.reason };
  }
  onFinish(i, l) {
  }
  onDeselect(i) {
  }
  onSelect(i) {
  }
  onKeyDown(i) {
  }
  onKeyUp(i) {
  }
  onMouseMove(i) {
  }
  onClick(i) {
  }
  onDragStart(i, l) {
  }
  onDrag(i, l) {
  }
  onDragEnd(i, l) {
  }
  getHexColorStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getNumericStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getStylingValue(i, l, d) {
    return i === void 0 ? l : typeof i == "function" ? i(d) : i;
  }
}
class q6 extends mp {
  constructor(...i) {
    super(...i), this.type = oc.Select;
  }
}
function rs(r, i) {
  const l = (P) => P * Math.PI / 180, d = l(r[1]), f = l(r[0]), g = l(i[1]), m = g - d, s = l(i[0]) - f, C = Math.sin(m / 2) * Math.sin(m / 2) + Math.cos(d) * Math.cos(g) * Math.sin(s / 2) * Math.sin(s / 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C)) * 6371e3 / 1e3;
}
const f1 = 63710088e-1;
function Yn(r) {
  return r % 360 * Math.PI / 180;
}
function G6(r) {
  return r / 6371.0088;
}
function ac(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function Fi(r, i = 9) {
  const l = Math.pow(10, i);
  return Math.round(r * l) / l;
}
const Wy = 57.29577951308232, Zy = 0.017453292519943295, Xf = 6378137, Di = (r, i) => ({ x: r === 0 ? 0 : r * Zy * Xf, y: i === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + i * Zy / 2)) * Xf }), sc = (r, i) => ({ lng: r === 0 ? 0 : Wy * (r / Xf), lat: i === 0 ? 0 : (2 * Math.atan(Math.exp(i / Xf)) - Math.PI / 2) * Wy });
function W6(r) {
  let i;
  if (r.geometry.type === "Polygon") i = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    i = [r.geometry.coordinates];
  }
  const l = [];
  for (let g = 0; g < i.length; g++) for (let m = 0; m < i[g].length - 1; m++) for (let s = 0; s < i.length; s++) for (let C = 0; C < i[s].length - 1; C++) f(g, m, s, C);
  return l.length > 0;
  function d(g) {
    return g < 0 || g > 1;
  }
  function f(g, m, s, C) {
    const P = i[g][m], M = i[g][m + 1], F = i[s][C], D = i[s][C + 1], A = (function(Y, W, ee, ie) {
      if (Ef(Y, ee) || Ef(Y, ie) || Ef(W, ee) || Ef(ie, ee)) return null;
      const te = Y[0], re = Y[1], X = W[0], Se = W[1], pe = ee[0], oe = ee[1], fe = ie[0], _e = ie[1], qe = (te - X) * (oe - _e) - (re - Se) * (pe - fe);
      return qe === 0 ? null : [((te * Se - re * X) * (pe - fe) - (te - X) * (pe * _e - oe * fe)) / qe, ((te * Se - re * X) * (oe - _e) - (re - Se) * (pe * _e - oe * fe)) / qe];
    })(P, M, F, D);
    if (A === null) return;
    let O, V;
    O = M[0] !== P[0] ? (A[0] - P[0]) / (M[0] - P[0]) : (A[1] - P[1]) / (M[1] - P[1]), V = D[0] !== F[0] ? (A[0] - F[0]) / (D[0] - F[0]) : (A[1] - F[1]) / (D[1] - F[1]), d(O) || d(V) || (A.toString(), l.push(A));
  }
}
function Ef(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function i0(r, i) {
  return Hy(r[0]) <= i && Hy(r[1]) <= i;
}
function p1(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (l = r[0]) >= -180 && l <= 180 && (i = r[1]) >= -90 && i <= 90;
  var i, l;
}
function Hy(r) {
  let i = 1, l = 0;
  for (; Math.round(r * i) / i !== r; ) i *= 10, l++;
  return l;
}
const ma = (r, i) => {
  const { x: l, y: d } = r, { x: f, y: g } = i, m = f - l, s = g - d;
  return Math.sqrt(s * s + m * m);
};
class eo {
  constructor({ store: i, mode: l, project: d, unproject: f, pointerDistance: g, coordinatePrecision: m, projection: s }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = i, this.mode = l, this.project = d, this.unproject = f, this.pointerDistance = g, this.coordinatePrecision = m, this.projection = s;
  }
}
function m1({ unproject: r, point: i, pointerDistance: l }) {
  const d = l / 2, { x: f, y: g } = i;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(f - d, g - d), r(f + d, g - d), r(f + d, g + d), r(f - d, g + d), r(f - d, g - d)].map((m) => [m.lng, m.lat])] } };
}
class Yf extends eo {
  constructor(i) {
    super(i);
  }
  create(i) {
    const { containerX: l, containerY: d } = i;
    return m1({ unproject: this.unproject, point: { x: l, y: d }, pointerDistance: this.pointerDistance });
  }
}
class Kf extends eo {
  constructor(i) {
    super(i);
  }
  measure(i, l) {
    const { x: d, y: f } = this.project(l[0], l[1]);
    return ma({ x: d, y: f }, { x: i.containerX, y: i.containerY });
  }
}
class Rg extends eo {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => this.getSnappable(f, (g) => !!(g.properties && g.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (f, g) => this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode && m.id !== g)).coordinate, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      s.forEach((C, P) => {
        const M = this.pixelDistance.measure(i, C);
        M < g.minDist && M < this.pointerDistance && (g.coordinate = C, g.minDist = M, g.featureId = m.id, g.featureCoordinateIndex = P);
      });
    }), g;
  }
}
function Xy(r, i, l) {
  const d = Yn(r[0]), f = Yn(r[1]), g = Yn(l), m = G6(i), s = Math.asin(Math.sin(f) * Math.cos(m) + Math.cos(f) * Math.sin(m) * Math.cos(g));
  return [ac(d + Math.atan2(Math.sin(g) * Math.sin(m) * Math.cos(f), Math.cos(m) - Math.sin(f) * Math.sin(s))), ac(s)];
}
function Yy(r, i) {
  const l = Yn(r[0]), d = Yn(i[0]), f = Yn(r[1]), g = Yn(i[1]), m = Math.sin(d - l) * Math.cos(g), s = Math.cos(f) * Math.sin(g) - Math.sin(f) * Math.cos(g) * Math.cos(d - l);
  return ac(Math.atan2(m, s));
}
function Z6({ x: r, y: i }, { x: l, y: d }) {
  const f = l - r, g = d - i;
  if (f === 0 && g === 0) return 0;
  let m = Math.atan2(g, f);
  return m *= 180 / Math.PI, m > 180 ? m -= 360 : m < -180 && (m += 360), m;
}
function H6(r, i, l) {
  const d = [], f = r.length;
  let g, m, s, C = 0;
  for (let M = 0; M < r.length && !(i >= C && M === r.length - 1); M++) {
    if (C > i && d.length === 0) {
      if (g = i - C, !g) return d.push(r[M]), d;
      m = Yy(r[M], r[M - 1]) - 180, s = Xy(r[M], g, m), d.push(s);
    }
    if (C >= l) return g = l - C, g ? (m = Yy(r[M], r[M - 1]) - 180, s = Xy(r[M], g, m), d.push(s), d) : (d.push(r[M]), d);
    if (C >= i && d.push(r[M]), M === r.length - 1) return d;
    C += rs(r[M], r[M + 1]);
  }
  if (C < i && r.length === f) throw new Error("Start position is beyond line");
  const P = r[r.length - 1];
  return [P, P];
}
function Rf(r) {
  return r * (Math.PI / 180);
}
function Ky(r) {
  return r * (180 / Math.PI);
}
class X6 extends eo {
  constructor(i) {
    super(i), this.config = void 0, this.config = i;
  }
  generateInsertionCoordinates(i, l, d) {
    const f = [i, l];
    let g = 0;
    for (let P = 0; P < f.length - 1; P++) g += rs(f[0], f[1]);
    if (g <= d) return f;
    let m = g / d - 1;
    Number.isInteger(m) || (m = Math.floor(m) + 1);
    const s = [];
    for (let P = 0; P < m; P++) {
      const M = H6(f, d * P, d * (P + 1));
      s.push(M);
    }
    const C = [];
    for (let P = 0; P < s.length; P++) C.push(s[P][1]);
    return this.limitCoordinates(C);
  }
  generateInsertionGeodesicCoordinates(i, l, d) {
    const f = rs(i, l), g = (function(m, s, C) {
      const P = [], M = Rf(m[1]), F = Rf(m[0]), D = Rf(s[1]), A = Rf(s[0]);
      C += 1;
      const O = 2 * Math.asin(Math.sqrt(Math.sin((D - M) / 2) ** 2 + Math.cos(M) * Math.cos(D) * Math.sin((A - F) / 2) ** 2));
      if (O === 0 || isNaN(O)) return P;
      for (let V = 0; V <= C; V++) {
        const Y = V / C, W = Math.sin((1 - Y) * O) / Math.sin(O), ee = Math.sin(Y * O) / Math.sin(O), ie = W * Math.cos(M) * Math.cos(F) + ee * Math.cos(D) * Math.cos(A), te = W * Math.cos(M) * Math.sin(F) + ee * Math.cos(D) * Math.sin(A), re = W * Math.sin(M) + ee * Math.sin(D);
        if (isNaN(ie) || isNaN(te) || isNaN(re)) continue;
        const X = Math.atan2(re, Math.sqrt(ie ** 2 + te ** 2)), Se = Math.atan2(te, ie);
        isNaN(X) || isNaN(Se) || P.push([Ky(Se), Ky(X)]);
      }
      return P.slice(1, -1);
    })(i, l, Math.floor(f / d));
    return this.limitCoordinates(g);
  }
  limitCoordinates(i) {
    return i.map((l) => [Fi(l[0], this.config.coordinatePrecision), Fi(l[1], this.config.coordinatePrecision)]);
  }
}
function Y6(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function K6(r, i) {
  if (r.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < r.geometry.coordinates.length; l++) {
    if (!p1(r.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!i0(r.geometry.coordinates[l], i)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function Jy(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function xl(r, i) {
  const l = (function(d, f) {
    const [g, m, s] = d, [C, P, M] = f;
    return g * C + m * P + s * M;
  })(r, i) / (Jy(r) * Jy(i));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function Xm(r) {
  const i = Yn(r[1]), l = Yn(r[0]);
  return [Math.cos(i) * Math.cos(l), Math.cos(i) * Math.sin(l), Math.sin(i)];
}
function wl(r) {
  const [i, l, d] = r, f = ac(Math.asin(d));
  return [ac(Math.atan2(l, i)), f];
}
function J6(r, i, l) {
  const d = Xm(r), f = Xm(i), g = Xm(l), [m, s, C] = g, [P, M, F] = (function(_e, qe) {
    const [Ve, Qe, ut] = _e, [gt, yt, lt] = qe;
    return [Qe * lt - ut * yt, ut * gt - Ve * lt, Ve * yt - Qe * gt];
  })(d, f), D = M * C - F * s, A = F * m - P * C, O = P * s - M * m, V = O * M - A * F, Y = D * F - O * P, W = A * P - D * M, ee = 1 / Math.sqrt(Math.pow(V, 2) + Math.pow(Y, 2) + Math.pow(W, 2)), ie = [V * ee, Y * ee, W * ee], te = [-1 * V * ee, -1 * Y * ee, -1 * W * ee], re = xl(d, f), X = xl(d, ie), Se = xl(f, ie), pe = xl(d, te), oe = xl(f, te);
  let fe;
  return fe = X < pe && X < oe || Se < pe && Se < oe ? ie : te, xl(d, fe) > re || xl(f, fe) > re ? rs(wl(fe), wl(d)) <= rs(wl(fe), wl(f)) ? [wl(d), true, false] : [wl(f), false, true] : [wl(fe), false, false];
}
function Q6(r, i, l) {
  const d = i.x - r.x, f = i.y - r.y, g = Math.max(0, Math.min(1, ((l.x - r.x) * d + (l.y - r.y) * f) / (d * d + f * f)));
  return { x: r.x + g * d, y: r.y + g * f };
}
class g1 extends eo {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => {
      const g = this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode));
      return g.coordinate ? [Fi(g.coordinate[0], this.config.coordinatePrecision), Fi(g.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (f, g) => {
      const m = this.getSnappable(f, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== g));
      return m.coordinate ? [Fi(m.coordinate[0], this.config.coordinatePrecision), Fi(m.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      const C = [];
      for (let D = 0; D < s.length - 1; D++) C.push([s[D], s[D + 1]]);
      let P;
      const M = [i.lng, i.lat];
      if (this.config.projection === "web-mercator" ? P = (function(D, A) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, Y = 0;
        for (let W of A) {
          const ee = W[0], ie = W[1];
          let te, re = 1 / 0;
          const X = Di(ee[0], ee[1]), Se = Di(ie[0], ie[1]), pe = Di(D[0], D[1]);
          if (ee[0] === D[0] && ee[1] === D[1]) te = ee;
          else if (ie[0] === D[0] && ie[1] === D[1]) te = ie;
          else {
            const { x: oe, y: fe } = Q6(X, Se, pe), { lng: _e, lat: qe } = sc(oe, fe);
            te = [_e, qe];
          }
          te && (re = ma(pe, Di(te[0], te[1])), re < V && (O = te, V = re, Y = A.indexOf(W)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, lineIndex: Y, distance: V };
      })(M, C) : this.config.projection === "globe" && (P = (function(D, A) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, Y = 0;
        for (let W of A) {
          const ee = W[0], ie = W[1];
          let te, re = 1 / 0;
          ee[0] === D[0] && ee[1] === D[1] ? te = ee : ie[0] === D[0] && ie[1] === D[1] ? te = ie : [te] = J6(ee, ie, D), te && (re = rs(D, te), re < V && (O = te, V = re, Y = A.indexOf(W)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, distance: V, lineIndex: Y };
      })(M, C)), !P) return;
      const F = this.pixelDistance.measure(i, P.coordinate);
      F < g.minDistance && F < this.pointerDistance && (g.featureId = m.id, g.coordinate = [Fi(P.coordinate[0], this.config.coordinatePrecision), Fi(P.coordinate[1], this.config.coordinatePrecision)], g.featureCoordinateIndex = P.lineIndex, g.minDistance = F);
    }), g;
  }
}
const eI = { cancel: "Escape", finish: "Enter" }, tI = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class rI extends mp {
  constructor(i) {
    super(i, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = eI, this.snapping = void 0, this.cursors = tI, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = Cn({}, this.cursors, i.cursors)), i != null && i.snapping && (this.snapping = i.snapping), (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : i != null && i.keyEvents && (this.keyEvents = Cn({}, this.keyEvents, i.keyEvents)), i != null && i.insertCoordinates && (this.insertCoordinates = i.insertCoordinates), i && i.editable && (this.editable = i.editable);
  }
  updateSnappedCoordinate(i) {
    const l = this.snapCoordinate(i);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [d] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [zi.SNAPPING_POINT]: true } }]);
        this.snappedPointId = d;
      }
      i.lng = l[0], i.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const i = this.store.getGeometryCopy(this.currentId);
    i.coordinates.pop(), this.updateGeometries([...i.coordinates], void 0, Mn.Commit), this.store.updateProperty([{ id: this.currentId, property: zi.CURRENTLY_DRAWING, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(i, l, d) {
    if (!this.currentId) return;
    const f = { type: "LineString", coordinates: i };
    if (this.validate && !this.validate({ type: "Feature", geometry: f }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: d }).valid) return;
    const g = [{ id: this.currentId, geometry: f }];
    this.closingPointId && l && g.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), d === "commit" && (this.lastCommittedCoordinates = f.coordinates), this.store.updateGeometry(g);
  }
  generateInsertCoordinates(i, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const d = rs(i, l) / (this.insertCoordinates.value + 1);
    let f = [];
    return this.projection === "globe" ? f = this.insertPoint.generateInsertionGeodesicCoordinates(i, l, d) : this.projection === "web-mercator" && (f = this.insertPoint.generateInsertionCoordinates(i, l, d)), f;
  }
  createLine(i) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [i, i] }, properties: { mode: this.mode, [zi.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [i, i], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(i) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [d] = this.store.create([{ geometry: { type: "Point", coordinates: [...i] }, properties: { mode: this.mode, [zi.CLOSING_POINT]: true } }]);
    this.closingPointId = d, this.setCursor(this.cursors.close);
    const f = [...l, i];
    this.updateGeometries(f, void 0, Mn.Commit), this.currentCoordinate++;
  }
  updateToLine(i, l) {
    if (!this.currentId) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates, [f, g] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : d[d.length - 2], { x: m, y: s } = this.project(f, g);
    if (ma({ x: m, y: s }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const C = [...d, i];
    this.updateGeometries(C, d[d.length - 1], Mn.Commit), this.currentCoordinate++;
  }
  registerBehaviors(i) {
    this.coordinateSnapping = new Rg(i, new Kf(i), new Yf(i)), this.insertPoint = new X6(i), this.clickBoundingBox = new Yf(i), this.pixelDistance = new Kf(i), this.lineSnapping = new g1(i, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new Rg(i, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(i) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = i;
    const l = this.updateSnappedCoordinate(i) || [i.lng, i.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates;
    if (d.pop(), this.closingPointId) {
      const [g, m] = d[d.length - 1], { x: s, y: C } = this.project(g, m);
      ma({ x: s, y: C }, { x: i.containerX, y: i.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let f = [...d, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const g = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], m = l;
      if (!Y6(g, m)) {
        const s = this.generateInsertCoordinates(g, m);
        f = [...this.lastCommittedCoordinates.slice(0, -1), ...s, l];
      }
    }
    this.updateGeometries(f, void 0, Mn.Provisional);
  }
  onRightClick(i) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: d } = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
    if (!l || d === void 0) return;
    const f = this.store.getGeometryCopy(l);
    let g;
    if (f.type === "LineString" && (g = f.coordinates, !(g.length <= 2))) {
      if (g.splice(d, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: f }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(i) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(i) || [i.lng, i.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: i.containerX, y: i.containerY });
  }
  onClick(i) {
    (i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(i), this.mouseMove = false, i.button === "right" ? this.onRightClick(i) : i.button === "left" && this.onLeftClick(i));
  }
  onKeyDown() {
  }
  onKeyUp(i) {
    i.key === this.keyEvents.cancel && this.cleanUp(), i.key === this.keyEvents.finish && this.close();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.editable) return;
    let d;
    if (this.state === "started") {
      const f = this.lineSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      f.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = f.featureCoordinateIndex, this.editedFeatureId = f.featureId, d = f.coordinate);
      const g = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      g.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = g.featureCoordinateIndex, this.editedFeatureId = g.featureId, d = g.coordinate);
    }
    if (this.editedFeatureId && d) {
      if (!this.editedPointId) {
        const [f] = this.store.create([{ geometry: { type: "Point", coordinates: d }, properties: { mode: this.mode, [zi.EDITED]: true } }]);
        this.editedPointId = f;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const d = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? d.coordinates[this.editedFeatureCoordinateIndex] = [i.lng, i.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, d.coordinates.splice(this.editedInsertIndex, 0, [i.lng, i.lat]), this.editedFeatureCoordinateIndex++);
    const f = { type: "LineString", coordinates: d.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: f, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: f }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: zi.EDITED, value: true }]));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: zi.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const i = this.currentId, l = this.closingPointId, d = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      i !== void 0 && this.store.delete([i]), d !== void 0 && this.store.delete([d]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "LineString" && i.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, i), l.zIndex = Vf, l;
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = i.properties[zi.CLOSING_POINT];
      return l.pointColor = this.getHexColorStylingValue(d ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, i), l.pointWidth = this.getNumericStylingValue(d ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, i), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => K6(l, this.coordinatePrecision));
  }
  lineStringFilter(i) {
    return !!(i.geometry.type === "LineString" && i.properties && i.properties.mode === this.mode);
  }
  snapCoordinate(i) {
    var l, d, f;
    let g;
    if ((l = this.snapping) != null && l.toLine) {
      let m;
      m = this.currentId ? this.lineSnapping.getSnappableCoordinate(i, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(i), m && (g = m);
    }
    return (d = this.snapping) != null && d.toCoordinate && (g = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(i, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(i)), (f = this.snapping) != null && f.toCustom && (g = this.snapping.toCustom(i, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), g;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === i.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const iI = "Feature is not a Point", nI = "Feature has invalid coordinates", oI = "Feature has coordinates with excessive precision";
function aI(r, i) {
  return r.geometry.type !== "Point" ? { valid: false, reason: iI } : p1(r.geometry.coordinates) ? i0(r.geometry.coordinates, i) ? { valid: true } : { valid: false, reason: oI } : { valid: false, reason: nI };
}
const sI = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class lI extends mp {
  constructor(i) {
    super(i, true), this.mode = "point", this.cursors = sI, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = Cn({}, this.cursors, i.cursors)), i != null && i.editable && (this.editable = i.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(i, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, i)) {
      if (this.editable) {
        const d = this.getNearestPointFeature(i);
        this.editedFeatureId = d == null ? void 0 : d.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, i) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [i.lng, i.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: zi.EDITED, value: true }])));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: zi.EDITED, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(i) {
    this.pixelDistance = new Kf(i), this.clickBoundingBox = new Yf(i);
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = !!(i.id && this.editedFeatureId === i.id);
      l.pointWidth = this.getNumericStylingValue(d ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(d ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, i), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => aI(l, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const l = { type: "Point", coordinates: [i.lng, i.lat] }, d = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: d }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid) return;
    const [f] = this.store.create([{ geometry: l, properties: d }]);
    this.onFinish(f, { mode: this.mode, action: "draw" });
  }
  onRightClick(i) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(i);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(i) {
    const l = this.clickBoundingBox.create(i), d = this.store.search(l);
    let f, g = 1 / 0;
    for (let m = 0; m < d.length; m++) {
      const s = d[m];
      if (s.geometry.type !== "Point" || s.properties.mode !== this.mode) continue;
      const C = this.pixelDistance.measure(i, s.geometry.coordinates);
      C > g || C > this.pointerDistance || (g = C, f = s);
    }
    return f;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class uI extends eo {
  constructor(i) {
    super(i);
  }
  createOrUpdate(i) {
    const l = this.store.getGeometryCopy(i), d = this.store.getPropertiesCopy(i);
    let f;
    if (l.type === "Polygon") f = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      f = l.coordinates;
    }
    const g = this.store.getPropertiesCopy(i), m = g.coordinatePointIds;
    if (m) if (m && m.every((s) => this.store.has(s))) {
      const s = g.coordinatePointIds, C = s.map((P) => this.store.getGeometryCopy(P).coordinates);
      if (s.length !== f.length) {
        this.deleteCoordinatePoints(s);
        const P = this.createPoints(f, d.mode, i);
        this.setFeatureCoordinatePoints(i, P);
      } else f.forEach((P, M) => {
        P[0] === C[M][0] && P[1] === C[M][1] || this.store.updateGeometry([{ id: s[M], geometry: { type: "Point", coordinates: P } }]);
      });
    } else {
      const s = m.filter((P) => this.store.has(P));
      s.length && this.deleteCoordinatePoints(s);
      const C = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, C);
    }
    else {
      const s = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, s);
    }
  }
  deletePointsByFeatureIds(i) {
    for (const l of i) this.deleteIfPresent(l);
  }
  getUpdated(i, l) {
    const d = this.store.getPropertiesCopy(i);
    if (d.coordinatePointIds) return d.coordinatePointIds.map((f, g) => ({ id: f, geometry: Cn({}, this.store.getGeometryCopy(f), { coordinates: l[g] }) }));
  }
  createPoints(i, l, d) {
    return this.store.create(i.map((f, g) => ({ geometry: { type: "Point", coordinates: f }, properties: { mode: l, [zi.COORDINATE_POINT]: true, [zi.COORDINATE_POINT_FEATURE_ID]: d, index: g } })));
  }
  setFeatureCoordinatePoints(i, l) {
    this.store.updateProperty([{ id: i, property: zi.COORDINATE_POINT_IDS, value: l }]);
  }
  deleteCoordinatePoints(i) {
    const l = i.filter((d) => this.store.has(d));
    this.store.delete(l);
  }
  deleteIfPresent(i) {
    const l = this.store.getPropertiesCopy(i).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(i, null));
  }
}
function Ag(r, i) {
  const l = r, d = i, f = Yn(l[1]), g = Yn(d[1]);
  let m = Yn(d[0] - l[0]);
  m > Math.PI && (m -= 2 * Math.PI), m < -Math.PI && (m += 2 * Math.PI);
  const s = Math.log(Math.tan(g / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)), C = (ac(Math.atan2(m, s)) + 360) % 360;
  return C > 180 ? -(360 - C) : C;
}
function v1(r, i, l) {
  let d = i;
  i < 0 && (d = -Math.abs(d));
  const f = d / f1, g = r[0] * Math.PI / 180, m = Yn(r[1]), s = Yn(l), C = f * Math.cos(s);
  let P = m + C;
  Math.abs(P) > Math.PI / 2 && (P = P > 0 ? Math.PI - P : -Math.PI - P);
  const M = Math.log(Math.tan(P / 2 + Math.PI / 4) / Math.tan(m / 2 + Math.PI / 4)), F = Math.abs(M) > 1e-11 ? C / M : Math.cos(m), D = [(180 * (g + f * Math.sin(s) / F) / Math.PI + 540) % 360 - 180, 180 * P / Math.PI];
  return D[0] += D[0] - r[0] > 180 ? -360 : r[0] - D[0] > 180 ? 360 : 0, D;
}
function cI(r, i, l, d, f) {
  const g = d(r[0], r[1]), m = d(i[0], i[1]), { lng: s, lat: C } = f((g.x + m.x) / 2, (g.y + m.y) / 2);
  return [Fi(s, l), Fi(C, l)];
}
function dI(r, i, l) {
  const d = v1(r, 1e3 * rs(r, i) / 2, Ag(r, i));
  return [Fi(d[0], l), Fi(d[1], l)];
}
function Qy({ featureCoords: r, precision: i, unproject: l, project: d, projection: f }) {
  const g = [];
  for (let m = 0; m < r.length - 1; m++) {
    let s;
    if (f === "web-mercator") s = cI(r[m], r[m + 1], i, d, l);
    else {
      if (f !== "globe") throw new Error("Invalid projection");
      s = dI(r[m], r[m + 1], i);
    }
    g.push(s);
  }
  return g;
}
class hI extends eo {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = i, this.selectionPointBehavior = l, this.coordinatePointBehavior = d;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(i) {
  }
  insert(i, l, d) {
    const f = this.store.getGeometryCopy(l), { midPointFeatureId: g, midPointSegment: m } = this.store.getPropertiesCopy(l), s = this.store.getGeometryCopy(g), C = s.type === "Polygon" ? s.coordinates[0] : s.coordinates;
    C.splice(m + 1, 0, f.coordinates), s.coordinates = s.type === "Polygon" ? [C] : C, this.store.updateGeometry([{ id: g, geometry: s }]), this.store.getPropertiesCopy(i)[zi.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(i), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(C, g, d), this.selectionPointBehavior.create(C, s.type, g);
  }
  create(i, l, d) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(f, g, m, s, C, P) {
      return Qy({ featureCoords: f, precision: m, project: s, unproject: C, projection: P }).map((M, F) => ({ geometry: { type: "Point", coordinates: M }, properties: g(F) }));
    })(i, (f) => ({ mode: this.mode, [dn.MID_POINT]: true, midPointSegment: f, midPointFeatureId: l }), d, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(i) {
    if (this._midPoints.length !== 0) return Qy({ featureCoords: i, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, d) => ({ id: this._midPoints[d], geometry: { type: "Point", coordinates: l } }));
  }
}
class fI extends eo {
  constructor(i) {
    super(i), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(i) {
  }
  create(i, l, d) {
    this._selectionPoints = this.store.create((function(f, g, m) {
      const s = [], C = g === "Polygon" ? f.length - 1 : f.length;
      for (let P = 0; P < C; P++) s.push({ geometry: { type: "Point", coordinates: f[P] }, properties: m(P) });
      return s;
    })(i, l, (f) => ({ mode: this.mode, index: f, [dn.SELECTION_POINT]: true, [dn.SELECTION_POINT_FEATURE_ID]: d })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(i) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, d) => ({ id: l, geometry: { type: "Point", coordinates: i[d] } }));
  }
  getOneUpdated(i, l) {
    if (this._selectionPoints[i] !== void 0) return { id: this._selectionPoints[i], geometry: { type: "Point", coordinates: l } };
  }
}
function y1(r, i) {
  let l = false;
  for (let m = 0, s = i.length; m < s; m++) {
    const C = i[m];
    for (let P = 0, M = C.length, F = M - 1; P < M; F = P++) (f = C[P])[1] > (d = r)[1] != (g = C[F])[1] > d[1] && d[0] < (g[0] - f[0]) * (d[1] - f[1]) / (g[1] - f[1]) + f[0] && (l = !l);
  }
  var d, f, g;
  return l;
}
const Dg = (r, i, l) => {
  const d = (g) => g * g, f = (g, m) => d(g.x - m.x) + d(g.y - m.y);
  return Math.sqrt(((g, m, s) => {
    const C = f(m, s);
    if (C === 0) return f(g, m);
    let P = ((g.x - m.x) * (s.x - m.x) + (g.y - m.y) * (s.y - m.y)) / C;
    return P = Math.max(0, Math.min(1, P)), f(g, { x: m.x + P * (s.x - m.x), y: m.y + P * (s.y - m.y) });
  })(r, i, l));
};
class pI extends eo {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = i, this.createClickBoundingBox = l, this.pixelDistance = d;
  }
  find(i, l) {
    let d, f, g, m, s = 1 / 0, C = 1 / 0, P = 1 / 0;
    const M = this.createClickBoundingBox.create(i), F = this.store.search(M);
    for (let D = 0; D < F.length; D++) {
      const A = F[D], O = A.geometry;
      if (O.type === "Point") {
        if (A.properties.selectionPoint || A.properties.coordinatePoint || !l && A.properties[dn.MID_POINT]) continue;
        const V = this.pixelDistance.measure(i, O.coordinates);
        A.properties[dn.MID_POINT] && V < this.pointerDistance && V < P ? (P = V, g = A) : !A.properties[dn.MID_POINT] && V < this.pointerDistance && V < s && (s = V, d = A);
      } else if (O.type === "LineString") {
        if (d) continue;
        for (let V = 0; V < O.coordinates.length - 1; V++) {
          const Y = O.coordinates[V], W = O.coordinates[V + 1], ee = Dg({ x: i.containerX, y: i.containerY }, this.project(Y[0], Y[1]), this.project(W[0], W[1]));
          ee < this.pointerDistance && ee < C && (C = ee, f = A);
        }
      } else if (O.type === "Polygon") {
        if (d || f) continue;
        y1([i.lng, i.lat], O.coordinates) && (m = A);
      }
    }
    return { clickedFeature: d || f || m, clickedMidPoint: g };
  }
}
class mI extends eo {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = i, this.featuresAtCursorEvent = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  startDragging(i, l) {
    this.draggedFeatureId = l, this.dragPosition = [i.lng, i.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(i, l) {
    const { clickedFeature: d } = this.featuresAtCursorEvent.find(i, true);
    return !(!d || d.id !== l);
  }
  drag(i, l) {
    if (!this.draggedFeatureId) return;
    const d = this.store.getGeometryCopy(this.draggedFeatureId), f = [i.lng, i.lat];
    if (d.type === "Polygon" || d.type === "LineString") {
      let g, m;
      if (d.type === "Polygon" ? (g = d.coordinates[0], m = g.length - 1) : (g = d.coordinates, m = g.length), !this.dragPosition) return false;
      for (let M = 0; M < m; M++) {
        const F = g[M];
        let D, A;
        if (this.config.projection === "web-mercator") {
          const O = Di(this.dragPosition[0], this.dragPosition[1]), V = Di(f[0], f[1]), Y = Di(F[0], F[1]), W = { x: O.x - V.x, y: O.y - V.y }, ee = Y.x - W.x, ie = Y.y - W.y, { lng: te, lat: re } = sc(ee, ie);
          D = te, A = re;
        } else {
          const O = [this.dragPosition[0] - f[0], this.dragPosition[1] - f[1]];
          D = F[0] - O[0], A = F[1] - O[1];
        }
        if (D = Fi(D, this.config.coordinatePrecision), A = Fi(A, this.config.coordinatePrecision), D > 180 || D < -180 || A > 90 || A < -90) return false;
        g[M] = [D, A];
      }
      d.type === "Polygon" && (g[g.length - 1] = [g[0][0], g[0][1]]);
      const s = this.selectionPoints.getUpdated(g) || [], C = this.midPoints.getUpdated(g) || [], P = this.coordinatePoints.getUpdated(this.draggedFeatureId, g) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: d }, ...s, ...C, ...P]), this.dragPosition = [i.lng, i.lat];
    } else d.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: f } }]), this.dragPosition = [i.lng, i.lat]);
  }
}
class gI extends eo {
  constructor(i, l, d, f, g, m, s) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g, this.coordinateSnapping = m, this.lineSnapping = s;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  snapCoordinate(i, l, d) {
    let f = [i.lng, i.lat];
    const g = (m) => !!(m.properties && m.properties.mode === d.properties.mode && m.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let m;
      m = this.lineSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l.toCoordinate) {
      let m;
      m = this.coordinateSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l != null && l.toCustom) {
      let m;
      m = l.toCustom(i, { currentCoordinate: this.draggedCoordinate.index, currentId: d.id, getCurrentGeometrySnapshot: d.id ? () => this.store.getGeometryCopy(d.id) : () => null, project: this.project, unproject: this.unproject }), m && (f = m);
    }
    return f;
  }
  drag(i, l, d, f) {
    const g = this.draggedCoordinate.id;
    if (g === null) return false;
    const m = this.draggedCoordinate.index, s = this.store.getGeometryCopy(g), C = this.store.getPropertiesCopy(g), P = s.type === "LineString" ? s.coordinates : s.coordinates[0], M = s.type === "Polygon" && (m === P.length - 1 || m === 0), F = { type: "Feature", id: g, geometry: s, properties: C }, D = this.snapCoordinate(i, f, F);
    if (i.lng > 180 || i.lng < -180 || i.lat > 90 || i.lat < -90) return false;
    if (M) {
      const W = P.length - 1;
      P[0] = D, P[W] = D;
    } else P[m] = D;
    const A = this.selectionPoints.getOneUpdated(m, D), O = A ? [A] : [], V = this.midPoints.getUpdated(P) || [], Y = this.coordinatePoints.getUpdated(g, P) || [];
    return !(s.type !== "Point" && !l && W6({ geometry: s }) || d && !d(F, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: g, geometry: s }, ...O, ...V, ...Y]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function e_(r) {
  let i = 0, l = 0, d = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((f) => {
    i += f[0], l += f[1], d++;
  }, true), [i / d, l / d];
}
const _1 = (r, i) => {
  if (i === 0 || i === 360 || i === -360) return r;
  const l = 0.017453292519943295 * i, d = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([m, s]) => Di(m, s)), f = d.reduce((m, s) => ({ x: m.x + s.x, y: m.y + s.y }), { x: 0, y: 0 });
  f.x /= d.length, f.y /= d.length;
  const g = d.map((m) => ({ x: f.x + (m.x - f.x) * Math.cos(l) - (m.y - f.y) * Math.sin(l), y: f.y + (m.x - f.x) * Math.sin(l) + (m.y - f.y) * Math.cos(l) })).map(({ x: m, y: s }) => [sc(m, s).lng, sc(m, s).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = g : r.geometry.coordinates = g, r;
};
function zg(r) {
  const i = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((l) => {
    const { x: d, y: f } = Di(l[0], l[1]);
    return [d, f];
  });
  return r.geometry.type === "Polygon" ? (function(l) {
    let d = 0, f = 0, g = 0;
    const m = l.length;
    for (let s = 0; s < m - 1; s++) {
      const [C, P] = l[s], [M, F] = l[s + 1], D = C * F - M * P;
      d += D, f += (C + M) * D, g += (P + F) * D;
    }
    return d /= 2, f /= 6 * d, g /= 6 * d, { x: f, y: g };
  })(i) : (function(l) {
    const d = l.length;
    let f = 0, g = 0;
    for (let m = 0; m < d; m++) {
      const [s, C] = l[m];
      f += s, g += C;
    }
    return { x: f / d, y: g / d };
  })(i);
}
class vI extends eo {
  constructor(i, l, d, f) {
    super(i), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = i, this.selectionPoints = l, this.midPoints = d, this.coordinatePoints = f;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(i, l, d) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const f = this.selectedGeometry;
    if (f.type !== "Polygon" && f.type !== "LineString") return;
    const g = [i.lng, i.lat];
    let m;
    const s = { type: "Feature", geometry: f, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = zg(s));
      const D = Di(i.lng, i.lat);
      if (m = Z6(this.selectedGeometryWebMercatorCentroid, D), m === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = m);
      _1(s, -(this.lastBearing - m));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = e_({ geometry: f })), m = Ag(this.selectedGeometryCentroid, g), !this.lastBearing) return void (this.lastBearing = m + 180);
      (function(D, A) {
        if (A === 0 || A === 360 || A === -360) return D;
        const O = e_(D);
        (D.geometry.type === "Polygon" ? D.geometry.coordinates[0] : D.geometry.coordinates).forEach((V) => {
          const Y = Ag(O, V) + A, W = (function(ie, te) {
            ie[0] += ie[0] - te[0] > 180 ? -360 : te[0] - ie[0] > 180 ? 360 : 0;
            const re = f1, X = te[1] * Math.PI / 180, Se = ie[1] * Math.PI / 180, pe = Se - X;
            let oe = Math.abs(ie[0] - te[0]) * Math.PI / 180;
            oe > Math.PI && (oe -= 2 * Math.PI);
            const fe = Math.log(Math.tan(Se / 2 + Math.PI / 4) / Math.tan(X / 2 + Math.PI / 4)), _e = Math.abs(fe) > 1e-11 ? pe / fe : Math.cos(X);
            return Math.sqrt(pe * pe + _e * _e * oe * oe) * re;
          })(O, V), ee = v1(O, W, Y);
          V[0] = ee[0], V[1] = ee[1];
        });
      })(s, -(this.lastBearing - (m + 180)));
    }
    const C = f.type === "Polygon" ? f.coordinates[0] : f.coordinates;
    C.forEach((D) => {
      D[0] = Fi(D[0], this.coordinatePrecision), D[1] = Fi(D[1], this.coordinatePrecision);
    });
    const P = this.midPoints.getUpdated(C) || [], M = this.selectionPoints.getUpdated(C) || [], F = this.coordinatePoints.getUpdated(l, C) || [];
    if (d && !d({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: f }, ...M, ...P, ...F]), this.projection === "web-mercator" ? this.lastBearing = m : this.projection === "globe" && (this.lastBearing = m + 180);
  }
}
class yI extends eo {
  constructor(i, l) {
    super(i), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = i, this.dragCoordinateResizeBehavior = l;
  }
  scale(i, l, d) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const f = this.dragCoordinateResizeBehavior.getDraggableIndex(i, l);
      this.dragCoordinateResizeBehavior.startDragging(l, f);
    }
    this.dragCoordinateResizeBehavior.drag(i, "center-fixed", d);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function b1({ coordinates: r, originX: i, originY: l, xScale: d, yScale: f }) {
  d === 1 && f === 1 || r.forEach((g) => {
    const { x: m, y: s } = Di(g[0], g[1]), C = i + (m - i) * d, P = l + (s - l) * f, { lng: M, lat: F } = sc(C, P);
    g[0] = M, g[1] = F;
  });
}
class _I extends eo {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  isValidDragWebMercator(i, l, d) {
    switch (i) {
      case 0:
        if (l <= 0 || d >= 0) return false;
        break;
      case 1:
        if (d >= 0) return false;
        break;
      case 2:
        if (l >= 0 || d >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || d <= 0) return false;
        break;
      case 5:
        if (d <= 0) return false;
        break;
      case 6:
        if (l <= 0 || d <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const i = this.getFeature(this.draggedCoordinate.id);
    if (!i) return null;
    const l = this.getNormalisedCoordinates(i.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: i, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = zg(d);
    if (!s) return null;
    const C = Di(m[0], m[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, C), M = Di(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: P, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  centerFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = zg(d);
    if (!s) return null;
    const C = Di(m[0], m[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, C), M = Di(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: P, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  scaleFixedWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    if (!this.isValidDragWebMercator(i, l.x - f.x, l.y - f.y)) return null;
    let m = ma(l, f) / ma(l, d);
    return m < 0 && (m = this.minimumScale), b1({ coordinates: g, originX: l.x, originY: l.y, xScale: m, yScale: m }), g;
  }
  oppositeFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Di(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), P = { x: d[s][0], y: d[s][1] }, M = Di(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: P }), f;
  }
  oppositeWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Di(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), P = { x: d[s][0], y: d[s][1] }, M = Di(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: P }), f;
  }
  scaleWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    const m = l.x - f.x, s = l.y - f.y;
    if (!this.isValidDragWebMercator(i, m, s)) return null;
    let C = 1;
    m !== 0 && i !== 1 && i !== 5 && (C = 1 - (l.x - d.x - m) / m);
    let P = 1;
    return s !== 0 && i !== 3 && i !== 7 && (P = 1 - (l.y - d.y - s) / s), this.validateScale(C, P) ? (C < 0 && (C = this.minimumScale), P < 0 && (P = this.minimumScale), this.performWebMercatorScale(g, l.x, l.y, C, P), g) : null;
  }
  getFeature(i) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(i);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: i, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(i) {
    return i.type === "Polygon" ? i.coordinates[0] : i.coordinates;
  }
  validateScale(i, l) {
    const d = !isNaN(i) && l < Number.MAX_SAFE_INTEGER, f = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return d && f;
  }
  performWebMercatorScale(i, l, d, f, g) {
    i.forEach((m) => {
      const { x: s, y: C } = Di(m[0], m[1]), P = l + (s - l) * f, M = d + (C - d) * g, { lng: F, lat: D } = sc(P, M);
      m[0] = F, m[1] = D;
    });
  }
  getBBoxWebMercator(i) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (i = i.map((s) => {
      const { x: C, y: P } = Di(s[0], s[1]);
      return [C, P];
    })).forEach(([s, C]) => {
      s < l[0] && (l[0] = s), C < l[1] && (l[1] = C), s > l[2] && (l[2] = s), C > l[3] && (l[3] = C);
    });
    const [d, f, g, m] = l;
    return [[d, m], [(d + g) / 2, m], [g, m], [g, m + (f - m) / 2], [g, f], [(d + g) / 2, f], [d, f], [d, m + (f - m) / 2]];
  }
  getIndexesWebMercator(i, l) {
    let d, f = 1 / 0;
    for (let g = 0; g < i.length; g++) {
      const m = ma({ x: l.x, y: l.y }, { x: i[g][0], y: i[g][1] });
      m < f && (d = g, f = m);
    }
    if (d === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[d], closestBBoxIndex: d };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  drag(i, l, d) {
    if (!this.draggedCoordinate.id) return false;
    const f = this.getFeature(this.draggedCoordinate.id);
    if (!f) return false;
    let g = null;
    if (l === "center" ? g = this.centerWebMercatorDrag(i) : l === "opposite" ? g = this.oppositeWebMercatorDrag(i) : l === "center-fixed" ? g = this.centerFixedWebMercatorDrag(i) : l === "opposite-fixed" && (g = this.oppositeFixedWebMercatorDrag(i)), !g) return false;
    for (let M = 0; M < g.length; M++) {
      const F = g[M];
      if (F[0] = Fi(F[0], this.coordinatePrecision), F[1] = Fi(F[1], this.coordinatePrecision), !i0(F, this.coordinatePrecision)) return false;
    }
    const m = this.midPoints.getUpdated(g) || [], s = this.selectionPoints.getUpdated(g) || [], C = this.coordinatePoints.getUpdated(f.id, g) || [], P = { type: f.geometry.type, coordinates: f.geometry.type === "Polygon" ? [g] : g };
    return !(d && !d({ id: this.draggedCoordinate.id, type: "Feature", geometry: P, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: P }, ...s, ...m, ...C]), 0));
  }
}
const bI = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, t_ = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class xI extends q6 {
  constructor(i) {
    super(i, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = bI, this.cursors = t_, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    if (super.updateOptions(i), this.cursors = i && i.cursors ? Cn({}, this.cursors, i.cursors) : t_, (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : i != null && i.keyEvents && (this.keyEvents = Cn({}, this.keyEvents, i.keyEvents)), (i == null ? void 0 : i.dragEventThrottle) !== void 0 && (this.dragEventThrottle = i.dragEventThrottle), (i == null ? void 0 : i.allowManualDeselection) !== void 0 && (this.allowManualDeselection = i.allowManualDeselection), i != null && i.flags) {
      this.flags = Cn({}, this.flags, i.flags), this.validations = {};
      for (const l in this.flags) {
        const d = this.flags[l].feature;
        d && d.validation && (this.validations[l] = d.validation);
      }
    }
  }
  selectFeature(i) {
    this.select(i, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(i) {
    this.pixelDistance = new Kf(i), this.clickBoundingBox = new Yf(i), this.featuresAtMouseEvent = new pI(i, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new fI(i), this.coordinatePoints = new uI(i), this.midPoints = new hI(i, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new Rg(i, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new g1(i, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new vI(i, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new mI(i, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new gI(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new _I(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new yI(i, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const i = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: dn.SELECTED, value: false }));
    this.store.updateProperty(i), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(i) {
    if (!this.selectionPoints.ids.length) return;
    let l, d = 1 / 0;
    if (this.selectionPoints.ids.forEach((D) => {
      const A = this.store.getGeometryCopy(D), O = this.pixelDistance.measure(i, A.coordinates);
      O < this.pointerDistance && O < d && (d = O, l = this.store.getPropertiesCopy(D));
    }), !l) return;
    const f = l.selectionPointFeatureId, g = l.index, m = this.store.getPropertiesCopy(f), s = this.flags[m.mode], C = this.validations[m.mode];
    if (!(s && s.feature && s.feature.coordinates && s.feature.coordinates.deletable)) return;
    const P = this.store.getGeometryCopy(f);
    let M;
    if (P.type === "Polygon") {
      if (M = P.coordinates[0], M.length <= 4) return;
    } else if (P.type === "LineString" && (M = P.coordinates, M.length <= 2)) return;
    if (!M || (P.type !== "Polygon" || g !== 0 && g !== M.length - 1 ? M.splice(g, 1) : (M.shift(), M.pop(), M.push([M[0][0], M[0][1]])), C && !C({ id: f, type: "Feature", geometry: P, properties: m }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid)) return;
    const F = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(F), this.store.updateGeometry([{ id: f, geometry: P }]), m.coordinatePointIds && this.coordinatePoints.createOrUpdate(f), this.selectionPoints.create(M, P.type, f), s && s.feature && s.feature.coordinates && s.feature.coordinates.midpoints && this.midPoints.create(M, f, this.coordinatePrecision);
  }
  select(i, l = true) {
    if (this.selected[0] === i) return;
    const { mode: d } = this.store.getPropertiesCopy(i), f = this.flags[d];
    if (!f || !f.feature) return;
    const g = this.selected[0];
    if (g) {
      if (g === i) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [i], this.store.updateProperty([{ id: i, property: dn.SELECTED, value: true }]), this.onSelect(i);
    const { type: m, coordinates: s } = this.store.getGeometryCopy(i);
    if (m !== "LineString" && m !== "Polygon") return;
    const C = m === "LineString" ? s : s[0];
    C && f && f.feature.coordinates && (this.selectionPoints.create(C, m, i), f.feature.coordinates.midpoints && this.midPoints.create(C, i, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const { clickedFeature: l, clickedMidPoint: d } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
    if (this.selected.length && d) this.midPoints.insert(this.selected[0], d.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  canScale(i) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => i.heldKeys.includes(l));
  }
  canRotate(i) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => i.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(i) {
    const l = this.canRotate(i), d = this.canScale(i);
    (l || d) && i.preventDefault();
  }
  onKeyDown(i) {
    this.preventDefaultKeyEvent(i);
  }
  onKeyUp(i) {
    if (this.preventDefaultKeyEvent(i), this.keyEvents.delete && i.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && i.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.selected.length) return;
    const d = this.store.getPropertiesCopy(this.selected[0]), f = this.flags[d.mode];
    if (!(f && f.feature && (f.feature.draggable || f.feature.coordinates && f.feature.coordinates.draggable || f.feature.coordinates && f.feature.coordinates.resizable || f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const g = this.selected[0], m = this.dragCoordinate.getDraggableIndex(i, g);
    if (f && f.feature && f.feature.coordinates && (f.feature.coordinates.draggable || f.feature.coordinates.resizable) && m !== -1) return this.setCursor(this.cursors.dragStart), f.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(g, m) : this.dragCoordinate.startDragging(g, m), void l(false);
    if (f && f.feature && f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: s } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
      if (this.selected.length && s) {
        this.midPoints.insert(g, s.id, this.coordinatePrecision);
        const C = this.dragCoordinate.getDraggableIndex(i, g);
        return this.dragCoordinate.startDragging(g, C), void l(false);
      }
    }
    return f && f.feature && f.feature.draggable && this.dragFeature.canDrag(i, g) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(i, g), void l(false)) : void 0;
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i)) return;
    const d = this.selected[0];
    if (!d) return;
    const f = this.store.getPropertiesCopy(d), g = this.flags[f.mode], m = (g && g.feature && g.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const s = this.validations[f.mode];
    if (g && g.feature && g.feature.rotateable && this.canRotate(i)) return l(false), void this.rotateFeature.rotate(i, d, s);
    if (g && g.feature && g.feature.scaleable && this.canScale(i)) return l(false), void this.scaleFeature.scale(i, d, s);
    if (this.dragCoordinateResizeFeature.isDragging() && g.feature && g.feature.coordinates && g.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(i, g.feature.coordinates.resizable, s);
    }
    if (this.dragCoordinate.isDragging()) {
      var C;
      const P = (C = g.feature) == null || (C = C.coordinates) == null ? void 0 : C.snappable;
      let M = { toCoordinate: false };
      return P === true ? M = { toCoordinate: true } : typeof P == "object" && (M = P), void this.dragCoordinate.drag(i, m, s, M);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(i, s) : l(true);
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(i) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((g) => {
      if (l) return;
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = true);
    });
    let d = false;
    if (this.selectionPoints.ids.forEach((g) => {
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = false, d = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: f } = this.featuresAtMouseEvent.find(i, true);
    this.setCursor(this.selected.length > 0 && (f && f.id === this.selected[0] || d) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.properties.mode === this.mode && i.geometry.type === "Point") {
      if (i.properties.selectionPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, i), l.zIndex = 30, l;
      if (i.properties.midPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, i), l.zIndex = 50, l;
    } else if (i.properties[dn.SELECTED]) {
      if (i.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, i), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, i), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, i), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, i), l.zIndex = Vf, l;
      if (i.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, i), l.zIndex = Vf, l;
      if (i.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, i), l.zIndex = Vf, l;
    }
    return l;
  }
  afterFeatureUpdated(i) {
    if (this.selected.length && i.id === this.selected[0]) {
      var l, d;
      const f = this.flags[i.properties.mode];
      if (f == null || (l = f.feature) == null || !l.coordinates) return;
      const g = i.geometry.type, m = i.id;
      let s;
      if (this.selectionPoints.delete(), this.midPoints.delete(), g === "Polygon") s = i.geometry.coordinates[0];
      else {
        if (g !== "LineString") return;
        s = i.geometry.coordinates;
      }
      this.selectionPoints.create(s, g, m), f != null && (d = f.feature) != null && (d = d.coordinates) != null && d.midpoints && this.midPoints.create(g === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates, m, this.coordinatePrecision);
    }
  }
}
class wI extends mp {
  constructor(...i) {
    super(...i), this.type = oc.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function x1(r, i, l, d, f) {
  for (; d > l; ) {
    if (d - l > 600) {
      const C = d - l + 1, P = i - l + 1, M = Math.log(C), F = 0.5 * Math.exp(2 * M / 3), D = 0.5 * Math.sqrt(M * F * (C - F) / C) * (P - C / 2 < 0 ? -1 : 1);
      x1(r, i, Math.max(l, Math.floor(i - P * F / C + D)), Math.min(d, Math.floor(i + (C - P) * F / C + D)), f);
    }
    const g = r[i];
    let m = l, s = d;
    for (Md(r, l, i), f(r[d], g) > 0 && Md(r, l, d); m < s; ) {
      for (Md(r, m, s), m++, s--; f(r[m], g) < 0; ) m++;
      for (; f(r[s], g) > 0; ) s--;
    }
    f(r[l], g) === 0 ? Md(r, l, s) : (s++, Md(r, s, d)), s <= i && (l = s + 1), i <= s && (d = s - 1);
  }
}
function Md(r, i, l) {
  const d = r[i];
  r[i] = r[l], r[l] = d;
}
function Hu(r, i) {
  Ad(r, 0, r.children.length, i, r);
}
function Ad(r, i, l, d, f) {
  f || (f = Ju([])), f.minX = 1 / 0, f.minY = 1 / 0, f.maxX = -1 / 0, f.maxY = -1 / 0;
  for (let g = i; g < l; g++) {
    const m = r.children[g];
    Dd(f, r.leaf ? d(m) : m);
  }
  return f;
}
function Dd(r, i) {
  return r.minX = Math.min(r.minX, i.minX), r.minY = Math.min(r.minY, i.minY), r.maxX = Math.max(r.maxX, i.maxX), r.maxY = Math.max(r.maxY, i.maxY), r;
}
function CI(r, i) {
  return r.minX - i.minX;
}
function SI(r, i) {
  return r.minY - i.minY;
}
function Ym(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Af(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function kI(r, i) {
  const l = Math.max(r.minX, i.minX), d = Math.max(r.minY, i.minY), f = Math.min(r.maxX, i.maxX), g = Math.min(r.maxY, i.maxY);
  return Math.max(0, f - l) * Math.max(0, g - d);
}
function Km(r, i) {
  return r.minX <= i.minX && r.minY <= i.minY && i.maxX <= r.maxX && i.maxY <= r.maxY;
}
function Df(r, i) {
  return i.minX <= r.maxX && i.minY <= r.maxY && i.maxX >= r.minX && i.maxY >= r.minY;
}
function Ju(r) {
  return { children: r, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function r_(r, i, l, d, f) {
  const g = [i, l];
  for (; g.length; ) {
    if ((l = g.pop()) - (i = g.pop()) <= d) continue;
    const m = i + Math.ceil((l - i) / d / 2) * d;
    x1(r, m, i, l, f), g.push(i, m, m, l);
  }
}
class PI {
  constructor(i) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, i), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(i) {
    let l = this.data;
    const d = [];
    if (!Df(i, l)) return d;
    const f = this.toBBox, g = [];
    for (; l; ) {
      for (let m = 0; m < l.children.length; m++) {
        const s = l.children[m], C = l.leaf ? f(s) : s;
        Df(i, C) && (l.leaf ? d.push(s) : Km(i, C) ? this._all(s, d) : g.push(s));
      }
      l = g.pop();
    }
    return d;
  }
  collides(i) {
    let l = this.data;
    if (Df(i, l)) {
      const d = [];
      for (; l; ) {
        for (let f = 0; f < l.children.length; f++) {
          const g = l.children[f], m = l.leaf ? this.toBBox(g) : g;
          if (Df(i, m)) {
            if (l.leaf || Km(i, m)) return true;
            d.push(g);
          }
        }
        l = d.pop();
      }
    }
    return false;
  }
  load(i) {
    if (i.length < this._minEntries) {
      for (let d = 0; d < i.length; d++) this.insert(i[d]);
      return;
    }
    let l = this._build(i.slice(), 0, i.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const d = this.data;
        this.data = l, l = d;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(i) {
    this._insert(i, this.data.height - 1);
  }
  clear() {
    this.data = Ju([]);
  }
  remove(i) {
    let l = this.data;
    const d = this.toBBox(i), f = [], g = [];
    let m, s, C = false;
    for (; l || f.length; ) {
      if (l || (l = f.pop(), s = f[f.length - 1], m = g.pop(), C = true), l.leaf) {
        const P = l.children.indexOf(i);
        P !== -1 && (l.children.splice(P, 1), f.push(l), this._condense(f));
      }
      C || l.leaf || !Km(l, d) ? s ? (m++, l = s.children[m], C = false) : l = null : (f.push(l), g.push(m), m = 0, s = l, l = l.children[0]);
    }
  }
  toBBox(i) {
    return i;
  }
  compareMinX(i, l) {
    return i.minX - l.minX;
  }
  compareMinY(i, l) {
    return i.minY - l.minY;
  }
  _all(i, l) {
    const d = [];
    for (; i; ) i.leaf ? l.push(...i.children) : d.push(...i.children), i = d.pop();
    return l;
  }
  _build(i, l, d, f) {
    const g = d - l + 1;
    let m, s = this._maxEntries;
    if (g <= s) return m = Ju(i.slice(l, d + 1)), Hu(m, this.toBBox), m;
    f || (f = Math.ceil(Math.log(g) / Math.log(s)), s = Math.ceil(g / Math.pow(s, f - 1))), m = Ju([]), m.leaf = false, m.height = f;
    const C = Math.ceil(g / s), P = C * Math.ceil(Math.sqrt(s));
    r_(i, l, d, P, this.compareMinX);
    for (let M = l; M <= d; M += P) {
      const F = Math.min(M + P - 1, d);
      r_(i, M, F, C, this.compareMinY);
      for (let D = M; D <= F; D += C) {
        const A = Math.min(D + C - 1, F);
        m.children.push(this._build(i, D, A, f - 1));
      }
    }
    return Hu(m, this.toBBox), m;
  }
  _chooseSubtree(i, l, d, f) {
    for (; f.push(l), !l.leaf && f.length - 1 !== d; ) {
      let s, C = 1 / 0, P = 1 / 0;
      for (let M = 0; M < l.children.length; M++) {
        const F = l.children[M], D = Ym(F), A = (g = i, m = F, (Math.max(m.maxX, g.maxX) - Math.min(m.minX, g.minX)) * (Math.max(m.maxY, g.maxY) - Math.min(m.minY, g.minY)) - D);
        A < P ? (P = A, C = D < C ? D : C, s = F) : A === P && D < C && (C = D, s = F);
      }
      l = s || l.children[0];
    }
    var g, m;
    return l;
  }
  _insert(i, l, d) {
    const f = d ? i : this.toBBox(i), g = [], m = this._chooseSubtree(f, this.data, l, g);
    for (m.children.push(i), Dd(m, f); l >= 0 && g[l].children.length > this._maxEntries; ) this._split(g, l), l--;
    this._adjustParentBBoxes(f, g, l);
  }
  _split(i, l) {
    const d = i[l], f = d.children.length, g = this._minEntries;
    this._chooseSplitAxis(d, g, f);
    const m = this._chooseSplitIndex(d, g, f), s = Ju(d.children.splice(m, d.children.length - m));
    s.height = d.height, s.leaf = d.leaf, Hu(d, this.toBBox), Hu(s, this.toBBox), l ? i[l - 1].children.push(s) : this._splitRoot(d, s);
  }
  _splitRoot(i, l) {
    this.data = Ju([i, l]), this.data.height = i.height + 1, this.data.leaf = false, Hu(this.data, this.toBBox);
  }
  _chooseSplitIndex(i, l, d) {
    let f, g = 1 / 0, m = 1 / 0;
    for (let s = l; s <= d - l; s++) {
      const C = Ad(i, 0, s, this.toBBox), P = Ad(i, s, d, this.toBBox), M = kI(C, P), F = Ym(C) + Ym(P);
      M < g ? (g = M, f = s, m = F < m ? F : m) : M === g && F < m && (m = F, f = s);
    }
    return f || d - l;
  }
  _chooseSplitAxis(i, l, d) {
    const f = i.leaf ? this.compareMinX : CI, g = i.leaf ? this.compareMinY : SI;
    this._allDistMargin(i, l, d, f) < this._allDistMargin(i, l, d, g) && i.children.sort(f);
  }
  _allDistMargin(i, l, d, f) {
    i.children.sort(f);
    const g = this.toBBox, m = Ad(i, 0, l, g), s = Ad(i, d - l, d, g);
    let C = Af(m) + Af(s);
    for (let P = l; P < d - l; P++) {
      const M = i.children[P];
      Dd(m, i.leaf ? g(M) : M), C += Af(m);
    }
    for (let P = d - l - 1; P >= l; P--) {
      const M = i.children[P];
      Dd(s, i.leaf ? g(M) : M), C += Af(s);
    }
    return C;
  }
  _adjustParentBBoxes(i, l, d) {
    for (let f = d; f >= 0; f--) Dd(l[f], i);
  }
  _condense(i) {
    for (let l, d = i.length - 1; d >= 0; d--) i[d].children.length === 0 ? d > 0 ? (l = i[d - 1].children, l.splice(l.indexOf(i[d]), 1)) : this.clear() : Hu(i[d], this.toBBox);
  }
}
class TI {
  constructor(i) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new PI(i && i.maxEntries ? i.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(i, l) {
    this.idToNode.set(i.id, l), this.nodeToId.set(l, i.id);
  }
  toBBox(i) {
    const l = [], d = [];
    let f;
    if (i.geometry.type === "Polygon") f = i.geometry.coordinates[0];
    else if (i.geometry.type === "LineString") f = i.geometry.coordinates;
    else {
      if (i.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      f = [i.geometry.coordinates];
    }
    for (let s = 0; s < f.length; s++) d.push(f[s][1]), l.push(f[s][0]);
    const g = Math.min(...d), m = Math.max(...d);
    return { minX: Math.min(...l), minY: g, maxX: Math.max(...l), maxY: m };
  }
  insert(i) {
    if (this.idToNode.get(String(i.id))) throw new Error("Feature already exists");
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  load(i) {
    const l = [], d = /* @__PURE__ */ new Set();
    i.forEach((f) => {
      const g = this.toBBox(f);
      if (this.setMaps(f, g), d.has(String(f.id))) throw new Error(`Duplicate feature ID found ${f.id}`);
      d.add(String(f.id)), l.push(g);
    }), this.tree.load(l);
  }
  update(i) {
    this.remove(i.id);
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  remove(i) {
    const l = this.idToNode.get(i);
    if (!l) throw new Error(`${i} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(i) {
    return this.tree.search(this.toBBox(i)).map((l) => this.nodeToId.get(l));
  }
  collides(i) {
    return this.tree.collides(this.toBBox(i));
  }
}
const II = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const i = 16 * Math.random() | 0;
  return (r == "x" ? i : 3 & i | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class MI {
  constructor(i) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new TI(), this.tracked = !i || i.tracked !== false, this.idStrategy = i && i.idStrategy ? i.idStrategy : II;
  }
  clone(i) {
    return JSON.parse(JSON.stringify(i));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(i) {
    return !!this.store[i];
  }
  load(i, l, d, f) {
    if (i.length === 0) return [];
    let g = this.clone(i);
    const m = [], s = [];
    g = g.filter((P) => {
      P.id == null && (P.id = this.idStrategy.getId());
      const M = P.id;
      if (l) {
        const F = l(P);
        if (!F.valid) return m.push({ id: M, valid: false, reason: F.reason }), false;
      }
      if (this.tracked) {
        if (P.properties.createdAt) {
          if (!Gy(P.properties.createdAt)) return m.push({ id: P.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else P.properties.createdAt = +/* @__PURE__ */ new Date();
        if (P.properties.updatedAt) {
          if (!Gy(P.properties.updatedAt)) return m.push({ id: P.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else P.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(M) ? (m.push({ id: M, valid: false, reason: `Feature already exists with this id: ${M}` }), false) : (this.store[M] = P, s.push(P), m.push({ id: M, valid: true }), true);
    }), this.spatialIndex.load(g);
    const C = s.map(({ id: P }) => P);
    return C.length > 0 && (this._onChange(C, "create", f), d && s.forEach((P) => {
      d(P);
    })), m;
  }
  search(i, l) {
    const d = this.spatialIndex.search(i).map((f) => this.store[f]);
    return this.clone(l ? d.filter(l) : d);
  }
  registerOnChange(i) {
    this._onChange = (l, d, f) => {
      i(l, d, f);
    };
  }
  getGeometryCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(i, l) {
    const d = [];
    i.forEach(({ id: f, property: g, value: m }) => {
      const s = this.store[f];
      if (!s) throw new Error(`No feature with this (${f}), can not update geometry`);
      d.push(f), m === void 0 ? delete s.properties[g] : s.properties[g] = m, this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  updateGeometry(i, l) {
    const d = [];
    i.forEach(({ id: f, geometry: g }) => {
      d.push(f);
      const m = this.store[f];
      if (!m) throw new Error(`No feature with this (${f}), can not update geometry`);
      m.geometry = this.clone(g), this.spatialIndex.update(m), this.tracked && (m.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  create(i, l) {
    const d = [];
    return i.forEach(({ geometry: f, properties: g }) => {
      let m, s = Cn({}, g);
      this.tracked && (m = +/* @__PURE__ */ new Date(), g ? (s.createdAt = typeof g.createdAt == "number" ? g.createdAt : m, s.updatedAt = typeof g.updatedAt == "number" ? g.updatedAt : m) : s = { createdAt: m, updatedAt: m });
      const C = this.getId(), P = { id: C, type: "Feature", geometry: f, properties: s };
      this.store[C] = P, this.spatialIndex.insert(P), d.push(C);
    }), this._onChange && this._onChange([...d], "create", l), d;
  }
  delete(i, l) {
    i.forEach((d) => {
      if (!this.store[d]) throw new Error(`No feature with id ${d}, can not delete`);
      delete this.store[d], this.spatialIndex.remove(d);
    }), this._onChange && this._onChange([...i], "delete", l);
  }
  copy(i) {
    return this.clone(this.store[i]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((i) => this.store[i]));
  }
  copyAllWhere(i) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && i(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class Xu {
  constructor({ name: i, callback: l, unregister: d, register: f }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = i, this.register = () => {
      this.registered || (this.registered = true, f(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, d(l));
    }, this.callback = l;
  }
}
var EI = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const i = this.getMapEventElement(), { left: l, top: d } = i.getBoundingClientRect();
    return { containerX: r.clientX - l, containerY: r.clientY - d };
  }
  getDrawEventFromEvent(r, i = false) {
    const l = this.getLngLatFromEvent(r);
    if (!l) return null;
    const { lng: d, lat: f } = l, { containerX: g, containerY: m } = this.getMapElementXYPosition(r), s = this.getButton(r), C = Array.from(this._heldKeys);
    return { lng: Fi(d, this._coordinatePrecision), lat: Fi(f, this._coordinatePrecision), containerX: g, containerY: m, button: s, heldKeys: C, isContextMenu: i };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((i) => {
      i.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new Xu({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState = "pre-dragging", this._lastDrawEvent = i);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new Xu({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const i = this.getDrawEventFromEvent(r);
      if (i) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(i), this._lastDrawEvent = i;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, d = { x: i.containerX, y: i.containerY }, f = this._currentModeCallbacks.getState(), g = ma(l, d);
        let m = false;
        if (m = f === "drawing" ? g < this._minPixelDragDistanceDrawing : f === "selecting" ? g < this._minPixelDragDistanceSelecting : g < this._minPixelDragDistance, m) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(i, (s) => {
          this.setDraggability.bind(this)(s);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(i, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new Xu({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new Xu({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(i, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (i.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(i)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new Xu({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new Xu({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
function Fg(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return true;
  if (r === void 0) return false;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return false;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const i = Object.getPrototypeOf(r);
    if (i !== Object.prototype && i !== null) return false;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return false;
  if (Array.isArray(r)) {
    for (const i of r) if (!Fg(i)) return false;
  }
  return typeof r == "object" && Object.keys(r).every((i) => typeof i == "string" && Fg(r[i]));
}
class RI {
  constructor(i) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = i.adapter, this._mode = new wI();
    const l = /* @__PURE__ */ new Set(), d = i.modes.reduce((M, F) => {
      if (l.has(F.mode)) throw new Error(`There is already a ${F.mode} mode provided`);
      return l.add(F.mode), M[F.mode] = F, M;
    }, {}), f = Object.keys(d);
    if (f.length === 0) throw new Error("No modes provided");
    f.forEach((M) => {
      if (d[M].type === oc.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = M;
      }
    }), this._modes = Cn({}, d, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new MI({ tracked: !!i.tracked, idStrategy: i.idStrategy ? i.idStrategy : void 0 });
    const g = (M) => {
      const F = [], D = this._store.copyAll().filter((A) => !M.includes(A.id) || (F.push(A), false));
      return { changed: F, unchanged: D };
    }, m = (M, F) => {
      this._enabled && this._eventListeners.finish.forEach((D) => {
        D(M, F);
      });
    }, s = (M, F, D) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((V) => {
        V(M, F, D);
      });
      const { changed: A, unchanged: O } = g(M);
      F === "create" ? this._adapter.render({ created: A, deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles()) : F === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: A }, this.getModeStyles()) : F === "delete" ? this._adapter.render({ created: [], deletedIds: M, unchanged: O, updated: [] }, this.getModeStyles()) : F === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles());
    }, C = (M) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((A) => {
        A(M);
      });
      const { changed: F, unchanged: D } = g([M]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: D, updated: F }, this.getModeStyles());
    }, P = (M) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((A) => {
        A();
      });
      const { changed: F, unchanged: D } = g([M]);
      F && this._adapter.render({ created: [], deletedIds: [], unchanged: D, updated: F }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((M) => {
      this._modes[M].register({ mode: M, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: s, onSelect: C, onDeselect: P, onFinish: m, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const i = {};
    return Object.keys(this._modes).forEach((l) => {
      i[l] = (d) => this._instanceSelectMode && d.properties[dn.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(d) : this._modes[l].styleFeature.bind(this._modes[l])(d);
    }), i;
  }
  featuresAtLocation({ lng: i, lat: l }, d) {
    const f = d && d.pointerDistance !== void 0 ? d.pointerDistance : 30, g = !d || d.ignoreSelectFeatures === void 0 || d.ignoreSelectFeatures, m = !(!d || d.ignoreCoordinatePoints === void 0) && d.ignoreCoordinatePoints, s = !(!d || d.ignoreCurrentlyDrawing === void 0) && d.ignoreCurrentlyDrawing, C = !(!d || d.ignoreClosingPoints === void 0) && d.ignoreClosingPoints, P = this._adapter.unproject.bind(this._adapter), M = this._adapter.project.bind(this._adapter), F = M(i, l), D = m1({ unproject: P, point: F, pointerDistance: f });
    return this._store.search(D).filter((A) => {
      if (g && (A.properties[dn.MID_POINT] || A.properties[dn.SELECTION_POINT]) || m && A.properties[zi.COORDINATE_POINT] || C && A.properties[zi.CLOSING_POINT] || s && A.properties[zi.CURRENTLY_DRAWING]) return false;
      if (A.geometry.type === "Point") {
        const O = A.geometry.coordinates, V = M(O[0], O[1]);
        return ma(F, V) < f;
      }
      if (A.geometry.type === "LineString") {
        const O = A.geometry.coordinates;
        for (let V = 0; V < O.length - 1; V++) {
          const Y = O[V], W = O[V + 1];
          if (Dg(F, M(Y[0], Y[1]), M(W[0], W[1])) < f) return true;
        }
        return false;
      }
      if (y1([i, l], A.geometry.coordinates)) return true;
      if (d != null && d.includePolygonsWithinPointerDistance) {
        const O = A.geometry.coordinates;
        for (const V of O) for (let Y = 0; Y < V.length - 1; Y++) {
          const W = V[Y], ee = V[Y + 1], ie = M(W[0], W[1]), te = M(ee[0], ee[1]);
          if (Dg(F, ie, te) < f) return true;
        }
      }
      return false;
    }).map((A) => {
      if (d == null || !d.addClosestCoordinateInfoToProperties) return A;
      let O;
      if (A.geometry.type === "Polygon") O = A.geometry.coordinates[0], O.pop();
      else {
        if (A.geometry.type !== "LineString") return A;
        O = A.geometry.coordinates;
      }
      let V, Y = -1, W = 1 / 0;
      for (let ee = 0; ee < O.length; ee++) {
        const ie = O[ee], te = ma(M(ie[0], ie[1]), F);
        te < W && (Y = ee, W = te, V = ie);
      }
      return A.properties.closestCoordinateIndexToEvent = Y, A.properties.closestCoordinatePixelDistanceToEvent = W, A.properties.closestCoordinateDistanceKmToEvent = rs(V, [i, l]), A;
    });
  }
  getSelectModeOrThrow() {
    const i = this.getSelectMode({ switchToSelectMode: true });
    if (!i) throw new Error("No select mode defined in instance");
    return i;
  }
  getSelectMode({ switchToSelectMode: i }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return i && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(i) {
    return !!(i.properties[dn.MID_POINT] || i.properties[dn.SELECTION_POINT] || i.properties[zi.COORDINATE_POINT] || i.properties[zi.SNAPPING_POINT]);
  }
  setModeStyles(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].styles = l;
  }
  updateModeOptions(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(i) {
    if (this._store.has(i)) return this._store.copy(i);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(i) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[i], this._mode.start();
  }
  removeFeatures(i) {
    this.checkEnabled();
    const l = [];
    i.forEach((d) => {
      if (!this._store.has(d)) throw new Error(`No feature with id ${d}, can not delete`);
      const f = this._store.copy(d);
      f.properties[dn.SELECTED] && this.deselectFeature(d), f.properties[zi.COORDINATE_POINT_IDS] && l.push(...f.properties[zi.COORDINATE_POINT_IDS]);
    }), this._store.delete([...i, ...l], { origin: "api" });
  }
  selectFeature(i) {
    this.getSelectModeOrThrow().selectFeature(i);
  }
  deselectFeature(i) {
    this.getSelectModeOrThrow().deselectFeature(i);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(i) {
    return this._store.has(i);
  }
  checkIsReservedProperty(i) {
    return ![...Object.values(dn), ...Object.values(zi)].includes(i);
  }
  updateFeatureProperties(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode;
    if (!this._modes[f]) throw new Error(`No mode with name ${f} present in instance`);
    const g = Object.entries(l);
    g.forEach(([m, s]) => {
      if (!this.checkIsReservedProperty(m)) throw new Error(`You are trying to update a reserved property name: ${m}. Please choose another name.`);
      if (s !== void 0 && !Fg(s)) throw new Error(`Invalid JSON value provided for property ${m}`);
    }), this._store.updateProperty(g.map(([m, s]) => ({ id: d.id, property: m, value: s })), { origin: "api" });
  }
  updateFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(d && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== d.geometry.type) throw new Error(`Geometry type mismatch: expected ${d.geometry.type}, got ${l.type}`);
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    const m = Cn({}, d, { geometry: l }), s = g.validateFeature(m);
    if (!s.valid) throw new Error(`Feature validation failed: ${s.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: d.id, geometry: l }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(m);
      const C = m.properties[dn.SELECTED], P = this.getSelectMode({ switchToSelectMode: false });
      P && C && P.afterFeatureUpdated(m);
    }
  }
  transformFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    let d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    let m;
    if (d.geometry.type === "Polygon") m = d.geometry.coordinates[0];
    else {
      if (d.geometry.type !== "LineString") throw new Error(`Feature geometry type ${d.geometry.type} is not supported for transformation`);
      m = d.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: s, y: C } = Di(l.origin[0], l.origin[1]);
      b1({ coordinates: m, originX: s, originY: C, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (d = _1(d, l.options.angle || 0), m = d.geometry.type === "Polygon" ? d.geometry.coordinates[0] : d.geometry.coordinates);
    if (m = m.map((s) => [Fi(s[0], this._adapter.getCoordinatePrecision()), Fi(s[1], this._adapter.getCoordinatePrecision())]), d.geometry.coordinates = d.geometry.type === "Polygon" ? [m] : m, this._store.updateGeometry([{ id: d.id, geometry: d.geometry }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(d);
      const s = d.properties[dn.SELECTED], C = this.getSelectMode({ switchToSelectMode: false });
      C && s && C.afterFeatureUpdated(d);
    }
  }
  addFeatures(i) {
    return this.checkEnabled(), i.length === 0 ? [] : this._store.load(i, (l) => {
      if (qy(l)) {
        const d = l.properties.mode, f = this._modes[d];
        if (!f) return { id: l.id, valid: false, reason: `${d} mode is not in the list of instantiated modes` };
        const g = f.validateFeature.bind(f)(l);
        return { id: l.id, valid: g.valid, reason: g.reason ? g.reason : g.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (qy(l)) {
        const d = this._modes[l.properties.mode];
        d && d.afterFeatureAdded && d.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((i) => {
        i();
      });
    }, getState: () => this._mode.state, onClick: (i) => {
      this._mode.onClick(i);
    }, onMouseMove: (i) => {
      this._mode.onMouseMove(i);
    }, onKeyDown: (i) => {
      this._mode.onKeyDown(i);
    }, onKeyUp: (i) => {
      this._mode.onKeyUp(i);
    }, onDragStart: (i, l) => {
      this._mode.onDragStart(i, l);
    }, onDrag: (i, l) => {
      this._mode.onDrag(i, l);
    }, onDragEnd: (i, l) => {
      this._mode.onDragEnd(i, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(i, l) {
    const { lng: d, lat: f } = i;
    return this.featuresAtLocation({ lng: d, lat: f }, l);
  }
  getFeaturesAtPointerEvent(i, l) {
    const d = this._adapter.getLngLatFromEvent.bind(this._adapter)(i);
    return d === null ? [] : this.featuresAtLocation(d, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) || d.push(l);
  }
  off(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) && d.splice(d.indexOf(l), 1);
  }
}
class AI extends EI.TerraDrawBaseAdapter {
  constructor(i) {
    super(i), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = i.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = i.renderBelowLayerId, this._prefixId = i.prefixId || "td";
  }
  _addGeoJSONSource(i, l) {
    this._map.addSource(i, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(i) {
    return this._map.addLayer({ id: i + "-outline", source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(i, l) {
    l === "Point" && this._addPointLayer(i), l === "LineString" && this._addLineLayer(i), l === "Polygon" && (this._addFillLayer(i), this._addFillOutlineLayer(i));
  }
  _addGeoJSONLayer(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._addGeoJSONSource(d, l), this._addLayer(d, i), d;
  }
  _setGeoJSONLayerData(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._map.getSource(d).setData({ type: "FeatureCollection", features: l }), d;
  }
  updateChangedIds(i) {
    [...i.updated, ...i.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), i.deletedIds.length > 0 && (this.changedIds.deletion = true), i.created.length === 0 && i.updated.length === 0 && i.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(i) {
    const { left: l, top: d } = this._container.getBoundingClientRect();
    return this.unproject(i.clientX - l, i.clientY - d);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(i) {
    i ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(i, l) {
    const { x: d, y: f } = this._map.project({ lng: i, lat: l });
    return { x: d, y: f };
  }
  unproject(i, l) {
    const { lng: d, lat: f } = this._map.unproject({ x: i, y: l });
    return { lng: d, lat: f };
  }
  setCursor(i) {
    const l = this._map.getCanvas();
    i === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = i;
  }
  setDoubleClickToZoom(i) {
    i ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(i, l) {
    this.updateChangedIds(i), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const d = [...i.created, ...i.updated, ...i.unchanged], f = [], g = [], m = [];
      for (let M = 0; M < d.length; M++) {
        const F = d[M], { properties: D } = F, A = l[D.mode](F);
        F.geometry.type === "Point" ? (D.pointColor = A.pointColor, D.pointOutlineColor = A.pointOutlineColor, D.pointOutlineWidth = A.pointOutlineWidth, D.pointWidth = A.pointWidth, D.zIndex = A.zIndex, f.push(F)) : F.geometry.type === "LineString" ? (D.lineStringColor = A.lineStringColor, D.lineStringWidth = A.lineStringWidth, g.push(F)) : F.geometry.type === "Polygon" && (D.polygonFillColor = A.polygonFillColor, D.polygonFillOpacity = A.polygonFillOpacity, D.polygonOutlineColor = A.polygonOutlineColor, D.polygonOutlineWidth = A.polygonOutlineWidth, m.push(F));
      }
      const s = this.changedIds.deletion || this.changedIds.styling, C = s || this.changedIds.linestrings, P = s || this.changedIds.polygons;
      (s || this.changedIds.points) && this._setGeoJSONLayerData("Point", f), C && this._setGeoJSONLayerData("LineString", g), P && this._setGeoJSONLayerData("Polygon", m), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(i) {
    var l;
    super.register(i);
    const d = this._addGeoJSONLayer("Polygon", []), f = this._addGeoJSONLayer("LineString", []), g = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(g, this._renderBeforeLayerId), this._map.moveLayer(f, g), this._map.moveLayer(d + "-outline", f), this._map.moveLayer(d, f)), (l = this._currentModeCallbacks) != null && l.onReady && this._currentModeCallbacks.onReady();
  }
}
const xn = [];
for (let r = 0; r < 256; ++r) xn.push((r + 256).toString(16).slice(1));
function DI(r, i = 0) {
  return (xn[r[i + 0]] + xn[r[i + 1]] + xn[r[i + 2]] + xn[r[i + 3]] + "-" + xn[r[i + 4]] + xn[r[i + 5]] + "-" + xn[r[i + 6]] + xn[r[i + 7]] + "-" + xn[r[i + 8]] + xn[r[i + 9]] + "-" + xn[r[i + 10]] + xn[r[i + 11]] + xn[r[i + 12]] + xn[r[i + 13]] + xn[r[i + 14]] + xn[r[i + 15]]).toLowerCase();
}
let Jm;
const zI = new Uint8Array(16);
function FI() {
  if (!Jm) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Jm = crypto.getRandomValues.bind(crypto);
  }
  return Jm(zI);
}
const LI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), i_ = { randomUUID: LI };
function Od(r, i, l) {
  var _a3;
  if (i_.randomUUID && !r) return i_.randomUUID();
  r = r || {};
  const d = r.random ?? ((_a3 = r.rng) == null ? void 0 : _a3.call(r)) ?? FI();
  if (d.length < 16) throw new Error("Random bytes length must be >= 16");
  return d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, DI(d);
}
function Ho() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function BI() {
  return { ...Ho(), version: 1, signature: void 0 };
}
class Rl {
  constructor(i = Od(), l, d, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = i, this.routes = l || { id: Od(), meta: Ho(), routes: [] }, this.drafts = d || { id: Od(), meta: Ho(), drafts: [] }, this.meta = { ...BI(), ...f };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(i) {
    return new Rl(i.id, i.routes, i.drafts, i.meta);
  }
  clone() {
    return Rl.fromStorage(this.toStorage());
  }
  updateName(i) {
    this.meta.name = i, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(i) {
    this.meta.description = i, this.meta.modification_timestamp = Date.now();
  }
  addTag(i) {
    this.meta.tags.includes(i) || (this.meta.tags.push(i), this.meta.modification_timestamp = Date.now());
  }
  removeTag(i) {
    const l = this.meta.tags.indexOf(i);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class OI {
  constructor(i = [], l = Od(), d = Ho()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = d || Ho(), this.routesInternal = i;
  }
  get name() {
    return this.meta || (this.meta = Ho()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Ho()), this.meta.name = i;
  }
  get routes() {
    return Ha(this.routesInternal);
  }
  set routes(i) {
    this.routesInternal = Ha(i);
  }
  findRoute(i) {
    return this.routesInternal.find((l) => l.id === i);
  }
  existRoute(i) {
    return this.routesInternal.some((l) => l.id === i);
  }
  addRoute(i) {
    if (this.existRoute(i.id)) throw new Error(`[CartoSketch.Route] Route ${i.id} already exist`);
    this.routesInternal.push(Ha(i)), this.updateModificationTime();
  }
  updateRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${i.id} not found`);
    this.routesInternal[l] = Ha(i), this.updateModificationTime();
  }
  removeRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((i) => i.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((i) => i.exportToStorage()) });
  }
}
class Qm {
  constructor(i = Od(), l = [], d = {}, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = i, this.meta = { ...Ho(), record_timespan: 0, ...f }, this.properties = d, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = Ho()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Ho()), this.meta.name = i;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(i) {
    this.meta.distance = i;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(i) {
    this.meta.record_timespan = i;
  }
  setPoints(i) {
    this.points = Ha(i), this.updateModificationTime();
  }
  appendPoint(i) {
    this.points.push(Ha(i)), this.updateModificationTime();
  }
  getPoints() {
    return Ha(this.points);
  }
  setProperties(i) {
    const l = Ha(i);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((i) => [i.longitude, i.latitude]) } };
  }
  exportToStorage() {
    return Ha({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var ri = ((r) => (r.MIGRATION_FAILED = "MIGRATION_FAILED", r.INVALID_VERSION = "INVALID_VERSION", r.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", r.ROLLBACK_FAILED = "ROLLBACK_FAILED", r.VALIDATION_FAILED = "VALIDATION_FAILED", r.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", r.DATA_CORRUPTION = "DATA_CORRUPTION", r))(ri || {});
class vi extends o2 {
  constructor(i, l = "MIGRATION_FAILED", d) {
    super(i, d);
    __publicField(this, "code");
    __publicField(this, "domain", a2.GENERIC);
    this.code = l;
  }
}
class ha extends vi {
  constructor(i, l = "INVALID_VERSION", d, f, g) {
    super(i, l, g), this.currentVersion = d, this.targetVersion = f;
  }
}
class $r extends vi {
  constructor(i, l, d, f) {
    super(i, "VALIDATION_FAILED", f), this.field = l, this.value = d;
  }
}
class n_ extends vi {
  constructor(i, l, d) {
    super(i, "DATA_CORRUPTION", d), this.corruptedData = l;
  }
}
class $I extends vi {
  constructor(i, l, d, f) {
    super(i, "ROLLBACK_FAILED", f), this.originalError = l, this.rollbackError = d;
  }
}
class Ed {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(i) {
    try {
      if (typeof i == "object" && i !== null && "version" in i) {
        const l = i.version;
        if (typeof l == "number" && l >= 0) return $i(l);
      }
      if (this.isRouteCollectionFormat(i)) return $i(0);
      if (this.isSketchArrayFormat(i)) return $i(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const d = l instanceof ha ? l : new ha(`Failed to extract version from data: ${l}`, ri.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static isRouteCollectionFormat(i) {
    return typeof i == "object" && i !== null && "routes" in i && !("sketches" in i) && Array.isArray(i.routes);
  }
  static isSketchArrayFormat(i) {
    return Array.isArray(i) && i.length > 0 && this.isSketchObject(i[0]);
  }
  static isSketchObject(i) {
    return typeof i == "object" && i !== null && "id" in i && "meta" in i && "routes" in i && "drafts" in i;
  }
  static validateVersion(i) {
    try {
      if (i < this.MIN_SUPPORTED_VERSION) throw new ha(`Version ${i} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, ri.UNSUPPORTED_VERSION, i);
      if (i > this.CURRENT_VERSION) throw new ha(`Version ${i} is above current version ${this.CURRENT_VERSION}`, ri.UNSUPPORTED_VERSION, i, this.CURRENT_VERSION);
      return $i(void 0);
    } catch (l) {
      const d = l instanceof ha ? l : new ha(`Version validation failed: ${l}`, ri.INVALID_VERSION, i, void 0, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static addVersionMetadata(i, l = this.CURRENT_VERSION) {
    return { ...i, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(i) {
    try {
      if (typeof i == "object" && i !== null && this.VERSION_KEY in i) {
        const l = i[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return $i(l);
      }
      return $i(null);
    } catch (l) {
      const d = l instanceof ha ? l : new ha(`Failed to extract version metadata: ${l}`, ri.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static isValidVersionInfo(i) {
    return typeof i == "object" && i !== null && "version" in i && "timestamp" in i && typeof i.version == "number" && typeof i.timestamp == "number";
  }
  static determineMigrationPath(i, l) {
    try {
      const d = this.validateVersion(i);
      if (d.isErr()) throw d.error;
      const f = this.validateVersion(l);
      if (f.isErr()) throw f.error;
      if (i === l) return $i([]);
      const g = [], m = i < l ? 1 : -1;
      for (let s = i; s !== l; s += m) g.push(s + m);
      return $i(g);
    } catch (d) {
      const f = d instanceof ha ? d : new ha(`Failed to determine migration path: ${d}`, ri.INVALID_VERSION, i, l, d instanceof Error ? d : new Error(String(d)));
      return Dr(f);
    }
  }
  static isMigrationNeeded(i) {
    return this.extractVersion(i).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(Ed, "CURRENT_VERSION", 1);
__publicField(Ed, "VERSION_KEY", "_data_version");
__publicField(Ed, "MIN_SUPPORTED_VERSION", 0);
class Ya {
  static validateSketchData(i) {
    try {
      if (!i || typeof i != "object") throw new $r("Sketch data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes", "drafts"];
      for (const g of d) if (!(g in l)) throw new $r(`Missing required field: ${g}`, g, l[g]);
      if (typeof l.id != "string" || !l.id) throw new $r("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new $r("Sketch meta must be an object", "meta", l.meta);
      const f = this.validateRouteCollectionData(l.routes);
      if (f.isErr()) throw f.error;
      if (!l.drafts || typeof l.drafts != "object") throw new $r("Sketch drafts must be an object", "drafts", l.drafts);
      return $i(l);
    } catch (l) {
      if (l instanceof $r) return Dr(l);
      const d = new $r(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static validateRouteCollectionData(i) {
    try {
      if (!i || typeof i != "object") throw new $r("Route collection data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes"];
      for (const f of d) if (!(f in l)) throw new $r(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new $r("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new $r("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new $r("Routes must be an array", "routes", l.routes);
      for (let f = 0; f < l.routes.length; f++) {
        const g = l.routes[f], m = this.validateRouteItem(g);
        if (m.isErr()) throw new $r(`Invalid route at index ${f}: ${m.error.message}`, `routes[${f}]`, g, m.error);
      }
      return $i(l);
    } catch (l) {
      if (l instanceof $r) return Dr(l);
      const d = new $r(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static validateRouteItem(i) {
    try {
      if (!i || typeof i != "object") throw new $r("Route item must be an object", "data", i);
      const l = i, d = ["id", "meta", "properties", "points"];
      for (const f of d) if (!(f in l)) throw new $r(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new $r("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new $r("Route points must be an array", "points", l.points);
      for (let f = 0; f < l.points.length; f++) {
        const g = l.points[f];
        if (!g || typeof g != "object") throw new $r(`Route point at index ${f} must be an object`, `points[${f}]`, g);
        const m = g;
        if (typeof m.latitude != "number" || typeof m.longitude != "number") throw new $r(`Route point at index ${f} must have numeric latitude and longitude`, `points[${f}]`, g);
      }
      return $i(l);
    } catch (l) {
      if (l instanceof $r) return Dr(l);
      const d = new $r(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static validateSketchArray(i) {
    try {
      if (!Array.isArray(i)) throw new $r("Sketch array must be an array", "data", i);
      if (i.length === 0) throw new $r("Sketch array cannot be empty", "data.length", i.length);
      for (let l = 0; l < i.length; l++) {
        const d = i[l], f = this.validateSketchData(d);
        if (f.isErr()) throw new $r(`Invalid sketch at index ${l}: ${f.error.message}`, `[${l}]`, d, f.error);
      }
      return $i(i);
    } catch (l) {
      if (l instanceof $r) return Dr(l);
      const d = new $r(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Dr(d);
    }
  }
  static validateData(i, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(i);
      case "route-collection":
        return this.validateRouteCollectionData(i);
      case "sketch-array":
        return this.validateSketchArray(i);
      default:
        return Dr(new $r(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(i, l) {
    try {
      const d = this.validateData(i, l);
      return d.isErr() ? Dr(new n_(`Data validation failed: ${d.error.message}`, i, d.error)) : $i({ isValid: true, errors: [], warnings: [] });
    } catch (d) {
      return Dr(new n_(`Data integrity check failed: ${d}`, i, d instanceof Error ? d : new Error(String(d))));
    }
  }
}
class jI {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(i) {
    try {
      const l = Ya.validateRouteCollectionData(i);
      if (l.isErr()) return Dr(new vi(`Invalid route collection data: ${l.error.message}`, ri.VALIDATION_FAILED, l.error));
      const d = l.value, f = new Rl();
      f.meta.name = d.meta.name || "Migrated Routes", f.meta.description = d.meta.description || "Migrated from route collection", f.meta.creation_timestamp = d.meta.creation_timestamp, f.meta.modification_timestamp = Date.now(), f.routes = d;
      const g = [f.toStorage()];
      return $i(g);
    } catch (l) {
      return Dr(new vi(`Route collection to sketch migration failed: ${l}`, ri.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(i) {
    try {
      const l = Ya.validateSketchArray(i);
      if (l.isErr()) return Dr(new vi(`Invalid sketch array data for rollback: ${l.error.message}`, ri.VALIDATION_FAILED, l.error));
      const d = l.value;
      if (d.length === 0) return Dr(new vi("Cannot rollback: empty sketch array", ri.MIGRATION_FAILED));
      const f = d[0];
      return $i(f.routes);
    } catch (l) {
      return Dr(new vi(`Route collection to sketch rollback failed: ${l}`, ri.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(i) {
    return Ya.validateRouteCollectionData(i).map(() => {
    }).mapErr((l) => new $r(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Ya.validateSketchArray(i).map(() => {
    }).mapErr((l) => new $r(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class NI {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return Dr(new vi("Sketch V1 to V2 migration not yet implemented", ri.STRATEGY_NOT_FOUND));
  }
  validateBefore(i) {
    return Ya.validateSketchArray(i).map(() => {
    }).mapErr((l) => new $r(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Dr(new $r("Sketch V2 validation not yet implemented", void 0, i));
  }
}
const _VI = class _VI {
  static register(i) {
    const l = this.getStrategyKey(i.fromVersion, i.toVersion);
    this.strategies.set(l, i);
  }
  static getStrategy(i, l) {
    const d = this.getStrategyKey(i, l), f = this.strategies.get(d);
    return f ? $i(f) : Dr(new vi(`No migration strategy found for version ${i} to ${l}`, ri.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(i, l) {
    const d = this.getStrategyKey(i, l);
    return this.strategies.has(d);
  }
  static getStrategyKey(i, l) {
    return `${i}->${l}`;
  }
};
__publicField(_VI, "strategies", /* @__PURE__ */ new Map());
_VI.register(new jI()), _VI.register(new NI());
let VI = _VI;
class UI {
  static createStrategy(i, l) {
    return VI.getStrategy(i, l);
  }
  static createStrategiesForPath(i) {
    try {
      const l = [];
      for (let d = 0; d < i.length; d++) {
        const f = d === 0 ? i[0] - 1 : i[d - 1], g = i[d], m = this.createStrategy(f, g);
        if (m.isErr()) return Dr(m.error);
        l.push(m.value);
      }
      return $i(l);
    } catch (l) {
      return Dr(new vi(`Failed to create strategies for migration path: ${l}`, ri.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class qI {
  static isMigrationNeeded(i) {
    return Ed.isMigrationNeeded(i);
  }
  static getDataVersion(i) {
    return Ed.extractVersion(i);
  }
  static migrateToCurrent(i, l = {}) {
    return this.migrateToVersion(i, Ed.getCurrentVersion(), l);
  }
  static migrateToVersion(i, l, d = {}) {
    try {
      const f = { ...this.DEFAULT_OPTIONS, ...d }, g = Ed.extractVersion(i);
      if (g.isErr()) return Dr(new vi(`Failed to extract current version: ${g.error.message}`, ri.INVALID_VERSION, g.error));
      const m = g.value;
      if (m === l) return $i({ data: i, fromVersion: m, toVersion: l, migratedVersions: [] });
      const s = Ed.determineMigrationPath(m, l);
      if (s.isErr()) return Dr(new vi(`Failed to determine migration path: ${s.error.message}`, ri.INVALID_VERSION, s.error));
      const C = s.value, P = UI.createStrategiesForPath(C);
      if (P.isErr()) return Dr(P.error);
      const M = P.value;
      if (f.validateBefore) {
        const O = this.validateDataBeforeMigration(i, m);
        if (O.isErr()) return Dr(new vi(`Pre-migration validation failed: ${O.error.message}`, ri.VALIDATION_FAILED, O.error));
      }
      const F = f.enableRollback ? i : void 0;
      let D = i;
      const A = [];
      for (const O of M) {
        const V = this.executeMigrationWithRetry(O, D, f);
        if (V.isErr()) {
          if (f.enableRollback && F) {
            const Y = this.rollbackToVersion(F);
            if (Y.isErr()) return Dr(new $I(`Migration failed and rollback also failed: ${Y.error.message}`, V.error, Y.error));
          }
          return Dr(V.error);
        }
        D = V.value, A.push(O.toVersion);
      }
      if (f.validateAfter) {
        const O = this.validateDataAfterMigration(D, l);
        if (O.isErr()) return Dr(new vi(`Post-migration validation failed: ${O.error.message}`, ri.VALIDATION_FAILED, O.error));
      }
      return $i({ data: D, fromVersion: m, toVersion: l, migratedVersions: A, rollbackData: f.enableRollback ? F : void 0 });
    } catch (f) {
      return Dr(new vi(`Migration service error: ${f}`, ri.MIGRATION_FAILED, f instanceof Error ? f : new Error(String(f))));
    }
  }
  static executeMigrationWithRetry(i, l, d) {
    let f = null;
    for (let g = 0; g <= (d.maxRetries || 0); g++) {
      try {
        const m = i.migrate(l);
        if (m.isErr()) {
          f = m.error;
          continue;
        }
        if (i.validateAfter) {
          const s = i.validateAfter(m.value);
          if (s.isErr()) {
            f = new vi(`Post-migration validation failed: ${s.error.message}`, ri.VALIDATION_FAILED, s.error);
            continue;
          }
        }
        return $i(m.value);
      } catch (m) {
        f = new vi(`Migration attempt ${g + 1} failed: ${m}`, ri.MIGRATION_FAILED, m instanceof Error ? m : new Error(String(m)));
      }
      g < (d.maxRetries || 0) && d.retryDelay && console.warn(`Migration failed, retrying in ${d.retryDelay}ms...`);
    }
    return Dr(f || new vi("Migration failed after all retry attempts", ri.MIGRATION_FAILED));
  }
  static rollbackToVersion(i) {
    try {
      return $i(i);
    } catch (l) {
      return Dr(new vi(`Rollback failed: ${l}`, ri.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(i, l) {
    switch (l) {
      case 0:
        return Ya.validateRouteCollectionData(i).map(() => {
        }).mapErr((d) => new vi(`Route collection validation failed: ${d.message}`, ri.VALIDATION_FAILED, d));
      case 1:
        return Ya.validateSketchArray(i).map(() => {
        }).mapErr((d) => new vi(`Sketch array validation failed: ${d.message}`, ri.VALIDATION_FAILED, d));
      default:
        return Dr(new vi(`Unknown version for pre-migration validation: ${l}`, ri.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(i, l) {
    switch (l) {
      case 1:
        return Ya.validateSketchArray(i).map(() => {
        }).mapErr((d) => new vi(`Sketch array validation failed: ${d.message}`, ri.VALIDATION_FAILED, d));
      default:
        return Dr(new vi(`Unknown version for post-migration validation: ${l}`, ri.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(i, l) {
    return Ya.checkDataIntegrity(i, l);
  }
}
__publicField(qI, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const n0 = $g("sketches", () => {
  const r = Re([]), i = Re(null), l = Re(null), d = Me(() => {
    if (!i.value) return null;
    const pe = r.value.find((oe) => oe.id === i.value);
    return pe ? new OI(pe.routes.routes.map((oe) => new Qm(oe.id, oe.points, oe.properties, oe.meta)), pe.routes.id, pe.routes.meta) : null;
  }), f = Me(() => d.value ? d.value.routes.map((pe) => ({ id: pe.id, name: pe.name, points: pe.getPoints(), meta: pe.meta })) : []), g = Me(() => i.value && r.value.find((pe) => pe.id === i.value) || null), m = Me(() => g.value ? g.value.drafts.drafts : []);
  async function s() {
    const pe = await K_("sketches");
    if (pe) {
      const oe = qI.migrateToCurrent(pe, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (oe.isErr()) {
        console.error("[SketchStore] Data migration failed:", oe.error), await C();
        return;
      }
      const fe = oe.value;
      fe.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${fe.fromVersion} to ${fe.toVersion}`), Array.isArray(fe.data) ? (r.value = fe.data.map((_e) => Rl.fromStorage(_e)), r.value.forEach((_e) => {
        _e.routes.routes.forEach(async (qe) => {
          if (qe.points.length > 1 && !qe.meta.distance) try {
            qe.meta.distance = await Mm(qe.points);
          } catch (Ve) {
            console.warn("Failed to calculate route distance:", Ve), qe.meta.distance = 0;
          }
        });
      }), !i.value && r.value.length > 0 && (i.value = r.value[0].id)) : await C();
    } else await C();
  }
  async function C() {
    const pe = new Rl();
    pe.meta.name = "Default Sketch", r.value = [pe], i.value = pe.id, await fo("sketches", r.value.map((oe) => oe.toStorage())), await po();
  }
  async function P(pe = "New Sketch") {
    const oe = new Rl();
    return oe.meta.name = pe, r.value.push(oe), await fo("sketches", r.value.map((fe) => fe.toStorage())), await po(), oe;
  }
  async function M(pe, oe) {
    const fe = r.value.find((_e) => _e.id === pe);
    fe && (oe.name !== void 0 && fe.updateName(oe.name), oe.description !== void 0 && fe.updateDescription(oe.description), oe.tags !== void 0 && (fe.meta.tags.forEach((_e) => fe.removeTag(_e)), oe.tags.forEach((_e) => fe.addTag(_e))), await fo("sketches", r.value.map((_e) => _e.toStorage())), await po());
  }
  async function F(pe) {
    const oe = r.value.findIndex((fe) => fe.id === pe);
    oe !== -1 && (r.value.splice(oe, 1), i.value === pe && (i.value = r.value.length > 0 ? r.value[0].id : null), await fo("sketches", r.value.map((fe) => fe.toStorage())), await po());
  }
  function D(pe) {
    i.value = pe, l.value = null;
  }
  async function A(pe, oe = {}, fe = {}) {
    g.value || await C();
    const _e = new Qm(void 0, [], oe, fe);
    return _e.meta.name = pe, g.value && g.value.routes.routes.push(_e.exportToStorage()), await fo("sketches", r.value.map((qe) => qe.toStorage())), await po(), _e;
  }
  async function O(pe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.findIndex((fe) => fe.id === pe);
    oe !== -1 && (g.value.routes.routes.splice(oe, 1), l.value === pe && (l.value = null), await fo("sketches", r.value.map((fe) => fe.toStorage())), await po());
  }
  async function V(pe, oe) {
    if (!g.value) return;
    const fe = g.value.routes.routes.find((_e) => _e.id === pe);
    if (fe) {
      if (fe.points.push(oe), fe.meta.modification_timestamp = Date.now(), fe.points.length > 1) try {
        if (fe.meta.distance) {
          const _e = await Mm([fe.points[fe.points.length - 2], oe]);
          fe.meta.distance += _e;
        } else {
          const _e = await Mm(fe.points);
          fe.meta.distance = _e;
        }
      } catch (_e) {
        console.warn("Failed to calculate route distance:", _e), fe.meta.distance || (fe.meta.distance = 0);
      }
      await fo("sketches", r.value.map((_e) => _e.toStorage())), await po();
    }
  }
  async function Y(pe, oe) {
    if (!g.value) return;
    const fe = g.value.routes.routes.find((_e) => _e.id === pe);
    fe && (oe.meta !== void 0 && (fe.meta = { ...fe.meta, ...oe.meta }), oe.properties !== void 0 && (fe.properties = { ...fe.properties, ...oe.properties }), fe.meta.modification_timestamp = Date.now(), await fo("sketches", r.value.map((_e) => _e.toStorage())), await po());
  }
  async function W(pe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((fe) => fe.id === pe);
    oe && (oe.points = [], oe.meta.modification_timestamp = Date.now(), await fo("sketches", r.value.map((fe) => fe.toStorage())), await po());
  }
  function ee(pe) {
    if (!g.value) return null;
    const oe = g.value.routes.routes.find((fe) => fe.id === pe);
    return oe ? new Qm(oe.id, oe.points, oe.properties, oe.meta) : null;
  }
  function ie(pe) {
    l.value = pe;
  }
  async function te(pe, oe = {}, fe = {}) {
    g.value || await C();
    const _e = { id: crypto.randomUUID(), meta: { ...Ho(), ...fe }, shape: pe, properties: oe };
    return g.value && g.value.drafts.drafts.push(_e), await fo("sketches", r.value.map((qe) => qe.toStorage())), await po(), _e;
  }
  async function re(pe, oe) {
    if (!g.value) return;
    const fe = g.value.drafts.drafts.find((_e) => _e.id === pe);
    fe && (oe.shape !== void 0 && (fe.shape = oe.shape), oe.properties !== void 0 && (fe.properties = { ...fe.properties, ...oe.properties }), oe.meta !== void 0 && (fe.meta = { ...fe.meta, ...oe.meta }, fe.meta.modification_timestamp = Date.now()), await fo("sketches", r.value.map((_e) => _e.toStorage())), await po());
  }
  async function X(pe) {
    if (!g.value) return;
    const oe = g.value.drafts.drafts.findIndex((fe) => fe.id === pe);
    oe !== -1 && (g.value.drafts.drafts.splice(oe, 1), await fo("sketches", r.value.map((fe) => fe.toStorage())), await po());
  }
  function Se(pe) {
    return g.value && g.value.drafts.drafts.find((oe) => oe.id === pe) || null;
  }
  return { sketches: r, currentSketchId: i, currentRouteId: l, routeCollection: d, routes: f, currentSketch: g, currentDrafts: m, init: s, createSketch: P, updateSketch: M, deleteSketch: F, setCurrentSketchId: D, addRoute: A, deleteRoute: O, addPointToRoute: V, updateRoute: Y, clearRoutePoints: W, getRouteById: ee, setCurrentRouteId: ie, addDraft: te, updateDraft: re, deleteDraft: X, getDraftById: Se };
}), w1 = $g("routes", () => {
  const r = n0(), i = Me(() => r.routeCollection), l = Me({ get: () => r.currentRouteId, set: (X) => r.setCurrentRouteId(X) }), d = Re(0);
  Ht(l, (X) => {
    var _a3, _b2;
    X && (d.value = ((_b2 = (_a3 = r.getRouteById(X)) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const f = Re(false), g = Re(-1), m = Re(null);
  let s;
  const C = Me(() => r.routes);
  function P(X) {
    m.value = X;
  }
  async function M() {
    await r.init();
  }
  async function F(X, Se = {}) {
    return await r.addRoute(X, Se);
  }
  async function D(X) {
    await r.deleteRoute(X);
  }
  async function A(X, Se) {
    await r.addPointToRoute(X, Se);
  }
  async function O(X, Se) {
    await r.updateRoute(X, Se);
  }
  async function V(X) {
    await r.clearRoutePoints(X);
  }
  function Y(X) {
    return r.getRouteById(X);
  }
  function W(X) {
    r.setCurrentRouteId(X);
  }
  function ee(X) {
    f.value || !m.value || (f.value = true, X && A(l.value, X), g.value = m.value.addLocationListener((Se) => {
      l.value && A(l.value, Se);
    }), r.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), s = setInterval(async () => {
      const Se = r.getRouteById(l.value);
      Se.recordTimespan !== void 0 && Se.meta.modification_timestamp && (d.value = Se.recordTimespan + (Date.now() - Se.meta.modification_timestamp), await r.updateRoute(l.value, { meta: { record_timespan: d.value } }));
    }, 100));
  }
  function ie() {
    !f.value || !m.value || (g.value !== -1 && (m.value.removeLocationListener(g.value), g.value = -1), s && (clearTimeout(s), s = void 0), f.value = false);
  }
  async function te(X) {
    try {
      if (!m.value) throw new Error("Geolocation service not available");
      if (f.value) ie();
      else if (l.value) ee();
      else {
        const Se = await F(X("trackerView.nameNewRoute"));
        W(Se.id), ee(m.value.getLastKnownLocation());
      }
    } catch (Se) {
      throw console.error(Se), Se;
    }
  }
  function re() {
    g.value !== -1 && m.value && (m.value.removeLocationListener(g.value), g.value = -1), f.value = false;
  }
  return { routeCollection: i, routes: C, currentRouteId: l, isRecording: f, watchingHandler: g, currentRouteRecordTimespan: d, setLocator: P, init: M, addRoute: F, deleteRoute: D, addPointToRoute: A, updateRoute: O, clearRoutePoints: V, getRouteById: Y, setCurrentRouteId: W, startRecording: ee, stopRecording: ie, toggleRecording: te, cleanup: re };
}), GI = { class: "upload-container" }, WI = { class: "action-buttons" }, ZI = ot({ __name: "TextFileUploaderDialog", props: es({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: es(["update:value", "confirm"], ["update:show"]), setup(r, { emit: i }) {
  const l = cp(), d = r, f = i, g = tc(r, "show");
  let m = [];
  const s = (M) => {
    m = [];
    for (const F of M) {
      const D = F.file;
      if (D) if (d.types.includes(D.type)) {
        const A = new FileReader();
        A.onload = (O) => {
          var _a3;
          ((_a3 = O.target) == null ? void 0 : _a3.result) && m.push(O.target.result), m.length === M.length && f("update:value", m);
        }, A.readAsText(D);
      } else l.warning(`Skipped file ${F.name} due to unsupported type ${D.type}`);
    }
  }, C = () => {
    f("confirm", m), g.value = false;
  }, P = (M) => {
    var _a3, _b2;
    return d.types.includes(((_a3 = M.file.file) == null ? void 0 : _a3.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = M.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${d.types.join("', '")}']`), false);
  };
  return (M, F) => (wt(), Tr(J(Vd), { show: g.value, "onUpdate:show": F[2] || (F[2] = (D) => g.value = D), preset: "dialog", title: "Dialog" }, { header: Ne(() => [...F[3] || (F[3] = [Pr(" File Upload ", -1)])]), default: Ne(() => [Pt("div", GI, [$e(J(v6), { multiple: d.multiple ?? false, onChange: F[0] || (F[0] = ({ fileList: D }) => s(D)), onBeforeUpload: P }, { default: Ne(() => [$e(J(Qb), null, { default: Ne(() => [$e(J(Ci), { size: 36, name: "upload", class: "upload-icon" }, { default: Ne(() => [(wt(), Tr(rc(d.icon ?? J(gb))))]), _: 1 }), Pt("div", null, ur(d.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: Ne(() => [Pt("div", WI, [$e(J(Nr), { onClick: F[1] || (F[1] = (D) => g.value = false) }, { default: Ne(() => [...F[4] || (F[4] = [Pr(" Cancel ", -1)])]), _: 1 }), $e(J(Nr), { type: "primary", onClick: C }, { default: Ne(() => [...F[5] || (F[5] = [Pr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), HI = Qn(ZI, [["__scopeId", "data-v-14c5a0c1"]]), XI = ot({ __name: "MglDrawer", props: es({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: es(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(r, { emit: i }) {
  Fl((D) => ({ a1b7bba2: J(f).modalColor, v305889d2: J(f).borderRadius, v60287bc6: M.value, v048a7f4c: P.value }));
  const l = r, d = i, f = ks(), g = s2("route-drawer"), m = Me(() => l.position || "left"), s = Me(() => {
    var _a3, _b2, _c, _d;
    return Math.min(vg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), C = Me(() => {
    var _a3, _b2, _c, _d;
    return Math.min(vg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), P = Me(() => m.value === "left" ? `${-16 - s.value}px` : m.value === "right" ? `${16 + s.value}px` : m.value === "top" ? `${-16 - C.value}px` : m.value === "bottom" ? `${16 + C.value}px` : "0px"), M = Me(() => m.value === "left" || m.value === "right" ? `${s.value}px` : `${C.value}px`), F = tc(r, "show");
  return Ht(s, () => d("update:width", s.value)), Ht(C, () => d("update:height", C.value)), (D, A) => (wt(), Tr(Io, { name: `slide-${m.value}` }, { default: Ne(() => [ga(Pt("div", { ref: "route-drawer", class: qo(["route-drawer", `route-drawer--${m.value}`]), onClick: A[0] || (A[0] = (O) => d("click", O)), onContextmenu: A[1] || (A[1] = (O) => d("contextmenu", O)) }, [jg(D.$slots, "default", {}, void 0, true)], 34), [[Qa, F.value]])]), _: 3 }, 8, ["name"]));
} }), YI = Qn(XI, [["__scopeId", "data-v-72b274a7"]]), KI = { class: "menu-list" }, JI = ["onClick", "onContextmenu", "onTouchstart"], QI = { class: "swipe-container" }, e4 = { style: { height: "fit-content", padding: "8px 12px" } }, t4 = ["onClick"], r4 = { style: { padding: "16px" } }, i4 = 120, n4 = 40, o4 = ot({ __name: "SelectableSwipeableMenuList", props: es({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: es(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(r, { emit: i }) {
  Fl((te) => ({ af602246: J(m).hoverColor, v2c598f52: J(m).primaryColor, f032366a: J(m).bodyColor, v6ce963b2: s.value }));
  const l = r, d = tc(r, "selection"), f = tc(r, "multipleSelection"), g = i, m = ks(), s = Re("0s"), C = Re({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), P = Re(false), M = Re(0), F = Re(0), D = Re(null);
  function A(te, re) {
    C.value.activeId !== re && W();
    const X = te.touches[0];
    C.value = { startX: X.clientX, delta: C.value.delta ?? 0, currentX: X.clientX, containerWidth: te.currentTarget.offsetWidth, activeId: re, leftMax: i4, rightMax: n4 };
  }
  function O(te) {
    C.value.activeId && (C.value.currentX = te.touches[0].clientX, C.value.delta += C.value.currentX - C.value.startX, C.value.delta = vg(C.value.delta, -C.value.leftMax, C.value.rightMax), C.value.startX = te.touches[0].clientX);
  }
  function V() {
    if (!C.value.activeId) return;
    s.value = `${Math.abs(C.value.delta) / C.value.containerWidth * 0.3}s`, setTimeout(() => {
      s.value = "0s";
    }, 300);
    const te = C.value.delta < 0 ? C.value.leftMax : C.value.rightMax;
    C.value.delta = Math.abs(C.value.delta) > te * 0.4 ? Math.sign(C.value.delta) * te : 0, C.value.delta === 0 && Math.abs(C.value.delta) < 5;
  }
  function Y(te, re) {
    te.stopPropagation(), !(C.value.delta > 5) && (W(), d.value !== re.id && (d.value = re.id));
  }
  function W() {
    C.value.delta > 0 || (C.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function ee(te, re) {
    if (te.stopPropagation(), te.preventDefault(), P.value) {
      P.value = false;
      return;
    }
    D.value = re, M.value = te.clientX, F.value = te.clientY, P.value = true, g("contextmenu", te, re);
  }
  function ie(te) {
    const re = [...f.value];
    if (re.includes(te)) {
      const X = re.indexOf(te);
      re.splice(X, 1);
    } else re.push(te);
    f.value = re;
  }
  return (te, re) => (wt(), Xt(Hr, null, [Pt("div", KI, [(wt(true), Xt(Hr, null, fn(l.items, (X) => (wt(), Xt("div", { key: X.id, class: qo(["menu-list-item", ...X.id === d.value ? ["active"] : []]), style: In({ "touch-action": C.value.activeId === X.id ? "pan-y" : "auto" }), onClick: (Se) => Y(Se, X), onContextmenu: $d((Se) => ee(Se, X), ["prevent"]), onTouchstart: (Se) => A(Se, X.id), onTouchmove: O, onTouchend: V }, [Pt("div", QI, [Pt("div", { class: "content-col", style: In({ transform: `translateX(${C.value.activeId === X.id || C.value.delta > 0 ? C.value.delta : 0}px)`, willChange: C.value.activeId === X.id ? "transform" : "auto", flexDirection: C.value.delta >= 0 || C.value.activeId !== X.id ? "row" : "row-reverse" }) }, [jg(te.$slots, "item", { item: X }, () => [Pt("div", e4, [Pt("div", null, ur(X.name ?? "Untitled"), 1)])], true)], 4), Pt("div", { class: "actions-col", style: In({ width: `${C.value.activeId === X.id && C.value.delta < 0 ? -C.value.delta : 0}px`, visibility: C.value.activeId === X.id && C.value.delta < 0 ? "visible" : "hidden", willChange: C.value.activeId === X.id ? "width" : "auto" }) }, [(wt(true), Xt(Hr, null, fn(l.swipeActions, (Se) => (wt(), Xt("button", { key: Se.name, class: "menu-action", style: In({ background: Se.color || J(m).primaryColorSuppl }), onClick: () => {
    Se.action(X.id), C.value.activeId = null;
  } }, ur(Se.label), 13, t4))), 128))], 4), Pt("div", { class: "select-col", style: In({ width: `${C.value.delta > 0 ? C.value.delta : 0}px`, backgroundColor: d.value === X.id ? J(m).primaryColor : "transparent", visibility: C.value.delta > 0 ? "visible" : "hidden" }) }, [Pt("div", r4, [$e(J(rP), { checked: f.value.includes(X.id), style: In({ border: d.value === X.id ? `1px solid ${J(m).bodyColor}` : "none", BorderRadius: d.value === X.id ? J(m).borderRadiusSmall : "none" }), "onUpdate:checked": () => ie(X.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, JI))), 128))]), $e(J(J_), { show: P.value, x: M.value, y: F.value, options: l.menuOptions.map((X) => {
    var _a3;
    return { ...X, label: ((_a3 = X.label) == null ? void 0 : _a3.value) ?? X.label };
  }), placement: "bottom-start", trigger: "manual", onClick: re[0] || (re[0] = (X) => P.value = false), onClickoutside: re[1] || (re[1] = (X) => P.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), a4 = Qn(o4, [["__scopeId", "data-v-b353d352"]]), s4 = { class: "drawer-floating" }, l4 = { class: "drawer-container" }, u4 = { class: "drawer-header" }, c4 = { class: "drawer-title" }, d4 = { class: "drawer-content" }, h4 = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, f4 = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, p4 = { key: 0 }, m4 = ot({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: es(["update:width"], ["update:show"]), setup(r, { emit: i }) {
  Fl((pe) => ({ v38b2b83c: J(C).borderRadius, v3ddcb48b: J(C).hoverColor, v485009dd: J(C).primaryColorPressed, v4f454a85: J(C).primaryColor, v73f3b15d: J(C).bodyColor }));
  const d = new Zg().isMobile, { t: f } = Eo(), g = Fb(), m = i, s = w1(), C = ks(), P = tc(r, "show"), M = Re(false), F = Re(0), D = Re(0), A = Re(null), O = Re(false), V = Re(""), Y = Re(null), W = [{ label: Me(() => f("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    M.value = false, s.addRoute(f("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], ee = [{ label: Me(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a3;
    ((_a3 = A.value) == null ? void 0 : _a3.id) && (V.value = A.value.name || "", O.value = true);
  } } }, { label: Me(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    A.value && s.deleteRoute(A.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...W], ie = [{ label: Me(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (pe) => {
    const oe = s.routes.find((fe) => fe.id === pe);
    Y.value = pe, V.value = (oe == null ? void 0 : oe.name) || "", O.value = true;
  } }, { label: Me(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (pe) => s.deleteRoute(pe), color: C.value.errorColorSuppl }];
  function te(pe) {
    if (pe.stopPropagation(), pe.preventDefault(), Y.value = s.currentRouteId, M.value) {
      M.value = false;
      return;
    }
    F.value = pe.clientX, D.value = pe.clientY, M.value = true;
  }
  async function re(pe) {
    V.value.trim() && (await s.updateRoute(pe, { meta: { name: V.value.trim() } }), O.value = false);
  }
  const X = Re([]);
  function Se() {
    g.warning({ title: f("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: f("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: f("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: f("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      X.value.forEach((pe) => {
        s.deleteRoute(pe), X.value = X.value.filter((oe) => oe !== pe);
      });
    } });
  }
  return (pe, oe) => (wt(), Xt(Hr, null, [$e(YI, { show: P.value, "onUpdate:show": oe[3] || (oe[3] = (fe) => P.value = fe), position: J(d) ? "bottom" : "left", onClick: oe[4] || (oe[4] = () => J(s).currentRouteId = null), "onUpdate:width": oe[5] || (oe[5] = (fe) => m("update:width", fe)), onContextmenu: oe[6] || (oe[6] = (fe) => te(fe)) }, { default: Ne(() => [Pt("div", s4, [J(d) && P.value ? jg(pe.$slots, "bottom-floating", { key: 0 }, void 0, true) : jr("", true)]), Pt("div", l4, [Pt("div", u4, [Pt("p", c4, ur(J(f)("components.trackerViewRouteDrawer.routes")), 1), X.value.length > 0 ? (wt(), Tr(J(Nr), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: Se }, { icon: Ne(() => [$e(J(Ci), { component: J(sp) }, null, 8, ["component"])]), _: 1 })) : jr("", true)]), Pt("div", d4, [$e(a4, { selection: J(s).currentRouteId, "onUpdate:selection": oe[0] || (oe[0] = (fe) => J(s).currentRouteId = fe), "multiple-selection": X.value, "onUpdate:multipleSelection": oe[1] || (oe[1] = (fe) => X.value = fe), items: J(s).routes, "menu-options": ee, "swipe-actions": ie, onContextmenu: oe[2] || (oe[2] = (fe, _e) => {
    Y.value = (_e == null ? void 0 : _e.id) ?? null, A.value = _e ?? null;
  }) }, { item: Ne(({ item: fe }) => {
    var _a3;
    return [Pt("div", h4, [Pt("div", null, ur(fe.name ?? J(f)("components.trackerViewRouteDrawer.nameNewRoute")), 1), Pt("div", f4, [Pt("div", null, ur(J(f)("components.trackerViewRouteDrawer.points", { num: fe.points.length })), 1), fe.points.length > 1 && ((_a3 = fe.meta) == null ? void 0 : _a3.distance) ? (wt(), Xt("div", p4, ur(J(f)("components.trackerViewRouteDrawer.distance", { distance: J(l2)(fe.meta.distance) })), 1)) : jr("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), $e(J(J_), { show: M.value, x: F.value, y: D.value, options: W.map((fe) => ({ ...fe, label: fe.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: oe[7] || (oe[7] = (fe) => M.value = false) }, null, 8, ["show", "x", "y", "options"]), $e(J(Vd), { show: O.value, "onUpdate:show": oe[10] || (oe[10] = (fe) => O.value = fe), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: oe[11] || (oe[11] = () => {
    Y.value && re(Y.value);
  }) }, { default: Ne(() => [$e(J(mo), { value: V.value, "onUpdate:value": oe[8] || (oe[8] = (fe) => V.value = fe), placeholder: "Enter new route name", onKeyup: oe[9] || (oe[9] = P_(() => {
    Y.value && re(Y.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), g4 = Qn(m4, [["__scopeId", "data-v-a6ce157e"]]), v4 = $g("map", () => {
  const r = Re(7), i = Re([0, 0]), l = Re(0), d = Re(0), f = Re(false);
  async function g() {
    const D = await K_("mapState");
    D && (r.value = D.zoom, i.value = D.center, l.value = D.bearing, f.value = D.isTrackingOrientation, d.value = D.lastUpdateTime);
  }
  async function m() {
    d.value = Date.now();
    const D = { zoom: r.value, center: i.value, bearing: l.value, isTrackingOrientation: f.value, lastUpdateTime: d.value };
    await fo("mapState", JSON.parse(JSON.stringify(D))), await po();
  }
  function s(D) {
    r.value = D;
  }
  function C(D) {
    i.value = D.toLngLatLike();
  }
  function P(D) {
    l.value = D;
  }
  function M(D) {
    f.value = D;
  }
  function F() {
    r.value = 7, i.value = [0, 0], l.value = 0, f.value = false;
  }
  return Ht([r, i, l, f], m, { deep: true }), { zoom: r, center: i, bearing: l, isTrackingOrientation: f, lastUpdateTime: d, init: g, save: m, setZoom: s, setCenter: C, setBearing: P, setTrackingOrientation: M, resetToDefault: F };
});
function y4() {
  for (const r of Al.handlers) r.callback(360 - Al.bearing);
}
var Al;
((r) => {
  r.bearing = 0;
  let i = false;
  r.handlers = [];
  function l(m) {
    if (!(v3(m.alpha) || typeof m.webkitCompassHeading < "u")) {
      g();
      return;
    }
    r.bearing = m.alpha, typeof m.webkitCompassHeading < "u" && (r.bearing = m.webkitCompassHeading), y4();
  }
  r.updater = l;
  function d(m) {
    const s = r.handlers.length > 0 ? r.handlers[r.handlers.length - 1].id + 1 : 0;
    return r.handlers.push({ callback: m, id: s }), s;
  }
  r.addHandler = d;
  function f() {
    i || (window.addEventListener("deviceorientation", l, true), i = true);
  }
  r.start = f;
  function g() {
    i && (window.removeEventListener("deviceorientation", l, true), i = false);
  }
  r.stop = g;
})(Al || (Al = {}));
const _4 = { class: "map-layout-container" }, b4 = { class: "map-layout" }, x4 = { key: 0, style: { width: "100%", height: "100%" } }, w4 = ["title", "onClick"], C4 = { style: { "z-index": "99", position: "absolute", right: "4px", top: "9em" } }, S4 = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, k4 = { style: { "font-family": "monospace", "padding-left": "8px" } }, P4 = ot({ __name: "TrackerView", setup(r) {
  Fl((zt) => {
    var _a3, _b2, _c;
    return { v9a568ab8: (_a3 = J(Cd).Button.common) == null ? void 0 : _a3.successColorSuppl, v7f3e72f8: J(d).boxShadow3, v173b2fe4: J(d).borderRadius, v5167d467: J(d).borderColor, v74e3543a: (_b2 = J(Cd).Button.common) == null ? void 0 : _b2.primaryColorSuppl, v70da48e9: (_c = J(Cd).Button.common) == null ? void 0 : _c.errorColorSuppl };
  });
  const l = new Zg().isMobile, d = ks(), f = uC(), g = v4(), m = cp(), s = pr("geolocation"), { t: C } = Eo(), P = Eo(), F = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", D = Ss(null), A = Ss(null), O = Re("select"), V = w1();
  V.setLocator(s);
  const Y = pr("noSleep"), W = Me(() => {
    var _a3;
    return V.currentRouteId ? ((_a3 = V.routes.find((It) => It.id === V.currentRouteId)) == null ? void 0 : _a3.points) || [] : [];
  }), ee = Re(false), ie = new Ps.Marker(), te = Me(() => {
    if (W.value.length > 1 || W.value.length === 0) return ie.remove(), { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: V.currentRouteId }, geometry: { type: "LineString", coordinates: W.value.map((zt) => [zt.longitude, zt.latitude]) } }] };
    if (W.value.length === 1) {
      ie.setLngLat([W.value[0].longitude, W.value[0].latitude]);
      const zt = D.value;
      zt && ie.addTo(zt);
    }
    return { type: "FeatureCollection", features: [] };
  }), re = [{ mode: new lI(), name: C("trackerView.terraDrawTools.point"), icon: Q_ }, { mode: new rI(), name: C("trackerView.terraDrawTools.line"), icon: $3 }, { mode: new xI({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: C("trackerView.terraDrawTools.select"), icon: B3 }];
  Ht([() => f.settings.mapLanguage, () => P.locale.value], (zt) => {
    zt && D.value && X(D.value, zt[0] === "interface" ? zt[1] : zt[0]);
  });
  const X = (zt, It) => {
    const At = It === "zh-CN" ? "zh" : "en", mr = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const gr of mr) zt.setLayoutProperty(gr, "text-field", ["get", `name:${At}`]);
  };
  function Se(zt) {
    const It = zt.getStyle().layers;
    let At;
    for (let mr = 0; mr < It.length; mr++) {
      const gr = It[mr];
      if (gr.type === "symbol" && gr.layout && typeof gr.layout == "object" && "text-field" in gr.layout) {
        At = gr.id;
        break;
      }
    }
    zt.addLayer({ id: "3d-buildings", source: "openfreemap", "source-layer": "building", type: "fill-extrusion", minzoom: 15, filter: ["!=", ["get", "hide_3d"], true], paint: { "fill-extrusion-color": ["interpolate", ["linear"], ["get", "render_height"], 0, "lightgray", 200, "royalblue", 400, "lightblue"], "fill-extrusion-height": ["interpolate", ["linear"], ["zoom"], 15, 0, 16, ["get", "render_height"]], "fill-extrusion-base": ["case", [">=", ["get", "zoom"], 16], ["get", "render_min_height"], 0] } }, At);
  }
  function pe(zt) {
    zt.removeLayer("3d-buildings");
  }
  const { toggleBuildingLayer: oe, isShowingBuildingLayer: fe } = (() => {
    const zt = Re(false);
    return { toggleBuildingLayer: () => {
      const It = D.value;
      It && (zt.value ? pe(It) : Se(It), zt.value = !zt.value);
    }, isShowingBuildingLayer: Me(() => zt.value) };
  })(), _e = Re(true);
  function qe(zt) {
    var _a3, _b2;
    D.value = zt.map, (_a3 = D.value) == null ? void 0 : _a3.addSource("openfreemap", { url: "https://tiles.openfreemap.org/planet", type: "vector" }), D.value && X(D.value, P.locale.value), g.isTrackingOrientation && (Qt(), Qt()), (_b2 = D.value) == null ? void 0 : _b2.on("click", () => {
      yt.value = false;
    }), A.value = new RI({ adapter: new AI({ map: D.value }), modes: re.map((It) => It.mode) }), A.value.start();
  }
  const Ve = /* @__PURE__ */ (() => {
    let zt = true;
    return async function() {
      try {
        V.isRecording || (zt = V.currentRouteId === null), await V.toggleRecording(C), !V.isRecording && zt && (et.value = true, setTimeout(() => {
          et.value = false;
        }, 3e3)), V.isRecording ? Y.enable() : Y.disable();
      } catch (It) {
        console.error(It), Y.disable();
      }
    };
  })(), Qe = Re(async () => {
  });
  function ut() {
    yt.value = false, m.warning("Not implemented yet");
  }
  const gt = Re(0), yt = Re(false);
  Ht(yt, (zt) => {
    var _a3;
    return (_a3 = D.value) == null ? void 0 : _a3.easeTo({ padding: l ? { bottom: zt ? gt.value : 0 } : { left: zt ? gt.value : 0 }, duration: 500 });
  });
  const lt = () => yt.value = !yt.value, et = Re(false), dt = Re(false);
  ji(async () => {
    var _a3;
    await V.init(), await g.init(), console.log(s.getLastKnownLocation()), Date.now() - g.lastUpdateTime > 6e4 && g.setCenter(s.getLastKnownLocation()), dt.value = true, (_a3 = A.value) == null ? void 0 : _a3.start();
  });
  const Ft = false;
  function ft(zt) {
    const It = zt / 1e3, At = It / 60, mr = At / 60, gr = It % 60, ir = At % 60, nr = mr;
    let Ut = "";
    return Math.floor(nr) > 0 && (Ut += `${String(Math.floor(nr))}h `), Math.floor(ir) > 0 && (Ut += `${String(Math.floor(ir))}m `), Ut += `${String(gr.toFixed(1)).padStart(4, "0")}s`, Ut;
  }
  let _t = 0;
  const $t = (zt) => {
    var _a3, _b2, _c, _d;
    if (_t = zt, g.isTrackingOrientation) {
      if (((_a3 = D.value) == null ? void 0 : _a3.isEasing()) || ((_b2 = D.value) == null ? void 0 : _b2.isMoving()) || ((_c = D.value) == null ? void 0 : _c.isRotating()) || ((_d = D.value) == null ? void 0 : _d.isZooming()) || Lt.value) return;
      g.setBearing(zt);
    }
  }, Qt = /* @__PURE__ */ (() => {
    let zt = null;
    return () => {
      var _a3;
      g.setTrackingOrientation(!g.isTrackingOrientation), g.isTrackingOrientation ? (zt = Al.addHandler($t), Al.start()) : zt !== null && (Al.stop(), zt = null, g.setBearing(0), (_a3 = D.value) == null ? void 0 : _a3.setBearing(0));
    };
  })(), Lt = Re(false);
  return (zt, It) => (wt(), Xt("div", _4, [Pt("div", b4, [$e(Io, { name: "map-load" }, { default: Ne(() => [dt.value ? (wt(), Xt("div", x4, [$e(J(s1), { bearing: J(g).bearing, "onUpdate:bearing": It[2] || (It[2] = (At) => J(g).bearing = At), zoom: J(g).zoom, "onUpdate:zoom": It[3] || (It[3] = (At) => J(g).zoom = At), center: J(g).center, "onUpdate:center": It[4] || (It[4] = (At) => J(g).center = At), "map-style": F, height: "100%", "onMap:load": qe, "onMap:touchstart": It[5] || (It[5] = (At) => Lt.value = true), "onMap:touchend": It[6] || (It[6] = (() => {
    Lt.value = false, J(g).isTrackingOrientation && $t(J(_t));
  })) }, { default: Ne(() => [$e(J(u1), { position: "top-left" }), $e(J(l1), { position: "top-left" }), $e(J(d1), { position: "bottom-left" }), $e(J(Mf), { position: "top-left" }, { default: Ne(() => [J(l) && J(s).isUsingGPS() || Ft ? (wt(), Xt("button", { key: 0, class: qo(["btn-control", { active: _e.value }]), onClick: It[0] || (It[0] = (At) => _e.value = !_e.value) }, [$e(J(Ci), { size: 20 }, { default: Ne(() => [$e(J(I3))]), _: 1 })], 2)) : jr("", true)]), _: 1 }), $e(J(Mf), { position: "top-left" }, { default: Ne(() => [Pt("button", { class: qo(["btn-control", { active: J(fe) }]), onClick: It[1] || (It[1] = (...At) => J(oe) && J(oe)(...At)) }, [$e(J(Ci), { size: 20 }, { default: Ne(() => [$e(J(S3))]), _: 1 })], 2)]), _: 1 }), !J(l) || Ft ? (wt(), Tr(J(Mf), { key: 0, position: "top-right" }, { default: Ne(() => [(wt(), Xt(Hr, null, fn(re, (At) => Pt("button", { key: At.name, class: qo(["btn-control", { active: At.mode.mode === O.value }]), title: At.name, onClick: () => {
    var _a3, _b2, _c;
    console.log("activeDrawMethod", O.value), O.value === At.mode.mode ? ((_a3 = A.value) == null ? void 0 : _a3.setMode("select"), O.value = "select") : (O.value = At.mode.mode, (_b2 = A.value) == null ? void 0 : _b2.start(), (_c = A.value) == null ? void 0 : _c.setMode(At.mode.mode));
  } }, [$e(J(Ci), { size: 20 }, { default: Ne(() => [(wt(), Tr(rc(At.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, w4)), 64))]), _: 1 })) : jr("", true), $e(J(Mf), { position: "bottom-left" }, { default: Ne(() => [$e(J(Ug), { trigger: "manual", show: et.value }, { trigger: Ne(() => [Pt("button", { class: qo(["btn-control", { active: yt.value }]), onClick: lt }, [$e(J(Ci), { size: 24 }, { default: Ne(() => [$e(J(Hg))]), _: 1 })], 2)]), default: Ne(() => [Pt("span", null, ur(J(C)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), $e(J(z6), { "source-id": "geojson", data: te.value, "line-metrics": true }, { default: Ne(() => [$e(J(O6), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-gradient": ["interpolate", ["linear"], ["line-progress"], 0, "#00ff00", 0.7, "#00DD00", 0.9, "#00BB00", 1, "#008800"], "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"]), J(s).isServiceRunning() && _e.value ? (wt(), Tr(J(R6), { key: 1, coordinates: J(s).getLastKnownLocation().toLngLatLike(), color: "#006600" }, null, 8, ["coordinates"])) : jr("", true)]), _: 1 }, 8, ["bearing", "zoom", "center"]), Pt("div", C4, [J(l) || Ft ? (wt(), Tr(N6, { key: 0, bearing: J(g).bearing, "onUpdate:bearing": It[7] || (It[7] = (At) => J(g).bearing = At), tracking: J(g).isTrackingOrientation, onToggleTracking: J(Qt) }, null, 8, ["bearing", "tracking", "onToggleTracking"])) : jr("", true)])])) : (wt(), Xt("div", S4, [$e(J(B5), { size: "large" }, { description: Ne(() => [$e(J(Za), null, { default: Ne(() => [Pr(ur(J(C)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 })]))]), _: 1 })]), $e(HI, { show: ee.value, "onUpdate:show": It[8] || (It[8] = (At) => ee.value = At), types: ["application/json", "text/plain"], onConfirm: Qe.value }, null, 8, ["show", "onConfirm"]), $e(g4, { show: yt.value, "onUpdate:show": It[9] || (It[9] = (At) => yt.value = At), "onUpdate:width": It[10] || (It[10] = (At) => gt.value = At) }, { "bottom-floating": Ne(() => [$e(J(ty), { theme: J(Cd) }, { default: Ne(() => [W.value.length > 1 ? (wt(), Tr(J(Nr), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: ut }, { default: Ne(() => [...It[11] || (It[11] = [Pr(" Follow ", -1)])]), _: 1 })) : jr("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), J(l) || Ft ? (wt(), Xt("div", { key: 0, class: qo(["mobile-record-button-container", { "drawer-open": yt.value }]) }, [$e(J(ty), { theme: J(Cd) }, { default: Ne(() => [$e(J(Nr), { type: J(V).isRecording ? "error" : "primary", size: "large", class: qo(["mobile-record-button", J(V).isRecording ? "recording" : "not-recording"]), onClick: J(Ve) }, { icon: Ne(() => [$e(J(Ci), { size: 20 }, { default: Ne(() => [(wt(), Tr(rc(J(V).isRecording ? J(X3) : J(q3)), { size: J(V).isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: Ne(() => [Pr(" " + ur(J(V).isRecording ? J(C)("trackerView.uiRecordingStatus.on") : J(C)("trackerView.uiRecordingStatus.off")) + " ", 1), Pt("p", k4, ur(J(V).currentRouteRecordTimespan ? `(${ft(J(V).currentRouteRecordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class", "onClick"])]), _: 1 }, 8, ["theme"])], 2)) : jr("", true)]));
} }), C1 = Qn(P4, [["__scopeId", "data-v-a31ee9fa"]]), T4 = Object.freeze(Object.defineProperty({ __proto__: null, default: C1 }, Symbol.toStringTag, { value: "Module" })), I4 = { class: "container" }, M4 = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, E4 = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, R4 = { style: { "font-weight": "500" } }, A4 = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, D4 = ot({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = r, f = i;
  function g(s) {
    f("select", s);
  }
  function m(s) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && f("remove", s);
  }
  return (s, C) => (wt(), Xt("div", I4, [$e(J(dp), { class: "select-listview", hoverable: "" }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(d.list, (P) => (wt(), Tr(J(hp), { key: P.id, title: P.name, onClick: (M) => g(P.id) }, { prefix: Ne(() => [Pt("div", M4, [$e(J(Ci), { size: "20" }, { default: Ne(() => [$e(J(mb))]), _: 1 })])]), suffix: Ne(() => [$e(J(Nr), { quaternary: "", circle: "", onClick: $d((M) => m(P.id), ["stop"]) }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(sp))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), default: Ne(() => [Pt("div", E4, [Pt("div", R4, ur(P.name), 1), Pt("div", A4, [(wt(true), Xt(Hr, null, fn(P.tags, (M) => (wt(), Tr(J(Mo), { key: M, size: "small", type: "info" }, { default: Ne(() => [Pr(ur(M.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), z4 = Qn(D4, [["__scopeId", "data-v-dc2c6049"]]), F4 = ot({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = r, f = [{ title: l("sketchEdit.import"), icon: gb, callback: () => {
    s("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Ud, callback: () => s("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: V3, callback: () => {
    g.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], g = Re(false), m = Re(d.placement);
  Ht(d, () => {
    g.value = d.active, m.value = d.placement;
  }, { deep: true }), Ht(g, () => {
    s("update:active", g.value);
  });
  const s = i;
  return (C, P) => (wt(), Tr(J(Lb), { show: g.value, "onUpdate:show": P[2] || (P[2] = (M) => g.value = M), width: 502, placement: m.value, "auto-focus": false }, { default: Ne(() => [$e(J(Bb), { title: J(l)("sketchEdit.cartoSketchLibrary") }, { footer: Ne(() => [$e(J(Yk), null, { default: Ne(() => [(wt(), Xt(Hr, null, fn(f, (M) => $e(J(Nr), { key: M.title, secondary: M.secondary, type: M.type, title: M.title, onClick: M.callback }, { icon: Ne(() => [$e(J(Ci), { size: M.iconSize }, { default: Ne(() => [(wt(), Tr(rc(M.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: Ne(() => [$e(z4, { list: r.list, onRemove: P[0] || (P[0] = (M) => s("remove", M)), onSelect: P[1] || (P[1] = (M) => s("select", M)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), L4 = ["title", "onClick"], zf = 20, B4 = ot({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i, f = [{ title: l("sketchEdit.save"), icon: E3, iconSize: zf, callback: () => d("save") }, { title: l("sketchEdit.open"), icon: F3, iconSize: zf, callback: () => d("open") }, { title: l("sketchEdit.newComponent"), icon: Ud, iconSize: zf, callback: () => d("create") }, { title: l("sketchEdit.editMetadata"), icon: cC, iconSize: zf, callback: () => d("edit-meta") }];
  return (g, m) => (wt(), Tr(J(vy), { justify: "space-between", align: "center" }, { default: Ne(() => [$e(J(Za), { strong: "" }, { default: Ne(() => [Pr(ur(r.sketchName || J(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), $e(J(vy), { align: "center" }, { default: Ne(() => [r.sketchName !== void 0 ? (wt(), Tr(J(Mo), { key: 0, type: "info", size: "small" }, { default: Ne(() => [Pr(ur(r.draftCount || 0) + " " + ur(J(l)("sketchEdit.drafts")) + ", " + ur(r.routeCount || 0) + " " + ur(J(l)("sketchEdit.routes")), 1)]), _: 1 })) : jr("", true), (wt(), Xt(Hr, null, fn(f, (s, C) => Pt("div", { key: C, title: s.title, class: "tool-tip-item", onClick: s.callback }, [$e(J(Ci), { size: s.iconSize }, { default: Ne(() => [(wt(), Tr(rc(s.icon)))]), _: 2 }, 1032, ["size"])], 8, L4)), 64))]), _: 1 })]), _: 1 }));
} }), O4 = Qn(B4, [["__scopeId", "data-v-5b012717"]]), $4 = { key: 0, class: "empty-state" }, j4 = ot({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i;
  return (f, g) => (wt(), Xt(Hr, null, [$e(J(dp), { hoverable: "" }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(r.components, (m) => (wt(), Tr(J(hp), { key: m.value, class: qo({ "selected-component": r.selectedId === m.value }), onClick: () => d("select", m.value, m.type) }, { prefix: Ne(() => [$e(J(Ci), { color: m.type === "draft" ? "#007bff" : "#28a745" }, { default: Ne(() => [(wt(), Tr(rc(m.type === "draft" ? J(mb) : J(Hg))))]), _: 2 }, 1032, ["color"])]), suffix: Ne(() => [$e(J(k5), { onPositiveClick: (s) => d("delete", m.value, m.type) }, { trigger: Ne(() => [$e(J(Nr), { quaternary: "", circle: "", size: "small" }, { default: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(sp))]), _: 1 })]), _: 1 })]), default: Ne(() => [Pr(" " + ur(J(l)("sketchEdit.deleteComponent")), 1)]), _: 1 }, 8, ["onPositiveClick"])]), default: Ne(() => [Pr(" " + ur(m.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), r.components.length === 0 ? (wt(), Xt("div", $4, [$e(J(qd), { description: J(l)("sketchEdit.noComponentsYet") }, { extra: Ne(() => [$e(J(Nr), { size: "small", onClick: g[0] || (g[0] = (m) => d("create")) }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : jr("", true)], 64));
} }), N4 = Qn(j4, [["__scopeId", "data-v-3addb8a0"]]), V4 = { key: 0, class: "properties-panel" }, U4 = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, q4 = ot({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i;
  return (f, g) => r.component ? (wt(), Xt("div", V4, [$e(J(G5), { type: "line", animated: "", "default-value": "properties" }, { default: Ne(() => [$e(J(zy), { name: "properties", tab: J(l)("sketchEdit.properties") }, { default: Ne(() => [$e(J(Wd), null, { default: Ne(() => [$e(J(wn), { label: J(l)("sketchEdit.visible") }, { default: Ne(() => [$e(J(Yb), { value: r.component.properties.visible !== false, "onUpdate:value": g[0] || (g[0] = (m) => d("updateProperties", { visible: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), r.type === "draft" ? (wt(), Xt(Hr, { key: 0 }, [$e(J(wn), { label: J(l)("sketchEdit.fillColor") }, { default: Ne(() => [$e(J(jm), { value: r.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": g[1] || (g[1] = (m) => d("updateProperties", { fillColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.strokeColor") }, { default: Ne(() => [$e(J(jm), { value: r.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": g[2] || (g[2] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.strokeThickness") }, { default: Ne(() => [$e(J(Ey), { value: r.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": g[3] || (g[3] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : jr("", true), r.type === "route" ? (wt(), Xt(Hr, { key: 1 }, [$e(J(wn), { label: J(l)("sketchEdit.strokeColor") }, { default: Ne(() => [$e(J(jm), { value: r.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": g[4] || (g[4] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.strokeThickness") }, { default: Ne(() => [$e(J(Ey), { value: r.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": g[5] || (g[5] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : jr("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), $e(J(zy), { name: "metadata", tab: J(l)("sketchEdit.metadata") }, { default: Ne(() => [$e(J(Wd), null, { default: Ne(() => [$e(J(wn), { label: J(l)("sketchEdit.name") }, { default: Ne(() => [$e(J(mo), { value: r.component.meta.name, "onUpdate:value": g[6] || (g[6] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: m, description: ((_a3 = r.component) == null ? void 0 : _a3.meta.description) ?? "", tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.description") }, { default: Ne(() => [$e(J(mo), { value: r.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": g[7] || (g[7] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = r.component) == null ? void 0 : _a3.meta.name) ?? "", description: m, tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.tags") }, { default: Ne(() => [$e(J(fT), { value: r.component.meta.tags || [], placeholder: J(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": g[8] || (g[8] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = r.component) == null ? void 0 : _a3.meta.name) ?? "", description: ((_b2 = r.component) == null ? void 0 : _b2.meta.description) ?? "", tags: m });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: "UUID" }, { default: Ne(() => [$e(J(mo), { value: r.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (wt(), Xt("div", U4, [$e(J(qd), { description: J(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), G4 = Qn(q4, [["__scopeId", "data-v-f700b4bc"]]), W4 = "dCeXFrS9lgSF8hm5C6nm", Z4 = `https://api.maptiler.com/maps/basic-v2/style.json?key=${W4}`;
function H4() {
  const r = Re(7), i = Ss(null), l = Re([0, 0]);
  function d(m) {
    i.value = m.map;
  }
  function f(m) {
    l.value = m, i.value && i.value.setCenter(m);
  }
  function g(m) {
    r.value = m, i.value && i.value.setZoom(m);
  }
  return { zoom: r, map: i, center: l, styleUrl: Z4, initMap: d, setCenter: f, setZoom: g };
}
function X4(r, i) {
  const l = [];
  return r.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "draft" });
  }), i.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "route" });
  }), l;
}
function Y4() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function K4() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function J4() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const Q4 = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, eM = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, tM = { class: "sketch-edit-container" }, rM = { class: "grid-layout" }, iM = { class: "meta-info-section" }, nM = { class: "metadata-item" }, oM = { class: "metadata-item" }, aM = ot({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(r) {
  const i = r, { t: l } = Eo(), d = cp(), f = n0(), { zoom: g, styleUrl: m, initMap: s } = H4(), C = Re(false), P = Re(null), M = Re(null), F = Re(false), D = Re(""), A = Re("draft"), O = Re(false), V = Re({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), Y = Re(""), W = Me(() => f.currentSketch), ee = Me(() => f.currentDrafts), ie = Me(() => {
    var _a3;
    return ((_a3 = W.value) == null ? void 0 : _a3.routes.routes) || [];
  }), te = Me(() => !!W.value), re = Me(() => !P.value || !M.value ? null : M.value === "draft" ? f.getDraftById(P.value) : f.getRouteById(P.value)), X = Me(() => X4(ee.value, ie.value));
  async function Se() {
    if (W.value) try {
      await f.updateSketch(W.value.id, { name: W.value.meta.name, description: W.value.meta.description, tags: W.value.meta.tags }), d.success(l("sketchEdit.saveSuccess"));
    } catch (lt) {
      d.error(l("sketchEdit.saveError")), console.error(lt);
    }
  }
  async function pe() {
    const lt = prompt(l("sketchEdit.enterSketchName"));
    lt && (await f.createSketch(lt), C.value = false);
  }
  async function oe() {
    if (!(!D.value.trim() || !W.value)) try {
      if (A.value === "draft") {
        const lt = await f.addDraft(Y4(), K4(), { name: D.value });
        P.value = lt.id, M.value = "draft";
      } else {
        const lt = await f.addRoute(D.value, J4());
        P.value = lt.id, M.value = "route";
      }
      F.value = false, D.value = "", d.success(l("sketchEdit.componentCreated"));
    } catch (lt) {
      d.error(l("sketchEdit.componentCreateError")), console.error(lt);
    }
  }
  async function fe(lt, et) {
    try {
      et === "draft" ? await f.deleteDraft(lt) : await f.deleteRoute(lt), P.value === lt && (P.value = null, M.value = null), d.success(l("sketchEdit.componentDeleted"));
    } catch (dt) {
      d.error(l("sketchEdit.componentDeleteError")), console.error(dt);
    }
  }
  async function _e(lt) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { properties: lt }) : await f.updateRoute(P.value, { properties: lt }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  async function qe(lt) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { meta: lt }) : await f.updateRoute(P.value, { name: lt.name }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  function Ve() {
    W.value && (V.value = { name: W.value.meta.name, description: W.value.meta.description, tags: [...W.value.meta.tags], created_by: W.value.meta.created_by, modified_by: W.value.meta.modified_by }, O.value = true);
  }
  function Qe() {
    Y.value.trim() && !V.value.tags.includes(Y.value.trim()) && (V.value.tags.push(Y.value.trim()), Y.value = "");
  }
  function ut(lt) {
    V.value.tags = V.value.tags.filter((et) => et !== lt);
  }
  async function gt() {
    if (W.value) try {
      await f.updateSketch(W.value.id, { name: V.value.name, description: V.value.description, tags: V.value.tags }), O.value = false, d.success(l("sketchEdit.saveSuccess"));
    } catch (lt) {
      d.error(l("sketchEdit.saveError")), console.error(lt);
    }
  }
  ji(() => {
    i.sketchId && f.setCurrentSketchId(i.sketchId);
  }), Ht(() => f.currentSketchId, (lt) => {
    lt && (P.value = null, M.value = null);
  });
  const yt = (lt) => new Date(lt).toLocaleString();
  return (lt, et) => (wt(), Xt(Hr, null, [$e(F4, { active: C.value, "onUpdate:active": et[0] || (et[0] = (dt) => C.value = dt), list: J(f).sketches.map((dt) => ({ id: dt.id, name: dt.meta.name, tags: dt.meta.tags })), placement: "right", onNew: pe, onRemove: et[1] || (et[1] = (dt) => J(f).deleteSketch(dt)), onSelect: et[2] || (et[2] = (dt) => J(f).setCurrentSketchId(dt)) }, null, 8, ["active", "list"]), $e(J(Vd), { show: F.value, "onUpdate:show": et[6] || (et[6] = (dt) => F.value = dt), preset: "dialog", title: J(l)("sketchEdit.createNewComponent") }, { action: Ne(() => [$e(J(Nr), { onClick: et[5] || (et[5] = (dt) => F.value = false) }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.cancel")), 1)]), _: 1 }), $e(J(Nr), { type: "primary", disabled: !D.value.trim(), onClick: oe }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: Ne(() => [$e(J(Wd), null, { default: Ne(() => [Pt("div", Q4, [$e(J(wn), { label: J(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: Ne(() => [$e(J(mo), { value: D.value, "onUpdate:value": et[3] || (et[3] = (dt) => D.value = dt), placeholder: J(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.type") }, { default: Ne(() => [$e(J(bg), { value: A.value, "onUpdate:value": et[4] || (et[4] = (dt) => A.value = dt), "consistent-menu-width": false, options: [{ label: J(l)("sketchEdit.draftShape"), value: "draft" }, { label: J(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), $e(J(Vd), { show: O.value, "onUpdate:show": et[11] || (et[11] = (dt) => O.value = dt), preset: "dialog", title: J(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: Ne(() => [$e(J(Nr), { onClick: et[10] || (et[10] = (dt) => O.value = false) }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.cancel")), 1)]), _: 1 }), $e(J(Nr), { type: "primary", disabled: !V.value.name.trim(), onClick: gt }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: Ne(() => [$e(J(Wd), null, { default: Ne(() => [$e(J(wn), { label: J(l)("sketchEdit.name") }, { default: Ne(() => [$e(J(mo), { value: V.value.name, "onUpdate:value": et[7] || (et[7] = (dt) => V.value.name = dt), placeholder: J(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.description") }, { default: Ne(() => [$e(J(mo), { value: V.value.description, "onUpdate:value": et[8] || (et[8] = (dt) => V.value.description = dt), type: "textarea", placeholder: J(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(l)("sketchEdit.tags") }, { default: Ne(() => [Pt("div", eM, [$e(J(mo), { value: Y.value, "onUpdate:value": et[9] || (et[9] = (dt) => Y.value = dt), placeholder: J(l)("sketchEdit.addTagPlaceholder"), onKeydown: P_($d(Qe, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), $e(J(Nr), { onClick: Qe }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.add")), 1)]), _: 1 })]), (wt(true), Xt(Hr, null, fn(V.value.tags, (dt) => (wt(), Tr(J(Mo), { key: dt, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: (Ft) => ut(dt) }, { default: Ne(() => [Pr(ur(dt), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), V.value.tags.length === 0 ? (wt(), Tr(J(qd), { key: 0, description: J(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : jr("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), Pt("div", tM, [Pt("div", rM, [Pt("div", iM, [$e(J(Xa), null, { default: Ne(() => {
    var _a3;
    return [$e(O4, { "sketch-name": (_a3 = W.value) == null ? void 0 : _a3.meta.name, "draft-count": ee.value.length, "route-count": ie.value.length, onSave: Se, onOpen: et[12] || (et[12] = (dt) => C.value = true), onCreate: et[13] || (et[13] = (dt) => F.value = true), onEditMeta: Ve }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), $e(J(Dy), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: Ne(() => [$e(J(Dy), { style: { height: "100%" }, direction: "vertical" }, { 1: Ne(() => [$e(J(Xa), { style: { height: "100%" }, title: J(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": Ne(() => [$e(J(Nr), { quaternary: "", circle: "", onClick: et[16] || (et[16] = (dt) => F.value = true) }, { icon: Ne(() => [$e(J(Ud))]), _: 1 })]), default: Ne(() => [$e(N4, { components: X.value, "selected-id": P.value, onSelect: et[14] || (et[14] = (dt, Ft) => {
    P.value = dt, M.value = Ft;
  }), onDelete: fe, onCreate: et[15] || (et[15] = (dt) => F.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: Ne(() => [$e(J(Xa), { class: "map-container", "content-style": "padding: 0;" }, { default: Ne(() => [$e(J(s1), { "map-style": J(m), center: [0, 0], zoom: J(g), height: "100%", "onMap:load": J(s) }, { default: Ne(() => [$e(J(u1), { position: "top-left" }), $e(J(d1), { position: "bottom-left" }), $e(J(l1), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), te.value ? jr("", true) : (wt(), Tr(J(qd), { key: 0, description: J(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(dC))]), _: 1 })]), extra: Ne(() => [$e(J(Nr), { size: "small", onClick: et[17] || (et[17] = (dt) => C.value = true) }, { default: Ne(() => [Pr(ur(J(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: Ne(() => [$e(J(Xa), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: Ne(() => [re.value ? (wt(), Tr(J(Za), { key: 0, depth: "3", class: "metadata" }, { default: Ne(() => [Pt("div", nM, ur(J(l)("sketchEdit.createdTimeBy", { user: re.value.meta.created_by, time: yt(re.value.meta.creation_timestamp) })), 1), Pt("div", oM, ur(J(l)("sketchEdit.modifiedTimeBy", { user: re.value.meta.modified_by, time: yt(re.value.meta.modification_timestamp) })), 1)]), _: 1 })) : jr("", true)]), default: Ne(() => [$e(G4, { component: re.value, type: M.value, onUpdateProperties: _e, onUpdateMeta: et[18] || (et[18] = (dt) => qe(dt)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), sM = Qn(aM, [["__scopeId", "data-v-b8cdd1f5"]]), lM = { class: "sketch-centre-view" }, uM = { class: "header" }, cM = { class: "title" }, dM = { class: "card-header" }, hM = { key: 0, class: "tags" }, fM = { class: "card-content" }, pM = { class: "meta-info" }, mM = { class: "meta-item" }, gM = { class: "meta-item" }, vM = { class: "meta-item" }, yM = { key: 0, class: "empty-state" }, _M = ot({ __name: "SketchCentreView", setup(r) {
  Fl((oe) => ({ v460cb2d9: J(pe).bodyColor }));
  const { t: i } = Eo(), l = Fb(), d = cp(), f = ks(), g = n0(), m = Me(() => g.sketches), s = Me({ get: () => g.currentSketchId, set: (oe) => g.setCurrentSketchId(oe) }), C = (oe) => {
    const fe = s.value === oe;
    return { borderColor: fe ? f.value.primaryColor : "", borderWidth: fe ? "2px" : "1px", padding: fe ? "0px" : "1px", zIndex: fe ? 0 : 1 };
  }, P = Re(false), M = Re(""), F = Re(""), D = Re(false), A = Re(""), O = async () => {
    await g.init();
  }, V = (oe) => new Date(oe).toLocaleDateString(), Y = (oe) => oe.routes.routes.length, W = (oe) => oe.drafts.drafts.length, ee = (oe) => {
    g.setCurrentSketchId(oe);
  }, ie = (oe) => {
    A.value = oe, D.value = true;
  }, te = async () => {
    if (!M.value.trim()) {
      d.error(i("sketchCentreView.nameRequired"));
      return;
    }
    const oe = await g.createSketch(M.value);
    await g.updateSketch(oe.id, { description: F.value }), g.setCurrentSketchId(oe.id), P.value = false, M.value = "", F.value = "", d.success(i("sketchCentreView.sketchCreated"));
  }, re = (oe) => {
    const fe = m.value.find((_e) => _e.id === oe);
    fe && l.warning({ title: i("sketchCentreView.deleteConfirmation.title"), content: i("sketchCentreView.deleteConfirmation.prompt", { name: fe.meta.name }), positiveText: i("sketchCentreView.deleteConfirmation.yes"), negativeText: i("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await g.deleteSketch(oe), d.success(i("sketchCentreView.sketchDeleted"));
    } });
  }, { width: X } = eb(), Se = Me(() => Math.floor(X.value / 360));
  ji(() => {
    O();
  });
  const pe = ks();
  return (oe, fe) => (wt(), Xt("div", lM, [Pt("div", uM, [Pt("h1", cM, ur(J(i)("sketchCentreView.title")), 1), $e(J(Nr), { type: "primary", secondary: "", circle: "", onClick: fe[0] || (fe[0] = (_e) => P.value = true) }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(Ud))]), _: 1 })]), _: 1 })]), $e(J(a5), { cols: Se.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(m.value, (_e) => (wt(), Tr(J(i5), { key: _e.id }, { default: Ne(() => [$e(J(Xa), { class: qo(["sketch-card", { selected: s.value === _e.id }]), style: In(C(_e.id)), hoverable: "", bordered: "", clickable: "", onClick: (qe) => ee(_e.id) }, { header: Ne(() => [Pt("div", dM, [$e(J(Za), { class: "sketch-name" }, { default: Ne(() => [Pr(ur(_e.meta.name), 1)]), _: 2 }, 1024), _e.meta.tags.length > 0 ? (wt(), Xt("div", hM, [(wt(true), Xt(Hr, null, fn(_e.meta.tags.slice(0, 3), (qe) => (wt(), Tr(J(Mo), { key: qe, size: "small", round: "", type: "info" }, { default: Ne(() => [Pr(ur(qe.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), _e.meta.tags.length > 3 ? (wt(), Tr(J(Mo), { key: 0, size: "small", round: "", type: "info" }, { default: Ne(() => [Pr(" +" + ur(_e.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : jr("", true)])) : jr("", true)])]), "header-extra": Ne(() => [$e(J(Sl), null, { default: Ne(() => [$e(J(Nr), { quaternary: "", circle: "", size: "small", onClick: $d((qe) => ie(_e.id), ["stop"]) }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(A3))]), _: 1 })]), _: 1 }, 8, ["onClick"]), $e(J(Nr), { quaternary: "", circle: "", size: "small", onClick: $d((qe) => re(_e.id), ["stop"]) }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(sp))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), _: 2 }, 1024)]), default: Ne(() => [Pt("div", fM, [$e(J(Za), { depth: "3", class: "description" }, { default: Ne(() => [Pr(ur(_e.meta.description || J(i)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), Pt("div", pM, [Pt("div", mM, [$e(J(Ci), { size: 16 }, { default: Ne(() => [$e(J(P3))]), _: 1 }), $e(J(Za), { depth: "3", style: { "font-size": "12px" } }, { default: Ne(() => [Pr(ur(V(_e.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), Pt("div", gM, [$e(J(Ci), { size: 16 }, { default: Ne(() => [$e(J(Hg))]), _: 1 }), $e(J(Za), { depth: "3", style: { "font-size": "12px" } }, { default: Ne(() => [Pr(ur(Y(_e)) + " " + ur(J(i)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), Pt("div", vM, [$e(J(Ci), { size: 16 }, { default: Ne(() => [$e(J(pb))]), _: 1 }), $e(J(Za), { depth: "3", style: { "font-size": "12px" } }, { default: Ne(() => [Pr(ur(W(_e)) + " " + ur(J(i)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), m.value.length === 0 ? (wt(), Xt("div", yM, [$e(J(Ci), { size: "48", depth: "3" }, { default: Ne(() => [$e(J(Q_))]), _: 1 }), $e(J(Za), { depth: "3" }, { default: Ne(() => [Pr(ur(J(i)("sketchCentreView.emptyState")), 1)]), _: 1 }), $e(J(Nr), { type: "primary", onClick: fe[1] || (fe[1] = (_e) => P.value = true) }, { icon: Ne(() => [$e(J(Ci), null, { default: Ne(() => [$e(J(Ud))]), _: 1 })]), default: Ne(() => [Pr(" " + ur(J(i)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : jr("", true), $e(J(Vd), { show: P.value, "onUpdate:show": fe[5] || (fe[5] = (_e) => P.value = _e), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: J(i)("sketchCentreView.newSketch") }, { footer: Ne(() => [$e(J(Sl), { justify: "end" }, { default: Ne(() => [$e(J(Nr), { onClick: fe[4] || (fe[4] = (_e) => P.value = false) }, { default: Ne(() => [Pr(ur(J(i)("sketchCentreView.cancel")), 1)]), _: 1 }), $e(J(Nr), { type: "primary", onClick: te }, { default: Ne(() => [Pr(ur(J(i)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: Ne(() => [$e(J(Wd), { model: { name: M.value, description: F.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: Ne(() => [$e(J(wn), { label: J(i)("sketchCentreView.sketchName"), required: "" }, { default: Ne(() => [$e(J(mo), { value: M.value, "onUpdate:value": fe[2] || (fe[2] = (_e) => M.value = _e), placeholder: J(i)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), $e(J(wn), { label: J(i)("sketchCentreView.description") }, { default: Ne(() => [$e(J(mo), { value: F.value, "onUpdate:value": fe[3] || (fe[3] = (_e) => F.value = _e), type: "textarea", placeholder: J(i)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), $e(J(Lb), { show: D.value, "onUpdate:show": fe[6] || (fe[6] = (_e) => D.value = _e), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: Ne(() => [$e(J(Bb), { title: J(i)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: Ne(() => [A.value ? (wt(), Tr(sM, { key: 0, "sketch-id": A.value }, null, 8, ["sketch-id"])) : jr("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), S1 = Qn(_M, [["__scopeId", "data-v-00cdfd4b"]]), bM = Object.freeze(Object.defineProperty({ __proto__: null, default: S1 }, Symbol.toStringTag, { value: "Module" })), o_ = {};
function xM(r) {
  let i = o_[r];
  if (i) return i;
  i = o_[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    i.push(d);
  }
  for (let l = 0; l < r.length; l++) {
    const d = r.charCodeAt(l);
    i[d] = "%" + ("0" + d.toString(16).toUpperCase()).slice(-2);
  }
  return i;
}
function lc(r, i) {
  typeof i != "string" && (i = lc.defaultChars);
  const l = xM(i);
  return r.replace(/(%[a-f0-9]{2})+/gi, function(d) {
    let f = "";
    for (let g = 0, m = d.length; g < m; g += 3) {
      const s = parseInt(d.slice(g + 1, g + 3), 16);
      if (s < 128) {
        f += l[s];
        continue;
      }
      if ((s & 224) === 192 && g + 3 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16);
        if ((C & 192) === 128) {
          const P = s << 6 & 1984 | C & 63;
          P < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(P), g += 3;
          continue;
        }
      }
      if ((s & 240) === 224 && g + 6 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), P = parseInt(d.slice(g + 7, g + 9), 16);
        if ((C & 192) === 128 && (P & 192) === 128) {
          const M = s << 12 & 61440 | C << 6 & 4032 | P & 63;
          M < 2048 || M >= 55296 && M <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(M), g += 6;
          continue;
        }
      }
      if ((s & 248) === 240 && g + 9 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), P = parseInt(d.slice(g + 7, g + 9), 16), M = parseInt(d.slice(g + 10, g + 12), 16);
        if ((C & 192) === 128 && (P & 192) === 128 && (M & 192) === 128) {
          let F = s << 18 & 1835008 | C << 12 & 258048 | P << 6 & 4032 | M & 63;
          F < 65536 || F > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (F -= 65536, f += String.fromCharCode(55296 + (F >> 10), 56320 + (F & 1023))), g += 9;
          continue;
        }
      }
      f += "\uFFFD";
    }
    return f;
  });
}
lc.defaultChars = ";/?:@&=+$,#";
lc.componentChars = "";
const a_ = {};
function wM(r) {
  let i = a_[r];
  if (i) return i;
  i = a_[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    /^[0-9a-z]$/i.test(d) ? i.push(d) : i.push("%" + ("0" + l.toString(16).toUpperCase()).slice(-2));
  }
  for (let l = 0; l < r.length; l++) i[r.charCodeAt(l)] = r[l];
  return i;
}
function oh(r, i, l) {
  typeof i != "string" && (l = i, i = oh.defaultChars), typeof l > "u" && (l = true);
  const d = wM(i);
  let f = "";
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r.charCodeAt(g);
    if (l && s === 37 && g + 2 < m && /^[0-9a-f]{2}$/i.test(r.slice(g + 1, g + 3))) {
      f += r.slice(g, g + 3), g += 2;
      continue;
    }
    if (s < 128) {
      f += d[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && g + 1 < m) {
        const C = r.charCodeAt(g + 1);
        if (C >= 56320 && C <= 57343) {
          f += encodeURIComponent(r[g] + r[g + 1]), g++;
          continue;
        }
      }
      f += "%EF%BF%BD";
      continue;
    }
    f += encodeURIComponent(r[g]);
  }
  return f;
}
oh.defaultChars = ";/?:@&=+$,-_.!~*'()#";
oh.componentChars = "-_.!~*'()";
function o0(r) {
  let i = "";
  return i += r.protocol || "", i += r.slashes ? "//" : "", i += r.auth ? r.auth + "@" : "", r.hostname && r.hostname.indexOf(":") !== -1 ? i += "[" + r.hostname + "]" : i += r.hostname || "", i += r.port ? ":" + r.port : "", i += r.pathname || "", i += r.search || "", i += r.hash || "", i;
}
function Jf() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const CM = /^([a-z0-9.+-]+:)/i, SM = /:[0-9]*$/, kM = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, PM = ["<", ">", '"', "`", " ", "\r", `
`, "	"], TM = ["{", "}", "|", "\\", "^", "`"].concat(PM), IM = ["'"].concat(TM), s_ = ["%", "/", "?", ";", "#"].concat(IM), l_ = ["/", "?", "#"], MM = 255, u_ = /^[+a-z0-9A-Z_-]{0,63}$/, EM = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, c_ = { javascript: true, "javascript:": true }, d_ = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
function a0(r, i) {
  if (r && r instanceof Jf) return r;
  const l = new Jf();
  return l.parse(r, i), l;
}
Jf.prototype.parse = function(r, i) {
  let l, d, f, g = r;
  if (g = g.trim(), !i && r.split("#").length === 1) {
    const P = kM.exec(g);
    if (P) return this.pathname = P[1], P[2] && (this.search = P[2]), this;
  }
  let m = CM.exec(g);
  if (m && (m = m[0], l = m.toLowerCase(), this.protocol = m, g = g.substr(m.length)), (i || m || g.match(/^\/\/[^@\/]+@[^@\/]+/)) && (f = g.substr(0, 2) === "//", f && !(m && c_[m]) && (g = g.substr(2), this.slashes = true)), !c_[m] && (f || m && !d_[m])) {
    let P = -1;
    for (let O = 0; O < l_.length; O++) d = g.indexOf(l_[O]), d !== -1 && (P === -1 || d < P) && (P = d);
    let M, F;
    P === -1 ? F = g.lastIndexOf("@") : F = g.lastIndexOf("@", P), F !== -1 && (M = g.slice(0, F), g = g.slice(F + 1), this.auth = M), P = -1;
    for (let O = 0; O < s_.length; O++) d = g.indexOf(s_[O]), d !== -1 && (P === -1 || d < P) && (P = d);
    P === -1 && (P = g.length), g[P - 1] === ":" && P--;
    const D = g.slice(0, P);
    g = g.slice(P), this.parseHost(D), this.hostname = this.hostname || "";
    const A = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!A) {
      const O = this.hostname.split(/\./);
      for (let V = 0, Y = O.length; V < Y; V++) {
        const W = O[V];
        if (W && !W.match(u_)) {
          let ee = "";
          for (let ie = 0, te = W.length; ie < te; ie++) W.charCodeAt(ie) > 127 ? ee += "x" : ee += W[ie];
          if (!ee.match(u_)) {
            const ie = O.slice(0, V), te = O.slice(V + 1), re = W.match(EM);
            re && (ie.push(re[1]), te.unshift(re[2])), te.length && (g = te.join(".") + g), this.hostname = ie.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > MM && (this.hostname = ""), A && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const s = g.indexOf("#");
  s !== -1 && (this.hash = g.substr(s), g = g.slice(0, s));
  const C = g.indexOf("?");
  return C !== -1 && (this.search = g.substr(C), g = g.slice(0, C)), g && (this.pathname = g), d_[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Jf.prototype.parseHost = function(r) {
  let i = SM.exec(r);
  i && (i = i[0], i !== ":" && (this.port = i.substr(1)), r = r.substr(0, r.length - i.length)), r && (this.hostname = r);
};
const RM = Object.freeze(Object.defineProperty({ __proto__: null, decode: lc, encode: oh, format: o0, parse: a0 }, Symbol.toStringTag, { value: "Module" })), k1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, P1 = /[\0-\x1F\x7F-\x9F]/, AM = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, s0 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, T1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, I1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, DM = Object.freeze(Object.defineProperty({ __proto__: null, Any: k1, Cc: P1, Cf: AM, P: s0, S: T1, Z: I1 }, Symbol.toStringTag, { value: "Module" })), zM = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((r) => r.charCodeAt(0))), FM = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((r) => r.charCodeAt(0)));
var eg;
const LM = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), BM = (eg = String.fromCodePoint) !== null && eg !== void 0 ? eg : function(r) {
  let i = "";
  return r > 65535 && (r -= 65536, i += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), i += String.fromCharCode(r), i;
};
function OM(r) {
  var i;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (i = LM.get(r)) !== null && i !== void 0 ? i : r;
}
var hn;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(hn || (hn = {}));
const $M = 32;
var xs;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(xs || (xs = {}));
function Lg(r) {
  return r >= hn.ZERO && r <= hn.NINE;
}
function jM(r) {
  return r >= hn.UPPER_A && r <= hn.UPPER_F || r >= hn.LOWER_A && r <= hn.LOWER_F;
}
function NM(r) {
  return r >= hn.UPPER_A && r <= hn.UPPER_Z || r >= hn.LOWER_A && r <= hn.LOWER_Z || Lg(r);
}
function VM(r) {
  return r === hn.EQUALS || NM(r);
}
var cn;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(cn || (cn = {}));
var bs;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(bs || (bs = {}));
class UM {
  constructor(i, l, d) {
    this.decodeTree = i, this.emitCodePoint = l, this.errors = d, this.state = cn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = bs.Strict;
  }
  startEntity(i) {
    this.decodeMode = i, this.state = cn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(i, l) {
    switch (this.state) {
      case cn.EntityStart:
        return i.charCodeAt(l) === hn.NUM ? (this.state = cn.NumericStart, this.consumed += 1, this.stateNumericStart(i, l + 1)) : (this.state = cn.NamedEntity, this.stateNamedEntity(i, l));
      case cn.NumericStart:
        return this.stateNumericStart(i, l);
      case cn.NumericDecimal:
        return this.stateNumericDecimal(i, l);
      case cn.NumericHex:
        return this.stateNumericHex(i, l);
      case cn.NamedEntity:
        return this.stateNamedEntity(i, l);
    }
  }
  stateNumericStart(i, l) {
    return l >= i.length ? -1 : (i.charCodeAt(l) | $M) === hn.LOWER_X ? (this.state = cn.NumericHex, this.consumed += 1, this.stateNumericHex(i, l + 1)) : (this.state = cn.NumericDecimal, this.stateNumericDecimal(i, l));
  }
  addToNumericResult(i, l, d, f) {
    if (l !== d) {
      const g = d - l;
      this.result = this.result * Math.pow(f, g) + parseInt(i.substr(l, g), f), this.consumed += g;
    }
  }
  stateNumericHex(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Lg(f) || jM(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 16), this.emitNumericEntity(f, 3);
    }
    return this.addToNumericResult(i, d, l, 16), -1;
  }
  stateNumericDecimal(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Lg(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 10), this.emitNumericEntity(f, 2);
    }
    return this.addToNumericResult(i, d, l, 10), -1;
  }
  emitNumericEntity(i, l) {
    var d;
    if (this.consumed <= l) return (d = this.errors) === null || d === void 0 || d.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (i === hn.SEMI) this.consumed += 1;
    else if (this.decodeMode === bs.Strict) return 0;
    return this.emitCodePoint(OM(this.result), this.consumed), this.errors && (i !== hn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(i, l) {
    const { decodeTree: d } = this;
    let f = d[this.treeIndex], g = (f & xs.VALUE_LENGTH) >> 14;
    for (; l < i.length; l++, this.excess++) {
      const m = i.charCodeAt(l);
      if (this.treeIndex = qM(d, f, this.treeIndex + Math.max(1, g), m), this.treeIndex < 0) return this.result === 0 || this.decodeMode === bs.Attribute && (g === 0 || VM(m)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (f = d[this.treeIndex], g = (f & xs.VALUE_LENGTH) >> 14, g !== 0) {
        if (m === hn.SEMI) return this.emitNamedEntityData(this.treeIndex, g, this.consumed + this.excess);
        this.decodeMode !== bs.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var i;
    const { result: l, decodeTree: d } = this, f = (d[l] & xs.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(l, f, this.consumed), (i = this.errors) === null || i === void 0 || i.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(i, l, d) {
    const { decodeTree: f } = this;
    return this.emitCodePoint(l === 1 ? f[i] & ~xs.VALUE_LENGTH : f[i + 1], d), l === 3 && this.emitCodePoint(f[i + 2], d), d;
  }
  end() {
    var i;
    switch (this.state) {
      case cn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== bs.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case cn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case cn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case cn.NumericStart:
        return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case cn.EntityStart:
        return 0;
    }
  }
}
function M1(r) {
  let i = "";
  const l = new UM(r, (d) => i += BM(d));
  return function(f, g) {
    let m = 0, s = 0;
    for (; (s = f.indexOf("&", s)) >= 0; ) {
      i += f.slice(m, s), l.startEntity(g);
      const P = l.write(f, s + 1);
      if (P < 0) {
        m = s + l.end();
        break;
      }
      m = s + P, s = P === 0 ? m + 1 : m;
    }
    const C = i + f.slice(m);
    return i = "", C;
  };
}
function qM(r, i, l, d) {
  const f = (i & xs.BRANCH_LENGTH) >> 7, g = i & xs.JUMP_TABLE;
  if (f === 0) return g !== 0 && d === g ? l : -1;
  if (g) {
    const C = d - g;
    return C < 0 || C >= f ? -1 : r[l + C] - 1;
  }
  let m = l, s = m + f - 1;
  for (; m <= s; ) {
    const C = m + s >>> 1, P = r[C];
    if (P < d) m = C + 1;
    else if (P > d) s = C - 1;
    else return r[C + f];
  }
  return -1;
}
const GM = M1(zM);
M1(FM);
function E1(r, i = bs.Legacy) {
  return GM(r, i);
}
function WM(r) {
  return Object.prototype.toString.call(r);
}
function l0(r) {
  return WM(r) === "[object String]";
}
const ZM = Object.prototype.hasOwnProperty;
function HM(r, i) {
  return ZM.call(r, i);
}
function gp(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    if (l) {
      if (typeof l != "object") throw new TypeError(l + "must be object");
      Object.keys(l).forEach(function(d) {
        r[d] = l[d];
      });
    }
  }), r;
}
function R1(r, i, l) {
  return [].concat(r.slice(0, i), l, r.slice(i + 1));
}
function u0(r) {
  return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111);
}
function Qf(r) {
  if (r > 65535) {
    r -= 65536;
    const i = 55296 + (r >> 10), l = 56320 + (r & 1023);
    return String.fromCharCode(i, l);
  }
  return String.fromCharCode(r);
}
const A1 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, XM = /&([a-z#][a-z0-9]{1,31});/gi, YM = new RegExp(A1.source + "|" + XM.source, "gi"), KM = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function JM(r, i) {
  if (i.charCodeAt(0) === 35 && KM.test(i)) {
    const d = i[1].toLowerCase() === "x" ? parseInt(i.slice(2), 16) : parseInt(i.slice(1), 10);
    return u0(d) ? Qf(d) : r;
  }
  const l = E1(r);
  return l !== r ? l : r;
}
function QM(r) {
  return r.indexOf("\\") < 0 ? r : r.replace(A1, "$1");
}
function uc(r) {
  return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(YM, function(i, l, d) {
    return l || JM(i, d);
  });
}
const eE = /[&<>"]/, tE = /[&<>"]/g, rE = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
function iE(r) {
  return rE[r];
}
function Ts(r) {
  return eE.test(r) ? r.replace(tE, iE) : r;
}
const nE = /[.?*+^$[\]\\(){}|-]/g;
function oE(r) {
  return r.replace(nE, "\\$&");
}
function _i(r) {
  switch (r) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Xd(r) {
  if (r >= 8192 && r <= 8202) return true;
  switch (r) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function Yd(r) {
  return s0.test(r) || T1.test(r);
}
function Kd(r) {
  switch (r) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function vp(r) {
  return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(//g, "\xDF")), r.toLowerCase().toUpperCase();
}
const aE = { mdurl: RM, ucmicro: DM }, sE = Object.freeze(Object.defineProperty({ __proto__: null, arrayReplaceAt: R1, assign: gp, escapeHtml: Ts, escapeRE: oE, fromCodePoint: Qf, has: HM, isMdAsciiPunct: Kd, isPunctChar: Yd, isSpace: _i, isString: l0, isValidEntityCode: u0, isWhiteSpace: Xd, lib: aE, normalizeReference: vp, unescapeAll: uc, unescapeMd: QM }, Symbol.toStringTag, { value: "Module" }));
function lE(r, i, l) {
  let d, f, g, m;
  const s = r.posMax, C = r.pos;
  for (r.pos = i + 1, d = 1; r.pos < s; ) {
    if (g = r.src.charCodeAt(r.pos), g === 93 && (d--, d === 0)) {
      f = true;
      break;
    }
    if (m = r.pos, r.md.inline.skipToken(r), g === 91) {
      if (m === r.pos - 1) d++;
      else if (l) return r.pos = C, -1;
    }
  }
  let P = -1;
  return f && (P = r.pos), r.pos = C, P;
}
function uE(r, i, l) {
  let d, f = i;
  const g = { ok: false, pos: 0, str: "" };
  if (r.charCodeAt(f) === 60) {
    for (f++; f < l; ) {
      if (d = r.charCodeAt(f), d === 10 || d === 60) return g;
      if (d === 62) return g.pos = f + 1, g.str = uc(r.slice(i + 1, f)), g.ok = true, g;
      if (d === 92 && f + 1 < l) {
        f += 2;
        continue;
      }
      f++;
    }
    return g;
  }
  let m = 0;
  for (; f < l && (d = r.charCodeAt(f), !(d === 32 || d < 32 || d === 127)); ) {
    if (d === 92 && f + 1 < l) {
      if (r.charCodeAt(f + 1) === 32) break;
      f += 2;
      continue;
    }
    if (d === 40 && (m++, m > 32)) return g;
    if (d === 41) {
      if (m === 0) break;
      m--;
    }
    f++;
  }
  return i === f || m !== 0 || (g.str = uc(r.slice(i, f)), g.pos = f, g.ok = true), g;
}
function cE(r, i, l, d) {
  let f, g = i;
  const m = { ok: false, can_continue: false, pos: 0, str: "", marker: 0 };
  if (d) m.str = d.str, m.marker = d.marker;
  else {
    if (g >= l) return m;
    let s = r.charCodeAt(g);
    if (s !== 34 && s !== 39 && s !== 40) return m;
    i++, g++, s === 40 && (s = 41), m.marker = s;
  }
  for (; g < l; ) {
    if (f = r.charCodeAt(g), f === m.marker) return m.pos = g + 1, m.str += uc(r.slice(i, g)), m.ok = true, m;
    if (f === 40 && m.marker === 41) return m;
    f === 92 && g + 1 < l && g++, g++;
  }
  return m.can_continue = true, m.str += uc(r.slice(i, g)), m;
}
const dE = Object.freeze(Object.defineProperty({ __proto__: null, parseLinkDestination: uE, parseLinkLabel: lE, parseLinkTitle: cE }, Symbol.toStringTag, { value: "Module" })), _a2 = {};
_a2.code_inline = function(r, i, l, d, f) {
  const g = r[i];
  return "<code" + f.renderAttrs(g) + ">" + Ts(g.content) + "</code>";
};
_a2.code_block = function(r, i, l, d, f) {
  const g = r[i];
  return "<pre" + f.renderAttrs(g) + "><code>" + Ts(r[i].content) + `</code></pre>
`;
};
_a2.fence = function(r, i, l, d, f) {
  const g = r[i], m = g.info ? uc(g.info).trim() : "";
  let s = "", C = "";
  if (m) {
    const M = m.split(/(\s+)/g);
    s = M[0], C = M.slice(2).join("");
  }
  let P;
  if (l.highlight ? P = l.highlight(g.content, s, C) || Ts(g.content) : P = Ts(g.content), P.indexOf("<pre") === 0) return P + `
`;
  if (m) {
    const M = g.attrIndex("class"), F = g.attrs ? g.attrs.slice() : [];
    M < 0 ? F.push(["class", l.langPrefix + s]) : (F[M] = F[M].slice(), F[M][1] += " " + l.langPrefix + s);
    const D = { attrs: F };
    return `<pre><code${f.renderAttrs(D)}>${P}</code></pre>
`;
  }
  return `<pre><code${f.renderAttrs(g)}>${P}</code></pre>
`;
};
_a2.image = function(r, i, l, d, f) {
  const g = r[i];
  return g.attrs[g.attrIndex("alt")][1] = f.renderInlineAsText(g.children, l, d), f.renderToken(r, i, l);
};
_a2.hardbreak = function(r, i, l) {
  return l.xhtmlOut ? `<br />
` : `<br>
`;
};
_a2.softbreak = function(r, i, l) {
  return l.breaks ? l.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
_a2.text = function(r, i) {
  return Ts(r[i].content);
};
_a2.html_block = function(r, i) {
  return r[i].content;
};
_a2.html_inline = function(r, i) {
  return r[i].content;
};
function hc() {
  this.rules = gp({}, _a2);
}
hc.prototype.renderAttrs = function(i) {
  let l, d, f;
  if (!i.attrs) return "";
  for (f = "", l = 0, d = i.attrs.length; l < d; l++) f += " " + Ts(i.attrs[l][0]) + '="' + Ts(i.attrs[l][1]) + '"';
  return f;
};
hc.prototype.renderToken = function(i, l, d) {
  const f = i[l];
  let g = "";
  if (f.hidden) return "";
  f.block && f.nesting !== -1 && l && i[l - 1].hidden && (g += `
`), g += (f.nesting === -1 ? "</" : "<") + f.tag, g += this.renderAttrs(f), f.nesting === 0 && d.xhtmlOut && (g += " /");
  let m = false;
  if (f.block && (m = true, f.nesting === 1 && l + 1 < i.length)) {
    const s = i[l + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === f.tag) && (m = false);
  }
  return g += m ? `>
` : ">", g;
};
hc.prototype.renderInline = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i);
  }
  return d;
};
hc.prototype.renderInlineAsText = function(r, i, l) {
  let d = "";
  for (let f = 0, g = r.length; f < g; f++) switch (r[f].type) {
    case "text":
      d += r[f].content;
      break;
    case "image":
      d += this.renderInlineAsText(r[f].children, i, l);
      break;
    case "html_inline":
    case "html_block":
      d += r[f].content;
      break;
    case "softbreak":
    case "hardbreak":
      d += `
`;
      break;
  }
  return d;
};
hc.prototype.render = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    s === "inline" ? d += this.renderInline(r[g].children, i, l) : typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i, l);
  }
  return d;
};
function Jn() {
  this.__rules__ = [], this.__cache__ = null;
}
Jn.prototype.__find__ = function(r) {
  for (let i = 0; i < this.__rules__.length; i++) if (this.__rules__[i].name === r) return i;
  return -1;
};
Jn.prototype.__compile__ = function() {
  const r = this, i = [""];
  r.__rules__.forEach(function(l) {
    l.enabled && l.alt.forEach(function(d) {
      i.indexOf(d) < 0 && i.push(d);
    });
  }), r.__cache__ = {}, i.forEach(function(l) {
    r.__cache__[l] = [], r.__rules__.forEach(function(d) {
      d.enabled && (l && d.alt.indexOf(l) < 0 || r.__cache__[l].push(d.fn));
    });
  });
};
Jn.prototype.at = function(r, i, l) {
  const d = this.__find__(r), f = l || {};
  if (d === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__[d].fn = i, this.__rules__[d].alt = f.alt || [], this.__cache__ = null;
};
Jn.prototype.before = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Jn.prototype.after = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f + 1, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Jn.prototype.push = function(r, i, l) {
  const d = l || {};
  this.__rules__.push({ name: r, enabled: true, fn: i, alt: d.alt || [] }), this.__cache__ = null;
};
Jn.prototype.enable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = true, l.push(d);
  }, this), this.__cache__ = null, l;
};
Jn.prototype.enableOnly = function(r, i) {
  Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(l) {
    l.enabled = false;
  }), this.enable(r, i);
};
Jn.prototype.disable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = false, l.push(d);
  }, this), this.__cache__ = null, l;
};
Jn.prototype.getRules = function(r) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[r] || [];
};
function Ko(r, i, l) {
  this.type = r, this.tag = i, this.attrs = null, this.map = null, this.nesting = l, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Ko.prototype.attrIndex = function(i) {
  if (!this.attrs) return -1;
  const l = this.attrs;
  for (let d = 0, f = l.length; d < f; d++) if (l[d][0] === i) return d;
  return -1;
};
Ko.prototype.attrPush = function(i) {
  this.attrs ? this.attrs.push(i) : this.attrs = [i];
};
Ko.prototype.attrSet = function(i, l) {
  const d = this.attrIndex(i), f = [i, l];
  d < 0 ? this.attrPush(f) : this.attrs[d] = f;
};
Ko.prototype.attrGet = function(i) {
  const l = this.attrIndex(i);
  let d = null;
  return l >= 0 && (d = this.attrs[l][1]), d;
};
Ko.prototype.attrJoin = function(i, l) {
  const d = this.attrIndex(i);
  d < 0 ? this.attrPush([i, l]) : this.attrs[d][1] = this.attrs[d][1] + " " + l;
};
function D1(r, i, l) {
  this.src = r, this.env = l, this.tokens = [], this.inlineMode = false, this.md = i;
}
D1.prototype.Token = Ko;
const hE = /\r\n?|\n/g, fE = /\0/g;
function pE(r) {
  let i;
  i = r.src.replace(hE, `
`), i = i.replace(fE, "\uFFFD"), r.src = i;
}
function mE(r) {
  let i;
  r.inlineMode ? (i = new r.Token("inline", "", 0), i.content = r.src, i.map = [0, 1], i.children = [], r.tokens.push(i)) : r.md.block.parse(r.src, r.md, r.env, r.tokens);
}
function gE(r) {
  const i = r.tokens;
  for (let l = 0, d = i.length; l < d; l++) {
    const f = i[l];
    f.type === "inline" && r.md.inline.parse(f.content, r.md, r.env, f.children);
  }
}
function vE(r) {
  return /^<a[>\s]/i.test(r);
}
function yE(r) {
  return /^<\/a\s*>/i.test(r);
}
function _E(r) {
  const i = r.tokens;
  if (r.md.options.linkify) for (let l = 0, d = i.length; l < d; l++) {
    if (i[l].type !== "inline" || !r.md.linkify.pretest(i[l].content)) continue;
    let f = i[l].children, g = 0;
    for (let m = f.length - 1; m >= 0; m--) {
      const s = f[m];
      if (s.type === "link_close") {
        for (m--; f[m].level !== s.level && f[m].type !== "link_open"; ) m--;
        continue;
      }
      if (s.type === "html_inline" && (vE(s.content) && g > 0 && g--, yE(s.content) && g++), !(g > 0) && s.type === "text" && r.md.linkify.test(s.content)) {
        const C = s.content;
        let P = r.md.linkify.match(C);
        const M = [];
        let F = s.level, D = 0;
        P.length > 0 && P[0].index === 0 && m > 0 && f[m - 1].type === "text_special" && (P = P.slice(1));
        for (let A = 0; A < P.length; A++) {
          const O = P[A].url, V = r.md.normalizeLink(O);
          if (!r.md.validateLink(V)) continue;
          let Y = P[A].text;
          P[A].schema ? P[A].schema === "mailto:" && !/^mailto:/i.test(Y) ? Y = r.md.normalizeLinkText("mailto:" + Y).replace(/^mailto:/, "") : Y = r.md.normalizeLinkText(Y) : Y = r.md.normalizeLinkText("http://" + Y).replace(/^http:\/\//, "");
          const W = P[A].index;
          if (W > D) {
            const re = new r.Token("text", "", 0);
            re.content = C.slice(D, W), re.level = F, M.push(re);
          }
          const ee = new r.Token("link_open", "a", 1);
          ee.attrs = [["href", V]], ee.level = F++, ee.markup = "linkify", ee.info = "auto", M.push(ee);
          const ie = new r.Token("text", "", 0);
          ie.content = Y, ie.level = F, M.push(ie);
          const te = new r.Token("link_close", "a", -1);
          te.level = --F, te.markup = "linkify", te.info = "auto", M.push(te), D = P[A].lastIndex;
        }
        if (D < C.length) {
          const A = new r.Token("text", "", 0);
          A.content = C.slice(D), A.level = F, M.push(A);
        }
        i[l].children = f = R1(f, m, M);
      }
    }
  }
}
const z1 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, bE = /\((c|tm|r)\)/i, xE = /\((c|tm|r)\)/ig, wE = { c: "\xA9", r: "\xAE", tm: "\u2122" };
function CE(r, i) {
  return wE[i.toLowerCase()];
}
function SE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && (d.content = d.content.replace(xE, CE)), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function kE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && z1.test(d.content) && (d.content = d.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function PE(r) {
  let i;
  if (r.md.options.typographer) for (i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type === "inline" && (bE.test(r.tokens[i].content) && SE(r.tokens[i].children), z1.test(r.tokens[i].content) && kE(r.tokens[i].children));
}
const TE = /['"]/, h_ = /['"]/g, f_ = "\u2019";
function Ff(r, i, l) {
  return r.slice(0, i) + l + r.slice(i + 1);
}
function IE(r, i) {
  let l;
  const d = [];
  for (let f = 0; f < r.length; f++) {
    const g = r[f], m = r[f].level;
    for (l = d.length - 1; l >= 0 && !(d[l].level <= m); l--) ;
    if (d.length = l + 1, g.type !== "text") continue;
    let s = g.content, C = 0, P = s.length;
    e: for (; C < P; ) {
      h_.lastIndex = C;
      const M = h_.exec(s);
      if (!M) break;
      let F = true, D = true;
      C = M.index + 1;
      const A = M[0] === "'";
      let O = 32;
      if (M.index - 1 >= 0) O = s.charCodeAt(M.index - 1);
      else for (l = f - 1; l >= 0 && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l--) if (r[l].content) {
        O = r[l].content.charCodeAt(r[l].content.length - 1);
        break;
      }
      let V = 32;
      if (C < P) V = s.charCodeAt(C);
      else for (l = f + 1; l < r.length && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l++) if (r[l].content) {
        V = r[l].content.charCodeAt(0);
        break;
      }
      const Y = Kd(O) || Yd(String.fromCharCode(O)), W = Kd(V) || Yd(String.fromCharCode(V)), ee = Xd(O), ie = Xd(V);
      if (ie ? F = false : W && (ee || Y || (F = false)), ee ? D = false : Y && (ie || W || (D = false)), V === 34 && M[0] === '"' && O >= 48 && O <= 57 && (D = F = false), F && D && (F = Y, D = W), !F && !D) {
        A && (g.content = Ff(g.content, M.index, f_));
        continue;
      }
      if (D) for (l = d.length - 1; l >= 0; l--) {
        let te = d[l];
        if (d[l].level < m) break;
        if (te.single === A && d[l].level === m) {
          te = d[l];
          let re, X;
          A ? (re = i.md.options.quotes[2], X = i.md.options.quotes[3]) : (re = i.md.options.quotes[0], X = i.md.options.quotes[1]), g.content = Ff(g.content, M.index, X), r[te.token].content = Ff(r[te.token].content, te.pos, re), C += X.length - 1, te.token === f && (C += re.length - 1), s = g.content, P = s.length, d.length = l;
          continue e;
        }
      }
      F ? d.push({ token: f, pos: M.index, single: A, level: m }) : D && A && (g.content = Ff(g.content, M.index, f_));
    }
  }
}
function ME(r) {
  if (r.md.options.typographer) for (let i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type !== "inline" || !TE.test(r.tokens[i].content) || IE(r.tokens[i].children, r);
}
function EE(r) {
  let i, l;
  const d = r.tokens, f = d.length;
  for (let g = 0; g < f; g++) {
    if (d[g].type !== "inline") continue;
    const m = d[g].children, s = m.length;
    for (i = 0; i < s; i++) m[i].type === "text_special" && (m[i].type = "text");
    for (i = l = 0; i < s; i++) m[i].type === "text" && i + 1 < s && m[i + 1].type === "text" ? m[i + 1].content = m[i].content + m[i + 1].content : (i !== l && (m[l] = m[i]), l++);
    i !== l && (m.length = l);
  }
}
const tg = [["normalize", pE], ["block", mE], ["inline", gE], ["linkify", _E], ["replacements", PE], ["smartquotes", ME], ["text_join", EE]];
function c0() {
  this.ruler = new Jn();
  for (let r = 0; r < tg.length; r++) this.ruler.push(tg[r][0], tg[r][1]);
}
c0.prototype.process = function(r) {
  const i = this.ruler.getRules("");
  for (let l = 0, d = i.length; l < d; l++) i[l](r);
};
c0.prototype.State = D1;
function ba(r, i, l, d) {
  this.src = r, this.md = i, this.env = l, this.tokens = d, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const f = this.src;
  for (let g = 0, m = 0, s = 0, C = 0, P = f.length, M = false; m < P; m++) {
    const F = f.charCodeAt(m);
    if (!M) if (_i(F)) {
      s++, F === 9 ? C += 4 - C % 4 : C++;
      continue;
    } else M = true;
    (F === 10 || m === P - 1) && (F !== 10 && m++, this.bMarks.push(g), this.eMarks.push(m), this.tShift.push(s), this.sCount.push(C), this.bsCount.push(0), M = false, s = 0, C = 0, g = m + 1);
  }
  this.bMarks.push(f.length), this.eMarks.push(f.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ba.prototype.push = function(r, i, l) {
  const d = new Ko(r, i, l);
  return d.block = true, l < 0 && this.level--, d.level = this.level, l > 0 && this.level++, this.tokens.push(d), d;
};
ba.prototype.isEmpty = function(i) {
  return this.bMarks[i] + this.tShift[i] >= this.eMarks[i];
};
ba.prototype.skipEmptyLines = function(i) {
  for (let l = this.lineMax; i < l && !(this.bMarks[i] + this.tShift[i] < this.eMarks[i]); i++) ;
  return i;
};
ba.prototype.skipSpaces = function(i) {
  for (let l = this.src.length; i < l; i++) {
    const d = this.src.charCodeAt(i);
    if (!_i(d)) break;
  }
  return i;
};
ba.prototype.skipSpacesBack = function(i, l) {
  if (i <= l) return i;
  for (; i > l; ) if (!_i(this.src.charCodeAt(--i))) return i + 1;
  return i;
};
ba.prototype.skipChars = function(i, l) {
  for (let d = this.src.length; i < d && this.src.charCodeAt(i) === l; i++) ;
  return i;
};
ba.prototype.skipCharsBack = function(i, l, d) {
  if (i <= d) return i;
  for (; i > d; ) if (l !== this.src.charCodeAt(--i)) return i + 1;
  return i;
};
ba.prototype.getLines = function(i, l, d, f) {
  if (i >= l) return "";
  const g = new Array(l - i);
  for (let m = 0, s = i; s < l; s++, m++) {
    let C = 0;
    const P = this.bMarks[s];
    let M = P, F;
    for (s + 1 < l || f ? F = this.eMarks[s] + 1 : F = this.eMarks[s]; M < F && C < d; ) {
      const D = this.src.charCodeAt(M);
      if (_i(D)) D === 9 ? C += 4 - (C + this.bsCount[s]) % 4 : C++;
      else if (M - P < this.tShift[s]) C++;
      else break;
      M++;
    }
    C > d ? g[m] = new Array(C - d + 1).join(" ") + this.src.slice(M, F) : g[m] = this.src.slice(M, F);
  }
  return g.join("");
};
ba.prototype.Token = Ko;
const RE = 65536;
function rg(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  return r.src.slice(l, d);
}
function p_(r) {
  const i = [], l = r.length;
  let d = 0, f = r.charCodeAt(d), g = false, m = 0, s = "";
  for (; d < l; ) f === 124 && (g ? (s += r.substring(m, d - 1), m = d) : (i.push(s + r.substring(m, d)), s = "", m = d + 1)), g = f === 92, d++, f = r.charCodeAt(d);
  return i.push(s + r.substring(m)), i;
}
function AE(r, i, l, d) {
  if (i + 2 > l) return false;
  let f = i + 1;
  if (r.sCount[f] < r.blkIndent || r.sCount[f] - r.blkIndent >= 4) return false;
  let g = r.bMarks[f] + r.tShift[f];
  if (g >= r.eMarks[f]) return false;
  const m = r.src.charCodeAt(g++);
  if (m !== 124 && m !== 45 && m !== 58 || g >= r.eMarks[f]) return false;
  const s = r.src.charCodeAt(g++);
  if (s !== 124 && s !== 45 && s !== 58 && !_i(s) || m === 45 && _i(s)) return false;
  for (; g < r.eMarks[f]; ) {
    const te = r.src.charCodeAt(g);
    if (te !== 124 && te !== 45 && te !== 58 && !_i(te)) return false;
    g++;
  }
  let C = rg(r, i + 1), P = C.split("|");
  const M = [];
  for (let te = 0; te < P.length; te++) {
    const re = P[te].trim();
    if (!re) {
      if (te === 0 || te === P.length - 1) continue;
      return false;
    }
    if (!/^:?-+:?$/.test(re)) return false;
    re.charCodeAt(re.length - 1) === 58 ? M.push(re.charCodeAt(0) === 58 ? "center" : "right") : re.charCodeAt(0) === 58 ? M.push("left") : M.push("");
  }
  if (C = rg(r, i).trim(), C.indexOf("|") === -1 || r.sCount[i] - r.blkIndent >= 4) return false;
  P = p_(C), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop();
  const F = P.length;
  if (F === 0 || F !== M.length) return false;
  if (d) return true;
  const D = r.parentType;
  r.parentType = "table";
  const A = r.md.block.ruler.getRules("blockquote"), O = r.push("table_open", "table", 1), V = [i, 0];
  O.map = V;
  const Y = r.push("thead_open", "thead", 1);
  Y.map = [i, i + 1];
  const W = r.push("tr_open", "tr", 1);
  W.map = [i, i + 1];
  for (let te = 0; te < P.length; te++) {
    const re = r.push("th_open", "th", 1);
    M[te] && (re.attrs = [["style", "text-align:" + M[te]]]);
    const X = r.push("inline", "", 0);
    X.content = P[te].trim(), X.children = [], r.push("th_close", "th", -1);
  }
  r.push("tr_close", "tr", -1), r.push("thead_close", "thead", -1);
  let ee, ie = 0;
  for (f = i + 2; f < l && !(r.sCount[f] < r.blkIndent); f++) {
    let te = false;
    for (let X = 0, Se = A.length; X < Se; X++) if (A[X](r, f, l, true)) {
      te = true;
      break;
    }
    if (te || (C = rg(r, f).trim(), !C) || r.sCount[f] - r.blkIndent >= 4 || (P = p_(C), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop(), ie += F - P.length, ie > RE)) break;
    if (f === i + 2) {
      const X = r.push("tbody_open", "tbody", 1);
      X.map = ee = [i + 2, 0];
    }
    const re = r.push("tr_open", "tr", 1);
    re.map = [f, f + 1];
    for (let X = 0; X < F; X++) {
      const Se = r.push("td_open", "td", 1);
      M[X] && (Se.attrs = [["style", "text-align:" + M[X]]]);
      const pe = r.push("inline", "", 0);
      pe.content = P[X] ? P[X].trim() : "", pe.children = [], r.push("td_close", "td", -1);
    }
    r.push("tr_close", "tr", -1);
  }
  return ee && (r.push("tbody_close", "tbody", -1), ee[1] = f), r.push("table_close", "table", -1), V[1] = f, r.parentType = D, r.line = f, true;
}
function DE(r, i, l) {
  if (r.sCount[i] - r.blkIndent < 4) return false;
  let d = i + 1, f = d;
  for (; d < l; ) {
    if (r.isEmpty(d)) {
      d++;
      continue;
    }
    if (r.sCount[d] - r.blkIndent >= 4) {
      d++, f = d;
      continue;
    }
    break;
  }
  r.line = f;
  const g = r.push("code_block", "code", 0);
  return g.content = r.getLines(i, f, 4 + r.blkIndent, false) + `
`, g.map = [i, r.line], true;
}
function zE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || f + 3 > g) return false;
  const m = r.src.charCodeAt(f);
  if (m !== 126 && m !== 96) return false;
  let s = f;
  f = r.skipChars(f, m);
  let C = f - s;
  if (C < 3) return false;
  const P = r.src.slice(s, f), M = r.src.slice(f, g);
  if (m === 96 && M.indexOf(String.fromCharCode(m)) >= 0) return false;
  if (d) return true;
  let F = i, D = false;
  for (; F++, !(F >= l || (f = s = r.bMarks[F] + r.tShift[F], g = r.eMarks[F], f < g && r.sCount[F] < r.blkIndent)); ) if (r.src.charCodeAt(f) === m && !(r.sCount[F] - r.blkIndent >= 4) && (f = r.skipChars(f, m), !(f - s < C) && (f = r.skipSpaces(f), !(f < g)))) {
    D = true;
    break;
  }
  C = r.sCount[i], r.line = F + (D ? 1 : 0);
  const A = r.push("fence", "code", 0);
  return A.info = M, A.content = r.getLines(i + 1, F, C, true), A.markup = P, A.map = [i, r.line], true;
}
function FE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  const m = r.lineMax;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 62) return false;
  if (d) return true;
  const s = [], C = [], P = [], M = [], F = r.md.block.ruler.getRules("blockquote"), D = r.parentType;
  r.parentType = "blockquote";
  let A = false, O;
  for (O = i; O < l; O++) {
    const ie = r.sCount[O] < r.blkIndent;
    if (f = r.bMarks[O] + r.tShift[O], g = r.eMarks[O], f >= g) break;
    if (r.src.charCodeAt(f++) === 62 && !ie) {
      let re = r.sCount[O] + 1, X, Se;
      r.src.charCodeAt(f) === 32 ? (f++, re++, Se = false, X = true) : r.src.charCodeAt(f) === 9 ? (X = true, (r.bsCount[O] + re) % 4 === 3 ? (f++, re++, Se = false) : Se = true) : X = false;
      let pe = re;
      for (s.push(r.bMarks[O]), r.bMarks[O] = f; f < g; ) {
        const oe = r.src.charCodeAt(f);
        if (_i(oe)) oe === 9 ? pe += 4 - (pe + r.bsCount[O] + (Se ? 1 : 0)) % 4 : pe++;
        else break;
        f++;
      }
      A = f >= g, C.push(r.bsCount[O]), r.bsCount[O] = r.sCount[O] + 1 + (X ? 1 : 0), P.push(r.sCount[O]), r.sCount[O] = pe - re, M.push(r.tShift[O]), r.tShift[O] = f - r.bMarks[O];
      continue;
    }
    if (A) break;
    let te = false;
    for (let re = 0, X = F.length; re < X; re++) if (F[re](r, O, l, true)) {
      te = true;
      break;
    }
    if (te) {
      r.lineMax = O, r.blkIndent !== 0 && (s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), P.push(r.sCount[O]), r.sCount[O] -= r.blkIndent);
      break;
    }
    s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), P.push(r.sCount[O]), r.sCount[O] = -1;
  }
  const V = r.blkIndent;
  r.blkIndent = 0;
  const Y = r.push("blockquote_open", "blockquote", 1);
  Y.markup = ">";
  const W = [i, 0];
  Y.map = W, r.md.block.tokenize(r, i, O);
  const ee = r.push("blockquote_close", "blockquote", -1);
  ee.markup = ">", r.lineMax = m, r.parentType = D, W[1] = r.line;
  for (let ie = 0; ie < M.length; ie++) r.bMarks[ie + i] = s[ie], r.tShift[ie + i] = M[ie], r.sCount[ie + i] = P[ie], r.bsCount[ie + i] = C[ie];
  return r.blkIndent = V, true;
}
function LE(r, i, l, d) {
  const f = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let g = r.bMarks[i] + r.tShift[i];
  const m = r.src.charCodeAt(g++);
  if (m !== 42 && m !== 45 && m !== 95) return false;
  let s = 1;
  for (; g < f; ) {
    const P = r.src.charCodeAt(g++);
    if (P !== m && !_i(P)) return false;
    P === m && s++;
  }
  if (s < 3) return false;
  if (d) return true;
  r.line = i + 1;
  const C = r.push("hr", "hr", 0);
  return C.map = [i, r.line], C.markup = Array(s + 1).join(String.fromCharCode(m)), true;
}
function m_(r, i) {
  const l = r.eMarks[i];
  let d = r.bMarks[i] + r.tShift[i];
  const f = r.src.charCodeAt(d++);
  if (f !== 42 && f !== 45 && f !== 43) return -1;
  if (d < l) {
    const g = r.src.charCodeAt(d);
    if (!_i(g)) return -1;
  }
  return d;
}
function g_(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  let f = l;
  if (f + 1 >= d) return -1;
  let g = r.src.charCodeAt(f++);
  if (g < 48 || g > 57) return -1;
  for (; ; ) {
    if (f >= d) return -1;
    if (g = r.src.charCodeAt(f++), g >= 48 && g <= 57) {
      if (f - l >= 10) return -1;
      continue;
    }
    if (g === 41 || g === 46) break;
    return -1;
  }
  return f < d && (g = r.src.charCodeAt(f), !_i(g)) ? -1 : f;
}
function BE(r, i) {
  const l = r.level + 2;
  for (let d = i + 2, f = r.tokens.length - 2; d < f; d++) r.tokens[d].level === l && r.tokens[d].type === "paragraph_open" && (r.tokens[d + 2].hidden = true, r.tokens[d].hidden = true, d += 2);
}
function OE(r, i, l, d) {
  let f, g, m, s, C = i, P = true;
  if (r.sCount[C] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[C] - r.listIndent >= 4 && r.sCount[C] < r.blkIndent) return false;
  let M = false;
  d && r.parentType === "paragraph" && r.sCount[C] >= r.blkIndent && (M = true);
  let F, D, A;
  if ((A = g_(r, C)) >= 0) {
    if (F = true, m = r.bMarks[C] + r.tShift[C], D = Number(r.src.slice(m, A - 1)), M && D !== 1) return false;
  } else if ((A = m_(r, C)) >= 0) F = false;
  else return false;
  if (M && r.skipSpaces(A) >= r.eMarks[C]) return false;
  if (d) return true;
  const O = r.src.charCodeAt(A - 1), V = r.tokens.length;
  F ? (s = r.push("ordered_list_open", "ol", 1), D !== 1 && (s.attrs = [["start", D]])) : s = r.push("bullet_list_open", "ul", 1);
  const Y = [C, 0];
  s.map = Y, s.markup = String.fromCharCode(O);
  let W = false;
  const ee = r.md.block.ruler.getRules("list"), ie = r.parentType;
  for (r.parentType = "list"; C < l; ) {
    g = A, f = r.eMarks[C];
    const te = r.sCount[C] + A - (r.bMarks[C] + r.tShift[C]);
    let re = te;
    for (; g < f; ) {
      const ut = r.src.charCodeAt(g);
      if (ut === 9) re += 4 - (re + r.bsCount[C]) % 4;
      else if (ut === 32) re++;
      else break;
      g++;
    }
    const X = g;
    let Se;
    X >= f ? Se = 1 : Se = re - te, Se > 4 && (Se = 1);
    const pe = te + Se;
    s = r.push("list_item_open", "li", 1), s.markup = String.fromCharCode(O);
    const oe = [C, 0];
    s.map = oe, F && (s.info = r.src.slice(m, A - 1));
    const fe = r.tight, _e = r.tShift[C], qe = r.sCount[C], Ve = r.listIndent;
    if (r.listIndent = r.blkIndent, r.blkIndent = pe, r.tight = true, r.tShift[C] = X - r.bMarks[C], r.sCount[C] = re, X >= f && r.isEmpty(C + 1) ? r.line = Math.min(r.line + 2, l) : r.md.block.tokenize(r, C, l, true), (!r.tight || W) && (P = false), W = r.line - C > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = Ve, r.tShift[C] = _e, r.sCount[C] = qe, r.tight = fe, s = r.push("list_item_close", "li", -1), s.markup = String.fromCharCode(O), C = r.line, oe[1] = C, C >= l || r.sCount[C] < r.blkIndent || r.sCount[C] - r.blkIndent >= 4) break;
    let Qe = false;
    for (let ut = 0, gt = ee.length; ut < gt; ut++) if (ee[ut](r, C, l, true)) {
      Qe = true;
      break;
    }
    if (Qe) break;
    if (F) {
      if (A = g_(r, C), A < 0) break;
      m = r.bMarks[C] + r.tShift[C];
    } else if (A = m_(r, C), A < 0) break;
    if (O !== r.src.charCodeAt(A - 1)) break;
  }
  return F ? s = r.push("ordered_list_close", "ol", -1) : s = r.push("bullet_list_close", "ul", -1), s.markup = String.fromCharCode(O), Y[1] = C, r.line = C, r.parentType = ie, P && BE(r, V), true;
}
function $E(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i], m = i + 1;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 91) return false;
  function s(ee) {
    const ie = r.lineMax;
    if (ee >= ie || r.isEmpty(ee)) return null;
    let te = false;
    if (r.sCount[ee] - r.blkIndent > 3 && (te = true), r.sCount[ee] < 0 && (te = true), !te) {
      const Se = r.md.block.ruler.getRules("reference"), pe = r.parentType;
      r.parentType = "reference";
      let oe = false;
      for (let fe = 0, _e = Se.length; fe < _e; fe++) if (Se[fe](r, ee, ie, true)) {
        oe = true;
        break;
      }
      if (r.parentType = pe, oe) return null;
    }
    const re = r.bMarks[ee] + r.tShift[ee], X = r.eMarks[ee];
    return r.src.slice(re, X + 1);
  }
  let C = r.src.slice(f, g + 1);
  g = C.length;
  let P = -1;
  for (f = 1; f < g; f++) {
    const ee = C.charCodeAt(f);
    if (ee === 91) return false;
    if (ee === 93) {
      P = f;
      break;
    } else if (ee === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (ee === 92 && (f++, f < g && C.charCodeAt(f) === 10)) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    }
  }
  if (P < 0 || C.charCodeAt(P + 1) !== 58) return false;
  for (f = P + 2; f < g; f++) {
    const ee = C.charCodeAt(f);
    if (ee === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!_i(ee)) break;
  }
  const M = r.md.helpers.parseLinkDestination(C, f, g);
  if (!M.ok) return false;
  const F = r.md.normalizeLink(M.str);
  if (!r.md.validateLink(F)) return false;
  f = M.pos;
  const D = f, A = m, O = f;
  for (; f < g; f++) {
    const ee = C.charCodeAt(f);
    if (ee === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!_i(ee)) break;
  }
  let V = r.md.helpers.parseLinkTitle(C, f, g);
  for (; V.can_continue; ) {
    const ee = s(m);
    if (ee === null) break;
    C += ee, f = g, g = C.length, m++, V = r.md.helpers.parseLinkTitle(C, f, g, V);
  }
  let Y;
  for (f < g && O !== f && V.ok ? (Y = V.str, f = V.pos) : (Y = "", f = D, m = A); f < g; ) {
    const ee = C.charCodeAt(f);
    if (!_i(ee)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10 && Y) for (Y = "", f = D, m = A; f < g; ) {
    const ee = C.charCodeAt(f);
    if (!_i(ee)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10) return false;
  const W = vp(C.slice(1, P));
  return W ? (d || (typeof r.env.references > "u" && (r.env.references = {}), typeof r.env.references[W] > "u" && (r.env.references[W] = { title: Y, href: F }), r.line = m), true) : false;
}
const jE = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], NE = "[a-zA-Z_:][a-zA-Z0-9:._-]*", VE = "[^\"'=<>`\\x00-\\x20]+", UE = "'[^']*'", qE = '"[^"]*"', GE = "(?:" + VE + "|" + UE + "|" + qE + ")", WE = "(?:\\s+" + NE + "(?:\\s*=\\s*" + GE + ")?)", F1 = "<[A-Za-z][A-Za-z0-9\\-]*" + WE + "*\\s*\\/?>", L1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", ZE = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", HE = "<[?][\\s\\S]*?[?]>", XE = "<![A-Za-z][^>]*>", YE = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", KE = new RegExp("^(?:" + F1 + "|" + L1 + "|" + ZE + "|" + HE + "|" + XE + "|" + YE + ")"), JE = new RegExp("^(?:" + F1 + "|" + L1 + ")"), Yu = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + jE.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(JE.source + "\\s*$"), /^$/, false]];
function QE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || !r.md.options.html || r.src.charCodeAt(f) !== 60) return false;
  let m = r.src.slice(f, g), s = 0;
  for (; s < Yu.length && !Yu[s][0].test(m); s++) ;
  if (s === Yu.length) return false;
  if (d) return Yu[s][2];
  let C = i + 1;
  if (!Yu[s][1].test(m)) {
    for (; C < l && !(r.sCount[C] < r.blkIndent); C++) if (f = r.bMarks[C] + r.tShift[C], g = r.eMarks[C], m = r.src.slice(f, g), Yu[s][1].test(m)) {
      m.length !== 0 && C++;
      break;
    }
  }
  r.line = C;
  const P = r.push("html_block", "", 0);
  return P.map = [i, C], P.content = r.getLines(i, C, r.blkIndent, true), true;
}
function eR(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let m = r.src.charCodeAt(f);
  if (m !== 35 || f >= g) return false;
  let s = 1;
  for (m = r.src.charCodeAt(++f); m === 35 && f < g && s <= 6; ) s++, m = r.src.charCodeAt(++f);
  if (s > 6 || f < g && !_i(m)) return false;
  if (d) return true;
  g = r.skipSpacesBack(g, f);
  const C = r.skipCharsBack(g, 35, f);
  C > f && _i(r.src.charCodeAt(C - 1)) && (g = C), r.line = i + 1;
  const P = r.push("heading_open", "h" + String(s), 1);
  P.markup = "########".slice(0, s), P.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = r.src.slice(f, g).trim(), M.map = [i, r.line], M.children = [];
  const F = r.push("heading_close", "h" + String(s), -1);
  return F.markup = "########".slice(0, s), true;
}
function tR(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph");
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  const f = r.parentType;
  r.parentType = "paragraph";
  let g = 0, m, s = i + 1;
  for (; s < l && !r.isEmpty(s); s++) {
    if (r.sCount[s] - r.blkIndent > 3) continue;
    if (r.sCount[s] >= r.blkIndent) {
      let A = r.bMarks[s] + r.tShift[s];
      const O = r.eMarks[s];
      if (A < O && (m = r.src.charCodeAt(A), (m === 45 || m === 61) && (A = r.skipChars(A, m), A = r.skipSpaces(A), A >= O))) {
        g = m === 61 ? 1 : 2;
        break;
      }
    }
    if (r.sCount[s] < 0) continue;
    let D = false;
    for (let A = 0, O = d.length; A < O; A++) if (d[A](r, s, l, true)) {
      D = true;
      break;
    }
    if (D) break;
  }
  if (!g) return false;
  const C = r.getLines(i, s, r.blkIndent, false).trim();
  r.line = s + 1;
  const P = r.push("heading_open", "h" + String(g), 1);
  P.markup = String.fromCharCode(m), P.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = C, M.map = [i, r.line - 1], M.children = [];
  const F = r.push("heading_close", "h" + String(g), -1);
  return F.markup = String.fromCharCode(m), r.parentType = f, true;
}
function rR(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph"), f = r.parentType;
  let g = i + 1;
  for (r.parentType = "paragraph"; g < l && !r.isEmpty(g); g++) {
    if (r.sCount[g] - r.blkIndent > 3 || r.sCount[g] < 0) continue;
    let P = false;
    for (let M = 0, F = d.length; M < F; M++) if (d[M](r, g, l, true)) {
      P = true;
      break;
    }
    if (P) break;
  }
  const m = r.getLines(i, g, r.blkIndent, false).trim();
  r.line = g;
  const s = r.push("paragraph_open", "p", 1);
  s.map = [i, r.line];
  const C = r.push("inline", "", 0);
  return C.content = m, C.map = [i, r.line], C.children = [], r.push("paragraph_close", "p", -1), r.parentType = f, true;
}
const Lf = [["table", AE, ["paragraph", "reference"]], ["code", DE], ["fence", zE, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", FE, ["paragraph", "reference", "blockquote", "list"]], ["hr", LE, ["paragraph", "reference", "blockquote", "list"]], ["list", OE, ["paragraph", "reference", "blockquote"]], ["reference", $E], ["html_block", QE, ["paragraph", "reference", "blockquote"]], ["heading", eR, ["paragraph", "reference", "blockquote"]], ["lheading", tR], ["paragraph", rR]];
function yp() {
  this.ruler = new Jn();
  for (let r = 0; r < Lf.length; r++) this.ruler.push(Lf[r][0], Lf[r][1], { alt: (Lf[r][2] || []).slice() });
}
yp.prototype.tokenize = function(r, i, l) {
  const d = this.ruler.getRules(""), f = d.length, g = r.md.options.maxNesting;
  let m = i, s = false;
  for (; m < l && (r.line = m = r.skipEmptyLines(m), !(m >= l || r.sCount[m] < r.blkIndent)); ) {
    if (r.level >= g) {
      r.line = l;
      break;
    }
    const C = r.line;
    let P = false;
    for (let M = 0; M < f; M++) if (P = d[M](r, m, l, false), P) {
      if (C >= r.line) throw new Error("block rule didn't increment state.line");
      break;
    }
    if (!P) throw new Error("none of the block rules matched");
    r.tight = !s, r.isEmpty(r.line - 1) && (s = true), m = r.line, m < l && r.isEmpty(m) && (s = true, m++, r.line = m);
  }
};
yp.prototype.parse = function(r, i, l, d) {
  if (!r) return;
  const f = new this.State(r, i, l, d);
  this.tokenize(f, f.line, f.lineMax);
};
yp.prototype.State = ba;
function ah(r, i, l, d) {
  this.src = r, this.env = l, this.md = i, this.tokens = d, this.tokens_meta = Array(d.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
ah.prototype.pushPending = function() {
  const r = new Ko("text", "", 0);
  return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
};
ah.prototype.push = function(r, i, l) {
  this.pending && this.pushPending();
  const d = new Ko(r, i, l);
  let f = null;
  return l < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), d.level = this.level, l > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], f = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(d), this.tokens_meta.push(f), d;
};
ah.prototype.scanDelims = function(r, i) {
  const l = this.posMax, d = this.src.charCodeAt(r), f = r > 0 ? this.src.charCodeAt(r - 1) : 32;
  let g = r;
  for (; g < l && this.src.charCodeAt(g) === d; ) g++;
  const m = g - r, s = g < l ? this.src.charCodeAt(g) : 32, C = Kd(f) || Yd(String.fromCharCode(f)), P = Kd(s) || Yd(String.fromCharCode(s)), M = Xd(f), F = Xd(s), D = !F && (!P || M || C), A = !M && (!C || F || P);
  return { can_open: D && (i || !A || C), can_close: A && (i || !D || P), length: m };
};
ah.prototype.Token = Ko;
function iR(r) {
  switch (r) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function nR(r, i) {
  let l = r.pos;
  for (; l < r.posMax && !iR(r.src.charCodeAt(l)); ) l++;
  return l === r.pos ? false : (i || (r.pending += r.src.slice(r.pos, l)), r.pos = l, true);
}
const oR = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function aR(r, i) {
  if (!r.md.options.linkify || r.linkLevel > 0) return false;
  const l = r.pos, d = r.posMax;
  if (l + 3 > d || r.src.charCodeAt(l) !== 58 || r.src.charCodeAt(l + 1) !== 47 || r.src.charCodeAt(l + 2) !== 47) return false;
  const f = r.pending.match(oR);
  if (!f) return false;
  const g = f[1], m = r.md.linkify.matchAtStart(r.src.slice(l - g.length));
  if (!m) return false;
  let s = m.url;
  if (s.length <= g.length) return false;
  s = s.replace(/\*+$/, "");
  const C = r.md.normalizeLink(s);
  if (!r.md.validateLink(C)) return false;
  if (!i) {
    r.pending = r.pending.slice(0, -g.length);
    const P = r.push("link_open", "a", 1);
    P.attrs = [["href", C]], P.markup = "linkify", P.info = "auto";
    const M = r.push("text", "", 0);
    M.content = r.md.normalizeLinkText(s);
    const F = r.push("link_close", "a", -1);
    F.markup = "linkify", F.info = "auto";
  }
  return r.pos += s.length - g.length, true;
}
function sR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 10) return false;
  const d = r.pending.length - 1, f = r.posMax;
  if (!i) if (d >= 0 && r.pending.charCodeAt(d) === 32) if (d >= 1 && r.pending.charCodeAt(d - 1) === 32) {
    let g = d - 1;
    for (; g >= 1 && r.pending.charCodeAt(g - 1) === 32; ) g--;
    r.pending = r.pending.slice(0, g), r.push("hardbreak", "br", 0);
  } else r.pending = r.pending.slice(0, -1), r.push("softbreak", "br", 0);
  else r.push("softbreak", "br", 0);
  for (l++; l < f && _i(r.src.charCodeAt(l)); ) l++;
  return r.pos = l, true;
}
const d0 = [];
for (let r = 0; r < 256; r++) d0.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
  d0[r.charCodeAt(0)] = 1;
});
function lR(r, i) {
  let l = r.pos;
  const d = r.posMax;
  if (r.src.charCodeAt(l) !== 92 || (l++, l >= d)) return false;
  let f = r.src.charCodeAt(l);
  if (f === 10) {
    for (i || r.push("hardbreak", "br", 0), l++; l < d && (f = r.src.charCodeAt(l), !!_i(f)); ) l++;
    return r.pos = l, true;
  }
  let g = r.src[l];
  if (f >= 55296 && f <= 56319 && l + 1 < d) {
    const s = r.src.charCodeAt(l + 1);
    s >= 56320 && s <= 57343 && (g += r.src[l + 1], l++);
  }
  const m = "\\" + g;
  if (!i) {
    const s = r.push("text_special", "", 0);
    f < 256 && d0[f] !== 0 ? s.content = g : s.content = m, s.markup = m, s.info = "escape";
  }
  return r.pos = l + 1, true;
}
function uR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 96) return false;
  const f = l;
  l++;
  const g = r.posMax;
  for (; l < g && r.src.charCodeAt(l) === 96; ) l++;
  const m = r.src.slice(f, l), s = m.length;
  if (r.backticksScanned && (r.backticks[s] || 0) <= f) return i || (r.pending += m), r.pos += s, true;
  let C = l, P;
  for (; (P = r.src.indexOf("`", C)) !== -1; ) {
    for (C = P + 1; C < g && r.src.charCodeAt(C) === 96; ) C++;
    const M = C - P;
    if (M === s) {
      if (!i) {
        const F = r.push("code_inline", "code", 0);
        F.markup = m, F.content = r.src.slice(l, P).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return r.pos = C, true;
    }
    r.backticks[M] = P;
  }
  return r.backticksScanned = true, i || (r.pending += m), r.pos += s, true;
}
function cR(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 126) return false;
  const f = r.scanDelims(r.pos, true);
  let g = f.length;
  const m = String.fromCharCode(d);
  if (g < 2) return false;
  let s;
  g % 2 && (s = r.push("text", "", 0), s.content = m, g--);
  for (let C = 0; C < g; C += 2) s = r.push("text", "", 0), s.content = m + m, r.delimiters.push({ marker: d, length: 0, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  return r.pos += f.length, true;
}
function v_(r, i) {
  let l;
  const d = [], f = i.length;
  for (let g = 0; g < f; g++) {
    const m = i[g];
    if (m.marker !== 126 || m.end === -1) continue;
    const s = i[m.end];
    l = r.tokens[m.token], l.type = "s_open", l.tag = "s", l.nesting = 1, l.markup = "~~", l.content = "", l = r.tokens[s.token], l.type = "s_close", l.tag = "s", l.nesting = -1, l.markup = "~~", l.content = "", r.tokens[s.token - 1].type === "text" && r.tokens[s.token - 1].content === "~" && d.push(s.token - 1);
  }
  for (; d.length; ) {
    const g = d.pop();
    let m = g + 1;
    for (; m < r.tokens.length && r.tokens[m].type === "s_close"; ) m++;
    m--, g !== m && (l = r.tokens[m], r.tokens[m] = r.tokens[g], r.tokens[g] = l);
  }
}
function dR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  v_(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && v_(r, i[d].delimiters);
}
const B1 = { tokenize: cR, postProcess: dR };
function hR(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 95 && d !== 42) return false;
  const f = r.scanDelims(r.pos, d === 42);
  for (let g = 0; g < f.length; g++) {
    const m = r.push("text", "", 0);
    m.content = String.fromCharCode(d), r.delimiters.push({ marker: d, length: f.length, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  }
  return r.pos += f.length, true;
}
function y_(r, i) {
  const l = i.length;
  for (let d = l - 1; d >= 0; d--) {
    const f = i[d];
    if (f.marker !== 95 && f.marker !== 42 || f.end === -1) continue;
    const g = i[f.end], m = d > 0 && i[d - 1].end === f.end + 1 && i[d - 1].marker === f.marker && i[d - 1].token === f.token - 1 && i[f.end + 1].token === g.token + 1, s = String.fromCharCode(f.marker), C = r.tokens[f.token];
    C.type = m ? "strong_open" : "em_open", C.tag = m ? "strong" : "em", C.nesting = 1, C.markup = m ? s + s : s, C.content = "";
    const P = r.tokens[g.token];
    P.type = m ? "strong_close" : "em_close", P.tag = m ? "strong" : "em", P.nesting = -1, P.markup = m ? s + s : s, P.content = "", m && (r.tokens[i[d - 1].token].content = "", r.tokens[i[f.end + 1].token].content = "", d--);
  }
}
function fR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  y_(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && y_(r, i[d].delimiters);
}
const O1 = { tokenize: hR, postProcess: fR };
function pR(r, i) {
  let l, d, f, g, m = "", s = "", C = r.pos, P = true;
  if (r.src.charCodeAt(r.pos) !== 91) return false;
  const M = r.pos, F = r.posMax, D = r.pos + 1, A = r.md.helpers.parseLinkLabel(r, r.pos, true);
  if (A < 0) return false;
  let O = A + 1;
  if (O < F && r.src.charCodeAt(O) === 40) {
    for (P = false, O++; O < F && (l = r.src.charCodeAt(O), !(!_i(l) && l !== 10)); O++) ;
    if (O >= F) return false;
    if (C = O, f = r.md.helpers.parseLinkDestination(r.src, O, r.posMax), f.ok) {
      for (m = r.md.normalizeLink(f.str), r.md.validateLink(m) ? O = f.pos : m = "", C = O; O < F && (l = r.src.charCodeAt(O), !(!_i(l) && l !== 10)); O++) ;
      if (f = r.md.helpers.parseLinkTitle(r.src, O, r.posMax), O < F && C !== O && f.ok) for (s = f.str, O = f.pos; O < F && (l = r.src.charCodeAt(O), !(!_i(l) && l !== 10)); O++) ;
    }
    (O >= F || r.src.charCodeAt(O) !== 41) && (P = true), O++;
  }
  if (P) {
    if (typeof r.env.references > "u") return false;
    if (O < F && r.src.charCodeAt(O) === 91 ? (C = O + 1, O = r.md.helpers.parseLinkLabel(r, O), O >= 0 ? d = r.src.slice(C, O++) : O = A + 1) : O = A + 1, d || (d = r.src.slice(D, A)), g = r.env.references[vp(d)], !g) return r.pos = M, false;
    m = g.href, s = g.title;
  }
  if (!i) {
    r.pos = D, r.posMax = A;
    const V = r.push("link_open", "a", 1), Y = [["href", m]];
    V.attrs = Y, s && Y.push(["title", s]), r.linkLevel++, r.md.inline.tokenize(r), r.linkLevel--, r.push("link_close", "a", -1);
  }
  return r.pos = O, r.posMax = F, true;
}
function mR(r, i) {
  let l, d, f, g, m, s, C, P, M = "";
  const F = r.pos, D = r.posMax;
  if (r.src.charCodeAt(r.pos) !== 33 || r.src.charCodeAt(r.pos + 1) !== 91) return false;
  const A = r.pos + 2, O = r.md.helpers.parseLinkLabel(r, r.pos + 1, false);
  if (O < 0) return false;
  if (g = O + 1, g < D && r.src.charCodeAt(g) === 40) {
    for (g++; g < D && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    if (g >= D) return false;
    for (P = g, s = r.md.helpers.parseLinkDestination(r.src, g, r.posMax), s.ok && (M = r.md.normalizeLink(s.str), r.md.validateLink(M) ? g = s.pos : M = ""), P = g; g < D && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    if (s = r.md.helpers.parseLinkTitle(r.src, g, r.posMax), g < D && P !== g && s.ok) for (C = s.str, g = s.pos; g < D && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    else C = "";
    if (g >= D || r.src.charCodeAt(g) !== 41) return r.pos = F, false;
    g++;
  } else {
    if (typeof r.env.references > "u") return false;
    if (g < D && r.src.charCodeAt(g) === 91 ? (P = g + 1, g = r.md.helpers.parseLinkLabel(r, g), g >= 0 ? f = r.src.slice(P, g++) : g = O + 1) : g = O + 1, f || (f = r.src.slice(A, O)), m = r.env.references[vp(f)], !m) return r.pos = F, false;
    M = m.href, C = m.title;
  }
  if (!i) {
    d = r.src.slice(A, O);
    const V = [];
    r.md.inline.parse(d, r.md, r.env, V);
    const Y = r.push("image", "img", 0), W = [["src", M], ["alt", ""]];
    Y.attrs = W, Y.children = V, Y.content = d, C && W.push(["title", C]);
  }
  return r.pos = g, r.posMax = D, true;
}
const gR = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, vR = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function yR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 60) return false;
  const d = r.pos, f = r.posMax;
  for (; ; ) {
    if (++l >= f) return false;
    const m = r.src.charCodeAt(l);
    if (m === 60) return false;
    if (m === 62) break;
  }
  const g = r.src.slice(d + 1, l);
  if (vR.test(g)) {
    const m = r.md.normalizeLink(g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  if (gR.test(g)) {
    const m = r.md.normalizeLink("mailto:" + g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  return false;
}
function _R(r) {
  return /^<a[>\s]/i.test(r);
}
function bR(r) {
  return /^<\/a\s*>/i.test(r);
}
function xR(r) {
  const i = r | 32;
  return i >= 97 && i <= 122;
}
function wR(r, i) {
  if (!r.md.options.html) return false;
  const l = r.posMax, d = r.pos;
  if (r.src.charCodeAt(d) !== 60 || d + 2 >= l) return false;
  const f = r.src.charCodeAt(d + 1);
  if (f !== 33 && f !== 63 && f !== 47 && !xR(f)) return false;
  const g = r.src.slice(d).match(KE);
  if (!g) return false;
  if (!i) {
    const m = r.push("html_inline", "", 0);
    m.content = g[0], _R(m.content) && r.linkLevel++, bR(m.content) && r.linkLevel--;
  }
  return r.pos += g[0].length, true;
}
const CR = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, SR = /^&([a-z][a-z0-9]{1,31});/i;
function kR(r, i) {
  const l = r.pos, d = r.posMax;
  if (r.src.charCodeAt(l) !== 38 || l + 1 >= d) return false;
  if (r.src.charCodeAt(l + 1) === 35) {
    const g = r.src.slice(l).match(CR);
    if (g) {
      if (!i) {
        const m = g[1][0].toLowerCase() === "x" ? parseInt(g[1].slice(1), 16) : parseInt(g[1], 10), s = r.push("text_special", "", 0);
        s.content = u0(m) ? Qf(m) : Qf(65533), s.markup = g[0], s.info = "entity";
      }
      return r.pos += g[0].length, true;
    }
  } else {
    const g = r.src.slice(l).match(SR);
    if (g) {
      const m = E1(g[0]);
      if (m !== g[0]) {
        if (!i) {
          const s = r.push("text_special", "", 0);
          s.content = m, s.markup = g[0], s.info = "entity";
        }
        return r.pos += g[0].length, true;
      }
    }
  }
  return false;
}
function __(r) {
  const i = {}, l = r.length;
  if (!l) return;
  let d = 0, f = -2;
  const g = [];
  for (let m = 0; m < l; m++) {
    const s = r[m];
    if (g.push(0), (r[d].marker !== s.marker || f !== s.token - 1) && (d = m), f = s.token, s.length = s.length || 0, !s.close) continue;
    i.hasOwnProperty(s.marker) || (i[s.marker] = [-1, -1, -1, -1, -1, -1]);
    const C = i[s.marker][(s.open ? 3 : 0) + s.length % 3];
    let P = d - g[d] - 1, M = P;
    for (; P > C; P -= g[P] + 1) {
      const F = r[P];
      if (F.marker === s.marker && F.open && F.end < 0) {
        let D = false;
        if ((F.close || s.open) && (F.length + s.length) % 3 === 0 && (F.length % 3 !== 0 || s.length % 3 !== 0) && (D = true), !D) {
          const A = P > 0 && !r[P - 1].open ? g[P - 1] + 1 : 0;
          g[m] = m - P + A, g[P] = A, s.open = false, F.end = m, F.close = false, M = -1, f = -2;
          break;
        }
      }
    }
    M !== -1 && (i[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = M);
  }
}
function PR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  __(r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && __(i[d].delimiters);
}
function TR(r) {
  let i, l, d = 0;
  const f = r.tokens, g = r.tokens.length;
  for (i = l = 0; i < g; i++) f[i].nesting < 0 && d--, f[i].level = d, f[i].nesting > 0 && d++, f[i].type === "text" && i + 1 < g && f[i + 1].type === "text" ? f[i + 1].content = f[i].content + f[i + 1].content : (i !== l && (f[l] = f[i]), l++);
  i !== l && (f.length = l);
}
const ig = [["text", nR], ["linkify", aR], ["newline", sR], ["escape", lR], ["backticks", uR], ["strikethrough", B1.tokenize], ["emphasis", O1.tokenize], ["link", pR], ["image", mR], ["autolink", yR], ["html_inline", wR], ["entity", kR]], ng = [["balance_pairs", PR], ["strikethrough", B1.postProcess], ["emphasis", O1.postProcess], ["fragments_join", TR]];
function sh() {
  this.ruler = new Jn();
  for (let r = 0; r < ig.length; r++) this.ruler.push(ig[r][0], ig[r][1]);
  this.ruler2 = new Jn();
  for (let r = 0; r < ng.length; r++) this.ruler2.push(ng[r][0], ng[r][1]);
}
sh.prototype.skipToken = function(r) {
  const i = r.pos, l = this.ruler.getRules(""), d = l.length, f = r.md.options.maxNesting, g = r.cache;
  if (typeof g[i] < "u") {
    r.pos = g[i];
    return;
  }
  let m = false;
  if (r.level < f) {
    for (let s = 0; s < d; s++) if (r.level++, m = l[s](r, true), r.level--, m) {
      if (i >= r.pos) throw new Error("inline rule didn't increment state.pos");
      break;
    }
  } else r.pos = r.posMax;
  m || r.pos++, g[i] = r.pos;
};
sh.prototype.tokenize = function(r) {
  const i = this.ruler.getRules(""), l = i.length, d = r.posMax, f = r.md.options.maxNesting;
  for (; r.pos < d; ) {
    const g = r.pos;
    let m = false;
    if (r.level < f) {
      for (let s = 0; s < l; s++) if (m = i[s](r, false), m) {
        if (g >= r.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    }
    if (m) {
      if (r.pos >= d) break;
      continue;
    }
    r.pending += r.src[r.pos++];
  }
  r.pending && r.pushPending();
};
sh.prototype.parse = function(r, i, l, d) {
  const f = new this.State(r, i, l, d);
  this.tokenize(f);
  const g = this.ruler2.getRules(""), m = g.length;
  for (let s = 0; s < m; s++) g[s](f);
};
sh.prototype.State = ah;
function IR(r) {
  const i = {};
  r = r || {}, i.src_Any = k1.source, i.src_Cc = P1.source, i.src_Z = I1.source, i.src_P = s0.source, i.src_ZPCc = [i.src_Z, i.src_P, i.src_Cc].join("|"), i.src_ZCc = [i.src_Z, i.src_Cc].join("|");
  const l = "[><\uFF5C]";
  return i.src_pseudo_letter = "(?:(?!" + l + "|" + i.src_ZPCc + ")" + i.src_Any + ")", i.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", i.src_auth = "(?:(?:(?!" + i.src_ZCc + "|[@/\\[\\]()]).)+@)?", i.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", i.src_host_terminator = "(?=$|" + l + "|" + i.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + i.src_ZPCc + "))", i.src_path = "(?:[/?#](?:(?!" + i.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + i.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + i.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + i.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + i.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + i.src_ZCc + "|[']).)+\\'|\\'(?=" + i.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + i.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + i.src_ZCc + "|$)|;(?!" + i.src_ZCc + "|$)|\\!+(?!" + i.src_ZCc + "|[!]|$)|\\?(?!" + i.src_ZCc + "|[?]|$))+|\\/)?", i.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', i.src_xn = "xn--[a-z0-9\\-]{1,59}", i.src_domain_root = "(?:" + i.src_xn + "|" + i.src_pseudo_letter + "{1,63})", i.src_domain = "(?:" + i.src_xn + "|(?:" + i.src_pseudo_letter + ")|(?:" + i.src_pseudo_letter + "(?:-|" + i.src_pseudo_letter + "){0,61}" + i.src_pseudo_letter + "))", i.src_host = "(?:(?:(?:(?:" + i.src_domain + ")\\.)*" + i.src_domain + "))", i.tpl_host_fuzzy = "(?:" + i.src_ip4 + "|(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%)))", i.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%))", i.src_host_strict = i.src_host + i.src_host_terminator, i.tpl_host_fuzzy_strict = i.tpl_host_fuzzy + i.src_host_terminator, i.src_host_port_strict = i.src_host + i.src_port + i.src_host_terminator, i.tpl_host_port_fuzzy_strict = i.tpl_host_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_port_no_ip_fuzzy_strict = i.tpl_host_no_ip_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + i.src_ZPCc + "|>|$))", i.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + i.src_ZCc + ")(" + i.src_email_name + "@" + i.tpl_host_fuzzy_strict + ")", i.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_fuzzy_strict + i.src_path + ")", i.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_no_ip_fuzzy_strict + i.src_path + ")", i;
}
function Bg(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    l && Object.keys(l).forEach(function(d) {
      r[d] = l[d];
    });
  }), r;
}
function _p(r) {
  return Object.prototype.toString.call(r);
}
function MR(r) {
  return _p(r) === "[object String]";
}
function ER(r) {
  return _p(r) === "[object Object]";
}
function RR(r) {
  return _p(r) === "[object RegExp]";
}
function b_(r) {
  return _p(r) === "[object Function]";
}
function AR(r) {
  return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const $1 = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
function DR(r) {
  return Object.keys(r || {}).reduce(function(i, l) {
    return i || $1.hasOwnProperty(l);
  }, false);
}
const zR = { "http:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.http || (l.re.http = new RegExp("^\\/\\/" + l.re.src_auth + l.re.src_host_port_strict + l.re.src_path, "i")), l.re.http.test(d) ? d.match(l.re.http)[0].length : 0;
} }, "https:": "http:", "ftp:": "http:", "//": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.no_http || (l.re.no_http = new RegExp("^" + l.re.src_auth + "(?:localhost|(?:(?:" + l.re.src_domain + ")\\.)+" + l.re.src_domain_root + ")" + l.re.src_port + l.re.src_host_terminator + l.re.src_path, "i")), l.re.no_http.test(d) ? i >= 3 && r[i - 3] === ":" || i >= 3 && r[i - 3] === "/" ? 0 : d.match(l.re.no_http)[0].length : 0;
} }, "mailto:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.mailto || (l.re.mailto = new RegExp("^" + l.re.src_email_name + "@" + l.re.src_host_strict, "i")), l.re.mailto.test(d) ? d.match(l.re.mailto)[0].length : 0;
} } }, FR = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", LR = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function BR(r) {
  r.__index__ = -1, r.__text_cache__ = "";
}
function OR(r) {
  return function(i, l) {
    const d = i.slice(l);
    return r.test(d) ? d.match(r)[0].length : 0;
  };
}
function x_() {
  return function(r, i) {
    i.normalize(r);
  };
}
function ep(r) {
  const i = r.re = IR(r.__opts__), l = r.__tlds__.slice();
  r.onCompile(), r.__tlds_replaced__ || l.push(FR), l.push(i.src_xn), i.src_tlds = l.join("|");
  function d(s) {
    return s.replace("%TLDS%", i.src_tlds);
  }
  i.email_fuzzy = RegExp(d(i.tpl_email_fuzzy), "i"), i.link_fuzzy = RegExp(d(i.tpl_link_fuzzy), "i"), i.link_no_ip_fuzzy = RegExp(d(i.tpl_link_no_ip_fuzzy), "i"), i.host_fuzzy_test = RegExp(d(i.tpl_host_fuzzy_test), "i");
  const f = [];
  r.__compiled__ = {};
  function g(s, C) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + C);
  }
  Object.keys(r.__schemas__).forEach(function(s) {
    const C = r.__schemas__[s];
    if (C === null) return;
    const P = { validate: null, link: null };
    if (r.__compiled__[s] = P, ER(C)) {
      RR(C.validate) ? P.validate = OR(C.validate) : b_(C.validate) ? P.validate = C.validate : g(s, C), b_(C.normalize) ? P.normalize = C.normalize : C.normalize ? g(s, C) : P.normalize = x_();
      return;
    }
    if (MR(C)) {
      f.push(s);
      return;
    }
    g(s, C);
  }), f.forEach(function(s) {
    r.__compiled__[r.__schemas__[s]] && (r.__compiled__[s].validate = r.__compiled__[r.__schemas__[s]].validate, r.__compiled__[s].normalize = r.__compiled__[r.__schemas__[s]].normalize);
  }), r.__compiled__[""] = { validate: null, normalize: x_() };
  const m = Object.keys(r.__compiled__).filter(function(s) {
    return s.length > 0 && r.__compiled__[s];
  }).map(AR).join("|");
  r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), BR(r);
}
function $R(r, i) {
  const l = r.__index__, d = r.__last_index__, f = r.__text_cache__.slice(l, d);
  this.schema = r.__schema__.toLowerCase(), this.index = l + i, this.lastIndex = d + i, this.raw = f, this.text = f, this.url = f;
}
function Og(r, i) {
  const l = new $R(r, i);
  return r.__compiled__[l.schema].normalize(l, r), l;
}
function yo(r, i) {
  if (!(this instanceof yo)) return new yo(r, i);
  i || DR(r) && (i = r, r = {}), this.__opts__ = Bg({}, $1, i), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Bg({}, zR, r), this.__compiled__ = {}, this.__tlds__ = LR, this.__tlds_replaced__ = false, this.re = {}, ep(this);
}
yo.prototype.add = function(i, l) {
  return this.__schemas__[i] = l, ep(this), this;
};
yo.prototype.set = function(i) {
  return this.__opts__ = Bg(this.__opts__, i), this;
};
yo.prototype.test = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return false;
  let l, d, f, g, m, s, C, P, M;
  if (this.re.schema_test.test(i)) {
    for (C = this.re.schema_search, C.lastIndex = 0; (l = C.exec(i)) !== null; ) if (g = this.testSchemaAt(i, l[2], C.lastIndex), g) {
      this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + g;
      break;
    }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (P = i.search(this.re.host_fuzzy_test), P >= 0 && (this.__index__ < 0 || P < this.__index__) && (d = i.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (m = d.index + d[1].length, (this.__index__ < 0 || m < this.__index__) && (this.__schema__ = "", this.__index__ = m, this.__last_index__ = d.index + d[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (M = i.indexOf("@"), M >= 0 && (f = i.match(this.re.email_fuzzy)) !== null && (m = f.index + f[1].length, s = f.index + f[0].length, (this.__index__ < 0 || m < this.__index__ || m === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = m, this.__last_index__ = s))), this.__index__ >= 0;
};
yo.prototype.pretest = function(i) {
  return this.re.pretest.test(i);
};
yo.prototype.testSchemaAt = function(i, l, d) {
  return this.__compiled__[l.toLowerCase()] ? this.__compiled__[l.toLowerCase()].validate(i, d, this) : 0;
};
yo.prototype.match = function(i) {
  const l = [];
  let d = 0;
  this.__index__ >= 0 && this.__text_cache__ === i && (l.push(Og(this, d)), d = this.__last_index__);
  let f = d ? i.slice(d) : i;
  for (; this.test(f); ) l.push(Og(this, d)), f = f.slice(this.__last_index__), d += this.__last_index__;
  return l.length ? l : null;
};
yo.prototype.matchAtStart = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return null;
  const l = this.re.schema_at_start.exec(i);
  if (!l) return null;
  const d = this.testSchemaAt(i, l[2], l[0].length);
  return d ? (this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + d, Og(this, 0)) : null;
};
yo.prototype.tlds = function(i, l) {
  return i = Array.isArray(i) ? i : [i], l ? (this.__tlds__ = this.__tlds__.concat(i).sort().filter(function(d, f, g) {
    return d !== g[f - 1];
  }).reverse(), ep(this), this) : (this.__tlds__ = i.slice(), this.__tlds_replaced__ = true, ep(this), this);
};
yo.prototype.normalize = function(i) {
  i.schema || (i.url = "http://" + i.url), i.schema === "mailto:" && !/^mailto:/i.test(i.url) && (i.url = "mailto:" + i.url);
};
yo.prototype.onCompile = function() {
};
const ec = 2147483647, fa = 36, h0 = 1, Jd = 26, jR = 38, NR = 700, j1 = 72, N1 = 128, V1 = "-", VR = /^xn--/, UR = /[^\0-\x7F]/, qR = /[\x2E\u3002\uFF0E\uFF61]/g, GR = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, og = fa - h0, pa = Math.floor, ag = String.fromCharCode;
function ys(r) {
  throw new RangeError(GR[r]);
}
function WR(r, i) {
  const l = [];
  let d = r.length;
  for (; d--; ) l[d] = i(r[d]);
  return l;
}
function U1(r, i) {
  const l = r.split("@");
  let d = "";
  l.length > 1 && (d = l[0] + "@", r = l[1]), r = r.replace(qR, ".");
  const f = r.split("."), g = WR(f, i).join(".");
  return d + g;
}
function q1(r) {
  const i = [];
  let l = 0;
  const d = r.length;
  for (; l < d; ) {
    const f = r.charCodeAt(l++);
    if (f >= 55296 && f <= 56319 && l < d) {
      const g = r.charCodeAt(l++);
      (g & 64512) == 56320 ? i.push(((f & 1023) << 10) + (g & 1023) + 65536) : (i.push(f), l--);
    } else i.push(f);
  }
  return i;
}
const ZR = (r) => String.fromCodePoint(...r), HR = function(r) {
  return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : fa;
}, w_ = function(r, i) {
  return r + 22 + 75 * (r < 26) - ((i != 0) << 5);
}, G1 = function(r, i, l) {
  let d = 0;
  for (r = l ? pa(r / NR) : r >> 1, r += pa(r / i); r > og * Jd >> 1; d += fa) r = pa(r / og);
  return pa(d + (og + 1) * r / (r + jR));
}, W1 = function(r) {
  const i = [], l = r.length;
  let d = 0, f = N1, g = j1, m = r.lastIndexOf(V1);
  m < 0 && (m = 0);
  for (let s = 0; s < m; ++s) r.charCodeAt(s) >= 128 && ys("not-basic"), i.push(r.charCodeAt(s));
  for (let s = m > 0 ? m + 1 : 0; s < l; ) {
    const C = d;
    for (let M = 1, F = fa; ; F += fa) {
      s >= l && ys("invalid-input");
      const D = HR(r.charCodeAt(s++));
      D >= fa && ys("invalid-input"), D > pa((ec - d) / M) && ys("overflow"), d += D * M;
      const A = F <= g ? h0 : F >= g + Jd ? Jd : F - g;
      if (D < A) break;
      const O = fa - A;
      M > pa(ec / O) && ys("overflow"), M *= O;
    }
    const P = i.length + 1;
    g = G1(d - C, P, C == 0), pa(d / P) > ec - f && ys("overflow"), f += pa(d / P), d %= P, i.splice(d++, 0, f);
  }
  return String.fromCodePoint(...i);
}, Z1 = function(r) {
  const i = [];
  r = q1(r);
  const l = r.length;
  let d = N1, f = 0, g = j1;
  for (const C of r) C < 128 && i.push(ag(C));
  const m = i.length;
  let s = m;
  for (m && i.push(V1); s < l; ) {
    let C = ec;
    for (const M of r) M >= d && M < C && (C = M);
    const P = s + 1;
    C - d > pa((ec - f) / P) && ys("overflow"), f += (C - d) * P, d = C;
    for (const M of r) if (M < d && ++f > ec && ys("overflow"), M === d) {
      let F = f;
      for (let D = fa; ; D += fa) {
        const A = D <= g ? h0 : D >= g + Jd ? Jd : D - g;
        if (F < A) break;
        const O = F - A, V = fa - A;
        i.push(ag(w_(A + O % V, 0))), F = pa(O / V);
      }
      i.push(ag(w_(F, 0))), g = G1(f, P, s === m), f = 0, ++s;
    }
    ++f, ++d;
  }
  return i.join("");
}, XR = function(r) {
  return U1(r, function(i) {
    return VR.test(i) ? W1(i.slice(4).toLowerCase()) : i;
  });
}, YR = function(r) {
  return U1(r, function(i) {
    return UR.test(i) ? "xn--" + Z1(i) : i;
  });
}, H1 = { version: "2.3.1", ucs2: { decode: q1, encode: ZR }, decode: W1, encode: Z1, toASCII: YR, toUnicode: XR }, KR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, JR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, QR = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }, eA = { default: KR, zero: JR, commonmark: QR }, tA = /^(vbscript|javascript|file|data):/, rA = /^data:image\/(gif|png|jpeg|webp);/;
function iA(r) {
  const i = r.trim().toLowerCase();
  return tA.test(i) ? rA.test(i) : true;
}
const X1 = ["http:", "https:", "mailto:"];
function nA(r) {
  const i = a0(r, true);
  if (i.hostname && (!i.protocol || X1.indexOf(i.protocol) >= 0)) try {
    i.hostname = H1.toASCII(i.hostname);
  } catch {
  }
  return oh(o0(i));
}
function oA(r) {
  const i = a0(r, true);
  if (i.hostname && (!i.protocol || X1.indexOf(i.protocol) >= 0)) try {
    i.hostname = H1.toUnicode(i.hostname);
  } catch {
  }
  return lc(o0(i), lc.defaultChars + "%");
}
function Ro(r, i) {
  if (!(this instanceof Ro)) return new Ro(r, i);
  i || l0(r) || (i = r || {}, r = "default"), this.inline = new sh(), this.block = new yp(), this.core = new c0(), this.renderer = new hc(), this.linkify = new yo(), this.validateLink = iA, this.normalizeLink = nA, this.normalizeLinkText = oA, this.utils = sE, this.helpers = gp({}, dE), this.options = {}, this.configure(r), i && this.set(i);
}
Ro.prototype.set = function(r) {
  return gp(this.options, r), this;
};
Ro.prototype.configure = function(r) {
  const i = this;
  if (l0(r)) {
    const l = r;
    if (r = eA[l], !r) throw new Error('Wrong `markdown-it` preset "' + l + '", check name');
  }
  if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return r.options && i.set(r.options), r.components && Object.keys(r.components).forEach(function(l) {
    r.components[l].rules && i[l].ruler.enableOnly(r.components[l].rules), r.components[l].rules2 && i[l].ruler2.enableOnly(r.components[l].rules2);
  }), this;
};
Ro.prototype.enable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.enable(r, true));
  }, this), l = l.concat(this.inline.ruler2.enable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + d);
  return this;
};
Ro.prototype.disable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.disable(r, true));
  }, this), l = l.concat(this.inline.ruler2.disable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + d);
  return this;
};
Ro.prototype.use = function(r) {
  const i = [this].concat(Array.prototype.slice.call(arguments, 1));
  return r.apply(r, i), this;
};
Ro.prototype.parse = function(r, i) {
  if (typeof r != "string") throw new Error("Input data should be a String");
  const l = new this.core.State(r, this, i);
  return this.core.process(l), l.tokens;
};
Ro.prototype.render = function(r, i) {
  return i = i || {}, this.renderer.render(this.parse(r, i), this.options, i);
};
Ro.prototype.parseInline = function(r, i) {
  const l = new this.core.State(r, this, i);
  return l.inlineMode = true, this.core.process(l), l.tokens;
};
Ro.prototype.renderInline = function(r, i) {
  return i = i || {}, this.renderer.render(this.parseInline(r, i), this.options, i);
};
const C_ = ot((r) => {
  const i = Ss(new Ro(r.options ?? {}));
  for (const d of r.plugins ?? []) i.value.use(d);
  const l = Me(() => i.value.render(r.source));
  return () => B("div", { innerHTML: l.value });
}, { props: ["source", "options", "plugins"] }), aA = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, sA = { class: "about-view" }, lA = { id: "project", class: "section project-section" }, uA = { class: "project-header" }, cA = { class: "project-description" }, dA = { id: "data-sources", class: "section data-sources" }, hA = ["href"], fA = { id: "credits", class: "section credits-section" }, pA = { class: "credit-content" }, mA = { key: 1 }, gA = { class: "license-text" }, vA = { class: "credit-links" }, yA = ["href"], _A = ["href"], bA = { __name: "AboutView", setup(r) {
  Fl((C) => ({ v1e81317d: `${s.value}px` }));
  const i = ks(), { t: l } = Eo(), d = Re(false), f = () => {
    d.value = window.innerWidth >= 700;
  };
  ji(() => {
    f(), window.addEventListener("resize", f);
  }), u2(() => {
    window.removeEventListener("resize", f);
  });
  const g = Re(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), m = (C) => C.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((P) => P.split(`
`).map((M) => M.trim()).join(" ")).join(`

`).trim(), s = Re(20);
  return (C, P) => (wt(), Xt("div", sA, [d.value ? (wt(), Tr(J(Pb), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: Ne(() => [$e(J($f), { title: J(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), $e(J($f), { title: J(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), $e(J($f), { title: J(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : jr("", true), Pt("section", lA, [$e(J(Xa), null, { default: Ne(() => [Pt("div", uA, [$e(J(Wb), { width: "100", src: g.value, "preview-disabled": "" }, null, 8, ["src"]), $e(J(X5), null, { default: Ne(() => [...P[0] || (P[0] = [Pr("Trackmaker", -1)])]), _: 1 })]), Pt("p", cA, ur(J(l)("aboutView.description")), 1), $e(J(py), { class: "license-collapse" }, { default: Ne(() => [$e(J(my), { title: "License", name: "license" }, { header: Ne(() => [$e(J(Sl), null, { default: Ne(() => [$e(J(Tf), null, { default: Ne(() => [...P[1] || (P[1] = [Pr("License", -1)])]), _: 1 }), $e(J(Mo), { type: "info", round: "", size: "small" }, { default: Ne(() => [...P[2] || (P[2] = [Pr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: Ne(() => [$e(J(C_), { source: J(aA), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), Pt("section", dA, [$e(J(Xa), null, { header: Ne(() => [Pr(ur(J(l)("aboutView.sections.dataSource")), 1)]), footer: Ne(() => [$e(J(C_), { source: J(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: Ne(() => [$e(J(dp), null, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(J(c2), (M) => (wt(), Tr(J(hp), { key: M.id }, { default: Ne(() => [$e(J(Sl), null, { default: Ne(() => [$e(J(Tf), null, { default: Ne(() => [Pr(ur(M.name), 1)]), _: 2 }, 1024), M.license ? (wt(), Tr(J(Mo), { key: 0, type: "info", round: "", size: "small" }, { default: Ne(() => [Pr(ur(M.license), 1)]), _: 2 }, 1024)) : jr("", true)]), _: 2 }, 1024)]), suffix: Ne(() => [Pt("a", { href: M.url, class: "external-link" }, [$e(J(Ci), { size: s.value, color: J(i).textColor1 }, { default: Ne(() => [$e(J(sy))]), _: 1 }, 8, ["size", "color"])], 8, hA)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), Pt("section", fA, [$e(J(Xa), { hoverable: "" }, { header: Ne(() => [Pr(ur(J(l)("aboutView.sections.credits")), 1)]), default: Ne(() => [$e(J(Tf), null, { default: Ne(() => [Pr(ur(J(l)("aboutView.creditIntro")), 1)]), _: 1 }), $e(J(py), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(J(d2).sort((M, F) => M.name.localeCompare(F.name)), (M) => (wt(), Tr(J(my), { key: M.id, title: M.name, name: M.id }, { header: Ne(() => [$e(J(Sl), null, { default: Ne(() => [Pr(ur(M.name) + " ", 1), M.licenseType.trim() ? (wt(), Tr(J(Sl), { key: 0 }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(M.licenseType.trim().split(",").map((F) => F.trim()), (F) => (wt(), Tr(J(Mo), { key: F, round: "", type: "info", size: "small" }, { default: Ne(() => [Pr(ur(F), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : jr("", true)]), _: 2 }, 1024)]), "header-extra": Ne(() => [Pt("div", vA, [M.homepage ? (wt(), Xt("a", { key: 0, href: M.homepage }, [$e(J(Ci), { size: s.value, color: J(i).textColor1 }, { default: Ne(() => [$e(J(sy))]), _: 1 }, 8, ["size", "color"])], 8, yA)) : jr("", true), M.url ? (wt(), Xt("a", { key: 1, href: M.url }, [$e(J(Ci), { size: s.value, color: J(i).textColor1 }, { default: Ne(() => [M.url.includes("github") ? (wt(), Tr(J(w3), { key: 0 })) : (wt(), Tr(J(pb), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, _A)) : jr("", true)])]), default: Ne(() => [Pt("div", pA, [Pt("p", null, ur(M.description), 1), M.license.trim() ? (wt(), Tr(J(WP), { key: 0 })) : jr("", true), M.license ? (wt(), Xt("div", mA, [$e(J(Tf), null, { default: Ne(() => [...P[3] || (P[3] = [Pt("strong", null, "License:", -1)])]), _: 1 }), Pt("div", gA, [Pt("pre", null, ur(m(M.license)), 1)])])) : jr("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, Y1 = Qn(bA, [["__scopeId", "data-v-e19031a0"]]), xA = Object.freeze(Object.defineProperty({ __proto__: null, default: Y1 }, Symbol.toStringTag, { value: "Module" })), wA = { class: "settings-view" }, CA = { class: "settings-layout" }, SA = { class: "settings-content" }, kA = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, PA = { key: 0 }, TA = { key: 1 }, IA = { key: 2 }, MA = { key: 0, class: "settings-nav" }, EA = ot({ __name: "SettingsView", setup(r) {
  const i = new Zg(), l = Me(() => i.isMobile), { width: d } = eb(), f = Me(() => d.value < 800), g = Me(() => d.value < 680), { t: m, availableLocales: s } = Eo(), C = pr("settings"), P = Me(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: m("settings.appearance.theme.options.light") }, { value: "dark", label: m("settings.appearance.theme.options.dark") }, { value: "system", label: m("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.interfaceLanguage.options.${M}`) })) }, { title: "mapLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.mapLanguage.options.${M}`) })).concat([{ value: "interface", label: m("settings.language.mapLanguage.options.interface") }]) }] }]);
  return ji(() => {
    C.init();
  }), (M, F) => (wt(), Xt("div", wA, [Pt("div", CA, [Pt("div", SA, [(wt(true), Xt(Hr, null, fn(P.value, (D) => (wt(), Tr(J(Xa), { id: "appearance", key: D.title, title: M.$t(`settings.${D.title}.title`) }, { default: Ne(() => [$e(J(dp), null, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(D.items, (A) => (wt(), Tr(J(hp), { key: A.title }, { default: Ne(() => [Pt("div", kA, [$e(J(UP), { style: { "white-space": "nowrap" }, tooltip: { trigger: l.value ? "click" : "hover" } }, { tooltip: Ne(() => [Pr(ur(A.items ? M.$t(`settings.${D.title}.${A.title}.title`) : M.$t(`settings.${D.title}.${A.title}`)), 1)]), default: Ne(() => [Pr(ur(A.items ? M.$t(`settings.${D.title}.${A.title}.title`) : M.$t(`settings.${D.title}.${A.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), A.type === "radio" ? (wt(), Xt("div", PA, [f.value ? (wt(), Tr(J(bg), { key: 1, value: J(C).settings[A.title], "onUpdate:value": (O) => J(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (wt(), Tr(J(NP), { key: 0, value: J(C).settings[A.title], "onUpdate:value": (O) => J(C).settings[A.title] = O }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(A.items, (O) => (wt(), Tr(J(BP), { key: O.value, value: O.value, label: O.label, checked: J(C).settings[A.title] === O.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : A.type === "select" ? (wt(), Xt("div", TA, [$e(J(bg), { value: J(C).settings[A.title], "onUpdate:value": (O) => J(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : A.type === "checkbox" ? (wt(), Xt("div", IA, [$e(J(Yb), { value: J(C).settings[A.title], "onUpdate:value": (O) => J(C).settings[A.title] = O }, null, 8, ["value", "onUpdate:value"])])) : jr("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), g.value ? jr("", true) : (wt(), Xt("div", MA, [$e(J(Pb), { "show-rail": true, style: { width: "128px" } }, { default: Ne(() => [(wt(true), Xt(Hr, null, fn(P.value, (D) => (wt(), Tr(J($f), { key: D.title, title: M.$t(`settings.${D.title}.title`), href: `#${D.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), K1 = Qn(EA, [["__scopeId", "data-v-eb834239"]]), RA = Object.freeze(Object.defineProperty({ __proto__: null, default: K1 }, Symbol.toStringTag, { value: "Module" })), LA = hC({ history: fC("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: _f() ? C1 : () => yf(() => Promise.resolve().then(() => T4), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: _f() ? S1 : () => yf(() => Promise.resolve().then(() => bM), void 0, import.meta.url) }, { path: "/about", name: "about", component: _f() ? Y1 : () => yf(() => Promise.resolve().then(() => xA), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: _f() ? K1 : () => yf(() => Promise.resolve().then(() => RA), void 0, import.meta.url) }] });
export {
  LA as default
};
